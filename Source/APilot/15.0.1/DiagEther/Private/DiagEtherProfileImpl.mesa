-- File: DiagEtherProfileImpl.mesa - last edit:-- KXW                    6-Apr-87 12:04:32-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.-- To relase the Ethernet Diagnostics with Pilot, Services and Mesa related portions are commented out.-- They are indicated by :-- * Profile * --DIRECTORY  Auth USING [--*Flavor, *-- FreeIdentity, IdentityHandle --*, MakeIdentity*--],  DiagEtherProfile USING [],  DiagEtherPromptMsgs USING [prompts],  Heap USING [systemZone],  --*NSName USING [maxDomainLength, maxLocalLength, maxOrgLength, NameRecord, String],  --*NSString USING [String, StringFromMesaString],  OfflineDiagInterface USING [GetAHelpText, GetAString, HelpText],  --*Profile USING [Qualification],  String USING [--*AppendChar, AppendString, AppendSubString, CopyToNewString,     --*FreeString, Length, *-- MakeString--*, SubStringDescriptor*--];DiagEtherProfileImpl: PROGRAM   IMPORTS Auth, DiagEtherPromptMsgs, Heap, --*NSString,-- String, OfflineDiagInterface  EXPORTS DiagEtherProfile --*, Profile*-- =  BEGIN OPEN     DiagEtherPromptMsgs,    ODI: OfflineDiagInterface;  cmFile: LONG STRING ¬ NIL;  fileName: LONG STRING ¬ NIL;  userName: PUBLIC LONG STRING ¬ NIL;  userPassword: PUBLIC LONG STRING ¬ NIL;  domainName: LONG STRING ¬ NIL;  orgName: LONG STRING ¬ NIL;  strong, simple: Auth.IdentityHandle ¬ NIL;    InitializeProfile: PUBLIC PROCEDURE = {    -- This procedure should be called by DiagEtherTestsImpl.RunEthernetTests.    -- Though ODI.DiagHeap will be destroied when user attempt to exit from ethenret test,    -- simple and strong will be left unchanged and not FREEed from ODI.DiagHeap.    -- This will cause AddressFault when user reenter the ethernet test because simple and strong    -- have trushed values.     simple _ NIL;    strong _ NIL;    InitStrings[];    };  LoginCmd: PUBLIC PROC = {    help: LONG POINTER TO ODI.HelpText;        help _ ODI.GetAHelpText[1];    help.textBody[0] _ prompts[userNameExpl];    userName _ ODI.GetAString[prompt: prompts[userName], defaultString: IF userName.length = 0 THEN NIL ELSE userName, help: help];   « help.textBody[0] _ prompts[domainExpl];    domainName _ ODI.GetAString[prompt: prompts[domain], help: help];    help.textBody[0] _ prompts[orgExpl];    orgName _ ODI.GetAString[prompt: prompts[organization], help: help];»    help.textBody[0] _ prompts[passwordExpl];    userPassword _ ODI.GetAString[prompt: prompts[password], help: help, echoWithStar: TRUE];    IF simple # NIL THEN Auth.FreeIdentity[@simple, Heap.systemZone];    IF strong # NIL THEN Auth.FreeIdentity[@strong, Heap.systemZone];    --* simple ¬ MakeID[flavor: simple];    --* strong ¬ MakeID[flavor: strong]    };  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- String/Credentials Commands  -- Followings are stolen from OthelloFetchImpl to EXPORT to Profile.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    --*    «S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {     RETURN[NSString.StringFromMesaString[s]]};  GetDefaultDomain: PUBLIC PROC [proc: PROC [LONG STRING]] = {    proc[domainName]};  GetDefaultOrganization: PUBLIC PROC [proc: PROC [LONG STRING]] = {    proc[orgName]};    GetID: PUBLIC PROC [    flavor: Auth.Flavor, proc: PROC [id: Auth.IdentityHandle]] =    BEGIN    SELECT flavor FROM      simple => proc[simple];      strong => proc[strong];      ENDCASE => ERROR;    END;  SetDefaultDomain: -- Profile--PUBLIC PROC[domain: LONG STRING] = {    domainName _ String.CopyToNewString[domain, Heap.systemZone]};      SetDefaultOrganization: -- Profile--PUBLIC PROC[organization: LONG STRING] = {    orgName _ String.CopyToNewString[organization, Heap.systemZone]};      Qualify: --Profile--PUBLIC PROC [    token, newToken: LONG STRING,    qualification: Profile.Qualification ¬ clearinghouse] = {    namePart: CARDINAL ¬ String.Length[token];    currentQual: Profile.Qualification ¬ none;    octalAddress: BOOLEAN ¬ TRUE; -- only '0..'7 and '# allowed    ss: String.SubStringDescriptor;    chChar: CHARACTER = ':;    regChar: CHARACTER = '.;    IF String.Length[token] = 0 THEN RETURN;    FOR i: CARDINAL IN [0..token.length) DO       SELECT token[i] FROM         regChar => {namePart ¬ i; currentQual ¬ registry};  -- look for last dot	 chChar => {namePart ¬ i; currentQual ¬ clearinghouse; EXIT}; -- first :	 IN['0..'7], '# => NULL;	 ENDCASE => octalAddress ¬ FALSE;       ENDLOOP;    IF currentQual = qualification OR octalAddress THEN {      String.AppendString[newToken, token]; RETURN};    ss ¬ [base: token, offset: 0, length: namePart];    String.AppendSubString[newToken, @ss];    SELECT qualification FROM      none => NULL;    <<registry =>        IF String.Length[defaultRegistry] > 0 THEN {	  String.AppendChar[newToken, regChar];	  String.AppendString[newToken, defaultRegistry]};>>      clearinghouse =>        IF String.Length[domainName] > 0 OR 	   String.Length[orgName] > 0 THEN {	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, domainName];	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, orgName]};      ENDCASE};      GetName: PROCEDURE[prompt: LONG STRING, help: LONG POINTER TO ODI.HelpText, dest: LONG POINTER TO LONG STRING, password: BOOLEAN _ FALSE] = {    str: LONG STRING _ String.MakeString[Heap.systemZone, NSName.maxLocalLength];        str _ ODI.GetAString[prompt: prompt, help: help, echoWithStar: password];    dest­ _ String.CopyToNewString[str, Heap.systemZone];    String.FreeString[Heap.systemZone, str];    };      MakeID: PROC [flavor: Auth.Flavor] RETURNS [id: Auth.IdentityHandle] = {    myName: NSName.NameRecord ¬ [      org: S[orgName], domain: S[domainName], local: S[userName]];    id ¬ Auth.MakeIdentity[      myName: @myName,      password: S[userPassword],      z: Heap.systemZone,      style: flavor,      dontCheck: TRUE]};»  InitStrings: PROCEDURE = {    IF userName = NIL THEN userName _ String.MakeString[Heap.systemZone, 40 --*NSName.maxLocalLength*--];    IF domainName = NIL THEN domainName _ String.MakeString[Heap.systemZone, 20 --*NSName.maxDomainLength*--];    IF orgName = NIL THEN orgName _ String.MakeString[Heap.systemZone, 20 --*NSName.maxOrgLength*--];    IF userPassword = NIL THEN userPassword _ String.MakeString[Heap.systemZone, 40 --*NSName.maxLocalLength*--];    };  -- Main Line  InitStrings[];  END...LOGtime	by	action21-Feb-85 16:24:39	MXT	Created.23-Feb-85 14:57:22	MXT	Added LogInCmd. 1-Mar-85 16:00:51	MXT	Added InitializeProfile.10-Mar-85 14:55:59	MXT	Removed Domaina and Organization from LoginCmd.21-Mar-85 12:54:23	MXT	Added default userName in LoginCmd.15-May-85 18:56:59	MXT	Changed 6-Apr-87 12:04:30	KXW	Fixed duplicated storage allocartion for strings.
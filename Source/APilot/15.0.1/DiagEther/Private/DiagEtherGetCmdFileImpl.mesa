-- File: DiagEtherGetCmdFileImpl.mesa - last edit:-- MXT                 29-Jan-86 18:45:16-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.-- To release the Ethernet Diagnostics with Pilot stuff, DiagEtherAddressTranslation is renamed to -- DiagEtherDiagEtherAddressTranslation.-- When Diagnostics release become independent from Pilot/Mesa, the DiagEtherDiagEtherAddressTranslation-- should be resumed to use DiagEtherAddressTranslation interface.DIRECTORY  DiagEtherAddressTranslation USING [Error, StringToHostNumber],  DiagEtherCmdDes USING [CmdDescriptArray],  DiagEtherCmdDrive USING [configParams, ConfigureParametersRec, Initialize, maxTryCount, minTryCount],  DiagEtherErrorMsgs USING [errors],  DiagEtherGetCmdFile USING [],  DiagEtherIOCmdMsgs USING [ioCmdMsgs],  DiagEtherPromptMsgs USING [prompts, Prompts],  DiagEtherPutErrorMsgs USING [PutErrorMsgs],  DiagEtherTests USING [Switch],  EthernetHardFaceDove USING [multicastIDLimit],  Format USING [HostNumber, Number, NumberFormat, StringProc],  HostNumbers USING [HostNumber, nullHostNumber],  Inline USING [HighByte, HighHalf, LowByte, LowHalf],  OfflineDiagInterface USING [AbortCurrentTest, AnOptionLine, DiagHeap, GetAHelpText,     GetAnOption, GetAnOptionLine, GetAnOptionsRecord, GetANumber, GetAString, GetYesNo,     HelpText, HitAnyKeyToContinue, OptionsRecord, PutData, PutMessage],  OfflineDiagTTYDove USING [rightEdge],  Runtime,  String USING [AppendChar, AppendNumber, AppendString, CopyToNewString, MakeString];DiagEtherGetCmdFileImpl: PROGRAM  IMPORTS     DiagEtherAddressTranslation, DiagEtherCmdDes, DiagEtherCmdDrive, DiagEtherErrorMsgs,    DiagEtherIOCmdMsgs, DiagEtherPromptMsgs, DiagEtherPutErrorMsgs,DiagEtherTests,     Format, Inline, OfflineDiagInterface, OfflineDiagTTYDove, Runtime, String  EXPORTS DiagEtherGetCmdFile =  BEGIN OPEN    DiagEtherIOCmdMsgs,    DiagEtherPromptMsgs,    DiagEtherErrorMsgs,    CmdDes: DiagEtherCmdDes,    CmdDrive: DiagEtherCmdDrive,    HardFace: EthernetHardFaceDove,    ODI: OfflineDiagInterface;  -- =================      -- TYPE.  -- =================      ShowCmdsProcType: TYPE = PROCEDURE[str: LONG STRING];  -- =================      -- PUBLIC variables.  -- =================      commandArrayIndex: PUBLIC CARDINAL;  commandArray:	PUBLIC ARRAY [0..256) OF CARDINAL¬ ALL[0];  -- ================      -- Grobal Variables  -- ================  repaintOptions: BOOLEAN ¬ TRUE;  inCmdChain:		BOOLEAN;--  NeedsDataOpr:		BOOLEAN;  StartedLogging:	BOOLEAN;  StartedTracing:	BOOLEAN;  InLoop:		BOOLEAN;  GotAParameter:	BOOLEAN;--  StatusToDisplay:	BOOLEAN;  singleBuff:		BOOLEAN;  maxReadBuffs:		CARDINAL¬ 2;  endOfCommandFile: BOOLEAN;  tempStr:		LONG STRING¬ [256];    -- ================      -- PUBLIC PROCEDURE  -- ================        GetCommandFile: PUBLIC PROCEDURE = {    ShowProc: ShowCmdsProcType = {ODI.PutData[str]};    helpPtr: LONG POINTER TO ODI.HelpText;    n: CARDINAL;    cmdRecPtr: LONG POINTER TO ODI.OptionsRecord;        commandArrayIndex	¬ 0;    commandArray		¬ ALL[0];    endOfCommandFile	¬ FALSE;    GotAParameter		¬ FALSE;    inCmdChain		¬ FALSE;    StartedLogging		¬ FALSE;    InLoop			¬ FALSE;    StartedTracing		¬ FALSE;    repaintOptions ¬ TRUE;    helpPtr ¬ ODI.GetAHelpText[1];    helpPtr.textBody[0] ¬ ioCmdMsgs[enterChoiceNumExpl];        cmdRecPtr ¬ DisplayCommandOptions[];    UNTIL endOfCommandFile DO      n ¬ ODI.GetAnOption[	optionTable: IF repaintOptions THEN cmdRecPtr ELSE NIL,	optionPrompt: prompts[command],	optionHelp: helpPtr];      IF repaintOptions THEN ShowCmds[ShowProc];      repaintOptions ¬ FALSE;      DecipherCommand[index: n-1];      --cmdRecPtr ¬ NIL;    ENDLOOP;      -- For testing.    IF DiagEtherTests.Switch[21] THEN {      index: CARDINAL ¬ 0;      cnt: CARDINAL ¬ 0;      UNTIL CmdDes.CmdDescriptArray[index].setEndOfCommandFile=TRUE DO        index ¬ index+1;      ENDLOOP;      tempStr.length ¬ 0;      String.AppendString[tempStr, "["];      UNTIL commandArray[cnt]=index DO        String.AppendNumber[tempStr, commandArray[cnt]];        String.AppendString[tempStr, ","];        cnt ¬ cnt+1;      ENDLOOP;      String.AppendNumber[tempStr, commandArray[cnt]];      String.AppendString[tempStr, "]"];      ODI.PutMessage[message: tempStr,		    clearMessageAreaFirst: TRUE];      ODI.HitAnyKeyToContinue[beep: FALSE];      };    }; --GetCmdFile-- Private PROCEDUREs  DisplayCommandOptions: PROCEDURE RETURNS[LONG POINTER TO ODI.OptionsRecord] = {    cmdStringLength:	CARDINAL ¬ 0;    numberOfLines:	CARDINAL;    count:		CARDINAL ¬ 0;    lastLineEntries:	CARDINAL;    lineCount:		CARDINAL;    optionsPerLine:	CARDINAL;    cmdRcrdPtr:	LONG POINTER TO ODI.OptionsRecord;    optionLinePtr:	LONG POINTER TO ODI.AnOptionLine;    selectionNumber:	CARDINAL;    rightEdge: CARDINAL = OfflineDiagTTYDove.rightEdge;    --get options per line    cmdStringLength ¬ 0;    count ¬ 0;    UNTIL count= LENGTH[CmdDes.CmdDescriptArray] DO      IF CmdDes.CmdDescriptArray[count].commandName.length > cmdStringLength THEN	cmdStringLength¬ CmdDes.CmdDescriptArray[count].commandName.length;      count ¬ count + 1;    ENDLOOP;    cmdStringLength ¬ cmdStringLength + 6; -- add the selection number    optionsPerLine ¬ rightEdge/cmdStringLength;    numberOfLines ¬ LENGTH[CmdDes.CmdDescriptArray]/optionsPerLine;    lastLineEntries ¬ LENGTH[CmdDes.CmdDescriptArray] MOD optionsPerLine;    IF lastLineEntries > 0 THEN numberOfLines ¬ numberOfLines + 1 ELSE      lastLineEntries ¬ optionsPerLine;    cmdRcrdPtr ¬  ODI.GetAnOptionsRecord[numberOfLines: numberOfLines];    cmdRcrdPtr.optionMenuTiTle ¬ ioCmdMsgs[commandS];    lineCount ¬ 0;    UNTIL lineCount = numberOfLines DO      IF lineCount = numberOfLines-1 THEN	optionsPerLine ¬ lastLineEntries;      optionLinePtr ¬ ODI.GetAnOptionLine [optionsPerLine: optionsPerLine];      count ¬ 0;      cmdRcrdPtr.linesOfOptions[lineCount] ¬ optionLinePtr;      count ¬ 0;      UNTIL count= optionsPerLine DO	selectionNumber ¬ (count*numberOfLines)+(lineCount); 	IF selectionNumber>=LENGTH[CmdDes.CmdDescriptArray] THEN EXIT;	optionLinePtr.optionsOnALine[count].position ¬ count*cmdStringLength + 1;	optionLinePtr.optionsOnALine[count].selectionNumberForThisItem ¬	  selectionNumber + 1;	optionLinePtr.optionsOnALine[count].option¬	  CmdDes.CmdDescriptArray[selectionNumber].commandName;	optionLinePtr.optionsOnALine[count].helpForThisOption¬	  CmdDes.CmdDescriptArray[selectionNumber].explanation;	count¬ count + 1;      ENDLOOP;      lineCount¬ lineCount + 1;    ENDLOOP;    RETURN [cmdRcrdPtr]    }; -- of DisplayCommandOptions  DecipherCommand: PROCEDURE [index: CARDINAL] = {    -- =================    -- Nested procedure.    -- =================      UpdateArrayAndDisplay: PROCEDURE [index: CARDINAL] =         BEGIN	commandArray [commandArrayIndex] ¬ index;	commandArrayIndex ¬ commandArrayIndex + 1;	ODI.PutData [data: CmdDes.CmdDescriptArray[index].commandName,		     startWithNewLine: FALSE];	END; --UpdateArrayAndDisplay    -- =================        -- First check for all the error conditions    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      -- check for error logging command errors    IF CmdDes.CmdDescriptArray[index].setStartLogging AND StartedLogging THEN {      ODI.PutMessage [        message: errors[allreadyLoggingErrs],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };    IF CmdDes.CmdDescriptArray[index].resetStartLogging AND NOT StartedLogging THEN {      ODI.PutMessage [        message: errors[notLoggingErrs],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };        -- check for tracing command errors    IF CmdDes.CmdDescriptArray[index].setTracing AND StartedTracing THEN {      ODI.PutMessage [        message: errors[allreadyTracingCmd],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };    IF CmdDes.CmdDescriptArray[index].resetTracing AND NOT StartedTracing THEN {      ODI.PutMessage [        message: errors[notTracingCmds],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };          -- check for looping errors    IF CmdDes.CmdDescriptArray[index].setLooping AND InLoop THEN {      ODI.PutMessage [        message: errors[allreadyInLoop],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };    IF CmdDes.CmdDescriptArray[index].resetLooping AND NOT InLoop THEN {      ODI.PutMessage [        message: errors[notLooping],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };          -- check for end of command file errors    IF CmdDes.CmdDescriptArray[index].setEndOfCommandFile AND InLoop THEN {      ODI.PutMessage [        message: errors[notAllowedInLoop],        beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN      };    --now set/reset desired booleans    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      IF CmdDes.CmdDescriptArray[index].setStartOfCmdChain THEN inCmdChain¬ TRUE;    IF CmdDes.CmdDescriptArray[index].getParamsCmd THEN inCmdChain¬ FALSE;        IF CmdDes.CmdDescriptArray[index].setStartLogging THEN StartedLogging¬ TRUE;    IF CmdDes.CmdDescriptArray[index].resetStartLogging THEN StartedLogging¬ FALSE;        IF CmdDes.CmdDescriptArray[index].setTracing THEN StartedTracing¬ TRUE;    IF CmdDes.CmdDescriptArray[index].resetTracing THEN StartedTracing¬ FALSE;        IF CmdDes.CmdDescriptArray[index].setLooping THEN InLoop¬ TRUE;    IF CmdDes.CmdDescriptArray[index].resetLooping THEN InLoop¬ FALSE;        IF CmdDes.CmdDescriptArray[index].setEndOfCommandFile THEN endOfCommandFile¬ TRUE;    -- now update the command array and the display with the command    UpdateArrayAndDisplay [index: index];    -- now get the required parameters    IF CmdDes.CmdDescriptArray[index].needLoopCount THEN GetLoopCount [];    IF CmdDes.CmdDescriptArray[index].needDelay THEN GetDelay [];    IF CmdDes.CmdDescriptArray[index].needUseSameDataBuff THEN GetIfUseSameDataBuff [];    IF CmdDes.CmdDescriptArray[index].needTryCount THEN GetTryCount [];     IF CmdDes.CmdDescriptArray[index].needData	 THEN GetData [];    IF CmdDes.CmdDescriptArray[index].needFrameLength	 THEN GetFrameLength [];    -- 82586 parameters setup.    IF CmdDes.CmdDescriptArray[index].needDestinationID THEN GetDestinationID[];    --IF CmdDes.CmdDescriptArray[index].needByteCount THEN GetByteCount[];    IF CmdDes.CmdDescriptArray[index].needMulticastID THEN GetMultiCastID[];    IF CmdDes.CmdDescriptArray[index].needConfigureParams THEN GetConfigureParams[];    IF GotAParameter THEN {      tempStr.length¬ 0;      String.AppendChar[tempStr, 10C]; --delete the space after the comma      String.AppendChar[tempStr, 10C]; --delete the comma      String.AppendString[tempStr, ioCmdMsgs[paramEnd]]; --append "];"      ODI.PutData[data: tempStr]; --output the string      GotAParameter¬ FALSE;      };    }; -- of DecipherCommand.        GetLoopCount: PROCEDURE = {      helpTextPtr:	LONG POINTER TO ODI.HelpText;            helpTextPtr  ¬ ODI.GetAHelpText[numberOfLines: 1];      helpTextPtr.textBody[0]¬ prompts[loopCntExpl];            GetParameter[        prompt: prompts[loopCnt],	minNumber: 1,	maxNumber: 65535,	explanation: helpTextPtr,	getPlusOrMinus: FALSE];      };        GetByteCount: PROCEDURE = {      helpTextPtr:	LONG POINTER TO ODI.HelpText;            helpTextPtr  ¬ ODI.GetAHelpText[numberOfLines: 1];      helpTextPtr.textBody[0]¬ prompts[getByteCountExpl];      GetParameter[        prompt: prompts[getByteCount],	minNumber: 0,	maxNumber: HardFace.multicastIDLimit * 6,	explanation: helpTextPtr];      };    GetFrameLength: PROCEDURE = {      helpTextPtr:	LONG POINTER TO ODI.HelpText;            helpTextPtr  ¬ ODI.GetAHelpText[numberOfLines: 1];      helpTextPtr.textBody[0]¬ prompts[getByteCountExpl];      GetParameter[        prompt: prompts[getByteCount],	minNumber: 0,	maxNumber: 16383,	explanation: helpTextPtr];      };    GetDestinationID: PROCEDURE = {      helpTextPtr:	LONG POINTER TO ODI.HelpText;            helpTextPtr  ¬ ODI.GetAHelpText[numberOfLines: 4];      helpTextPtr.textBody[0]¬ prompts[getDestIDExpl0];      helpTextPtr.textBody[1]¬ prompts[getDestIDExpl1];      helpTextPtr.textBody[2]¬ prompts[getDestIDExpl2];      helpTextPtr.textBody[3]¬ prompts[getDestIDExpl3];      GetHostNumber[        prompt: prompts[getDestID],	explanation: helpTextPtr];      };    GetMultiCastID: PROCEDURE = {      helpTextPtr:	LONG POINTER TO ODI.HelpText;      bytes: CARDINAL;            GetByteCount[];      bytes ¬ commandArray [commandArrayIndex - 1];            helpTextPtr  ¬ ODI.GetAHelpText[numberOfLines: 1];      helpTextPtr.textBody[0]¬ prompts[getMultiCastIDExpl];      FOR i: CARDINAL IN [0..HardFace.multicastIDLimit) DO        GetHostNumber[          prompt: prompts[getMultiCastID],	  explanation: helpTextPtr];	ENDLOOP;      };    GetConfigureParams: PROCEDURE = {      -- This procedure will show the option sheet to setup configure parameters.      -- 82586's configure command can set up some parameters. The length of parameter list      -- is between 4 and 12 bytes. If client specifies more than 12 bytes of parameters,      -- the first 12 bytes are valid.            -- ~~~~~~~~~~~~~~~~~~~      -- Nested Procedure      -- ~~~~~~~~~~~~~~~~~~~      SetParams: PROCEDURE[n: CARDINAL] = {	name: DiagEtherPromptMsgs.Prompts;		l, c: CARDINAL;	c ¬ (n-1)/numberOfLines;	l ¬ (n-1) MOD numberOfLines;		name ¬ VAL[n + DiagEtherPromptMsgs.Prompts.configureParams.ORD];		SELECT name FROM	  saveBadFrames => paramRecPtr.saveBadFrames ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.saveBadFrames];	  syncReady => paramRecPtr.syncReady ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.syncReady];	  externalLoopback => paramRecPtr.externalLoopback ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.externalLoopback];	  internalLoopback => paramRecPtr.internalLoopback ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.internalLoopback];	  padding => paramRecPtr.padding ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.padding];	  bitstuffing => paramRecPtr.bitstuffing ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.bitstuffing];	  CRC16 => paramRecPtr.CRC16 ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.CRC16];	  noCRCInsertion => paramRecPtr.noCRCInsertion ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.noCRCInsertion];	  txNoCRS => paramRecPtr.txNoCRS ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.txNoCRS];	  NRZEncoding => paramRecPtr.NRZEncoding ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.NRZEncoding];	  broadcastDisable => paramRecPtr.broadcastDisable ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.broadcastDisable];	  promiscuousMode => paramRecPtr.promiscuousMode ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.promiscuousMode];	  internalCDT => paramRecPtr.internalCDT ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.internalCDT];	  internalCRS => paramRecPtr.internalCRS ¬ ODI.GetYesNo[	    prompt: prompts[name], defaultSpecified: TRUE,	    default: paramRecPtr.internalCRS];	  fifoLimit => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 15,	      defaultNumber: paramRecPtr.fifoLimit];	    paramRecPtr.fifoLimit ¬ LOOPHOLE[num]};	  retryNumber => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 15,	      defaultNumber: paramRecPtr.retryNumber];	    paramRecPtr.retryNumber ¬ LOOPHOLE[num]};	  preambleLength => {	    i: CARDINAL;	    ok: BOOLEAN ¬ FALSE;	    UNTIL ok DO	      [number: i] ¬ ODI.GetANumber[		prompt: prompts[name],		lowLimit: 0, upperLimit: 16,		defaultNumber: 2 -- eight --];	      ok ¬ TRUE;	      SELECT i FROM		2 => paramRecPtr.preambleLength ¬ two; 		4 => paramRecPtr.preambleLength ¬ four; 		8 => paramRecPtr.preambleLength ¬ eight; 		16 => paramRecPtr.preambleLength ¬ sixteen; 		ENDCASE => {ok ¬ FALSE;		  ODI.PutMessage[prompts[preambleLengthExpl]];};	    ENDLOOP;	    };	  addrTypeLoc => {	    default: BOOLEAN ¬ IF paramRecPtr.addrTypeLoc = buffer THEN TRUE ELSE FALSE;	    helpText.textBody[0] ¬ prompts[getAddrTypeLocExpl1];	    helpText.textBody[1] ¬ prompts[getAddrTypeLocExpl2];	    paramRecPtr.addrTypeLoc ¬ IF ODI.GetYesNo[		prompt: prompts[getAddrTypeLoc], help: helpText,		defaultSpecified: TRUE, default: default] 	      THEN buffer ELSE desc};	  expBackoffMethod => {	    default: BOOLEAN ¬ IF paramRecPtr.expBackoffMethod = ethernet THEN TRUE ELSE FALSE;	    helpText.textBody[0]¬ prompts[getExpBackoffMethodExpl1];	    helpText.textBody[1]¬ prompts[getExpBackoffMethodExpl2];	    paramRecPtr.expBackoffMethod ¬ IF ODI.GetYesNo[	      prompts[getExpBackoffMethod], helpText, TRUE, default] THEN ethernet ELSE alternate};	  addrLength => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 7,	      defaultNumber: paramRecPtr.addrLength];	    paramRecPtr.addrLength ¬ LOOPHOLE[num]};	  accContRes => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 7,	      defaultNumber: paramRecPtr.accContRes];	    paramRecPtr.accContRes ¬ LOOPHOLE[num]};	  linearPriority => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 7,	      defaultNumber: paramRecPtr.linearPriority];	    paramRecPtr.linearPriority ¬ LOOPHOLE[num]};	  CDTFilter => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 7,	      defaultNumber: paramRecPtr.CDTFilter];	    paramRecPtr.CDTFilter ¬ LOOPHOLE[num]};	  CRSFilter => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 7,	      defaultNumber: paramRecPtr.CRSFilter];	    paramRecPtr.CRSFilter ¬ LOOPHOLE[num]};	  interframeSpacing => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 255,	      defaultNumber: paramRecPtr.interframeSpacing];	    paramRecPtr.interframeSpacing ¬ LOOPHOLE[num]};	  minFrameLength => {	    num: CARDINAL;	    [number: num] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 255,	      defaultNumber: paramRecPtr.minFrameLength];	    paramRecPtr.minFrameLength ¬ LOOPHOLE[num]};	  slotTime => {	    slotTime: CARDINAL;	    [number: slotTime] ¬ ODI.GetANumber[	      prompt: prompts[name],	      lowLimit: 0, upperLimit: 2047,	      defaultNumber: 512];	    paramRecPtr.slotTimeLow ¬ Inline.LowByte[slotTime];	    paramRecPtr.slotTimeHigh ¬ Inline.HighByte[slotTime]};	  ENDCASE => quit ¬ TRUE;	parameterItems.linesOfOptions[l].optionsOnALine[c].option ¬ GetConfigNameString[name];	};		-- ~~~~~~~~~~~~~~~~~~~~~~~	-- End of Nested procedure	-- ~~~~~~~~~~~~~~~~~~~~~~~            paramRecPtr: LONG POINTER TO CmdDrive.ConfigureParametersRec;      parameterItems: LONG POINTER TO ODI.OptionsRecord;      optionLinePtr:	LONG POINTER TO ODI.AnOptionLine;      helpText: LONG POINTER TO ODI.HelpText ¬ ODI.GetAHelpText[2];      cmdStringLength:	CARDINAL ¬ 0;      numberOfLines:	CARDINAL;      count:		CARDINAL ¬ 0;      lastLineEntries:	CARDINAL;      optionsPerLine:	CARDINAL;      quit: BOOLEAN ¬ FALSE;      first: BOOLEAN ¬ TRUE;      n: CARDINAL ¬ 0;      length: CARDINAL ¬ 0;      commandName: DiagEtherPromptMsgs.Prompts;      repaintOptions ¬ TRUE;      IF CmdDrive.configParams = NIL THEN CmdDrive.Initialize[];      paramRecPtr ¬ CmdDrive.configParams;            -- Get longest string length.      FOR i: DiagEtherPromptMsgs.Prompts IN [fifoLimit..exitFromSetConfigMode] DO        IF prompts[i].length>cmdStringLength THEN cmdStringLength ¬ prompts[i].length;	length ¬ length + 1;      ENDLOOP;      cmdStringLength ¬ cmdStringLength + prompts[descriptor].length + 1;      numberOfLines ¬ 10;      lastLineEntries ¬ 2;      optionsPerLine ¬ 3;      parameterItems ¬ ODI.GetAnOptionsRecord[numberOfLines];      parameterItems.optionMenuTiTle ¬ prompts[configureParams];            BEGIN      itemPtr: CARDINAL = DiagEtherPromptMsgs.Prompts.fifoLimit.ORD;      helpPtr: CARDINAL = DiagEtherPromptMsgs.Prompts.fifoLimitExpl.ORD;      offset: CARDINAL ¬ numberOfLines;      optionsPerLine: CARDINAL;            FOR i: CARDINAL IN [0..numberOfLines) DO        optionsPerLine ¬ IF VAL[i + 2 * offset + itemPtr] IN [DiagEtherPromptMsgs.Prompts.fifoLimit..DiagEtherPromptMsgs.Prompts.exitFromSetConfigMode] THEN 3 ELSE 2;	optionLinePtr ¬ ODI.GetAnOptionLine[optionsPerLine];		FOR j: CARDINAL IN [0..optionsPerLine) DO	  commandName ¬ VAL[j * offset + i + itemPtr];	  optionLinePtr[j].position ¬ j*cmdStringLength + 1;	  optionLinePtr[j].selectionNumberForThisItem ¬ j * offset + i + 1;	  optionLinePtr[j].option ¬ GetConfigNameString[commandName];	  commandName ¬ VAL[j * offset + i + helpPtr];	  optionLinePtr[j].helpForThisOption ¬ prompts[commandName];	ENDLOOP;	parameterItems.linesOfOptions[i] ¬ optionLinePtr;      ENDLOOP;      END;      UNTIL quit DO        ENABLE ODI.AbortCurrentTest => {quit ¬ TRUE; CONTINUE};	        n ¬ ODI.GetAnOption[	  optionTable: IF first THEN parameterItems ELSE NIL,	  optionPrompt: prompts[command]];	  	SetParams[n];      ENDLOOP;            -- Store long (double word) pointer to commandArray.      commandArray[commandArrayIndex] ¬ Inline.HighHalf[paramRecPtr];      commandArrayIndex ¬ commandArrayIndex + 1;      commandArray[commandArrayIndex] ¬ Inline.LowHalf[paramRecPtr];      commandArrayIndex ¬ commandArrayIndex + 1;      GotAParameter ¬ TRUE;      }; -- of GetConfigureParams.    GetConfigNameString: PROCEDURE[cmd: DiagEtherPromptMsgs.Prompts] RETURNS[LONG STRING] = {      str: LONG STRING ¬ String.MakeString[ODI.DiagHeap, 256];      paramRecPtr: LONG POINTER TO CmdDrive.ConfigureParametersRec  ¬ CmdDrive.configParams;            str.length ¬ 0;      String.AppendString[to: str, from: prompts[cmd]];      SELECT cmd FROM          saveBadFrames => String.AppendString[to: str, 	    from: IF paramRecPtr.saveBadFrames THEN prompts[yes] ELSE prompts[no]];	  syncReady => String.AppendString[to: str, 	    from: IF paramRecPtr.syncReady THEN prompts[yes] ELSE prompts[no]];	  externalLoopback => String.AppendString[to: str, 	    from: IF paramRecPtr.externalLoopback THEN prompts[yes] ELSE prompts[no]];	  internalLoopback => String.AppendString[to: str, 	    from: IF paramRecPtr.internalLoopback THEN prompts[yes] ELSE prompts[no]];	  padding => String.AppendString[to: str, 	    from: IF paramRecPtr.padding THEN prompts[yes] ELSE prompts[no]];	  bitstuffing => String.AppendString[to: str, 	    from: IF paramRecPtr.bitstuffing THEN prompts[yes] ELSE prompts[no]];	  CRC16 => String.AppendString[to: str, 	    from: IF paramRecPtr.CRC16 THEN prompts[yes] ELSE prompts[no]];	  noCRCInsertion => String.AppendString[to: str, 	    from: IF paramRecPtr.noCRCInsertion THEN prompts[yes] ELSE prompts[no]];	  txNoCRS => String.AppendString[to: str, 	    from: IF paramRecPtr.txNoCRS THEN prompts[yes] ELSE prompts[no]];	  NRZEncoding => String.AppendString[to: str, 	    from: IF paramRecPtr.NRZEncoding THEN prompts[yes] ELSE prompts[no]];	  broadcastDisable => String.AppendString[to: str, 	    from: IF paramRecPtr.broadcastDisable THEN prompts[yes] ELSE prompts[no]];	  promiscuousMode => String.AppendString[to: str, 	    from: IF paramRecPtr.promiscuousMode THEN prompts[yes] ELSE prompts[no]];	  internalCDT => String.AppendString[to: str, 	    from: IF paramRecPtr.internalCDT THEN prompts[yes] ELSE prompts[no]];	  internalCRS => String.AppendString[to: str, 	    from: IF paramRecPtr.internalCRS THEN prompts[yes] ELSE prompts[no]];	  fifoLimit => String.AppendNumber[s: str, n: paramRecPtr.fifoLimit, radix: 10];	  retryNumber => String.AppendNumber[s: str, n: paramRecPtr.retryNumber, radix: 10];	  preambleLength => {String.AppendNumber[s: str, 	    n: SELECT paramRecPtr.preambleLength FROM	      two => 2, four => 4, eight => 8, ENDCASE => 16, 	    radix: 10];	    };	  addrTypeLoc => 	    String.AppendString[to: str, 	      from: IF paramRecPtr.addrTypeLoc=buffer THEN prompts[buffer] ELSE prompts[descriptor]];	  expBackoffMethod => String.AppendString[to: str, 	      from: IF paramRecPtr.expBackoffMethod=ethernet THEN prompts[ethernet] ELSE prompts[alternate]];	  addrLength => String.AppendNumber[s: str, n: paramRecPtr.addrLength, radix: 10];	  accContRes => String.AppendNumber[s: str, n: paramRecPtr.accContRes, radix: 10];	  linearPriority => String.AppendNumber[s: str, n: paramRecPtr.linearPriority, radix: 10];	  CDTFilter => String.AppendNumber[s: str, n: paramRecPtr.CDTFilter, radix: 10];	  CRSFilter => String.AppendNumber[s: str, n: paramRecPtr.CRSFilter, radix: 10];	  interframeSpacing => String.AppendNumber[s: str, n: paramRecPtr.interframeSpacing, radix: 10];	  minFrameLength => String.AppendNumber[s: str, n: paramRecPtr.minFrameLength, radix: 10];	  slotTime => {	    num: CARDINAL;	    num ¬ paramRecPtr.slotTimeHigh * 256 + paramRecPtr.slotTimeLow;	    String.AppendNumber[s: str, n: num, radix: 10]};	  ENDCASE;	RETURN[String.CopyToNewString[str, ODI.DiagHeap]];	};    GetDelay: PROCEDURE = {      helpTextPtr:	LONG POINTER TO ODI.HelpText;            helpTextPtr  ¬ ODI.GetAHelpText[numberOfLines: 1];      helpTextPtr.textBody[0]¬ prompts[timeIncrementEquals];            GetParameter[        prompt: prompts[delayCnt],	minNumber: 1,	maxNumber: 65535,	explanation: helpTextPtr];      };    GetIfUseSameDataBuff: PROCEDURE = {      yes: BOOLEAN;            yes¬ ODI.GetYesNo[prompt: prompts[useSameDataBuffYN]];            ODI.PutData [data: prompts[useSameDataBuff]];      IF yes THEN {        ODI.PutData [data: prompts[yes]];        singleBuff¬ TRUE;}      ELSE {        ODI.PutData [data: prompts[no]];        singleBuff¬ FALSE;        };      ODI.PutData [data: ioCmdMsgs[paramSeparator]];            --update command array      IF yes THEN commandArray [commandArrayIndex]¬ 1 ELSE	commandArray [commandArrayIndex]¬ 0;      commandArrayIndex¬ commandArrayIndex+ 1;            GotAParameter¬ TRUE;      };  GetTryCount: PROCEDURE = {    helpTextPtr: LONG POINTER TO ODI.HelpText ¬ ODI.GetAHelpText[numberOfLines: 1];        tempStr.length¬ 0;    String.AppendString[tempStr, prompts[tryCntExpl]];    String.AppendNumber[tempStr, CmdDrive.minTryCount];    String.AppendString[tempStr, ioCmdMsgs[to]];    String.AppendNumber[tempStr, CmdDrive.maxTryCount];    helpTextPtr.textBody[0]¬ tempStr;        GetParameter[      prompt: prompts[tryCnt],      minNumber: CmdDrive.minTryCount,      maxNumber: CmdDrive.maxTryCount,      explanation: helpTextPtr];	    }; --GetTryCount  GetData: PROCEDURE = {    helpTextPtr: LONG POINTER TO ODI.HelpText;        helpTextPtr ¬ ODI.GetAHelpText[numberOfLines: 1];    helpTextPtr.textBody[0]¬ prompts[hexDataExpl];        GetParameter [      prompt:	prompts[hexData],      minNumber: 0,      maxNumber: LAST[CARDINAL],      dataInHex: FALSE,      explanation: helpTextPtr];	  }; --GetData  GetParameter: PROCEDURE [prompt: LONG STRING¬ NIL, dataInHex: BOOLEAN¬ FALSE, numWithin: BOOLEAN¬ TRUE,      minNumber: CARDINAL¬ 0, maxNumber: CARDINAL¬ 65535,      explanation: LONG POINTER TO ODI.HelpText ¬ NIL,      getPlusOrMinus: BOOLEAN¬ FALSE, plusOrMinusExpl: LONG POINTER TO ODI.HelpText ¬ NIL,      minModifier: CARDINAL¬ 0, maxModifier: CARDINAL¬ 65535] = {    S: Format.StringProc = {String.AppendString[to: str, from: s]};    str: LONG STRING¬ [20];    num: CARDINAL;    plus: BOOLEAN;    hexFormat: Format.NumberFormat = [base: 16, zerofill: TRUE];    str.length¬ 0;    [longNumber: , number: num, foreward: , numberInStringFormat: str]¬     ODI.GetANumber [       prompt: prompt,       numberIsHexadecimal: dataInHex,       lowLimit: minNumber,       upperLimit: maxNumber,       help: explanation];         -- diplay the entered number    ODI.PutData [data: prompt];    IF dataInHex THEN {str.length ¬ 0;      Format.Number[proc: S, n: num, format: hexFormat]};    ODI.PutData [data: str];	      -- update command array    commandArray [commandArrayIndex]¬ num;    commandArrayIndex¬ commandArrayIndex+ 1;          --get the +or- head number    IF InLoop AND getPlusOrMinus THEN    { str.length¬ 0;     [longNumber: , number: num, foreward: plus, numberInStringFormat: str]¬	ODI.GetANumber [	   prompt:	prompts[plusOrMinus],	   lowLimit:	minModifier,	   upperLimit:	maxModifier,	   help:		plusOrMinusExpl];         -- display the entered number including plus of minus     IF plus THEN ODI.PutData[data: ioCmdMsgs[plus]] ELSE       ODI.PutData[data: ioCmdMsgs[minus]];     ODI.PutData [data: str];            -- update command array      IF plus THEN commandArray [commandArrayIndex]¬ 1 ELSE	commandArray [commandArrayIndex]¬ 0;      commandArrayIndex¬ commandArrayIndex+ 1;      commandArray [commandArrayIndex]¬ num;      commandArrayIndex¬ commandArrayIndex+ 1;    };	     ODI.PutData[data: ioCmdMsgs[paramSeparator]];    GotAParameter¬ TRUE;  }; --GetParameter    GetHostNumber: PROCEDURE[prompt: STRING ¬ NIL, explanation: LONG POINTER TO ODI.HelpText ¬ NIL] = {    proc: Format.StringProc = {ODI.PutData[data: s]};    -- This procedure gets 48-bits Ethernet address.    string: LONG STRING ¬ [30];    --tempID: DiagEtherAddressTranslation.NetworkAddress;    id: HostNumbers.HostNumber;    idIsOk: BOOLEAN ¬ FALSE;        UNTIL idIsOk DO      ENABLE Runtime.UnboundProcedure, Runtime.ControlFault => {        IF string.length = 0 THEN {	  ODI.PutMessage[errors[invalidData]];	  };	idIsOk ¬ FALSE;	RETRY};	      -- get ID in string format.       string.length ¬ 0;      string ¬ ODI.GetAString[prompt: prompt, help: explanation];        idIsOk ¬ TRUE;      id ¬ LOOPHOLE[DiagEtherAddressTranslation.StringToHostNumber[string	! DiagEtherAddressTranslation.Error => {	    DiagEtherPutErrorMsgs.PutErrorMsgs[errors[notANumberString]]; 	    idIsOk ¬ FALSE;	    CONTINUE}	]];	         IF id = HostNumbers.nullHostNumber THEN {        DiagEtherPutErrorMsgs.PutErrorMsgs[errors[notANumberString]];	idIsOk ¬ FALSE};    ENDLOOP;        -- feedback to user.    ODI.PutData[data: prompt];    Format.HostNumber[proc, LOOPHOLE[id], productSoftware];--    ODI.PutData[data: string];    -- update comand array    commandArray[commandArrayIndex] ¬ WordFromByte[id.a, id.b];    commandArrayIndex ¬ commandArrayIndex + 1;    commandArray[commandArrayIndex] ¬ WordFromByte[id.c, id.d];    commandArrayIndex ¬ commandArrayIndex + 1;    commandArray[commandArrayIndex] ¬ WordFromByte[id.e, id.f];    commandArrayIndex ¬ commandArrayIndex + 1;        ODI.PutData[data: ioCmdMsgs[paramSeparator]];    GotAParameter¬ TRUE;    };-- of GetHostNumber.        WordFromByte: PROCEDURE[a, b: [0..256)] RETURNS[CARDINAL] = {RETURN[a*256+b]};    GetOptionsPerLine: PROCEDURE[cmdStringLength, length: CARDINAL]     RETURNS[optionsPerLine, numberOfLines, lastLineEntries: CARDINAL] = {    rightEdge: CARDINAL = OfflineDiagTTYDove.rightEdge;    cmdStringLength ¬ cmdStringLength + 6; -- add the selection number    optionsPerLine ¬ rightEdge/cmdStringLength;    numberOfLines ¬ length/optionsPerLine;    lastLineEntries ¬ length MOD optionsPerLine;    IF lastLineEntries > 0 THEN numberOfLines ¬ numberOfLines + 1 ELSE      lastLineEntries ¬ optionsPerLine;    };  ShowCmds: PROCEDURE[proc: ShowCmdsProcType] = {    «index: CARDINAL;    i: CARDINAL ¬ 0;        IF commandArrayIndex = 1 THEN RETURN;    UNTIL i = commandArrayIndex DO      index ¬ commandArray[i];      i ¬ i + 1;      -- Print Command Name      proc[CmdDes.CmdDescriptArray[index].commandName];      -- Then check if that command has some parameters.      IF CmdDes.CmdDescriptArray[index].needLoopCount THEN i ¬ PutOneParameter[prompts[loopCnt], i];      IF CmdDes.CmdDescriptArray[index].needDelay THEN i ¬ PutOneParameter[prompts[delayCnt], i];      IF CmdDes.CmdDescriptArray[index].needUseSameDataBuff THEN i ¬ PutYesNo[prompts[useSameDataBuff], i];      IF CmdDes.CmdDescriptArray[index].needTryCount THEN i ¬ PutOneParameter[prompts[tryCnt], i];      --IF CmdDes.CmdDescriptArray[index].needUnit THEN i ¬ PutOneParameter[prompts[unit], i];      IF CmdDes.CmdDescriptArray[index].needData THEN i ¬ PutOneParameter[prompts[hexData], i, TRUE];      IF CmdDes.CmdDescriptArray[index].needDestinationID THEN i ¬ PutHostID[prompts[getDestID], i];      IF CmdDes.CmdDescriptArray[index].needByteCount THEN i ¬ PutOneParameter[prompts[getByteCount], i];      IF CmdDes.CmdDescriptArray[index].needMulticastID THEN i ¬ PutMultiCastID[prompts[getMultiCastID], i];      IF CmdDes.CmdDescriptArray[index].needConfigureParams THEN i ¬ i + 2;      ENDLOOP;    };»      PutOneParameter: PROCEDURE[str: LONG STRING, index: CARDINAL, dataIsHex: BOOLEAN ¬ FALSE] RETURNS[CARDINAL] = {    proc[str];    str.length ¬ 0;    String.AppendNumber[s: str, n: commandArray[index],       radix: IF dataIsHex THEN 16 ELSE 10];    index ¬ index + 1;    proc[str];    proc[ioCmdMsgs[paramSeparator]];    PutParameterTail[];    RETURN[index]};     PutHostID: PROCEDURE[str: LONG STRING, index: CARDINAL] RETURNS[CARDINAL] = {    proc: Format.StringProc = {proc[s]};    id: HostNumbers.HostNumber;    num: CARDINAL;        proc[str];    num ¬ commandArray[index]; index ¬ index + 1;    id.a ¬ Inline.HighByte[num];    id.b ¬ Inline.LowByte[num];    num ¬ commandArray[index]; index ¬ index + 1;    id.c ¬ Inline.HighByte[num];    id.d ¬ Inline.LowByte[num];    num ¬ commandArray[index]; index ¬ index + 1;    id.e ¬ Inline.HighByte[num];    id.f ¬ Inline.LowByte[num];    Format.HostNumber[proc, LOOPHOLE[id], productSoftware];    ODI.PutData [data: ioCmdMsgs[paramSeparator]];    PutParameterTail[];    RETURN[index]};  PutMultiCastID: PROCEDURE[str: LONG STRING, index: CARDINAL] RETURNS[CARDINAL] = {    FOR i: CARDINAL IN [0..HardFace.multicastIDLimit) DO      index ¬ PutHostID[prompts[getMultiCastID], index];      ENDLOOP;    RETURN[index]};  PutYesNo: PROCEDURE[str: LONG STRING, index: CARDINAL]  RETURNS[CARDINAL] = {    proc[str];    str.length ¬ 0;    IF commandArray[index] = 1 THEN proc[prompts[yes]]      ELSE proc[prompts[no]];    index ¬ index + 1;    ODI.PutData [data: ioCmdMsgs[paramSeparator]];    PutParameterTail[];    RETURN[index]};      PutParameterTail: PROCEDURE = {    str: LONG STRING ¬ [10];    str.length ¬ 0;    String.AppendChar[str, 10C]; --delete the space after the comma    String.AppendChar[str, 10C]; --delete the comma    String.AppendString[str, ioCmdMsgs[paramEnd]]; --append "];"    proc[str]; --output the string    };    index: CARDINAL;    i: CARDINAL ¬ 0;        IF commandArrayIndex = 1 THEN RETURN;    UNTIL i = commandArrayIndex DO      index ¬ commandArray[i];      i ¬ i + 1;      -- Print Command Name      proc[CmdDes.CmdDescriptArray[index].commandName];      -- Then check if that command has some parameters.      IF CmdDes.CmdDescriptArray[index].needLoopCount THEN i ¬ PutOneParameter[prompts[loopCnt], i];      IF CmdDes.CmdDescriptArray[index].needDelay THEN i ¬ PutOneParameter[prompts[delayCnt], i];      IF CmdDes.CmdDescriptArray[index].needUseSameDataBuff THEN i ¬ PutYesNo[prompts[useSameDataBuff], i];      IF CmdDes.CmdDescriptArray[index].needTryCount THEN i ¬ PutOneParameter[prompts[tryCnt], i];      --IF CmdDes.CmdDescriptArray[index].needUnit THEN i ¬ PutOneParameter[prompts[unit], i];      IF CmdDes.CmdDescriptArray[index].needData THEN i ¬ PutOneParameter[prompts[hexData], i, TRUE];      IF CmdDes.CmdDescriptArray[index].needDestinationID THEN i ¬ PutHostID[prompts[getDestID], i];      IF CmdDes.CmdDescriptArray[index].needByteCount THEN i ¬ PutOneParameter[prompts[getByteCount], i];      IF CmdDes.CmdDescriptArray[index].needMulticastID THEN i ¬ PutMultiCastID[prompts[getMultiCastID], i];      IF CmdDes.CmdDescriptArray[index].needConfigureParams THEN i ¬ i + 2;      ENDLOOP;    };     END...  LOG		Time		By	Action13-Feb-85 17:32:51	MXT	Created.25-Feb-85 15:14:54	MXT 	UpGraded to Pilot 11.1.22-Mar-85 11:50:16	MXT	Deleted obsolute codes to reduse size.15-May-85 18:53:45	MXT	Added GetFrameLength for SetTransmitData.20-May-85 14:01:10	MXT	Changed GetConfigureParams to show configure parameters correctly.29-Jan-86 18:45:16	MXT	Renamed AddressTranslation to DiagEtherAddressTranslation. 
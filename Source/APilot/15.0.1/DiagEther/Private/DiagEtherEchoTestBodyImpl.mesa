-- File: DiagEtherEchoTestBodyImpl.mesa - last edit:-- KXW                   1-Jun-87 16:49:09-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved.-- This module uses Pilot Communication interface such as Socket, Router, etc.-- XNS and Base should be bound with UtilityPilotKernel.DIRECTORY  DiagEtherEchoTest,  DiagEtherErrorMsgs,  DiagEtherTests,  Environment,  EthernetDriverFriends,  Format,  Inline,  NSBuffer,  NSConstants,  NSTypes,  OfflineDiagInterface,  Process,  Router,  Socket,  String,  System;DiagEtherEchoTestBodyImpl: PROGRAM  IMPORTS    DiagEtherErrorMsgs, DiagEtherTests, EthernetDriverFriends, Format, Inline, NSBuffer, OfflineDiagInterface,    «Process, »Router, String, Socket, System  EXPORTS DiagEtherEchoTest =  BEGIN OPEN     DiagEtherErrorMsgs,    ODI: OfflineDiagInterface,    DiagEtherEchoTest;  pEcho: PROCESS;  nullStatsInfo: EthernetDriverFriends.EtherStatsInfo ¬ TRASH;  -- =====================  -- Echo Result variables  -- =====================  totals: EchoResults;  etherNewStats: EthernetDriverFriends.EtherStatsInfo;  etherOldStats: EthernetDriverFriends.EtherStatsInfo;  enterTime, exitTime: System.GreenwichMeanTime;  respTime: LONG CARDINAL ¬ 0;    -- ===========  -- PUBLIC PROC  -- ===========  StartEchoUser: PUBLIC PROCEDURE [    targetSystemElement: System.NetworkAddress, echoParams: EchoParams,    eventReporter: EventReporter ¬ NIL,    host: System.NetworkAddress ¬ System.nullNetworkAddress] =    BEGIN    IF pEcho # NIL THEN RETURN;    InitializeMe[];    pEcho ¬ FORK StartEcho[targetSystemElement, echoParams, eventReporter, host];      «Process.Detach[FORK StartEcho[targetSystemElement, echoParams, eventReporter, host]];»    END;  -- ==============  -- Echo Test Body  -- ==============  StartEcho: PROC [    where: System.NetworkAddress, echoParams: EchoParams,    eventReporter: EventReporter ¬ NIL, host: System.NetworkAddress] =    BEGIN    b: NSBuffer.Buffer;    minWordsPerBuffer, maxWordsPerBuffer: CARDINAL;    funny, late: LONG CARDINAL ¬ 0;    wrong: LONG CARDINAL ¬ 0;    myAddr: System.NetworkAddress;    mySoc: Socket.ChannelHandle;    packetNumber: CARDINAL ¬ 0;    loopCount: CARDINAL ¬ 0;    pleaseStop: BOOLEAN ¬ FALSE;    routing: CARDINAL;    errorCount: CARDINAL ¬ 0;    sendTime, rcvTime: LONG CARDINAL;    waitTime: Socket.WaitTime;        --threshold: CARDINAL ¬ 10;    PutPktNumber: PROCEDURE [n, pktNum, echoedNum: CARDINAL] = {      ODI.PutData[data: "Word #"L, numberAfterData: n, startWithNewLine: TRUE];      ODI.PutData[data: " : PacketNumber = "L, numberAfterData: pktNum];      ODI.PutData[data: " / EchoedNumber = "L, numberAfterData: echoedNum]};          S: PROCEDURE [type: NSTypes.ErrorCode] RETURNS [str: LONG STRING] = {      RETURN[        SELECT type FROM          unspecified => "unspecified"L,          badChecksum => "badChecksum"L,          noSocket => "noSocket"L,          resourceLimits => "resourceLimits"L,          listenerReject => "listenerReject"L,          invalidPacketType => "invalidPacketType"L,          protocolViolation => "protocolViolation"L,          unspecifiedInRoute => "unspecifiedInRoute"L,          inconsistent => "inconsistent"L,          cantGetThere => "cantGetThere"L,          excessHops => "excessHops"L,          tooBig => "tooBig"L,          ENDCASE => "UnKnown"L]};    PrintErrorNS: PROC [b: NSBuffer.Buffer] = {      source: System.NetworkAddress ¬ b.ns.source;      errorCount ¬ errorCount + 1;      IF b.ns.packetType = error THEN {        str: LONG STRING ¬ [256];        len: CARDINAL = b.ns.pktLength;        --err: CARDINAL = LOOPHOLE[b.ns.errorType];        str.length ¬ 0;        String.AppendString[to: str, from: "[Error packet, code="L];        String.AppendString[to: str, from: S[b.ns.errorType]];        ODI.PutData[data: str, startWithNewLine: TRUE];        ODI.PutData[data: ", from: "L];        PrintNSAddress[source];        ODI.PutData["] "L];        FOR i: CARDINAL IN [0..len - NSTypes.wordsPerIDPHeader) DO          WriteChar[Inline.LowByte[b.ns.errorBody[i]]];          WriteChar[Inline.HighByte[b.ns.errorBody[i]]];          ENDLOOP}      ELSE {        pckt: CARDINAL = LOOPHOLE[b.ns.packetType];        ODI.PutData[data: " ***** "L, startWithNewLine: TRUE];        ODI.PutData[          data: "Funny packet type = " «L,	  numberAfterData: LOOPHOLE[pckt]» ];        ODI.PutData[" ***** "L]};      };    --Process.Yield[];    finish ¬ FALSE;        [etherOldStats, enterTime] ¬ GetEthernetStats[];    where.socket ¬ NSConstants.echoerSocket;    routing ¬ Router.GetDelayToNet[where.net      ! Router.NoTableEntryForNet => {routing ¬ 0; CONTINUE}];    IF routing = Router.infinity THEN {      ODI.PutMessage[errors[cantReach]]; RETURN};    myAddr ¬ Socket.AssignNetworkAddress[];    mySoc ¬ Socket.Create[myAddr.socket];    waitTime ¬ IF ~echoParams.waitForResponse THEN (routing+1) * echoParams.minMsecsBetweenPackets * 1000      ELSE 4000*routing + 1500;    Socket.SetWaitTime[mySoc, waitTime];    minWordsPerBuffer ¬ (echoParams.minPacketSizeInBytes + 4)/2;    maxWordsPerBuffer ¬ echoParams.maxPacketSizeInBytes/2;    UNTIL pleaseStop DO      ENABLE ABORTED => {IF b # NIL THEN Socket.ReturnBuffer[b]; EXIT};      FOR len: CARDINAL IN [minWordsPerBuffer..maxWordsPerBuffer] UNTIL pleaseStop        DO        data: CARDINAL ¬          SELECT echoParams.wordContents FROM            all0s => 0,            all1s => 177777B,            incrWords => 0,            allConstant => echoParams.constant * 256 + echoParams.constant,            ENDCASE => 0;        b ¬ Socket.GetSendBuffer[mySoc];        b.ns.destination ¬ where;        b.ns.packetType ¬ echo;        b.ns.echoType ¬ echoRequest;        --Socket.SetPacketBytes[b, len];	Socket.SetPacketWords[b, len];	b.ns.echoWords[minWordsPerBuffer] ¬ data;        FOR i: CARDINAL IN [minWordsPerBuffer + 1..len - minWordsPerBuffer) DO          --b.ns.echoBytes[i] ¬ data; ENDLOOP;	  IF echoParams.wordContents = incrWords THEN b.ns.echoWords[i] ¬ b.ns.echoWords[i - 1] + 1	  ELSE b.ns.echoWords[i] ¬ data;	  ENDLOOP;        b.ns.echoWords[0] ¬ b.ns.echoWords[1] ¬ (packetNumber ¬ packetNumber + 1);        -- Before send packet, check if user want to stop.        --ODI.LookForAbort[        --  ! ODI.AbortCurrentTest => {pleaseStop ¬ TRUE; CONTINUE}];        -- and get ethernet stats.	pleaseStop ¬ LookForAbort[];		IF pleaseStop THEN {NSBuffer.ReturnBuffer[b]; LOOP};	        Socket.PutPacket[mySoc, b];	sendTime ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];        totals.totalAttempts ¬ totals.totalAttempts + 1;        «Process.Yield[];»  -- be sure we don't hog machine        BEGIN        b ¬ Socket.GetPacket[mySoc ! Socket.TimeOut => GOTO late];        SELECT TRUE FROM          (b.ns.packetType # echo) => {            totals.unexpected ¬ totals.unexpected + 1;            IF eventReporter # NIL THEN eventReporter[unexpected]};          --IF errorCount>threshold THEN GOTO fatal};          (b.ns.echoWords[0] # packetNumber) => {            IF eventReporter # NIL THEN eventReporter[late];	    IF DiagEtherTests.Switch[29] THEN 	      PutPktNumber[0, packetNumber, b.ns.echoWords[0]];            totals.late ¬ totals.late + 1};          (b.ns.echoWords[1] # packetNumber) => {            IF eventReporter # NIL THEN eventReporter[late];	    IF DiagEtherTests.Switch[29] THEN 	      PutPktNumber[1, packetNumber, b.ns.echoWords[1]];            totals.late ¬ totals.late + 1};          (len # Socket.GetPacketBytes[b]/2) => {            IF eventReporter # NIL THEN eventReporter[late];	    IF DiagEtherTests.Switch[29] THEN 	      ODI.PutMessage["Invalid Length"L];            totals.late ¬ totals.late + 1};          ENDCASE => {	    rcvTime ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];	    IF echoParams.wordContents = incrWords THEN {	      FOR i: CARDINAL IN [minWordsPerBuffer + 1..len - minWordsPerBuffer) DO	        IF b.ns.echoWords[i] # b.ns.echoWords[i-1] + 1 THEN {		  totals.bad ¬ totals.bad + 1;		  IF eventReporter # NIL THEN eventReporter[badDataGoodCRC];		  EXIT};		REPEAT FINISHED => {		  IF eventReporter # NIL THEN		      eventReporter[			IF len = maxWordsPerBuffer THEN sizeChange ELSE success];		    totals.successes ¬ totals.successes + 1};		ENDLOOP;	      }	    ELSE {	      FOR i: CARDINAL IN [minWordsPerBuffer..len - minWordsPerBuffer) DO		IF b.ns.echoWords[i] # data THEN {		  totals.bad ¬ totals.bad + 1;		  IF eventReporter # NIL THEN eventReporter[badDataGoodCRC];		  EXIT};		REPEAT		  FINISHED => {		    IF eventReporter # NIL THEN		      eventReporter[			IF len = maxWordsPerBuffer THEN sizeChange ELSE success];		    totals.successes ¬ totals.successes + 1};		ENDLOOP;	      };	    respTime ¬ respTime + rcvTime - sendTime;	    };        NSBuffer.ReturnBuffer[b];        EXITS          late => {            IF eventReporter # NIL THEN eventReporter[timeout];            totals.timeouts ¬ totals.timeouts + 1};        --fatal => {NSBuffer.ReturnBuffer[b]; pleaseStop ¬ TRUE};        END;        -- After received one packet, check user abort        --ODI.LookForAbort[        --! ODI.AbortCurrentTest => {pleaseStop ¬ TRUE; CONTINUE}]		pleaseStop ¬ LookForAbort[];        ENDLOOP;      ENDLOOP;    Socket.Delete[mySoc];    END;  LookForAbort: PROC RETURNS[stopIt: BOOLEAN] = {RETURN[finish]};    finish: BOOLEAN ¬ FALSE;    -- ======================  -- Echo Result Management  -- ======================  GetEchoResults: PUBLIC PROC [    stopIt: BOOLEAN, host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [totalsSinceStart: EchoResults] = {    IF stopIt THEN      IF pEcho # NIL THEN {«Process.Abort[pEcho]; »        finish ¬ TRUE; JOIN pEcho; pEcho ¬ NIL};        --finish ¬ stopIt;    CollectStatus[];    RETURN[totals]};  CollectStatus: PROCEDURE = {    [etherNewStats, exitTime] ¬ GetEthernetStats[];        totals.totalTime ¬ (exitTime - enterTime)/LONG[1000];    totals.okButDribble ¬ etherNewStats.okButDribble - etherOldStats.okButDribble;    totals.badAlignmentButOkCrc ¬ etherNewStats.badAlignmentButOkCrc - etherOldStats.badAlignmentButOkCrc;    totals.packetTooLong ¬ etherNewStats.packetTooLong - etherOldStats.packetTooLong;    totals.overrun ¬ etherNewStats.overrun - etherOldStats.overrun;    totals.idleInput ¬ etherNewStats.idleInput - etherOldStats.idleInput;    totals.tooManyCollisions ¬ etherNewStats.tooManyCollisions - etherOldStats.tooManyCollisions;    totals.lateCollisions ¬ etherNewStats.lateCollisions - etherOldStats.lateCollisions;    totals.underrun ¬ etherNewStats.underrun - etherOldStats.underrun;    totals.stuckOutput ¬ etherNewStats.stuckOutput - etherOldStats.stuckOutput;        IF totals.successes>0 THEN       totals.avgDelayInMsecs ¬ respTime/LONG[1000]/totals.successes    ELSE totals.avgDelayInMsecs ¬ 0;    };  GetEthernetStats: PROCEDURE    RETURNS [EthernetDriverFriends.EtherStatsInfo, System.GreenwichMeanTime] = {    newStats: EthernetDriverFriends.EtherStatsInfo;    time: System.GreenwichMeanTime;    newStats ¬ EthernetDriverFriends.GetEthernetStats[      1 ! Router.NetworkNonExistent => GOTO noNet];    time ¬ System.GetGreenwichMeanTime[];    RETURN[newStats, time];    EXITS      noNet => {        ODI.PutMessage[errors[noMoreNets]]; RETURN[nullStatsInfo, LOOPHOLE[LONG[0]]]};    };  PrintNSAddress: PROC [addr: System.NetworkAddress] = {    S: Format.StringProc = {ODI.PutData[s]};    Format.NetworkAddress[proc: S, networkAddress: addr, format: octal];    };  WriteChar: PROC [c: CHARACTER] = {    s: LONG STRING ¬ [2];    s.length ¬ 0;    String.AppendChar[s: s, c: c];    ODI.PutData[s];    };  InitializeMe: PROC = {    finish ¬ FALSE;    respTime ¬ 0;    totals ¬ [totalTime: 0, totalAttempts: 0, successes: 0, timeouts: 0, late: 0, unexpected: 0, bad: 0,    avgDelayInMsecs: 0,    okButDribble: 0, badAlignmentButOkCrc: 0, packetTooLong: 0, overrun: 0, idleInput: 0,    tooManyCollisions: 0, lateCollisions: 0, underrun: 0, stuckOutput: 0,    spare: 0];    };      InitializeMe[];    END...    LOG.1-Jun-87 16:48:35	KXW		Buffer was replaced by NSBuffer.
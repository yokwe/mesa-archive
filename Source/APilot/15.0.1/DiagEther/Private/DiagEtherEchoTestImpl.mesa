-- File: DiagEtherEchoTestImpl.mesa - last edit:-- MXT                 30-Jan-86  9:18:19-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.-- DiagEtherAddressTranslation.-- When Diagnostics release become independent from Pilot/Mesa, the DiagEtherAddressTranslation-- should be resumed to use AddressTranslation interface.DIRECTORY  DiagEtherAddressTranslation USING [Error, NetworkAddress, StringToNetworkAddress],  DiagEtherBasicTestExtras USING[ActivateEthernetDriver],  DiagEtherEchoTest,  DiagEtherErrorMsgs,  DiagEtherIOCmdMsgs USING [ioCmdMsgs],  DiagEtherMenuMsgs USING [menuMsgs],  DiagEtherNS USING [CHIsBound, GetNearestServer],  DiagEtherProfile USING [LoginCmd],  DiagEtherPromptMsgs USING [prompts],  DiagEtherPutErrorMsgs USING [PutBadSyntax, PutCHLookupProblem, PutErrorMsgs, PutOtherCHProblem, PutScanError],  DiagEtherTests USING[dumpBuffer],  Format,  Inline,  OfflineDiagInterface USING [AbortCurrentTest, AnOptionLine, DiagHeap, DisplayFixedPositionData,     FixedPositionDisplayRecord, GetAFixedPositionDisplayRecord, GetAnOption, GetAnOptionLine, GetAnOptionsRecord, GetARow, GetYesNo,     LookForAbort, OfflineDiagnosticProc, OptionsRecord, PutData, PutMessage, ResultType, userType],  Runtime USING [ControlFault, ControlLink, UnboundProcedure],  String,  System USING [GetGreenwichMeanTime, GreenwichMeanTime, NetworkAddress, nullNetworkAddress];DiagEtherEchoTestImpl: PROGRAM  IMPORTS DiagEtherAddressTranslation, DiagEtherBasicTestExtras,    DiagEtherEchoTest, DiagEtherErrorMsgs, DiagEtherIOCmdMsgs, DiagEtherNS, DiagEtherProfile, DiagEtherMenuMsgs,    DiagEtherPromptMsgs, DiagEtherPutErrorMsgs, DiagEtherTests, Format, Inline,    OfflineDiagInterface, Runtime,    String, System  EXPORTS DiagEtherEchoTest =  BEGIN  OPEN DiagEtherErrorMsgs, DiagEtherIOCmdMsgs, DiagEtherMenuMsgs, DiagEtherPromptMsgs,    ODI: OfflineDiagInterface,    DiagEtherEchoTest;  OptionRecHandle: TYPE = LONG POINTER TO ODI.OptionsRecord;  --serverOn: BOOLEAN ¬ FALSE;    -- PUBLIC PROCEDUREs  EnterEchoTest: PUBLIC ODI.OfflineDiagnosticProc = {    ENABLE {      ODI.AbortCurrentTest => {	--IF serverOn THEN TurnServerOff[];	REJECT;  	};      UNWIND => NULL;      };          optionCmd: OptionRecHandle ¬ NIL;    selection: CARDINAL ¬ 0;    quitCmd: BOOLEAN ¬ FALSE;        --IF ~serverOn THEN TurnServerOn[];    DiagEtherBasicTestExtras.ActivateEthernetDriver[];    result ¬ none;    --[] ¬ GetAProperties[];    -- START echo test.    --result ¬ StartEchoTest[];    optionCmd ¬ AllocateOptionCmd[];    UNTIL quitCmd DO      selection ¬ ODI.GetAnOption[        optionTable: optionCmd, defaultOption: 1,        optionPrompt: ioCmdMsgs[enterChoiceNum]	«! ODI.AbortCurrentTest => {	    IF optionCmd#NIL THEN DeAllocateOptionCmd[optionCmd];	    REJECT}»];      SELECT selection FROM        1 => result ¬ StartEchoTest[];        2 => [] ¬ GetAProperties[ ! ODI.AbortCurrentTest => CONTINUE];        3 =>	  IF ~DiagEtherNS.CHIsBound THEN quitCmd ¬ TRUE	  ELSE -- CHStub was bound.	    SELECT ODI.userType FROM	      IN [NormalUser.. Administrator] => quitCmd ¬ TRUE;	      IN [Services..Programmer] => LogOn[];	      ENDCASE => quitCmd ¬ TRUE;        ENDCASE -- Quit -- => quitCmd ¬ TRUE;      ENDLOOP;    --DeAllocateOptionCmd[optionCmd];    --IF serverOn THEN TurnServerOff[];    RETURN[result];    };  LogOn: PROCEDURE = {DiagEtherProfile.LoginCmd[]};    --TurnServerOn: PROCEDURE = {  --  CommDiag.ServerOn[]; serverOn ¬ TRUE};      --TurnServerOff: PROCEDURE = {  --  CommDiag.ServerOff[]; serverOn ¬ FALSE};      AllocateOptionCmd: PROCEDURE RETURNS [optionRec: OptionRecHandle] = {    optionLinePtr: LONG POINTER TO ODI.AnOptionLine;    promptSpaces: CARDINAL ¬ 2;    -- promptInterval: CARDINAL ¬ 30;--  -- 80/3;    selectIndex: CARDINAL ¬ 1;    numberOfItems: CARDINAL ¬ IF ODI.userType IN[NormalUser.. Administrator] OR ~DiagEtherNS.CHIsBound THEN 3 ELSE 4;    optionRec ¬ ODI.GetAnOptionsRecord[numberOfItems];    -- 1. Start Echo Test    -- 2. Property    -- 3. Log on. => This shoud not be applied for the user and sysAdmin level.    -- 4. Quit    -- This option has 4 items.    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ selectIndex; -- 1    optionLinePtr[0].option ¬ String.CopyToNewString[      s: menuMsgs[startEchoTest], z: ODI.DiagHeap];    optionLinePtr[0].helpForThisOption ¬ String.CopyToNewString[      s: menuMsgs[startEchoTestExpl], z: ODI.DiagHeap];    optionRec.linesOfOptions[selectIndex-1] ¬ optionLinePtr;  -- first line.    selectIndex ¬ selectIndex + 1;    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ selectIndex; -- 2    optionLinePtr[0].option ¬ String.CopyToNewString[      s: menuMsgs[setProperty], z: ODI.DiagHeap];    optionLinePtr[0].helpForThisOption ¬ String.CopyToNewString[      s: menuMsgs[setPropertyExpl], z: ODI.DiagHeap];    optionRec.linesOfOptions[selectIndex-1] ¬ optionLinePtr;  -- second line.    selectIndex ¬ selectIndex + 1;    IF ODI.userType IN [Services..Programmer] AND DiagEtherNS.CHIsBound THEN {      optionLinePtr ¬ ODI.GetAnOptionLine[1];	optionLinePtr[0].position ¬ promptSpaces;	optionLinePtr[0].selectionNumberForThisItem ¬ selectIndex; -- 3	optionLinePtr[0].option ¬ String.CopyToNewString[	  s: prompts[logOn], 	  z: ODI.DiagHeap];	optionLinePtr[0].helpForThisOption ¬ String.CopyToNewString[	  s: prompts[logOnExpl], 	  z: ODI.DiagHeap];     optionRec.linesOfOptions[selectIndex-1] ¬ optionLinePtr; -- third line.  	selectIndex ¬ selectIndex + 1;      };    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ selectIndex; -- 3 or 4.    optionLinePtr[0].option ¬ String.CopyToNewString[      s: menuMsgs[quit], z: ODI.DiagHeap];    optionLinePtr[0].helpForThisOption ¬ String.CopyToNewString[      s: menuMsgs[quitExpl], z: ODI.DiagHeap];    optionRec.linesOfOptions[selectIndex-1] ¬ optionLinePtr;  -- first line.    };  DeAllocateOptionCmd: PROCEDURE [options: OptionRecHandle] = {    IF options = NIL THEN RETURN; ODI.DiagHeap.FREE[@options]; options ¬ NIL; };  ListServers: PUBLIC ODI.OfflineDiagnosticProc = {    DiagEtherProfile.LoginCmd[];    };  -- of ListServers.  ShowFinalStatus: PUBLIC ODI.OfflineDiagnosticProc = {};  -- of ShowFinalStatus  ShowIntermediateStatus: PUBLIC ODI.OfflineDiagnosticProc = {};  -- of ShowIntermediateStatus  StartEchoTest: PUBLIC ODI.OfflineDiagnosticProc = {    ok: BOOLEAN ¬ TRUE;    -- Get Echo destination address.    IF properties.echoDest.name = NIL THEN      ok ¬ DiagEtherNS.GetNearestServer[]       «IF DiagEtherNS.CHIsBound THEN ok ¬ DiagEtherNS.GetNearestServer[]      ELSE {	ODI.PutMessage[message: errors[echoDestNameNeeded], beep: TRUE];	ok ¬ FALSE}»    ELSE       IF properties.echoDest.address = System.nullNetworkAddress THEN         [properties.echoDest.address, ok] ¬ GetAddressFromName[properties.echoDest.name];    IF ~ok THEN {      UNTIL ODI.GetYesNo[prompt: prompts[proceeding]] DO ENDLOOP;      RETURN[failed]};     IF properties.echoSourceType=remote THEN       [properties.echoSource.address, ok] ¬ GetAddressFromName[properties.echoSource.name];    IF ~ok THEN {      UNTIL ODI.GetYesNo[prompt: prompts[proceeding]] DO ENDLOOP;      RETURN[failed]};    ShowTestParameters[];    ShowEchoTestMsgs[];    result ¬ StartEchoTestInternal[];    RETURN[result];    };  -- of StartEchoTest      -- Private Internal Procedures.  GetAddressFromName: PROCEDURE[name: LONG STRING] RETURNS[addr: System.NetworkAddress, ok: BOOLEAN] = {    AppendNetNumber: PROC = {      str: LONG STRING ¬ [80];      S: Format.StringProc = {        String.AppendString[to: str, from: s]};	      str.length ¬ 0;      Format.NetworkNumber[S, properties.localID.address.net, octal];      String.AppendChar[s: str, c: '.];      String.AppendString[to: str, from: name];      String.AppendChar[s: str, c: '.];      name ¬ String.CopyToNewString[s: str, z: ODI.DiagHeap, longer: str.length - name.length + 1];      };    first: BOOLEAN ¬ TRUE;        ODI.PutMessage[message: prompts[gettingNetAddr]];        [addr, ] ¬ DiagEtherAddressTranslation.StringToNetworkAddress[      s: name      ! DiagEtherAddressTranslation.Error => {          WITH errorRecord SELECT FROM	    badSyntax => {	      DiagEtherPutErrorMsgs.PutBadSyntax[field];	      GOTO addressTranslationError};	    chLookupProblem => {	      DiagEtherPutErrorMsgs.PutCHLookupProblem[[allDown, first]--*rc*--];	      GOTO addressTranslationError};	    otherCHProblem => {	      DiagEtherPutErrorMsgs.PutOtherCHProblem[reason];	      GOTO addressTranslationError};	    scanError => {	      DiagEtherPutErrorMsgs.PutScanError[position];	      GOTO addressTranslationError};	    ENDCASE};	Runtime.ControlFault, Runtime.UnboundProcedure => {	  IF first THEN {	    AppendNetNumber[];	    first ¬ FALSE;	    RETRY}	  ELSE GOTO addressTranslationError}	«Runtime.UnboundProcedure => {	  IF dest = LOOPHOLE[Courier.LocalSystemElement, Runtime.ControlLink] THEN {	    AppendNetNumber[];	    RETRY}	  ELSE GOTO addressTranslationError}»	    ];    RETURN[addr, TRUE];    EXITS      addressTranslationError => {        DiagEtherPutErrorMsgs.PutErrorMsgs[msg: errors[noCHWasBound]];	DiagEtherPutErrorMsgs.PutErrorMsgs[msg: errors[enterNetworkAddr]];        RETURN[System.nullNetworkAddress, FALSE]};    };      DumpFinalStatus: PROCEDURE[srcPtr: LONG POINTER TO EchoResults] =     BEGIN    destPtr: LONG POINTER;        destPtr ¬ LOOPHOLE[DiagEtherTests.dumpBuffer];    destPtr­ ¬ LAST[CARDINAL];    destPtr ¬ destPtr + 1;        Inline.LongCOPY[from: srcPtr, nwords: SIZE[EchoResults],      to: destPtr];    destPtr ¬ destPtr + SIZE[EchoResults];    Inline.LongCOPY[from: properties, nwords: SIZE[TestProperties],      to: destPtr];    END;      ShowEchoResults: PROCEDURE [    totals: EchoResults, last: BOOLEAN ¬ FALSE] = {    rowCount: CARDINAL ¬ IF last THEN 9 ELSE 7;    upDateOnly: BOOLEAN ¬ TRUE;        IF echoResultRec = NIL OR last THEN {      echoResultRec ¬ AllocateDataRec[rowCount];      upDateOnly ¬ FALSE}    ELSE upDateOnly ¬ TRUE;        -- Update values.    echoResultRec.rows[0].rowItems[0].value ¬ totals.totalAttempts;    echoResultRec.rows[1].rowItems[0].value ¬ totals.successes;    echoResultRec.rows[2].rowItems[0].value ¬ totals.timeouts;    echoResultRec.rows[3].rowItems[0].value ¬ totals.late;    echoResultRec.rows[4].rowItems[0].value ¬ totals.packetTooLong;    echoResultRec.rows[5].rowItems[0].value ¬ totals.bad;    echoResultRec.rows[6].rowItems[0].value ¬ totals.unexpected;    IF last THEN {      echoResultRec.rows[7].rowItems[0].value ¬ totals.avgDelayInMsecs;      echoResultRec.rows[8].rowItems[0].value ¬ 	IF totals.totalAttempts = 0 THEN 0  -- No Echo.	  ELSE (totals.successes * 100) / totals.totalAttempts;      };    ODI.DisplayFixedPositionData[      displayData: echoResultRec,      clearDataArea: last,      upDateOnly: upDateOnly];        IF last THEN {«ODI.DiagHeap.FREE[@echoResultRec];» echoResultRec ¬ NIL};    };  echoResultRec: LONG POINTER TO ODI.FixedPositionDisplayRecord ¬ NIL;  AllocateDataRec: PROCEDURE[rowCount: CARDINAL] RETURNS[echoResults: LONG POINTER TO ODI.FixedPositionDisplayRecord] = {    promptSpaces: CARDINAL = 0;    echoResults ¬ ODI.GetAFixedPositionDisplayRecord[rowCount];    echoResults.displayTitle ¬ prompts[echoResults];        FOR i: CARDINAL IN [0..rowCount) DO      echoResults.rows[i] ¬ ODI.GetARow[1];      echoResults.rows[i].rowItems[0].namePosition ¬ 0;      echoResults.rows[i].rowItems[0].name ¬ NIL;      echoResults.rows[i].rowItems[0].stringValue ¬ NIL;      echoResults.rows[i].rowItems[0].valuePosition ¬ 0;      ENDLOOP;          echoResults.rows[0].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[0].rowItems[0].name ¬ String.CopyToNewString[s: prompts[packetsAttempted], z: ODI.DiagHeap];    echoResults.rows[0].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[0].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[0].rowItems[0].name.length + echoResults.rows[0].rowItems[0].stringValue.length;        echoResults.rows[1].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[1].rowItems[0].name ¬ String.CopyToNewString[s: prompts[goodPacketsRcvd], z: ODI.DiagHeap];    echoResults.rows[1].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[1].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[1].rowItems[0].name.length + echoResults.rows[1].rowItems[0].stringValue.length;        echoResults.rows[2].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[2].rowItems[0].name ¬ String.CopyToNewString[s: prompts[timeOutedPackets], z: ODI.DiagHeap];    echoResults.rows[2].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[2].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[2].rowItems[0].name.length + echoResults.rows[2].rowItems[0].stringValue.length;        echoResults.rows[3].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[3].rowItems[0].name ¬ String.CopyToNewString[s: prompts[latePackets], z: ODI.DiagHeap];    echoResults.rows[3].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[3].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[3].rowItems[0].name.length + echoResults.rows[3].rowItems[0].stringValue.length;        echoResults.rows[4].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[4].rowItems[0].name ¬ String.CopyToNewString[s: prompts[maxLengthPackts], z: ODI.DiagHeap];    echoResults.rows[4].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[4].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[4].rowItems[0].name.length + echoResults.rows[4].rowItems[0].stringValue.length;        echoResults.rows[5].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[5].rowItems[0].name ¬ String.CopyToNewString[s: prompts[crcError], z: ODI.DiagHeap];    echoResults.rows[5].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[5].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[5].rowItems[0].name.length + echoResults.rows[5].rowItems[0].stringValue.length;        echoResults.rows[6].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[6].rowItems[0].name ¬ String.CopyToNewString[s: prompts[unExpectedPackets], z: ODI.DiagHeap];    echoResults.rows[6].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[6].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[6].rowItems[0].name.length + echoResults.rows[6].rowItems[0].stringValue.length;      IF rowCount=9 THEN {    echoResults.rows[7].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[7].rowItems[0].name ¬ String.CopyToNewString[s: prompts[aveRoundTripDelay], z: ODI.DiagHeap];    echoResults.rows[7].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[7].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[7].rowItems[0].name.length + echoResults.rows[7].rowItems[0].stringValue.length;        echoResults.rows[8].rowItems[0].namePosition ¬ promptSpaces;    echoResults.rows[8].rowItems[0].name ¬ String.CopyToNewString[s: prompts[percentOfCorrectPackets], z: ODI.DiagHeap];    echoResults.rows[8].rowItems[0].stringValue ¬ String.CopyToNewString[s: "=  "L, z: ODI.DiagHeap];    echoResults.rows[8].rowItems[0].valuePosition ¬       promptSpaces + echoResults.rows[8].rowItems[0].name.length + echoResults.rows[8].rowItems[0].stringValue.length;    };    };  ShowEchoTestMsgs: PROCEDURE = {    S: PROC [s1, s2: LONG STRING] = {      pad: CARDINAL;      crLF: BOOLEAN ¬ FALSE;            IF s1.length>nextPos THEN {crLF ¬ TRUE; pad ¬ 0}      ELSE {crLF ¬ FALSE; pad ¬ nextPos - s1.length};      ODI.PutMessage[message: s1];      ODI.PutMessage[message: s2, startWithNewLine: crLF, blankSpaces: pad];      };          nextPos: CARDINAL = 40;        -- Display realtime feedback key.    IF properties.realTimeFeedBack THEN {      ODI.PutMessage[message: prompts[fbTitle], numOfBlankLines: 0];      S[prompts[fbSuccess], prompts[fbUnreached]];      S[prompts[fbDelaied], prompts[fbCRCError]];      S[prompts[fbMaxLengthPacket], prompts[fbUnexpected]];      };    ODI.PutMessage[message: prompts[echoAbortMsg], numOfBlankLines: 1];    ODI.PutMessage[message: prompts[echoStarted], numOfBlankLines: 1];    };  StartEchoTestInternal: PROCEDURE RETURNS [result: ODI.ResultType] = {    RealTimeFeedBackProc: EventReporter -- PROC[event: EchoEvent] --  = {      ODI.PutData[        data: feedBackString[event], startWithNewLine: firstFBKey, blankSpaces: 0];      firstFBKey ¬ FALSE;      };    displayFeedbackProc: EventReporter;    feedBackString: ARRAY EchoEvent OF STRING = [      success: prompts[successKey], timeout: prompts[timeoutKey],       late: prompts[lateKey], sizeChange: prompts[sizeChangeKey],       badDataGoodCRC: prompts[badDataGoodCRCKey], unexpected: prompts[unexpectedKey]];    previousTime, currentTime: System.GreenwichMeanTime;    firstFBKey: BOOLEAN ¬ TRUE;    -- All parameters are already set up so I can start Echo Test right now.    totalsSinceStart: EchoResults ¬ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];    userWantToAbort: BOOLEAN ¬ FALSE;    destServer, sourceServer: LONG POINTER TO MachineIDRecord;    result ¬ none;    destServer ¬ properties.echoDest;    sourceServer ¬ properties.echoSource;    IF sourceServer.address = System.nullNetworkAddress THEN       sourceServer.address ¬ properties.localID.address;      -- Echo Source is defaulted by local machine.    displayFeedbackProc ¬      IF properties.echoSourceType = local AND        properties.realTimeFeedBack THEN RealTimeFeedBackProc ELSE NIL;        ShowEchoResults[totalsSinceStart, FALSE];    ODI.PutData[clearDataAreaOnly: TRUE];    StartEchoUser[      host: sourceServer.address,      targetSystemElement: destServer.address,      echoParams: properties.echoParams­,      eventReporter: displayFeedbackProc];    previousTime ¬ System.GetGreenwichMeanTime[];    userWantToAbort ¬ FALSE;    UNTIL userWantToAbort DO      currentTime ¬ System.GetGreenwichMeanTime[];      ODI.LookForAbort[        !        ODI.AbortCurrentTest => {  -- User hit STOP.          userWantToAbort ¬ TRUE; CONTINUE}; ];      IF (currentTime - previousTime >= itermedResultIntervalInSec)        OR userWantToAbort THEN {        previousTime ¬ currentTime;     	totalsSinceStart ¬ GetEchoResults[	  host:sourceServer.address, 	  stopIt: userWantToAbort];        ShowEchoResults[totalsSinceStart, userWantToAbort];        firstFBKey ¬ TRUE;        };      ENDLOOP;    result ¬      IF totalsSinceStart.totalAttempts = 0 THEN ambiguous      ELSE        IF (totalsSinceStart.successes * 100) / totalsSinceStart.totalAttempts > 95        THEN passed ELSE failed;    DumpFinalStatus[@totalsSinceStart];        UNTIL ODI.GetYesNo[prompt: prompts[proceeding]] DO ENDLOOP;    --EXITS    --  commError => {UNTIL ODI.GetYesNo[prompts[proceeding]] DO ENDLOOP};    };  -- of StartEchoTestInternal  END...  LOGtime	by	action29-Jan-85 20:02:05	MXT	Created23-Feb-85 14:52:06	MXT	Added DiagEtherProfile.LoginCmd before enterring the Echo Test selection mode.  1-Mar-85 16:45:30	MXT	Changed the EnterEchoTest to returns correct results and added prompt message in EnterEchoTest. 18-Mar-85 11:06:12	MXT	Moved DiagEtherPofile.LoginCmd to DiagEtherEchoTestPropertyImpl 19-Mar-85 17:45:52	MXT	Added StartCH to initialize CH stuffs.23-Mar-85 19:23:38	MXT	Removed StartCH to DiagEtherTestsImpl. 8-Apr-85 19:17:54	MXT	Changed to use NSName.AppendNameToString in GetNearestServer.11-Apr-85 15:17:27	MXT	Changed to use CHIsBound in EchoTestStart.15-May-85 18:50:11	MXT	Upgraded to Pilot 12.0 CommOnlineDiagnostics28-May-85 17:45:22	MXT	Removed unused codes. 7-Jun-85 11:25:55	MXT	Changed to check System.nullNetworkAddress in StartEchoTest17-Oct-85 14:09:55	MXT	Changed for New Boot file.29-Jan-86 18:44:09	MXT	Renamed AddressTranslation to DiagEtherAddressTranslation. 
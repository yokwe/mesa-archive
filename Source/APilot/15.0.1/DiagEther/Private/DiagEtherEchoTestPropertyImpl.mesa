-- File: DiagEtherEchoTestPropertyImpl.mesa - last edit:-- MXT                  4-Jun-86 11:17:09-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherEchoTest,  DiagEtherErrorMsgs	USING [errors],  DiagEtherIOCmdMsgs  USING[ioCmdMsgs],  DiagEtherNS USING [CHIsBound],  DiagEtherProfile USING [LoginCmd],  DiagEtherPromptMsgs USING [prompts],  Format USING [HostNumber, NetworkNumber, StringProc],  OfflineDiagInterface USING [AnOptionLine, DiagHeap, DisplayItem, FixedPositionDisplayRecord,     GetAFixedPositionDisplayRecord, GetAHelpText, GetAnOption, GetAnOptionLine,     GetAnOptionsRecord, GetANumber, GetARow, GetAString, GetYesNo,     HelpText, OfflineDiagnosticProc, OptionsRecord, PutMessage, PutTestParameters, userType],--  Profile USING [GetDefaultDomain, GetDefaultOrganization, SetDefaultDomain, SetDefaultOrganization, String],  Router USING [FindMyHostID, GetNetworkID, NetworkNonExistent],  String USING [AppendChar, AppendDecimal, AppendString, Copy, CopyToNewString, Equivalent, MakeString],  System USING [HostNumber, NetworkAddress, NetworkNumber, nullNetworkAddress, nullNetworkNumber, nullSocketNumber];DiagEtherEchoTestPropertyImpl: PROGRAM  IMPORTS    DiagEtherErrorMsgs, DiagEtherProfile, DiagEtherIOCmdMsgs, DiagEtherPromptMsgs,    DiagEtherNS, Format, OfflineDiagInterface, «Profile, »Router, String  EXPORTS DiagEtherEchoTest =  BEGIN  OPEN ODI: OfflineDiagInterface,    DiagEtherIOCmdMsgs, DiagEtherPromptMsgs, DiagEtherEchoTest;  -- =====  -- TYPEs  -- =====  OptionRecHandle: TYPE = LONG POINTER TO ODI.OptionsRecord;  ErrorType: TYPE = {invalidName, nullDomainAndOrg, others};    -- =================  -- Grobal variables.  -- =================  properties: PUBLIC PropertyHandle ¬ NIL;  parameters: LONG POINTER TO ODI.FixedPositionDisplayRecord ¬ NIL;  domainIndex, orgIndex, remoteEchoNameIndex, echoDestIndex, dataPatIndex, fbIndex,    minPacketIndex, maxPacketIndex, waitTimeIndex: CARDINAL;  domainAndOrgOK: PUBLIC BOOLEAN ¬ FALSE;  -- following ARRAY should be merged to some msgs file.  errorMsgs: ARRAY ErrorType OF STRING ¬ [    invalidName: "Invalid Name",    nullDomainAndOrg: "Domain and/or Organization is not specified.",    others: "Other Error"];  notLoggedIn: BOOLEAN ¬ TRUE;  -- =========  -- Constants  -- =========  maxMachineNameLength: CARDINAL = 80;  --   optionLinePtr: PUBLIC LONG POINTER TO ODI.AnOptionLine;  maxFullNameLength: CARDINAL = 86;  maxDomainLength: CARDINAL = 20;  maxOrgLength: CARDINAL = 20;    -- =================  -- PUBLIC PROCEDUREs  -- =================  GetAProperties: PUBLIC ODI.OfflineDiagnosticProc = {    «ENABLE {      ODI.AbortCurrentTest => {        IF parameters # NIL THEN {ODI.DiagHeap.FREE[@parameters]; parameters ¬ NIL};        REJECT;  -- Transform this SIGNAL to upper level.        };      UNWIND => NULL};»    ok: BOOLEAN ¬ FALSE;    quitCmd: CARDINAL = 14;    selection: CARDINAL ¬ 0;    first: BOOLEAN ¬ TRUE;    rePaintProps: BOOLEAN ¬ FALSE;    defaultEchoSourceType: EchoSourceType ¬ local;    --    IF DiagEtherNS.CHIsBound THEN GetDefaultDomainAndOrg[];    ShowTestParameters[];    -- Start Dialogue.    UNTIL ok DO      StartInitialDialogue[];      ok ¬ ODI.GetYesNo[prompt: prompts[confirm]];      ENDLOOP;        IF parameters # NIL THEN     RETURN[none];    };  Initialize: PUBLIC PROCEDURE = {    notLoggedIn ¬ TRUE;    InitializeProps[]};  -- of Initialize.  ShowTestParameters: PUBLIC PROCEDURE = {ShowTestParametersInternal[FALSE]; };  ShowTestParametersInternal: PROCEDURE [upDateOnly: BOOLEAN ¬ TRUE] = {    IF ~upDateOnly THEN parameters ¬ GetFormattedPropSheet[];    ODI.PutTestParameters[parameters: parameters, upDateOnly: upDateOnly];    };  StartInitialDialogue: PUBLIC PROCEDURE = {    feedBack: BOOLEAN ¬ TRUE;--    IF DiagEtherNS.CHIsBound THEN SetDomainAndOrganization[feedBack];    SELECT ODI.userType FROM      NormalUser => {        SetRealTimeFeedBack[feedBack];        SetDataPattern[feedBack];        SetMinPacketSize[feedBack];        SetMaxPacketSize[feedBack];        };      Administrator => {        SetEchoDestination[feedBack];        SetRealTimeFeedBack[feedBack];        SetDataPattern[feedBack];        SetMinPacketSize[feedBack];        SetMaxPacketSize[feedBack];        SetWaitforResponse[feedBack];        };      IN [Services..Programmer] => {        -- The user should log on with proper user name and password.        IF notLoggedIn AND DiagEtherNS.CHIsBound THEN {	  DiagEtherProfile.LoginCmd[];	  notLoggedIn ¬ FALSE};        -- Then he can set everything.        SetEchoDestination[feedBack];        SetEchoSource[local, feedBack];        SetRealTimeFeedBack[feedBack];        SetDataPattern[feedBack];        SetMinPacketSize[feedBack];        SetMaxPacketSize[feedBack];        SetWaitforResponse[feedBack];        };      ENDCASE;    };    -- PROCEDUREs for the GetAPropertys.  GetEchoSource: PROCEDURE RETURNS [num: CARDINAL] = {    RETURN[1]; -- Local Source Only.   « optPtr: LONG POINTER TO ODI.OptionsRecord ¬ ODI.GetAnOptionsRecord[2];    optionLinePtr: LONG POINTER TO ODI.AnOptionLine;    promptSpaces: CARDINAL = 5;    optPtr.optionMenuTiTle ¬ prompts[echoSourceOptions];    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ 1;    optionLinePtr[0].option ¬ prompts[local];    optionLinePtr[0].helpForThisOption ¬ prompts[localExpl];    optPtr.linesOfOptions[0] ¬ optionLinePtr;  -- first line.    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ 2;    optionLinePtr[0].option ¬ prompts[remote];    optionLinePtr[0].helpForThisOption ¬ prompts[remoteExpl];    optPtr.linesOfOptions[1] ¬ optionLinePtr;  -- first line.    num ¬ ODI.GetAnOption[      optionTable: optPtr,      defaultOption: IF properties.echoSourceType = local THEN 1 ELSE 2,      optionPrompt: prompts[enterEchoSourceType]];»    -- ShowTestParametersInternal[FALSE];    };  GetDataType: PROCEDURE RETURNS [num: CARDINAL] = {    optPtr: LONG POINTER TO ODI.OptionsRecord ¬ ODI.GetAnOptionsRecord[4];    optionLinePtr: LONG POINTER TO ODI.AnOptionLine;    default: CARDINAL;    promptSpaces: CARDINAL = 5;    optPtr.optionMenuTiTle ¬ prompts[dataPatternOptions];    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ 1;    optionLinePtr[0].option ¬ prompts[incrData];    optionLinePtr[0].helpForThisOption ¬ prompts[incrDataExpl];    optPtr.linesOfOptions[0] ¬ optionLinePtr;  -- first line.    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ 2;    optionLinePtr[0].option ¬ prompts[all0Data];    optionLinePtr[0].helpForThisOption ¬ prompts[all0DataExpl];    optPtr.linesOfOptions[1] ¬ optionLinePtr;  -- first line.    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ 3;    optionLinePtr[0].option ¬ prompts[all1Data];    optionLinePtr[0].helpForThisOption ¬ prompts[all1DataExpl];    optPtr.linesOfOptions[2] ¬ optionLinePtr;  -- first line.    optionLinePtr ¬ ODI.GetAnOptionLine[1];    optionLinePtr[0].position ¬ promptSpaces;    optionLinePtr[0].selectionNumberForThisItem ¬ 4;    optionLinePtr[0].option ¬ prompts[constantData];    optionLinePtr[0].helpForThisOption ¬ prompts[constantDataExpl];    optPtr.linesOfOptions[3] ¬ optionLinePtr;  -- first line.    default ¬      SELECT properties.echoParams.wordContents FROM        incrWords => 1,        all0s => 2,        all1s => 3,        ENDCASE -- allConstant -- => 4;    num ¬ ODI.GetAnOption[      optionTable: optPtr, defaultOption: default,      optionPrompt: prompts[enterDataType]];    --ShowTestParametersInternal[FALSE];    };  «GetDefaultDomainAndOrg: PROCEDURE = {    Profile.GetDefaultDomain[SetDefaultDomain];    Profile.GetDefaultOrganization[SetDefaultOrganization];    };  SetDefaultDomain: PROCEDURE [domain: Profile.String] = {    properties.domainAndOrganization.domain ¬ domain;    };  SetDefaultOrganization: PROCEDURE [org: Profile.String] = {    properties.domainAndOrganization.org ¬ org;    };»  SetDataPattern: PROC [feedBack: BOOLEAN ¬ TRUE] = {    prompt: STRING ¬ [256];    selected: CARDINAL ¬ 0;    upDateOnly: BOOLEAN ¬ TRUE;    selected ¬ GetDataType[];    SELECT selected FROM      1 => {        --IF properties.echoParams.wordContents = allConstant THEN upDateOnly ¬ FALSE;        properties.echoParams.wordContents ¬ incrWords};      2 => {        --IF properties.echoParams.wordContents = allConstant THEN upDateOnly ¬ FALSE;        properties.echoParams.wordContents ¬ all0s};      3 => {        --IF properties.echoParams.wordContents = allConstant THEN upDateOnly ¬ FALSE;        properties.echoParams.wordContents ¬ all1s};      4 => {        --IF properties.echoParams.wordContents # allConstant THEN upDateOnly ¬ FALSE;        String.Copy[to: prompt, from: prompts[enterConstantData]];        String.AppendDecimal[prompt, properties.echoParams.constant];        properties.echoParams.wordContents ¬ allConstant;        [, properties.echoParams.constant, , ] ¬ ODI.GetANumber[          prompt: prompts[enterConstantData], lowLimit: 0, upperLimit: 255,          defaultNumber: properties.echoParams.constant];        };      ENDCASE;    upDateOnly ¬ FALSE;    GetDataPatString[parameters, dataPatIndex];    ShowTestParametersInternal[upDateOnly];    };  -- of SetDataPattern  «SetDomainAndOrganization: PROC[feedBack: BOOLEAN ¬ TRUE] = {    tempDomain: LONG STRING ¬ [maxDomainLength];    tempOrg: LONG STRING ¬ [maxOrgLength];    help: LONG POINTER TO ODI.HelpText;    domainOK, orgOK: BOOLEAN ¬ FALSE;    help ¬ ODI.GetAHelpText[1];    GetDefaultDomainAndOrg[];    -- Get Domain.    help.textBody[0] ¬ prompts[domainExpl];    tempDomain.length ¬ 0;    tempDomain ¬ ODI.GetAString[      prompt: prompts[domain],      defaultString: properties.domainAndOrganization.domain, help: help];    properties.domainAndOrganization.domain ¬ String.CopyToNewString[      s: tempDomain, z: ODI.DiagHeap];    Profile.SetDefaultDomain[tempDomain];    parameters.rows[domainIndex].rowItems[0].stringValue ¬ String.CopyToNewString[s: tempDomain, z: ODI.DiagHeap];    -- Get Organization.    help.textBody[0] ¬ prompts[orgExpl];    tempOrg ¬ ODI.GetAString[      prompt: prompts[organization],      defaultString: properties.domainAndOrganization.org, help: help];    properties.domainAndOrganization.org ¬ String.CopyToNewString[      s: tempOrg, z: ODI.DiagHeap];    Profile.SetDefaultOrganization[tempOrg];    parameters.rows[orgIndex].rowItems[0].stringValue ¬ String.CopyToNewString[s: tempOrg, z: ODI.DiagHeap];    domainAndOrgOK ¬ tempDomain.length # 0 AND tempOrg.length # 0;    IF feedBack THEN ShowTestParametersInternal[];    };»  -- of SetDomainAndOrganization      SetEchoDestination: PROC [feedBack: BOOLEAN ¬ TRUE] = {    temp: LONG STRING ¬ [maxFullNameLength];    temp.length ¬ 0;    String.Copy[to: temp, from: properties.echoDest.name];    temp ¬ GetNameOrAddress[      prompts[enterEchoDest], temp];    IF NOT String.Equivalent[temp, properties.echoDest.name] THEN {    -- user changed echo destination name/address.      properties.echoDest.address ¬ System.nullNetworkAddress;      properties.echoDest.name ¬ IF temp.length = 0 THEN NIL 	ELSE String.CopyToNewString[z: ODI.DiagHeap, s: temp];      };    IF feedBack THEN {      parameters.rows[echoDestIndex].rowItems[0].stringValue ¬ temp;      ShowTestParametersInternal[];      };    };  -- of SetEchoDestination  SetEchoSource: PROC [    defaultType: EchoSourceType ¬ local, feedBack: BOOLEAN ¬ TRUE] = {    remoteSource: LONG STRING ¬ [maxFullNameLength];    upDateOnly: BOOLEAN ¬ TRUE;    selected: CARDINAL ¬ 1;    selected ¬ GetEchoSource[];    IF properties.echoSourceType = remote THEN {      remoteSource.length ¬ 0;      String.Copy[        to: remoteSource,         from: properties.echoSource.name]};    SELECT selected FROM      1 => {        properties.echoSource.address ¬ properties.localID.address;        properties.echoSourceType ¬ local};      2 => {        remoteSource ¬ GetNameOrAddress[          prompts[remoteSource], remoteSource];        properties.echoSourceType ¬ remote;	IF NOT String.Equivalent[remoteSource, properties.echoSource.name] THEN {	  properties.echoSource.address ¬ System.nullNetworkAddress;	  properties.echoSource.name ¬ IF remoteSource.length = 0 THEN NIL	    ELSE String.CopyToNewString[z: ODI.DiagHeap, s: remoteSource]           };	};      ENDCASE;    upDateOnly ¬ FALSE;    IF feedBack THEN {      IF properties.echoSourceType = remote AND upDateOnly THEN        parameters.rows[remoteEchoNameIndex].rowItems[0].stringValue ¬ remoteSource;      ShowTestParametersInternal[upDateOnly];      };    };  -- of SetEchoSource  SetMaxPacketSize: PROC [feedBack: BOOLEAN ¬ TRUE] = {    prompt: LONG STRING ¬ [256];    String.Copy[to: prompt, from: prompts[askMaxPacketSize]];    --String.AppendNumber[prompt, properties.echoParams.maxPacketSizeInBytes];    [, properties.echoParams.maxPacketSizeInBytes, , ] ¬ ODI.GetANumber[      prompt: prompt, lowLimit: properties.echoParams.minPacketSizeInBytes,      upperLimit: 512, defaultNumber: 512];    IF feedBack THEN {      parameters.rows[maxPacketIndex].rowItems[0].value ¬        properties.echoParams.maxPacketSizeInBytes;      ShowTestParametersInternal[];      };    --    RETURN[none];    };  -- of SetMaxPacketSize  SetMinPacketSize: PROC [feedBack: BOOLEAN ¬ TRUE] = {    prompt: STRING ¬ [256];    String.Copy[to: prompt, from: prompts[askMinPacketSize]];    -- String.AppendNumber[prompt, properties.echoParams.minPacketSizeInBytes];    [, properties.echoParams.minPacketSizeInBytes, , ] ¬ ODI.GetANumber[      prompt: prompt, lowLimit: 2, upperLimit: 512, defaultNumber: 2];    IF feedBack THEN {      parameters.rows[minPacketIndex].rowItems[0].value ¬        properties.echoParams.minPacketSizeInBytes;      ShowTestParametersInternal[];      };    --    RETURN[none];    };  -- of SetMinPacketSize  SetRealTimeFeedBack: PROC [feedBack: BOOLEAN ¬ TRUE] = {    IF properties.echoSourceType # local THEN RETURN;    properties.realTimeFeedBack ¬ ODI.GetYesNo[      prompt: prompts[askRealTimeFeedBack], defaultSpecified: TRUE,       default: properties.realTimeFeedBack];    IF feedBack THEN {      parameters.rows[fbIndex].rowItems[0].stringValue ¬        IF properties.realTimeFeedBack THEN prompts[yes] ELSE prompts[no];      ShowTestParametersInternal[];      };    --    RETURN[none];    };  -- of SetRealTimeFeedBack  SetWaitforResponse: PROC [feedBack: BOOLEAN ¬ TRUE] = {    prev: BOOLEAN ¬ properties.echoParams.waitForResponse;    upDateOnly: BOOLEAN ¬ FALSE;    properties.echoParams.waitForResponse ¬ ODI.GetYesNo[      prompt: prompts[waitForResponse], defaultSpecified: TRUE,      default: properties.echoParams.waitForResponse];    IF ~properties.echoParams.waitForResponse THEN      [, properties.echoParams.minMsecsBetweenPackets, , ] ¬ ODI.GetANumber[        prompt: prompts[enterDelayPacket], defaultNumber: 100];    IF feedBack THEN {      upDateOnly ¬ (prev = properties.echoParams.waitForResponse);      IF NOT prev THEN -- wait time is shown on display.        parameters.rows[waitTimeIndex].rowItems[0].value ¬          properties.echoParams.minMsecsBetweenPackets;      ShowTestParametersInternal[upDateOnly];      };    --    RETURN[none];    };  -- of SetWaitforResponse  ShowTestProperty: PUBLIC ODI.OfflineDiagnosticProc = {    ShowTestParameters[];    RETURN[none];    };  -- of ShowTestProperty  --   -- PUBLIC PROCEDUREs for EchoTestExtra.  PutBadPropMessage: PUBLIC PROCEDURE = {    ODI.PutMessage[DiagEtherErrorMsgs.errors[fixPropSheetItems]]; };  -- of PutBadPropMessage  PutErrorMessage: PROCEDURE [code: ErrorType] = {    temp: LONG STRING ¬ [256];    String.Copy[to: temp, from: "ERROR "];    String.AppendString[to: temp, from: errorMsgs[code]];    ODI.PutMessage[temp];    };  -- Private Internal Procedures.  GetDataPatString: PROCEDURE [    params: LONG POINTER TO ODI.FixedPositionDisplayRecord, index: CARDINAL] = {    item: ODI.DisplayItem;    item ¬ params.rows[index].rowItems[0];    item.stringValue ¬      SELECT properties.echoParams.wordContents FROM        incrWords => prompts[incrData],        all0s => prompts[all0Data],        all1s => prompts[all1Data],        ENDCASE => prompts[constantData];    item.valuePosition ¬ 0;    IF properties.echoParams.wordContents = allConstant THEN {      item.valuePosition ¬        item.namePosition + item.name.length + item.stringValue.length;      item.value ¬ properties.echoParams.constant};    params.rows[index].rowItems[0] ¬ item;    };  -- of GetDataPatString.  GetFormattedNetAddr: PROCEDURE [address: System.NetworkAddress]    RETURNS [LONG STRING] = {    stringProc: Format.StringProc = {String.AppendString[to: string, from: s]; };    string: LONG STRING ¬ String.MakeString[      z: ODI.DiagHeap, maxlength: maxMachineNameLength];    string.length ¬ 0;    -- at first, get a product software format.    Format.NetworkNumber[      proc: stringProc, networkNumber: address.net, format: productSoftware];    String.AppendChar[string, '.];    Format.HostNumber[      proc: stringProc, hostNumber: address.host, format: productSoftware];    String.AppendString[to: string, from: ". = "L];    -- next, get a octal format.    Format.NetworkNumber[      proc: stringProc, networkNumber: address.net, format: octal];    String.AppendString[to: string, from: "B."L];    Format.HostNumber[proc: stringProc, hostNumber: address.host, format: octal];    String.AppendString[to: string, from: "B. = "L];    -- at last, get a hex format.    Format.NetworkNumber[      proc: stringProc, networkNumber: address.net, format: hex];    String.AppendChar[string, '.];    Format.HostNumber[proc: stringProc, hostNumber: address.host, format: hex];    String.AppendChar[string, '.];   -- properties.localID.name ¬ String.CopyToNewString[s: string, z: ODI.DiagHeap];    RETURN[string];    };  GetFormattedPropSheet: PROCEDURE    RETURNS [propSheet: LONG POINTER TO ODI.FixedPositionDisplayRecord] = {    OPEN props: properties;    promptSpaces: CARDINAL ¬ 4;    temp: LONG STRING ¬ [256];    n: CARDINAL ¬ GetNumberOfDisplayItems[];    index: CARDINAL ¬ 0;    propSheet ¬ ODI.GetAFixedPositionDisplayRecord[n];    propSheet.displayTitle ¬ String.CopyToNewString[      s: prompts[propSheetTitle], z: ODI.DiagHeap];    FOR i: CARDINAL IN [0..n) DO      propSheet.rows[i] ¬ ODI.GetARow[1];      propSheet.rows[i].rowItems[0].namePosition ¬ 0;      propSheet.rows[i].rowItems[0].name ¬ NIL;      propSheet.rows[i].rowItems[0].stringValue ¬ NIL;      propSheet.rows[i].rowItems[0].valuePosition ¬ 0;      ENDLOOP;    propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;    propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[      s: prompts[localAddress], z: ODI.DiagHeap];    propSheet.rows[index].rowItems[0].stringValue ¬ GetFormattedNetAddr[      properties.localID.address];    --props.localID.name;    index ¬ index + 1;    IF DiagEtherNS.CHIsBound THEN {      propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;      propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[	s: prompts[domain], z: ODI.DiagHeap];      propSheet.rows[index].rowItems[0].stringValue ¬ String.CopyToNewString[	s: props.domainAndOrganization.domain, z: ODI.DiagHeap];      domainIndex ¬ index;      index ¬ index + 1;      propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;      propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[	s: prompts[organization], z: ODI.DiagHeap];      propSheet.rows[index].rowItems[0].stringValue ¬ String.CopyToNewString[	s: props.domainAndOrganization.org, z: ODI.DiagHeap];      orgIndex ¬ index;      index ¬ index + 1;      };    SELECT props.echoSourceType FROM      local => {        propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;        propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[          s: prompts[echoSource], z: ODI.DiagHeap];        propSheet.rows[index].rowItems[0].stringValue ¬ prompts[local];        index ¬ index + 1;        };      remote => {        propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;        propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[          s: prompts[echoSource], z: ODI.DiagHeap];        propSheet.rows[index].rowItems[0].stringValue ¬ prompts[remote];        index ¬ index + 1;        propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;        propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[          s: prompts[echoSrcNameForRemote], z: ODI.DiagHeap];        propSheet.rows[index].rowItems[0].stringValue ¬ String.CopyToNewString[props.echoSource.name, ODI.DiagHeap];        remoteEchoNameIndex ¬ index;        index ¬ index + 1;        };      ENDCASE;    propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;    propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[      s: prompts[echoDestinaiton], z: ODI.DiagHeap];    propSheet.rows[index].rowItems[0].stringValue ¬ String.CopyToNewString[props.echoDest.name, ODI.DiagHeap];    echoDestIndex ¬ index;    index ¬ index + 1;    IF props.echoSourceType = local THEN {      -- Real time feedback is only appricapable in the local echo.      propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;      propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[        s: prompts[realTimeFeedBack], z: ODI.DiagHeap];      propSheet.rows[index].rowItems[0].stringValue ¬        IF props.realTimeFeedBack THEN prompts[yes] ELSE prompts[no];      fbIndex ¬ index;      index ¬ index + 1;      };    propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;    propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[      s: prompts[dataPattern], z: ODI.DiagHeap];    GetDataPatString[propSheet, index];    dataPatIndex ¬ index;    index ¬ index + 1;    propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;    propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[      s: prompts[minPacketSize], z: ODI.DiagHeap];    propSheet.rows[index].rowItems[0].stringValue ¬ NIL;    propSheet.rows[index].rowItems[0].valuePosition ¬      promptSpaces + propSheet.rows[index].rowItems[0].name.length;    propSheet.rows[index].rowItems[0].value ¬      props.echoParams.minPacketSizeInBytes;    minPacketIndex ¬ index;    index ¬ index + 1;    propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;    propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[      s: prompts[maxPacketSize], z: ODI.DiagHeap];    propSheet.rows[index].rowItems[0].stringValue ¬ NIL;    propSheet.rows[index].rowItems[0].valuePosition ¬      promptSpaces + propSheet.rows[index].rowItems[0].name.length;    propSheet.rows[index].rowItems[0].value ¬      props.echoParams.maxPacketSizeInBytes;    maxPacketIndex ¬ index;    index ¬ index + 1;    propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;    propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[      s: prompts[waitForAResponse], z: ODI.DiagHeap];    propSheet.rows[index].rowItems[0].stringValue ¬      IF ~props.echoParams.waitForResponse THEN prompts[no] ELSE prompts[yes];    index ¬ index + 1;    IF ~props.echoParams.waitForResponse THEN {      propSheet.rows[index].rowItems[0].namePosition ¬ promptSpaces;      propSheet.rows[index].rowItems[0].name ¬ String.CopyToNewString[        s: prompts[waitTimeInMilliSec], z: ODI.DiagHeap];      propSheet.rows[index].rowItems[0].valuePosition ¬        promptSpaces + propSheet.rows[index].rowItems[0].name.length;      propSheet.rows[index].rowItems[0].value ¬        props.echoParams.minMsecsBetweenPackets;      waitTimeIndex ¬ index;      };    };  -- of GetFormattedPropSheet  GetMyAddress: PROCEDURE = {    properties.localID.address.net ¬ System.nullNetworkNumber;    properties.localID.address.host ¬ Router.FindMyHostID[];    properties.localID.address.socket ¬ System.nullSocketNumber; --mySocketNumber;    properties.localID.address.net ¬ Router.GetNetworkID[1, ethernet      ! Router.NetworkNonExistent => GOTO noNetwork];        EXITS      noNetwork => {      properties.localID.address.net ¬ System.nullNetworkNumber;        «str: LONG STRING ¬ [256];	num: LONG CARDINAL;		[num, , , str] ¬ ODI.GetANumber[prompt: prompts[enterNetNum],	  numberIsLong: TRUE, defaultNumber: 0];	properties.localID.address.net ¬ IF str.length=0 OR num=0 THEN System.nullNetworkNumber ELSE LOOPHOLE[num];»	}; -- of noNetwork    };  -- of GetMyAddress  GetNameOrAddress: PROCEDURE [prompt: LONG STRING, default: LONG STRING ¬ NIL]    RETURNS [LONG STRING] = {    help: LONG POINTER TO ODI.HelpText;    temp: LONG STRING ¬ [256];    IF DiagEtherNS.CHIsBound THEN {      help ¬ ODI.GetAHelpText[8];      help.textBody[0] ¬ prompts[nameAndAddressExpl];      help.textBody[1] ¬ ioCmdMsgs[echoNameExmpl1];      help.textBody[2] ¬ ioCmdMsgs[echoNameExmpl2];      help.textBody[3] ¬ ioCmdMsgs[echoNameExmpl3];      help.textBody[4] ¬ ioCmdMsgs[echoAddrExmpl1];      help.textBody[5] ¬ ioCmdMsgs[echoAddrExmpl2];      help.textBody[6] ¬ ioCmdMsgs[echoAddrExmpl3];      help.textBody[7] ¬ ioCmdMsgs[echoAddrExmpl4]}    ELSE {      help ¬ ODI.GetAHelpText[5];      help.textBody[0] ¬ prompts[nameAndAddressExpl];      help.textBody[1] ¬ ioCmdMsgs[echoAddrExmpl1];      help.textBody[2] ¬ ioCmdMsgs[echoAddrExmpl2];      help.textBody[3] ¬ ioCmdMsgs[echoAddrExmpl3];      help.textBody[4] ¬ ioCmdMsgs[echoAddrExmpl4]};    temp.length ¬ 0;      temp ¬ ODI.GetAString[        prompt: prompt, defaultString: default, help: help];    RETURN[temp];    };  -- of GetNameOrAddress  GetNumberOfDisplayItems: PROCEDURE RETURNS [n: CARDINAL] = {    n ¬ 10;  -- Fixed.    IF NOT DiagEtherNS.CHIsBound THEN n ¬ n - 2;      -- Domain and Organization won't be displayed.    IF properties.echoSourceType = remote THEN n ¬ n + 1;    -- Echo Source name will be displayed.    IF ~properties.echoParams.waitForResponse THEN n ¬ n + 1;    -- Not wait for Response.    };  -- of GetNumberOfDisplayItems  InitializeProps: PROCEDURE = {    properties ¬ ODI.DiagHeap.NEW[TestProperties ¬ []];    properties.domainAndOrganization ¬ ODI.DiagHeap.NEW[NameRecord ¬ []];    properties.echoSource ¬ ODI.DiagHeap.NEW[MachineIDRecord ¬ []];--    properties.echoSource.name ¬ String.MakeString[ODI.DiagHeap, maxFullNameLength];    properties.echoDest ¬ ODI.DiagHeap.NEW[MachineIDRecord ¬ []];--    properties.echoDest.name ¬ String.MakeString[ODI.DiagHeap, maxFullNameLength];    properties.localID ¬ ODI.DiagHeap.NEW[MachineIDRecord ¬ []];    properties.echoParams ¬ ODI.DiagHeap.NEW[      EchoParams ¬ [      wordContents: incrWords, constant: 170, minMsecsBetweenPackets: 100]];    properties.realTimeFeedBack ¬ TRUE;    GetMyAddress[];    };  -- Main Line CODE  InitializeProps[];  END...  LOGtime	by	action5-Feb-85 12:36:16	MXT	Created.23-Feb-85 14:55:22	MXT	Added GetDefaultDomainAndOrg to set domain and organization. 1-Mar-85 10:56:39	MXT	Added the default constant value in InitializeProps. 4-Mar-85 14:48:32	MXT	Changed the defaule value for the properties.echoParams.wordContents to allConstant instead of incrementing.10-Mar-85 15:00:37	MXT	Added  SetDomainAndOrganization in StartInitialDialogue.15-Mar-85 20:12:00	MXT	Changed to use NSString for the domainAndOrganization.17-Mar-85 18:11:54	MXT	Added DiagEtherProfile.LoginCmd in the property setting dialogue, Removed some useless codes to reduce the size and changed the initial value for the properties.echoParams.wordContents to incrementing.21-Mar-85 19:51:22	MXT	Added notLoggedIn to determine user already logged in or not.23-Mar-85 19:05:47	MXT	Added notLoggedIn initialize statement in Initialize. 8-Apr-85 19:52:22	MXT	Added allocation statement for the properties.echoDest.name in InitializeProps. 9-Apr-85 17:58:41	MXT	Removed NSName and NSString.15-May-85 18:51:57	MXT	Upgraded for Pilot 12.0 7-Jun-85 11:28:02	MXT	Changed to check if user changed echo destination/source name in SetEchoDestination & SetEchoSource.17-Oct-85 14:10:52	MXT	Changed for New Boot file.29-Jan-86 19:04:54	MXT	Commented out Profile interface. 4-Jun-86 11:17:08	MXT	Fixed address fault in SetWaitforResponse.
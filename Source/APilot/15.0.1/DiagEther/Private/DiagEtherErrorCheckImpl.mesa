-- File: DiagEtherErrorCheckImpl.mesa - last edit:-- MXT                  2-Aug-85 19:31:50-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherBasicTest,  DiagEtherCmds,  DiagEtherErrorCheck,  DiagEtherLogAndTrace,  DiagEtherIOCB,  DiagEtherIOCmdMsgs,  --DiagEtherPromptMsgs,  DiagEtherTestControl,  DiagEtherTests,  EthernetIOFaceDove,  EthernetHardFaceDove,  OfflineDiagInterface,  String;DiagEtherErrorCheckImpl: PROGRAM  IMPORTS    DiagEtherBasicTest, DiagEtherLogAndTrace, DiagEtherIOCB, DiagEtherIOCmdMsgs,  --DiagEtherPromptMsgs,     DiagEtherTestControl, DiagEtherTests, OfflineDiagInterface, String  EXPORTS DiagEtherErrorCheck =  BEGIN  OPEN DiagEtherErrorCheck, DiagEtherIOCmdMsgs,    IOFace: EthernetIOFaceDove,    HardFace: EthernetHardFaceDove,    --PromptMsgs: DiagEtherPromptMsgs,    ODI: OfflineDiagInterface;  -- ================  -- PUBLIC VARIABLEs  -- ================  Error: PUBLIC BOOLEAN;  MPCode: PUBLIC CARDINAL;  PublicErrorCheckArray: PUBLIC LONG DESCRIPTOR FOR PACKED ARRAY OF expectedStatus;  ECNull: PUBLIC PACKED ARRAY [0..1] OF expectedStatus;  ECStandard1: PUBLIC PACKED ARRAY [0..8] OF expectedStatus;  -- ================  -- GLOBAL VARIABLEs  -- ================  DataError: BOOLEAN _ FALSE;  DiagDataError: BOOLEAN _ FALSE;  -- ================  -- PUBLIC PROCEDURE  -- ================  CheckStatus: PUBLIC PROCEDURE [    errorMask: LONG DESCRIPTOR FOR PACKED ARRAY OF      DiagEtherErrorCheck.expectedStatus _ PublicErrorCheckArray,    retryOnError: BOOLEAN _ FALSE] = {    cnt: CARDINAL _ 0;    errorCode: CARDINAL _ 0;    statusPtr: DiagEtherErrorCheck.expectedStatus;    lastIOCB: LONG POINTER TO IOFace.IOCB ¬ LOOPHOLE[DiagEtherIOCB.currentIOCB];    status: IOFace.IOCBStatus;    i586Status: HardFace.Status;    status ¬ lastIOCB.status;    i586Status ¬ lastIOCB.i586Status;        Error _ FALSE;    -- return if not checking for errors    IF NOT DiagEtherTestControl.CheckForError THEN RETURN;    IF ODI.userType = Programmer AND DiagEtherTests.Switch[3] THEN {      ptr: CARDINAL _ 0;      str: STRING _ [8];      first: BOOLEAN ¬ TRUE;      yes: BOOLEAN _ FALSE;      ODI.PutMessage[        message: "STATUS SELECTION ARRAY: ", clearMessageAreaFirst: TRUE];      UNTIL ptr = LENGTH[errorMask] DO        str.length _ 0;        String.AppendNumber[str, ORD[errorMask[ptr]], 10];        ODI.PutMessage[message: str, startWithNewLine: first];        ODI.PutMessage[message: ", ", startWithNewLine: FALSE];	first ¬ FALSE;        ptr _ ptr + 1;        ENDLOOP;      UNTIL yes DO        yes _ ODI.GetYesNo[prompt: ioCmdMsgs[proceedYN]]; ENDLOOP;      };    IF ODI.userType = Programmer AND DiagEtherTests.Switch[4] THEN {      Error ¬ TRUE};    UNTIL cnt = LENGTH[errorMask] OR Error DO      ENABLE NotATDRIocb => {        Error ¬ TRUE; EXIT};            statusPtr _ errorMask[cnt];      SELECT statusPtr FROM        i586CmdAbortedTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.configure];	  IF NOT s.aborted THEN Error ¬ TRUE};        i586CmdAbortedFalse => {-- command was not aborted. Check if there is no error.	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.configure];	  IF NOT s.aborted THEN Error ¬ TRUE};	i586CompletionTrue => {IF NOT i586Status.completion THEN Error ¬ TRUE};	i586CompletionFalse => {IF i586Status.completion THEN Error ¬ TRUE};	i586BusyTrue => {IF NOT i586Status.busy THEN Error ¬ TRUE};	i586BusyFalse => {IF i586Status.busy THEN Error ¬ TRUE};	i586OkayTrue => {IF NOT i586Status.okay THEN Error ¬ TRUE};	i586OkayFalse => {IF i586Status.okay THEN Error ¬ TRUE};	        diagnoseFailedTrue => {-- Diagnose command terminated with failed status.	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.diagnose];	  IF NOT s.fail THEN Error ¬ TRUE};        diagnoseFailedFalse => {--	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.diagnose];	  IF s.fail THEN Error ¬ TRUE};        xmitNoCRSTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF NOT s.noCRS THEN Error ¬ TRUE};        xmitNoCRSFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF s.noCRS THEN Error ¬ TRUE};        xmitLossOfCTSTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF NOT s.lossOfCTS THEN Error ¬ TRUE};        xmitLossOfCTSFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF s.lossOfCTS THEN Error ¬ TRUE};        xmitUnderRunTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF NOT s.underrun THEN Error ¬ TRUE};        xmitUnderRunFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF s.underrun THEN Error ¬ TRUE};        xmitDefferedTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF NOT s.deferred THEN Error ¬ TRUE};        xmitDefferedFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF s.deferred THEN Error ¬ TRUE};        xmitSqeTestTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF NOT s.sqeTest THEN Error ¬ TRUE};        xmitSqeTestFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF s.sqeTest THEN Error ¬ TRUE};        xmitTooManyCollisionsTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF NOT s.tooManyCollisions THEN Error ¬ TRUE};        xmitTooManyCollisionsFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.command.transmit];	  IF s.tooManyCollisions THEN Error ¬ TRUE};        firmwareBusyFalse => {Error ¬ CheckGoodCompletion[]};        firmwareBusyTrue => {Error ¬ TRUE};        overrunFalse => {Error ¬ CheckGoodCompletion[]};        overrunTrue => {Error ¬ TRUE};        CRCErrorTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF NOT s.crcErr THEN Error ¬ TRUE};        CRCErrorFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF s.crcErr THEN Error ¬ TRUE};        ALNErrorTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF NOT s.alnErr THEN Error ¬ TRUE};        ALNErrorFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF s.alnErr THEN Error ¬ TRUE};        RSCErrorTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF NOT s.rscErr THEN Error ¬ TRUE};        RSCErrorFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF s.rscErr THEN Error ¬ TRUE};        OverRunErrorTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF NOT s.ovrnErr THEN Error ¬ TRUE};        OverRunErrorFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF s.ovrnErr THEN Error ¬ TRUE};        FrameTooShortTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF NOT s.frameTooShort THEN Error ¬ TRUE};        FrameTooShortFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF s.frameTooShort THEN Error ¬ TRUE};        NoEOFFlagTrue => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF NOT s.noEOFFlag THEN Error ¬ TRUE};        NoEOFFlagFalse => {	  OPEN s: LOOPHOLE[i586Status, HardFace.Status.receiveFrame];	  IF s.noEOFFlag THEN Error ¬ TRUE};        iocbDoneTrue => {	  IF NOT status.done THEN Error ¬ TRUE};        iocbDoneFalse => {	  IF status.done THEN Error ¬ TRUE};        iocbHandledTrue => {	  IF NOT status.handled THEN Error ¬ TRUE};        iocbHandledFalse => {	  IF status.handled THEN Error ¬ TRUE};        iocbOkayTrue => {	  IF NOT status.okay THEN Error ¬ TRUE};        iocbOkayFalse => {	  IF status.okay THEN Error ¬ TRUE};        iocbFrameTooLongTrue => {	  IF NOT status.frameTooLong THEN Error ¬ TRUE};        iocbFrameTooLongFalse => {	  IF status.frameTooLong THEN Error ¬ TRUE};        iocbIsDequeuedTrue => {	  IF NOT status.isDequeued THEN Error ¬ TRUE};        iocbIsDequeuedFalse => {	  IF status.isDequeued THEN Error ¬ TRUE};	  	tdrLinkOKTrue => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF NOT r.linkOK THEN Error ¬ TRUE};	tdrLinkOKFalse => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF r.linkOK THEN Error ¬ TRUE};	tdrXcvrProblemTrue => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF NOT r.xcvrProblem THEN Error ¬ TRUE};	tdrXcvrProblemFalse => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF r.xcvrProblem THEN Error ¬ TRUE};	tdrOpenTrue => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF NOT r.open THEN Error ¬ TRUE};	tdrOpenFalse => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF r.open THEN Error ¬ TRUE};	tdrShortTrue => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF NOT r.short THEN Error ¬ TRUE};	tdrShortFalse => {	  r: HardFace.TDRTestResults ¬ GetTDRResults[lastIOCB];	  IF r.short THEN Error ¬ TRUE};        cmdTimedOutFalse => {Error ¬ CheckGoodCompletion[]};        cmdTimedOutTrue => {Error ¬ TRUE};        invalidChannelFalse => {Error ¬ CheckGoodCompletion[]};        goodCompletionFalse => {Error ¬ TRUE};        goodCompletionTrue => {	  IF ODI.userType = Programmer AND DiagEtherTests.Switch[3] THEN 	    ODI.PutData[data: "LpBk Results = "L, numberAfterData: DiagEtherBasicTest.lpbkResultsPercentage];	  Error ¬ IF DiagEtherBasicTest.lpbkResultsPercentage<10 THEN TRUE ELSE FALSE};        ENDCASE;      cnt _ cnt + 1;      ENDLOOP;    IF ODI.userType = Programmer AND DiagEtherTests.Switch[3] THEN {      ODI.PutData[data: "Error ="L, numberAfterData: cnt - 1];      ODI.HitAnyKeyToContinue[]};           IF Error THEN {      -- This is DUMMY      ErrorReport[MPOffset: IF errorCode = 0 THEN ORD[statusPtr] ELSE errorCode]};    };  --CheckStatus  --   ErrorReport: PUBLIC PROCEDURE [MPOffset: CARDINAL] = {    DiagEtherLogAndTrace.LogEvent[TRUE, TRUE];    IF DiagEtherTestControl.ContinueOnError      OR DiagEtherTestControl.ReturnAfterCommand THEN RETURN;    IF DiagEtherTestControl.LoopOnError THEN RETURN;        -- call service    DiagEtherTests.CallService[0];    };  --ErrorReport--  GetTDRResults: PROC[iocb: LONG POINTER TO IOFace.IOCB] RETURNS[results: HardFace.TDRTestResults] =    BEGIN    WITH cb: iocb SELECT FROM      command => WITH c: cb.select SELECT cb.action FROM        timeDomainRfl => {	  results ¬ c.results;	  };	ENDCASE => SIGNAL NotATDRIocb;      ENDCASE => SIGNAL NotATDRIocb;    END;  NotATDRIocb: SIGNAL;    InitErrorCheck: PUBLIC PROCEDURE =    BEGIN    ECNull _ [      spare1,  -- 128      spare1];  -- 128    ECStandard1 _ [      cmdTimedOutFalse,  -- 130      overrunFalse,  --  26      CRCErrorFalse,  --  28      goodCompletionTrue, spare1, spare2, spare3, spare4, spare5];  -- 134    PublicErrorCheckArray ¬ DESCRIPTOR[ECStandard1];    END;  CheckGoodCompletion: PROCEDURE RETURNS[error: BOOLEAN ¬ FALSE] = {    RETURN[FALSE]};      CheckXmitStatus: PROCEDURE RETURNS[error: BOOLEAN ¬ FALSE] = {    RETURN[FALSE]};  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- ==============  -- MAIN LINE CODE  -- ==============  InitErrorCheck[];  END...LOG	Time		By	Action12-Feb-85 18:39:11	MXT	Created.25-Mar-85 18:32:23	MXT	Added some expectedStatus items in CheckStatus.
-- File: DiagEtherBasicTestImpl.mesa - last edit:-- KXW                         1-Jun-87 18:07:35-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.-- To release the Ethernet Diagnostics with Pilot stuff, AddressTranslation is renamed to -- DiagEtherAddressTranslation.-- When Diagnostics release become independent from Pilot/Mesa, the DiagEtherAddressTranslation-- should be resumed to use AddressTranslation interface.DIRECTORY  DiagEtherAddressTranslation,  DiagEtherBasicTest,  DiagEtherBasicTestExtras,  DiagEtherCmds,  DiagEtherEchoTest,  DiagEtherErrorMsgs,  DiagEtherIOCB,  DiagEtherIOCmdMsgs,  DiagEtherPromptMsgs,  DiagEtherTests,  Driver,  EtherMAC,  DoveInputOutput,  Environment,  EthernetFace,  EthernetIOFaceDove,  EthernetSpecialFaceDove,  Format,  Inline,  NSConstants,  NSTypes,  OfflineDiagInterface,  Process,  ProcessPriorities,  ResidentHeap,  Runtime,  SpecialRuntime,  SpecialSystem,  String,  System,  Zone;DiagEtherBasicTestImpl: MONITOR  IMPORTS    DiagEtherAddressTranslation, DiagEtherCmds, DiagEtherEchoTest,    DiagEtherErrorMsgs, DiagEtherTests, DiagEtherIOCB, DiagEtherIOCmdMsgs,    DiagEtherPromptMsgs, Driver, DoveInputOutput, EthernetFace,    EthernetSpecialFaceDove, Format, Inline, OfflineDiagInterface, Process,    ResidentHeap, SpecialRuntime, String, System  EXPORTS DiagEtherBasicTest, DiagEtherBasicTestExtras =  BEGIN  OPEN DiagEtherBasicTest, DiagEtherErrorMsgs, DiagEtherPromptMsgs,    IOFace: EthernetIOFaceDove, ODI: OfflineDiagInterface;  -- ================  -- PUBLIC Variables  -- ================  EtherDriverNotResponding: PUBLIC SIGNAL = CODE;  TestNotAcceptable: PUBLIC ERROR = CODE;  CmdOf856Failed: PUBLIC ERROR = CODE;  lpbkResultsPercentage: PUBLIC CARDINAL;  numberOfPackets: PUBLIC LONG CARDINAL;  -- ================  -- Grobal Variables  -- ================  destAddr: System.NetworkAddress ¬ System.nullNetworkAddress;  myAddr: System.NetworkAddress ¬ System.nullNetworkAddress;  -- For EthernetFace  thisDevice: EthernetFace.DeviceHandle ¬ EthernetFace.nullDeviceHandle;  inInterruptBits, outInterruptBits: WORD;  inputWait, outputWait: LONG POINTER TO CONDITION ¬ NIL;  commandIOCB: EthernetFace.ControlBlock ¬ DiagEtherIOCB.currentIOCB;  inIOCB: EthernetFace.ControlBlock ¬ NIL;  outIOCB: EthernetFace.ControlBlock ¬ NIL;  -- LONG POINTER  globalStatePtr: EthernetFace.GlobalStatePtr;  -- For Loopback Test  lpbackResults: LONG POINTER TO DiagEtherEchoTest.EchoResults ¬ NIL;  inBuffer: InputBuffer ¬ NIL;  inBufferLength: CARDINAL ¬ 128;  outBuffer: OutputBuffer ¬ NIL;    -- inBufferLength is larger than outBufferLength to hold all data.  outBufferLength: CARDINAL ¬ 64;  retries, missed: LONG CARDINAL ¬ 0;  inputDone: CONDITION;  loopBack: LoopbackType _ none;  outputDone: CONDITION;  locked: BOOLEAN ¬ FALSE;  --BOOLEANs to control test  pleaseStop, sendFinished: BOOLEAN;  packetReceived: BOOLEAN ¬ FALSE;  waitForRcvFinished: BOOLEAN ¬ FALSE;  etherDriverActive: BOOLEAN ¬ TRUE;  raiseAbortCurrentTest: BOOLEAN ¬ FALSE;  processIsRunning: BOOLEAN ¬ FALSE;  idleProcess: CONDITION;  ethernet: ARRAY EthernetFace.Status OF LONG STRING;  InputBuffer: TYPE = LONG POINTER TO InputBufferBody;  InputBufferBody: TYPE = MACHINE DEPENDENT RECORD [    alignment(0): ARRAY [0..11) OF WORD, body(11): BufferBody];  OutputBuffer: TYPE = LONG POINTER TO OutputBufferBody;  OutputBufferBody: TYPE = MACHINE DEPENDENT RECORD [    alignment(0): ARRAY [0..11) OF WORD, body(11): BufferBody];  BufferBody: TYPE = RECORD [    dest: System.HostNumber,    source: System.HostNumber,    packetType: WORD,    data: NSTypes.BufferBody];  LoopbackType: TYPE = MACHINE DEPENDENT{    none(0), onTheNet(1), internal(2), external(3)};  CoudntInitGlobalStatePtr: ERROR = CODE;  -- =========  -- Constants  -- =========  -- =================  -- PUBLIC PROCEDUREs  -- =================  «DoCmd will be used to initiate some special iocb to the ethernet driver.  For DLion, there is noway to control the ethernet driver through Mesa Interface, the ERROR TestNotAcceptable will be raised.  For Dove, the special iocb will be passed to the EthernetSpecialFaceDove.Initate. This mechanism was implemented in DoCmdInternal.»  DoCmd: PUBLIC PROCEDURE [cb: EthernetFace.ControlBlock]    RETURNS [status: EthernetFace.Status] = {    --IF etherDriverActive THEN DeactivateEthernetDriver[];    IF thisDevice = EthernetFace.nullDeviceHandle THEN {      IF ~InitEther[] THEN {        ODI.PutMessage[errors[coudntFindDeviceHandle]];        thisDevice ¬ EthernetFace.nullDeviceHandle;        --IF NOT etherDriverActive AND NOT loopBack THEN ActivateEthernetDriver[];        RETURN[otherError]};      };    -- Ok, I got device handle.     IF DiagEtherTests.thisIsDove THEN      status ¬ DoCmdInternal[        thisDevice, cb]    ELSE {      ODI.PutMessage[errors[doveOnly]];      --IF NOT etherDriverActive AND NOT loopBack THEN ActivateEthernetDriver[];      ERROR TestNotAcceptable};    IF ODI.userType = Programmer THEN      BEGIN      str: LONG STRING ¬ [80];      String.Copy[to: str, from: "Elapsed time (microsec) = "L];      String.AppendLongDecimal[        s: str,        n: System.PulsesToMicroseconds[stop] - System.PulsesToMicroseconds[start]];      ODI.PutMessage[str];      END;    SELECT status FROM      <<pending => SIGNAL EtherDriverNotResponding;      overrun => SIGNAL      underrun => SIGNAL      packetTooLong => SIGNAL      tooManyCollisions => SIGNAL      crc => SIGNAL      crcAndBadAlignment => SIGNAL      badAlignmentButOkCrc => SIGNAL>>      otherError => ERROR CmdOf856Failed;      ENDCASE;  -- ok.    --IF NOT etherDriverActive AND NOT loopBack THEN ActivateEthernetDriver[];    };  -- of DoCmd  «StartTest will be used for the loopback test.   SendAndRcv is reserved for debugging only.   »  StartTest: PUBLIC PROCEDURE [test: TestMode] RETURNS [success: BOOLEAN ¬ FALSE] =    {    --DeactivateEthernetDriver[];    IF ~InitEther[] THEN {      ODI.PutMessage[errors[coudntFindDeviceHandle]];      thisDevice ¬ EthernetFace.nullDeviceHandle;      --IF NOT etherDriverActive THEN ActivateEthernetDriver[];       RETURN[FALSE]};    loopBack _ none;    SELECT test FROM      SendAndRcv => {TurnOnEthernetHead[]; StartTestBody[]};      InternalLoopBackTest => {        loopBack _ internal;        IF ~SetUpInternalLoopBack[] THEN GOTO faultExit ELSE StartTestBody[]};      ExternalLoopBackTest => {        loopBack _ external;        IF ~SetUpExternalLoopBack[] THEN GOTO faultExit ELSE StartTestBody[]};      ENDCASE => GOTO faultExit;    --IF NOT etherDriverActive THEN ActivateEthernetDriver[];    RETURN[TRUE];    EXITS      faultExit => {        --IF NOT etherDriverActive THEN ActivateEthernetDriver[];        loopBack _ none; RETURN[FALSE]};    };  -- of StartTest  StopAll: PUBLIC PROCEDURE = {    -- This procedure will be called when ODI.AbortCurrentTest was raised.    pleaseStop ¬ TRUE; };  -- of StopAll  -- Exported procedures for the DiagEtherTestCmds  «StopExtLoopBack: PUBLIC PROCEDURE = {    IF DiagEtherTests.thisIsDove THEN {      commandIOCB ¬ LOOPHOLE[DiagEtherIOCB.AllocateIOCB[]];      ResetExternalLoopbackDove[];      DiagEtherIOCB.DeAllocateIOCB[LOOPHOLE[commandIOCB]]}    ELSE ResetExternalLoopbackDLion[];    };  StopIntLoopBack: PUBLIC PROCEDURE = {    IF DiagEtherTests.thisIsDove THEN {      commandIOCB ¬ LOOPHOLE[DiagEtherIOCB.AllocateIOCB[]];      ResetInternalLoopbackDove[];      DiagEtherIOCB.DeAllocateIOCB[LOOPHOLE[commandIOCB]]}    ELSE ResetInternalLoopbackDLion[]};»  -- ===================  -- External Procedures  -- ===================  ResetExternalLoopbackDove: PROCEDURE = {    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    cmd.op _ command[      action: configure,      select: [      configure[      byteCount: 12, internalLoopback: FALSE, externalLoopback: FALSE,      broadcastDisable: FALSE, minFrameLength: 64]]];    [] ¬ DoCmd[LOOPHOLE[cmd]];    };  ResetExternalLoopbackDLion: PROCEDURE = {};  SetUpExternalLoopBack: PROCEDURE RETURNS [ok: BOOLEAN] = {    IF ODI.userType = Programmer AND DiagEtherTests.Switch[64] THEN      SetDestAddress[]    ELSE destAddr ¬ myAddr;    commandIOCB ¬ LOOPHOLE[DiagEtherIOCB.AllocateIOCB[]];    ok ¬      IF DiagEtherTests.thisIsDove THEN SetUpExternalLoopBackDove[]      ELSE SetUpExternalLoopBackDLion[];    DiagEtherIOCB.DeAllocateIOCB[LOOPHOLE[commandIOCB]];    RETURN[ok]};  SetUpExternalLoopBackDLion: PROCEDURE RETURNS [BOOLEAN] = {RETURN[TRUE]};  SetDestAddress: PROC = {    str: LONG STRING ¬ [80];    str ¬ ODI.GetAString["Destination: "L];    [destAddr, ] ¬ DiagEtherAddressTranslation.StringToNetworkAddress[      str ! DiagEtherAddressTranslation.Error => GOTO defaultAddr];    RETURN;    EXITS      defaultAddr => {        destAddr ¬ DiagEtherEchoTest.properties.localID.address; RETURN};    };  SetUpExternalLoopBackDove: PROCEDURE RETURNS [BOOLEAN] = {    status: EthernetFace.Status ¬ pending;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    cmd.op ¬ command[      action: configure,      select: [      configure[      byteCount: 12, internalLoopback: FALSE, externalLoopback: TRUE,      broadcastDisable: TRUE, promiscuousMode: TRUE, minFrameLength: 18]]];    status ¬ DoCmd[LOOPHOLE[cmd]];    IF status # ok THEN RETURN[FALSE];    RETURN[TRUE];    };  -- of SetUpExternalLoopBack.  ResetInternalLoopbackDove: PROC = {    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    cmd.op _ command[      action: configure,      select: [      configure[      byteCount: 12, internalLoopback: FALSE, externalLoopback: FALSE,      broadcastDisable: FALSE, promiscuousMode: FALSE, minFrameLength: 64]]];    [] ¬ DoCmd[LOOPHOLE[cmd]]};  ResetInternalLoopbackDLion: PROC = {    «resetMask: CARDINAL = 177773B;    new: CARDINAL « ¬ GetEStatus[]» ;    --new ¬ LOOPHOLE[Inline.BITAND[new, resetMask]];    new ¬ 1;  -- enableReceive.    DLionInputOutput.Output[datum: new, register: EICtl];»    };  SetUpInternalLoopBack: PROCEDURE RETURNS [ok: BOOLEAN] = {    status: EthernetFace.Status ¬ pending;    commandIOCB ¬ LOOPHOLE[DiagEtherIOCB.AllocateIOCB[]];    destAddr ¬ myAddr;    status ¬      IF DiagEtherTests.thisIsDove THEN SetUpInternalLoopBackDove[]      ELSE SetUpInternalLoopBackDLion[];    DiagEtherIOCB.DeAllocateIOCB[LOOPHOLE[commandIOCB]];    IF status # ok THEN RETURN[FALSE];    RETURN[TRUE]};  SetUpInternalLoopBackDove: PROCEDURE RETURNS [status: EthernetFace.Status] = {    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    cmd.op ¬ command[      action: configure,      select: [      configure[      byteCount: 12, internalLoopback: TRUE, externalLoopback: FALSE,      broadcastDisable: TRUE, promiscuousMode: TRUE, minFrameLength: 32]]];    status ¬ DoCmd[LOOPHOLE[cmd]];    };  SetUpInternalLoopBackDLion: PROCEDURE RETURNS [EthernetFace.Status] = {    «new: CARDINAL;    turnOffMask: CARDINAL = 2;    enableRcvMask: CARDINAL = 1;    loopBackMask: CARDINAL = 8;    localLoopMask: CARDINAL = 4;    new ¬ localLoopMask + loopBackMask + enableRcvMask;    DLionInputOutput.Output[datum: new, register: EICtl];»    RETURN[ok]; };  StartTestBody: PUBLIC PROCEDURE =    BEGIN    s: EthernetFace.Status;    raiseAbortCurrentTest ¬ FALSE;    IF thisDevice = EthernetFace.nullDeviceHandle THEN RETURN;    IF lpbackResults = NIL THEN InitLpbackResults[];    -- Post message    SELECT loopBack FROM      internal => ODI.PutMessage[message: DiagEtherIOCmdMsgs.ioCmdMsgs[loopBack]];      external =>        ODI.PutMessage[message: DiagEtherIOCmdMsgs.ioCmdMsgs[commTurnAroundPlug]];      ENDCASE;    --TurnOnEthernetHead[];    pleaseStop ¬ FALSE;    sendFinished ¬ FALSE;    retries ¬ 0;    missed ¬ 0;    ODI.PutMessage[prompts[echoAbortMsg]];    pReceive ¬ FORK Receive[];    Send[];    s ¬ JOIN pReceive;    --IF NOT etherDriverActive THEN ActivateEthernetDriver[];    DumpFinalStatus[];    ShowFinalStatus[TRUE, TRUE];    CleanUp[];    loopBack ¬ none;    IF raiseAbortCurrentTest THEN {      ODI.PutMessage[message: " "L, clearMessageAreaFirst: TRUE];      SIGNAL ODI.AbortCurrentTest};          --IF DiagEtherTests.Switch[127] THEN SIGNAL ODI.AbortCurrentTest;    END;  -- of StartTestBody  pReceive: PROCESS RETURNS [stat: EthernetFace.Status];  CleanUp: PROCEDURE = {    IF inIOCB # NIL THEN {FreeIOCB[inIOCB]; inIOCB ¬ NIL};    IF outIOCB # NIL THEN {FreeIOCB[outIOCB]; outIOCB ¬ NIL};    IF lpbackResults # NIL THEN {      ODI.DiagHeap.FREE[@lpbackResults]; lpbackResults ¬ NIL};    };  ActivateEthernetDriver: PUBLIC -- Extras -- PROC =    BEGIN    network: Driver.Device;    IF etherDriverActive THEN RETURN;    network ¬ Driver.GetNthDevice[1, ethernet ! ANY => GOTO networkError];    IF network = NIL THEN RETURN;    network.activateDriver[];    etherDriverActive ¬ TRUE;    IF ODI.userType = Programmer THEN      ODI.PutMessage["Ether Driver was activated."L];    EXITS networkError => NULL;    END;  DeactivateEthernetDriver: PUBLIC -- Extras -- PROC =    BEGIN    network: Driver.Device;    IF NOT etherDriverActive THEN RETURN;    network ¬ Driver.GetNthDevice[1, ethernet ! ANY => GOTO networkError];    IF network = NIL THEN RETURN;    network.deactivateDriver[];    etherDriverActive ¬ FALSE;    IF ODI.userType = Programmer THEN      ODI.PutMessage["Ether Driver was deactivated."L];    EXITS networkError => NULL;    END;  InitLpbackResults: PROCEDURE =    BEGIN    lpbackResults ¬ ODI.DiagHeap.NEW[      DiagEtherEchoTest.EchoResults ¬ [      totalTime: 0, totalAttempts: 0, successes: 0, timeouts: 0, late: 0,      unexpected: 0, bad: 0, avgDelayInMsecs: 0, okButDribble: 0,      badAlignmentButOkCrc: 0, packetTooLong: 0, overrun: 0, idleInput: 0,      tooManyCollisions: 0, lateCollisions: 0, underrun: 0, stuckOutput: 0,      spare: 0]];    END;  InitOutputIOCB: PROCEDURE RETURNS [EthernetFace.ControlBlock] =    BEGIN    iocb: LONG POINTER TO IOFace.IOCB;    -- Outputbuffer is 16 words alligned.    outBuffer ¬ LOOPHOLE[DiagEtherTests.xmitDataPtr];    -- outBuffer.body.dest ¬ me;     outBuffer.body.dest ¬ destAddr.host;    outBuffer.body.source ¬ myAddr.host;    outBuffer.body.packetType ¬ LOOPHOLE[EtherMAC.EthernetPacketType.ns];    -- setup NSTypes.BufferBody    outBuffer.body.data.packetType ¬      IF loopBack = internal OR loopBack = external THEN private ELSE echo;    outBuffer.body.data.destination ¬ System.nullNetworkAddress;    outBuffer.body.data.source ¬ System.nullNetworkAddress;    outBuffer.body.data.transportControl _ [FALSE, 0, 0];    outBuffer.body.data.echoType _ echoRequest;    iocb ¬ LOOPHOLE[AllocateIOCB[]];    IF DiagEtherTests.thisIsDove THEN      iocb.op ¬ output[        address: DoveInputOutput.LongPointerToOpieAddress[@outBuffer.body],        length: SIZE[BufferBody], count: TRASH];    RETURN[LOOPHOLE[iocb]];    END;  InitInputIOCB: PROCEDURE RETURNS [EthernetFace.ControlBlock] =    BEGIN    iocb: LONG POINTER TO IOFace.IOCB;    inBuffer ¬ LOOPHOLE[DiagEtherTests.rcvDataPtr];    iocb ¬ LOOPHOLE[AllocateIOCB[]];    IF DiagEtherTests.thisIsDove THEN      iocb.op ¬ input[        address: DoveInputOutput.LongPointerToOpieAddress[@inBuffer.body],        length: SIZE[BufferBody], count: TRASH];    RETURN[LOOPHOLE[iocb]];    END;  AllocateIOCB: PROC RETURNS [iocb: EthernetFace.ControlBlock] = {    iocb ¬ DiagEtherIOCB.AllocateIOCB[]; };  FreeIOCB: PROC [iocb: EthernetFace.ControlBlock] = {    DiagEtherIOCB.DeAllocateIOCB[LOOPHOLE[iocb]]; };  ResetDeviceHandle: PUBLIC -- DiagEtherBasicTestExtras -- PROCEDURE = {    thisDevice ¬ EthernetFace.nullDeviceHandle};  InitEther: PROCEDURE RETURNS [status: BOOLEAN] = {    WaitProcessAvail[];    thisDevice ¬ EthernetFace.nullDeviceHandle;    thisDevice ¬ EthernetFace.GetNextDevice[thisDevice];    IF thisDevice = EthernetFace.nullDeviceHandle THEN RETURN[FALSE];    EthernetFace.AddCleanup[thisDevice];    TurnOnEthernetHead[];    RETURN[TRUE];    };  -- of InitEther.  Initialize: PROCEDURE = {    numberOfPackets ¬ 100;        [inputWait, inInterruptBits] ¬ SpecialRuntime.AllocateNakedCondition[];    [outputWait, outInterruptBits] ¬ SpecialRuntime.AllocateNakedCondition[];    Process.DisableTimeout[@idleProcess];    Process.SetTimeout[@inputDone, Process.MsecToTicks[1500]];    Process.SetTimeout[@outputDone, Process.MsecToTicks[1000]];    Process.DisableTimeout[inputWait];    Process.SetTimeout[outputWait, Process.MsecToTicks[1000]];    myAddr ¬ DiagEtherEchoTest.properties.localID.address;    IF EthernetFace.globalStateSize # 0 THEN      BEGIN      status: Zone.Status;      [globalStatePtr, status] ¬ ResidentHeap.MakeNode[        EthernetFace.globalStateSize, a8];      IF status # okay THEN RETURN WITH ERROR CoudntInitGlobalStatePtr;      END;    ethernet[pending] ¬ "pending";    ethernet[ok] ¬ "ok";    ethernet[overrun] ¬ "overrun";    ethernet[underrun] ¬ "underrun";    ethernet[packetTooLong] ¬ "packetTooLong";    ethernet[tooManyCollisions] ¬ "tooManyCollisions";    ethernet[crc] ¬ "crc";    ethernet[crcAndBadAlignment] ¬ "crcAndBadAlignment";    ethernet[badAlignmentButOkCrc] ¬ "badAlignmentButOkCrc";    ethernet[otherError] ¬ "otherError";    };  -- of Initialize.  TurnOnEthernetHead: PROCEDURE = {    EthernetFace.TurnOff[thisDevice];    EthernetFace.TurnOn[      thisDevice, LOOPHOLE[myAddr.host], inInterruptBits, outInterruptBits,      globalStatePtr];    };  ShowFinalStatus: PROC [final: BOOLEAN ¬ FALSE, clear: BOOLEAN ¬ TRUE] = {    results: LONG POINTER TO ODI.FixedPositionDisplayRecord;    promptSpaces: CARDINAL = 0;    nextPos: CARDINAL = 40;    n: CARDINAL ¬ IF final THEN 10 ELSE 9;    results ¬ ODI.GetAFixedPositionDisplayRecord[n];    results.displayTitle ¬ prompts[loopbackTestResults];    FOR i: CARDINAL IN [0..n) DO      results.rows[i] ¬ ODI.GetARow[1];      results.rows[i].rowItems[0].namePosition ¬ 0;      results.rows[i].rowItems[0].name ¬ NIL;      results.rows[i].rowItems[0].stringValue ¬ NIL;      results.rows[i].rowItems[0].valuePosition ¬ 0;      ENDLOOP;    results.rows[0].rowItems[0].namePosition ¬ promptSpaces;    results.rows[0].rowItems[0].name ¬ prompts[packetsAttempted];    results.rows[0].rowItems[0].stringValue ¬ prompts[equal];    results.rows[0].rowItems[0].valuePosition ¬      promptSpaces + results.rows[0].rowItems[0].name.length + results.rows[        0].rowItems[0].stringValue.length + 1;    results.rows[0].rowItems[0].value ¬ lpbackResults.totalAttempts;    results.rows[1].rowItems[0].namePosition ¬ promptSpaces;    results.rows[1].rowItems[0].name ¬ prompts[goodPacketsRcvd];    results.rows[1].rowItems[0].stringValue ¬ prompts[equal];    results.rows[1].rowItems[0].valuePosition ¬      promptSpaces + results.rows[1].rowItems[0].name.length + results.rows[        1].rowItems[0].stringValue.length + 1;    results.rows[1].rowItems[0].value ¬ lpbackResults.successes;    results.rows[2].rowItems[0].namePosition ¬ promptSpaces;    results.rows[2].rowItems[0].name ¬ prompts[latePackets];    results.rows[2].rowItems[0].stringValue ¬ prompts[equal];    results.rows[2].rowItems[0].valuePosition ¬      promptSpaces + results.rows[2].rowItems[0].name.length + results.rows[        2].rowItems[0].stringValue.length + 1;    results.rows[2].rowItems[0].value ¬ lpbackResults.late;    results.rows[3].rowItems[0].namePosition ¬ promptSpaces;    results.rows[3].rowItems[0].name ¬ prompts[overRun];    results.rows[3].rowItems[0].stringValue ¬ prompts[equal];    results.rows[3].rowItems[0].valuePosition ¬      promptSpaces + results.rows[3].rowItems[0].name.length + results.rows[        3].rowItems[0].stringValue.length + 1;    results.rows[3].rowItems[0].value ¬ lpbackResults.overrun;    results.rows[4].rowItems[0].namePosition ¬ promptSpaces;    results.rows[4].rowItems[0].name ¬ prompts[pktTooLong];    results.rows[4].rowItems[0].stringValue ¬ prompts[equal];    results.rows[4].rowItems[0].valuePosition ¬      promptSpaces + results.rows[4].rowItems[0].name.length + results.rows[        4].rowItems[0].stringValue.length + 1;    results.rows[4].rowItems[0].value ¬ lpbackResults.packetTooLong;    results.rows[5].rowItems[0].namePosition ¬ promptSpaces;    results.rows[5].rowItems[0].name ¬ prompts[crcError];    results.rows[5].rowItems[0].stringValue ¬ prompts[equal];    results.rows[5].rowItems[0].valuePosition ¬      promptSpaces + results.rows[5].rowItems[0].name.length + results.rows[        5].rowItems[0].stringValue.length + 1;    results.rows[5].rowItems[0].value ¬ lpbackResults.badAlignmentButOkCrc;    results.rows[6].rowItems[0].namePosition ¬ promptSpaces;    results.rows[6].rowItems[0].name ¬ prompts[unExpectedPackets];    results.rows[6].rowItems[0].stringValue ¬ prompts[equal];    results.rows[6].rowItems[0].valuePosition ¬      promptSpaces + results.rows[6].rowItems[0].name.length + results.rows[        6].rowItems[0].stringValue.length + 1;    results.rows[6].rowItems[0].value ¬ lpbackResults.unexpected;    results.rows[7].rowItems[0].namePosition ¬ promptSpaces;    results.rows[7].rowItems[0].name ¬ prompts[retries];    results.rows[7].rowItems[0].stringValue ¬ prompts[equal];    results.rows[7].rowItems[0].valuePosition ¬      promptSpaces + results.rows[7].rowItems[0].name.length + results.rows[        7].rowItems[0].stringValue.length + 1;    results.rows[7].rowItems[0].value ¬ retries;    results.rows[8].rowItems[0].namePosition ¬ promptSpaces;    results.rows[8].rowItems[0].name ¬ prompts[missed];    results.rows[8].rowItems[0].stringValue ¬ prompts[equal];    results.rows[8].rowItems[0].valuePosition ¬      promptSpaces + results.rows[8].rowItems[0].name.length + results.rows[        8].rowItems[0].stringValue.length + 1;    results.rows[8].rowItems[0].value ¬ missed;    IF final THEN {      results.rows[9].rowItems[0].namePosition ¬ promptSpaces;      results.rows[9].rowItems[0].name ¬ prompts[percentOfCorrectPackets];      results.rows[9].rowItems[0].stringValue ¬ prompts[equal];      results.rows[9].rowItems[0].valuePosition ¬        promptSpaces + results.rows[9].rowItems[0].name.length + results.rows[          9].rowItems[0].stringValue.length + 1;      lpbkResultsPercentage ¬        IF lpbackResults.totalAttempts = 0 THEN 0        ELSE Inline.LowHalf[          (lpbackResults.successes * 100) / lpbackResults.totalAttempts];      results.rows[9].rowItems[0].value ¬ lpbkResultsPercentage;      };    ODI.DisplayFixedPositionData[      displayData: results, clearDataArea: clear, upDateOnly: NOT clear];          FOR i: CARDINAL IN [0..n) DO      ODI.DiagHeap.FREE[@results.rows[i]];      ENDLOOP;    ODI.DiagHeap.FREE[@results];    };  DumpFinalStatus: PROCEDURE =    BEGIN    longPtr: LONG POINTER;    longPtr ¬ LOOPHOLE[DiagEtherTests.dumpBuffer];    longPtr­ ¬ LAST[CARDINAL] / 2;    longPtr ¬      longPtr + SIZE[DiagEtherEchoTest.EchoResults] + SIZE[        DiagEtherEchoTest.TestProperties] + 1;    --longPtr ¬ LOOPHOLE[DiagEtherTests.dumpBuffer + SIZE[DiagEtherEchoTest.EchoResults] + SIZE[DiagEtherEchoTest.TestProperties]];    Inline.LongCOPY[      from: lpbackResults, nwords: SIZE[DiagEtherEchoTest.EchoResults],      to: longPtr];    END;  -- ================  -- ENTRY PROCEDUREs  -- ================  start, stop: System.Pulses;  DoCmdInternal: ENTRY PROCEDURE [    dH: EthernetFace.DeviceHandle, cb: EthernetFace.ControlBlock]    RETURNS [status: EthernetFace.Status ¬ pending] = {    status ¬ pending;    start ¬ System.GetClockPulses[];    EthernetSpecialFaceDove.Initiate[dH, LOOPHOLE[cb]];    -- Check If the 586 executed the given command.    UNTIL status # pending DO      WAIT outputWait;      status ¬ EthernetFace.GetStatus[cb];      IF status = pending THEN GOTO cmdTimedOut;      IF CheckUserAbort[] THEN GOTO userAbort;      ENDLOOP;    stop ¬ System.GetClockPulses[];    -- Ok, 82586 was seemed to finish his work. Collect his status.    RETURN[status];    EXITS      userAbort => {        stop ¬ System.GetClockPulses[];        };      cmdTimedOut => {stop ¬ System.GetClockPulses[]; RETURN[pending]};    };  -- of DoCmdInternal  Receive: ENTRY PROCEDURE RETURNS [EthernetFace.Status] =    BEGIN    status: EthernetFace.Status;    length: CARDINAL;    lastMissed, currentMissed: CARDINAL;    first: BOOLEAN ¬ TRUE;    IF inIOCB = NIL THEN inIOCB ¬ InitInputIOCB[];    lpbackResults.successes ¬ 0;    lastMissed ¬ EthernetFace.GetPacketsMissed[thisDevice];        -- Receiving dummy    SmashInBuffer[];    [] ¬ ReceiveInternal[];    NotifyWaitInput[];    UNTIL sendFinished DO      ENABLE ABORTED => EXIT;      status ¬ pending;            SmashInBuffer[]; -- clear inBuffer first.      status ¬ ReceiveInternal[];      --IF first THEN {first ¬ FALSE; LOOP};      length ¬ EthernetFace.GetPacketLength[inIOCB];      currentMissed ¬ EthernetFace.GetPacketsMissed[thisDevice];      missed ¬ missed + currentMissed - lastMissed;      lastMissed ¬ currentMissed;      Lock[];      SELECT status FROM        ok => {          «IF loopBack = none            OR loopBack = onTheNet AND inBuffer.body.data.packetType # echo THEN            LOOP;»          IF CheckData[length] THEN {            lpbackResults.successes ¬ lpbackResults.successes + 1;            IF ODI.userType = Programmer THEN {              ODI.PutMessage[                message: "!"L, startWithNewLine: FALSE, blankSpaces: 0];	      }            }          ELSE {            lpbackResults.unexpected ¬ lpbackResults.unexpected + 1;            IF ODI.userType = Programmer THEN              ODI.PutMessage[                message: "*"L, startWithNewLine: FALSE, blankSpaces: 0]};          };        pending => {          lpbackResults.late ¬ lpbackResults.late + 1;          IF ODI.userType = Programmer THEN            ODI.PutMessage[message: "?"L, startWithNewLine: FALSE, blankSpaces: 0];          };        overrun, underrun => {          lpbackResults.overrun ¬ lpbackResults.overrun + 1;          IF ODI.userType = Programmer THEN            ODI.PutMessage[              message: ">"L, startWithNewLine: FALSE, blankSpaces: 0]};        packetTooLong => {          IF ODI.userType = Programmer THEN            ODI.PutMessage[message: "<"L, startWithNewLine: FALSE, blankSpaces: 0];          lpbackResults.packetTooLong ¬ lpbackResults.packetTooLong + 1;          };        crc, crc, crcAndBadAlignment, badAlignmentButOkCrc => {          IF ODI.userType = Programmer THEN            ODI.PutMessage[message: "%"L, startWithNewLine: FALSE, blankSpaces: 0];          lpbackResults.badAlignmentButOkCrc ¬            lpbackResults.badAlignmentButOkCrc + 1;          };        otherError => {          lpbackResults.unexpected ¬ lpbackResults.unexpected + 1;          IF ODI.userType = Programmer THEN            ODI.PutMessage[              message: "@"L, startWithNewLine: FALSE, blankSpaces: 0]};        ENDCASE;	      Release[];      NotifyWaitInput[];      ENDLOOP;    NotifyProcessAvail[];    RETURN[status];    END;  marker0, marker1: CARDINAL ¬ 0;  dataType: DiagEtherCmds.TestDataType ¬ b000000;  Send: ENTRY PROCEDURE =    BEGIN    «GetAddress: PROC RETURNS[host: System.HostNumber] = {      str: LONG STRING ¬ [256];      str ¬ ODI.GetAString["Dest HostNumber"L];      host ¬ DiagEtherAddressTranslation.StringToHostNumber[        str ! DiagEtherAddressTranslation.Error => GOTO defaultAddr];      EXITS defaultAddr => {host ¬ me};      };»    loopCounter: LONG CARDINAL ¬ numberOfPackets;    status: EthernetFace.Status;    packetLength: CARDINAL;    timedOut: BOOLEAN ¬ FALSE;        SetUpOutput: PROC = {      -- set up output buffer     IF loopBack # external THEN          FOR i: CARDINAL IN [2..outBufferLength) DO            outBuffer.body.data.nsWords[i] ¬ DiagEtherCmds.testDataArray[dataType];            ENDLOOP;        outBuffer.body.data.pktLength ¬ packetLength;        outBuffer.body.data.destination ¬ destAddr;        outBuffer.body.data.destination.socket _ NSConstants.echoerSocket;        outBuffer.body.data.source ¬ myAddr;	SELECT loopBack FROM	  internal => {	    outBuffer.body.data.nsWords[0] ¬ Inline.LowHalf[lpbackResults.totalAttempts];	    outBuffer.body.data.nsWords[1] ¬ Inline.HighHalf[lpbackResults.totalAttempts];	    };	  external => {	    outBuffer.body.data.checksum ¬ Inline.LowHalf[lpbackResults.totalAttempts];	    outBuffer.body.data.nsWords[0] ¬ 1;	    };	  ENDCASE => {	    outBuffer.body.data.nsWords[0] ¬ 1;	    outBuffer.body.data.nsWords[1] ¬ LAST[CARDINAL]}};        dataType ¬ b000000;    outBufferLength ¬ 64;    marker0 ¬ marker1 ¬ 0;    packetLength ¬      SELECT loopBack FROM        external => 18,        ENDCASE => outBufferLength + NSTypes.bytesPerIDPHeader + 7;    lpbackResults.totalAttempts ¬ 0;    IF loopBack = none OR loopBack = onTheNet THEN SetDestAddress[];    IF DiagEtherTests.Switch[29] THEN      [number: packetLength] ¬ ODI.GetANumber[        prompt: "Packet Length = "L, lowLimit: 1, upperLimit: 512,        defaultNumber: packetLength];    IF outIOCB = NIL THEN outIOCB ¬ InitOutputIOCB[];    -- Sending dummy packet    SetUpOutput[];    [] ¬ SendInternal[];    [] ¬ WaitForInput[];     UNTIL pleaseStop DO      Lock[]; -- lock lpbackResults.            IF lpbackResults.totalAttempts MOD 100 = 0 OR (ODI.userType = Programmer AND DiagEtherTests.Switch[56]) THEN        ShowFinalStatus[FALSE, lpbackResults.totalAttempts = 0];        --IF marker0 MOD 100 = 0 THEN ShowFinalStatus[FALSE, marker0 = 0];        -- setup output data buffer.        IF loopBack # external THEN          FOR i: CARDINAL IN [2..outBufferLength) DO            outBuffer.body.data.nsWords[i] ¬ DiagEtherCmds.testDataArray[dataType];            ENDLOOP;        outBuffer.body.data.pktLength ¬ packetLength;        outBuffer.body.data.destination ¬ destAddr;        outBuffer.body.data.destination.socket _ NSConstants.echoerSocket;        outBuffer.body.data.source ¬ myAddr;	SELECT loopBack FROM	  internal => {	    outBuffer.body.data.nsWords[0] ¬ Inline.LowHalf[lpbackResults.totalAttempts];	    outBuffer.body.data.nsWords[1] ¬ Inline.HighHalf[lpbackResults.totalAttempts];	    };	  external => {	    outBuffer.body.data.checksum ¬ Inline.LowHalf[lpbackResults.totalAttempts];	    outBuffer.body.data.nsWords[0] ¬ 1;	    };	  ENDCASE => {	    outBuffer.body.data.nsWords[0] ¬ 1;	    outBuffer.body.data.nsWords[1] ¬ LAST[CARDINAL];	    };        lpbackResults.totalAttempts ¬ lpbackResults.totalAttempts + 1;	sendFinished ¬ lpbackResults.totalAttempts = numberOfPackets;        status ¬ SendInternal[];        retries ¬ retries + EthernetFace.GetRetries[outIOCB];		Release[]; -- release lpbackResults; Receive process can touch it.	timedOut ¬ WaitForInput[];	Lock[];        IF timedOut THEN {          lpbackResults.late ¬ lpbackResults.late + 1;	  SmashInBuffer[];          IF ODI.userType = Programmer THEN            ODI.PutMessage[message: "?"L, startWithNewLine: FALSE, blankSpaces: 0];          };	Release[];        dataType ¬ IF dataType = other THEN b000000 ELSE SUCC[dataType];        IF DiagEtherTests.Switch[127] THEN {          IF CheckUserAbort[] THEN {pleaseStop ¬ TRUE; raiseAbortCurrentTest ¬ TRUE; loopCounter ¬ 1; EXIT}          ELSE pleaseStop ¬ lpbackResults.totalAttempts = numberOfPackets;	  }        ELSE pleaseStop ¬ CheckUserAbort[];        ENDLOOP;      «IF DiagEtherTests.Switch[127] THEN {        loopCounter ¬ loopCounter - 1; pleaseStop ¬ FALSE}      ELSE loopCounter ¬ 0;      ENDLOOP;»    sendFinished ¬ TRUE;    StopReceive[];    END;  StopReceive: PROC = {Process.EnableAborts[inputWait]; Process.Abort[pReceive]; };  StopOperation: PROC = {};  Lock: INTERNAL PROC = {    IF locked THEN WAIT outputDone    ELSE -- NOT locked      locked ¬ TRUE};  Release: INTERNAL PROC = {    locked ¬ FALSE; NOTIFY outputDone};      NotifyWaitInput: INTERNAL PROC = {packetReceived ¬ TRUE; NOTIFY inputDone};  WaitForInput: INTERNAL PROC RETURNS[timedOut: BOOLEAN] = {    count: CARDINAL ¬ 0;    packetReceived ¬ FALSE;    waitForRcvFinished ¬ TRUE;    UNTIL packetReceived OR count >= 1 DO      WAIT inputDone; count ¬ count + 1; ENDLOOP;    RETURN[NOT packetReceived];    };      WaitProcessAvail: ENTRY PROC = {    WHILE processIsRunning DO WAIT idleProcess; ENDLOOP; };  NotifyProcessAvail: INTERNAL PROC = {    processIsRunning ¬ FALSE; NOTIFY idleProcess};  -- ===================  -- INTERNAL PROCEDUREs  -- ===================  ShowPacketData: INTERNAL PROC[cls: BOOLEAN ¬ FALSE] = {    S: Format.StringProc = {ODI.PutMessage[message: s, startWithNewLine: FALSE]};    str: LONG STRING ¬ [40];    ODI.PutMessage[message: "Packet Data"L, clearMessageAreaFirst: cls];    ODI.PutMessage[" Immediate Address of packet"L];    ODI.PutMessage["  ["L];    Format.HostNumber[proc: S, hostNumber: inBuffer.body.dest, format: octal];    ODI.PutMessage[message: " <= "L, startWithNewLine: FALSE];    Format.HostNumber[proc: S, hostNumber: inBuffer.body.source, format: octal];    ODI.PutMessage["  ["L];    Format.NetworkAddress[S, inBuffer.body.data.destination, octal];    ODI.PutMessage[message: " <= "L, startWithNewLine: FALSE];    Format.NetworkAddress[S, inBuffer.body.data.source, octal];    ODI.PutMessage[message: "]"L, startWithNewLine: FALSE];    ODI.PutMessage["  PacketLength = "L];    Format.Decimal[S, inBuffer.body.data.pktLength];    ODI.PutMessage["  Buffer data:"L];    FOR i: CARDINAL IN [0..20) DO      Format.Octal[S, inBuffer.body.data.nsWords[i]];      ODI.PutMessage[message: ", "L, startWithNewLine: FALSE];      ENDLOOP;    };  CheckData: INTERNAL PROCEDURE [length: CARDINAL] RETURNS [ok: BOOLEAN ¬ FALSE] =    {    feedBack: BOOLEAN ¬ ODI.userType = Programmer;    showData: BOOLEAN ¬ DiagEtherTests.Switch[100];    IF showData THEN {      S: Format.StringProc = {ODI.PutMessage[message: s, startWithNewLine: FALSE]};      ODI.PutMessage[        message: "Received Packet Length = "L, clearMessageAreaFirst: TRUE];      Format.Decimal[S, length];      };    IF loopBack IN [internal..external]      AND inBuffer.body.data.checksum # outBuffer.body.data.checksum THEN {      IF feedBack THEN ODI.PutMessage[message: "C"L, startWithNewLine: FALSE];       IF showData THEN ShowPacketData[];      RETURN[FALSE]};    IF loopBack IN [internal..external]      AND inBuffer.body.data.destination.host # myAddr.host THEN {      IF feedBack THEN ODI.PutMessage[message: "@"L, startWithNewLine: FALSE];      IF showData THEN ShowPacketData[];      RETURN[FALSE]};    IF loopBack IN [internal..external] AND inBuffer.body.data.packetType # private      THEN {      IF feedBack THEN ODI.PutMessage["Not a private packet"L];      IF showData THEN ShowPacketData[];      RETURN[FALSE]};    IF loopBack IN [internal..internal]      AND inBuffer.body.data.source.host # myAddr.host THEN {      IF feedBack THEN ODI.PutMessage[message: "&"L, startWithNewLine: FALSE];      IF showData THEN ShowPacketData[];      RETURN[FALSE]};    IF loopBack = internal THEN      IF ~AllDataAreValid[length - NSTypes.bytesPerIDPHeader - 7] THEN {        IF feedBack THEN {          ODI.PutMessage[message: "*"L, startWithNewLine: FALSE];          ShowPacketData[]};        RETURN[FALSE]};    RETURN[TRUE];    };  AllDataAreValid: INTERNAL PROCEDURE [length: CARDINAL]    RETURNS [ok: BOOLEAN ¬ TRUE] = {    FOR i: CARDINAL IN [2..length) DO      IF inBuffer.body.data.nsWords[i] # outBuffer.body.data.nsWords[i] THEN        RETURN[FALSE];      ENDLOOP;    RETURN[TRUE]};  SmashInBuffer: INTERNAL PROCEDURE = {    inBuffer.body.data.checksum ¬ 0;    inBuffer.body.data.destination ¬ System.nullNetworkAddress;    inBuffer.body.data.source ¬ System.nullNetworkAddress;    inBuffer.body.dest ¬ System.nullNetworkAddress.host;    inBuffer.body.source ¬ System.nullNetworkAddress.host;    inBuffer.body.packetType ¬ LOOPHOLE[0];    };  CheckUserAbort: INTERNAL PROCEDURE RETURNS [userWantToAbort: BOOLEAN] = {    userWantToAbort ¬ FALSE;    ODI.LookForAbort[      ! ODI.AbortCurrentTest => {userWantToAbort ¬ TRUE; CONTINUE}]};  ReceiveInternal: INTERNAL PROCEDURE    RETURNS [status: EthernetFace.Status ¬ pending] =    BEGIN    EthernetFace.QueueInput[thisDevice, @inBuffer.body, inBufferLength, inIOCB];    «IF NOT sendFinished THEN {      WAIT inputWait; status ¬ EthernetFace.GetStatus[inIOCB];      };»          UNTIL status # pending OR sendFinished DO      WAIT inputWait; status ¬ EthernetFace.GetStatus[inIOCB]; ENDLOOP;    END;  -- of ReceiveInternal.  SendInternal: INTERNAL PROCEDURE    RETURNS [status: EthernetFace.Status ¬ pending] =    BEGIN    EthernetFace.QueueOutput[      thisDevice, @outBuffer.body, outBuffer.body.data.pktLength, outIOCB];    UNTIL status # pending DO      WAIT outputWait;      status ¬ EthernetFace.GetStatus[outIOCB];      IF status = pending THEN GOTO sendTimedOut;      ENDLOOP;    RETURN[status];    EXITS sendTimedOut => RETURN[pending];    END;  -- of SendInternal.  -- Main line.  Initialize[];  END...  LOGTime			By	Action 1-Apr-85 13:37:40	MXT	Created21-Aug-85 14:14:06	MXT	Initialize and allocate 'globalStatePtr' for New EthernetFace.TurnOn12-Sep-85 15:33:26	MXT	Changed to get correct number of missed packet.29-Jan-86 18:42:11	MXT	Renamed AddressTranslation to DiagEtherAddressTranslation.10-Mar-87 11:24:06	KXW	Corrected misspell(Fixed AR10159). 27-Apr-87 16:00:48	KXW	Modified ReceiveInternal to fix AR10297 and AR10466. 7-May-87 13:55:15	KXW	Modified Send, Receive to fix AR10791. 1-Jun-87 14:40:42	KXW	DriverTypes was replaced by EtherMAC. 1-Jun-87 18:07:06	KXW	Driver.Network was replaced by Driver.Device.
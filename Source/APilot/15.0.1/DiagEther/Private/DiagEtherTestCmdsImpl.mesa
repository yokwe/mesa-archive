-- File: DiagEtherTestCmdsImpl.mesa - last edit:-- MXT                  5-Feb-86 10:24:21-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherBasicTest USING [CmdOf856Failed, DoCmd, StartTest, TestNotAcceptable],  DiagEtherCmdDrive USING [ConfigureParametersRec, paramArrayL1, paramPtrL1],  DiagEtherCmds USING [SetTransmitDataPattern],  DiagEtherDisplay USING [DisplayStatus, DisplayStatusBuffer],  DiagEtherErrorCheck USING [ECStandard1, PublicErrorCheckArray],  DiagEtherErrorMsgs USING [errors],  DiagEtherIOCB USING [AllocateIOCB, currentIOCB],  DiagEtherMenuMsgs USING [menuMsgs],  DiagEtherPromptMsgs USING [prompts],  DiagEtherRunCmdFile USING [runningUserCmdFile],  DiagEtherTestCmds USING [],  DiagEtherTestParameters USING [configureCheckArray, diagnoseCheckArray, individualAddressCheckArray, inputCheckArray,     multicastAddrCheckArray, outputCheckArray, tdrChechArray, transmitCheckArray],  DiagEtherTests USING [CallService, thisIsDove, Switch],  DoveInputOutput USING [LongPointerToOpieAddress, OpieAddress],  EthernetFace USING [ControlBlock, controlBlockSize],  EthernetHardFaceDove USING [DumpStatusBlock, multicastIDLimit, SCBBase, TDRTestResults],  EthernetIOFaceDove USING [IOCB],  HostNumbers USING [HostNumber],  Inline  USING[HighByte, LongCOPY, LowByte],  OfflineDiagInterface USING [DiagHeap, LookForAbort, PutData, PutMessage, userType],  String USING [AppendString];DiagEtherTestCmdsImpl: PROGRAM   IMPORTS DiagEtherBasicTest, DiagEtherCmdDrive, DiagEtherCmds, DiagEtherDisplay,          DiagEtherErrorCheck, DiagEtherErrorMsgs, DiagEtherIOCB, DiagEtherMenuMsgs,          DiagEtherPromptMsgs, DiagEtherRunCmdFile, DiagEtherTestParameters, DiagEtherTests,	  DoveInputOutput, EthernetFace, Inline, OfflineDiagInterface, String  EXPORTS DiagEtherTestCmds =  BEGIN OPEN         DoveIO: DoveInputOutput,        HardFace: EthernetHardFaceDove,        IOFace: EthernetIOFaceDove,	ODI: OfflineDiagInterface,	DiagEtherPromptMsgs;         -- ================  -- GLOBAL VARIABLEs  -- ================  commandIOCB: EthernetFace.ControlBlock _ LOOPHOLE[DiagEtherIOCB.AllocateIOCB[]];  byteLength: PUBLIC CARDINAL ¬ 0;    -- =================  -- PUBLIC PROCEDUREs  -- =================  ReadStatus: PUBLIC PROCEDURE = {DumpStatus[]};      SetTimeoutCntr: PUBLIC PROCEDURE = {};  SetTransmitData: PUBLIC PROCEDURE = {    OPEN DiagEtherCmdDrive;    xmitData: CARDINAL ¬ paramArrayL1[paramPtrL1].xmitData;        DiagEtherCmds.SetTransmitDataPattern[xmitData];    };  SendPacket: PUBLIC PROCEDURE = {    };  StartIntLoopBack: PUBLIC PROCEDURE = {    -- This Procedure will send configure command with Internal Loopback = TRUE;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];        cmd.op _ command[      action: configure,      select: [configure[        byteCount: 2,	internalLoopback: TRUE]]      ];    --SetupIOCB[cmd];    -- Next, send, receive and verify data.    [] ¬ DiagEtherBasicTest.StartTest[InternalLoopBackTest];    };      StopIntLoopBack: PUBLIC PROCEDURE = {    --ResetI586[]    };  StartExtLoopBack: PUBLIC PROCEDURE = {    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];        cmd.op _ command[      action: configure,      select: [configure[        byteCount: 2,	internalLoopback: FALSE,	externalLoopback: TRUE]]      ];    [] ¬ DiagEtherBasicTest.StartTest[      IF ODI.userType = Programmer AND DiagEtherTests.Switch[123] THEN SendAndRcv       ELSE ExternalLoopBackTest];    };  StopExtLoopBack: PUBLIC PROCEDURE = {    --ResetI586[]    };    ResetI586: PROCEDURE = {    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    configParams: LONG POINTER TO DiagEtherCmdDrive.ConfigureParametersRec;        configParams _ ODI.DiagHeap.NEW[      DiagEtherCmdDrive.ConfigureParametersRec _ [        fifoLimit: 11, slotTimeLow: Inline.LowByte[256], 	slotTimeHigh: Inline.HighByte[256]]];          cmd.op _ command[      action: configure,      select: [configure[        byteCount: 12]]      ];    CopyConfigParams[cmd, configParams];    SetupIOCB[cmd];    ODI.DiagHeap.FREE[@configParams];    };  -- Following procedures are used to setup the IOCB.  Nop: PUBLIC PROCEDURE = {    -- The variant part for the NOP command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: nop;    -- cmdIOCB.select: NULL;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];        cmd.op _ command[      action: nop,      select: [nop[]]      ];    SetupIOCB[cmd];    };  IndividualAddress: PUBLIC PROCEDURE = {    OPEN DiagEtherCmdDrive;        cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];        cmd.op _ command[      action: individualAddr,      select: [individualAddr[paramArrayL1[paramPtrL1].hostNumber]]      ];    SetupIOCB[cmd];    };      Configure: PUBLIC PROCEDURE = {    OPEN DiagEtherCmdDrive;    -- The variant part for the NOP command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: configure;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    paramPtr: LONG POINTER TO ConfigureParametersRec;        paramPtr ¬ paramArrayL1[paramPtrL1].configureParams;    cmd.op _ command[      action: configure,      select: [configure[        byteCount: 12]]      ];    CopyConfigParams[cmd, paramPtr];    SetupIOCB[cmd];  };    MultiCastAddr: PUBLIC PROCEDURE = {    OPEN DiagEtherCmdDrive;    -- The variant part for the MultiCastAddr command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: multicastAddr;    -- cmdIOCB.select.byteCount: [0..16383];    -- cmdIOCB.select.multicastID: PACKED ARRAY [0..multicastIDLimit) OF HostNumbers.HostNumber    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    multicastIDs: PACKED ARRAY [0..HardFace.multicastIDLimit) OF HostNumbers.HostNumber;        FOR i: CARDINAL IN [0..HardFace.multicastIDLimit) DO      multicastIDs[i] _ paramArrayL1[paramPtrL1].multicastIDs[i];      ENDLOOP;          cmd.op _ command[      action: multicastAddr,      select: [multicastAddr[        byteCount: GetByteCount[],	multicastID: multicastIDs]]      ];    SetupIOCB[cmd];    };       Transmit: PUBLIC PROCEDURE = {    OPEN DiagEtherCmdDrive;    -- The variant part for the Transmit command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: transmit;    -- cmdIOCB.select.bdPtr: SCBBase RELATIVE POINTER TO TransmitBufferDescriptor;    -- cmdIOCB.select.destAddr: HostNumbers.HostNumber;    -- cmdIOCB.select.type: DriverTypes.EthernetPacketType;        --ODI.PutMessage["Transmit is not implemented."L];    ODI.PutMessage[prompts[transmit]];    ODI.PutMessage[message: prompts[notImplemented], startWithNewLine: FALSE];    «cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    cmd.op _ command[      action: transmit,      select: [transmit[        bdPtr: GetTBD[] «xmitBufferPtr»,	destAddr: paramArrayL1[paramPtrL1].hostNumber,	type: ns]]      ];    SetupIOCB[cmd];»    };      TimeDomainRefl: PUBLIC PROCEDURE = {    -- The variant part for the NOP command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: timeDomainRfl;    -- cmdIOCB.select.results: TDRTestResults;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    checkPt1: CARDINAL = 0;    checkPt2: CARDINAL = 0;    IF ODI.userType # Programmer THEN {      ODI.PutMessage[DiagEtherMenuMsgs.menuMsgs[tDRTest]];      ODI.PutMessage[message: prompts[notImplemented], startWithNewLine: FALSE];      RETURN};          cmd.op _ command[      action: timeDomainRfl,      select: [timeDomainRfl[        results: NULL]]      ];    SetupIOCB[cmd !      DiagEtherBasicTest.CmdOf856Failed => GOTO failed];    -- Display TDR Status.    WITH cb: cmd SELECT FROM      command => 	WITH c: cb.select SELECT cb.action FROM        timeDomainRfl => {	  str: LONG STRING ¬ [256];	  -- Link OK?	  String.AppendString[to: str, from: prompts[linkOK]];	  String.AppendString[to: str, 	    from: IF c.results.linkOK THEN prompts[yes] ELSE prompts[no]];	  ODI.PutData[data: str, startWithNewLine:TRUE, 	    clearHeadingAndData: ~DiagEtherRunCmdFile.runningUserCmdFile];	  -- Transceiver Problem?	  str.length ¬ 0;	  String.AppendString[to: str, from: prompts[xcvrProblem]];	  String.AppendString[to: str, 	    from: IF c.results.xcvrProblem THEN prompts[yes] ELSE prompts[no]];	  ODI.PutData[data: str, startWithNewLine:TRUE];	  -- Open circuit?	  str.length ¬ 0;	  String.AppendString[to: str, from: prompts[open]];	  String.AppendString[to: str, 	    from: IF c.results.open THEN prompts[yes] ELSE prompts[no]];	  ODI.PutData[data: str, startWithNewLine:TRUE];	  -- Short circuit?	  str.length ¬ 0;	  String.AppendString[to: str, from: prompts[short]];	  String.AppendString[to: str, 	    from: IF c.results.short THEN prompts[yes] ELSE prompts[no]];	  ODI.PutData[data: str, startWithNewLine:TRUE];	  -- Echoing time.	  str.length ¬ 0;	  String.AppendString[to: str, from: prompts[time]];	  ODI.PutData[data: str, 	    numberAfterData: c.results.time,	    startWithNewLine:TRUE];	  IF NOT c.results.linkOK THEN	    BEGIN	    IF c.results.xcvrProblem THEN ODI.PutMessage[DiagEtherErrorMsgs.errors[prblmOnXver]]	    ELSE	    SELECT c.results.time FROM	      IN [0..checkPt1) => {		ODI.PutMessage[DiagEtherErrorMsgs.errors[prblmOnXverCable]];};	      IN [checkPt1..checkPt2) => {		ODI.PutMessage[DiagEtherErrorMsgs.errors[prblmOnCoaxCable]];};	    ENDCASE => {};	    END;	  };	ENDCASE;      ENDCASE;          EXITS failed => {      DiagEtherTests.CallService[0]};    };nullResults: HardFace.TDRTestResults = [  linkOK: FALSE, xcvrProblem: FALSE, open: FALSE, short: FALSE,   unused: 0, time: 0];  DumpStatus: PUBLIC PROCEDURE = {    -- The variant part for the dumpStatus command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: dumpStatus;    -- cmdIOCB.select.buffer: SCBBase RELATIVE POINTER TO DumpStatusBlock;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    statusBuffer: LONG POINTER TO HardFace.DumpStatusBlock ¬ ODI.DiagHeap.NEW[HardFace.DumpStatusBlock];    oaToBuffer: DoveIO.OpieAddress;        IF DiagEtherTests.thisIsDove THEN       oaToBuffer ¬ DoveIO.LongPointerToOpieAddress[statusBuffer];        «TRICKY!!    Temporary implementation to test the function of diagnostic.    EtherTask.asm will copy the contents of HardFace.DumpStatusBlock into     user specified buffer but this mechanism is not defined expricitely.    Someday EthernetIOFaceDove should be changed.    Should redefine the EthernetIOFace and EthernetHardFaceDove?»        cmd.op ¬ output[      address: oaToBuffer,      length: 170];          cmd.op _ command[      action: dumpStatus,      select: [dumpStatus[        buffer: LOOPHOLE[oaToBuffer.A15toA0]]]      ];    SetupIOCB[cmd];    DiagEtherDisplay.DisplayStatusBuffer[statusBuffer];        ODI.DiagHeap.FREE[@statusBuffer];    };      Diagnose: PUBLIC PROCEDURE = {    -- The variant part for the NOP command.    -- cmdIOCB: command IOCB;    -- cmdIOCB.action: diagnose;    -- cmdIOCB.select: NULL;    cmd: LONG POINTER TO IOFace.IOCB = LOOPHOLE[commandIOCB];    cmd.op _ command[      action: diagnose,      select: [diagnose[]]      ];    SetupIOCB[cmd];   };     -- ==================  -- Private PROCEDUREs  -- ==================  GetNumberOfRows: PROCEDURE[cb: LONG POINTER TO IOFace.IOCB] RETURNS[number: CARDINAL] = {    number ¬ WITH c: cb SELECT FROM      command => SELECT c.action FROM        individualAddr, configure, multicastAddr => 5,        transmit => 7,	diagnose => 5,	ENDCASE => 4,      ENDCASE -- receiveFrame -- => 6;      };  GetByteCount: PROCEDURE RETURNS[CARDINAL] = {RETURN[12]};  SetupIOCB: PROCEDURE[cmdIOCB: LONG POINTER TO IOFace.IOCB] = {    OPEN DiagEtherTestParameters;    -- At here, the iocb for the DOVE will be set up so I should check if thisIsDove.    -- For the dlion, consecutive codes are nonsence.        IF ~DiagEtherTests.thisIsDove THEN RETURN WITH ERROR DiagEtherBasicTest.TestNotAcceptable;        ODI.LookForAbort[];        -- At first, setup the error status mask. This will be used in DiagEtherErrorCheck.CheckStatus.    -- All the error check mask array was initialized in DiagEtherTestParameters.Initialize.    DiagEtherErrorCheck.PublicErrorCheckArray ¬       WITH cb: cmdIOCB SELECT FROM	command =>	  SELECT cb.action FROM	    individualAddr => DESCRIPTOR[individualAddressCheckArray],	    configure => DESCRIPTOR[configureCheckArray],	    multicastAddr => DESCRIPTOR[multicastAddrCheckArray],	    diagnose => DESCRIPTOR[diagnoseCheckArray],	    transmit => DESCRIPTOR[transmitCheckArray],	    timeDomainRfl => DESCRIPTOR[tdrChechArray],	    ENDCASE => DESCRIPTOR[DiagEtherErrorCheck.ECStandard1],	output => DESCRIPTOR[outputCheckArray],	input => DESCRIPTOR[inputCheckArray],	ENDCASE => DESCRIPTOR[DiagEtherErrorCheck.ECStandard1];	          [] ¬ DiagEtherBasicTest.DoCmd[LOOPHOLE[cmdIOCB]];    --     -- copy cmdIOCB into DiagEtherIOCB.currentIOCB. This was intended to hold latest IOCB image to test the iocb items.    Inline.LongCOPY[from: cmdIOCB, nwords: EthernetFace.controlBlockSize,      to: DiagEtherIOCB.currentIOCB];    IF ODI.userType = Programmer THEN DiagEtherDisplay.DisplayStatus[];    };      CopyConfigParams: PROCEDURE[cb: LONG POINTER TO IOFace.IOCB, paramPtr: LONG POINTER TO DiagEtherCmdDrive.ConfigureParametersRec] = {    WITH iocb: cb SELECT FROM      command => WITH c: iocb.select SELECT iocb.action FROM        configure => { -- This should be changed to use Inline.LongCOPY.	  c.byteCount ¬ paramPtr.byteCount;	  c.fifoLimit ¬ paramPtr.fifoLimit;	  c.saveBadFrames ¬ paramPtr.saveBadFrames;	  c.syncReady ¬ paramPtr.syncReady;	  c.externalLoopback ¬ paramPtr.externalLoopback;	  c.internalLoopback ¬ paramPtr.internalLoopback;	  c.preambleLength ¬ SELECT paramPtr.preambleLength FROM 	    two => two, four => four, eight => eight, sixteen => sixteen, ENDCASE => eight;	  c.addrTypeLoc ¬ SELECT paramPtr.addrTypeLoc FROM	    desc => desc, buffer => buffer, ENDCASE => desc;	  c.addrLength ¬ paramPtr.addrLength;	  c.expBackoffMethod ¬ SELECT paramPtr.expBackoffMethod FROM	    ethernet => ethernet, alternate => alternate, ENDCASE => ethernet;	  c.accContRes ¬ paramPtr.accContRes;	  c.linearPriority ¬ paramPtr.linearPriority;	  c.interframeSpacing ¬ paramPtr.interframeSpacing;	  c.slotTimeLow ¬ paramPtr.slotTimeLow;	  c.retryNumber ¬ paramPtr.retryNumber;	  c.slotTimeHigh ¬ paramPtr.slotTimeHigh;	  c.padding ¬ paramPtr.padding;	  c.bitstuffing ¬ paramPtr.bitstuffing;	  c.CRC16 ¬ paramPtr.CRC16;	  c.noCRCInsertion ¬ paramPtr.noCRCInsertion;	  c.txNoCRS ¬ paramPtr.txNoCRS;	  c.NRZEncoding ¬ paramPtr.NRZEncoding;	  c.broadcastDisable ¬ paramPtr.broadcastDisable;	  c.promiscuousMode ¬ paramPtr.promiscuousMode;	  c.internalCDT ¬ paramPtr.internalCDT;	  c.CDTFilter ¬ paramPtr.CDTFilter;	  c.internalCRS ¬ paramPtr.internalCRS;	  c.CRSFilter ¬ paramPtr.CRSFilter;	  c.minFrameLength ¬ paramPtr.minFrameLength;	  };	ENDCASE;      ENDCASE;      }; -- of CopyConfigParams  END...    LOGTime		By	Action17-Jan-85 10:15:41	MXT	Created. 1-Mar-85 17:48:40	MXT	Added DisplayIOCBStatus and DisplayI586Status. 7-Mar-85 12:16:18	MXT	Added Display TDR Status in TimeDomainRefl.22-Mar-85 12:22:55	MXT  Reduced some codes. 9-Apr-85 17:45:44	MXT	Removed DisplayIOCBStatus.12-Apr-85 18:39:01	MXT	Changed for New DiagEtherBasicTest.23-Apr-85 16:09:21	MXT	Removed DriverTypes17-May-85 10:09:21	MXT	Assigned Status dump buffer address correctly. 3-Jun-85 19:48:14	MXT	Added Inline.LongCOPY to copy from cmdIOCB to currentIOCB in proc SetupIOCB.
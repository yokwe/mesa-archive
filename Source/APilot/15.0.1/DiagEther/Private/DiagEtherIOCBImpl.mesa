-- File: DiagEtherIOCBImpl.mesa - last edit:-- MXT                 19-Aug-85 17:51:52-- File: IOCBImpl.mesa - last edit:-- MXT                  2-Jul-85 10:57:17-- File: DiagEtherIOCBImpl.mesa - last edit:-- MXT                 26-Jun-85 15:45:54-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  CommUtil USING [AllocateIocbs],  DiagEtherIOCB,  EthernetFace ,  EthernetIOFaceDove USING [IOCB, IOCBStatus, IOCBType],  Heap USING [systemZone];  DiagEtherIOCBImpl: PROGRAM   IMPORTS CommUtil, EthernetFace, Heap  EXPORTS DiagEtherIOCB =  BEGIN OPEN IOCB: DiagEtherIOCB,    IOFace: EthernetIOFaceDove;    currentIOCB: PUBLIC EthernetFace.ControlBlock;  iocbs: LONG POINTER TO Iocbs;  Iocbs: TYPE = RECORD[    iocb: EthernetFace.ControlBlock ¬ NIL,    next: LONG POINTER TO Iocbs ¬ NIL,    avail: BOOLEAN ¬ TRUE];      iocbCnt: CARDINAL ¬ 6;    AllocateIOCB: PUBLIC PROCEDURE RETURNS[iocb: EthernetFace.ControlBlock] = {    --iocb ¬ CommUtil.AllocateIocbs[EthernetFace.controlBlockSize];    temp: LONG POINTER TO Iocbs ¬ iocbs;        THROUGH [0..iocbCnt - 1) DO      IF temp.avail THEN {        iocb ¬ temp.iocb; temp.avail ¬ FALSE; EXIT}      ELSE         IF temp.next = NIL THEN GOTO noIocbAvailable        ELSE {	  temp ¬ temp.next;};      ENDLOOP;        RETURN[iocb];        EXITS noIocbAvailable => RETURN[NIL];          «status: Zone.Status;    p: Zone.Base RELATIVE POINTER;    [p, status] _ ResidentHeap.MakeNode[EthernetFace.controlBlockSize, a16];    IF status # okay THEN RETURN[NIL];    iocb _ @ResidentHeap.first64K[p];»    };  DeAllocateIOCB: PUBLIC PROCEDURE[iocb: EthernetFace.ControlBlock] = {    temp: LONG POINTER TO Iocbs ¬ iocbs;        THROUGH [0..iocbCnt - 1) DO      IF temp.iocb = iocb THEN {        temp.avail ¬ TRUE}      ELSE IF temp.next = NIL THEN EXIT        ELSE temp ¬ temp.next;      ENDLOOP;          --CommUtil.FreeIocbs[iocb];   « p: Zone.Base RELATIVE POINTER _ Inline.LowHalf[      iocb - LOOPHOLE[ResidentHeap.first64K, LONG POINTER]];    [] _ ResidentHeap.FreeNode[p];»    };	 « GetIOCBStatus: PUBLIC PROCEDURE RETURNS[status: IOFace.IOCBStatus] = {    -- RETURN[currentIOCB.status];    status _ nullIOCBStatus;    }; -- of GetIOCBStatus.»    <<SetUpIOCB: PUBLIC PROCEDURE[op: EthernetIOFaceDove.IOCBType] = {        IF op = command THEN IOCB.commandIOCB.action ¬cmd;    SELECT op FROM      input => {inputIOCB.address.type ¬ MapAddrType[          ! invalidAddressType => {	    inputIOCB.address.type ¬ nil; CONTINUE}];        iocb ¬ inputIOCB};      output => {outputIOCB.address.type ¬ MapAddrType[          ! invalidAddressType => {	    outputIOCB.address.type ¬ nil; CONTINUE}];        iocb ¬ outputIOCB};      ENDCASE -- command -- => iocb ¬ commandIOCB;          };>>    «SetUpCmdIOCB: PUBLIC PROCEDURE[op: IOFace.IOCBType, cmd: HardFace.ActionCommand, select: HardFace.CommandSelect]      RETURNS[iocb: IOCB.IOCBPtr] = {      tempIOCB: command IOFace.IOCB;      iocb ¬ AllocateIOCB[]; -- At first, allocate IOCB.      tempIOCB.action ¬ cmd;      tempIOCB.select ¬ select;      };»          Init: PROCEDURE = {    «currentIOCB ¬ LOOPHOLE[AllocateIOCB[]];»    --currentIOCB holds real iocb image.    --iocb: LONG POINTER TO EthernetIOFaceDove.IOCB;    prev: LONG POINTER TO Iocbs;    --iocb ¬ OfflineDiagInterface.DiagHeap.NEW[EthernetIOFaceDove.IOCB];    --iocbs ¬ OfflineDiagInterface.DiagHeap.NEW[Iocbs];   iocbs ¬ Heap.systemZone.NEW[Iocbs];   currentIOCB ¬ LOOPHOLE[Heap.systemZone.NEW[EthernetIOFaceDove.IOCB]];        iocbs.iocb ¬ CommUtil.AllocateIocbs[EthernetFace.controlBlockSize * iocbCnt];    prev ¬ iocbs;    THROUGH [0..iocbCnt - 1) DO      temp: LONG POINTER TO Iocbs ¬ Heap.systemZone.NEW[Iocbs ¬ []];      --temp: LONG POINTER TO Iocbs ¬ OfflineDiagInterface.DiagHeap.NEW[Iocbs ¬ []];      prev.next ¬ temp;      temp.iocb ¬ prev.iocb + EthernetFace.controlBlockSize;      temp.avail ¬ TRUE;      prev ¬ temp;      --REPEAT FINISHED => {      --  prev.next ¬ NIL;};      ENDLOOP;    --iocb.next ¬ DIO.nilOpieAddress;    --iocb.clientCondition ¬ IOCB.nullCondition;   --currentIOCB.i586Status ¬ TRASH;    --iocb.status ¬ IOCB.nullStatus;    --currentIOCB ¬ LOOPHOLE[iocb];    };        -- ==============  -- Main line code  -- ==============    Init[];  END...    LOG  Time			By	Action   4-Jan-85 11:20:11	MXT	Creation.   25-Feb-85 15:17:12	MXT	Added Copyright Notice.   25-Apr-85 16:13:08	MXT	Changed AllocationIOCB to allocate iocb into first 64K of VM correctly.   15-May-85 18:55:04	MXT	Changed to use CommUtil interface to allocate iocb.   26-Jun-85 15:42:41	MXT	Removed unused codes.
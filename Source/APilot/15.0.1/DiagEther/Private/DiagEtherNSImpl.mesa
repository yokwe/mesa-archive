-- File: DiagEtherNSImpl.mesa - last edit:-- STC   9-Oct-87 16:19:06-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.  -- Many NS related statements are commented out to reduce the code size. -- Someday NS configs can be bound with diagnostics, these statements can be used to get-- default echo destination server.DIRECTORY  --AuthSpecial USING [MakeNullCHConversation],  CH USING [«ConversationHandle, Enumerate, FreeConversationHandle,» MakeRhs «, NameStreamProc, ReturnCode»],  --CHCommonLookups USING [LookupAddress],  --CHEntriesExtras USING [server],  DiagEtherEchoTest USING [properties],  DiagEtherNS USING [],  DiagEtherPromptMsgs USING [prompts],  Format,   Inline,   NSBuffer,--  NSName USING [Name, NameRecord, String],--  NSString USING [AppendToMesaString, String, StringFromMesaString],  OfflineDiagInterface USING [AbortCurrentTest, DiagHeap, LookForAbort, PutMessage],  Process USING [MsecToTicks, Pause, SetTimeout, SecondsToTicks],  Runtime  USING[GlobalFrame, IsBound --, UnboundProcedure --],  SpecialCommunication,  String USING [AppendChar, AppendString, Copy, MakeString],  System USING [GetGreenwichMeanTime, GreenwichMeanTime, NetworkAddress, nullNetworkAddress];DiagEtherNSImpl: MONITOR  IMPORTS     «AuthSpecial,» CH, «CHCommonLookups,» DiagEtherEchoTest, DiagEtherPromptMsgs, Format, Inline,     «NSString,» OfflineDiagInterface, Process, Runtime,     SpecialCommunication, String, System  EXPORTS DiagEtherNS =  BEGIN  OPEN DiagEtherPromptMsgs,    ODI: OfflineDiagInterface,    DiagEtherEchoTest;   MachineTypes: TYPE = MACHINE DEPENDENT {dlion(0), dove(1), kiku(2), others(3)};  machineIDMasks: ARRAY MachineTypes OF MachineIDType = [dlion: [a: 0, b: 125000B, c: 0], dove: [a: 0, b: 125101B, c: 0],    kiku: [a: 4000B, b: 33400B, c: 0], others: [a: 0, b: 0, c: 0]];  MachineIDType: TYPE = RECORD[a, b, c: CARDINAL];  CHIsBound: PUBLIC BOOLEAN ¬ FALSE;    StartCHStub: PUBLIC ENTRY PROCEDURE =     BEGIN    frame: PROGRAM;        IF NOT (Runtime.IsBound[LOOPHOLE[CH.MakeRhs]]) THEN {GOTO noCHStub}    	ELSE {frame ¬ Runtime.GlobalFrame[LOOPHOLE[CH.MakeRhs]];    	      CHIsBound _ TRUE;   	      START frame;};       Process.Pause[Process.MsecToTicks[3000]];    EXITS      noCHStub => CHIsBound _ FALSE;    END;  Spy: SpecialCommunication.SpyProc = {    IF b.fo.type # ns THEN RETURN[b];    destCandidate ¬ LOOPHOLE[b, NSBuffer.Buffer].ns.source;    NotifyWatcher[];    RETURN[b];    };      NotifyWatcher: ENTRY PROC =    BEGIN     IF wait THEN {wait ¬ FALSE; NOTIFY spy};    END;  destCandidate: System.NetworkAddress ¬ System.nullNetworkAddress;  spy: CONDITION;  wait: BOOLEAN ¬ FALSE;  VerifyNetworkAddress: INTERNAL PROCEDURE[addr: System.NetworkAddress] RETURNS[ok: BOOLEAN ¬ FALSE] =    BEGIN    temp: MachineIDType ¬ LOOPHOLE[destCandidate.host, MachineIDType];        IF addr = System.nullNetworkAddress THEN RETURN[FALSE];    IF addr.net#properties.localID.address.net THEN RETURN[FALSE];    ok ¬ FALSE;    FOR machine: MachineTypes IN [dlion..others) DO      ok ¬ Inline.BITAND[machineIDMasks[machine].b, temp.b] # 0;      IF ok THEN RETURN[ok];      ENDLOOP;    RETURN[FALSE];    END;    GetNearestServer: PUBLIC ENTRY PROCEDURE RETURNS[ok: BOOLEAN ¬ FALSE] =     BEGIN    S: Format.StringProc = {String.AppendString[to: str, from: s]};    str: LONG STRING ¬ [256];    enterTime, currentTime: System.GreenwichMeanTime;    timeExpired: BOOLEAN ¬ FALSE;    prevCandidate: System.NetworkAddress ¬ destCandidate;        ODI.PutMessage[prompts[gettingNetAddr]];    destCandidate ¬ System.nullNetworkAddress;    enterTime ¬ System.GetGreenwichMeanTime[];        [] ¬ SpecialCommunication.SetSpyProc[Spy, ns];        UNTIL ok OR timeExpired DO      wait ¬ TRUE;      WAIT spy;      IF destCandidate # prevCandidate THEN {	IF VerifyNetworkAddress[destCandidate] THEN {	  properties.echoDest.address ¬ destCandidate;	  str.length ¬ 0;	  Format.NetworkNumber[S, destCandidate.net, productSoftware];	  String.AppendChar[s: str, c: '.];	  Format.HostNumber[S, destCandidate.host, productSoftware];	  String.AppendChar[s: str, c: '.];	  String.AppendString[to:str, from: " = "L];	  Format.NetworkNumber[S, destCandidate.net, octal];	  String.AppendChar[s: str, c: '.];	  Format.HostNumber[S, destCandidate.host, octal];	  String.AppendChar[s: str, c: '.];	  String.AppendString[to:str, from: " = "L];	  Format.NetworkNumber[S, destCandidate.net, hex];	  String.AppendChar[s: str, c: '.];	  Format.HostNumber[S, destCandidate.host, hex];	  String.AppendChar[s: str, c: '.];	  IF properties.echoDest.name = NIL THEN 	    properties.echoDest.name ¬ String.MakeString[ODI.DiagHeap, str.length];	  String.Copy[to: properties.echoDest.name, from: str];	  ok ¬ TRUE}	ELSE ok ¬ FALSE;      };      currentTime ¬ System.GetGreenwichMeanTime[];      timeExpired ¬ (currentTime - enterTime) > LOOPHOLE[30];      ODI.LookForAbort[! ODI.AbortCurrentTest => EXIT];    ENDLOOP;        IF timeExpired AND prevCandidate # System.nullNetworkAddress THEN {      destCandidate ¬ prevCandidate; ok ¬ TRUE};          [] ¬ SpecialCommunication.SetSpyProc[NIL, ns];        IF ok THEN String.Copy[to: str, from: prompts[done]]    ELSE IF timeExpired THEN String.Copy[to: str, from: prompts[failed]]      ELSE String.Copy[to: str, from: prompts[aborted]];        ODI.PutMessage[      message: str,       startWithNewLine: FALSE];        «rc: CH.ReturnCode;    dest: LONG STRING ¬ String.MakeString[ODI.DiagHeap, NSName.maxLocalLength];    addr: System.NetworkAddress;        -- Show message    ODI.PutMessage[message: prompts[gettingNetAddr]];        [rc, addr] ¬ FindEchoDestination[dest];    -- Found name will be filled into dest.    IF rc.code # done THEN {      DiagEtherPutErrorMsgs.PutCHLookupProblem[rc];      UNTIL ODI.GetYesNo[prompts[proceeding]] DO ENDLOOP;      ok ¬ FALSE}    ELSE {      ok ¬ addr # System.nullNetworkAddress;      properties.echoDest.address ¬ addr;      IF properties.echoDest.name=NIL THEN         properties.echoDest.name ¬ String.MakeString[ODI.DiagHeap, dest.length];      properties.echoDest.name.length ¬ 0;      String.AppendString[to: properties.echoDest.name, from: dest]};        String.FreeString[ODI.DiagHeap, dest];    RETURN[ok];»    END; -- of GetNearestServer.  «FindEchoDestination: PROC[destName: LONG STRING] RETURNS[rc: CH.ReturnCode, addr: System.NetworkAddress] = {    conversationH: CH.ConversationHandle;    success: BOOLEAN;    nsName: NSName.Name ¬ @pattern;    pattern: NSName.NameRecord ¬ [];    wildCard: CHARACTER = '*;    firstChar: CARDINAL ¬ ORD['A];    matchPattern: LONG STRING ¬ [2];    found: BOOLEAN ¬ FALSE;        GetAddress: CH.NameStreamProc = {      -- fill in the destination name.      destName.length ¬ 0;      NSString.AppendToMesaString[to: destName, from: currentName.local];      -- get a network address for the destination.      [rc, addr, success] ¬ CHCommonLookups.LookupAddress[	conversation: conversationH,	name: currentName];      IF NOT success THEN addr ¬ System.nullNetworkAddress};          nsName.domain ¬ NSString.StringFromMesaString[properties.domainAndOrganization.domain];    nsName.org ¬ NSString.StringFromMesaString[properties.domainAndOrganization.org];    conversationH ¬ AuthSpecial.MakeNullCHConversation[ODI.DiagHeap];        WHILE firstChar IN [ORD['A]..ORD['Z]] DO      matchPattern.length ¬ 0;      String.AppendChar[s: matchPattern, c: VAL[firstChar]];      String.AppendChar[s: matchPattern, c: wildCard];      nsName.local ¬ NSString.StringFromMesaString[matchPattern];      -- get first distinguished name.      rc ¬ CH.Enumerate[	conversation: conversationH,	name: nsName,	pn: CHEntriesExtras.server,	eachName: GetAddress];	      IF rc.code = done AND success THEN EXIT;            firstChar ¬ SUCC[firstChar];      ENDLOOP;        CH.FreeConversationHandle[@conversationH, ODI.DiagHeap];    };»      Process.SetTimeout[@spy, Process.SecondsToTicks[30]]; -- 30 sec timeout.      END...LOG16-Apr-85 13:35:41: MXT	Created 6-Jun-85 20:14:05	MXT	Used new algorithm to get default echo destination faster.14-Jun-85 10:07:38	MXT	Merged StartCHStub. 2-Jun-87 15:21:12	KXW	Modified Spy for 14.0. 9-Oct-87 16:17:04, STC, workaround on a bug in Runtime.UnboundedProcedure
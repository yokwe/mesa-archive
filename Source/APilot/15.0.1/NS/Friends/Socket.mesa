-- File: Socket.mesa - last edit:-- AOF                 18-Aug-86 17:37:33-- SMA                 23-May-86 16:59:15-- Copyright (C) 1984, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [ReturnBuffer],  Environment USING [Byte],  NSBuffer USING [AccessHandle, Buffer],  NSTypes USING [PacketType, WaitTime],  System USING [NetworkAddress, SocketNumber];Socket: DEFINITIONS  IMPORTS Buffer =  BEGIN  -- Our types  ChannelHandle: TYPE[2];  nullChannelHandle: READONLY ChannelHandle;    -- copied TYPEs  Byte: TYPE = Environment.Byte;  NetworkAddress: TYPE = System.NetworkAddress;  SocketNumber: TYPE = System.SocketNumber;  WaitTime: TYPE = NSTypes.WaitTime; -- msecs  -- DEFINITIONS  SocketStatus: TYPE = RECORD[    localAddr: NetworkAddress, incompleteGets: CARDINAL];  -- CONSTANTS USED BY THE CLIENT  uniqueNetworkAddr: READONLY NetworkAddress;  defaultWaitTime: WaitTime = 60000; -- msecs  infiniteWaitTime: WaitTime = LAST[WaitTime];  -- PROCS  AssignNetworkAddress: PROC[] RETURNS [NetworkAddress];  GetAssignedAddress: PROC[cH: ChannelHandle] RETURNS [NetworkAddress];  GetBufferPool: PROC[cH: ChannelHandle] RETURNS [NSBuffer.AccessHandle];  Create: PROC[    socket: SocketNumber,  --will be used as source address when sending    send: CARDINAL ¬ 1,  --limits number of buffers acquired for sending    receive: CARDINAL ¬ 2, --limits how many input buffers will be queued    type: NSTypes.PacketType ¬ private]  --possible filtering by socket    RETURNS [ChannelHandle];  Delete: PROC[cH: ChannelHandle];  GetStatus: PROC[cH: ChannelHandle] RETURNS [SocketStatus];  SetWaitTime: PROC[cH: ChannelHandle, time: WaitTime];  --NOTE:  sending and receiving packets - they are in real buffers      --all gets wait for a packet to arrive or TimeOut.  GetPacket: PROC[cH: ChannelHandle] RETURNS [b: NSBuffer.Buffer];  --puts are asynchronous  PutPacket: PROC[cH: ChannelHandle, b: NSBuffer.Buffer];  <<  This procedure broadcast a packet to all hosts on all locally connected  nets. The user only need supply the destination socket number of the packet.  Actual transmission could take a while, but the client will get control back  almost immediately.  >>  BroadcastPacketToAllConnectedNets: PROC[cH: ChannelHandle, b: NSBuffer.Buffer];  -- ERRORS  TimeOut: ERROR; -- error when timeout ocurrs on blocked call like TransferWait  DuplicateSocket: ERROR;  --that address/packet type already exists.=  -- UTILITIES  LocalAddressFromSocket: PROC[SocketNumber] RETURNS [NetworkAddress];  BroadcastAddressFromSocket: PROC[SocketNumber] RETURNS [NetworkAddress];  FixupUnknownSocketNumber: PROC[    LONG POINTER TO NetworkAddress, SocketNumber];  GetSendBuffer: PROC[ChannelHandle] RETURNS [NSBuffer.Buffer];  ReturnBuffer: PROC[b: NSBuffer.Buffer] = INLINE    {Buffer.ReturnBuffer[LOOPHOLE[b]]};    SwapSourceAndDestination: PROC[NSBuffer.Buffer];  GetSource: PROC[NSBuffer.Buffer] RETURNS [NetworkAddress];  GetDestination: PROC[NSBuffer.Buffer] RETURNS [NetworkAddress];  SetDestination: PROC[NSBuffer.Buffer, NetworkAddress];    GetPacketBytes: PROC[NSBuffer.Buffer] RETURNS [CARDINAL];  SetPacketWords: PROC[NSBuffer.Buffer, CARDINAL];  SetPacketBytes: PROC[NSBuffer.Buffer, CARDINAL];  END.LOG14-May-84 13:09:51  AOF  Post Klamath
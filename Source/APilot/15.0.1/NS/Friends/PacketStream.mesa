-- File: PacketStream.mesa - last edit:-- AOF                 15-Aug-86  9:25:04-- Copyright (C) 1983, 1986 by Xerox Corporation. All rights reserved. -- Function: The internal definitions module for Pilot Packet Streams.DIRECTORY  Environment USING [Byte],  NSBuffer USING [Buffer],  NSTypes USING [bytesPerIDPHeader, bytesPerSppHeader, ConnectionID],  NetworkStream USING [    defaultWaitTime, FailureReason, SuspendReason, WaitTime, ClassOfService],  System USING [NetworkAddress];PacketStream: DEFINITIONS  IMPORTS NetworkStream =  BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    destroy: PROC[psH: Handle],    put: PROC [NSBuffer.Buffer],    get: PROC RETURNS [NSBuffer.Buffer],    waitForAttention: PROC RETURNS [Environment.Byte],    setWaitTime: PROC [WaitTime],    findAddresses: PROC RETURNS [local, remote: System.NetworkAddress],    getSenderSizeLimit: PROC RETURNS [CARDINAL],    setSenderSizeLimit: PROC [size: CARDINAL],    getSendBuffer: PROC RETURNS [NSBuffer.Buffer],    returnSendBuffer: PROC [NSBuffer.Buffer],    returnReceiveBuffer: PROC [NSBuffer.Buffer],    getState: PROC RETURNS[State],    setState: PROC [newState: State]];  unknownConnID: NSTypes.ConnectionID = [0];  Byte: TYPE = Environment.Byte;  bytesPerSequencedPktHeader: CARDINAL = NSTypes.bytesPerSppHeader +    NSTypes.bytesPerIDPHeader;  WaitTime: TYPE = NetworkStream.WaitTime;  ClassOfService: TYPE = NetworkStream.ClassOfService;  defaultWaitTime: WaitTime = NetworkStream.defaultWaitTime;  infiniteWaitTime: READONLY WaitTime;  State: TYPE = {active, inactive};  SuspendReason: TYPE = NetworkStream.SuspendReason;  FailureReason: TYPE = NetworkStream.FailureReason;  ConnectionSuspended: ERROR [why: SuspendReason];  ConnectionFailed: SIGNAL [why: FailureReason];  InvalidPacketSize: ERROR;  Make: PROC [    local, remote: System.NetworkAddress, localConnID, remoteConnID:     NSTypes.ConnectionID, establishConnection: BOOLEAN,     timeout: WaitTime ¬ defaultWaitTime, classOfService: ClassOfService]     RETURNS [Handle];  GetUniqueConnectionID: PROC RETURNS [iD: NSTypes.ConnectionID];  Destroy: PROC [psH: Handle] = INLINE {psH.destroy[psH]};  Put: PROC [psH: Handle, p: NSBuffer.Buffer] = INLINE {psH.put[p]};  Get: PROC [psH: Handle] RETURNS [NSBuffer.Buffer] = INLINE    {RETURN[psH.get[]]};  WaitForAttention: PROC [psH: Handle] RETURNS [Environment.Byte] = INLINE    {RETURN[psH.waitForAttention[]]};  SetWaitTime: PROC [psH: Handle, time: WaitTime] = INLINE    {psH.setWaitTime[time]};  FindAddresses: PROC [psH: Handle]    RETURNS [local, remote: System.NetworkAddress] = INLINE    {[local, remote] ¬ psH.findAddresses[]};  GetSendBuffer: PROC [psH: Handle] RETURNS [NSBuffer.Buffer] = INLINE {    RETURN[psH.getSendBuffer[]]};  ReturnSendBuffer: PROC [psH: Handle, p: NSBuffer.Buffer] = INLINE {    psH.returnSendBuffer[p]};  ReturnReceiveBuffer: PROC [psH: Handle, p: NSBuffer.Buffer] = INLINE    {psH.returnReceiveBuffer[p]};      GetSenderSizeLimit: PROC [psH: Handle] RETURNS [CARDINAL] = INLINE    {RETURN[psH.getSenderSizeLimit[]]};  SetSenderSizeLimit: PROC [psH: Handle, size: CARDINAL] = INLINE    {psH.setSenderSizeLimit[size]};  GetState: PROC [psH: Handle] RETURNS [State] = INLINE {RETURN[psH.getState[]]};  SetState: PROC [psH: Handle, newState: State] = INLINE {psH.setState[newState]};  -- connection table routines  ConnectionAlreadyThere: PROC [    remote: System.NetworkAddress, remoteConnID: NSTypes.ConnectionID]    RETURNS [BOOLEAN];  END.LOG15-Aug-86  9:24:21 AOF Trimmed.15-Aug-86  9:24:22 PacketStream.Handle now LONG POINTER TO ...
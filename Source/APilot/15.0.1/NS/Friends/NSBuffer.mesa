-- File: NSBuffer.mesa - last edit:-- AOF                 19-Aug-86 10:18:32-- SMA                 22-May-86 15:30:43-- MI                  21-Mar-86 11:42:16-- Copyright (C) 1984, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer,  Environment USING [Block],  NSTypes USING [BufferBody, maxIDPBytesPerPacket];NSBuffer: DEFINITIONS IMPORTS Buffer =  BEGIN OPEN B: Buffer;  -- QUEUES  Queue: TYPE = B.Queue;  QueueObject: TYPE = B.QueueObject;  Enqueue: PROC[q: B.Queue, b: Buffer] =    INLINE {B.Enqueue[q, LOOPHOLE[b]]};  Dequeue: PROC[q: B.Queue] RETURNS [Buffer] =    INLINE {RETURN[LOOPHOLE[B.Dequeue[q]]]};  ExtractFromQueue: PUBLIC PROC[q: B.Queue, b: Buffer] RETURNS [Buffer] =    INLINE {RETURN[LOOPHOLE[B.ExtractFromQueue[q, LOOPHOLE[b]]]]};  QueueLength: PROC[q: B.Queue] RETURNS [CARDINAL] =    INLINE {RETURN[q.length]};  QueueEmpty: PROC[q: B.Queue] RETURNS [BOOLEAN] =    INLINE {RETURN[q.length = 0]};  QueueInitialize: PROC[q: B.Queue] =    INLINE {B.QueueInitialize[q]};  QueueCleanup: PROC[q: B.Queue] =    INLINE {B.QueueCleanup[q]};  --BUFFER POOLS Operations  AccessHandle: TYPE = B.AccessHandle;    MakePool: PROC[send, receive: CARDINAL, type: B.PoolType ¬ normalPool]    RETURNS [AccessHandle] =    INLINE {RETURN[B.MakePool[send, receive, type]]};  DestroyPool: PROC[aH: AccessHandle] =    INLINE {B.DestroyPool[aH]};  BuffersLeft: PROC[aH: AccessHandle] RETURNS [CARDINAL] =    INLINE {RETURN[B.BuffersLeft[aH]]};  SendBuffersLeft: PROC[aH: AccessHandle] RETURNS [CARDINAL] =    INLINE {RETURN[B.SendBuffersLeft[aH]]};  ReceiveBuffersLeft: PROC[aH: AccessHandle] RETURNS [CARDINAL] =    INLINE {RETURN[B.ReceiveBuffersLeft[aH]]};  GetBuffer: PROC[    aH: AccessHandle, function: B.Function, wait: BOOLEAN ¬ TRUE,    size: CARDINAL ¬ NSTypes.maxIDPBytesPerPacket] RETURNS [b: Buffer] =    INLINE {RETURN[LOOPHOLE[B.GetBuffer[ns, aH, function, wait, size]]]};  ReturnBuffer: PROC[b: Buffer] =    INLINE {B.ReturnBuffer[LOOPHOLE[b]]};  CreditReceiveBuffer: PROC[aH: AccessHandle, b: Buffer] RETURNS[BOOLEAN] =    INLINE {RETURN[B.CreditReceiveBuffer[aH, LOOPHOLE[b]]]};  DataBytesPerRawBuffer: PROC [b: Buffer] RETURNS [CARDINAL] =    INLINE {RETURN[B.DataBytesPerRawBuffer[LOOPHOLE[b]]]};    Seal: TYPE = B.Seal;  TransferStatus: TYPE = B.TransferStatus;  -- BUFFERS  Pointer: TYPE = LONG POINTER TO Buffer;  Buffer: TYPE = LONG POINTER TO BufferObject;  BufferBody: TYPE = NSTypes.BufferBody;  Body: TYPE = LONG POINTER TO BufferBody;  --This 'might' catch errors in redefining the BufferObject for XNS use.--  Trap: NATURAL[SIZE[B.BufferObject]..SIZE[B.BufferObject]] = SIZE[BufferObject];  BufferObject: TYPE = MACHINE DEPENDENT RECORD [    ns(0): LONG POINTER TO BufferBody,  --actual pointer to word aligned body    filler1(2), filler2(3): CARDINAL,  --no need for ns client to look here    linkLayer(4): Environment.Block,  --needed by driver & capsulation routines    requeueProcedure(8): PROC[Buffer],  --used by ns and other clients    requeueData(10): LONG UNSPECIFIED,  --used by ns and other clients    fo(12): B.FixedOverhead];  --common buffer management stuff      END.  LOG23-Apr-86 16:11:49  MI   Created and contents are copied from NSTypes and Buffer.21-May-86 16:25:16  SMA  Added Seal.18-Aug-86 17:25:52  AOF  Removed redefinition of BufferBody
-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- File: GateTeletype.mesa - last edit:-- Danielson.PA        21-May-84 11:10:01-- Thatcher.PA         26-Jan-83 17:47:38DIRECTORY  Auth USING [Authenticate, AuthenticationError,     Credentials, FreeIdentity, GetFlavor, MakeIdentity, IdentityHandle,    Verifier],   CFDStream USING [    DeleteProcedure, GetProcedure, Handle, Object, PutProcedure,    SendAttentionProcedure, SetSSTProcedure, WaitAttentionProcedure],  CH USING [ConversationHandle, FreeConversationHandle, IsMemberClosure,     LookupDistinguishedName, MakeConversationHandle, ReturnCode],  CHPIDs USING [members],  GateMake USING [OperationAborted, InstanceObject],  GateStream USING [Error, garbledReceiveData, noGetForData, parityError, none],  GateTeletypeControl USING [GlobalStats, GlobalStatsRecord, Stats, StatsRecord],  Heap USING [systemZone],  NSName USING [CopyName, FreeName, MakeName, Name, nullNameRecord],  NSString USING [String],  Stream USING [defaultInputOptions],  System USING [GetGreenwichMeanTime, SecondsSinceEpoch];GateTeletype: MONITOR   IMPORTS Auth, CH, GateMake, GateStream, Heap, NSName, System  EXPORTS GateMake, GateTeletypeControl =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    -- firstPort points to a chain of PortEntrys.  Each PortEntry contains the  -- access control information for the port and a pointer to the  -- TeletypeObject for that port.  If the port is not active, then  -- the TeletypeHandle is NIL.  -- The freeMe BOOLEAN is used if the ECS requests that the PortEntry  -- be deleted while an active session is in progress. In this case, the  -- entry is removed from the chain, but it is not freed.  freeMe is set  -- to force it to be freed later when the Stream is deleted.     firstPort: Port ¬ NIL;  Port: TYPE = LONG POINTER TO PortEntry;  PortEntry: TYPE = RECORD [    next: Port,    line: CARDINAL,    accessControl: NSName.Name,    identity: Auth.IdentityHandle,    globalStats: GateTeletypeControl.GlobalStatsRecord,    teletype: TeletypeHandle,    freeMe: BOOLEAN];  -- Set if Stream.Delete code should free PortEntry    -- Dummy port is a PortEntry that is used for RS-232-C ports that  -- are not owned by the ECS and thus don't have a port entry.  These  -- ports have the port field in their TeletypeHandle pointing to  -- dummyPort.  This prevents the global statistics code from having   -- to continually check to make sure that the port field is valid (not NIL).     dummyPort: PortEntry ¬ [NIL, 0, NIL, NIL, [], NIL, FALSE];  endSession: CONDITION;  -- Notified on every Stream delete.    -- The TeletypeObject contains the instance information for each active  -- teletype driver.  It contains the stream object, the downstream handle,  -- the statistics record for the port, and a pointer to the port entry.  -- As stated above the pointer to the port entry will point to dummyPort  -- if the port is not registerd by the ECS.     TeletypeHandle: TYPE = LONG POINTER TO TeletypeObject;  TeletypeObject: TYPE = RECORD [    ttyStream: GateMake.InstanceObject,    downStream: CFDStream.Handle,    stats: GateTeletypeControl.StatsRecord,    port: Port];    -- Exported to GateTeletypeControl  -- AllowAccess allows the ECS to define a port to be used for TTY emulation  -- purposes and to enable statistics collection.   -- Ports for Greeter only use are also defined to enable statistics  -- to be collected.  The routine allocates a PortEntry and adds it to the  -- port chain (port chain head is firstPort).    AllowAccess: PUBLIC ENTRY PROCEDURE [port: CARDINAL, accessControl: NSName.Name,    myName: NSName.Name, myPassword: NSString.String] =    BEGIN    newPort: Port ¬ z.NEW[PortEntry ¬ [next: firstPort, line: port,      globalStats: [], teletype: NIL, freeMe: FALSE,      accessControl: NSName.CopyName[z, accessControl],      identity: Auth.MakeIdentity[myName, myPassword, z, , TRUE]]];    firstPort ¬ newPort;    END;    -- Disallow Access allows the ECS to disable a previous defined port for  -- TTY emulation and statistics collection.    DisallowAccess: PUBLIC ENTRY PROCEDURE [port: CARDINAL] =    BEGIN    portHandle: Port;    FOR portHandle ¬ firstPort, portHandle.next UNTIL portHandle = NIL DO      IF portHandle.line = port THEN EXIT;      REPEAT        FINISHED => RETURN;  -- Didn't find it...ignore request.      ENDLOOP;    -- If active session, leave the entry around to be freed at Stream.Delete time    IF portHandle.teletype # NIL THEN portHandle.teletype.port.freeMe ¬ TRUE     ELSE FreePort[portHandle];    END;   -- WaitUntilIdle allows the ECS to wait until the particular RS-232-C port  -- used for TTY emulation is idle.  It cannot be used for ports used by the  -- Greeter since the port may be only listening.    WaitUntilIdle: PUBLIC ENTRY PROCEDURE [port: CARDINAL] =    BEGIN    portHandle: Port;    DO      FOR portHandle ¬ firstPort, portHandle.next UNTIL portHandle = NIL DO        IF portHandle.line = port THEN EXIT;	REPEAT	  FINISHED => RETURN;	ENDLOOP;      WAIT endSession;      ENDLOOP;    END;      -- Frees a PortObject and removes it from the port list.    FreePort: INTERNAL PROCEDURE [port: Port] =    BEGIN    previousPort: Port ¬ NIL;    IF port.accessControl # NIL THEN NSName.FreeName[z, port.accessControl];    Auth.FreeIdentity[@port.identity, z];    IF port = firstPort THEN firstPort ¬ port.next    ELSE      FOR prevPort: Port ¬ firstPort, prevPort.next UNTIL prevPort = NIL DO	IF prevPort.next = port THEN {prevPort.next ¬ port.next; EXIT};  	ENDLOOP;    z.FREE[@port];    END;      -- Get session statistics for a particular line.  If no session is active  -- on the line, the procedure returns FALSE.  Note that parameters are  -- copied to the user's memory and the session user name is allocated   -- from the heap supplied by the caller.    GetStats: PUBLIC ENTRY PROCEDURE [line: CARDINAL,    stats: GateTeletypeControl.Stats, z: UNCOUNTED ZONE] RETURNS [BOOLEAN] =    BEGIN    port: Port;    -- First try and locate the PortEntry.  If it's not found, no statistics.    FOR port ¬ firstPort, port.next UNTIL port = NIL DO      IF port.line = line THEN EXIT;      REPEAT        FINISHED => RETURN [FALSE];      ENDLOOP;    -- We found port.   If not active session, no statistics.    IF port.teletype = NIL THEN RETURN [FALSE];    -- Otherwise, copy statistics and return TRUE.    stats­ ¬ port.teletype.stats;    stats.user ¬ IF port.teletype.stats.user = NIL THEN NIL    ELSE NSName.CopyName[z, port.teletype.stats.user];    RETURN [TRUE];    END;    -- Get Global Stats returns the statistics for a particular line.   -- Returns FALSE if statistics are not being collected for that line.    GetGlobalStats: PUBLIC ENTRY PROCEDURE [line: CARDINAL,     stats: GateTeletypeControl.GlobalStats] RETURNS [BOOLEAN] =    BEGIN    port: Port;    currentSessionSeconds: LONG CARDINAL;    -- Look through port list for this line.  If not  found, no statistics    FOR port ¬ firstPort, port.next UNTIL port = NIL DO      IF port.line = line THEN EXIT;      REPEAT        FINISHED => RETURN [FALSE];  -- Isn't there, no global stats      ENDLOOP;    stats­ ¬ port.globalStats;  -- Copy stats to caller    -- Take any current session into account in the global stats    IF port.teletype # NIL THEN      BEGIN      currentSessionSeconds ¬         System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]] -          System.SecondsSinceEpoch[port.teletype.stats.sessionStart];      -- If the shortest session is zero, use current time as the shortest      IF stats.shortestSessionSeconds = 0 THEN        stats.shortestSessionSeconds ¬ currentSessionSeconds;      -- If the current session is longest, tell the user      IF currentSessionSeconds > stats.longestSessionSeconds THEN        stats.longestSessionSeconds ¬ currentSessionSeconds;      -- Include the current session time in the total time      stats.allSessionsSeconds ¬ stats.allSessionsSeconds +        currentSessionSeconds;      END;    RETURN[TRUE];    END;    -- Increment a statistic counter.  Done under monitor to be safe.    Increment: ENTRY PROCEDURE [counter: LONG POINTER TO LONG CARDINAL,    count: LONG CARDINAL] = INLINE    BEGIN counter­ ¬ counter­ + count END;    -- Stream initialization.  -- I don't like InitTeletypeDriver being an ENTRY    InitTeletypeDriver: PUBLIC ENTRY PROCEDURE [remote: BOOLEAN,     line: CARDINAL, stream: CFDStream.Handle,    credentials: Auth.Credentials, verifier: Auth.Verifier]    RETURNS [newStream: CFDStream.Handle] =    BEGIN ENABLE UNWIND => NULL;        WorldAccess: PROCEDURE [access: NSName.Name] RETURNS [BOOLEAN] = INLINE       BEGIN RETURN[access = NIL OR access.local.bytes = NIL] END;          conversation: CH.ConversationHandle;    code: CH.ReturnCode;    name: NSName.Name ¬ NIL;    tty: TeletypeHandle ¬ NIL;    ok: BOOLEAN ¬ TRUE;    port: Port;    FOR port ¬ firstPort, port.next UNTIL port = NIL DO        IF port.line = line THEN EXIT;	ENDLOOP;    IF remote THEN       BEGIN      -- Remote access is not allowed unless the ECS has supplied access      -- information.  This protects us against illegal usage because of      -- lack of product factoring.      IF port = NIL THEN        RETURN WITH ERROR GateStream.Error[noCommunicationHardware];      -- We always try to authenticate the user      -- so we can get his name for network management purposes      name ¬ Auth.Authenticate[recipient: port.identity,         credentialsToCheck: credentials, verifierToCheck: verifier, z: z !	   Auth.AuthenticationError =>  IF WorldAccess[port.accessControl] THEN	    GOTO noNeedToAuthenticate ELSE GOTO authenticateFailure];      -- If we get back a null NameRecord, the user passed in null credentials      -- and verifier.  If World access then that is ok, else it's an error.      IF name = NIL OR name­ = NSName.nullNameRecord THEN        IF WorldAccess[port.accessControl] THEN GOTO noNeedToAuthenticate	ELSE 	  BEGIN	  IF name # NIL THEN NSName.FreeName[z, name];	  RETURN WITH ERROR GateStream.Error[userNotAuthenticated];	  END;      -- Get a conversation handle to lookup the distinguished name and      -- do any IsMemberClosures.      [conversation: conversation, ok: ok, authCallError:  ] ¬         CH.MakeConversationHandle[identity: port.identity, heap: z];      IF ~ok THEN  -- Should always be ok!        BEGIN	NSName.FreeName[z, name];	RETURN WITH ERROR GateStream.Error[userNotAuthenticated];	END;      -- Allocate and lookup up distinguished name, if flavor of credentials      -- is simple.      IF Auth.GetFlavor[credentials] = simple THEN        BEGIN        distinguishedName: NSName.Name ¬ NSName.MakeName[z];        [rc: code] ¬ CH.LookupDistinguishedName[          conversation: conversation,          name: name, distingName: distinguishedName];        NSName.FreeName[z, name];  -- Free non-distinguished name        name ¬ distinguishedName; -- Copy distinguished name	IF code.code # done THEN	  BEGIN	  NSName.FreeName[z, name];	  CH.FreeConversationHandle[conversation: @conversation, heap: z];	  RETURN WITH ERROR GateStream.Error[userNotAuthenticated];	  END;	END;      -- We have the distinguished name.  If WorldAccess, then      -- we are finished, so free ConversationHandle      IF WorldAccess[port.accessControl] THEN 	CH.FreeConversationHandle[conversation: @conversation, heap: z]      ELSE        BEGIN	[rc: code, isMember: ok] ¬ CH.IsMemberClosure[          conversation: conversation,          element: name, name: port.accessControl, pn: CHPIDs.members,          pn2: CHPIDs.members, distingName: NIL];        -- Free the conversation handle        CH.FreeConversationHandle[conversation: @conversation, heap: z];        -- If code.code # done either the LookupDistinguishedName or the        -- is member closure failed due probably to a Clearinghouse failure         IF code.code # done OR ~ok THEN NSName.FreeName[z, name];        -- If code.code # done then the user could not be authenticated        IF code.code # done THEN	   RETURN WITH ERROR GateStream.Error[userNotAuthenticated];        -- If ok is not TRUE, the IsMemberClosure failed.         IF ~ok THEN          BEGIN	  IF port # NIL THEN port.globalStats.numberOfAccessControlFailures ¬ 	      port.globalStats.numberOfAccessControlFailures + 1; 	  RETURN WITH ERROR GateStream.Error[userNotAuthorized];	  END;	END;      EXITS        noNeedToAuthenticate => NULL;	authenticateFailure =>	  RETURN WITH ERROR GateStream.Error[userNotAuthenticated];      END;    -- Allocate and initialize TeletypeObject    tty ¬ z.NEW[TeletypeObject ¬ [      ttyStream:       [streamObject:	[options: Stream.defaultInputOptions, get: Get, put: Put, setSST: SetSST,	  sendAttention: SendAttention, waitAttention: WaitAttention,	  delete: Delete], realWaitAttention: WaitAttention, realDelete: Delete,	 unNew: FALSE],       downStream: stream,      stats: [        sessionStart: System.GetGreenwichMeanTime[],         user: name],      port: IF port = NIL THEN @dummyPort ELSE port]];    -- If we have a port entry, fill in the teletype object pointer in the port    -- to indicate that we have an active session.    IF port # NIL THEN port.teletype ¬ tty;    -- Increment session count.    tty.port.globalStats.numberOfSessions ¬       tty.port.globalStats.numberOfSessions + 1;    RETURN[LOOPHOLE[tty, CFDStream.Handle]];    END;     -- Stream procedures  Get: CFDStream.GetProcedure =    BEGIN OPEN LOOPHOLE[sH, TeletypeHandle];    [bytesTransferred, why, sst] ¬ downStream.get[      downStream, physicalRecordHandle, options !      GateMake.OperationAborted =>        BEGIN        why ¬ SELECT reason FROM	  transmissionMediumDown => endOfStream,	  ENDCASE => sstChange;        bytesTransferred ¬ 0;	sst ¬ GateStream.none;	CONTINUE;	END];    Increment[@stats.bytesReceived, bytesTransferred];    Increment[@port.globalStats.totalBytesReceived, bytesTransferred];    SELECT sst FROM      GateStream.garbledReceiveData =>         BEGIN        Increment[@stats.receiveFramingErrors, 1];	Increment[@port.globalStats.totalReceiveFramingErrors, 1];	END;      GateStream.parityError =>        BEGIN        Increment[@stats.receiveParityErrors, 1];	Increment[@port.globalStats.totalReceiveParityErrors, 1];	END;      ENDCASE;    END;  Put: CFDStream.PutProcedure =    BEGIN OPEN LOOPHOLE[sH, TeletypeHandle];    bytes: LONG CARDINAL;    downStream.put[downStream, physicalRecordHandle, endPhysicalRecord !      GateMake.OperationAborted => CONTINUE];  -- later, try and return status?    bytes ¬ LONG[physicalRecordHandle.body.stopIndexPlusOne -      physicalRecordHandle.body.startIndex];    Increment[@stats.bytesSent, bytes];    Increment[@port.globalStats.totalBytesSent, bytes];      END;  SetSST: CFDStream.SetSSTProcedure =    BEGIN OPEN LOOPHOLE[sH, TeletypeHandle];    downStream.setSST[downStream, sst];    END;  SendAttention: CFDStream.SendAttentionProcedure =    BEGIN OPEN LOOPHOLE[sH, TeletypeHandle];    downStream.sendAttention[downStream, byte  !      GateMake.OperationAborted => CONTINUE];    END;  WaitAttention: CFDStream.WaitAttentionProcedure =    BEGIN OPEN LOOPHOLE[sH, TeletypeHandle];    byte ¬ downStream.waitAttention[downStream];    IF byte = GateStream.noGetForData THEN      Increment[@stats.receiveDataLostErrors, 1];    END;  Delete: CFDStream.DeleteProcedure =    BEGIN OPEN LOOPHOLE[sH, TeletypeHandle];        DeleteLocked: ENTRY PROCEDURE =      BEGIN      sessionTime: LONG CARDINAL ¬        System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]] -        System.SecondsSinceEpoch[stats.sessionStart];      port.globalStats.allSessionsSeconds ¬ port.globalStats.allSessionsSeconds +        sessionTime;      IF port.globalStats.shortestSessionSeconds = 0 OR        sessionTime < port.globalStats.shortestSessionSeconds THEN          port.globalStats.shortestSessionSeconds ¬ sessionTime;      IF sessionTime > port.globalStats.longestSessionSeconds THEN        port.globalStats.longestSessionSeconds ¬ sessionTime;      port.teletype ¬ NIL;  -- Indicate no active session      IF stats.user # NIL THEN NSName.FreeName[z, stats.user];      IF port.freeMe THEN FreePort[port];      BROADCAST endSession;      END;       downStream.delete[downStream];    DeleteLocked[];    z.FREE[@sH];    END;  END.LOGDecember 1, 1980  3:02 PM  Bill Danielson  Action: Created file.January 23, 1981  2:09 PM  Bill Danielson  Action: Change Error to CreationFailed. 6-Aug-81 11:01:23  Bill Danielson  Action: Pescadero interface changes.13-Aug-81 18:17:13  Bill Danielson  Action: New cleanup stuff.27-Nov-81 15:36:08  Bill Danielson  Action: Make TeletypeHandle a LONG POINTER.29-Jan-82 13:39:08  Bill Danielson  Action: Catch OperationAborted on Gets.26-Jan-83 17:45:39  Mike Thatcher   Action: Catch OperationAborted on SendAttention.24-Jan-84 11:02:16  Bill Danielson  Action: Add stopping stuff. 6-Apr-84 20:21:26  Bill Danielson  Action: Fixed increment to increment by  					count rather than 1.10-May-84 16:26:22  Bill Danielson  Action: Lookup distinguished name for simple  credentials.  AR 7536. 
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: GateStreamMgrInstance.mesa - last edit:-- Danielson.PA        21-Mar-84 21:35:20-- Artibee.PA          11-Apr-84 14:35:21DIRECTORY  CFDStream USING [Byte, Delete, DeleteProcedure,     Handle, WaitAttentionProcedure],  GateMake USING [    AwaitConnectionReady, ModuleReportObject, ModuleStatus,    ProtocolDriverReason, StatusReporter, WhoCalled],  GateStream USING [    bindFailed, configurationMismatch3270,     hostNotPolling3270, hostPolling3270,    mediumUp, mediumDown, noGetForData, none, ourAccessIDRejected,     puActive, puInactive, unexpectedRemoteBehavior,    unexpectedSoftwareFailure, unsupportedProtocolFeature, weRejectedAccessID],  GateStreamInternal USING [    DeleteTransmissionMedium, MgrInstanceHandle, MgrInstanceObject,    QuiesceTransmissionMedium],  Heap USING [systemZone],  Process USING [Abort, EnableAborts],  Runtime USING [SelfDestruct];GateStreamMgrInstance: MONITOR  IMPORTS CFDStream, GateStreamInternal, Heap, Process, Runtime  EXPORTS GateStreamInternal, GateMake =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  inUse: BOOLEAN ¬ FALSE;  newed: BOOLEAN ¬ FALSE;  initialize: PROCEDURE [new: BOOLEAN]    RETURNS [instance: GateStreamInternal.MgrInstanceHandle] ¬ Initialize;  instanceObject: GateStreamInternal.MgrInstanceObject;  connectionStateChange: CONDITION;  attentionByteReceived: CONDITION;  lastStatusReported: GateMake.ModuleStatus;  lastDriverReason: GateMake.ProtocolDriverReason;  connectionComplete: BOOLEAN;  whoCalled: GateMake.WhoCalled;  disallowCleanUp: BOOLEAN;  nextAttention: Attention;  topLevelWaitAttention: CFDStream.WaitAttentionProcedure;  topLevelDelete: CFDStream.DeleteProcedure;  attentionProcess: PROCESS;  Attention: TYPE = LONG POINTER TO AttentionObject;  AttentionObject: TYPE = RECORD [byte: CFDStream.Byte, next: Attention];  CreateMgrInstance: PUBLIC PROCEDURE    RETURNS [instance: GateStreamInternal.MgrInstanceHandle] =    BEGIN    IF ~GetNewInstance[] THEN RETURN[Initialize[FALSE]]    ELSE      BEGIN      frame: LONG POINTER TO FRAME[GateStreamMgrInstance] ¬ NEW        GateStreamMgrInstance;      START frame;      RETURN[frame.initialize[TRUE]];      END;    END;  GetNewInstance: ENTRY PROCEDURE RETURNS [new: BOOLEAN] =    BEGIN  -- always called from original instance --    new ¬ inUse;    inUse ¬ TRUE;    END;  FreeInstance: ENTRY PROCEDURE[] = BEGIN inUse ¬ FALSE; END;  Initialize: PROCEDURE [new: BOOLEAN]    RETURNS [instance: GateStreamInternal.MgrInstanceHandle] =    BEGIN    newed ¬ new;    disallowCleanUp ¬ connectionComplete ¬ FALSE;    whoCalled ¬ aborted;    attentionProcess ¬ NIL;    nextAttention ¬ NIL;    instanceObject ¬ [      medium: NIL, cfdStream: NIL,      delete: Delete, statusReporter: ReportEvent,      waitConnection: WaitConnectionComplete, waitAttention: WaitAttention,      attentionProcess: AttentionProcess,      notifyAttentionReceived: NotifyAttentionReceived, networkStream: NIL,      cfdStreamGet: NIL, cfdStreamWaitAttention:NIL,      networkStreamWaitAttention: NIL, networkStreamGet: NIL, fake: FALSE];    RETURN[@instanceObject];    END;  Delete: CFDStream.DeleteProcedure =    BEGIN    savedAttention: Attention;    GateStreamInternal.QuiesceTransmissionMedium[instanceObject.medium];    IF attentionProcess # NIL THEN      BEGIN      -- CFDStream.SendAttention[instanceObject.cfdStream, GateStream.cleanup];      Process.Abort[attentionProcess];      JOIN attentionProcess;      instanceObject.cfdStream.waitAttention ¬ topLevelWaitAttention;      instanceObject.cfdStream.delete ¬ topLevelDelete;      CFDStream.Delete[instanceObject.cfdStream];      attentionProcess ¬ NIL;      END    ELSE IF instanceObject.cfdStream # NIL THEN      CFDStream.Delete[instanceObject.cfdStream];    UNTIL nextAttention = NIL DO      savedAttention ¬ nextAttention.next;      z.FREE[@nextAttention];      nextAttention ¬ savedAttention;      ENDLOOP;    GateStreamInternal.DeleteTransmissionMedium[instanceObject.medium];    FreeInstance[];    IF newed THEN Runtime.SelfDestruct[];    END;  ReportEvent: PROCEDURE [report: GateMake.ModuleReportObject]    RETURNS [commitSuicide: BOOLEAN] =    -- Called by framer, driver, and transducer when "Significant"    -- status change occurs.  Perhaps want to log these events by module    -- and type and/or inform client.    BEGIN    commitSuicide ¬ FALSE;  -- for those cases that do explicit RETURNS    SELECT lastStatusReported ¬ report.moduleStatus FROM      softwareInconsistency =>        NotifyAttentionReceived[GateStream.unexpectedSoftwareFailure];      protocolError =>        NotifyAttentionReceived[GateStream.unexpectedRemoteBehavior];      ENDCASE =>        -- now, let's process the status according to who reported it        WITH report SELECT FROM          bscDriver =>            SELECT lastStatusReported FROM              destroyMedium =>                SELECT lastDriverReason ¬ protocolDriverReason FROM                  ourSecurityIDRejected =>                    NotifyAttentionReceived[GateStream.ourAccessIDRejected];                  weRejectedRemoteID =>                    NotifyAttentionReceived[GateStream.weRejectedAccessID];                  Xerox800Rvi =>                    NotifyAttentionReceived[                      GateStream.unsupportedProtocolFeature];                  cfdNotResponding, discReceived =>                    NotifyAttentionReceived[                      GateStream.unexpectedRemoteBehavior];                  ENDCASE;              none =>                SELECT lastDriverReason ¬ protocolDriverReason FROM                  disconnectSavingData =>                    BEGIN                    disallowCleanUp ¬ TRUE;                    RETURN;  -- stay alive                    END;                  noGet =>                    BEGIN                    NotifyAttentionReceived[GateStream.noGetForData];                    RETURN;  -- stay alive                    END;                  IN [ourSecurityIDRejected..discReceived] =>                    NotifyAttentionReceived[                      (SELECT lastDriverReason FROM                         ourSecurityIDRejected =>                           GateStream.ourAccessIDRejected,                         weRejectedRemoteID => GateStream.weRejectedAccessID,                         Xerox800Rvi => GateStream.unsupportedProtocolFeature,                         cfdNotResponding, discReceived =>                           GateStream.unexpectedRemoteBehavior,                         ENDCASE => GateStream.unexpectedSoftwareFailure)];                  ENDCASE;              ENDCASE;          transducer =>            SELECT lastStatusReported FROM              connectionComplete =>                BEGIN                whoCalled ¬                  SELECT transducerReason FROM                    weWereCalled => they,                    ENDCASE => we;                NotifyConnectionComplete[];                NotifyAttentionReceived[GateStream.mediumUp];                RETURN;  -- stay alive                END;              mediumDown => NotifyAttentionReceived[GateStream.mediumDown];              ENDCASE;          mux, snaDispatcher =>             SELECT multiplexReason FROM              configurationMismatch =>                BEGIN                NotifyAttentionReceived[GateStream.configurationMismatch3270];                RETURN;  -- stay alive                END;              hostPolling =>                BEGIN                NotifyAttentionReceived[GateStream.hostPolling3270];                RETURN;  -- stay alive                END;              hostNotPolling =>                BEGIN                NotifyAttentionReceived[GateStream.hostNotPolling3270];                RETURN;  -- stay alive                END;              ENDCASE;          snaLUMgr =>             SELECT luMgrReason FROM              puActive =>                BEGIN                NotifyAttentionReceived[GateStream.puActive];                RETURN;  -- stay alive                END;              puInActive =>                BEGIN                NotifyAttentionReceived[GateStream.puInactive];                RETURN;  -- stay alive                END;              bindFailed =>                BEGIN                NotifyAttentionReceived[GateStream.bindFailed];                RETURN;  -- stay alive                END;              ENDCASE;          framer => NULL;          ENDCASE;    -- fatal problem, we are deleting     connectionComplete ¬ FALSE;    commitSuicide ¬ TRUE;    -- Force RS232 Transducer processes to quiesece    GateStreamInternal.QuiesceTransmissionMedium[instanceObject.medium];    whoCalled ¬ aborted;    NotifyConnectionComplete[];  -- Make connection complete/attn return    END;  NotifyConnectionComplete: ENTRY PROCEDURE =    BEGIN     connectionComplete ¬ TRUE;     NOTIFY connectionStateChange;    NOTIFY attentionByteReceived;  -- Wake up attn waiter also    END;  WaitConnectionComplete: ENTRY PROCEDURE RETURNS [GateMake.WhoCalled] =    -- wait for notification of connection complete    BEGIN    UNTIL connectionComplete DO WAIT connectionStateChange; ENDLOOP;    RETURN[whoCalled];    END;  WaitAttention: ENTRY PROCEDURE [sH: CFDStream.Handle]    RETURNS [byte: CFDStream.Byte] =    BEGIN ENABLE UNWIND => NULL;    saveAttention: Attention;    UNTIL ((nextAttention # NIL) OR       (whoCalled = aborted AND connectionComplete)) DO       WAIT attentionByteReceived; ENDLOOP;    IF nextAttention = NIL THEN RETURN WITH ERROR ABORTED;    byte ¬ nextAttention.byte;    saveAttention ¬ nextAttention;    nextAttention ¬ nextAttention.next;    z.FREE[@saveAttention];    END;    AttentionProcess: PROCEDURE =    BEGIN    topLevelWaitAttention ¬ instanceObject.cfdStream.waitAttention;    instanceObject.cfdStream.waitAttention ¬ WaitAttention;    topLevelDelete ¬ instanceObject.cfdStream.delete;    instanceObject.cfdStream.delete ¬ Delete;    attentionProcess ¬ FORK AttentionWaiter[];    END;  AttentionWaiter: PROCEDURE =    BEGIN    byte: CFDStream.Byte ¬ GateStream.none;    DO      ENABLE ABORTED => EXIT;      byte ¬ topLevelWaitAttention[instanceObject.cfdStream];      NotifyAttentionReceived[byte];      ENDLOOP;    whoCalled ¬ aborted;    NotifyConnectionComplete[];    END;  NotifyAttentionReceived: ENTRY PROCEDURE [byte: CFDStream.Byte] =    BEGIN    attention: Attention ¬ z.NEW[AttentionObject ¬ [byte, NIL]];    lastAttention: Attention;    IF nextAttention = NIL THEN nextAttention ¬ attention ELSE      BEGIN      lastAttention ¬ nextAttention;      UNTIL lastAttention.next = NIL DO        lastAttention ¬ lastAttention.next ENDLOOP;      lastAttention.next ¬ attention;      END;    BROADCAST attentionByteReceived;    END;Process.EnableAborts[@attentionByteReceived];  END.LOG 3-Feb-81  5:36:00  BRD  Initialize global frame variables in Initialize.14-Feb-81 12:25:00  BRD  Initialize nextAttention.24-Feb-81  2:23:00  BRD  Add check for non-created CFDStream in Delete.12-Mar-81  3:20:00  BRD  Fix for cleanup using ReportEvent. 5-Jun-81 11:20:03  BRD  Changes for GAP. 4-Nov-81 16:14:32  BRD  Replace Delete and WaitAttention pointer in                          downstream CFDStream object on delete.22-Mar-82 14:06:00  SAB  Added mux variant with multiplexReason of                         configurationMismatch to StatusReporter. 6-Oct-82 15:37:07  MZA  Added NOTIFY to NotifyAttentionReceived19-Jan-83 14:00:03  DDM  AR 9629: Added hostPolling/hostNotPolling to 			  mux varient of ModuleReportObject for StatusReporter. 6-Jul-83 15:52:07  BRD  Enabled aborts on attentionByteReceived condition. 5-Oct-83 17:12:27  BRD  Klamath conversion.11-Jan-84 15:47:34  MZA  ReportEvent handles SNA related stuff.20-Mar-84 10:48:45  BRD  Make WaitAttention return ABORTED after link goes down.11-Apr-84 14:35:28  MZA  Make AttentionWaiter pass aborted to WaitAttention.
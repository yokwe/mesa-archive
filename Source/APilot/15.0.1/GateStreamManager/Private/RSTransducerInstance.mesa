-- File: RSTransducerInstance.mesa - last edit:-- AOF                  3-Dec-85 16:19:16-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- File: RSTransducerInstance.mesa - last edit:-- Danielson.PA         5-Jul-84 14:45:23-- Asai.PA             31-Oct-83 15:31:58-- AOF                 15-Feb-85  8:33:21DIRECTORY  ByteBlt USING [ByteBlt],  CFDStream USING [    Object, Handle, SubSequenceType, PhysicalRecordHandle,    InputOptions, CompletionCode, Byte],  Environment USING [Block, Byte, wordsPerPage],  GateControl USING [],  GateMake USING [    OperationAborted, ProtocolDescHandle, StatusReporter,    ModuleReportObject, ModuleStatus, InstanceObject, InstanceHandle],  GateSpy USING [    GetSpyProcedure, PutSpyProcedure, StatusSpyProcedure, StopSpyProcedure],  GateStream USING [abortGetTransaction, abortPutTransaction,     garbledReceiveData, noGetForData, none, interrupt,    cleanup, parityError],  GateStreamInternal USING [ResourceObject],  Heap USING [CreateUniform, Delete],  Process USING [EnableAborts, InitializeCondition, MsecToTicks],  Runtime USING [SelfDestruct],  RS232C USING [    ChannelHandle, CommParamObject, Duplexity, CompletionHandle,    TransferStatus, DeviceStatus,    Put, TransferWait, TransmitNow, Get, GetStatus, SetParameter,    Suspend, StatusWait, ChannelSuspended, LatchBitClearMask, SendBreak,    PhysicalRecord],  RS232CCorrespondents USING [nsSystemElement];RSTransducerInstance: MONITOR  IMPORTS    ByteBlt, GateMake, Heap, Process, RS232C, Runtime  EXPORTS GateMake, GateSpy, GateControl =  BEGIN    -- instance control  newed: BOOLEAN ¬ FALSE;  inUse: BOOLEAN ¬ FALSE;    -- various definitions  TimeRecord: TYPE = RECORD [    startTime: CARDINAL, finishTime: CARDINAL];  LineState: TYPE = {lineDown, lineUp, aborted};  InstanceHandle: TYPE = LONG POINTER TO InstanceType;  InstanceType: TYPE = RECORD [    instanceObject: GateMake.InstanceObject,  -- holds stream object and more    nextInstance: InstanceHandle ¬ NIL,    line: CARDINAL ¬ LAST[CARDINAL],    getSpyProcedure: GateSpy.GetSpyProcedure ¬ NIL,    putSpyProcedure: GateSpy.PutSpyProcedure ¬ NIL,    statusSpyProcedure: GateSpy.StatusSpyProcedure ¬ NIL,    stopSpyProcedure: GateSpy.StopSpyProcedure ¬ NIL,    channel: RS232C.ChannelHandle];  -- writeable data  lineState: LineState;  lineChange: CONDITION;  newInstance: CONDITION;  instanceData: InstanceType;  instanceHead: InstanceHandle ¬ NIL;  channelHandle: RS232C.ChannelHandle;  reportProc: GateMake.StatusReporter;  -- report events to Gateway Mgr  connectionStatusProcess: PROCESS;  duplex: RS232C.Duplexity;  lastStatus: RS232C.TransferStatus;  lastSST: CFDStream.SubSequenceType;  searching: BOOLEAN ¬ FALSE;    -- attention support  attentionArrived: CONDITION;  receivedAttention: CFDStream.SubSequenceType;    -- multiple buffering  BufferElementPointer: TYPE = LONG POINTER TO BufferElement;  BufferElement: TYPE = RECORD[    comp: RS232C.CompletionHandle,    next: BufferElementPointer,    buffer: PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];  buffering, dataLeft: BOOLEAN;  myHeap: UNCOUNTED ZONE;  bufferSize: CARDINAL;  topBufferElement, bottomBufferElement: BufferElementPointer;  dataBlock: Environment.Block;  startRSTransducer: PROCEDURE [    interfaceHandle: LONG POINTER,  -- to rs232c ResourceObject    commParamHandle: LONG POINTER TO RS232C.CommParamObject,    protocolDescHandle: GateMake.ProtocolDescHandle,    statusReporter: GateMake.StatusReporter,    new: BOOLEAN] RETURNS [instance: GateMake.InstanceHandle] ¬      StartRSTransducer;      -- stats  totDataLost, breakCnt: CARDINAL;  async: BOOLEAN ¬ FALSE;    -- Interface Procedures  InitRSTransducer: PUBLIC PROCEDURE [  -- always called in first instance    interfaceHandle: LONG POINTER,  -- LONG POINTER TO an rs232c ResourceHandle    commParamHandle: LONG POINTER TO RS232C.CommParamObject,    protocolDescHandle: GateMake.ProtocolDescHandle,    statusReporter: GateMake.StatusReporter]    RETURNS [stream: CFDStream.Handle] =    BEGIN    new: BOOLEAN ¬ FALSE;    proc: PROCEDURE [      interfaceHandle: LONG POINTER,      commParamHandle: LONG POINTER TO RS232C.CommParamObject,      protocolDescHandle: GateMake.ProtocolDescHandle,      statusReporter: GateMake.StatusReporter, new: BOOLEAN]      RETURNS [instance: GateMake.InstanceHandle];    transducerHandle: GateMake.InstanceHandle;    IF (new ¬ GetNewInstance[]) THEN      BEGIN      frame: LONG POINTER TO FRAME [RSTransducerInstance] ¬        NEW RSTransducerInstance;      START frame;      proc ¬ frame.startRSTransducer;      END    ELSE proc ¬ StartRSTransducer;    transducerHandle ¬ proc[interfaceHandle,       commParamHandle, protocolDescHandle, statusReporter, new];    stream ¬ @transducerHandle.streamObject;    stream.delete ¬ TopDelete;    Enqueue[LOOPHOLE[stream]];    END;      StartRSTransducer: PROCEDURE [ -- called in particular instance    interfaceHandle: LONG POINTER,  -- to rs232c ResourceObject    commParamHandle: LONG POINTER TO RS232C.CommParamObject,    protocolDescHandle: GateMake.ProtocolDescHandle,    statusReporter: GateMake.StatusReporter,    new: BOOLEAN]    RETURNS [instance: GateMake.InstanceHandle] =    BEGIN OPEN resource: LOOPHOLE[interfaceHandle,      LONG POINTER TO rs232c GateStreamInternal.ResourceObject];    -- initializations    newed ¬ new;    receivedAttention ¬ GateStream.none;    lineState ¬ lineDown;    buffering ¬ dataLeft ¬ FALSE;    totDataLost ¬ breakCnt ¬ 0;    lastSST ¬ GateStream.none;    -- save params    channelHandle ¬ resource.channel;    reportProc ¬ statusReporter;    duplex ¬ commParamHandle.duplex;    -- form instance object    instanceData.instanceObject ¬ [      streamObject: [      options:, get: Get, put: Put, setSST: SetSST,      sendAttention: SendAttention, waitAttention: WaitAttention,      delete: Delete], realWaitAttention: WaitAttention,      realDelete: Delete, unNew:];    instanceData.channel ¬ resource.channel;    instanceData.line ¬ resource.line;    instance ¬ @instanceData.instanceObject;    async ¬ FALSE;    -- do buffering if appropriate    WITH protocolDescHandle SELECT FROM      ttySimulate =>         BEGIN	async ¬ TRUE;	InitializeBuffering[128, 8]; -- TEMP	END;      -- polledBSC => InitializeBuffering[2048,2];      ibm3270 =>         IF correspondent = RS232CCorrespondents.nsSystemElement 	  THEN InitializeBuffering[maxReceiveBlockSize + 4, 2]; -- + 4 for LH/LT      ENDCASE => NULL;    -- create interface status monitor process    connectionStatusProcess ¬ FORK ConnectionWatch[resource.currentStatus];    END;      TopDelete: PROCEDURE [sH: CFDStream.Handle] =    BEGIN  -- Always called in first instance    instance: InstanceHandle ¬ Dequeue[sH];    IF instance.stopSpyProcedure # NIL THEN instance.stopSpyProcedure[mediumDown];    instance.instanceObject.realDelete [sH];    END;      -- Stream operations  Put: PROCEDURE [    sH: CFDStream.Handle,    physicalRecordHandle: CFDStream.PhysicalRecordHandle,    endPhysicalRecord: BOOLEAN] =    -- put things to the channel, wait for their completion     -- ignore endPhysRec, always send the block    -- if half duplex, then endPhysRec means turn line around (raise RTS)    BEGIN    ENABLE RS232C.ChannelSuspended => GOTO noChannel;    -- locals    complete: RS232C.CompletionHandle;    transferStatus: RS232C.TransferStatus;    status: RS232C.DeviceStatus;    -- check if line is up, wait if necessary    IF lineState # lineUp THEN      IF WaitLineChange[] # lineUp THEN GOTO aborted;    -- if half-duplex, raise Req-To-Send, wait for Clear-To-Send    IF duplex = half THEN RS232C.SetParameter[      channelHandle, [requestToSend[TRUE]]];    status ¬ RS232C.GetStatus[channelHandle];    UNTIL status.clearToSend DO      status ¬ RS232C.StatusWait[channelHandle, status]; ENDLOOP;    -- send to channel, check for errors    complete ¬ RS232C.Put[      channelHandle, LOOPHOLE[LONG[physicalRecordHandle]]];    [, transferStatus] ¬ RS232C.TransmitNow[channelHandle, complete];    IF instanceData.putSpyProcedure # NIL      THEN instanceData.putSpyProcedure[        LOOPHOLE[LONG[physicalRecordHandle]], transferStatus, status];    [] ¬ CheckTransferStatus[transferStatus, GateStream.none, normal];    -- if half-duplex, drop Req-To-Send    IF (duplex = half) AND endPhysicalRecord THEN      RS232C.SetParameter[channelHandle, [requestToSend[FALSE]]];    EXITS      noChannel,      aborted =>{        IF instanceData.stopSpyProcedure # NIL 	THEN instanceData.stopSpyProcedure[mediumDown];        ERROR GateMake.OperationAborted[transmissionMediumDown];	};    END;  Get: PROCEDURE [    sH: CFDStream.Handle,    physicalRecordHandle: CFDStream.PhysicalRecordHandle,    options: CFDStream.InputOptions]    RETURNS [      bytesTransferred: CARDINAL, why: CFDStream.CompletionCode,      sst: CFDStream.SubSequenceType] =    -- Get from the channel, wait for completion    -- end physical record means we got all the data from one RS232C.Get.     BEGIN    ENABLE RS232C.ChannelSuspended => GOTO noChannel;    -- locals    complete: RS232C.CompletionHandle;    IF lastSST # GateStream.none THEN      BEGIN      lastSST ¬ GateStream.none;      RETURN[0, sstChange, GateStream.none];      END;    why ¬ normal;    sst ¬ GateStream.none;    -- send to channel, check for errors    -- IF timeStamps THEN getTimeTable[getTimeIndex].startTime ¬ timerPtr­;    IF ~dataLeft THEN      -- no data left from last time, so get next completion handle      -- to wait for more data      BEGIN      IF buffering THEN        -- if we are buffer completion handle is in topBufferElement        IF topBufferElement = NIL THEN GOTO noChannel        ELSE complete ¬ topBufferElement.comp      ELSE        -- if we are not buffering, do a Get to obtain completion handle	complete ¬ RS232C.Get[          channelHandle, LOOPHOLE[LONG[physicalRecordHandle]]];      [bytesTransferred, lastStatus] ¬ RS232C.TransferWait[        channelHandle, complete];      IF instanceData.getSpyProcedure # NIL THEN         IF buffering THEN	  BEGIN	  tempRecord: RS232C.PhysicalRecord ¬ [             [NIL, 0, 0], [LOOPHOLE[@topBufferElement.buffer], 0, bufferSize], 	     [NIL, 0, 0]];          lastStatus ¬ instanceData.getSpyProcedure[@tempRecord, 	    bytesTransferred, lastStatus, ];	  END	ELSE          lastStatus ¬ instanceData.getSpyProcedure[	    LOOPHOLE[LONG[physicalRecordHandle]], bytesTransferred, lastStatus, ];      -- IF timeStamps THEN      --   BEGIN      --   getTimeTable[getTimeIndex].finishTime ¬ timerPtr­;      --   getTimeIndex ¬ (getTimeIndex + 1) MOD maxGetTimeIndex;      --   END;      END;    IF buffering THEN      -- if buffering we have to copy data from channel into clients buffers       BEGIN -- copy data to clients buffers      startingIndex: CARDINAL;      IF ~dataLeft THEN dataBlock ¬ [LOOPHOLE[@topBufferElement.buffer],         0, bytesTransferred];      startingIndex ¬ dataBlock.startIndex;      dataBlock.startIndex ¬ ByteBlt.ByteBlt[        to: physicalRecordHandle.header, from: dataBlock] + dataBlock.startIndex;      dataBlock.startIndex ¬ ByteBlt.ByteBlt[        to: physicalRecordHandle.body, from: dataBlock] + dataBlock.startIndex;      dataBlock.startIndex ¬ ByteBlt.ByteBlt[        to: physicalRecordHandle.trailer, from: dataBlock] + dataBlock.startIndex;      bytesTransferred ¬ dataBlock.startIndex - startingIndex;      IF dataBlock.startIndex = dataBlock.stopIndexPlusOne THEN        BEGIN -- we got to the end of the data received	why ¬ endRecord;	dataLeft ¬ FALSE;	DoTheNextGet[];	END      ELSE        -- still more data to copy, set flag so we remember on next Get	dataLeft ¬ TRUE        END    ELSE why ¬ endRecord;  -- not buffering so endRecord always TRUE    IF why = endRecord THEN      [sst, why] ¬ CheckTransferStatus[        lastStatus, sst, why];  -- may generate error    lastSST ¬ sst;    EXITS noChannel =>      ERROR GateMake.OperationAborted[transmissionMediumDown];    END;  SetSST: PROCEDURE [    sH: CFDStream.Handle, sst: CFDStream.SubSequenceType] = BEGIN END;  SendAttention: PROCEDURE [    sH: CFDStream.Handle, byte: CFDStream.Byte] =    BEGIN    ENABLE RS232C.ChannelSuspended => GOTO noChannel;    SELECT byte FROM      GateStream.abortGetTransaction, GateStream.abortPutTransaction =>        -- Figure out right thing to do here later!         [] ¬ ReportEvent[destroyMedium, FALSE];      GateStream.cleanup =>        BEGIN        NotifyAttentionArrived[GateStream.cleanup];        [] ¬ ReportEvent[destroyMedium, FALSE];        END;      GateStream.interrupt => RS232C.SendBreak[channelHandle];      ENDCASE;  -- others treated as NOPs    EXITS      noChannel =>        ERROR GateMake.OperationAborted[transmissionMediumDown];    END;  WaitAttention: ENTRY PROCEDURE [sH: CFDStream.Handle]    RETURNS [byte: CFDStream.Byte] =    -- wait for break or cleanup     BEGIN ENABLE UNWIND => NULL;    UNTIL (byte ¬ receivedAttention) # GateStream.none DO      WAIT attentionArrived; ENDLOOP;    receivedAttention ¬ GateStream.none;  -- termination condition    END;  Delete: PROCEDURE [sH: CFDStream.Handle] =    -- free any resources we may be using, recover FORK'ed processes    BEGIN    -- locals    -- do transfer waits on any outstanding gets if transducer is doing buffering    RS232C.Suspend[channelHandle, all ! ABORTED => RETRY];    RS232C.SetParameter[channelHandle, [dataTerminalReady[FALSE]] !       ABORTED => RETRY];    -- Do transfer waits on any waiting Gets.  Note that we have to be    -- careful and not do a transfer wait if we have already done one.    -- If "moreData" is TRUE then we have already done a transfer wait on    -- the topBufferElement and so we skip that one, simply setting moreDat    -- to FALSE.    IF buffering THEN      BEGIN      UNTIL topBufferElement = NIL DO        IF dataLeft THEN dataLeft ¬ FALSE  -- Don't xferWait twice20-Mar-84 10:44:25  BRD	 Enable aborts on lineChange 	ELSE [] ¬ RS232C.TransferWait[channelHandle, topBufferElement.comp];        topBufferElement ¬ topBufferElement.next;        ENDLOOP;      Heap.Delete[myHeap];      END;    -- terminate WaitAttention if any    NotifyAttentionArrived[GateStream.cleanup];    --Do something to nil out SPY Procedures if first instance    instanceData.getSpyProcedure ¬ NIL;    instanceData.putSpyProcedure ¬ NIL;    instanceData.statusSpyProcedure ¬ NIL;    instanceData.stopSpyProcedure ¬ NIL;    instanceData.line ¬ LAST[CARDINAL];    -- delete the status watcher (it returned when channel deleted)    JOIN connectionStatusProcess;    FreeInstance[];    IF newed THEN Runtime.SelfDestruct[];    END;    -- Support Procedures  CheckTransferStatus: PRIVATE PROCEDURE [    transferStatus: RS232C.TransferStatus, sst: CFDStream.SubSequenceType,    why: CFDStream.CompletionCode] RETURNS [newSST: CFDStream.SubSequenceType,    newWhy: CFDStream.CompletionCode] =    -- check status after a data transfer operation    BEGIN    --locals    globalStatus: RS232C.DeviceStatus;    newSST ¬ sst;    newWhy ¬ why;    SELECT transferStatus FROM      success => NULL;      frameTimeout, aborted =>        ERROR GateMake.OperationAborted[garbledReceiveData];      dataLost =>        IF async  	  THEN NotifyAttentionArrived[GateStream.noGetForData]	  ELSE ERROR GateMake.OperationAborted[garbledReceiveData];      asynchFramingError => newSST ¬ GateStream.garbledReceiveData;       deviceError =>        BEGIN  -- some global status        globalStatus ¬ RS232C.GetStatus[channelHandle];        IF globalStatus.dataLost THEN ClearDataLost[];        IF globalStatus.breakDetected THEN BreakReceived[];        END;      checksumError, invalidChar, invalidFrame =>        ERROR GateMake.OperationAborted[checksumError];      parityError => newSST ¬ GateStream.parityError;      ENDCASE =>  -- disaster        ERROR GateMake.OperationAborted[transmissionMediumDown];    IF sst # newSST THEN newWhy ¬ sstChange;    END;  ClearDataLost: PRIVATE PROCEDURE =    -- clear data lost latch    BEGIN    --locals    mask: RS232C.LatchBitClearMask;    -- clear it by setParam    totDataLost ¬ totDataLost + 1;    mask ¬ LOOPHOLE[0, RS232C.LatchBitClearMask];    mask.dataLost ¬ TRUE;    NotifyAttentionArrived[GateStream.noGetForData];    RS232C.SetParameter[      channelHandle, [latchBitClear[mask]] !      RS232C.ChannelSuspended => GOTO noChannel];    EXITS      noChannel =>        ERROR GateMake.OperationAborted[transmissionMediumDown];    END;  BreakReceived: PROCEDURE =    -- notify client and clear breakDetected latch    BEGIN    --locals        mask: RS232C.LatchBitClearMask;    breakCnt ¬ breakCnt + 1;    mask ¬ LOOPHOLE[0, RS232C.LatchBitClearMask];    mask.breakDetected ¬ TRUE;    NotifyAttentionArrived[GateStream.interrupt];  -- a generic control    RS232C.SetParameter[      channelHandle, [latchBitClear[mask]] !      RS232C.ChannelSuspended => GOTO noChannel];    EXITS      noChannel =>        ERROR GateMake.OperationAborted[transmissionMediumDown];    END;  DoTheNextGet: PROCEDURE =    BEGIN    -- Remove top buffer element from queue, do a Get, and insert buffer element    -- at the end of the queue if the Get was successful.    bufferElement: BufferElementPointer ¬ topBufferElement;    physicalRecord: RS232C.PhysicalRecord ¬ [      [NIL, 0, 0], [LOOPHOLE[@bufferElement.buffer], 0, bufferSize], [NIL, 0, 0]];    topBufferElement ¬ bufferElement.next;    bufferElement.comp ¬ RS232C.Get[      channelHandle, @physicalRecord !        RS232C.ChannelSuspended => GOTO channelSuspended];    bottomBufferElement.next ¬ bufferElement;    bottomBufferElement ¬ bufferElement;    bufferElement.next ¬ NIL;    EXITS channelSuspended => NULL;    END;    InitializeBuffering: PROCEDURE [size, howMany: CARDINAL] =     BEGIN    newElement: BufferElementPointer;    pageCount: CARDINAL ¬ SIZE[BufferElement[size]] * howMany/      Environment.wordsPerPage + 1;    bufferSize ¬ size;    buffering ¬ TRUE;    myHeap ¬ Heap.CreateUniform[initial: pageCount,       maxSize: SIZE[BufferElement[size]], increment:  1,       objectSize: SIZE[BufferElement[size]]];    bottomBufferElement ¬ topBufferElement ¬ NIL;    THROUGH [0..howMany) DO      newElement ¬ myHeap.NEW[BufferElement[size]];      newElement.next ¬ topBufferElement;      topBufferElement ¬ newElement;      IF bottomBufferElement = NIL THEN bottomBufferElement ¬ topBufferElement;      ENDLOOP;    THROUGH [0..howMany) DO DoTheNextGet[] ENDLOOP;    END;       NotifyAttentionArrived: ENTRY PROCEDURE [    attentionByte: CFDStream.SubSequenceType] =    -- notify the condition    BEGIN    receivedAttention ¬ attentionByte;    NOTIFY attentionArrived;    END;  ConnectionWatch: PRIVATE PROCEDURE [status: RS232C.DeviceStatus] =    -- a process to wait for an abnormal status change    -- this process must terminate if channel goes away    BEGIN    --locals    -- wait for complete connection (may be complete already)    UNTIL status.dataSetReady DO      status ¬ RS232C.StatusWait[        channelHandle, status !        RS232C.ChannelSuspended => GOTO abortedBeforeMediumUp];      ENDLOOP;    -- report completion and await abnormal termination    IF status.statusAborted THEN GOTO abortedBeforeMediumUp;    IF ~ReportEvent[connectionComplete, status.ringHeard] THEN      BEGIN      NotifyLineChange[lineUp];  -- tell a waiting sender to proceed      -- wait for abnormal status change; go away if fatal, hard change      UNTIL HardStatusChange[status] = mediumDown DO        status ¬ RS232C.StatusWait[          channelHandle, status !          RS232C.ChannelSuspended => EXIT];        IF status.statusAborted THEN EXIT;        ENDLOOP;      END;    NotifyLineChange[aborted];    -- if sender waiting for DSR, this will complete them    IF ~ReportEvent[mediumDown, FALSE] THEN      BEGIN      -- world not ending yet, but make channel operations complete and hang up phone      -- and stop monitoring      RS232C.Suspend[channelHandle, all ! ABORTED => RETRY];      RS232C.SetParameter[channelHandle, [dataTerminalReady[FALSE]] !        ABORTED => RETRY];      END    ELSE NULL;  -- Mgr taking care of channel deletion when stream deleted    EXITS      abortedBeforeMediumUp => -- channel suspended before DSR came up	BEGIN	NotifyLineChange[aborted];	[] ¬ ReportEvent[destroyMedium, FALSE];	END;    END;  HardStatusChange: PRIVATE PROCEDURE [status: RS232C.DeviceStatus] RETURNS [hardStatus: GateMake.ModuleStatus] =    -- check DSR status; determine if non-transient    BEGIN    --locals    dsrRecovTimeInSecs: CARDINAL = 5;  -- tenths of secs to wait for DSR recovery    loopWait: CARDINAL ¬ 100;  -- msecs between checking for DataSetReady    loopCount: CARDINAL ¬ dsrRecovTimeInSecs*100/loopWait;    i: CARDINAL;    temp: RS232C.DeviceStatus;    -- see if DSR drop is solid     IF ~status.dataSetReady THEN      BEGIN  -- wait a reasonable time for it to come back without hogging      FOR i IN [0..loopCount] DO        WaitFor[loopWait];	temp ¬ status;        status ¬ RS232C.GetStatus[          channelHandle ! RS232C.ChannelSuspended => EXIT];        IF temp # status AND instanceData.statusSpyProcedure # NIL	THEN instanceData.statusSpyProcedure[status];        IF status.statusAborted THEN EXIT;        IF status.dataSetReady THEN RETURN[connectionComplete];        ENDLOOP;      hardStatus ¬ mediumDown;  -- it didn't come back in loopCount retries      END    ELSE hardStatus ¬ connectionComplete;    END;  NotifyLineChange: PRIVATE ENTRY PROCEDURE [newState: LineState] =    -- tell sender about state of line    BEGIN    --locals    lineState ¬ newState;    NOTIFY lineChange;    END;  WaitLineChange: PRIVATE ENTRY PROCEDURE    RETURNS [newState: LineState] =    -- wait for active or aborted state    BEGIN ENABLE UNWIND => NULL;    --locals    UNTIL (lineState = lineUp) OR (lineState = aborted) DO      WAIT lineChange; ENDLOOP;    RETURN[lineState];    END;  ReportEvent: PROCEDURE [    moduleStatus: GateMake.ModuleStatus, ringHeard: BOOLEAN]    RETURNS [commitSuicide: BOOLEAN] =    -- report event to Gateway Manager    BEGIN    --locals    eventReport: transducer GateMake.ModuleReportObject ¬ [      moduleStatus: moduleStatus,      variantPart: transducer[      interfaceHandle: @channelHandle,      transducerReason:      (IF ringHeard THEN weWereCalled ELSE noReason)]];    commitSuicide ¬ reportProc[eventReport];    END;    -- Misc Support Routines    SuspendLine: PUBLIC ENTRY PROCEDURE [line: CARDINAL] =    BEGIN    -- look for correct line #    instance: InstanceHandle;    FOR instance ¬ instanceHead, instance.nextInstance UNTIL instance = NIL DO      IF instance.line = line THEN EXIT;      REPEAT        FINISHED => RETURN;      ENDLOOP;    RS232C.Suspend[instance.channel, all];    END;  WaitFor: PRIVATE ENTRY PROCEDURE [msecs: CARDINAL] =    -- wait for specified millisecs    BEGIN    --locals    timeOut: CONDITION;    Process.InitializeCondition[@timeOut, Process.MsecToTicks[msecs]];    WAIT timeOut;    END;  GetNewInstance: ENTRY PROCEDURE RETURNS [    new: BOOLEAN] =    BEGIN -- always called from original instance	    new ¬ inUse;    inUse ¬ TRUE;    END;    FreeInstance: ENTRY PROCEDURE =    BEGIN inUse ¬ FALSE END;     SetSpy: PUBLIC ENTRY PROCEDURE [line: CARDINAL, get: GateSpy.GetSpyProcedure,    put: GateSpy.PutSpyProcedure, status: GateSpy.StatusSpyProcedure,    stop: GateSpy.StopSpyProcedure] RETURNS [BOOLEAN] =  BEGIN    temp: InstanceHandle;    searching ¬ TRUE;    UNTIL instanceHead # NIL OR ~searching DO WAIT newInstance; ENDLOOP;    IF ~searching THEN RETURN [FALSE];    temp ¬ instanceHead;    UNTIL temp.line = line DO      IF ~searching THEN RETURN[FALSE];      IF temp.nextInstance # NIL THEN temp ¬ temp.nextInstance      ELSE BEGIN         WHILE temp.nextInstance = NIL AND searching DO 	    WAIT newInstance;         ENDLOOP;         temp ¬ instanceHead;	 END;      ENDLOOP;    temp.getSpyProcedure ¬ get;    temp.putSpyProcedure ¬ put;    temp.stopSpyProcedure ¬ stop;    temp.statusSpyProcedure ¬ status;    searching ¬ FALSE;    RETURN [TRUE];  END;     ClearSpy: PUBLIC ENTRY PROCEDURE [line: CARDINAL] RETURNS [BOOLEAN] =   BEGIN   temp: InstanceHandle ¬ instanceHead;   IF searching THEN {      searching ¬ FALSE;      NOTIFY newInstance;      RETURN[FALSE];      }   ELSE {      WHILE temp # NIL DO         IF temp.line = line THEN EXIT ELSE temp ¬ temp.nextInstance;      REPEAT         FINISHED => RETURN[FALSE];      ENDLOOP;      temp.getSpyProcedure ¬  NIL;      temp.putSpyProcedure ¬ NIL;      temp.statusSpyProcedure ¬ NIL;      temp.stopSpyProcedure ¬ NIL;      RETURN[TRUE];      };   END;  StatusSpy: PROCEDURE =   BEGIN   -- this will invoke the statusSpyProc if needed.   END;    Enqueue: ENTRY PROCEDURE [instance:InstanceHandle] =   BEGIN   instance.nextInstance ¬ instanceHead;   instanceHead ¬ instance;   NOTIFY newInstance;   END;    Dequeue: ENTRY PROCEDURE [stream: CFDStream.Handle]    RETURNS [instance: InstanceHandle] =   BEGIN   previous: InstanceHandle ¬ NIL;   FOR instance ¬ instanceHead, instance.nextInstance UNTIL instance = NIL DO     IF @instance.instanceObject.streamObject = stream THEN       BEGIN       IF previous = NIL THEN -- Deleting top entry in queue.         instanceHead ¬ instance.nextInstance       ELSE previous.nextInstance ¬ instance.nextInstance;       EXIT;       END;     previous ¬ instance;     REPEAT       FINISHED => ERROR;  -- Didn't find instance     ENDLOOP;   END;	   -- MAIN PROGRAM --    Process.EnableAborts[@attentionArrived];  Process.EnableAborts[@lineChange];  END.LOG15-Jul-81 11:38:35  BRD  Combined RSTransducer, RSTransducerMgr, and                          TTYRingInstance into one module12-Oct-81 14:29:44  BRD  1) New DSR monitoring code  2) Make DataError SIGNAL                         3) Always wait for CTS before xmitting23-Oct-81 18:18:22  BRD  Add buffering for polledBSC26-Oct-81 14:55:44  BRD  Follow stream rules for sstChange15-Dec-81 10:01:36  MC   Changed buffer size for polledBSC to 1024                          (was 256) 1-Apr-82 14:04:43  BRD  Put back in PolledBSC buffering (two 2048 buffers)23-Jan-83 17:55:00  MAT	 Code to catch ChannelSuspended in module SendAttention23-Jun-83 14:58:20  BRD	 Spy Procedures and Spy Control; EXPORT GateSpy 6-Oct-83 18:48:31  BRD	 Klamath Conversion18-Oct-83 14:20:04  BRD	 Merge in some of MT logging code31-Oct-83 15:30:26  MA	 Add InitializeBuffering to StartRSTransducer 1-Nov-83  9:35:16  BRD	 Enable aborts on WaitAttention15-Jan-84 14:30:27  BRD	 Fixed instance Enqueue/Dequeue code 5-Mar-84 11:55:02  BRD	 Retry any aborts from RS232C channel calls20-Mar-84 10:44:25  BRD	 Enable aborts on lineChange20-Mar-84 10:52:40  BRD	 If moreData set, don't xferWait twice. 5-Jul-84 14:41:31  BRD  Fix dataLost to report it based on head bug.15-Feb-85  8:33:34  AOF  CommParamHandles became LONG 3-Dec-85 16:18:36  AOF  Notify SSTChange when a parity error occurs
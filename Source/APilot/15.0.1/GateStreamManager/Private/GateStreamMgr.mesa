-- File: GateStreamMgr.mesa - last edit:-- AOF                 21-Jan-87 11:54:42-- Bishop.PA           20-Mar-84  9:50:57-- Danielson.PA         5-Mar-84 11:56:10-- Thatcher.PA         27-Feb-84 10:24:13-- Artibee.pa          23-Mar-84 17:49:33-- AOF		       12-Feb-85 15:49:44-- Copyright (C) 1983, 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Auth USING [Credentials, Verifier],  CFDStream USING [Handle, SubSequenceType],  Courier USING [SystemElement],  Dialup USING [AbortCall, Dial, Number, Outcome, pause],  GateMake USING [    AwaitConnectionReady, BscDriverImpl, DataErrorReason, DriverHandle,     GateStreamMgrInstance, InitRSTransducer,    <<InitBscDriver, >>InitFramer, InitMux, <<InitSNA, >>InitTeletypeDriver,     InitPolledBSCDriver, LUs, NewLUSession, NewTerminalForMux,     OperationAbortedReason, ProtocolDescriptor, ProtocolDescHandle,     RSTransducerInstance, StatusReporter],  GateMakeExtras USING [ProtocolDescHandle, ProtocolDescriptor,    InitSiemensMSV1Driver, InitSiemensMux, NewTerminalForSiemensMux],  GateMakeExtraExtras USING [InitBSCDriver, InitSNA],  GateStreamExtras USING [SessionParameterHandle],  GateStream USING [    AuthenticateProc, CallBackType, CompletionProcedure, ControllerAddress,    DeviceAddress, DeviceType, Error,     ForeignDevice, infiniteTime, LineControl, NopAuthenticateProc, NopPollProc,     PollProc, Resource, SessionParameterHandle, TransportObject,    unspecifiedDeviceAddress, WaitTime],  GateStreamInternal USING [    CreateMgrInstance, MgrInstanceHandle, ProcedureObject,     RegisterManager, ResourceHandle, ResourceObject],  Heap USING [Error, systemZone],  NSName USING [Name],  NSString USING [String],  Process USING [Detach, InitializeCondition, SecondsToTicks,    SetTimeout],  RS232C USING [    AutoRecognitionWait, AutoRecognitionOutcome, ChannelHandle, ChannelInUse,    ChannelSuspended, CharLength, CommParamObject, Create, Delete, GetStatus,    InvalidLineNumber, InvalidParameter, LineType, NoRS232CHardware, Parity,    SetLineType, SetParameter, DeviceStatus, --RedefineChannelUse,-- ReserveType,    Suspend, StatusWait, StopBits, UnimplementedFeature],  RS232CCorrespondents USING [xerox800, xerox850, system6, ibm3270Host,    nsSystemElement, siemens9750, ttyHost, failure],  RS232CEnvironment USING [LineSpeed],  System USING [nullNetworkAddress];GateStreamMgr: MONITOR  IMPORTS Dialup, GateStream, GateMake, GateMakeExtras, GateMakeExtraExtras,    GateStreamInternal, Heap, Process, RS232C  EXPORTS GateStream, GateMake, GateStreamInternal, CFDStream =    BEGIN    Resource: PUBLIC TYPE = GateStreamInternal.ResourceHandle;  -- CFDStream EXPORTS    EndOfStream: PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  LongBlock: PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  ShortBlock: PUBLIC ERROR = CODE;  SSTChange: PUBLIC SIGNAL [sst: CFDStream.SubSequenceType,    nextIndex: CARDINAL] = CODE;  TimeOut: PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;    OperationAborted: PUBLIC ERROR [reason: GateMake.OperationAbortedReason] = CODE;  DataError: PUBLIC SIGNAL [reason: GateMake.DataErrorReason] = CODE;    z: UNCOUNTED ZONE = Heap.systemZone;    mgr: GateStreamInternal.ProcedureObject ¬ [    DoCreate, DoReserve, DoAbortReserve, DoUseMediumForOISCP];  -- protocol Descriptors  x800ProtocolDescriptor: bsc GateMakeExtras.ProtocolDescriptor = [    byteSize: 8, parity: none, correspondent: RS232CCorrespondents.xerox800,    stopBits: 1, syncCount: 0, syncChar: 0,  -- SYN added by Framer & Driver    maxSendBlockSize: 254, maxReceiveBlockSize: 254, codeSet: ascii,    variantPart: bsc[    intraFrameTimeOut: 0 -- means infinite -- , contentionControl: primary]];  x850ProtocolDescriptor: bsc GateMakeExtras.ProtocolDescriptor = [    -- Also used by Xerox860 for now -- byteSize: 8, parity: none,    correspondent: RS232CCorrespondents.xerox850, stopBits: 1, syncCount: 2,    syncChar: 26B,  -- SYN    maxSendBlockSize: 506,  -- [512-framing] problem)     maxReceiveBlockSize: 512, codeSet: ascii,    variantPart: bsc[    intraFrameTimeOut: 0 -- means infinite -- , contentionControl: primary]];  sys6ProtocolDescriptor: bsc GateMakeExtras.ProtocolDescriptor = [    byteSize: 8, parity: none, correspondent: RS232CCorrespondents.system6,    stopBits: 1, syncCount: 2, syncChar: 62B,  -- SYN    maxSendBlockSize: 512, maxReceiveBlockSize: 512, codeSet: ebcdic,    variantPart: bsc[intraFrameTimeOut: 0, contentionControl: primary]];  ttyHostProtocolDescriptor: ttySimulate GateMakeExtras.ProtocolDescriptor = [    byteSize: 7, parity: even, correspondent: RS232CCorrespondents.ttyHost,    stopBits: 1, syncCount: 0, syncChar: 0, maxSendBlockSize: 1024,    maxReceiveBlockSize: 1024,  -- "ring buffer"     codeSet: ascii,     variantPart: ttySimulate[frameTimeout: 100, flowControl:[none, 0, 0]]];  ibm3270ProtocolDescriptor: ibm3270 GateMakeExtras.ProtocolDescriptor ¬ [    byteSize: 8, parity: none,    correspondent: RS232CCorrespondents.ibm3270Host,      stopBits: 1, syncCount: 2, syncChar: 62B, maxSendBlockSize:256,    maxReceiveBlockSize: 4096, codeSet: ebcdic,    variantPart: ibm3270[      controllerAddress: GateStream.unspecifiedDeviceAddress]];        siemens9750ProtocolDescriptor: ibm3270 GateMakeExtras.ProtocolDescriptor ¬ [    byteSize: 7, parity: odd,    correspondent: RS232CCorrespondents.siemens9750,      stopBits: 1, syncCount: 3, syncChar: 26B, maxSendBlockSize: 256,    maxReceiveBlockSize: 4096, codeSet: ascii,    variantPart: ibm3270[      controllerAddress: GateStream.unspecifiedDeviceAddress]];  -- constants  timerResolutionInSecs: CARDINAL = 2;  --secs  -- Public Interface procedures     DoCreate: PROCEDURE [systemElement: Courier.SystemElement,    sessionParameterHandle: GateStream.SessionParameterHandle,    transport: LONG DESCRIPTOR FOR ARRAY OF GateStream.TransportObject,    createTimeout: GateStream.WaitTime, version: CARDINAL,    credentials: Auth.Credentials, verifier: Auth.Verifier]    RETURNS [cfdStream: CFDStream.Handle] =    -- Create a gateway stream     BEGIN    mgr: GateStreamInternal.MgrInstanceHandle ¬      GateStreamInternal.CreateMgrInstance[];    rs232cDirectConnect: BOOLEAN ¬ FALSE;  --NEW  11-Jul-83    BEGIN    ENABLE UNWIND => mgr.delete[mgr.cfdStream];    -- Build gateway stream based on transport list.    -- First comes the physical medium level.  It must currently be RS232C    protocolDescriptor: GateMakeExtras.ProtocolDescriptor;    level: CARDINAL;    commParams: LONG POINTER TO RS232C.CommParamObject;    phoneNumber: LONG STRING;    siemensIsClient: BOOLEAN ¬ FALSE;    snaIsClient: BOOLEAN ¬ FALSE;        siemensIsClient ¬ SetProtocolDescriptor[LOOPHOLE[sessionParameterHandle, GateStreamExtras.SessionParameterHandle], @protocolDescriptor,       transport];    WITH transport: transport[0] SELECT FROM      rs232c =>        BEGIN	WITH transport.commParams SELECT FROM  --NEW  11-Jul-83	  directConn => rs232cDirectConnect ¬ TRUE;  --NEW  11-Jul-83	  ENDCASE;  --NEW  11-Jul-83	commParams ¬ transport.commParams;	phoneNumber ¬ transport.phoneNumber;        mgr.medium ¬ DoReserve[transport, NIL, dontCall];	WITH resource: mgr.medium SELECT FROM	  rs232c =>  -- should always be rs232c	    BEGIN	    changeLineType: BOOLEAN ¬ resource.lineType=autoRecognition;            SetChannelParams[resource.channel, transport.commParams,	      @protocolDescriptor, changeLineType];            mgr.cfdStream ¬ GateMake.InitRSTransducer[              mgr.medium, transport.commParams,	      LOOPHOLE[LONG[@protocolDescriptor], GateMake.ProtocolDescHandle],              mgr.statusReporter];            -- tell modem we are ready            RS232C.SetParameter[resource.channel, [dataTerminalReady[TRUE]] !	      ABORTED => CONTINUE];	    -- set RTS FALSE for half-duplex, TRUE for duplex            RS232C.SetParameter[resource.channel,	      [requestToSend[transport.commParams.duplex = full]] !	        ABORTED => CONTINUE];	    END;	  ENDCASE;        END;      polledBSCTerminal =>       	  BEGIN	  IF siemensIsClient	    THEN AddNewSiemensTerminal[@transport, mgr, TRUE, credentials, verifier]	    ELSE AddNewTerminal[@transport, mgr, TRUE, credentials, verifier !	      GateStream.Error => IF reason = controllerDoesNotExist THEN 	        GOTO kludge];   	  EXITS	    -- this is a kludge so old Star can create sessions 	    --with SNA controllers	    kludge => AddNewSNADevice[@transport, mgr, version, FALSE,	      credentials, verifier, luTwo];	  END;      polledBSCPrinter =>         IF siemensIsClient	  THEN AddNewSiemensTerminal[@transport, mgr, FALSE, credentials, verifier]	  ELSE AddNewTerminal[@transport, mgr, FALSE, credentials, verifier];      sdlcTerminal => AddNewSNADevice[@transport, mgr, version, TRUE,        credentials, verifier, luTwo];      sdlcPrinter => AddNewSNADevice[@transport, mgr, version, TRUE,        credentials, verifier, luThree];      ENDCASE => ERROR GateStream.Error[illegalTransport];    FOR level IN [1..LENGTH[transport]) DO      WITH transport: transport[level] SELECT FROM        bsc =>          MakeBSCTransport[rs232cDirectConnect,  --NEW  11-Jul-83            sessionParameterHandle, @transport,	    LOOPHOLE[LONG[@protocolDescriptor], GateMake.ProtocolDescHandle], mgr];        teletype =>          MakeTeletypeTransport[	    systemElement, LOOPHOLE[sessionParameterHandle, GateStreamExtras.SessionParameterHandle], @transport,	    protocolDescriptor, mgr, credentials, verifier];	polledBSCController => 	  IF siemensIsClient	    THEN MakeMSV1Transport[sessionParameterHandle, @transport,              LOOPHOLE[LONG[@protocolDescriptor], GateMake.ProtocolDescHandle], 	      mgr, commParams.lineSpeed, transport.accessControl, 	      transport.controllerName, transport.controllerPassword]	    ELSE MakePolledBSCTransport[sessionParameterHandle, @transport,	      LOOPHOLE[LONG[@protocolDescriptor], GateMake.ProtocolDescHandle], 	      mgr, commParams.lineSpeed, transport.accessControl, 	      transport.controllerName, transport.controllerPassword];	sdlcController => {	  snaIsClient ¬ TRUE;	  MakeSNATransport[	    sessionParameterHandle, @transport,	    LOOPHOLE[LONG[@protocolDescriptor], GateMake.ProtocolDescHandle], 	    mgr, commParams, createTimeout, phoneNumber,	    transport.accessControl, transport.controllerName,	    transport.controllerPassword] };        ENDCASE => ERROR GateStream.Error[illegalTransport];      ENDLOOP;    mgr.attentionProcess[];    WITH transport: transport[0] SELECT FROM      rs232c => IF ~snaIsClient         THEN ActivateRS232CTransport[@transport, createTimeout];      ENDCASE;    RETURN[mgr.cfdStream];    END;  -- for UNWIND    END;  DoReserve: PROCEDURE [transport: GateStream.TransportObject,    completionProcedure: GateStream.CompletionProcedure,    callBackType: GateStream.CallBackType]    RETURNS [resource: Resource] =    BEGIN    resource ¬ NIL;    WITH trans: transport SELECT FROM      rs232c =>        BEGIN	WITH t: trans.line SELECT FROM          reserveNeeded =>            BEGIN  -- need to allocate resource record and reserve RS232C line            ENABLE UNWIND => IF resource # NIL THEN z.FREE[@resource];	    commP: RS232C.CommParamObject ¬ trans.commParams­;  -- Copy to shorten            resource ¬ z.NEW[rs232c GateStreamInternal.ResourceObject !              Heap.Error => ERROR GateStream.Error[tooManyGateStreams]];            resource­ ¬ [0, rs232c[              line: t.lineNumber,              lineType: trans.commParams.lineType, -- GateStream.Create chks this	      channel: RS232C.Create[                t.lineNumber, @commP,  		trans.preemptOthers, trans.preemptMe !                  RS232C.UnimplementedFeature, RS232C.InvalidParameter =>                    ERROR GateStream.Error[inconsistentParams];                  RS232C.ChannelInUse => ERROR GateStream.Error[		    transmissionMediumUnavailable];                  RS232C.NoRS232CHardware, RS232C.InvalidLineNumber =>                    ERROR GateStream.Error[noCommunicationHardware]],	      currentStatus: [FALSE, FALSE, FALSE, FALSE, FALSE, 		FALSE, FALSE, FALSE, FALSE],	      process: NIL]];  -- process filled in below            END;          alreadyReserved =>            BEGIN  -- simply copy resource handle and JOIN any process            resource ¬ t.resource;            WITH r: resource SELECT FROM	      rs232c => IF r.process # NIL THEN JOIN r.process;	      ENDCASE => ERROR GateStream.Error[illegalTransport];            END;          ENDCASE => ERROR GateStream.Error[illegalTransport];        WITH r: resource SELECT FROM	  rs232c => 	    r.process ¬ SELECT callBackType FROM            dontCall => NIL,            ENDCASE => FORK ReserveWait[resource, completionProcedure,	      callBackType];	  ENDCASE => ERROR GateStream.Error[illegalTransport];	END;      ENDCASE => ERROR GateStream.Error[illegalTransport];    END;  ReserveWait: PROCEDURE [    resource: Resource, completionProcedure: GateStream.CompletionProcedure,    callBackType: GateStream.CallBackType] =    BEGIN    WITH r: resource SELECT FROM      rs232c =>        BEGIN        RS232C.SetParameter[r.channel, [requestToSend[FALSE]]];        RS232C.SetParameter[r.channel, [dataTerminalReady[TRUE]]];        SELECT callBackType FROM	  callOnAutoRecognition =>	    BEGIN	    outcome: RS232C.AutoRecognitionOutcome ¬ RS232CCorrespondents.failure;	    outcome ¬ RS232C.AutoRecognitionWait[r.channel !	      RS232C.ChannelSuspended => CONTINUE];	    completionProcedure[resource, [callOnAutoRecognition[outcome]]];	    IF outcome # RS232CCorrespondents.failure THEN	      r.currentStatus ¬ RS232C.GetStatus[r.channel !	      RS232C.ChannelSuspended => CONTINUE];	    END;	  callOnActive =>	    BEGIN	    outcome: BOOLEAN ¬ TRUE;	    UNTIL r.currentStatus.dataSetReady DO              r.currentStatus ¬ RS232C.StatusWait[                r.channel, r.currentStatus !		  RS232C.ChannelSuspended => GO TO terminate];              REPEAT	        terminate => outcome ¬ FALSE;	      ENDLOOP;	    completionProcedure[resource, [callOnActive[outcome]]];	    END;	  ENDCASE;	END;      ENDCASE;    END;  DoAbortReserve: PROCEDURE [resource: Resource] =    BEGIN  -- Only rs232c supported now    QuiesceTransmissionMedium[resource];    WITH r: resource SELECT FROM      rs232c => IF r.process # NIL THEN JOIN r.process;      ENDCASE => ERROR GateStream.Error[illegalTransport];    DeleteTransmissionMedium[resource];    END;  QuiesceTransmissionMedium: PUBLIC PROCEDURE [    resource: Resource] =    BEGIN    IF resource # NIL THEN      WITH r: resource SELECT FROM        rs232c =>	  BEGIN ENABLE ABORTED => RETRY;	  RS232C.Suspend[r.channel, all];	  RS232C.SetParameter[r.channel, [dataTerminalReady[FALSE]]];	  END;        ENDCASE;    END;  DeleteTransmissionMedium: PUBLIC PROCEDURE [    resource: Resource] =    BEGIN    IF resource # NIL THEN      BEGIN       WITH r: resource SELECT FROM        rs232c => RS232C.Delete[r.channel ! ABORTED => RETRY];	ENDCASE;      z.FREE[@resource];      END;    END;  DoUseMediumForOISCP: PROCEDURE [transport: GateStream.TransportObject] =    BEGIN    resource: Resource ¬ NIL;    WITH trans: transport SELECT FROM      rs232c =>        BEGIN ENABLE UNWIND => IF resource # NIL THEN DoAbortReserve[resource];	resource  ¬  DoReserve[transport, NIL, dontCall];        WITH r: resource SELECT FROM          rs232c =>            BEGIN ENABLE              BEGIN              RS232C.InvalidParameter =>	        ERROR GateStream.Error[inconsistentParams];              RS232C.ChannelSuspended =>	        ERROR GateStream.Error[mediumConnectFailed];              END;            RS232C.SetLineType[r.channel, bitSynchronous];            << RS232C.RedefineChannelUse[              r.channel, trans.commParams, oisCommunication, trans.preemptOthers,              trans.preemptMe]; >>            Process.Detach[FORK ChannelWatcher[r.channel]];            END;	  ENDCASE => ERROR GateStream.Error[illegalTransport];	END;      ENDCASE => ERROR GateStream.Error[illegalTransport];    END;  ChannelWatcher: PROCEDURE [channel: RS232C.ChannelHandle] =    BEGIN    status: RS232C.DeviceStatus ¬ [      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];    DO      status ¬ RS232C.StatusWait[        channel, status ! RS232C.ChannelSuspended => EXIT];      ENDLOOP;    RS232C.Delete[channel];    END;  MakeBSCTransport: PROCEDURE [rs232cDirectConnect: BOOLEAN,  --NEW  11-Jul-83    sessionParameterHandle: GateStream.SessionParameterHandle,    transport: LONG POINTER TO bsc GateStream.TransportObject,    protocolDescriptorHandle: LONG POINTER TO GateMake.ProtocolDescriptor,    mgrInstance: GateStreamInternal.MgrInstanceHandle] =    BEGIN    lineNumber: CARDINAL ¬ 0;    bscDriver: GateMake.DriverHandle;    device: GateStream.ForeignDevice ¬ sessionParameterHandle.foreignDevice;    pollProc: GateStream.PollProc ¬ NIL;    authenticateProc: GateStream.AuthenticateProc ¬ NIL;    SELECT device FROM      xerox800, xerox850, cmcII =>        IF transport.lineControl = primary THEN	  ERROR GateStream.Error[inconsistentParams];      xerox860, system6, ibm2770, ibm2770Host, ibm6670, ibm6670Host,      ibm2780, ibm2780Host =>        WITH protocolDescriptorHandle­ SELECT FROM          bsc => contentionControl ¬ transport.lineControl;          ENDCASE => ERROR GateStream.Error[illegalTransport];      ENDCASE => ERROR GateStream.Error[unimplemented];    WITH s: sessionParameterHandle­ SELECT FROM      xerox850, xerox860 =>        pollProc ¬ IF s.pollProc = GateStream.NopPollProc THEN NopPoll	  ELSE s.pollProc;      ENDCASE;    WITH rh: mgrInstance.medium SELECT FROM      rs232c =>        lineNumber ¬ rh.line;      ENDCASE => ERROR GateStream.Error[illegalTransport];    authenticateProc ¬ IF transport.authenticateProc =      GateStream.NopAuthenticateProc THEN NopAuthenticate        ELSE transport.authenticateProc;    bscDriver ¬ GateMakeExtraExtras.InitBSCDriver[      mgrInstance.cfdStream, device, authenticateProc,      transport.localTerminalID, transport.localSecurityID, pollProc,      transport.bidReply, transport.sendLineHoldingEOTs,      transport.expectLineHoldingEOTs,      rs232cDirectConnect,  --NEW  11-Jul-83      lineNumber,  --NEW  20-Mar-84      protocolDescriptorHandle, mgrInstance.waitConnection,      mgrInstance.statusReporter];    mgrInstance.cfdStream ¬ GateMake.InitFramer[      device, bscDriver, protocolDescriptorHandle, mgrInstance.statusReporter];    END;  NopPoll: GateStream.PollProc = BEGIN RETURN[FALSE] END;  NopAuthenticate: GateStream.AuthenticateProc = BEGIN RETURN[TRUE] END;    MakeTeletypeTransport: PROCEDURE [systemElement: Courier.SystemElement,    sessionParameterHandle: GateStreamExtras.SessionParameterHandle,    transport: LONG POINTER TO teletype GateStream.TransportObject,    protocolDescriptor: GateMakeExtras.ProtocolDescriptor,    mgrInstance: GateStreamInternal.MgrInstanceHandle,     credentials: Auth.Credentials, verifier: Auth.Verifier] =    BEGIN    IF sessionParameterHandle.foreignDevice # ttyHost  AND       sessionParameterHandle.foreignDevice # oldTtyHost THEN      ERROR GateStream.Error[unimplemented];    WITH mgrInstance.medium­ SELECT FROM      rs232c =>         mgrInstance.cfdStream ¬ GateMake.InitTeletypeDriver[            systemElement # System.nullNetworkAddress, line,	    mgrInstance.cfdStream, credentials, verifier];     ENDCASE => ERROR GateStream.Error[unimplemented];    END; MakePolledBSCTransport: PROCEDURE [    sessionParameterHandle: GateStream.SessionParameterHandle,    transport: LONG POINTER TO polledBSCController GateStream.TransportObject,    protocolDescriptorHandle: LONG POINTER TO GateMake.ProtocolDescriptor,    mgrInstance: GateStreamInternal.MgrInstanceHandle,    lineSpeed: RS232CEnvironment.LineSpeed,    accessControl: LONG DESCRIPTOR FOR ARRAY OF NSName.Name,    controllerName: NSName.Name, controllerPassword: NSString.String] =    BEGIN    muxHandle: CFDStream.Handle;    device: GateStream.ForeignDevice ¬ sessionParameterHandle.foreignDevice;    protocolDescriptorHandle.variantPart ¬ ibm3270[transport.controllerAddress];    protocolDescriptorHandle.maxSendBlockSize ¬ transport.sendBlockSize;    --  the Mux is passive in that it is driven by calls from the PolledBSCDriver    --   and from the Manager; it must be initialized first    muxHandle ¬ GateMake.InitMux[      device, protocolDescriptorHandle, mgrInstance.statusReporter,      transport.hostControllerName, transport.alternateControllerName,      transport.portsOnController, transport.devicesOnController,       accessControl, controllerName, controllerPassword];    mgrInstance.cfdStream ¬ GateMake.InitPolledBSCDriver[      mgrInstance.cfdStream, muxHandle, device, protocolDescriptorHandle,       mgrInstance.statusReporter, lineSpeed ];     END;     MakeMSV1Transport: PROCEDURE [    sessionParameterHandle: GateStream.SessionParameterHandle,    transport: LONG POINTER TO polledBSCController GateStream.TransportObject,    protocolDescriptorHandle: LONG POINTER TO GateMake.ProtocolDescriptor,    mgrInstance: GateStreamInternal.MgrInstanceHandle,    lineSpeed: RS232CEnvironment.LineSpeed,    accessControl: LONG DESCRIPTOR FOR ARRAY OF NSName.Name,    controllerName: NSName.Name, controllerPassword: NSString.String] =    BEGIN    muxHandle: CFDStream.Handle;    device: GateStream.ForeignDevice ¬ sessionParameterHandle.foreignDevice;    protocolDescriptorHandle.variantPart ¬ ibm3270[transport.controllerAddress];    protocolDescriptorHandle.maxSendBlockSize ¬ transport.sendBlockSize;    --  the Mux is passive in that it is driven by calls from the SiemensMSV1Driver    --   and from the Manager; it must be initialized first    muxHandle ¬ GateMakeExtras.InitSiemensMux[      device, protocolDescriptorHandle, mgrInstance.statusReporter,      transport.hostControllerName, transport.alternateControllerName,      transport.portsOnController, transport.devicesOnController,      accessControl, controllerName, controllerPassword];    mgrInstance.cfdStream ¬ GateMakeExtras.InitSiemensMSV1Driver[      mgrInstance.cfdStream, muxHandle, device, protocolDescriptorHandle,       mgrInstance.statusReporter, lineSpeed ];     END;     MakeSNATransport: PROCEDURE [    sessionParameterHandle: GateStream.SessionParameterHandle,    transport: LONG POINTER TO sdlcController GateStream.TransportObject,    protocolDescriptorHandle: LONG POINTER TO GateMake.ProtocolDescriptor,    mgrInstance: GateStreamInternal.MgrInstanceHandle,    commParams: LONG POINTER TO RS232C.CommParamObject,    createTimeout: GateStream.WaitTime, phoneNumber: LONG STRING,    accessControl: LONG DESCRIPTOR FOR ARRAY OF NSName.Name,    controllerName: NSName.Name, controllerPassword: NSString.String] =    BEGIN    lineNumber: CARDINAL ¬ 0;    WITH rs232cHandle: mgrInstance.medium SELECT FROM      rs232c => lineNumber ¬ rs232cHandle.line;      ENDCASE => ERROR GateStream.Error[illegalTransport];    protocolDescriptorHandle.variantPart ¬ ibm3270[transport.controllerAddress];    mgrInstance.cfdStream ¬ GateMakeExtraExtras.InitSNA[      mgrInstance.cfdStream,      sessionParameterHandle.foreignDevice, protocolDescriptorHandle,       mgrInstance.statusReporter, transport.hostControllerName,      transport.alternateControllerName, transport.controllerXID, lineNumber,       transport.portsOnController, transport.devicesOnController, commParams,      createTimeout, phoneNumber,      accessControl, controllerName, controllerPassword];     END;      AddNewTerminal: PROCEDURE [    transport: LONG POINTER TO polledBSCTerminal GateStream.TransportObject,    mgrInstance: GateStreamInternal.MgrInstanceHandle,    deviceIsADisplay: BOOLEAN ¬ TRUE, credentials: Auth.Credentials,    verifier: Auth.Verifier] =    BEGIN    mgrInstance.cfdStream ¬ GateMake.NewTerminalForMux[      transport.hostControllerName, transport.deviceAddress, credentials,       verifier, deviceIsADisplay];    END;     AddNewSiemensTerminal: PROCEDURE [    transport: LONG POINTER TO polledBSCTerminal GateStream.TransportObject,    mgrInstance: GateStreamInternal.MgrInstanceHandle,    deviceIsADisplay: BOOLEAN ¬ TRUE, credentials: Auth.Credentials,    verifier: Auth.Verifier] =    BEGIN    mgrInstance.cfdStream ¬ GateMakeExtras.NewTerminalForSiemensMux[      transport.hostControllerName, transport.deviceAddress, credentials,       verifier, deviceIsADisplay];    END;     -- When do we use hostControllerName vs alternateControllerName?  -- To do: check transport name against our controllerInfo name.    AddNewSNADevice: PROCEDURE [    transport: LONG POINTER TO sdlcTerminal GateStream.TransportObject,    mgrInstance: GateStreamInternal.MgrInstanceHandle, version: CARDINAL,    requestedSNA: BOOLEAN, credentials: Auth.Credentials,    verifier: Auth.Verifier, luType: GateMake.LUs ¬ luTwo] =    BEGIN    mgrInstance.cfdStream ¬ GateMake.NewLUSession[transport.hostControllerName,         luType, transport.deviceAddress, version, requestedSNA, 	credentials, verifier];    END;        ActivateRS232CTransport: PROCEDURE [    transportHandle: LONG POINTER TO rs232c GateStream.TransportObject,    timeout: GateStream.WaitTime] =    BEGIN    ActivateRS232C[transportHandle.commParams,      transportHandle.phoneNumber, timeout];    END;  ActivateRS232C: PUBLIC PROCEDURE [    commParams: LONG POINTER TO RS232C.CommParamObject,    phoneNumber: LONG STRING, timeout: GateStream.WaitTime] =    -- finish building transport and dial phone if necessary    -- timeouts still need implementing    BEGIN    number: LONG POINTER TO Dialup.Number ¬ NIL;    index: CARDINAL;    char: CHARACTER;    -- set RS232C parameters (this should be part of RSTransducer)    -- dial the telephone, if requested    timeoutProcess: PROCESS ¬ NIL;    state: {dialing, aborting, idle} ¬ dialing;    timeoutCondition: CONDITION;    TimeoutProcess: ENTRY PROCEDURE [dialerNumber: CARDINAL] =      BEGIN ENABLE UNWIND => NULL;      DO         SELECT state FROM          dialing => -- timing out dialing	    BEGIN	    WAIT timeoutCondition;  -- wait for dialing to timeout or complete	    IF state = dialing THEN state ¬ aborting;	    END;	  aborting => -- aborting dialing	    BEGIN	    Process.SetTimeout[@timeoutCondition,	      Process.SecondsToTicks[5]]; -- retry abort after 5 seconds	    Dialup.AbortCall[dialerNumber];	    WAIT timeoutCondition;  -- wait for dialing to terminate	    END;	  idle => EXIT;  -- dialing has completed, terminate this process	  ENDCASE;        ENDLOOP;      END;    ForceIdle: PROCEDURE =      BEGIN      NotifyIdle[];      IF timeoutProcess # NIL THEN JOIN timeoutProcess;      timeoutProcess ¬ NIL;      IF number # NIL THEN z.FREE[@number];      number ¬ NIL;      END;    NotifyIdle: ENTRY PROCEDURE = INLINE      BEGIN ENABLE UNWIND => NULL;      state ¬ idle;      NOTIFY timeoutCondition;      END;    Process.InitializeCondition[@timeoutCondition,      Process.SecondsToTicks[timeout]];    WITH commParams­ SELECT FROM      dialConn =>        IF dialMode = auto AND phoneNumber # NIL AND	  phoneNumber.length # 0 THEN          BEGIN ENABLE UNWIND => ForceIdle[];          IF timeout # GateStream.infiniteTime THEN	    timeoutProcess ¬ FORK TimeoutProcess[dialerNumber];	  number ¬ z.NEW[Dialup.Number[phoneNumber.length]];	  FOR index IN [0..phoneNumber.length) DO	    number[index] ¬ SELECT char ¬ phoneNumber[index] FROM	      IN ['0..'9] => LOOPHOLE[char - '0],	      IN ['A..'F] => LOOPHOLE[char + 10 - 'A],	      IN ['a..'f] => LOOPHOLE[char + 10 - 'a],	      '* => 10,              '# => 11,              '= => 12,  -- EON --              '< => 13,  -- SEP..await dial tone --              '> => Dialup.pause,	      ENDCASE => ERROR GateStream.Error[badAddressFormat];	    ENDLOOP; 	  THROUGH [0..retryCount] DO            SELECT Dialup.Dial[dialerNumber, number, 0, RS366] FROM              success => EXIT;              dataLineOccupied, dialingTimeout, transferTimeout, transmissionError                => ERROR GateStream.Error[dialingHardwareProblem];              dialerNotPresent => ERROR GateStream.Error[noDialingHardware];              formatError => ERROR GateStream.Error[badAddressFormat];              aborted => ERROR GateStream.Error[mediumConnectFailed];	      ENDCASE;  -- includes aborted, no answer, busy, so retry            REPEAT FINISHED => ERROR GateStream.Error[mediumConnectFailed];            ENDLOOP;          ForceIdle[];          END;      ENDCASE;    END;  SetProtocolDescriptor: PROCEDURE [    sessionParameterHandle: GateStreamExtras.SessionParameterHandle,    protocolDescHandle: GateMakeExtras.ProtocolDescHandle,     transport: LONG DESCRIPTOR FOR ARRAY OF GateStream.TransportObject]    RETURNS [is9750: BOOLEAN ¬ FALSE] =    BEGIN    WITH s: sessionParameterHandle­ SELECT FROM      xerox800 => protocolDescHandle­ ¬ x800ProtocolDescriptor;      xerox850, xerox860 => protocolDescHandle­ ¬ x850ProtocolDescriptor;      system6, cmcII, ibm2770, ibm2770Host, ibm6670, ibm6670Host,      ibm2780, ibm2780Host =>        BEGIN        protocolDescHandle­ ¬ sys6ProtocolDescriptor;        protocolDescHandle.maxSendBlockSize ¬ s.sendBlocksize;        protocolDescHandle.maxReceiveBlockSize ¬ s.receiveBlocksize;        END;      oldTtyHost =>        BEGIN        protocolDescHandle­ ¬ ttyHostProtocolDescriptor;        protocolDescHandle.byteSize ¬ s.charLength;        protocolDescHandle.parity ¬ s.parity;        WITH protocolDescHandle­ SELECT FROM          ttySimulate => frameTimeout ¬ s.frameTimeout;          ENDCASE;        protocolDescHandle.stopBits ¬ s.stopBits;        END;      ttyHost =>        BEGIN        protocolDescHandle­ ¬ ttyHostProtocolDescriptor;        protocolDescHandle.byteSize ¬ s.charLength;        protocolDescHandle.parity ¬ s.parity;        WITH protocolDescHandle­ SELECT FROM          ttySimulate => {	     frameTimeout ¬ s.frameTimeout;	     flowControl ¬ s.flowControl; };          ENDCASE;        protocolDescHandle.stopBits ¬ s.stopBits;        END;      siemens9750Host =>        BEGIN	protocolDescHandle­ ¬ siemens9750ProtocolDescriptor;	is9750 ¬ TRUE;	END;      ibm3270Host =>         BEGIN	protocolDescHandle­ ¬ ibm3270ProtocolDescriptor;        WITH t0: transport[0] SELECT FROM	  rs232c => WITH t1: transport[1] SELECT FROM	    sdlcController => 	      BEGIN  -- Its an SNA controller, fix correspondent and blocksizes	      protocolDescHandle.correspondent ¬ 	        RS232CCorrespondents.nsSystemElement;	      protocolDescHandle.maxReceiveBlockSize ¬	        protocolDescHandle.maxSendBlockSize ¬ t1.linkBlockSize;	      END;	    ENDCASE;	  ENDCASE; 	END;      ENDCASE => ERROR GateStream.Error[illegalTransport];    END;  SetChannelParams: PROCEDURE [    channel: RS232C.ChannelHandle,    commParamHandle: LONG POINTER TO RS232C.CommParamObject,    protocolDescHandle: GateMakeExtras.ProtocolDescHandle, setLineType: BOOLEAN] =    -- incorporate current set of comm line parameters    BEGIN    ENABLE      BEGIN      RS232C.InvalidParameter, RS232C.UnimplementedFeature =>         ERROR GateStream.Error[inconsistentParams];      RS232C.ChannelSuspended => ERROR GateStream.Error[mediumConnectFailed];      ABORTED => RETRY;      END;    -- locals    lineType: RS232C.LineType ¬ commParamHandle.lineType;    -- set channel parameters    IF setLineType THEN RS232C.SetLineType[channel, lineType];    RS232C.SetParameter[        channel, [correspondent[protocolDescHandle.correspondent]]];    RS232C.SetParameter[channel, [lineSpeed[commParamHandle.lineSpeed]]];    IF lineType = asynchronous THEN      RS232C.SetParameter[channel, [stopBits[protocolDescHandle.stopBits]]];    IF lineType # bitSynchronous THEN      RS232C.SetParameter[channel, [parity[protocolDescHandle.parity]]];    IF lineType # bitSynchronous THEN      RS232C.SetParameter[channel, [charLength[protocolDescHandle.byteSize]]];    IF lineType = byteSynchronous THEN      RS232C.SetParameter[channel, [syncCount[protocolDescHandle.syncCount]]];    IF lineType = byteSynchronous THEN      RS232C.SetParameter[channel, [syncChar[protocolDescHandle.syncChar]]];    WITH protocolDescHandle­ SELECT FROM      ttySimulate => {         RS232C.SetParameter[channel, [frameTimeout[frameTimeout]]];	 RS232C.SetParameter[channel, [flowControl[flowControl]]];	 };      bsc => RS232C.SetParameter[channel, [frameTimeout[intraFrameTimeOut]]];      ENDCASE;    END;  -- Main program which starts everything  -- GateTeletype does not needed to be started    GateStreamInternal.RegisterManager[@mgr];  START GateMake.GateStreamMgrInstance;  START GateMake.RSTransducerInstance;  START GateMake.BscDriverImpl;  -- This starts all of the BscDriver code  END.LOG                         Rubicon release.15-Jul-81 14:11:58  BRD  Clean up DoReserve to not clobber the resource                          record when RS232C channel is already reserved. 5-Aug-81 18:38:03  BRD  Remove RS232CManager10-Aug-81 17:23:03  MMC  Manager now passes line control to BSC Driver (AR 7991)16-Aug-81 13:05:31  BRD  Changed DoFree to DoAbortReserve 3-Sep-81 13:09:09  BRD  1) Put SIGNAL definitions from CFDStreamImpl code                           into this module.  2) Added code to start all modules 4-Sep-81 16:20:06  BRD  Add code for 3270 2-Oct-81 16:50:07  MMC   Add stuff for changing way mgr initializes                          PolledBSC Transport. 5-Oct-81 18:01:16  BRD  Remove references to PolledDriverHandle.12-Oct-81 14:12:06  BRD  New Resource object 2) Fix timeout code19-Oct-81 18:19:20  BRD  Handle Nop poll and auth procs correctly23-Oct-81 15:04:37  BRD  Allow polledBSCTerminal as level 0 transport. 6-Nov-81 11:08:25  DDM  Correctly pass transducerHandle and                          muxHandle to InitPolledBSCDriver16-Dec-81 17:10:16  MMC  MaxReceiveBlockSize is now passed to the PBSCDriver17-Dec-81 17:52:48  MMC  Resource type fixed 15-Mar-82 16:44:57  BRD  Fix dialing timeout race by adding timeoutOccurred                          boolean 17-Mar-82 10:43:24  BRD  Remove polled BSC rcv blocksize parameter 18-Mar-82 11:47:52  BRD  Get rid of all the LOOPHOLEs for Resource 22-Mar-82 12:21:15  SAB  Added ibm2770, ibm2770Host, ibm6670, & ibm6670Host                          to check for deviceTypes in MakeBSCTransport. 			  Added new parameters to call line per changes made 			  in GateMake on 16-Mar-82. Added Bill Danielson's 			  change of 0, in resource­ ¬ [ to map to change in 			  GateStreamInternal of 18-Mar-82. 2-Apr-82 13:56:23  BRD  Workaround for Dialup.AbortDial race condition27-Apr-82 10:25:51  MMC  Cranked up MaxReceiveBlockSize for PolledBSCDriver			 The Rochester host made us go over 2K (now 4K temp) 6-May-82 11:07:08  MMC  Line speed is now passed to InitPolledBSCDriver to 			 increase buffering at speeds > 4800 to help Exxon			 problem with 9600 6-Oct-82 16:26:37  MZA  Added saving of lineType to DoReserve and checking of                         reserved lineType=autoRecognition in DoCreate so as to			 call on SetChannelParams with setLineType=TRUE10-Jan-83 12:01:00  SAB  Added stuff to export GateStreamExtras.  All changes                         have been initialed S-AB so FINDs can easily delete			 this kludge when GateStream is changed.  Also fixed the			 code line "ENDCASE => GateStream.Error" in a number			 of places.14-Feb-83  8:44:03  MAT  Added code to translate the signal ChannelSuspended to 			 to an outcome of failure during the call to			 RS232C.AutoRecognitionWait in ReserveWait 6-Jul-83 15:49:41  BRD  Mods required for Greeter. 8-Jul-83 16:36:53  BRD  1) Add send buffer size setting for polled BSC.  			 2) ibm2780, ibm2780Host11-Jul-83  6:41:52  SAB  Added directConnect parameter to InitBscDriver call.  6-Oct-83 16:54:55  BRD  Klamath Conversion. 13-Oct-83 10:05:24  MZA  Many changes predominantly to support SNA:			 1) added controllerInfo, CreateControllerInfo proc			 2) support new transport types in DoCreate			 3) added MakeSNATransport proc for sdlcController			 4) added display BOOLEAN to (Add)NewTerminal(ForMux)			 5) added AddNewSNADevice(Kludge) procs 9-Jan-84 17:17:36  BRD  Moved SetChannel Params ahead of starting RSTransducer  			   except for setting DTR and RTS.12-Jan-84 23:16:06  MZA  SetChannelParams to nsSystemElement if bitSynch.  9-Feb-84 14:00:42  MMC  Added MakeMSV1Transport, AddNewSiemensTerminal, Added 			 support in DoCreate, SetProtocolDescriptor 9750, Added			 siemens9750ProtocolDescriptor 21-Feb-84  9:57:48  MAT  change to GateMakeExtras and GateStreamExtras for			 supporting flow control for TTY.27-Feb-84 10:20:22  MAT	 included MMC changes of 9-Feb which got missed. 5-Mar-84 11:55:48  BRD	 Retry any aborted RS232C calls. 14-Mar-84 16:43:21  MZA	 Don't ActivateRS232CTransport in DoCreate if snaIsClient.20-Mar-84  9:42:40  SAB	 GateMakeExtraExtras with InitBSCDriver ¬ InitBscDriver			 passing lineNumber.23-Mar-84 17:39:19  MZA	 Use GateMakeExtraExtras.InitSNA passing lineNumber.21-Jan-87 11:18:26  AOF	 LONG POINTERs for MDS Relief 
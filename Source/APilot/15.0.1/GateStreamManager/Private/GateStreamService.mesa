-- File: GateStreamService.mesa - last edit:-- AOF                 14-Sep-87 19:01:40-- Copyright (C) 1984, 1985 , 1987, 1987 by Xerox Corporation. All rights reserved. -- File: GateStreamService.mesa - last edit:-- Danielson.PA         2-Jul-84 14:38:53-- AOF		       14-Feb-85 15:24:29DIRECTORY  Auth USING [Credentials, nullVerifier, nullCredentials, Verifier],  Courier USING [    Arguments, Description, Dispatcher, Error, ExportRemoteProgram,     Free, NoSuchProcedureNumber, SignalRemoteError],  CFDStream USING [Delete, Handle],  Environment USING [Block, Byte],  GateStream USING [cleanup, Error, ErrorReason, mediumDown,    none, TransportObject],  GateNetMgt USING [CallBackProc],  GateStreamCourierInternal USING [    Argument, ArgumentDescription, badAddressFormat, bugInGAPCode,     controllerAlreadyExists, controllerDoesNotExist,     CreateArgument, CurrentVersion,    dialingHardwareProblem, GAP, gapNotExported, gapCommunicationError,     illegalTransport, inconsistentParams, mediumConnectFailed,    noCommunicationHardware, noDialingHardware,    OldVersion, Procedure, Result, ResultDescription, serviceNotFound,    serviceTooBusy, deviceAddressInUse,    deviceAddressInvalid, tooManyGateStreams,    transmissionMediumUnavailable, unimplemented, userNotAuthenticated,    userNotAuthorized, Close, CloseReply],  GateStreamInternal USING [DispatcherCreate],  Heap USING [systemZone],  NetworkStream USING [closeSST, --Close, CloseReply,--    SetWaitTime, infiniteWaitTime],  Stream USING [    Block, Byte, CompletionCode, defaultObject, EndOfStream,    GetProcedure, Handle, Object, PutBlock,    PutProcedure, SetInputOptions,    SetSSTProcedure, SendAttentionProcedure, SetTimeoutProcedure,    WaitAttentionProcedure,SendAttention, SetSST, SSTChange,     TimeOut, WaitForAttention],  System USING [GreenwichMeanTime, GetGreenwichMeanTime];GateStreamService: MONITOR  IMPORTS    Courier, CFDStream, GateStream, GateStreamCourierInternal,    GateStreamInternal, Heap, NetworkStream, Stream, System  EXPORTS GateStream, GateNetMgt =  BEGIN      closingTimeout: LONG CARDINAL = 60*1000; -- 60 seconds in milliseconds  callBack: GateNetMgt.CallBackProc ¬ NIL;    -- Error mapping arrays. These arrays map GateStream errors to   -- Courier error reasons.  They also handle backward compatible  -- error mapping, that is, they map errors that are unknown by  -- older GAP clients.  OldCourierError: ARRAY GateStream.ErrorReason OF CARDINAL = [    GateStreamCourierInternal.unimplemented,    GateStreamCourierInternal.noCommunicationHardware,    GateStreamCourierInternal.illegalTransport,    GateStreamCourierInternal.mediumConnectFailed,    GateStreamCourierInternal.badAddressFormat,    GateStreamCourierInternal.noDialingHardware,    GateStreamCourierInternal.dialingHardwareProblem,    GateStreamCourierInternal.transmissionMediumUnavailable,    GateStreamCourierInternal.inconsistentParams,    GateStreamCourierInternal.tooManyGateStreams,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.gapNotExported,    GateStreamCourierInternal.gapCommunicationError,    GateStreamCourierInternal.controllerAlreadyExists,    GateStreamCourierInternal.controllerDoesNotExist,    GateStreamCourierInternal.deviceAddressInUse,    GateStreamCourierInternal.deviceAddressInvalid,    GateStreamCourierInternal.tooManyGateStreams,  -- serviceTooBusy    GateStreamCourierInternal.inconsistentParams,  -- userNotAuthenticated    GateStreamCourierInternal.inconsistentParams,  -- userNotAuthorized    GateStreamCourierInternal.unimplemented, -- serviceNotFound    GateStreamCourierInternal.bugInGAPCode, -- registeredTwice    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,     GateStreamCourierInternal.bugInGAPCode];  CourierError: ARRAY GateStream.ErrorReason OF CARDINAL = [    GateStreamCourierInternal.unimplemented,    GateStreamCourierInternal.noCommunicationHardware,    GateStreamCourierInternal.illegalTransport,    GateStreamCourierInternal.mediumConnectFailed,    GateStreamCourierInternal.badAddressFormat,    GateStreamCourierInternal.noDialingHardware,    GateStreamCourierInternal.dialingHardwareProblem,    GateStreamCourierInternal.transmissionMediumUnavailable,    GateStreamCourierInternal.inconsistentParams,    GateStreamCourierInternal.tooManyGateStreams,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.gapNotExported,    GateStreamCourierInternal.gapCommunicationError,    GateStreamCourierInternal.controllerAlreadyExists,    GateStreamCourierInternal.controllerDoesNotExist,    GateStreamCourierInternal.deviceAddressInUse,    GateStreamCourierInternal.deviceAddressInvalid,    GateStreamCourierInternal.serviceTooBusy,    GateStreamCourierInternal.userNotAuthenticated,    GateStreamCourierInternal.userNotAuthorized,    GateStreamCourierInternal.serviceNotFound,    GateStreamCourierInternal.bugInGAPCode,  -- registeredTwice    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode,    GateStreamCourierInternal.bugInGAPCode];   -- Procedures    -- ExportGAP and UnExportGAP are currently NOPs.  GAP is exported  -- in the start trap for this procedure    ExportGAP: PUBLIC PROCEDURE =    BEGIN END;    UnexportGAP: PUBLIC PROCEDURE =    BEGIN END;    maxTransport: CARDINAL = 3;    NetMgtRegister: PUBLIC ENTRY PROCEDURE [new: GateNetMgt.CallBackProc] RETURNS [    old: GateNetMgt.CallBackProc] =    BEGIN    old ¬ callBack;    callBack ¬ new;    END;    Dispatcher: Courier.Dispatcher =    BEGIN    argument: GateStreamCourierInternal.Argument;    newArgument: GateStreamCourierInternal.CreateArgument;    result: GateStreamCourierInternal.Result;    procedure: GateStreamCourierInternal.Procedure ¬ LOOPHOLE[procedureNumber];    net: Stream.Handle;    oldVersion: BOOLEAN;    closeStarted: BOOLEAN ¬ FALSE;    endAttention: BOOLEAN ¬ FALSE;    sentOldCleanups: BOOLEAN ¬ FALSE;    object: Stream.Object ¬ Stream.defaultObject;    bytes: PACKED ARRAY [0..2) OF Environment.Byte;    bytesBlock: Environment.Block;    cfdStream: CFDStream.Handle;    process: PROCESS;    timeStarted: System.GreenwichMeanTime ¬ System.GetGreenwichMeanTime[];            GetFilter: Stream.GetProcedure =      BEGIN      ENABLE Courier.Error => GOTO suspended;      IF closeStarted THEN        BEGIN	bytesTransferred ¬ 0;	GOTO suspended;	END;      [bytesTransferred, why, sst] ¬ net.get[net, block, options !        Stream.SSTChange => IF sst = NetworkStream.closeSST THEN 	  BEGIN	  bytesTransferred ¬ nextIndex - block.startIndex;	  GOTO suspended;	  END];      IF sst = NetworkStream.closeSST THEN GOTO suspended;      EXITS suspended =>         BEGIN 	closeStarted ¬ TRUE;	IF options.signalEndOfStream THEN 	  SIGNAL Stream.EndOfStream[bytesTransferred + block.startIndex]; 	RETURN [bytesTransferred, endOfStream, GateStream.none];        END;      END;    PutFilter: Stream.PutProcedure =      BEGIN      ENABLE Courier.Error => ERROR ABORTED;      Stream.PutBlock[net, block, endRecord];      END;    SendAttentionFilter: Stream.SendAttentionProcedure =      BEGIN      ENABLE Courier.Error => ERROR ABORTED;      Stream.SendAttention[net, byte];      END;    WaitAttentionFilter: Stream.WaitAttentionProcedure =      BEGIN      byte: Stream.Byte;      IF endAttention THEN ERROR ABORTED;      byte ¬ Stream.WaitForAttention[net !        Courier.Error => {endAttention ¬ TRUE; ERROR ABORTED}];      IF byte = GateStream.cleanup THEN        BEGIN	endAttention ¬ TRUE;	IF oldVersion AND ~sentOldCleanups THEN	  BEGIN	  sentOldCleanups ¬ TRUE;	  SendAttentionFilter[net, GateStream.cleanup];	  SetSSTFilter[net, GateStream.cleanup];	  SetSSTFilter[net, GateStream.none];	  END;	ERROR ABORTED;	END;      RETURN [byte];      END;       SetSSTFilter: Stream.SetSSTProcedure =      BEGIN      ENABLE Courier.Error => ERROR ABORTED;      Stream.SetSST[net, sst];      END;    GetStream: PROCEDURE RETURNS [stream: Stream.Handle] =      BEGIN      -- ENABLE NetworkStream.ConnectionSuspended => CONTINUE;      -- Courier.Error is caught by client calling       net ¬ results[        [@result, GateStreamCourierInternal.ResultDescription[	  procedure, oldVersion]], TRUE];      Stream.SetInputOptions[net, [TRUE, FALSE, FALSE, FALSE, FALSE, FALSE]];      NetworkStream.SetWaitTime[net, NetworkStream.infiniteWaitTime];      SetSSTFilter[net, GateStream.none ! ABORTED => CONTINUE];      RETURN[@object];      END;        PurgeAttention: PROCEDURE =      BEGIN      UNTIL endAttention DO         ENABLE ABORTED, Stream.TimeOut => EXIT;        [] ¬ WaitAttentionFilter[net];        ENDLOOP;      END;        SetTimeoutFilter: Stream.SetTimeoutProcedure =      BEGIN net.setTimeout[net, waitTime] END;          oldVersion ¬ cH.versionNumber = GateStreamCourierInternal.OldVersion;    object.get ¬ GetFilter;    object.put ¬ PutFilter;    object.setSST ¬ SetSSTFilter;    object.sendAttention ¬ SendAttentionFilter;    object.waitAttention ¬ WaitAttentionFilter;    object.setTimeout ¬ SetTimeoutFilter;    arguments[[IF oldVersion THEN @argument ELSE @newArgument,      GateStreamCourierInternal.ArgumentDescription[procedure, oldVersion]]];    BEGIN ENABLE GateStream.Error =>        BEGIN	IF callBack # NIL THEN	  IF oldVersion THEN WITH argument SELECT procedure FROM	    create => callBack[cH.remote, createFailure, timeStarted,              sessionParameters, transportList, waitTime, cH.versionNumber, 	      Auth.nullCredentials, Auth.nullVerifier, reason];	    ENDCASE	  ELSE SELECT procedure FROM	    create => callBack[cH.remote, createFailure, timeStarted, 	      newArgument.sessionParameters, newArgument.transportList, 	      newArgument.waitTime, cH.versionNumber,	      newArgument.credentials, newArgument.verifier, reason];	    ENDCASE	ELSE NULL;        Courier.SignalRemoteError[IF oldVersion THEN OldCourierError[reason]          ELSE CourierError[reason]]; -- Do I need a Courier.Free here? 	END;      IF oldVersion THEN WITH argument SELECT procedure FROM        create =>           BEGIN ENABLE ABORTED, Stream.TimeOut => CONTINUE;          IF LENGTH[transportList] > maxTransport THEN  	   Courier.SignalRemoteError[GateStreamCourierInternal.illegalTransport];	  IF callBack # NIL THEN callBack[cH.remote, create, timeStarted,            sessionParameters, transportList, waitTime, cH.versionNumber, 	    Auth.nullCredentials, Auth.nullVerifier, unimplemented];          cfdStream ¬ GateStreamInternal.DispatcherCreate[cH.remote,             sessionParameters, transportList, waitTime, cH.versionNumber, 	    Auth.nullCredentials, Auth.nullVerifier, 	    GetStream ! Courier.Error => GOTO getStreamError];	 IF callBack # NIL THEN callBack[cH.remote, delete, timeStarted,            sessionParameters, transportList, waitTime, cH.versionNumber, 	    Auth.nullCredentials, Auth.nullVerifier,  unimplemented];	  CFDStream.Delete[cfdStream];	  IF ~endAttention THEN SendAttentionFilter[net, GateStream.mediumDown];	  IF ~sentOldCleanups THEN	    BEGIN	    sentOldCleanups ¬ TRUE;	    SendAttentionFilter[net, GateStream.cleanup];	    SetSSTFilter[net, GateStream.cleanup];	    SetSSTFilter[net, GateStream.none];	    END;	  bytesBlock ¬ [LOOPHOLE[LONG[@bytes]], 0, 1];	  DO ENABLE Stream.TimeOut => EXIT;	    SELECT GetFilter[net, bytesBlock, net.options].why FROM	      endOfStream => EXIT;	      attention => -- If cleanup, flush the cleanup	        BEGIN	        [] ¬ GetFilter[net, bytesBlock, net.options];		IF bytes[0] = GateStream.cleanup THEN PurgeAttention[];		END;	      ENDCASE;	    ENDLOOP;	  END;        reset, delete, iAmStillHere => GOTO exit;  -- now all are NOPs.        ENDCASE => ERROR Courier.NoSuchProcedureNumber      ELSE SELECT procedure FROM        create =>	  BEGIN	  IF LENGTH[newArgument.transportList] > maxTransport THEN 	     Courier.SignalRemoteError[	       GateStreamCourierInternal.illegalTransport];	  IF callBack # NIL THEN callBack[cH.remote, create, timeStarted, 	    newArgument.sessionParameters, newArgument.transportList, 	    newArgument.waitTime, cH.versionNumber,	    newArgument.credentials, newArgument.verifier,	    unimplemented];	  cfdStream ¬ GateStreamInternal.DispatcherCreate[cH.remote, 	    newArgument.sessionParameters, newArgument.transportList, 	    newArgument.waitTime, cH.versionNumber,	    newArgument.credentials, newArgument.verifier,	    GetStream ! Courier.Error => GOTO getStreamError];	 IF callBack # NIL THEN callBack[cH.remote, delete, timeStarted, 	    newArgument.sessionParameters, newArgument.transportList, 	    newArgument.waitTime, cH.versionNumber,	    newArgument.credentials, newArgument.verifier,	    unimplemented];          CFDStream.Delete[cfdStream];	  -- NetworkStream.SetWaitTime[net, closingTimeout];          SendAttentionFilter[net, GateStream.cleanup !	     ABORTED, Stream.TimeOut => CONTINUE];	  process ¬ FORK PurgeAttention[];	  END;	reset, delete => GOTO exit; -- now all are NOPs.        ENDCASE => ERROR Courier.NoSuchProcedureNumber;      IF closeStarted THEN [] ¬ GateStreamCourierInternal.CloseReply[net]                       ELSE [] ¬ GateStreamCourierInternal.Close[net];      IF ~oldVersion THEN JOIN process;      EXITS        exit => [] ¬ results[          [@result, GateStreamCourierInternal.ResultDescription[	    procedure, oldVersion]], FALSE ! Courier.Error => CONTINUE];	getStreamError => NULL;      END;    Courier.Free[[IF oldVersion THEN @argument ELSE @newArgument,      GateStreamCourierInternal.ArgumentDescription[procedure, TRUE]],        Heap.systemZone ! Courier.Error => CONTINUE];    END;-- Export GAP to the worldCourier.ExportRemoteProgram[  programNumber: GateStreamCourierInternal.GAP,  versionRange: [GateStreamCourierInternal.OldVersion,          GateStreamCourierInternal.CurrentVersion],  dispatcher: Dispatcher,  serviceName: "GAP Version 3"L,  zone: Heap.systemZone,  classOfService: transactional];END.LOG                         Rubicon release.12-Jun-81 10:21:07  BRD  Pescadero changes. 5-Aug-81 18:45:04  BRD  Removed RS232CManager.25-Aug-81 11:23:31  BRD  Added callback procedures. 7-Sep-81 15:17:34  BRD  Added network close code.21-Sep-81 15:09:13  BRD  GAP Cleanup code.25-Sep-81 14:35:02  BRD  1) Add UNWIND => NULL to ENTRY procs 2) AttentionByte                          fix 3) Reset timeout back to five minutes after			  quiesce13-Oct-81 16:26:49  BRD  Make DoExport wait until not users in all cases19-Oct-81 18:38:06  BRD  Fix null Poll and Auth procs26-Oct-81 16:13:52  BRD  Handle SSTs correctly12-Nov-81 18:46:49  BRD  Catch Courier.Error when rtn'ing results17-Dec-81 16:40:10  BRD  Trinity conversion11-Jan-82 13:34:14  BRD  1) Conversion to new Courier. 2) Allocate buffer                          from a heap19-Jan-82 12:58:12  BRD  Fix for attention byte removal 2-Mar-82 11:50:54  BRD  Make IAmStillHere not be an ENTRY PROCEDURE 8-Mar-82 15:15:40  BRD  Add new state fastStop to handle shutdown race10-Mar-82 18:45:37  BRD  Free resource entry from serviceQ when                         timeoutInactiveUsers times out a resource26-Mar-82 19:36:56  BRD  Fix heap allocation 1-Apr-82 12:59:25  BRD  New EnumerateLong proc 6-Oct-82 15:52:28  MZA  Added check for normal end in GrabNetworkStream12-Oct-82 20:57:38  MZA  Added QuiesceTransmissionMedium in DestroyResource;                         added ABORTED to CFDStreamGet ENABLE for safety;                         added SetSST[,0] to CFDStreamGet on cleanup to push the			 SetSST[,cleanup] out to fix tty emul hang13-Jun-83 11:34:18  BRD  Re-organization;10-Aug-83 10:58:14  BRD  Catch ConnectionSuspended during Close.  This can be			  removed when Klamath conversion occurs since this			  signal is not supposed to be raised by these procedures.30-Sep-83 17:51:46  BRD  Klamath conversion/Authentication.27-Oct-83 18:55:17  BRD  Delete CFD stream when connection terminates. 5-Mar-84 13:52:41  BRD  Timeout slow closing.20-Mar-84 10:53:53  BRD  Export GAP during start trap.  Cleanup of unused globals.23-Apr-84 10:45:56  BRD  Change CFDStream.Delete to be BEFORE cleanup			  with stub.  This will allow resources to be freed 			  even if the stub client never calls Delete.23-Apr-84 16:07:26  BRD  Change old style close to send cleanup if we			  are closing down.  Add sentOldCleanupsChange CFDStream.Delete to be BEFORE cleanup			  with stub.  This will allow resources to be freed 			  even if the stub client never calls Delete boolean.27-Apr-84 11:38:53  BRD  Fix stream filter to handle Stream.SetTimeout correctly.24-May-84 20:04:58  BRD  Take out timeouts in current version also.12-Jun-84 19:00:17  BRD  Fixed bug if Courier returned error when checking			   out stream. 2-Jul-84 14:03:17  BRD  Net Mgt create/delete hooks14-Feb-85 15:39:23  AOF  NetworkStream.ConnectionSuspended => Courier.Error14-Sep-87 18:29:46  AOF  Xlate all Courier.Errors to ABORTED
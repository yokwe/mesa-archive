-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: GateDispatcher.mesa - last edit:-- Danielson.PA        27-Jun-84 17:13:21DIRECTORY  Auth USING [Credentials, Verifier],  CFDStream USING [defaultInputOptions, Delete,    GetBlock, Handle, Object, PhysicalRecord, PutBlock, SendAttention, SetSST,    WaitForAttention],  Environment USING [Block, Byte],  GateStream USING [CallBackType, CompletionProcedure, CreateProcedure,     cleanup, Error, ErrorReason, none, Resource,     SessionParameterHandle, TransportObject, ValidateProcedure, WaitTime],  GateStreamInternal USING [ProcedureHandle],  GateStubInternal USING [GetStreamProcedure, ProcedureObject, ProcedureHandle,    RegisterDispatcher, TryCourier],  Heap USING [systemZone],  Process USING [Abort, CancelAbort, Detach, GetCurrent],  Stream USING [    Block, Byte, CompletionCode, GetBlock, Handle, Milliseconds, PutBlock,    SendAttention, SetInputOptions, SetSST, SubSequenceType, WaitForAttention],  System USING [NetworkAddress];GateDispatcher: MONITOR  IMPORTS    CFDStream, GateStream, GateStubInternal, Heap, Process, Stream  EXPORTS GateStream, GateStreamInternal =  BEGIN    -- 1. Need catch code in getStream to handle Courier.Errors    ServiceHandle: TYPE = LONG POINTER TO ServiceObject;    ServiceObject: TYPE = RECORD [    next: ServiceHandle,  -- forward pointer to chaining service objects    prev: ServiceHandle,  -- backward pointer for chaining service objects    id: LONG CARDINAL, -- service ID    validate: GateStream.ValidateProcedure,  -- client validate procedure    create: GateStream.CreateProcedure,  -- client create procedure    useCount: CARDINAL,  -- number of clients using service    terminating: BOOLEAN];  -- client has done UnRegister  object: GateStubInternal.ProcedureObject ¬ [    DispatcherCreate, DispatcherReserve,     DispatcherAbortReserve, DispatcherUseMediumForNS,    ConnectTwoStreams];  mgrObject: GateStreamInternal.ProcedureHandle ¬ NIL;  serviceQ: ServiceHandle ¬ NIL;  serviceEvent: CONDITION;  nullStream: CFDStream.Object ¬ [CFDStream.defaultInputOptions,    NIL, NIL, NIL, NIL, NIL, NopDelete];  -- ProceduresRegister: PUBLIC ENTRY PROCEDURE [serviceID: LONG CARDINAL,  validate: GateStream.ValidateProcedure, create: GateStream.CreateProcedure] =  BEGIN ENABLE UNWIND => NULL;  service: ServiceHandle;  top: ServiceHandle ¬ serviceQ;  FOR service ¬ serviceQ, service.next UNTIL service = NIL DO    IF serviceQ.id = serviceID THEN ERROR GateStream.Error[registeredTwice];    ENDLOOP;   serviceQ ¬ Heap.systemZone.NEW[ServiceObject ¬ [top, NIL, serviceID,    validate, create, 0, FALSE]];  IF top # NIL THEN top.prev ¬ serviceQ;  END;UnRegister: PUBLIC ENTRY PROCEDURE [serviceID: LONG CARDINAL] =  BEGIN  service: ServiceHandle ¬ NIL;  FOR service ¬ serviceQ, service.next UNTIL service = NIL DO    IF service.id = serviceID THEN EXIT;    REPEAT      FINISHED => RETURN;  -- Didn't find it, so ignore request    ENDLOOP;  -- If this service is currently in use, then we can't free it now, so wait  -- until user count becomes zero.  Otherwise, free it now  service.terminating ¬ TRUE;  WHILE service.useCount # 0 DO WAIT serviceEvent ENDLOOP;  IF service.prev = NIL THEN serviceQ ¬ service.next  ELSE service.prev.next ¬ service.next;  IF service.next # NIL THEN service.next.prev ¬ service.prev;  Heap.systemZone.FREE[@service];  END;RegisterManager: PUBLIC PROCEDURE [mgr: GateStreamInternal.ProcedureHandle] =  BEGIN  mgrObject ¬ mgr;  END;DispatcherCreate: PUBLIC PROCEDURE [systemElement: System.NetworkAddress,  sessionParameterHandle: GateStream.SessionParameterHandle,  transport: LONG DESCRIPTOR FOR ARRAY OF GateStream.TransportObject,  createTimeout: GateStream.WaitTime,  version: CARDINAL,   credentials: Auth.Credentials,  verifier: Auth.Verifier,  getStream: GateStubInternal.GetStreamProcedure]  RETURNS [cfdStream: CFDStream.Handle] =  BEGIN  service: ServiceHandle ¬ NIL;  sH: Stream.Handle;   busy: BOOLEAN ¬ FALSE;  -- First check through list of registered services  IF  -- Validate parameters    LENGTH[transport] = 2 AND    transport[1].transportType = teletype THEN      UNTIL (service ¬ GetNextService[service]) = NIL DO        IF service.terminating THEN LOOP; -- Skip terminating services	WITH t: transport[0] SELECT  FROM	  rs232c => WITH t.line SELECT FROM	    alreadyReserved => LOOP;	    reserveNeeded => IF LONG[lineNumber] # service.id + 32000 THEN LOOP;	    ENDCASE;	  service => IF t.id # service.id THEN LOOP;	  ENDCASE => LOOP;        service.validate[systemElement, sessionParameterHandle, transport, 	  credentials, verifier];	IF (sH ¬ getStream[]) = NIL THEN 	  -- NIL means the service is talking to a local Gate client.	  -- There is no stream.  We must create two fake streams and link	  -- them together.  If a stream is provided, just pass it to the	  -- service (this is the GAP or talking to Greeter case).	  BEGIN	  [cfdStream, sH] ¬ CreateTwoStreams[];	  -- Oh, oh, a detach...ok for now, since this code never gets called!	  Process.Detach[FORK StartService[service, systemElement,	     sessionParameterHandle, transport, credentials, verifier, sH]];	  END	ELSE 	  BEGIN	  StartService[service, systemElement, sessionParameterHandle,	    transport, credentials, verifier, sH];          cfdStream ¬ @nullStream;	  END;	RETURN;	REPEAT FINISHED => IF transport[0].transportType = service THEN	  ERROR GateStream.Error[serviceNotFound];      ENDLOOP;  -- Not for a registered service, so check other GAP devices.  IF mgrObject # NIL THEN  -- Make sure manager has registered    BEGIN    cfdStream ¬ mgrObject.create[systemElement, sessionParameterHandle,       transport, createTimeout, version, credentials, verifier];    IF (sH ¬ getStream[! UNWIND => CFDStream.Delete[cfdStream]]) = NIL      THEN RETURN[cfdStream]  -- Normal GateStream     ELSE ConnectTwoStreams[cfdStream, sH];    END  ELSE GateStream.Error[unimplemented]  END;NopDelete: PROCEDURE [sH: CFDStream.Handle] =  BEGIN END;DispatcherReserve: PROCEDURE [transport: GateStream.TransportObject,  completionProcedure: GateStream.CompletionProcedure,  callBackType: GateStream.CallBackType,  credentials: Auth.Credentials,  verifier: Auth.Verifier] RETURNS [resource: GateStream.Resource] =  BEGIN  IF mgrObject = NIL THEN GateStream.Error[unimplemented];  resource ¬ mgrObject.reserve[    transport, completionProcedure, callBackType];  END;  DispatcherAbortReserve: PROCEDURE [resource: GateStream.Resource] =  BEGIN  IF mgrObject = NIL THEN GateStream.Error[unimplemented];  mgrObject.abortReserve[resource];  END;  DispatcherUseMediumForNS: PROCEDURE [transport: GateStream.TransportObject] =  BEGIN  IF mgrObject = NIL THEN GateStream.Error[unimplemented];  mgrObject.useMediumForOISCP[transport];   END;GetNextService: ENTRY PROCEDURE [service: ServiceHandle] RETURNS [  next: ServiceHandle] =  BEGIN  next ¬ IF service = NIL THEN serviceQ ELSE service.next;   IF service # NIL AND     (service.useCount ¬ service.useCount - 1) = 0 AND     service.terminating THEN BROADCAST serviceEvent;  IF next # NIL THEN next.useCount ¬ next.useCount + 1;  END;ReleaseService: ENTRY PROCEDURE [service: ServiceHandle] =  BEGIN  IF (service.useCount ¬ service.useCount - 1) = 0 AND service.terminating THEN    BROADCAST serviceEvent;  END;StartService: PROCEDURE [service: ServiceHandle,  systemElement: System.NetworkAddress,  sessionParameters: GateStream.SessionParameterHandle,  transport: LONG DESCRIPTOR FOR ARRAY OF GateStream.TransportObject,  credentials: Auth.Credentials,  verifier: Auth.Verifier,  sH: Stream.Handle] =  BEGIN  service.create[systemElement, sessionParameters, transport,    credentials, verifier, sH];  -- Currently, both network streams and Gateway streams use   -- LAST[Stream.Milliseconds] as the timeout value indicating infinite timeout.  -- Hopefully, in the next release of Pilot, there will be a value indicating  -- infinite timeout that can be used in place of LAST[Stream.Milliseconds]  sH.setTimeout[sH, LAST[Stream.Milliseconds]];  ReleaseService[service];  END;-- Connects a CFDStream and Stream-- Close protocol or one side dying ends things ends thingsConnectTwoStreams: PUBLIC PROCEDURE [cfd: CFDStream.Handle, sH: Stream.Handle] =  BEGIN  byte: Environment.Byte;  cfdGet: PROCESS;  clientGet: PROCESS;  clientWait: PROCESS;  Stream.SetInputOptions[sH,     [TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE]];  cfdGet ¬ FORK CFDGets[cfd, sH];  clientGet ¬ FORK Gets[sH, cfd];  clientWait ¬ FORK Attentions[sH, cfd, Process.GetCurrent[]];  DO    ENABLE ABORTED => EXIT;    byte ¬ CFDStream.WaitForAttention[cfd];    Stream.SendAttention[sH, byte];    ENDLOOP;  Process.Abort[clientGet];  Process.Abort[cfdGet];  Process.Abort[clientWait];  JOIN clientGet;  JOIN cfdGet;  JOIN clientWait;  Process.CancelAbort[Process.GetCurrent[]];  END;-- The following procedures allow a stream and a CFDStream to be connected.-- One set does Get/Puts and the other WaitAttention/SendAttentionsbufferSize: CARDINAL = 128;Bytes: TYPE = RECORD [  PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];  CFDGets: PROCEDURE [cfdStream: CFDStream.Handle, sH: Stream.Handle] =  BEGIN  sst: Stream.SubSequenceType;  why: Stream.CompletionCode;  block: Stream.Block ¬ [LOOPHOLE[Heap.systemZone.NEW[Bytes[bufferSize]]],    0, bufferSize];  record: CFDStream.PhysicalRecord ¬ [[NIL, 0, 0], block, [NIL, 0, 0]];  Stream.SetSST[sH, GateStream.none];  DO ENABLE ABORTED => EXIT;    block.stopIndexPlusOne ¬ bufferSize;    [block.stopIndexPlusOne, why, sst] ¬ CFDStream.GetBlock[      cfdStream, @record];    Stream.PutBlock[sH, block, why=endRecord];    IF why = endOfStream THEN EXIT;    IF why=sstChange THEN Stream.SetSST[sH, sst];    ENDLOOP;  Stream.SetSST[sH, GateStream.none ! ABORTED => CONTINUE];  Heap.systemZone.FREE[@block.blockPointer];  END;    Gets: PROCEDURE [sH: Stream.Handle, cfdStream: CFDStream.Handle] =  BEGIN  sst: Stream.SubSequenceType;  why: Stream.CompletionCode;  block: Stream.Block ¬ [LOOPHOLE[Heap.systemZone.NEW[Bytes[bufferSize]]],     0, bufferSize];  record: CFDStream.PhysicalRecord ¬ [[NIL, 0, 0], block, [NIL, 0, 0]];  CFDStream.SetSST[cfdStream, GateStream.none];  DO ENABLE ABORTED => EXIT;    block.stopIndexPlusOne ¬ bufferSize;    [block.stopIndexPlusOne, why, sst] ¬ Stream.GetBlock[sH, block];    IF why = endOfStream THEN EXIT;    record.body ¬ block;    CFDStream.PutBlock[cfdStream, @record, why=endRecord];    IF why = sstChange THEN CFDStream.SetSST[cfdStream, sst];    ENDLOOP;  CFDStream.SetSST[cfdStream, GateStream.none];  Heap.systemZone.FREE[@block.blockPointer];  END;Attentions: PROCEDURE [sH: Stream.Handle, cfdStream: CFDStream.Handle,  process: PROCESS] =  BEGIN  byte: Stream.Byte ¬ 0B;  UNTIL byte = GateStream.cleanup DO    ENABLE ABORTED => EXIT;    byte ¬ Stream.WaitForAttention[sH];    CFDStream.SendAttention[cfdStream, byte];    ENDLOOP;  Process.Abort[process];  END;CreateTwoStreams: PROCEDURE RETURNS [  cfdStream: CFDStream.Handle, sH: Stream.Handle] =  BEGIN  ERROR GateStubInternal.TryCourier;  -- Not implemented yet!  --ERROR GateStream.Error[unimplemented];--  -- Not implemented yet!  END;-- Main programGateStubInternal.RegisterDispatcher[@object];   END.LOG13-Jun-83 13:37:44 BRD Created file.   6-Oct-83 17:43:46 BRD Klamath conversion.   9-Nov-83 14:27:11 BRD Fix UnRegister to wait until no more active users.  15-Jan-84 14:16:17 BRD Check for endOfStream in CFDGets.  20-Mar-84 11:04:38 BRD Catch ABORTED when GetStream called. (AR 5918) 23-Apr-84 11:19:58 BRD Set stream timeouts to infinite after service return 15-Jun-84 13:43:54 BRD AR 8672 -- put unwinds on GetStream calls27-Jun-84 17:11:56 BRD AR 9209 -- Catch ABORTED signal in CFDGets.                                  
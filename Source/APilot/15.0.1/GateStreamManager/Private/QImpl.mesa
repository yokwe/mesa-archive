-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved.  -- ***************************************************************** -- * QImpl.mesa                                                    * -- * This module is responsible for implementing the queue package * -- *     used by the PolledBSC Driver                              * -- *     used by the GAP Server (GateStreamService)                * -- * The impl uses only long pointers and queues/dequeues          * -- *  either UNSPECIFIED (short) or LONG POINTER (long) data.      * -- * It creates its own Heap for the queues.                       * -- * (last edited by: BRD     on:  6-Oct-83 17:10:12)              * -- *****************************************************************DIRECTORY  QDefs USING [CallBack, CallBackLong,     ExitProc, ExitProcLong, Queue, QueueObject, QElement,    QElementData, QElementObject, QLocation],  Heap USING [Create, Delete, FreeNode, MakeNode, NWords],  Process USING [InitializeMonitor],  Space USING [PageCount];QImpl: MONITOR LOCKS q USING q: QDefs.Queue  IMPORTS Heap, Process  EXPORTS QDefs SHARES QDefs =    BEGIN    -- CONSTANTS    heapPages: Space.PageCount = 2;	-- easily handle 10 Qs(10 elems/Q)  -- heapPages = 2  typical size   myThreshold: Heap.NWords = SIZE[QDefs.QElementObject];    -- WRITEABLE DATA    myHeap: UNCOUNTED ZONE ¬ Heap.Create[    initial: heapPages*2, increment: heapPages,    threshold: myThreshold, swapUnitSize: 1];  elementQ: QDefs.Queue ¬ CreateQueue[];    -- SIGNALS & ERRORS    QBad: PUBLIC ERROR = CODE;    -- PUBLIC Procs    -- ******************************************************************************  -- * CreateQueue will initialize the head, tail, and lenght of the queue.       *  -- ******************************************************************************    CreateQueue: PUBLIC PROCEDURE RETURNS [q: QDefs.Queue] =    BEGIN						-- BEGIN CreateQueue    q ¬ AllocateBlock[SIZE[QDefs.QueueObject]];    Process.InitializeMonitor[@q.LOCK];    q.head ¬ q.tail ¬ NIL;    q.length ¬ 0;    END;						-- END CreateQueue  -- ******************************************************************************  -- * DeleteQueue will remove elements of queue and free element storage.        *  -- ******************************************************************************    DeleteQueue: PUBLIC PROCEDURE [q: QDefs.Queue] =    BEGIN						-- BEGIN DeleteQueue        ClearQueue: ENTRY PROCEDURE [q: QDefs.Queue] =      BEGIN      ENABLE UNWIND => NULL;      outcome: BOOLEAN;      elem: QDefs.QElement;             IF q = NIL THEN ERROR QBad;				-- Be defensive      [outcome, elem] ¬ DequeueElement[q];      WHILE outcome DO              FreeElement[elementQ, elem];        [outcome, elem] ¬ DequeueElement[q];      ENDLOOP;     END;         ClearQueue[q];					-- empty the queue    FreeBlock[q];					-- Free queue    END;						-- END DeleteQueue  -- ******************************************************************************  -- * Dequeue will remove short element from head of Q.                          *  -- ******************************************************************************    Dequeue: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue]    RETURNS [outcome: BOOLEAN, elemData: UNSPECIFIED] =    BEGIN						-- BEGIN Dequeue    ENABLE UNWIND => NULL;    elem: QDefs.QElement;        [outcome, elem] ¬ DequeueElement[q];    IF outcome THEN       BEGIN						-- copy element elemData      WITH e: elem.data SELECT FROM        short => elemData ¬ e.elemData;        long =>  {FreeElement[elementQ, elem]; ERROR QBad};        ENDCASE;      FreeElement[elementQ, elem];      END    ELSE elemData ¬ 0;    END;						-- END Dequeue    -- ******************************************************************************  -- * DequeueLong will remove long element from head of Q.                       *  -- ******************************************************************************    DequeueLong: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue]    RETURNS [outcome: BOOLEAN, elemData: LONG POINTER] =    BEGIN						-- BEGIN DequeueLong    ENABLE UNWIND => NULL;    elem: QDefs.QElement;        [outcome, elem] ¬ DequeueElement[q];    IF outcome THEN       BEGIN						-- copy element elemData      WITH e: elem.data SELECT FROM        long => elemData ¬ e.elemData;        short => {FreeElement[elementQ, elem]; ERROR QBad};        ENDCASE;      FreeElement[elementQ, elem];      END    ELSE elemData ¬ NIL;    END;						-- END DequeueLong         -- ******************************************************************************  -- * Enqueue will add short element to location of Q.                           *  -- ******************************************************************************    Enqueue: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue, elemData: UNSPECIFIED,    location: QDefs.QLocation] =    BEGIN						-- BEGIN Enqueue    ENABLE UNWIND => NULL;    IF q = NIL THEN ERROR QBad;				-- Be defensive    EnqueueInternal[q, elemData, location];    END;						-- END Enqueue    -- ******************************************************************************  -- * EnqueueLong will add long element to location of Q.                        *  -- ******************************************************************************    EnqueueLong: PUBLIC ENTRY PROCEDURE [    q: QDefs.Queue, elemData: LONG POINTER, location: QDefs.QLocation] =    BEGIN						-- BEGIN EnqueueLong    ENABLE UNWIND => NULL;    IF q = NIL THEN ERROR QBad;				-- Be defensive    EnqueueLongInternal[q, elemData, location];		-- allocate & fill element    END;						-- END EnqueueLong    -- ******************************************************************************  -- * ExtractQueue will extract short element according to elemData.             *  -- ******************************************************************************    ExtractQueue: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue, elemData: UNSPECIFIED]    RETURNS [BOOLEAN] =    BEGIN						-- BEGIN ExtractQueue    ENABLE UNWIND => NULL;    data: QDefs.QElementData ¬ [short[elemData]];        RETURN[ExtractElement[q, data]];    END;						-- END ExtractQueue    -- ******************************************************************************  -- * ExtractQueueLong will extract long element according to elemData.          *  -- ******************************************************************************    ExtractQueueLong: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue, elemData: LONG POINTER]    RETURNS [BOOLEAN] =    BEGIN						-- BEGIN ExtractQueueLong    ENABLE UNWIND => NULL;    data: QDefs.QElementData ¬ [long[elemData]];        RETURN[ExtractElement[q, data]];    END;						-- END ExtractQueueLong     -- ******************************************************************************  -- * Finalize returns heap pages.                                               *  -- ******************************************************************************    Finalize: PUBLIC PROCEDURE =    BEGIN						-- BEGIN Finalize    EraseHeap[];    END;						-- END Finalize    -- ******************************************************************************  -- * GetNext will remove short element from head of q and requeue it at the     *  -- * tail of Q.                                                                 *  -- ******************************************************************************    GetNext: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue]    RETURNS [outcome: BOOLEAN, elemData: UNSPECIFIED] =    BEGIN						-- BEGIN GetNext    ENABLE UNWIND => NULL;    elem: QDefs.QElement;        [outcome, elem] ¬ DequeueElement[q];    IF outcome THEN       BEGIN						-- copy element elemData      WITH e: elem.data SELECT FROM        short => elemData ¬ e.elemData;        long =>  {FreeElement[elementQ, elem]; ERROR QBad};        ENDCASE;      EnqueueElement[q, elem, tail];      END;    END;						-- END GetNext  -- ******************************************************************************  -- * GetNextLong will remove element from head of q and requeue at tail of Q.   *  -- ******************************************************************************    GetNextLong: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue]    RETURNS [outcome: BOOLEAN, elemData: LONG POINTER] =    BEGIN						-- BEGIN GetNextLong    ENABLE UNWIND => NULL;    elem: QDefs.QElement;        [outcome, elem] ¬ DequeueElement[q];    IF outcome THEN       BEGIN						-- copy element elemData      WITH e: elem.data SELECT FROM        long => elemData ¬ e.elemData;        short => {FreeElement[elementQ, elem]; ERROR QBad};        ENDCASE;      EnqueueElement[q, elem, tail];      END;    END;						-- END GetNextLong    -- ******************************************************************************  -- * Enumerate will enumerate the elements of the Q and perform operation in    *  -- * the call back procedure specified by the caller.                           *  -- ******************************************************************************    Enumerate: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue,    proc: QDefs.CallBack, exit: QDefs.ExitProc] =    BEGIN						-- BEGIN Enumerate    ENABLE UNWIND => NULL;    elem: QDefs.QElement;    elemData: UNSPECIFIED;    continue, free, addNewEntry: BOOLEAN;    elements: CARDINAL ¬ q.length;        continue ¬ TRUE;    THROUGH [0..elements) DO      [, elem] ¬ DequeueElement[q];      WITH e: elem.data SELECT FROM        short => [continue, free] ¬ proc[e.elemData];  -- call client	ENDCASE => {FreeElement[elementQ, elem]; ERROR QBad};      IF free        THEN FreeElement[elementQ, elem]	ELSE EnqueueElement[q, elem, tail];      IF ~continue THEN EXIT;      ENDLOOP;    IF exit # NIL THEN      BEGIN      [addNewEntry, elemData] ¬ exit[continue];      IF addNewEntry THEN EnqueueInternal[q, elemData, tail];      END;    END;						-- END Enumerate   -- ******************************************************************************  -- * EnumerateLong will enumerate the elements of the Q and perform operation   *  -- * in the call back procedure specified by the caller.                        *  -- ******************************************************************************    EnumerateLong: PUBLIC ENTRY PROCEDURE [q: QDefs.Queue,    proc: QDefs.CallBackLong, exit: QDefs.ExitProcLong] =    BEGIN						-- BEGIN EnumerateLong    ENABLE UNWIND => NULL;    elem: QDefs.QElement;    elemData: LONG POINTER;    continue, free, addNewEntry: BOOLEAN;    elements: CARDINAL ¬ q.length;        continue ¬ TRUE;    THROUGH [0..elements) DO      [, elem] ¬ DequeueElement[q];      WITH e: elem.data SELECT FROM        long => [continue, free] ¬ proc[e.elemData];  -- call client	ENDCASE => {FreeElement[elementQ, elem]; ERROR QBad};      IF free        THEN FreeElement[elementQ, elem]	ELSE EnqueueElement[q, elem, tail];      IF ~continue THEN EXIT;      ENDLOOP;    IF exit # NIL THEN      BEGIN      [addNewEntry, elemData] ¬ exit[continue];      IF addNewEntry THEN EnqueueLongInternal[q, elemData, tail];      END;    END;						-- END EnumerateLong -- PRIVATE & STORAGE MGT Procs  -- ******************************************************************************  -- * AllocateBlock will allocate from our heap.                                 *  -- ******************************************************************************    AllocateBlock: PROCEDURE [nwords: Heap.NWords] RETURNS [ptr: LONG POINTER] =    INLINE    BEGIN						-- BEGIN AllocateBlock    ptr ¬ Heap.MakeNode[myHeap, nwords];    END;						-- END AllocateBlock    -- ******************************************************************************  -- * AllocateElement will allocate queue element.                               *  -- ******************************************************************************    AllocateElement: ENTRY PROCEDURE [q: QDefs.Queue] RETURNS [elem:QDefs.QElement] =    BEGIN						-- BEGIN AllocateElement    ENABLE UNWIND => NULL;    outcome: BOOLEAN;        [outcome, elem] ¬ DequeueElement[q];    IF outcome THEN RETURN;    THROUGH [0..20) DO      elem ¬ AllocateBlock[SIZE[QDefs.QElementObject]];      elem­ ¬ QDefs.QElementObject[queue: q, nextQElem: NIL, data: [long[NIL]]];      EnqueueElement[q, elem, head];      ENDLOOP;    [,elem] ¬ DequeueElement[q];    END;						-- END AllocateElement  -- ******************************************************************************  -- * CompareQData will compare queue element data.                              *  -- ******************************************************************************    CompareQData: PROCEDURE [data1, data2: QDefs.QElementData] RETURNS [BOOLEAN] =    BEGIN						-- BEGIN CompareQData    WITH d1: data1 SELECT FROM      short => WITH d2: data2 SELECT FROM        short => RETURN [d1.elemData = d2.elemData];	ENDCASE;      long => WITH d2: data2 SELECT FROM        long => RETURN [d1.elemData = d2.elemData];	ENDCASE;      ENDCASE;    RETURN[FALSE];    END;						-- END CompareQData    -- ******************************************************************************  -- * DequeueElement will remove queue element from queue.                       *  -- ******************************************************************************    DequeueElement: INTERNAL PROCEDURE [q: QDefs.Queue]    RETURNS [outcome: BOOLEAN, elem: QDefs.QElement] =    BEGIN						-- BEGIN DequeueElement    IF q = NIL THEN ERROR QBad;				-- Be defensive    outcome ¬ TRUE;    IF (elem ¬ q.head) = NIL THEN RETURN[FALSE, NIL];	-- check for empty queue    IF (q.head ¬ q.head.nextQElem) = NIL		-- fix head(& tail if lost      THEN q.tail ¬ NIL;				-- last element     q.length ¬ q.length - 1;    IF elem.queue # q THEN ERROR QBad;			-- Be defensive    elem.nextQElem ¬ NIL;    END;						-- END DequeueElement    -- ******************************************************************************  -- * EnqueueElement will add queue element to queue.                            *  -- ******************************************************************************    EnqueueElement: INTERNAL PROCEDURE [q: QDefs.Queue, elem: QDefs.QElement,    location: QDefs.QLocation] =    BEGIN						-- BEGIN EnqueueElement    SELECT location FROM      head =>						-- add to head of queue	BEGIN	IF q.head = NIL	  THEN q.tail ¬ elem	  ELSE elem.nextQElem ¬ q.head;	q.head ¬ elem;	END;      ENDCASE =>	BEGIN						-- add to tail of queue	IF q.head = NIL	THEN q.head ¬ elem	ELSE q.tail.nextQElem ¬ elem;	q.tail ¬ elem;	END;    q.length ¬ q.length + 1;    END;						-- END EnqueueElement    -- ******************************************************************************  -- * EnqueueInternal will add short element to location of Q.                   *  -- ******************************************************************************    EnqueueInternal: INTERNAL PROCEDURE [q: QDefs.Queue, elemData: UNSPECIFIED,    location: QDefs.QLocation] =    BEGIN						-- BEGIN EnqueueInternal    elem: QDefs.QElement;        elem ¬ AllocateElement[elementQ];			-- alloc & fill element    elem­ ¬ QDefs.QElementObject[queue: q, nextQElem: NIL,      data: [short[elemData]]];    EnqueueElement[q, elem, location];    END;						-- END EnqueueInternal    -- ******************************************************************************  -- * EnqueueLongInternal will add long element to location of Q.                *  -- ******************************************************************************    EnqueueLongInternal: INTERNAL PROCEDURE [q: QDefs.Queue, elemData: LONG POINTER,    location: QDefs.QLocation] =    BEGIN					     -- BEGIN EnqueueLongInternal    elem: QDefs.QElement;        elem ¬ AllocateElement[elementQ];			-- alloc & fill element    elem­ ¬ QDefs.QElementObject[queue: q, nextQElem: NIL,      data: [long[elemData]]];    EnqueueElement[q, elem, location];    END;						-- END EnqueueLongInternal          -- ******************************************************************************  -- * EraseHeap will destroy heap, free associated pages.                        *  -- ******************************************************************************    EraseHeap: PROCEDURE = INLINE    BEGIN						-- BEGIN EraseHeap    Heap.Delete[myHeap];    END;						-- END EraseHeap    -- ******************************************************************************  -- *ExtractElement will extract queue element according to data and free element*  -- ******************************************************************************    ExtractElement: INTERNAL PROCEDURE [q: QDefs.Queue,elemData: QDefs.QElementData]    RETURNS [outcome: BOOLEAN] =    BEGIN						-- BEGIN ExtractElement    nextElem: QDefs.QElement;    prevElem: QDefs.QElement ¬ NIL;        IF q = NIL THEN ERROR QBad;				-- Be defensive    IF (nextElem ¬ q.head) = NIL THEN RETURN[FALSE];	-- check for empty queue    UNTIL nextElem = NIL DO				-- search from head to tail      IF CompareQData[nextElem.data, elemData] THEN	BEGIN	IF nextElem = q.head	  THEN q.head ¬ nextElem.nextQElem	  ELSE prevElem.nextQElem ¬ nextElem.nextQElem;	IF nextElem = q.tail THEN q.tail ¬ prevElem;	q.length ¬ q.length - 1;	FreeElement[elementQ, nextElem];	RETURN[TRUE];	END;      prevElem ¬ nextElem;      nextElem ¬ nextElem.nextQElem;      ENDLOOP;    RETURN[FALSE];    END;						-- END ExtractElement  -- ******************************************************************************  -- * FreeBlock will free in our heap.                                           *  -- ******************************************************************************    FreeBlock: PROCEDURE [ptr: LONG POINTER] = INLINE    BEGIN						-- BEGIN FreeBlock    Heap.FreeNode[myHeap, ptr];    END;						-- END FreeBlock  -- ******************************************************************************  -- * FreeElement will free an element from the Q.                               *  -- ******************************************************************************    FreeElement: ENTRY PROCEDURE [q: QDefs.Queue, elem: QDefs.QElement] =    BEGIN						-- BEGIN FreeElement    ENABLE UNWIND => NULL;    elem­ ¬ QDefs.QElementObject[queue: q, nextQElem: NIL, data: [long[NIL]]];    EnqueueElement[q, elem, head];    END;						-- END FreeElement  -- MAIN PROGRAM --  FreeElement[elementQ, AllocateElement[elementQ]];  -- create some queue elements  END.LOG23-Aug-81 13:20:16  BRD  Make pointers long, so we don't use MDS	20-Sep-81 18:50:44  BRD  Put GateStream.Error here since I can't put it                           in logical places and still bind	16-Oct-81 11:53:49  BRD	 Add GetNext and GetNextLong 9-Nov-81 19:18:36  BRD	 Don't allocate/free nodes so often17-Dec-81 19:11:41  BRD	 Added ennumerates 1-Apr-82 13:18:27  BRD  Added exit procs to enumerates 6-Oct-82 17:14:14  MMC  Made Qs to be allocated from VM instead of 			 system zone, documented code a bit26-Oct-82 14:11:32  MAT  Changed DeleteQueue to handle both types of elemData 8-Dec-82 11:28:40  DDM  AR 10471: Allocate 3*heapPages for Space to compensate for GAP Server not deleting queue of ServiceHandle; tile Heap in units of 1 page.12-Jan-83 14:59:03  DDM  Increase initial and increment sizes for Heap creation as per request of Star/Stub Performance group.29-Mar-83 17:33:46  BRD  Sierra conversion. 6-Oct-83 17:10:21  BRD  Klamath conversion.
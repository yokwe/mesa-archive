-- Copyright (C) Xerox Corporation 1985, 1986, 1987, 1988. All rights reserved.---- File: DiskUtilityMiscDove.mesa	-Last edited:-- STC, 21-Sep-88 10:23:55, Labelless---- This interface module provides access to DiskUtilityMiscImplDove, which-- holds miscellaneous procedures that do not fit into OfflineDiskUtilitiesDove.--DIRECTORY  CompatibilityDiskFace USING [Command, Label, Operation],  DiskChannel 		USING [DirectOperation, DriveState, IOStatus],  Environment 		USING [Base],--  PilotDiskFace 	USING [DiskAddress, DeviceHandle, Label, Status, Command],  PilotDiskFace 	USING [DiskAddress, DeviceHandle, Status],  SpecialVolume 	USING [SubVolume],  PhysicalVolume 	USING [PageNumber, Handle, ID, PageCount],  OfflineDiagInterface  USING [FixedPositionDisplayRecord,  			       OfflineDiagnosticProc];DiskUtilityMiscDove: DEFINITIONS =BEGIN--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Data structure and public variables--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  RamBadPageTable: TYPE = RECORD [  -- Bad page table in RAM     badPageCount: CARDINAL, -- Bad pages in this instance of RamBadPageTable     badPages: SEQUENCE tableSize: CARDINAL OF PhysicalVolume.PageNumber];  ASubVolume: TYPE = RECORD [ -- Holds the informtion for a subvolume  		     svInfo: SpecialVolume.SubVolume, svName: LONG STRING];  -- Holds all the ASubVolumes for this disk  SubVolumeTable: TYPE = RECORD [ -- Holds pointers to all the ASubVolumes  	 validSVCount: CARDINAL,    	 sv: SEQUENCE maxSubVolumes: CARDINAL OF ASubVolume];  subVolumeTable: LONG POINTER TO SubVolumeTable;  volumeInfoValid: BOOLEAN;  -- TRUE => Valid information in subVolumeTable    leftEdge: CARDINAL = 3;    -- Drive access/ID info  driveIndex: CARDINAL;  -- Index associated with a drive.  pvHandle: PhysicalVolume.Handle;  -- Handle for accessing the drive  pvID: PhysicalVolume.ID; -- System.UniversalID  deviceHandle: PilotDiskFace.DeviceHandle; -- Handle to the drive    -- Drive attributes  cylinders: CARDINAL;  -- Number of cylinders on the disk  movingHeads: CARDINAL;  -- Number of moving heads the disk has  fixedHeads: CARDINAL;  -- Number of fixed heads the disk has  sectorsPerTrack: CARDINAL;  -- The number of sectors on a track    -- firstPilotPage is first page where Pilot volumes may begin. Number of pages  -- available to hold Pilot volumes is (totalPagesOnADisk - firstPilotPage)  firstPilotPage: PhysicalVolume.PageNumber;  totalPagesOnADisk: PhysicalVolume.PageCount; -- Total pages on the disk  pagesPerTrack: CARDINAL;  -- The number of pages on a track.  pagesPerCylinder: CARDINAL;  -- The number of pages per cylinder.  firstAllowableBP: CARDINAL;  -- The first page of cylinder 1    subVolumeInfoAvailable: BOOLEAN; -- TRUE => Info in subVolumeTable are valid    -- Points to disk operation block  op: READONLY LONG POINTER TO DiskChannel.DirectOperation;  labeledOp: READONLY LONG POINTER TO CompatibilityDiskFace.Operation;    -- Items related to pages saved on a track  labelSpaceSize: CARDINAL;  -- Pages for holding the labels on a track  pointerToLabelSpace: LONG POINTER;  -- Point to labels from a track  pointerToDataSpace: LONG POINTER;  -- Point to data from a track  -- Data pages transfered from a sector  DataPages: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF LONG POINTER];  dataPages: LONG POINTER TO DataPages;  -- SEQUENCE of pointers to disk page labels  Labels: TYPE = RECORD [  	  SEQUENCE COMPUTED CARDINAL OF LONG POINTER TO CompatibilityDiskFace.Label];  labels: LONG POINTER TO Labels;  -- For holding results of save or restore operations  SaveOpStatus: TYPE = RECORD [    		SEQUENCE COMPUTED CARDINAL OF PilotDiskFace.Status];  saveOpStatus: LONG POINTER TO SaveOpStatus;  restoreOpStatus: LONG POINTER TO SaveOpStatus;  -- Flags in order to share procedures  RigidDiskDiag: BOOLEAN;    InitStarted: BOOLEAN;    virginDisk: BOOLEAN;    currentBPTOnDisk: LONG POINTER TO RamBadPageTable;    preFormatBPT: LONG POINTER TO RamBadPageTable;    --******************************************************************************--  Allocate space for a BPT and initialize it to all 1's--******************************************************************************GetABlankBadPageTable: PROC [tableSize: CARDINAL] 		       RETURNS [aNewBPT: LONG POINTER TO RamBadPageTable];--******************************************************************************-- Get the subvolume information from the drive--******************************************************************************GetSubVolumeInfo: PROCEDURE [table: LONG POINTER TO SubVolumeTable] 		    RETURNS [tableValid: BOOLEAN ¬ FALSE];		  --******************************************************************************-- More to go or quit? Yes returns, no raises AbortCurrentTest--******************************************************************************NoQuitsYesReturns: PROC [prompt: LONG STRING, default: BOOLEAN];--******************************************************************************-- Pauses for an input. Once an input has been received, raise AbortCurrentTest--******************************************************************************PauseAndQuit: PROCEDURE;--******************************************************************************-- Allocates space for a disk operation and returns a  pointer to the space. --******************************************************************************PrepareForDirectOperation: PROCEDURE RETURNS [              -- pOp will be aligned per requirements of DiskChannel.DoDirectIO              pOp: LONG POINTER TO DiskChannel.DirectOperation,              -- pStorage should be used when freeing              pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED];	      	      --******************************************************************************-- Converts a physical disk address to a Pilot page number (LONG CARDINAL)--******************************************************************************ConvertDiskAddressToPage: PROCEDURE [diskAddress: PilotDiskFace.DiskAddress]			  RETURNS [page: LONG CARDINAL];--******************************************************************************-- Converts a Pilot page to its physical address--******************************************************************************ConvertPageToDiskAddress: PROCEDURE [page: LONG CARDINAL]                          RETURNS [diskAddress: PilotDiskFace.DiskAddress];			  			  --******************************************************************************-- Heading for page information.--******************************************************************************PrintExpandedPageHeading: PROC[appendSaveStatus, appendRestoreStatus,			       appendErrorStatus: BOOLEAN];    -- Positions for printing status information    saveStatusPosition: READONLY CARDINAL; -- Status of save operation    restoreStatusPosition: READONLY CARDINAL;  -- Status of restore operation--******************************************************************************-- Expand a page number and display it in the Data Area. The error status of a-- a page can also be btained by setting "getStatus: TRUE". This will invoke-- the page scavenger to scavenge the page to obtain its status for display. --******************************************************************************ExpandPageNumber: PROCEDURE [pageToBeExpanded: PhysicalVolume.PageNumber,			     getStatus: BOOLEAN ¬ FALSE]; -- TRUE scavenges page--******************************************************************************-- Allocate and initializes fixed display records--******************************************************************************GetADisplayRecord: PROCEDURE [numberOfRows, itemsOnARow: CARDINAL]       RETURNS [LONG POINTER TO OfflineDiagInterface.FixedPositionDisplayRecord];--******************************************************************************-- Print bad page table contents in the Data Area --******************************************************************************DisplayBPTable: PROCEDURE [bpt: LONG POINTER TO RamBadPageTable];--******************************************************************************-- Print bad page table contents on a local printer --******************************************************************************TTYPrintBadPageTable: PROCEDURE [bpt: LONG POINTER TO RamBadPageTable];--******************************************************************************-- Display the bad page table on the drive--******************************************************************************ReadCurrentBPTFromDisk: PROCEDURE [bpt: LONG POINTER TO RamBadPageTable]			RETURNS [LONG POINTER TO RamBadPageTable];--******************************************************************************-- Add a bad page into the bad page table on the disk--******************************************************************************AddABadPage: PROCEDURE [pageToBeAdded: PhysicalVolume.PageNumber];-- Add a damaged page into the damaged page table on the disk--******************************************************************************AddADamagedPage: PROCEDURE [pageToBeAdded: PhysicalVolume.PageNumber];--******************************************************************************--******************************************************************************-- See if a page is in the bad page table--******************************************************************************InBadPageTable: PROCEDURE [page: PhysicalVolume.PageNumber,	                   table: LONG POINTER TO RamBadPageTable]		RETURNS   [foundInTable: BOOLEAN];--******************************************************************************-- Resets a table to all ones--******************************************************************************ResetBadPageTable: PROCEDURE [bpt: LONG POINTER TO RamBadPageTable];--******************************************************************************-- Make sure cylinder 0 is ok. Cylinder 0 can not have bad pages--******************************************************************************CheckCylinderZero: PROCEDURE;--******************************************************************************-- Take volume offline--******************************************************************************ForceDriveOffline: PROCEDURE [handle: PhysicalVolume.Handle];--******************************************************************************-- Sets up the drive to be in one of the following states:----	inactive => Drive can only be read--	direct => For Direct I/O (Same effect as AssertNotAPilotVolume)--	channel => For  Channel I/O (Same effect as AssertPilotVolume)----******************************************************************************SetDriveStateTo: PROCEDURE [newState: DiskChannel.DriveState];--******************************************************************************-- Attempt to repair a bad page--******************************************************************************RepairABadPage: PROCEDURE [pageToBeRepaired: PhysicalVolume.PageNumber];--******************************************************************************-- Save all the labels and data pages of a track--******************************************************************************SaveATrack: PROCEDURE [page: PhysicalVolume.PageNumber,		       displayStatus: BOOLEAN ¬ TRUE];<<--******************************************************************************-- Restore labels and data pages read off a track--******************************************************************************RestoreATrack: PROCEDURE [page: PhysicalVolume.PageNumber];>>--******************************************************************************-- Does a direct I/O to the disk on the specified page--******************************************************************************DoAPageOp: PROCEDURE [page: PhysicalVolume.PageNumber,		      operation: CompatibilityDiskFace.Command]	     RETURNS [DiskChannel.IOStatus];	     InitOpPtrs: PROCEDURE;--******************************************************************************-- Prints the status of a direct operation--******************************************************************************PrintStatus: PROCEDURE [opStatus: PilotDiskFace.Status, position: CARDINAL,			newLine: BOOLEAN ¬ FALSE];--******************************************************************************-- Scans a given page to see how reliable it is. Give hardFailureCount and-- softErrorCount--******************************************************************************TestABadPage: PROCEDURE  [pageToBeTested: PhysicalVolume.PageNumber];--******************************************************************************-- Add RAM bad page table to disk--******************************************************************************AddBadPageTable: PROCEDURE [bpt: LONG POINTER TO RamBadPageTable,		 	    getConfirmation: BOOLEAN];--******************************************************************************-- Test a RAM bad page table. Actions: testPage, repairPage, markPageBad--******************************************************************************TestPagesInBadPageTable: PROC [bpt: LONG POINTER TO RamBadPageTable];--******************************************************************************-- Print bad page table to a printer--******************************************************************************PrintBadPageTable: OfflineDiagInterface.OfflineDiagnosticProc;--******************************************************************************-- Enter Bad Pages into BPT, by page number or Error Map--******************************************************************************EnterBadPagesIntoBadPageTable: OfflineDiagInterface.OfflineDiagnosticProc;EnterNewDiskErrorMap: OfflineDiagInterface.OfflineDiagnosticProc;--******************************************************************************-- Print bad page table to a printer--******************************************************************************HeadRetraction: OfflineDiagInterface.OfflineDiagnosticProc;--******************************************************************************GoFormatDisk: PROCEDURE;StartInit: PROCEDURE;ValidateIDandCheckVirginity: PROCEDURE;DisplayBadPageTable: OfflineDiagInterface.OfflineDiagnosticProc;CollectNewBadPage: PROCEDURE	[bpCollector: LONG POINTER TO RamBadPageTable,	 oldBPTable: LONG POINTER TO RamBadPageTable,	 badPageCount: CARDINAL, newBadPage: PhysicalVolume.PageNumber]	 	RETURNS [CARDINAL];CheckPVPages: PROCEDURE  RETURNS [BOOLEAN];ManufDskCkOut: BOOLEAN;TryCount: CARDINAL;END.  -- DiskUtilityMiscDove.mesaLOG:26-Jul-85  7:59:46 by KL, Creation17-Sep-86 12:22:30 by SPL, added entry for InitOpPtrs27-Feb-87  8:56:36 by STC, added PrintBadPageTable, EnterNewDiskErrorMap, GoFormatDisk 5-Mar-87 14:12:35 by STC, added RigidDiskDiag and InitStarted17-Mar-87 20:16:06 by STC, added preFormatBPT, virginDisk, StartInit24-Mar-87 20:38:53 by STC, added ManufDskCkOut28-Mar-87 15:43:31 by STC, added EnterBadPagesIntoBadPageTable12-May-87 11:14:41 by STC, added ValidateIDandCheckVirginity, DisplayBadPageTable12-May-87 11:14:41 by STC, added currentBPTOnDisk, preFormatBPT15-May-87  6:43:58 by STC, added CollectNewBadPage22-May-87  9:59:56 by STC, added CheckPVPages 6-Jul-87 17:23:35 by STC, added HeadRetraction 1-Sep-87 14:15:54, STC, added TryCount21-Sep-88 10:22:06, STC, merge SPL's Labelless, 29-Oct-86 11:54:21
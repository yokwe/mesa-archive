-- File SysConfigKeyboardImpl.mesa-- Last edited:	 5-Jan-87 10:58:42	RDM	Add badMemConfig message.--  9-Dec-86  9:42:48	RDM Add EEprom error messages.-- 10-Sep-85 13:32:36	by: AMR-- Edited:	31-Jul-85 15:36:46	by: AMR-- Created	18-Jun-85 14:45:24	by: AMR<<	Copyright (C) 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig ],  Inline	        USING [ LowHalf, LowByte ],  OfflineDiagInterface  USING [ AbortCurrentTest, AnOptionLine, ARow,				DisplayFixedPositionData,			        FixedPositionDisplayRecord, 				GetAnOptionsRecord,				GetAnOptionLine, GetAnOption,				GetAFixedPositionDisplayRecord, GetARow,			        GetANumber, GetYesNo,				OfflineDiagnosticProc, OptionsRecord, 				PutMessage],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, statusPtr],  SysConfigChannelDefs  USING [ eePromImage];    SysConfigKeyboardImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureKeyboard:--******************************************************************************ConfigureKeyboard: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    -- VMM    KeyboardTypes: TYPE = {none, english, european, japanese, learSiegler, newKeyboardType};    numberKeyboardTypes: CARDINAL = ORD[LAST[KeyboardTypes]] + 1;  keyboardOptionTable: LONG POINTER TO Odi.OptionsRecord _      Odi.GetAnOptionsRecord [2];  -- Just one row of option here  keyboardOptionRow0: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [4];  keyboardOptionRow1: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [numberKeyboardTypes - 4 + 1 ]; -- Extra option is for EXIT    keyboardInformation: LONG POINTER TO Odi.FixedPositionDisplayRecord _      Odi.GetAFixedPositionDisplayRecord [2];    keyboardInfoRow0: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  keyboardInfoRow1: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];      leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 3;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  keyboardSelected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN _ TRUE;  currentSettingPosition: CARDINAL = 40;    keyboardInformation.displayTitle _ msgKey[keyboardSetting];  keyboardInformation.rows[0] _ keyboardInfoRow0;  keyboardInformation.rows[1] _ keyboardInfoRow1;    -- Now fill in the static fields of the display record  keyboardInfoRow0.rowItems[0].namePosition _ leftEdge;  keyboardInfoRow0.rowItems[0].name _ msgKey[currentKeyboard];  keyboardInfoRow0.rowItems[0].valuePosition _ noNumericData;    keyboardInfoRow1.rowItems[0].namePosition _ leftEdge;  keyboardInfoRow1.rowItems[0].name _ msgKey[newKeyboardSetting];  keyboardInfoRow1.rowItems[0].stringValue _ NIL;  keyboardInfoRow1.rowItems[0].value _ 0;     -- Now construct the keyboard option table  --  keyboardOptionTable.linesOfOptions[0] _ keyboardOptionRow0; -- Save pointer to row  keyboardOptionTable.linesOfOptions[1] _ keyboardOptionRow1; -- Save pointer to row  keyboardOptionTable.optionMenuTiTle _ msgKey[keyboardChoices];    keyboardOptionRow0.optionsOnALine[0].position _ leftEdge;  keyboardOptionRow0.optionsOnALine[0].selectionNumberForThisItem _ 1;  keyboardOptionRow0.optionsOnALine[0].option _ msgKey[noKeyboard];  -- %Change    xPosition _ leftEdge + msgKey[learSieglerKeyboard].length + 8;  keyboardOptionRow0.optionsOnALine[1].position _ xPosition;  keyboardOptionRow0.optionsOnALine[1].selectionNumberForThisItem _ 2;  keyboardOptionRow0.optionsOnALine[1].option _ msgKey[englishKeyboard];  -- %Change    xPosition _ xPosition + msgKey[newKeyboardType].length + 8;  keyboardOptionRow0.optionsOnALine[2].position _ xPosition;  keyboardOptionRow0.optionsOnALine[2].selectionNumberForThisItem _ 3;  keyboardOptionRow0.optionsOnALine[2].option _ msgKey[europeanKeyboard];  -- %Change    xPosition _ xPosition + msgKey[europeanKeyboard].length + 16;  keyboardOptionRow0.optionsOnALine[3].position _ xPosition;  keyboardOptionRow0.optionsOnALine[3].selectionNumberForThisItem _ 4;  keyboardOptionRow0.optionsOnALine[3].option _ msgKey[japaneseKeyboard];  -- %Change    keyboardOptionRow1.optionsOnALine[0].position _ leftEdge;  keyboardOptionRow1.optionsOnALine[0].selectionNumberForThisItem _ 5;  keyboardOptionRow1.optionsOnALine[0].option _ msgKey[learSieglerKeyboard];  -- %Change    xPosition _ leftEdge + msgKey[learSieglerKeyboard].length + 8;  keyboardOptionRow1.optionsOnALine[1].position _ xPosition;  keyboardOptionRow1.optionsOnALine[1].selectionNumberForThisItem _ 6;  keyboardOptionRow1.optionsOnALine[1].option _ msgKey[newKeyboardType];  -- %Change    xPosition _ xPosition + msgKey[newKeyboardType].length + 8;  -- %Change  keyboardOptionRow1.optionsOnALine[2].position _ xPosition;  keyboardOptionRow1.optionsOnALine[2].selectionNumberForThisItem _ 7;  keyboardOptionRow1.optionsOnALine[2].option _ msgKey[exitSelection];    IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN _ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue _ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until exit is requested      keyboardInfoRow0.rowItems[0].stringValue _ SELECT eePromImage.Keyboard FROM      							none => msgKey[noKeyboard],      							english => msgKey[englishKeyboard],      							european => msgKey[europeanKeyboard],      							japanese => msgKey[japaneseKeyboard],      							learSiegler => msgKey[learSieglerKeyboard]      							ENDCASE => msgKey[unknown];    keyboardInfoRow1.rowItems[0].value _ LONG[LOOPHOLE[eePromImage.Keyboard]];    IF keyboardInfoRow0.rowItems[0].stringValue = msgKey[unknown] THEN    		{keyboardInfoRow1.rowItems[0].valuePosition _   		leftEdge + msgKey[newKeyboardSetting].length + aSpace; } ELSE		{keyboardInfoRow1.rowItems[0].name _ NIL; };  		      IF initialEntry = FALSE THEN       Odi.DisplayFixedPositionData [  -- Display the drive information       		displayData: keyboardInformation, upDateOnly: FALSE];		      keyboardSelected _ Odi.GetAnOption [  -- Always returns a valid option      optionTable: IF initialEntry THEN keyboardOptionTable ELSE NIL,      optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit    initialEntry _ FALSE;        IF keyboardSelected = 7 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested     SELECT keyboardSelected FROM       1 => eePromImage.Keyboard _ none;       2 => eePromImage.Keyboard _ english;       3 => eePromImage.Keyboard _ european;       4 => eePromImage.Keyboard _ japanese;       5 => eePromImage.Keyboard _ learSiegler;       6 => {            keyboardInfoRow1.rowItems[0].value _ Odi.GetANumber [            prompt: msgKey[newKeyboardType],	    lowLimit: 0,	    upperLimit: 0FFH,            numberIsLong: TRUE,            defaultNumber: keyboardInfoRow1.rowItems[0].value].longNumber;              eePromImage.Keyboard _ Inline.LowByte[Inline.LowHalf[keyboardInfoRow1.rowItems[0].value]]; --New Keyboard value;            };       ENDCASE;    keyboardInfoRow1.rowItems[0].valuePosition _ noNumericData;    keyboardInfoRow1.rowItems[0].name _ msgKey[newKeyboardSetting];            ENDLOOP; -- Outer loop    END; -- ConfigureKeyboardEND.logcreated on 18-Jun-85 14:45:24 by Allen Roberts
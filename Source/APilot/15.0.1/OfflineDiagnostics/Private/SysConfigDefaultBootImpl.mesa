-- File SysConfigDefaultBootImpl.mesa-- Last edited:  5-Jan-87 10:50:09	RDM	Add badMemConfig message.--  9-Dec-86  8:58:56	RDM--	       	       10-Sep-85 11:40:05	by: MR-- Created	       8-29-85			by: MR<<	Copyright (C) 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig ],  ---Inline	        USING [ LowHalf, LowByte ],  OfflineDiagInterface  USING [ AbortCurrentTest, AnOptionLine, ARow,			        DisplayFixedPositionData, 			        FixedPositionDisplayRecord, 				GetAFixedPositionDisplayRecord,				GetAnOption, GetAnOptionLine, 				GetAnOptionsRecord, GetARow, GetYesNo,				OfflineDiagnosticProc, OptionsRecord, 				PutMessage],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, statusPtr],  SysConfigChannelDefs  USING [ eePromImage];    SysConfigDefaultBootImpl: PROGRAM	IMPORTS OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureDceDtePort:--******************************************************************************ConfigureDefaultBoot: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN      type: TYPE = {bootDiagFast, bootDiagSlow,  bootDiagNotPresent};    numberTypes: CARDINAL = ORD[LAST[type]]+1;  optionTable: LONG POINTER TO Odi.OptionsRecord _      Odi.GetAnOptionsRecord [2];  -- Just two rows of options here  optionRow0: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [2];  optionRow1: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [ numberTypes - 2 + 1 ]; -- Extra option is for EXIT    leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 5;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  selected: CARDINAL;  -- The option selected by the user  initialEntry:  BOOLEAN _ TRUE;  information: LONG POINTER TO Odi.FixedPositionDisplayRecord _      Odi.GetAFixedPositionDisplayRecord [1];  -- 4 single-itemed rows of data    infoRow0: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row      -- Now construct the dce option table  --  optionTable.optionMenuTiTle _ msgKey[configDefaultBoot];  optionTable.linesOfOptions[0] _ optionRow0; -- Save pointer to row  optionTable.linesOfOptions[1] _ optionRow1; -- Save pointer to row    optionRow0.optionsOnALine[0].position _ leftEdge;  optionRow0.optionsOnALine[0].selectionNumberForThisItem _ 1;  optionRow0.optionsOnALine[0].option _ msgKey[setShortDefaultDiag];  -- %Change    xPosition _ leftEdge + msgKey[setShortDefaultDiag].length + 8;  -- %Change  optionRow0.optionsOnALine[1].position _ xPosition;  optionRow0.optionsOnALine[1].selectionNumberForThisItem _ 2;  optionRow0.optionsOnALine[1].option _ msgKey[setLongDefaultDiag];  -- %Change    optionRow1.optionsOnALine[0].position _ leftEdge;  optionRow1.optionsOnALine[0].selectionNumberForThisItem _ 3;  optionRow1.optionsOnALine[0].option _ msgKey[noBootDiag];    xPosition _ leftEdge + msgKey[setShortDefaultDiag].length + 8;  -- %Change  optionRow1.optionsOnALine[1].position _ xPosition;  optionRow1.optionsOnALine[1].selectionNumberForThisItem _ 4;  optionRow1.optionsOnALine[1].option _ msgKey[exitSelection];    -- Now fill in the static fields of the dce record  information.displayTitle _ msgKey[setDefaultBootDiag];  information.rows[0] _ infoRow0;  -- First row    infoRow0.rowItems[0].namePosition _ leftEdge;  -- Name position  infoRow0.rowItems[0].name _ msgKey[defaultBootDiag];  infoRow0.rowItems[0].valuePosition _ noNumericData;  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN _ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue _ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until exit is requested    selected _ Odi.GetAnOption [  -- Always returns a valid option    optionTable: IF initialEntry THEN optionTable ELSE NIL,    optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit    initialEntry _ FALSE;        SELECT selected FROM      4 => SIGNAL Odi.AbortCurrentTest;  -- Exit requested      3 => {eePromImage.DefaultBootDiag _ noDiags;            eePromImage.DefaultDiagnostics _ fast; };      2 => {eePromImage.DefaultBootDiag _ runDiags;      	    eePromImage.DefaultDiagnostics _ normal;};	         1 => {eePromImage.DefaultBootDiag _ runDiags;            eePromImage.DefaultDiagnostics _ fast;};      ENDCASE;          infoRow0.rowItems[0].stringValue _ SELECT selected FROM       1 =>  msgKey[short],       2 =>  msgKey[long]       ENDCASE =>  msgKey[none];					    Odi.DisplayFixedPositionData [  -- Display the drive information         displayData: information, upDateOnly: FALSE];            ENDLOOP; -- Outer loop    END;END.logcreated on 8-29-85 by Mi Ra Yoon
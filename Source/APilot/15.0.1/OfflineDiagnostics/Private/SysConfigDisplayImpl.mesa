-- File SysConfigDisplayImpl.mesa-- Last edited:	 16-Oct-87 17:19:23	STC	convert to 14.0-- edited:	 5-Jan-87 10:52:40	RDM	Add badMemConfig message.--  9-Dec-86  9:08:36	RDM--  1-Oct-85 15:23:29	by: AMR-- Created	18-Jun-85 14:40:31	by: AMR<<	Copyright (C) 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig ],  Inline	        USING [ LowHalf ],  OfflineDiagInterface  USING [ OfflineDiagnosticProc,  				AbortCurrentTest,				OptionsRecord, AnOptionLine, GetAnOptionsRecord,				GetAnOptionLine, GetAnOption,				GetAFixedPositionDisplayRecord, GetARow,			        FixedPositionDisplayRecord, ARow, 				DisplayFixedPositionData,			        GetANumber, GetYesNo, PutMessage],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, statusPtr],  SysConfigChannelDefs  USING [ eePromImage],  DoveInputOutput	USING [GetMicrocodeVersion, MachineType, MicrocodeVersion];    SysConfigDisplayImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs, DoveInputOutput			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureDisplay:  --******************************************************************************ConfigureDisplay: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    -- Screen types supported. Whenever new types are encountered, simply add     ScreenChoicesPresent: TYPE = {notPresent, present};      MCodeVersion:DoveInputOutput.MicrocodeVersion;    numberOfScreenChoicesPresent: CARDINAL = ORD[LAST[ScreenChoicesPresent]] + 1;  screenChoicesPresentOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [2];  -- Just one row of option here  screenChoicesPresentOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];  screenChoicesPresentOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [numberOfScreenChoicesPresent - 2 + 1 ]; -- Extra option is for EXIT      screenInformation: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [6];  -- 2 single-itemed rows of data       screenInfoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item in a row  screenInfoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item in a row  screenInfoRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item in a row  screenInfoRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item in a row  screenInfoRow4: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item in a row  screenInfoRow5: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item in a row       -- This fixed-position display record holds the screen information as being  -- displayed at the top of the data area. The rest of the data area still can  -- be used to print normal data (PutData still retains its full power)  --      leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 1;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  screenTypeSelected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN ¬ TRUE;  -- Now fill in the static fields of the display record    -- Fill in the screen Information record fields  screenInformation.displayTitle ¬ msgKey[screeninfo];  --  has to be modified  screenInformation.rows[0] ¬ screenInfoRow0;  -- First row  screenInformation.rows[1] ¬ screenInfoRow1;  -- Second row  screenInformation.rows[2] ¬ screenInfoRow2;  -- third row  screenInformation.rows[3] ¬ screenInfoRow3;  -- fourth row  screenInformation.rows[4] ¬ screenInfoRow4;  -- fifth row  screenInformation.rows[5] ¬ screenInfoRow5;  -- fifth row    -- Now fill in the static fields of the display record  --   -- Fill in first row static data  screenInfoRow0.rowItems[0].namePosition ¬ leftEdge;  -- Name position  screenInfoRow0.rowItems[0].name ¬ msgKey[screen];  screenInfoRow0.rowItems[0].valuePosition ¬ noNumericData; -- no value     -- Fill in second  row static data  screenInfoRow1.rowItems[0].namePosition ¬ leftEdge;  -- Name position  screenInfoRow1.rowItems[0].name ¬ msgKey[screentype];  screenInfoRow1.rowItems[0].valuePosition ¬ noNumericData; -- no value   -- Fill in third row static data  screenInfoRow2.rowItems[0].namePosition ¬ leftEdge;  -- Name position  screenInfoRow2.rowItems[0].name ¬ msgKey[screentype];  screenInfoRow2.rowItems[0].valuePosition ¬ noNumericData; -- no value    -- Fill in fourth row static data  screenInfoRow3.rowItems[0].namePosition ¬ leftEdge;  -- Name position  screenInfoRow3.rowItems[0].name ¬ msgKey[screentype];  screenInfoRow3.rowItems[0].valuePosition ¬ noNumericData;    -- Fill in fifth row static data  screenInfoRow4.rowItems[0].namePosition ¬ leftEdge;  -- Name position  screenInfoRow4.rowItems[0].name ¬ NIL;  screenInfoRow4.rowItems[0].stringValue ¬ NIL;  -- No string value  screenInfoRow4.rowItems[0].valuePosition ¬ 0;          -- Fill in sixth row static data  screenInfoRow5.rowItems[0].namePosition ¬ leftEdge;  -- Name position  screenInfoRow5.rowItems[0].name ¬ NIL;  screenInfoRow5.rowItems[0].stringValue ¬ NIL;  -- No string value  screenInfoRow5.rowItems[0].valuePosition ¬ 0;       -- Now construct the screen option table  --  screenChoicesPresentOptionTable.linesOfOptions[0] ¬ screenChoicesPresentOptionRow0; -- Save pointer to row  screenChoicesPresentOptionTable.linesOfOptions[1] ¬ screenChoicesPresentOptionRow1; -- Save pointer to row  screenChoicesPresentOptionTable.optionMenuTiTle ¬ msgKey[configDisplay];    screenChoicesPresentOptionRow0.optionsOnALine[0].position ¬ leftEdge;  screenChoicesPresentOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  screenChoicesPresentOptionRow0.optionsOnALine[0].option ¬ msgKey[screenPresent];  -- %Change    xPosition ¬ leftEdge + msgKey[screenPresent].length + 8;  -- %Change  screenChoicesPresentOptionRow0.optionsOnALine[1].position ¬ xPosition;  screenChoicesPresentOptionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  screenChoicesPresentOptionRow0.optionsOnALine[1].option ¬ msgKey[screenNotPresent];  -- %Change    screenChoicesPresentOptionRow1.optionsOnALine[0].position ¬ leftEdge;  screenChoicesPresentOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  screenChoicesPresentOptionRow1.optionsOnALine[0].option ¬ msgKey[returnToTopLevel];  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN ¬ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue ¬ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until STOP is hit or valid data has been received                    screenInfoRow0.rowItems[0].stringValue ¬ SELECT eePromImage.DisplayPresent FROM 						      none => msgKey[screenNotPresent]						      ENDCASE => msgKey[screenPresent];						           screenInfoRow1.rowItems[0].stringValue ¬ SELECT eePromImage.DisplayBWColor FROM 						      color => msgKey[color]						      ENDCASE => msgKey[blackWhite];						            screenInfoRow2.rowItems[0].stringValue ¬ SELECT eePromImage.DisplayMap FROM						      bitMapType => msgKey[bitMapped]						      ENDCASE => msgKey[notBitMapped];            screenInfoRow3.rowItems[0].stringValue ¬ SELECT eePromImage.DisplaySize FROM						      small => msgKey[small]						      ENDCASE => msgKey[large];     -- Get  info     screenTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option     optionTable: IF initialEntry THEN screenChoicesPresentOptionTable ELSE NIL,     optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit     initialEntry ¬ FALSE;          [] ¬ Odi.GetAnOption [  -- Always returns a valid option     optionTable: IF initialEntry THEN screenChoicesPresentOptionTable ELSE NIL,     optionPrompt: msgKey[blanks], justDisplayTable:TRUE,      defaultOption: 0]; -- dummy display to erase Enter selection choice stmt.    IF screenTypeSelected = 3 THEN SIGNAL Odi.AbortCurrentTest;   --to get out completely        IF screenTypeSelected = 2 THEN {	      eePromImage.DisplayPresent ¬ none;	      SIGNAL Odi.AbortCurrentTest;  };	                          eePromImage.DisplayPresent ¬ present;          screenInfoRow0.rowItems[0].stringValue ¬ SELECT eePromImage.DisplayPresent FROM 							none => msgKey[screenNotPresent]							ENDCASE => msgKey[screenPresent];    Odi.DisplayFixedPositionData [displayData:screenInformation, upDateOnly:TRUE];    IF [] ¬ Odi.GetYesNo [prompt:msgKey[screenSetColor]]  THEN   eePromImage.DisplayBWColor ¬ blackAndWhite	    							  ELSE   eePromImage.DisplayBWColor ¬ color;           screenInfoRow1.rowItems[0].stringValue ¬ SELECT eePromImage.DisplayBWColor FROM        							color => msgKey[color]							ENDCASE => msgKey[blackWhite];							      Odi.DisplayFixedPositionData [displayData:screenInformation, upDateOnly:TRUE];            					           IF [] ¬ Odi.GetYesNo [prompt:msgKey[screenSetBitMapped ]]  THEN  eePromImage.DisplayMap ¬ bitMapType             						       ELSE  eePromImage.DisplayMap ¬ nonBitMapType;							           screenInfoRow2.rowItems[0].stringValue ¬ SELECT eePromImage.DisplayMap FROM							bitMapType => msgKey[bitMapped]							ENDCASE => msgKey[notBitMapped];	     Odi.DisplayFixedPositionData [displayData:screenInformation, upDateOnly:TRUE];						          Odi.PutMessage [msgKey[small]];  -- display small screen size    Odi.PutMessage [msgKey[large]];  -- display large screen size           IF [] ¬ Odi.GetYesNo [prompt:msgKey[screenSetSize ]] THEN eePromImage.DisplaySize ¬ small    							 ELSE eePromImage.DisplaySize ¬ large;    screenInfoRow3.rowItems[0].stringValue ¬ SELECT eePromImage.DisplaySize FROM							small => msgKey[small]							ENDCASE => msgKey[large];    Odi.DisplayFixedPositionData [displayData:screenInformation, upDateOnly:TRUE];	    MCodeVersion ¬ DoveInputOutput.GetMicrocodeVersion[] ;        IF MCodeVersion.machineType = DoveInputOutput.MachineType.daisy THEN {       screenInfoRow4.rowItems[0].name ¬ msgKey[Xalignment];       screenInfoRow5.rowItems[0].name ¬ msgKey[Yalignment];        screenInfoRow4.rowItems[0].valuePosition ¬               leftEdge + msgKey[Xalignment].length + aSpace;       screenInfoRow5.rowItems[0].valuePosition ¬               leftEdge + msgKey[Yalignment].length + aSpace;                										     -- Get X alignment info       screenInfoRow4.rowItems[0].value ¬ eePromImage.DisplayxAlignment;       screenInfoRow4.rowItems[0].value ¬ Odi.GetANumber [       	  prompt: msgKey[Xalignment],	  lowLimit: 0,	  upperLimit: 0FFH,	  numberIsLong: TRUE,	  defaultNumber: screenInfoRow4.rowItems[0].value].longNumber;       eePromImage.DisplayxAlignment ¬ Inline.LowHalf[screenInfoRow4.rowItems[0].value]; --X alignment       Odi.DisplayFixedPositionData [displayData:screenInformation, upDateOnly:TRUE];                          -- Get Y alignment       screenInfoRow5.rowItems[0].value ¬ eePromImage.DisplayyAlignment;       screenInfoRow5.rowItems[0].value ¬ Odi.GetANumber [       	  prompt: msgKey[Yalignment],	  lowLimit: 0,	  upperLimit: 0FFH,	  numberIsLong: TRUE, 	  defaultNumber: screenInfoRow5.rowItems[0].value].longNumber;       eePromImage.DisplayyAlignment ¬ Inline.LowHalf[screenInfoRow5.rowItems[0].value]; --Y alignment       Odi.DisplayFixedPositionData [displayData:screenInformation, upDateOnly:TRUE];   	};              ENDLOOP; -- inner loop         END;  -- ConfigureDisplayEND.logCreated on 18-Jun-85 14:40:31 by Allen Roberts
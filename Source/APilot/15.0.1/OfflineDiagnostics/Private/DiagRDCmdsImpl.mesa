-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- File: DiagRDCmdsImpl.mesa - last edit:-- TXM,  8-Jun-89 10:09:49--DIRECTORY  CompatibilityDiskFace USING [Command, Operation],  Device USING [Type],  DiskChannel USING [    DirectOperation, operationSize, diskOpWordAlignment, DiskChannelPrivate,    IOStatus, DoDirectIO, GetNextDrive, GetDriveAttributes, InspectDiskShape,    Drive, nullDrive],  DiagDiskBuff USING [    GenDataBuffer, GenFormatDataBuffer, GenDiagDataBuffer, GenLabelBuffer ],--    GenDiagLabelBuffer ],  DiagDiskCmdDrive USING [    --Unit,-- Cylinder, Head, Sector, SectorCount, MinCylinder, MinHead, MinSector,    MinUnit, MaxCylinder, MaxHead, MaxSector, MaxUnit, RecalFirst, TryCount,    UseSameDataBuff, ParamArrayL1, ParamPtrL1],  DiagRDDisplay USING [DumpMemory],  DiagDiskTestControl USING [UseDiagData, UseFormatData],  DiagRDTests USING [ReadDataBuffPtr, ReadLabelBuffPtr, Switch],  DiagDiskTimer USING [ResetTimer, StartTimer],  Environment USING [Base, first64K],  OfflineDiagInterface USING [--HitAnyKeyToContinue,-- LookForAbort--, PutMessage--],  PilotDisk USING [],  PilotDiskFace USING [    ControllerHandle, DeviceHandle, DiskAddress, GetDeviceAttributes,    GetNextController, GetNextDevice, nullControllerHandle, nullDeviceHandle,    Operation, Recalibrate],  ResidentHeap USING [ --FreeNode,-- MakeNode],  --String USING [AppendDecimal, AppendString],  Zone USING [Status],  DiagRDCmds USING [];DiagRDCmdsImpl: PROGRAM  IMPORTS    DiskChannel, DiagDiskBuff, DiagDiskCmdDrive, DiagRDDisplay,    DiagDiskTestControl, DiagRDTests, DiagDiskTimer, OfflineDiagInterface,    PilotDiskFace, ResidentHeap--, String  EXPORTS DiagRDCmds =  BEGIN OPEN Odi: OfflineDiagInterface;  tempStr: STRING ¬ [110];  -- volumeHanle:		PhysicalVolume.Handle;  DiskChannelStatus: PUBLIC DiskChannel.IOStatus;  --***remove later  NotFound: PUBLIC BOOLEAN ¬ FALSE;  NotReady: PUBLIC BOOLEAN ¬ FALSE;  CmdTimeOut: PUBLIC BOOLEAN;  DataDataPtr: PUBLIC LONG POINTER TO ARRAY OF WORD;  DataSize: PUBLIC CARDINAL ¬ 256;  DelayCount: PUBLIC LONG CARDINAL;  DiskCommand: PUBLIC CompatibilityDiskFace.Command;  LabelDataPtr: PUBLIC LONG POINTER TO ARRAY OF WORD;  LabelSize: PUBLIC CARDINAL ¬ 10;  OpPtr: PUBLIC LONG POINTER TO CompatibilityDiskFace.Operation;  TimesRetried: PUBLIC CARDINAL;  diskModel: PUBLIC Device.Type;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Private variables  nowKnown: BOOLEAN;  drive: DiskChannel.Drive ¬ DiskChannel.nullDrive;  controllerHandle: PilotDiskFace.ControllerHandle ¬    PilotDiskFace.nullControllerHandle;  deviceHandle: PilotDiskFace.DeviceHandle ¬ PilotDiskFace.nullDeviceHandle;  noCmdTimeOut: BOOLEAN ¬ FALSE;  op: LONG POINTER TO DiskChannel.DirectOperation;  labeledOperation: CompatibilityDiskFace.Operation;  opPtrPresent: BOOLEAN ¬ FALSE;  opStorage: Environment.Base RELATIVE POINTER;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- get operation pointer  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetOperationPtr: PROC    RETURNS [      pOp: LONG POINTER TO DiskChannel.DirectOperation,      pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] =    -- pOp will be aligned per requirements of DoDirectIO.    -- pStorage should be used when freeing.    BEGIN    rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;    status: Zone.Status;    NoWay: ERROR = CODE;    diskOpAlign: CARDINAL ¬ DiskChannel.diskOpWordAlignment;     [pStorage, status] ¬ ResidentHeap.MakeNode[      n: DiskChannel.operationSize + diskOpAlign - 1,      alignment: a1];    IF status ~= okay THEN ERROR NoWay;    rpDirOp ¬ pStorage;    pOp ¬ @Environment.first64K[rpDirOp];    pOp ¬      LOOPHOLE[((LOOPHOLE[pOp, LONG CARDINAL] +                 SIZE[DiskChannel.DiskChannelPrivate] + diskOpAlign - 1) / 		diskOpAlign) * diskOpAlign - 		SIZE[DiskChannel.DiskChannelPrivate]];    opPtrPresent ¬ TRUE;    END;  --GetOperationPtr  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to check for command timeout  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DoIO: PROCEDURE =    BEGIN    noCmdTimeOut ¬ FALSE;    [status: DiskChannelStatus, retryCount: TimesRetried] ¬ DiskChannel.DoDirectIO[      op];    noCmdTimeOut ¬ TRUE;    DiagDiskTimer.ResetTimer[];    END;  --DoIO  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- performs Lable/Header/Data operations  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DiskOpr: PUBLIC PROCEDURE =    BEGIN    dataPtr: CARDINAL ¬ 0;    diskadr: PilotDiskFace.DiskAddress;    outParam: BOOLEAN ¬ TRUE;    « formatTries:		CARDINAL¬ 10; format: BOOLEAN ¬ DiskCommand.header= write   AND DiskCommand.label= write   AND DiskCommand.data= write;  IF format THEN {   help: LONG POINTER TO Odi.HelpText;      help ¬ Odi.GetAHelpText[1];   help.textBody [0] ¬ "Valid input is between 1 and 200."L;      [number: formatTries] ¬ Odi.GetANumber[     prompt: "Format Passes = "L,     help: help, lowLimit: 1, upperLimit: 200,     defaultNumber: 10];   };    UNTIL formatTries=0 DO»    Odi.LookForAbort[];    « IF format AND DiagRDTests.Switch[25] THEN {   Odi.PutData[data: "Format Passes = "L, numberAfterData: formatTries, startWithNewLine: TRUE];   Odi.PutData[data: " / "L, numberAfterData: 10, startWithNewLine: FALSE];   };»    «IF DiagRDTests.Switch[13] THEN {      tempStr.length ¬ 0;      IF DiskCommand.header = noOp THEN        String.AppendString[tempStr, "NoOpHeader/"];      IF DiskCommand.header = read THEN        String.AppendString[tempStr, "ReadHeader/"];      IF DiskCommand.header = write THEN        String.AppendString[tempStr, "WriteHeader/"];      IF DiskCommand.header = verify THEN        String.AppendString[tempStr, "VerifyHeader/"];      IF DiskCommand.label = noOp THEN String.AppendString[tempStr, "NoOpLabel/"];      IF DiskCommand.label = read THEN String.AppendString[tempStr, "ReadLabel/"];      IF DiskCommand.label = write THEN        String.AppendString[tempStr, "WriteLabel/"];      IF DiskCommand.label = verify THEN        String.AppendString[tempStr, "VerifyLabel/"];      IF DiskCommand.data = noOp THEN String.AppendString[tempStr, "NoOpData["];      IF DiskCommand.data = read THEN String.AppendString[tempStr, "ReadData["];      IF DiskCommand.data = write THEN String.AppendString[tempStr, "WriteData["];      IF DiskCommand.data = verify THEN        String.AppendString[tempStr, "VerifyData["];      Odi.PutMessage[message: tempStr, clearMessageAreaFirst: TRUE];      tempStr.length ¬ 0;      String.AppendString[tempStr, "Recalibrate first: "];      IF DiagDiskCmdDrive.RecalFirst = 1 THEN String.AppendString[tempStr, "Yes, "]      ELSE String.AppendString[tempStr, "No, "];      String.AppendString[tempStr, "Use same buffer area: "];      IF DiagDiskCmdDrive.UseSameDataBuff = 1 THEN        String.AppendString[tempStr, "Yes, "]      ELSE String.AppendString[tempStr, "No, "];      String.AppendString[tempStr, "Try count: "];      String.AppendDecimal[tempStr, DiagDiskCmdDrive.TryCount];      Odi.PutMessage[message: tempStr, startWithNewLine: TRUE];      tempStr.length ¬ 0;      String.AppendString[tempStr, "Unit: "];      String.AppendDecimal[tempStr, DiagDiskCmdDrive.Unit];      String.AppendString[tempStr, ", Cylinder: "];      String.AppendDecimal[tempStr, DiagDiskCmdDrive.Cylinder];      String.AppendString[tempStr, ", Head: "];      String.AppendDecimal[tempStr, DiagDiskCmdDrive.Head];      String.AppendString[tempStr, ", Sector: "];      String.AppendDecimal[tempStr, DiagDiskCmdDrive.Sector];      String.AppendString[tempStr, ", SectorCount: "];      String.AppendDecimal[tempStr, DiagDiskCmdDrive.SectorCount];      Odi.PutMessage[message: tempStr, startWithNewLine: TRUE];      Odi.HitAnyKeyToContinue[];      };»    --get the operation pointer if there is none    IF NOT opPtrPresent THEN [pOp: op, pStorage: opStorage] ¬ GetOperationPtr[];    --set up the pointer (LOOPHOLE to get labeled operation, SPL)    OpPtr ¬ @(LOOPHOLE[op.diskOp, CompatibilityDiskFace.Operation]);    CmdTimeOut ¬ FALSE;    IF DiagDiskCmdDrive.ParamPtrL1 > 0 THEN      dataPtr ¬ DiagDiskCmdDrive.ParamPtrL1 - 1    ELSE dataPtr ¬ DiagDiskCmdDrive.ParamPtrL1;    --generate the write label buffers    IF DiskCommand.label = write OR DiskCommand.label = verify THEN {<<      IF DiagDiskTestControl.UseDiagData THEN        DiagDiskBuff.GenDiagLabelBuffer[ptr: LabelDataPtr, size: LabelSize]      ELSE	>>        DiagDiskBuff.GenLabelBuffer[          data: DiagDiskCmdDrive.ParamArrayL1[dataPtr].LabelDataMem,          ptr: LabelDataPtr, size: LabelSize];      };<<-- restored, STC, 16-Oct-88 17:19:41 -- Above replaced by the following    LabelDataPtr ¬ DiagRDTests.ReadLabelBuffPtr;    DiagDiskBuff.GenDiagLabelBuffer[ptr: LabelDataPtr, size: LabelSize];>>    --generate the write data buffers    IF DiskCommand.data = write OR DiskCommand.data = verify THEN {      IF DiagDiskTestControl.UseFormatData THEN        DiagDiskBuff.GenFormatDataBuffer[          ptr: DataDataPtr,          size:          IF DiagDiskCmdDrive.UseSameDataBuff = 1 THEN DataSize          ELSE DiagDiskCmdDrive.SectorCount * DataSize]      ELSE        IF DiagDiskTestControl.UseDiagData THEN          DiagDiskBuff.GenDiagDataBuffer[            ptr: DataDataPtr,            size:            IF DiagDiskCmdDrive.UseSameDataBuff = 1 THEN DataSize            ELSE DiagDiskCmdDrive.SectorCount * DataSize]        ELSE          DiagDiskBuff.GenDataBuffer[            data: DiagDiskCmdDrive.ParamArrayL1[dataPtr].DataMem, ptr: DataDataPtr,            size:            IF DiagDiskCmdDrive.UseSameDataBuff = 1 THEN DataSize            ELSE DiagDiskCmdDrive.SectorCount * DataSize];      };    --set up disk address    diskadr.cylinder ¬ DiagDiskCmdDrive.Cylinder;    diskadr.head ¬ DiagDiskCmdDrive.Head;    diskadr.sector ¬ DiagDiskCmdDrive.Sector;    -- check for recalibrate first    IF DiagDiskCmdDrive.RecalFirst = 1 THEN      PilotDiskFace.Recalibrate[deviceHandle];    labeledOperation ¬ [      clientHeader: diskadr, labelPtr: LOOPHOLE[LabelDataPtr],      dataPtr: DataDataPtr,      incrementDataPtr:      IF DiagDiskCmdDrive.UseSameDataBuff = 1 THEN FALSE ELSE TRUE,      command: DiskCommand, tries: DiagDiskCmdDrive.TryCount,      pageCount: DiagDiskCmdDrive.SectorCount, device: deviceHandle];    op­.diskOp ¬ LOOPHOLE[labeledOperation, PilotDiskFace.Operation];    DelayCount ¬ 0;    --do IO operation and check for command time-out    {    process: PROCESS;    timedOut: BOOLEAN ¬ FALSE;    process ¬ FORK DoIO[];    timedOut ¬ DiagDiskTimer.StartTimer[      ticks: 300 + (DiagDiskCmdDrive.SectorCount * 10)];    IF timedOut THEN CmdTimeOut ¬ TRUE ELSE JOIN process;    };    -- output complete IOCB    IF DiagRDTests.Switch[64] THEN {      DiagRDDisplay.DumpMemory[        title: "IOCB DUMP", ptr: LOOPHOLE[@op­.diskOp], words: 80];      };    «IF DiskCommand.header= write   AND DiskCommand.label= write   AND DiskCommand.data= write THEN format¬ TRUE ELSE format¬ FALSE; IF format THEN { WITH s: DiskChannelStatus SELECT FROM    disk=> SELECT s.status FROM	goodCompletion=> format¬ FALSE;     ENDCASE;   ENDCASE; }; formatTries¬ formatTries-1; IF formatTries=0 THEN format¬ FALSE; ENDLOOP;--for UNTIL NOT format DO»    END;  --DiskOptr  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- reads the device status  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ReadStatus: PUBLIC PROCEDURE = BEGIN END;  --ReadStatus  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set noOp data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetNoOpData: PUBLIC PROCEDURE =    BEGIN    DiskCommand.data ¬ noOp;    DataDataPtr ¬ DiagRDTests.ReadDataBuffPtr;    DiskOpr[];    END;  --SetNoOpData  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set noOp the header  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetNoOpHeader: PUBLIC PROCEDURE = BEGIN DiskCommand.header ¬ noOp; END;  --SetNoOpHeader  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set noOp label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetNoOpLabel: PUBLIC PROCEDURE =    BEGIN    DiskCommand.label ¬ noOp;    LabelDataPtr ¬ DiagRDTests.ReadLabelBuffPtr;    END;  --SetNoOpLabel  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set read data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetReadData: PUBLIC PROCEDURE =    BEGIN    DiskCommand.data ¬ read;    DataDataPtr ¬ DiagRDTests.ReadDataBuffPtr;    DiskOpr[];    END;  --SetReadData  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set read the header  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetReadHeader: PUBLIC PROCEDURE = BEGIN DiskCommand.header ¬ read; END;  --SetReadHeader  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set read label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetReadLabel: PUBLIC PROCEDURE =    BEGIN    DiskCommand.label ¬ read;    LabelDataPtr ¬ DiagRDTests.ReadLabelBuffPtr;    END;  --SetReadLabel  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set write data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetWriteData: PUBLIC PROCEDURE =    BEGIN    dataPtr: CARDINAL ¬ 0;    DiskCommand.data ¬ write;    IF DiagDiskCmdDrive.ParamPtrL1 > 0 THEN      dataPtr ¬ DiagDiskCmdDrive.ParamPtrL1 - 1;    DataDataPtr ¬ DiagDiskCmdDrive.ParamArrayL1[dataPtr].WriteDataPtr;    DiskOpr[];    END;  --SetWriteData  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set write the header  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetWriteHeader: PUBLIC PROCEDURE = BEGIN DiskCommand.header ¬ write; END;  --SetWriteHeader  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set verify data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetVerifyData: PUBLIC PROCEDURE =    BEGIN    dataPtr: CARDINAL ¬ 0;    DiskCommand.data ¬ verify;    IF DiagDiskCmdDrive.ParamPtrL1 > 0 THEN      dataPtr ¬ DiagDiskCmdDrive.ParamPtrL1 - 1;    DataDataPtr ¬ DiagDiskCmdDrive.ParamArrayL1[dataPtr].WriteDataPtr;    DiskOpr[];    END;  --SetVerifyData  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set verify label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetVerifyLabel: PUBLIC PROCEDURE =    BEGIN    DiskCommand.label ¬ verify;    LabelDataPtr ¬ DiagDiskCmdDrive.ParamArrayL1[      DiagDiskCmdDrive.ParamPtrL1].WriteLabelPtr;    END;  --SetVerifyLabel  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set write label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetWriteLabel: PUBLIC PROCEDURE =    BEGIN    DiskCommand.label ¬ write;    LabelDataPtr ¬ DiagDiskCmdDrive.ParamArrayL1[      DiagDiskCmdDrive.ParamPtrL1].WriteLabelPtr;    END;  --SetWriteLabel  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- set verify the header  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetVerifyHeader: PUBLIC PROCEDURE = BEGIN DiskCommand.header ¬ verify; END;  --SetVerifyHeader  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Main line code   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --get the handles  controllerHandle ¬ PilotDiskFace.GetNextController[    PilotDiskFace.nullControllerHandle];  deviceHandle ¬ PilotDiskFace.GetNextDevice[PilotDiskFace.nullDeviceHandle];  drive ¬ DiskChannel.GetNextDrive[drive];  IF drive = DiskChannel.nullDrive THEN ERROR;  nowKnown ¬ DiskChannel.InspectDiskShape[drive: drive, mode: quickReadOnly];  IF NOT nowKnown THEN ERROR;  [deviceType: diskModel] ¬ DiskChannel.GetDriveAttributes[drive];  [cylinders: DiagDiskCmdDrive.MaxCylinder, movingHeads: DiagDiskCmdDrive.MaxHead,    sectorsPerTrack: DiagDiskCmdDrive.MaxSector] ¬    PilotDiskFace.GetDeviceAttributes[deviceHandle];  DiagDiskCmdDrive.MinUnit ¬ 0;  DiagDiskCmdDrive.MaxUnit ¬ 0;  DiagDiskCmdDrive.MinCylinder ¬ 0;  DiagDiskCmdDrive.MaxCylinder ¬ DiagDiskCmdDrive.MaxCylinder - 1;  DiagDiskCmdDrive.MinHead ¬ 0;  DiagDiskCmdDrive.MaxHead ¬ DiagDiskCmdDrive.MaxHead - 1;  DiagDiskCmdDrive.Head ¬ 0;  DiagDiskCmdDrive.MinSector ¬ 0;  DiagDiskCmdDrive.MaxSector ¬ DiagDiskCmdDrive.MaxSector - 1;  END...--of DiagRDCmdsImpl.mesaLOG10-Dec-85 13:08:30 MXT29-Aug-86 15:42:32 converted ptr stuffs to CompatibilityDiskFace for operations 4-Sep-86  9:18:26 removed Status conversion foo stuff30-Oct-86 12:34:55 SPL removed fooXXX from DiskChannelStatus 19-Sep-88 16:43:03, STC merge Labelless conversion16-Oct-88 17:20:48, STC restored generate label buffer 8-Jun-89 10:09:49, TXM changed to use diskOpWordAlignment instead of constants			 in GetOperationPtr for labelless
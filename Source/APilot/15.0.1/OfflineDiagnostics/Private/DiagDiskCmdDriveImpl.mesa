-- File: DiagDiskCmdDriveImpl.mesa -- last edit: STC, 14-Sep-87 16:14:28-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: DiagDiskCmdDriveImpl.mesa---- DIRECTORY DiagRDBasicTest	USING	[InRunUnit], DiagDiskCmdDes		USING	[CommandRecord], DiagDiskMkIOCmd	USING	[mkIOCmd], DiagRDErrorCheck	USING	[CheckStatus, 				 SubtestSoftErrorCount], DiagDiskTestControl	USING	[ControlCylinder, ControlHead,				 ControlSector, ControlSectorCount,				 ControlLoopCount, ControlTrackCount,				 ControlUnit, CountSubtestSoftErrors,				 EndlessLoop, LoopOnError, MaxSubtestSoftErrors,				 RepeatCommand, ReturningOnSoftError,				 ReturningOnSoftErrorInTable,				 UseSectorsPerHead,				 UseSectorsPerCylinder, UseHalfSectorsPerDrive,				 UseSectorsPerDrive, UseHeadsPerDrive,				 UseTracksPerDrive, UseCylindersPerDrive,				 UseFirstCylinder, UseFirstHead, UseFirstSector,				 UseLastCylinder, UseLastHead, UseLastSector,				 UseHalfSectorsPerCylinder,				 UseSectorCountPerHead,				 UseSectorCountPerCylinder], DiagRDSurfaceVerify	USING	[BadPageCount], --DiagRDTests		USING	[Switch], Inline			USING	[DBITSHIFT], Process		USING	[Pause], OfflineDiagInterface	USING	[PutMessage], --String			USING	[AppendNumber, AppendString], DiagDiskCmdDrive	USING	[ParamRecord];				  DiagDiskCmdDriveImpl: PROGRAM     IMPORTS	DiagDiskMkIOCmd,	DiagRDBasicTest,	DiagRDErrorCheck,	DiagDiskTestControl,	DiagRDSurfaceVerify,	--DiagRDTests,	Inline,	OfflineDiagInterface,	Process--, String    EXPORTS	DiagDiskCmdDrive =BEGIN    OPEN	DiagDiskMkIOCmd, Tc: DiagDiskTestControl, Odi: OfflineDiagInterface;  CmdDescriptionArray:		PUBLIC LONG DESCRIPTOR FOR ARRAY OF					DiagDiskCmdDes.CommandRecord; -- command stuff cmdPtr:			CARDINAL; Command:			PUBLIC CARDINAL; Continue:			PUBLIC BOOLEAN¬ FALSE; Rigid:				PUBLIC BOOLEAN¬ TRUE; Floppy:			PUBLIC BOOLEAN¬ FALSE; endOfCmdFile:			BOOLEAN¬ FALSE; NeedLabelData:			BOOLEAN¬ FALSE; -- looping stuff loop:				BOOLEAN¬ FALSE; firstTimeLoop:			BOOLEAN¬ FALSE; endLoop:			BOOLEAN¬ FALSE; loopCount:			LONG CARDINAL; startLoopAt:			CARDINAL; tempStr:			LONG STRING¬ [256]; -- delay count Delay:				CARDINAL;  --disk parameters LoopCount:			PUBLIC LONG CARDINAL; RecalFirst:			PUBLIC CARDINAL; UseSameDataBuff:		PUBLIC CARDINAL; TryCount:			PUBLIC CARDINAL¬     1; MinTryCount:			PUBLIC CARDINAL¬     1; MaxTryCount:			PUBLIC CARDINAL¬   255; Unit:				PUBLIC CARDINAL¬     0; MinUnit:			PUBLIC CARDINAL¬     0; MaxUnit:			PUBLIC CARDINAL¬     3; Cylinder:			PUBLIC CARDINAL¬     0; MinCylinder:			PUBLIC CARDINAL¬     0; MaxCylinder:			PUBLIC CARDINAL; Head:				PUBLIC CARDINAL¬     0; MinHead:			PUBLIC CARDINAL¬     0; MaxHead:			PUBLIC CARDINAL; Sector:			PUBLIC CARDINAL¬     0; MinSector:			PUBLIC CARDINAL¬     0; MaxSector:			PUBLIC CARDINAL; SectorCount:			PUBLIC CARDINAL¬     1; MinSectorCount:		PUBLIC CARDINAL¬     1; MaxSectorCount:		PUBLIC CARDINAL¬ 65535; TrackCount:			PUBLIC CARDINAL¬     1; MinTrackCount:			PUBLIC CARDINAL¬     1; MaxTrackCount:			PUBLIC CARDINAL¬ 65535;  --Sector incrementing XferPassedMaxCylinder:		PUBLIC BOOLEAN¬ FALSE; XferPassedMaxHead:		PUBLIC BOOLEAN¬ TRUE; XferPassedMaxSector:		PUBLIC BOOLEAN¬ TRUE;     --memory for command parameters in first loop  ParamPtrL1: PUBLIC CARDINAL¬ 0;  ParamArrayL1:	PUBLIC ARRAY [0..3] OF DiagDiskCmdDrive.ParamRecord;    ParameterRecord: TYPE= RECORD [	item1Freeze:			BOOLEAN¬ FALSE,	item1:				CARDINAL¬ 0,	item1Change:			CARDINAL¬ 0,	item1Incr:			BOOLEAN¬ TRUE,	minItem1:			CARDINAL¬ 0,	maxItem1:			CARDINAL¬ 0,  	item2Freeze:			BOOLEAN¬ FALSE,	item2:				CARDINAL¬ 0,	item2Change:			CARDINAL¬ 0,	item2Incr:			BOOLEAN¬ TRUE,	minItem2:			CARDINAL¬ 0,	maxItem2:			CARDINAL¬ 0,			item3Freeze:			BOOLEAN¬ FALSE,	item3:				CARDINAL¬ 0,	item3Change:			CARDINAL¬ 0,	item3Incr:			BOOLEAN¬ TRUE,	minItem3:			CARDINAL¬ 0,	maxItem3:			CARDINAL¬ 0,			item4Freeze:			BOOLEAN¬ FALSE,	item4:				CARDINAL¬ 0,	item4Change:			CARDINAL¬ 0,	item4Incr:			BOOLEAN¬ FALSE,	minItem4:			CARDINAL¬ 0,	maxItem4:			CARDINAL¬ 0,			itemsToXfer:			CARDINAL¬ 1,	itemsToXferCrossesMaxItem1:	BOOLEAN¬ FALSE,	itemsToXferCrossesMaxItem2:	BOOLEAN¬ FALSE,	itemsToXferCrossesMaxItem3:	BOOLEAN¬ FALSE	];  parmRecord: ParameterRecord; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Selects and executes commands from the Command File -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ExecuteCommands: PUBLIC PROCEDURE [commandArray:		LONG DESCRIPTOR FOR ARRAY OF CARDINAL¬ DESCRIPTOR [NIL, 0]] = BEGIN softError: BOOLEAN ¬ FALSE; softErrInTable: BOOLEAN ¬ FALSE;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetNumber: PROCEDURE RETURNS [count: CARDINAL] = BEGIN count¬ commandArray [cmdPtr]; cmdPtr¬ cmdPtr+ 1; END; --getNumber -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetParameters: PROCEDURE  = BEGIN -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SignIsPositive: PROCEDURE RETURNS [positive: BOOLEAN¬ TRUE]  = BEGIN  count: CARDINAL;  count¬ commandArray [cmdPtr];  cmdPtr¬ cmdPtr+ 1;  IF count= 0 THEN positive¬ FALSE;  END; --SignIsPositive -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   IF NOT loop THEN { IF CmdDescriptionArray[Command].needLoopCount THEN   {  IF Tc.ControlLoopCount THEN     { []¬ GetNumber []; []¬ GetNumber [];       SELECT TRUE FROM         Tc.UseSectorsPerHead=> loopCount¬ MaxSector+ 1;         Tc.UseHalfSectorsPerCylinder=> loopCount¬	   ((MaxSector+ 1)*(MaxHead+ 1))/2;         Tc.UseSectorsPerCylinder=> loopCount¬	   (MaxSector+ 1)*(MaxHead+ 1);         Tc.UseHalfSectorsPerDrive=> loopCount¬	   ((MaxSector+ 1)*(MaxHead+ 1)*(MaxCylinder+ 1))/2;         Tc.UseSectorsPerDrive=> loopCount¬	    (MaxSector+ 1)*(MaxHead+ 1)*(MaxCylinder+ 1);         Tc.UseHeadsPerDrive=> loopCount¬ MaxHead+ 1;         Tc.UseTracksPerDrive=> loopCount¬	    (MaxHead+ 1)*(MaxCylinder+ 1);         Tc.UseCylindersPerDrive=> loopCount¬ MaxCylinder+ 1;       ENDCASE=> loopCount¬ LoopCount;       RETURN;     } ELSE     { lp: CARDINAL;       loopCount¬ GetNumber[]; --get the most significant part of the number       lp¬ GetNumber[]; --get the least significant part of the number       loopCount¬ Inline.DBITSHIFT[loopCount, 16];       loopCount¬ loopCount+ lp;       RETURN     };   };   IF CmdDescriptionArray[Command].needDelay THEN   { Delay¬ GetNumber []; RETURN   };   IF CmdDescriptionArray[Command].needLabelData THEN   { NeedLabelData¬ TRUE; RETURN   };   IF NOT CmdDescriptionArray[Command].getParamsCmd THEN RETURN;        --now we get the noOp/read/write/verify operation parameters   ParamArrayL1[ParamPtrL1].SkipCount¬ 0;   IF CmdDescriptionArray[Command].needRecalFirst THEN   { ParamArrayL1[ParamPtrL1].recalFirstMem¬ RecalFirst¬ GetNumber[];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   IF CmdDescriptionArray[Command].needUseSameDataBuff THEN   { ParamArrayL1[ParamPtrL1].useSameDataBuffMem¬ UseSameDataBuff¬ GetNumber[];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   IF CmdDescriptionArray[Command].needTryCount THEN   { ParamArrayL1[ParamPtrL1].tryCountMem¬ TryCount¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   --get unit number   IF CmdDescriptionArray[Command].needUnit THEN   { IF Tc.ControlUnit THEN     { []¬ GetNumber [];       ParamArrayL1[ParamPtrL1].UnitMem¬ Unit;     } ELSE Unit¬ ParamArrayL1[ParamPtrL1].UnitMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;     IF firstTimeLoop THEN     { IF SignIsPositive [] THEN       ParamArrayL1[ParamPtrL1].UnitPos¬ TRUE ELSE         ParamArrayL1[ParamPtrL1].UnitPos¬ FALSE;       ParamArrayL1[ParamPtrL1].UnitChange¬ GetNumber [];       ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 2;     };   };   --get cylinder number   IF CmdDescriptionArray[Command].needCylinder THEN   { IF Tc.ControlCylinder THEN     { []¬ GetNumber [];       ParamArrayL1[ParamPtrL1].CylinderMem¬ Cylinder;       IF Tc.UseFirstCylinder THEN         ParamArrayL1[ParamPtrL1].CylinderMem¬ Cylinder¬ MinCylinder;       IF Tc.UseLastCylinder THEN         ParamArrayL1[ParamPtrL1].CylinderMem¬ Cylinder¬ MaxCylinder;     } ELSE Cylinder¬ ParamArrayL1[ParamPtrL1].CylinderMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;     IF firstTimeLoop THEN     { IF SignIsPositive [] THEN         ParamArrayL1[ParamPtrL1].CylinderPos¬ TRUE ELSE           ParamArrayL1[ParamPtrL1].CylinderPos¬ FALSE;       ParamArrayL1[ParamPtrL1].CylinderChange¬ GetNumber [];       ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 2;     };   };   --get head number   IF CmdDescriptionArray[Command].needHead THEN   { IF Tc.ControlHead THEN     { []¬ GetNumber [];       ParamArrayL1[ParamPtrL1].HeadMem¬ Head;       IF Tc.UseFirstHead THEN         ParamArrayL1[ParamPtrL1].HeadMem¬ Head¬ MinHead;       IF Tc.UseLastHead THEN         ParamArrayL1[ParamPtrL1].HeadMem¬ Head¬ MaxHead;     } ELSE Head¬ ParamArrayL1[ParamPtrL1].HeadMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;     IF firstTimeLoop THEN     { IF SignIsPositive [] THEN         ParamArrayL1[ParamPtrL1].HeadPos¬ TRUE ELSE           ParamArrayL1[ParamPtrL1].HeadPos¬ FALSE;       ParamArrayL1[ParamPtrL1].HeadChange¬ GetNumber [];       ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 2;     };   };   --get sector number   IF CmdDescriptionArray[Command].needSector THEN   { IF Tc.ControlSector THEN     {[]¬ GetNumber [];       ParamArrayL1[ParamPtrL1].SectorMem¬ Sector;       IF Tc.UseFirstSector THEN         ParamArrayL1[ParamPtrL1].SectorMem¬ Sector¬ MinSector;       IF Tc.UseLastSector THEN         ParamArrayL1[ParamPtrL1].SectorMem¬ Sector¬ MaxSector;     } ELSE Sector¬ ParamArrayL1[ParamPtrL1].SectorMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;     IF firstTimeLoop THEN     { IF SignIsPositive [] THEN         ParamArrayL1[ParamPtrL1].SectorPos¬ TRUE ELSE           ParamArrayL1[ParamPtrL1].SectorPos¬ FALSE;       ParamArrayL1[ParamPtrL1].SectorChange¬ GetNumber [];       ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 2;     };   };   --get sector count number   IF CmdDescriptionArray[Command].needSectorCount THEN   { IF Tc.ControlSectorCount THEN     { []¬ GetNumber [];       SELECT TRUE FROM         Tc.UseSectorCountPerHead=> ParamArrayL1[ParamPtrL1].SectorCountMem¬           SectorCount¬ MaxSector+ 1;         Tc.UseSectorCountPerCylinder=> ParamArrayL1[ParamPtrL1].SectorCountMem¬            SectorCount¬ (MaxSector+ 1)*(MaxHead+ 1);       ENDCASE=> ParamArrayL1[ParamPtrL1].SectorCountMem¬ SectorCount;     } ELSE SectorCount¬ ParamArrayL1[ParamPtrL1].SectorCountMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   --get track count   IF CmdDescriptionArray[Command].needTrackCount THEN   { IF Tc.ControlTrackCount THEN     { []¬ GetNumber [];       ParamArrayL1[ParamPtrL1].TrackCountMem¬ TrackCount     } ELSE TrackCount¬ ParamArrayL1[ParamPtrL1].TrackCountMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   --get label data   IF NeedLabelData THEN   { ParamArrayL1[ParamPtrL1].LabelDataMem¬ GetNumber [];     NeedLabelData¬ FALSE;     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   --get data   IF CmdDescriptionArray[Command].needData THEN   { ParamArrayL1[ParamPtrL1].DataMem¬ GetNumber [];     ParamArrayL1[ParamPtrL1].SkipCount¬ ParamArrayL1[ParamPtrL1].SkipCount+ 1;   };   --point to next parameter record   IF firstTimeLoop THEN ParamPtrL1¬ ParamPtrL1+ 1;   RETURN };  IF loop THEN  { IF CmdDescriptionArray[Command].needDelay THEN    { Delay¬ GetNumber []; RETURN};    IF NOT CmdDescriptionArray[Command].getParamsCmd THEN RETURN;        --get the required parameters    RecalFirst¬ ParamArrayL1[ParamPtrL1].recalFirstMem;    UseSameDataBuff¬ ParamArrayL1[ParamPtrL1].useSameDataBuffMem;    TryCount¬ ParamArrayL1[ParamPtrL1].tryCountMem;        cmdPtr¬ cmdPtr+ ParamArrayL1[ParamPtrL1].SkipCount;        parmRecord.item1Freeze¬		Tc.ControlSector;    parmRecord.item1¬			ParamArrayL1[ParamPtrL1].SectorMem;    parmRecord.item1Change¬		ParamArrayL1[ParamPtrL1].SectorChange;    parmRecord.item1Incr¬		ParamArrayL1[ParamPtrL1].SectorPos;    parmRecord.minItem1¬		MinSector;    parmRecord.maxItem1¬		MaxSector;         parmRecord.item2Freeze¬		Tc.ControlHead;    parmRecord.item2¬			ParamArrayL1[ParamPtrL1].HeadMem;    parmRecord.item2Change¬		ParamArrayL1[ParamPtrL1].HeadChange;    parmRecord.item2Incr¬		ParamArrayL1[ParamPtrL1].HeadPos;    parmRecord. minItem2¬		MinHead;    parmRecord.maxItem2¬		MaxHead;	       parmRecord.item3Freeze¬		Tc.ControlCylinder;    parmRecord.item3¬			ParamArrayL1[ParamPtrL1].CylinderMem;    parmRecord.item3Change¬		ParamArrayL1[ParamPtrL1].CylinderChange;    parmRecord.item3Incr¬		ParamArrayL1[ParamPtrL1].CylinderPos;    parmRecord.minItem3¬		MinCylinder;    parmRecord.maxItem3¬		MaxCylinder;	       parmRecord.item4Freeze¬		Tc.ControlUnit;    parmRecord.item4¬			ParamArrayL1[ParamPtrL1].UnitMem;    parmRecord.item4Change¬		ParamArrayL1[ParamPtrL1].UnitChange;    parmRecord.item4Incr¬		ParamArrayL1[ParamPtrL1].UnitPos;    parmRecord.minItem4¬		MinUnit;    parmRecord.maxItem4¬		MaxUnit;	       parmRecord.itemsToXfer¬		ParamArrayL1[ParamPtrL1].SectorCountMem;    parmRecord.itemsToXferCrossesMaxItem1¬XferPassedMaxSector;    parmRecord.itemsToXferCrossesMaxItem2¬XferPassedMaxHead;    parmRecord.itemsToXferCrossesMaxItem3¬XferPassedMaxCylinder;	    [newItemsToXfer:	SectorCount,     newItem1:		ParamArrayL1[ParamPtrL1].SectorMem,     newItem2:		ParamArrayL1[ParamPtrL1].HeadMem,     newItem3:		ParamArrayL1[ParamPtrL1].CylinderMem,     newItem4:		ParamArrayL1[ParamPtrL1].UnitMem]¬	UpdateParameters [parmRcd: parmRecord];	       Sector¬ ParamArrayL1[ParamPtrL1].SectorMem;    Head¬ ParamArrayL1[ParamPtrL1].HeadMem;    Cylinder¬ ParamArrayL1[ParamPtrL1].CylinderMem;    Unit¬ ParamArrayL1[ParamPtrL1].UnitMem;        ParamPtrL1¬ ParamPtrL1+ 1;  };  END; --GetParameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ endOfCmdFile¬ FALSE; IF BASE [commandArray]= NIL THEN RETURN;  IF Tc.CountSubtestSoftErrors THEN   DiagRDErrorCheck.SubtestSoftErrorCount¬ Tc.MaxSubtestSoftErrors;  -- display the entered command file «IF DiagRDTests.Switch[3] THEN { cnt:		CARDINAL¬ 0;   tempStr.length¬ 0;   String.AppendString[tempStr, "["];   UNTIL cnt= LENGTH[commandArray] OR tempStr.length>= 248 DO     String.AppendNumber[tempStr, commandArray[cnt]];     String.AppendString[tempStr, ","];     cnt¬cnt+1;   ENDLOOP;   String.AppendNumber[tempStr, commandArray[cnt]];   String.AppendString[tempStr, "]"];   Odi.PutMessage[message: tempStr, 		  clearMessageAreaFirst: TRUE];   Odi.HitAnyKeyToContinue[]; };»    -- if command file is not to be continued IF NOT Continue THEN { cmdPtr¬ 0;   ParamPtrL1¬ 0;   NeedLabelData¬ FALSE;   loop¬ FALSE;   firstTimeLoop¬ FALSE; }; Continue¬ FALSE; endOfCmdFile¬ FALSE; UNTIL endOfCmdFile DO    --loop on error can only be exited with stop key   IF Tc.LoopOnError THEN   { done: BOOLEAN¬ FALSE;     UNTIL done DO       CmdDescriptionArray[Command].cmdProc; --parameters are still set up     ENDLOOP;   };   IF Tc.RepeatCommand THEN   { CmdDescriptionArray[Command].cmdProc; --parameters are still set up     DiagRDErrorCheck.CheckStatus[];     LOOP;   };   IF (loop AND endLoop) THEN   { ParamPtrL1¬ 0;     endLoop¬ FALSE;     IF NOT Tc.EndlessLoop THEN loopCount¬ loopCount- 1;     IF loopCount> 0 THEN     cmdPtr¬ startLoopAt ELSE     loop¬ FALSE   };       -- get the next command   Command¬ commandArray [cmdPtr];   cmdPtr¬ cmdPtr+ 1;       -- get all the needed parameters   GetParameters[];       -- now execute the command (IO or otherwise)   CmdDescriptionArray[Command].cmdProc;      --check IO status   IF CmdDescriptionArray[Command].returnsIOStatus THEN     { softError ¬ FALSE; softErrInTable ¬ FALSE;       DiagRDErrorCheck.CheckStatus[         !DiagDiskTestControl.ReturningOnSoftErrorInTable =>	 	{ softErrInTable ¬ TRUE; LOOP;};          DiagDiskTestControl.ReturningOnSoftError => {            softError ¬ TRUE; CONTINUE; }; ];       IF (softError AND NOT softErrInTable) THEN     	 { failure: CARDINAL ¬ 0;-- ***** Only retry if it's in Confidence Test! *****	   IF DiagRDBasicTest.InRunUnit THEN	      { FOR i: CARDINAL IN [0..9] DO	  	  softError ¬ FALSE;		  CmdDescriptionArray[Command].cmdProc; -- ReDo the Op		  DiagRDErrorCheck.CheckStatus[		     !DiagDiskTestControl.ReturningOnSoftError =>			{softError ¬ TRUE; CONTINUE; }; ];		  IF softError THEN failure ¬ failure + 1; 		  ENDLOOP;	        IF failure > 2 THEN	       	  {DiagRDSurfaceVerify.BadPageCount ¬		  	DiagRDSurfaceVerify.BadPageCount + 1;		   Odi.PutMessage[message: mkIOCmd[word0Bit02], beep: TRUE];		  };	       };	     	  };    };       ENDLOOP; --IF DiagRDTests.Switch[56] THEN Odi.PutData[data: "Current Bad Page Count = "L,  --   numberAfterData: DiagRDErrorCheck.BadPageCount, startWithNewLine: TRUE]; END; --ExecuteCommands        -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to increment/decrement parameters like cylinder/head/sector etc. -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    UpdateParameters: PROCEDURE [parmRcd: ParameterRecord]	RETURNS [newItemsToXfer:		CARDINAL¬ 0,		 newItem1:			CARDINAL¬ 0,		 newItem2:			CARDINAL¬ 0,		 newItem3:			CARDINAL¬ 0,		 newItem4:			CARDINAL¬ 0]  =BEGIN  OPEN parmRcd;  count:	CARDINAL;  items1:	CARDINAL;  items2:	CARDINAL;  items3:	CARDINAL;  items4:	CARDINAL;      IncrItem1: PROCEDURE	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT item1Freeze THEN {     change: CARDINAL¬ item1Change;     UNTIL change< items1 DO	change¬ change-items1;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+item1> maxItem1 THEN {	item1¬ (change+ item1)- items1;	overflow¬ overflow+ 1} ELSE	item1¬ item1+ change};  END;    DecrItem1: PROCEDURE	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT item1Freeze THEN {     change: CARDINAL¬ item1Change;        UNTIL change< items1 DO	   change¬ change-items1;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (item1- minItem1) THEN {	item1¬ (maxItem1+1+(item1- minItem1))- change;	underflow¬ underflow+ 1} ELSE	item1¬ item1- change};  END;	   	     IncrItem2: PROCEDURE [addOverflow: CARDINAL¬ 0]	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT item2Freeze THEN {     change: CARDINAL;     IF addOverflow= 0 THEN	change¬ item2Change ELSE change¬ addOverflow;     UNTIL change< items2 DO	change¬ change-items2;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+item2> maxItem2 THEN {	item2¬ (change+ item2)- items2;	overflow¬ overflow+ 1} ELSE	item2¬ item2+ change};  END;       DecrItem2: PROCEDURE [addUnderflow: CARDINAL¬ 0]	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT item2Freeze THEN {     change: CARDINAL;     IF addUnderflow= 0 THEN	change¬ item2Change ELSE change¬ addUnderflow;        UNTIL change< items2 DO	   change¬ change-items2;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (item2- minItem2) THEN {	item2¬ (maxItem2+1+(item2- minItem2))- change;	underflow¬ underflow+ 1} ELSE	item2¬ item2- change};  END;            IncrItem3: PROCEDURE [addOverflow: CARDINAL¬ 0]	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT item3Freeze THEN {     change: CARDINAL;     IF addOverflow= 0 THEN	change¬ item3Change ELSE change¬ addOverflow;     UNTIL change< items3 DO	change¬ change-items3;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+item3> maxItem3 THEN {	item3¬ (change+ item3)- items3;	overflow¬ overflow+ 1} ELSE	item3¬ item3+ change};  END;	  DecrItem3: PROCEDURE [addUnderflow: CARDINAL¬ 0]	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT item3Freeze THEN {     change: CARDINAL;     IF addUnderflow= 0 THEN	change¬ item3Change ELSE change¬ addUnderflow;        UNTIL change< items3 DO	   change¬ change-items3;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (item3- minItem3) THEN {	item3¬ (maxItem3+1+(item3- minItem3))- change;	underflow¬ underflow+ 1} ELSE	item3¬ item3- change};  END;		  IncrItem4: PROCEDURE [addOverflow: CARDINAL¬ 0]	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT item4Freeze THEN {     change: CARDINAL;     IF addOverflow= 0 THEN	change¬ item4Change ELSE change¬ addOverflow;     UNTIL change< items4 DO	change¬ change-items4;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+item4> maxItem4 THEN {	item4¬ (change+ item4)- items4;	overflow¬ overflow+ 1} ELSE	item4¬ item4+ change};  END;	  DecrItem4: PROCEDURE [addUnderflow: CARDINAL¬ 0]	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT item4Freeze THEN {     change: CARDINAL;     IF addUnderflow= 0 THEN	change¬ item4Change ELSE change¬ addUnderflow;        UNTIL change< items4 DO	   change¬ change-items4;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (item4- minItem4) THEN {	item4¬ (maxItem4+1+(item4- minItem4))- change;	underflow¬ underflow+ 1} ELSE	item4¬ item4- change};  END;      items1¬ (maxItem1- minItem1)+ 1;  items2¬ (maxItem2- minItem2)+ 1;  items3¬ (maxItem3- minItem3)+ 1;  items4¬ (maxItem4- minItem4)+ 1;  IF NOT item1Freeze AND item1Change> 0 THEN {     IF item1Incr THEN {	count¬ IncrItem1 [];	IF count> 0 THEN count¬ IncrItem2 [addOverflow: count];	IF count> 0 THEN count¬ IncrItem3 [addOverflow: count]; 	IF count> 0 THEN count¬ IncrItem4 [addOverflow: count]} ELSE {	   count¬ DecrItem1 [];	   IF count> 0 THEN count¬ DecrItem2 [addUnderflow: count];	   IF count> 0 THEN count¬ DecrItem3 [addUnderflow: count];	   IF count> 0 THEN count¬ DecrItem4 [addUnderflow: count]}};	     IF NOT item2Freeze AND item2Change> 0 THEN {     IF item2Incr THEN {	count¬ IncrItem2 [];	IF count> 0 THEN count¬ IncrItem3 [addOverflow: count];	IF count> 0 THEN count¬ IncrItem4 [addOverflow: count]} ELSE {	   count¬ DecrItem2 [];	   IF count> 0 THEN count¬ DecrItem3 [addUnderflow: count];	   IF count> 0 THEN count¬ DecrItem4 [addUnderflow: count]}};	     IF NOT item3Freeze AND item3Change> 0 THEN {     IF item3Incr THEN {	count¬ IncrItem3 [];	IF count> 0 THEN count¬ IncrItem4 [addOverflow: count]} ELSE {	   count¬ DecrItem3 [];	   IF count> 0 THEN count¬ DecrItem4 [addUnderflow: count]}};    IF NOT item4Freeze AND item4Change> 0 THEN {     IF item4Incr THEN 	count¬ IncrItem4 [] ELSE 	   count¬ DecrItem4 []};    -- transfer changes  newItem1¬ item1;  newItem2¬ item2;  newItem3¬ item3;  newItem4¬ item4;   SELECT FALSE FROM itemsToXferCrossesMaxItem1 => {}; itemsToXferCrossesMaxItem2 => {}; itemsToXferCrossesMaxItem3 => { maxPageCnt:	LONG CARDINAL;   pageCnt:	LONG CARDINAL;   maxPageCnt¬ (maxItem3+1);   maxPageCnt¬ maxPageCnt*(maxItem2+1)*(maxItem1-minItem1+1);   pageCnt¬ item3;   pageCnt¬ (pageCnt*(maxItem2+ 1)*(maxItem1-minItem1+ 1))+     ((item2* (maxItem1-minItem1+ 1))+(item1)+itemsToXfer);   IF pageCnt> maxPageCnt THEN   { pageCnt¬ pageCnt- maxPageCnt;     newItemsToXfer¬ CARDINAL[pageCnt];     newItemsToXfer¬ itemsToXfer- newItemsToXfer   } ELSE newItemsToXfer ¬ itemsToXfer; }; ENDCASE => newItemsToXfer¬ itemsToXfer;	   END; --UpdateParameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- do nothing procedure -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NoOp: PUBLIC PROCEDURE = BEGIN END; --NoOp -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Start loop procedure -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ StartLoop: PUBLIC PROCEDURE = BEGIN firstTimeLoop¬ TRUE; startLoopAt¬ cmdPtr; END; --StartLoop -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- end loop procedure -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EndLoop: PUBLIC PROCEDURE = BEGIN endLoop¬ TRUE; loop¬ TRUE; firstTimeLoop¬ FALSE; END; --EndLoop -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to delay a given amount of time before executing the next command -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   TimeDelay: PUBLIC PROCEDURE =BEGIN Process.Pause [Delay]; END; --TimeDelay -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to set end of the command file -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   SetEndOfFile: PUBLIC PROCEDURE =BEGIN endOfCmdFile¬ TRUE; END; --TimeDelay	    END...	  LOGCreated:  8-Jan-85 16:37:5710-Dec-85 11:55:12, MXT: Commented out DiagFD* stuffs. 1-Sep-87 14:35:47, STC, retry in ConfidenceTest and post all errors.14-Sep-87 15:47:14, STC, use right BadPageCount.	  	  
-- Copyright (C) 1987 Xerox Corporation. All rights reserved.-- File: DiskUtilSelfDescrImpl.mesa	- Last edited:-- STC, 28-Sep-88 12:58:30, Labelless --DIRECTORY  Checksum USING [ComputeChecksum],  Device USING [nullType],  DiskChannel USING [IOStatus, defaultTries, DoDirectIO, GetNextDrive],  DiskChannelInternal USING [DriveObject],  DiskUtilityMiscDove USING [cylinders, dataPages, deviceHandle,  	firstPilotPage, fixedHeads, ForceDriveOffline, labeledOp,	labels,	ManufDskCkOut, InitStarted,	movingHeads, op, pagesPerCylinder, pagesPerTrack, pvHandle,	sectorsPerTrack, StartInit, totalPagesOnADisk, virginDisk],  DiskUtilityMsgKeysDove USING [duMessage],  DiskUtilSelfDescr USING [],  EEpromDefs USING [RigidDiskTypeBits],  FormatPilotDisk USING [DiskInfo],  Inline USING [BITNOT],  OfflineDiagInterface USING [GetYesNo, PutMessage, PutTestParameters,  	userType],  PilotDiskFace	USING [GetDeviceAttributes, unknownAttribute],  PhysicalVolume USING [AssertNotAPilotVolume, Error],  SelfDescribingDisks USING [DiskShape, DiskShapeDescriptorAddress,  	DiskShapeDescriptorPageFormat],  SpecialPilotDiskFace USING [GetDiskShape, SetDiskShape],  SysConfigChannelDefs USING [eePromImage],  SysConfigMsgKeysDove USING [configMsg],  SysConfigRigidDiskDefs USING [arraySize, diskShapeImage,  	GetRigidDiskTypeString, rigidDiskArray],  SysConfigSubDefs USING [ConfigRDDisk];DiskUtilSelfDescrImpl: PROGRAM  IMPORTS Checksum, DiskChannel, DiskUtilityMiscDove, DiskUtilityMsgKeysDove, FormatPilotDisk, Inline, OfflineDiagInterface, PhysicalVolume, PilotDiskFace, SpecialPilotDiskFace, SysConfigChannelDefs, SysConfigMsgKeysDove, SysConfigRigidDiskDefs, SysConfigSubDefs  EXPORTS DiskChannel, DiskUtilSelfDescr =BEGINOPEN DiskUtilityMsgKeysDove, Odi: OfflineDiagInterface,  Misc: DiskUtilityMiscDove, SysDisk: SysConfigRigidDiskDefs;Drive: TYPE = LONG POINTER TO DriveObject;nullDrive: Drive = NIL;DriveObject: PUBLIC TYPE = DiskChannelInternal.DriveObject;VerifyDiskShape: PUBLIC PROC =  BEGIN  ds: SelfDescribingDisks.DiskShape ¬ SpecialPilotDiskFace.GetDiskShape [Misc.deviceHandle];  type: EEpromDefs.RigidDiskTypeBits ¬ none;  IF ds.type # Device.nullType    THEN FOR i: CARDINAL IN [0..SysDisk.arraySize) DO      IF SysDisk.rigidDiskArray[i].type = ds.type THEN {        type ¬ VAL[i+1];	EXIT};      ENDLOOP;  IF type # none THEN {    Odi.PutMessage [SysConfigMsgKeysDove.configMsg[diskType]];    Odi.PutMessage [message: SysDisk.GetRigidDiskTypeString [type], startWithNewLine: FALSE];    IF (OfflineDiagInterface.userType # Manufacturing) THEN    	{IF NOT Odi.GetYesNo[prompt:		 DiskUtilityMsgKeysDove.duMessage[isDiskTypeCorrect]]      	THEN type ¬ none};};  IF type = none THEN ds ¬ GetDiskShapeFromUser [] ELSE    BEGIN     IF ds.rpm = PilotDiskFace.unknownAttribute      THEN ds.rpm ¬ SysDisk.rigidDiskArray[ORD[type]-1].rpm;    ds.vcmDisk ¬ SysDisk.rigidDiskArray[ORD[type]-1].vcmDisk;    END;  SpecialPilotDiskFace.SetDiskShape [Misc.deviceHandle, ds];  IF type = none THEN -- must fix Misc constants    BEGIN    drive: Drive ¬ nullDrive;    DO      drive ¬ DiskChannel.GetNextDrive [drive];      IF drive = nullDrive THEN EXIT;      IF drive.handle = Misc.deviceHandle THEN        BEGIN	drive.diskTypeKnown ¬ FALSE; -- will cause DiskChannel.InspectDriveShape to look at drive again	EXIT	END;    ENDLOOP;    [Misc.firstPilotPage, Misc.totalPagesOnADisk, Misc.pagesPerTrack, Misc.pagesPerCylinder]       ¬ FormatPilotDisk.DiskInfo [Misc.pvHandle];    [Misc.cylinders, Misc.movingHeads, Misc.fixedHeads, Misc.sectorsPerTrack]       ¬ PilotDiskFace.GetDeviceAttributes [Misc.deviceHandle];    END;  END;WriteDiskShapeToDisk: PUBLIC PROC [withinDiskUtil: BOOLEAN]	RETURNS [ioStatus: DiskChannel.IOStatus] =  BEGIN  dsp: LONG POINTER TO SelfDescribingDisks.DiskShapeDescriptorPageFormat;  ds: SelfDescribingDisks.DiskShape;  IF ~withinDiskUtil THEN  	{Misc.ManufDskCkOut ¬ FALSE; -- conditional StartInit  	    IF ~Misc.InitStarted THEN Misc.StartInit [];};  IF Misc.virginDisk THEN RETURN [[disk[headerNotFound]]];  dsp ¬ Misc.dataPages[0];  Misc.ForceDriveOffline [Misc.pvHandle];  PhysicalVolume.AssertNotAPilotVolume [Misc.pvHandle -- Initiate direct access    	 ! PhysicalVolume.Error => IF error = alreadyAsserted THEN CONTINUE ];-- read label, test read data  Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		    command: [verify, read, read],		    device: Misc.deviceHandle,		    clientHeader: SelfDescribingDisks.DiskShapeDescriptorAddress,		    pageCount: 1,		    tries: DiskChannel.defaultTries, 		    labelPtr: Misc.labels[0],		    dataPtr: dsp,		    incrementDataPtr: FALSE];  ioStatus ¬ DiskChannel.DoDirectIO [Misc.op].status;  WITH ioStatus SELECT FROM    disk => IF status # goodCompletion THEN RETURN;    ENDCASE => RETURN;-- build disk shape sector data  ds ¬ SpecialPilotDiskFace.GetDiskShape [Misc.deviceHandle];  dsp­ ¬ [diskShape: ds, checkSum: NULL, invertedCheckSum: NULL];  dsp.checkSum ¬ Checksum.ComputeChecksum [p: dsp, nWords: 254];  dsp.invertedCheckSum ¬ Inline.BITNOT [dsp.checkSum];-- write data  Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		    command: [verify, verify, write],		    device: Misc.deviceHandle,		    clientHeader: SelfDescribingDisks.DiskShapeDescriptorAddress,		    pageCount: 1,		    tries: DiskChannel.defaultTries, 		    labelPtr: Misc.labels[0],		    dataPtr: dsp,		    incrementDataPtr: FALSE];  ioStatus ¬ DiskChannel.DoDirectIO [Misc.op].status;  END;GetDiskShapeFromUser: PROC RETURNS [ds: SelfDescribingDisks.DiskShape] =  BEGIN  type: EEpromDefs.RigidDiskTypeBits;  SysConfigSubDefs.ConfigRDDisk [];  ds ¬ SysConfigRigidDiskDefs.diskShapeImage;  type ¬ SysConfigChannelDefs.eePromImage.RigidDiskType;  Odi.PutTestParameters []; -- clears display  Odi.PutMessage [message: SysConfigMsgKeysDove.configMsg[diskType], clearMessageAreaFirst: TRUE];  Odi.PutMessage [message: SysDisk.GetRigidDiskTypeString [type], startWithNewLine: FALSE];  END;-- main codeEND...  DiskUtilSelfDescrImpl.mesa    LOG4-May-87 -- JPM -- Created8-May-87 -- JPM -- Added code to fix Misc and DiskChannel constants when disk type changes.11-May-87 -- JPM -- Added return code from WriteDiskShapeToDisk12-May-87 -- JPM -- Added prompt msg to user confirmation of disk type14-May-87 -- JPM -- Added call to Misc.ForceDriveOffline before writing disk shape15-May-87 -- JPM -- In WriteDiskShapeToDisk, read label and test read data before write28-May-87 -- JPM -- Replaced temporary string by new duMessage string17-Nov-87 10:18:24 STC, remove GetYesNo for diskType IF Manufacturing17-Dec-87 10:43:09 STC, IF ~withinDiskUtil THEN ManufDskCkOut ¬ FALSE 5-Feb-88 16:37:23 STC, conditional StartInit 8-Feb-88 18:31:31 STC, add DiskUtilityMsgKeysDove in OPEN. 7-Mar-88 15:34:20 STC, add InitializeSpace if ~InitStarted.23-Sep-88 12:43:24 STC, convert to Labelless, use CompatibilityDiskFace.
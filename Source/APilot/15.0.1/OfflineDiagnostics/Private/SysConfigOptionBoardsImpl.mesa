-- File SysConfigOptionBoardsImpl.mesa-- Last edited:	30-Jan-87 12:51:44	RDM Add badMemConfig message & printingScanningOption.--  9-Dec-86  9:50:47	RDM Add EEProm error messages.--  4-Feb-86 10:54:08	by: RRP changes for 12.2--  1-Sep-85 16:48:50	by: AMR-- Created	12-Jul-85		13-Jul-85 11:55:08<<	Copyright (C) 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig, OptionData ],  Inline	        USING [ LowHalf, LowByte ],  OfflineDiagInterface  USING [ OfflineDiagnosticProc,			        AbortCurrentTest,GetYesNo,				OptionsRecord, AnOptionLine, GetAnOptionsRecord,				GetAnOptionLine, GetAnOption,				GetAFixedPositionDisplayRecord, GetARow,				HitAnyKeyToContinue,			        FixedPositionDisplayRecord, ARow, 				DisplayFixedPositionData,			        PutMessage, GetANumber],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, statusPtr],  SysConfigChannelDefs  USING [ eePromImage];    SysConfigOptionBoardsImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs, SysConfigSubDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureOptionBoards:--******************************************************************************ConfigureOptionBoards: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    optionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [2];  optionTable3: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [2];  optionTable2: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [3];  optionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];   optionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];  option2Row0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];   option2Row1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];  option2Row2: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];  option3Row0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];   option3Row1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];  optionConfiguration: SysConfigSubDefs.OptionsValidity;    leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 5;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  selected: CARDINAL;  -- The option selected by the user  tempValue:LONG CARDINAL;  initialEntry: BOOLEAN ¬ TRUE;  information: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [12];    infoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow4: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow5: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow6: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow7: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow8: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow9: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow10: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow11: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row   -- Now construct the ai option table  --  optionTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row  optionTable.linesOfOptions[1] ¬ optionRow1; -- Save pointer to row  optionTable.optionMenuTiTle ¬ msgKey[configOptionBoards];    optionRow0.optionsOnALine[0].position ¬ leftEdge;  optionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  optionRow0.optionsOnALine[0].option ¬ msgKey[setPCOption];    xPosition ¬ leftEdge + msgKey[overrideAllocations].length + 8;  optionRow0.optionsOnALine[1].position ¬ xPosition;  optionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  optionRow0.optionsOnALine[1].option ¬ msgKey[setOtherOption];      optionRow1.optionsOnALine[0].position ¬ leftEdge;  optionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  optionRow1.optionsOnALine[0].option ¬ msgKey[overrideAllocations];  xPosition ¬ leftEdge + msgKey[overrideAllocations].length + 8;  optionRow1.optionsOnALine[1].position ¬ xPosition;  optionRow1.optionsOnALine[1].selectionNumberForThisItem ¬ 4;  optionRow1.optionsOnALine[1].option ¬ msgKey[returnToTopLevel];    -- Now fill in the static fields of the record  information.displayTitle ¬ msgKey[optionBoardHeader];  information.rows[0] ¬ infoRow0;  information.rows[1] ¬ infoRow1;  information.rows[2] ¬ infoRow2;  information.rows[3] ¬ infoRow3;  information.rows[4] ¬ infoRow4;  information.rows[5] ¬ infoRow5;  information.rows[6] ¬ infoRow6;  information.rows[7] ¬ infoRow7;  information.rows[8] ¬ infoRow8;  information.rows[9] ¬ infoRow9;  information.rows[10] ¬ infoRow10;  information.rows[11] ¬ infoRow11;  --  -- Fill in first row static data  infoRow0.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow0.rowItems[0].name ¬ msgKey[PCOptionBoard];  infoRow0.rowItems[0].valuePosition ¬ noNumericData;    tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionBoard]];  infoRow0.rowItems[0].stringValue ¬ IF tempValue = 0  					THEN msgKey[notPresent]					ELSE msgKey[present];  				     -- Fill in second row static data  infoRow1.rowItems[0].namePosition ¬ leftEdge + 3;  -- Name position  infoRow1.rowItems[0].name ¬ msgKey[PCOptionHardware1];  tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionHardware1]];    IF  tempValue = 0 THEN {  	infoRow1.rowItems[0].valuePosition ¬ noNumericData;  	infoRow1.rowItems[0].stringValue ¬ msgKey[none];}  ELSE  {  	infoRow1.rowItems[0].stringValue ¬ NIL;		  	infoRow1.rowItems[0].valuePosition ¬      		leftEdge + 3 + msgKey[PCOptionHardware1].length + aSpace;  	infoRow1.rowItems[0].value ¬  tempValue;};  	  infoRow2.rowItems[0].namePosition ¬ leftEdge + 3;  -- Name position  infoRow2.rowItems[0].name ¬ msgKey[PCOptionHardware2];  tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionHardware2]];  IF tempValue = 0 THEN {  	infoRow2.rowItems[0].valuePosition ¬ noNumericData;  	infoRow2.rowItems[0].stringValue ¬ msgKey[none];}  ELSE {  	infoRow2.rowItems[0].stringValue ¬ NIL;  	infoRow2.rowItems[0].valuePosition ¬      		leftEdge + 3 + msgKey[PCOptionHardware2].length + aSpace;  	infoRow2.rowItems[0].value ¬  tempValue;};	     -- Fill in third row static data  infoRow3.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow3.rowItems[0].name ¬ msgKey[OptionBoardOne];  infoRow3.rowItems[0].valuePosition ¬ noNumericData;  infoRow3.rowItems[0].stringValue ¬     SELECT eePromImage.OptionBoardOne.optionType FROM       none => msgKey[notPresent],       laserPrintingOption => msgKey[laserPrintingOption],       printingScanningOption => msgKey[printingScanningOption],    ENDCASE => NIL;  IF infoRow3.rowItems[0].stringValue = NIL THEN    {infoRow3.rowItems[0].stringValue ¬ msgKey[unknown];     infoRow3.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +       msgKey[OptionBoardOne].length + aSpace;     infoRow3.rowItems[0].value ¬        LONG[LOOPHOLE[eePromImage.OptionBoardOne.optionType]]};      infoRow4.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow4.rowItems[0].name ¬ msgKey[attributes];  infoRow4.rowItems[0].stringValue ¬ NIL;  infoRow4.rowItems[0].valuePosition ¬ leftEdge + msgKey[attributes].length +    aSpace;  infoRow4.rowItems[0].value ¬    LONG[LOOPHOLE[eePromImage.OptionBoardOne.optionSpecificData]];   infoRow5.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow5.rowItems[0].name ¬ msgKey[interruptAllocation];  infoRow5.rowItems[0].stringValue ¬ NIL;  infoRow5.rowItems[0].valuePosition ¬ leftEdge +    msgKey[interruptAllocation].length + aSpace;  infoRow5.rowItems[0].value ¬     LONG[LOOPHOLE[eePromImage.OptionBoardOne.expansionInterruptAllocation]];  -- Fill in fourth row static data  infoRow6.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow6.rowItems[0].name ¬ msgKey[OptionBoardTwo];  infoRow6.rowItems[0].valuePosition ¬ noNumericData;  infoRow6.rowItems[0].stringValue ¬     SELECT eePromImage.OptionBoardTwo.optionType FROM       none => msgKey[notPresent],       laserPrintingOption => msgKey[laserPrintingOption],       printingScanningOption => msgKey[printingScanningOption],    ENDCASE => NIL;  IF infoRow6.rowItems[0].stringValue = NIL THEN    {infoRow6.rowItems[0].stringValue ¬ msgKey[unknown];     infoRow6.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +       msgKey[OptionBoardTwo].length + aSpace;     infoRow6.rowItems[0].value ¬        LONG[LOOPHOLE[eePromImage.OptionBoardTwo.optionType]]};      infoRow7.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow7.rowItems[0].name ¬ msgKey[attributes];  infoRow7.rowItems[0].stringValue ¬ NIL;  infoRow7.rowItems[0].valuePosition ¬      leftEdge + msgKey[attributes].length + aSpace;  infoRow7.rowItems[0].value ¬     LONG[LOOPHOLE[eePromImage.OptionBoardTwo.optionSpecificData]];  infoRow8.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow8.rowItems[0].name ¬ msgKey[interruptAllocation];  infoRow8.rowItems[0].stringValue ¬ NIL;  infoRow8.rowItems[0].valuePosition ¬ leftEdge +    msgKey[interruptAllocation].length + aSpace;  infoRow8.rowItems[0].value ¬     LONG[LOOPHOLE[eePromImage.OptionBoardTwo.expansionInterruptAllocation]];    -- Fill in fifth row static data  infoRow9.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow9.rowItems[0].name ¬ msgKey[OptionBoardThree];  infoRow9.rowItems[0].valuePosition ¬ noNumericData;  infoRow9.rowItems[0].stringValue ¬     SELECT eePromImage.OptionBoardThree.optionType FROM       none => msgKey[notPresent],       laserPrintingOption => msgKey[laserPrintingOption],       printingScanningOption => msgKey[printingScanningOption],    ENDCASE => NIL;  IF infoRow9.rowItems[0].stringValue = NIL THEN    {infoRow9.rowItems[0].stringValue ¬ msgKey[unknown];     infoRow9.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +       msgKey[OptionBoardThree].length + aSpace;     infoRow9.rowItems[0].value ¬        LONG[LOOPHOLE[eePromImage.OptionBoardThree.optionType]]};      infoRow10.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow10.rowItems[0].name ¬ msgKey[attributes];  infoRow10.rowItems[0].stringValue ¬ NIL;  infoRow10.rowItems[0].valuePosition ¬ leftEdge + msgKey[attributes].length +    aSpace;  infoRow10.rowItems[0].value ¬     LONG[LOOPHOLE[eePromImage.OptionBoardThree.optionSpecificData]];  infoRow11.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow11.rowItems[0].name ¬ msgKey[interruptAllocation];  infoRow11.rowItems[0].stringValue ¬ NIL;  infoRow11.rowItems[0].valuePosition ¬ leftEdge +    msgKey[interruptAllocation].length + aSpace;  infoRow11.rowItems[0].value ¬     LONG[LOOPHOLE[eePromImage.OptionBoardThree.expansionInterruptAllocation]];  initialEntry _ TRUE;  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN _ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue _ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until exit is requested           initialEntry _ FALSE;    [] ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: optionTable,	optionPrompt: msgKey[blanks], justDisplayTable:TRUE]; -- Change screen or Exit    Odi.DisplayFixedPositionData [  -- Display the information	 displayData: information, upDateOnly: FALSE];          selected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable:  NIL,      optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit        IF selected = 4 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested  Odi.PutMessage [msgKey[dataSpaceBar]];  [] ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: NIL,	optionPrompt: msgKey[blanks], justDisplayTable:TRUE]; -- erase option prompt  IF selected = 1 THEN {  -- Get PC info		    IF [] ¬ Odi.GetYesNo [prompt:msgKey[askPCOptionBoard]] THEN  {       eePromImage.PCOptionBoard ¬ Inline.LowByte[1];       infoRow0.rowItems[0].stringValue ¬ msgKey[present];       Odi.DisplayFixedPositionData [displayData:information,				     upDateOnly: TRUE];  -- Update       infoRow1.rowItems[0].valuePosition ¬  	    leftEdge + 3 + msgKey[PCOptionHardware1].length + aSpace;       infoRow1.rowItems[0].value ¬ Odi.GetANumber [	    prompt: msgKey[getPCAttributes1],	    lowLimit: 0,	    upperLimit: 0FFH,	    numberIsLong: TRUE,	    defaultNumber: 0].longNumber;       Odi.DisplayFixedPositionData [displayData:information,				     upDateOnly: TRUE];  -- display Update       eePromImage.PCOptionHardware1 ¬ Inline.LowByte[Inline.LowHalf[infoRow1.rowItems[0].value]];              infoRow2.rowItems[0].valuePosition ¬  	    leftEdge + 3 + msgKey[PCOptionHardware1].length + aSpace;       infoRow2.rowItems[0].value ¬ Odi.GetANumber [	    prompt: msgKey[getPCAttributes2],	    lowLimit: 0,	    upperLimit: 0FFFFH,	    numberIsLong: TRUE,	    defaultNumber: 0].longNumber;       Odi.DisplayFixedPositionData [displayData:information,				     upDateOnly: TRUE];  -- display Update       eePromImage.PCOptionHardware2 ¬ Inline.LowHalf[infoRow2.rowItems[0].value]}        ELSE  {	    eePromImage.PCOptionBoard ¬ Inline.LowHalf[0];	    eePromImage.PCOptionHardware1 ¬ 0;	    eePromImage.PCOptionHardware2 ¬ 0;	    infoRow0.rowItems[0].stringValue ¬ msgKey[notPresent];	    infoRow1.rowItems[0].valuePosition ¬ noNumericData;	    infoRow1.rowItems[0].stringValue ¬ msgKey[none];	    infoRow2.rowItems[0].valuePosition ¬ noNumericData;	    infoRow2.rowItems[0].stringValue ¬ msgKey[none];	    Odi.DisplayFixedPositionData [displayData:information,					  upDateOnly: TRUE];  -- display Update	    };   };  -- For option 1    IF selected = 2 THEN    BEGIN    GetOptionBoardInfo: PROCEDURE[currentSettings: EEpromDefs.OptionData,			 prompt: LONG STRING ¬ NIL]	RETURNS [optionBoardInfo: EEpromDefs.OptionData] =    BEGIN      selected: CARDINAL;      [] _ Odi.GetAnOption [	 optionTable: optionTable2,	 optionPrompt: msgKey[blanks], justDisplayTable:TRUE];      Odi.DisplayFixedPositionData [	displayData: information, upDateOnly: FALSE];      selected ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: NIL,	optionPrompt: prompt,	defaultOption: IF SysConfigControlDefs.statusPtr­ = checkSumError		   THEN 5 --"defaultConfiguration"--		   ELSE 6 --"doNotChange"--];      [] ¬ Odi.GetAnOption [optionTable: NIL, optionPrompt: msgKey[blanks],	justDisplayTable:TRUE,  -- erase option prompt	defaultOption: 0];        optionBoardInfo.optionType ¬ SELECT selected FROM	1 => laserPrintingOption,	2 => printingScanningOption,	3,5 => none,	4 => LOOPHOLE[Inline.LowByte[Inline.LowHalf[Odi.GetANumber [	      prompt: msgKey[newOption],	      lowLimit: 0,	      upperLimit: 01FH,	      numberIsLong: TRUE,	      defaultNumber:		LONG[LOOPHOLE[currentSettings.optionType]]].longNumber]]],	6 => currentSettings.optionType,      ENDCASE => LOOPHOLE[15];      [] _ Odi.GetAnOption [	 optionTable: optionTable3,	 optionPrompt: msgKey[blanks], justDisplayTable:TRUE];      Odi.DisplayFixedPositionData [	displayData: information, upDateOnly: FALSE];      selected ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: NIL,	optionPrompt: prompt, 	defaultOption: IF SysConfigControlDefs.statusPtr­ = checkSumError		   THEN 2 --defaultConfiguration--		   ELSE 3 --doNotChange-- ];      [] ¬ Odi.GetAnOption [optionTable:  NIL, optionPrompt: msgKey[blanks],	justDisplayTable:TRUE, -- erase option prompt	defaultOption: 0];        optionBoardInfo.optionSpecificData ¬ SELECT selected FROM	1 => LOOPHOLE[Inline.LowByte[Inline.LowHalf[Odi.GetANumber [	  prompt: msgKey[newAttributes],	  lowLimit: 0,	  upperLimit: 07H,	  numberIsLong: TRUE,	  defaultNumber:	    LONG[LOOPHOLE[currentSettings.optionSpecificData]]].longNumber]]],	2,3 => currentSettings.optionSpecificData,      ENDCASE => LOOPHOLE[15];      RETURN[optionBoardInfo];    END; --GetOptionBoardInfo   -- Now construct the type option tables   --    optionTable2.optionMenuTiTle ¬ msgKey[optionTypes];    optionTable2.linesOfOptions[0] ¬ option2Row0; -- Save pointer to row    optionTable2.linesOfOptions[1] ¬ option2Row1; -- Save pointer to row    optionTable2.linesOfOptions[2] ¬ option2Row2; -- Save pointer to row    option2Row0.optionsOnALine[0].position ¬ leftEdge;    option2Row0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;    option2Row0.optionsOnALine[0].option ¬ msgKey[laserPrintingOption];    xPosition ¬ leftEdge + msgKey[newOption].length + 5;    option2Row0.optionsOnALine[1].position ¬ xPosition;    option2Row0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;    option2Row0.optionsOnALine[1].option ¬ msgKey[printingScanningOption];    option2Row1.optionsOnALine[0].position ¬ leftEdge;    option2Row1.optionsOnALine[0].selectionNumberForThisItem ¬ 3;    option2Row1.optionsOnALine[0].option ¬ msgKey[notPresent];    option2Row1.optionsOnALine[1].position ¬ xPosition;    option2Row1.optionsOnALine[1].selectionNumberForThisItem ¬ 4;    option2Row1.optionsOnALine[1].option ¬ msgKey[newOption];    option2Row2.optionsOnALine[0].position ¬ leftEdge;    option2Row2.optionsOnALine[0].selectionNumberForThisItem ¬ 5;    option2Row2.optionsOnALine[0].option ¬ msgKey[defaultConfiguration];    option2Row2.optionsOnALine[1].position ¬ xPosition;    option2Row2.optionsOnALine[1].selectionNumberForThisItem ¬ 6;    option2Row2.optionsOnALine[1].option ¬ msgKey[doNotChange];    optionTable3.optionMenuTiTle ¬ msgKey[attributes];    optionTable3.linesOfOptions[0] ¬ option3Row0; -- Save pointer to row    optionTable3.linesOfOptions[1] ¬ option3Row1; -- Save pointer to row    option3Row0.optionsOnALine[0].position ¬ leftEdge;    option3Row0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;    option3Row0.optionsOnALine[0].option ¬ msgKey[newAttributes];    xPosition ¬ leftEdge + msgKey[newAttributes].length + 5;    option3Row0.optionsOnALine[1].position ¬ xPosition;    option3Row0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;    option3Row0.optionsOnALine[1].option ¬ msgKey[defaultConfiguration];    option3Row1.optionsOnALine[0].position ¬ leftEdge;    option3Row1.optionsOnALine[0].selectionNumberForThisItem ¬ 3;    option3Row1.optionsOnALine[0].option ¬ msgKey[doNotChange];    -- Get OptionBoard1 info    eePromImage.OptionBoardOne ¬      GetOptionBoardInfo[eePromImage.OptionBoardOne, msgKey[OptionBoardOne]];    infoRow3.rowItems[0].valuePosition ¬ noNumericData;    infoRow3.rowItems[0].stringValue ¬       SELECT eePromImage.OptionBoardOne.optionType FROM	none => msgKey[notPresent],	laserPrintingOption => msgKey[laserPrintingOption],	printingScanningOption => msgKey[printingScanningOption],      ENDCASE => NIL;    IF infoRow3.rowItems[0].stringValue = NIL THEN      {infoRow3.rowItems[0].stringValue ¬ msgKey[unknown];       infoRow3.rowItems[0].valuePosition ¬ leftEdge +	 msgKey[unknown].length + msgKey[OptionBoardOne].length + aSpace;       infoRow3.rowItems[0].value ¬	 LONG[LOOPHOLE[eePromImage.OptionBoardOne.optionType]]};        infoRow4.rowItems[0].value ¬      LONG[LOOPHOLE[eePromImage.OptionBoardOne.optionSpecificData]];     Odi.DisplayFixedPositionData [displayData:information,				 upDateOnly: TRUE];  -- Update            -- Get OptionBoard2 info    eePromImage.OptionBoardTwo ¬      GetOptionBoardInfo[eePromImage.OptionBoardTwo, msgKey[OptionBoardTwo]];    infoRow6.rowItems[0].valuePosition ¬ noNumericData;    infoRow6.rowItems[0].stringValue ¬       SELECT eePromImage.OptionBoardTwo.optionType FROM	none => msgKey[notPresent],	laserPrintingOption => msgKey[laserPrintingOption],	printingScanningOption => msgKey[printingScanningOption],      ENDCASE => NIL;    IF infoRow6.rowItems[0].stringValue = NIL THEN      {infoRow6.rowItems[0].stringValue ¬ msgKey[unknown];       infoRow6.rowItems[0].valuePosition ¬ leftEdge +	 msgKey[unknown].length + msgKey[OptionBoardTwo].length + aSpace;       infoRow6.rowItems[0].value ¬	 LONG[LOOPHOLE[eePromImage.OptionBoardTwo.optionType]]};        infoRow7.rowItems[0].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardTwo.optionSpecificData]];    Odi.DisplayFixedPositionData [displayData:information,				 upDateOnly: TRUE];  -- Update	     -- Get OptionBoard3 info    eePromImage.OptionBoardThree ¬      GetOptionBoardInfo[eePromImage.OptionBoardThree,msgKey[OptionBoardThree]];    infoRow9.rowItems[0].valuePosition ¬ noNumericData;    infoRow9.rowItems[0].stringValue ¬       SELECT eePromImage.OptionBoardThree.optionType FROM	none => msgKey[notPresent],	laserPrintingOption => msgKey[laserPrintingOption],	printingScanningOption => msgKey[printingScanningOption],      ENDCASE => NIL;    IF infoRow9.rowItems[0].stringValue = NIL THEN      {infoRow9.rowItems[0].stringValue ¬ msgKey[unknown];       infoRow9.rowItems[0].valuePosition ¬ leftEdge +	 msgKey[unknown].length + msgKey[OptionBoardThree].length + aSpace;       infoRow9.rowItems[0].value ¬	 LONG[LOOPHOLE[eePromImage.OptionBoardThree.optionType]]};        infoRow10.rowItems[0].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardThree.optionSpecificData]];    Odi.DisplayFixedPositionData [displayData:information,				    upDateOnly: TRUE];  -- Update    optionConfiguration ¬ SysConfigSubDefs.AllocateExpansionInterrupts[];    infoRow5.rowItems[0].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardOne.expansionInterruptAllocation]];    infoRow8.rowItems[0].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardTwo.expansionInterruptAllocation]];    infoRow11.rowItems[0].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardThree.expansionInterruptAllocation]];    Odi.DisplayFixedPositionData [displayData:information,				    upDateOnly: TRUE];  -- Update    SELECT optionConfiguration FROM      tooManyOptions => {Odi.PutMessage [			   message: msgKey[tooManyOptionsWarning],			   clearMessageAreaFirst:TRUE];			 Odi.HitAnyKeyToContinue[]};      invalidConfiguration => {Odi.PutMessage [				 message: msgKey[invalidConfigurationWarning],				 clearMessageAreaFirst:TRUE];			       Odi.HitAnyKeyToContinue[]};    ENDCASE; END; IF selected = 3 THEN    BEGIN      eePromImage.OptionBoardOne.expansionInterruptAllocation ¬	LOOPHOLE[Inline.LowByte[Inline.LowHalf[Odi.GetANumber [	  prompt: msgKey[expansionInterruptsForOptionBoardOne],	  lowLimit: 0,	  upperLimit: 0FFH,	  numberIsLong: TRUE,	  defaultNumber:       LONG[LOOPHOLE[eePromImage.OptionBoardOne.expansionInterruptAllocation]]].	 longNumber]]];      infoRow5.rowItems[0].value ¬ 	LONG[LOOPHOLE[eePromImage.OptionBoardOne.expansionInterruptAllocation]];      Odi.DisplayFixedPositionData [displayData:information,				    upDateOnly: TRUE];  -- Update      eePromImage.OptionBoardTwo.expansionInterruptAllocation ¬	LOOPHOLE[Inline.LowByte[Inline.LowHalf[Odi.GetANumber [	  prompt: msgKey[expansionInterruptsForOptionBoardTwo],	  lowLimit: 0,	  upperLimit: 0FFH,	  numberIsLong: TRUE,	  defaultNumber:       LONG[LOOPHOLE[eePromImage.OptionBoardTwo.expansionInterruptAllocation]]].	 longNumber]]];      infoRow8.rowItems[0].value ¬ 	LONG[LOOPHOLE[eePromImage.OptionBoardTwo.expansionInterruptAllocation]];      Odi.DisplayFixedPositionData [displayData:information,				    upDateOnly: TRUE];  -- Update      eePromImage.OptionBoardThree.expansionInterruptAllocation ¬	LOOPHOLE[Inline.LowByte[Inline.LowHalf[Odi.GetANumber [	  prompt: msgKey[expansionInterruptsForOptionBoardThree],	  lowLimit: 0,	  upperLimit: 0FFH,	  numberIsLong: TRUE,	  defaultNumber:     LONG[LOOPHOLE[eePromImage.OptionBoardThree.expansionInterruptAllocation]]].       longNumber]]];     infoRow11.rowItems[0].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardThree.expansionInterruptAllocation]];     Odi.DisplayFixedPositionData [displayData:information,				    upDateOnly: TRUE];  -- Update    END;       ENDLOOP; -- Outer loop  END;  -- ConfigureAIBoardEND.logcreated on 11-Jul-85 10:54:28 by AMR
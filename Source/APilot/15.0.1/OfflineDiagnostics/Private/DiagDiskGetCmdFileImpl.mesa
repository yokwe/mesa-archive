-- File: DiagDiskGetCmdFileImpl.mesa - last edit:-- MXT                 10-Dec-85 13:11:48-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: DiagDiskGetCmdFileImpl.mesa----  DIRECTORY DiagDiskMkIOCmd	USING	[mkIOCmd], DiagDiskMkMisc		USING	[mkMisc], DiagDiskCmdDrive	USING	[MinUnit, MaxUnit, MinCylinder, MaxCylinder,				 MinHead, MaxHead, MinSector, MaxSector,				 MaxTryCount, MinTryCount,				 MinSectorCount, MaxSectorCount,				 CmdDescriptionArray--, Floppy, Rigid--], --DiagFDTests		USING	[Switch], --DiagRDTests		USING	[Switch], Inline			USING	[LowHalf, HighHalf], OfflineDiagTTYDove	USING	[rightEdge], OfflineDiagInterface	USING	[AnOptionLine, GetANumber, GetAnOption,				 GetAnOptionLine, GetAnOptionsRecord,				 GetYesNo, --HitAnyKeyToContinue,				 OptionsRecord, PutData, PutMessage,				 GetAHelpText, HelpText], String			USING	[AppendChar, AppendNumber, AppendString], DiagDiskGetCmdFile	USING	[];				 				   DiagDiskGetCmdFileImpl:  PROGRAM     IMPORTS	DiagDiskMkIOCmd,	DiagDiskMkMisc,	DiagDiskCmdDrive,	--DiagFDTests,	--DiagRDTests,	Inline,	OfflineDiagTTYDove,	OfflineDiagInterface,	String    EXPORTS	DiagDiskGetCmdFile  = BEGIN     OPEN	DiagDiskMkMisc,	DiagDiskMkIOCmd,	Cd: DiagDiskCmdDrive,	Odi: OfflineDiagInterface;				  -- holds the final command string CommandArrayPtr:	PUBLIC CARDINAL; CommandArray:		PUBLIC ARRAY [0..255] OF CARDINAL¬ ALL[0]; tempStr:		LONG STRING¬ [256];				  NeedLabelData:		BOOLEAN¬ FALSE; inCmdChain:		BOOLEAN; NeedsLabelOpr:		BOOLEAN; NeedsDataOpr:		BOOLEAN; StartedLogging:	BOOLEAN; StartedTracing:	BOOLEAN; InLoop:		BOOLEAN;   endOfCommandFile:	BOOLEAN; GotAParameter:		BOOLEAN; StatusToDisplay:	BOOLEAN; VerifyLabel:		BOOLEAN; VerifyData:		BOOLEAN;  singleBuff:		BOOLEAN; maxReadBuffs:		CARDINAL¬ 2;         -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- puts the seclected command into the command array  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    DecipherCommand: PROCEDURE [index: CARDINAL]  = BEGIN    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  UpdateArrayAndDisplay: PROCEDURE [index: CARDINAL]  = BEGIN  CommandArray [CommandArrayPtr]¬ index;  CommandArrayPtr¬ CommandArrayPtr+ 1;  Odi.PutData [data: Cd.CmdDescriptionArray[index].commandName,	       startWithNewLine: FALSE];  END; --UpdateArrayAndDisplay -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- First check for all the error conditions -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- incorrect choice of command IF NOT inCmdChain    AND (Cd.CmdDescriptionArray[index].setNeedsDataOpr --label operation         OR  Cd.CmdDescriptionArray[index].getParamsCmd --data operation--) THEN   { Odi.PutMessage [message: mkIOCmd[needHeaderOperation],    		     beep: TRUE,    		     clearMessageAreaFirst: TRUE];     RETURN   }; IF NeedsLabelOpr   AND NOT Cd.CmdDescriptionArray[index].setNeedsDataOpr THEN   { Odi.PutMessage [message: mkIOCmd[needLabelOperation],    		     beep: TRUE,    		     clearMessageAreaFirst: TRUE];     RETURN   }; IF NeedsDataOpr   AND NOT Cd.CmdDescriptionArray[index].getParamsCmd THEN   { Odi.PutMessage [message: mkIOCmd[needDataOperation],    		     beep: TRUE,    		     clearMessageAreaFirst: TRUE];     RETURN   };   -- check for error logging command errors IF Cd.CmdDescriptionArray[index].setStartLogging AND StartedLogging THEN   { Odi.PutMessage [message: mkIOCmd[allreadyLoggingErrs],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   }; IF Cd.CmdDescriptionArray[index].resetStartLogging AND NOT StartedLogging THEN   { Odi.PutMessage [message: mkIOCmd[notLoggingErrs],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   }; -- check for tracing command errors IF Cd.CmdDescriptionArray[index].setTracing AND StartedTracing THEN   { Odi.PutMessage [message: mkIOCmd[allreadyTracingCmds],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   }; IF Cd.CmdDescriptionArray[index].resetTracing AND NOT StartedTracing THEN   { Odi.PutMessage [message: mkIOCmd[notTracingCmds],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   };     -- check for looping errors IF Cd.CmdDescriptionArray[index].setLooping AND InLoop THEN   { Odi.PutMessage [message: mkIOCmd[allreadyInLoop],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   }; IF Cd.CmdDescriptionArray[index].resetLooping AND NOT InLoop THEN   { Odi.PutMessage [message: mkIOCmd[notLooping],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   };     -- check for end of command file errors IF Cd.CmdDescriptionArray[index].setEndOfCommandFile AND InLoop THEN   { Odi.PutMessage [message: mkIOCmd[notAllowedInLoop],		     beep: TRUE,		     clearMessageAreaFirst: TRUE];     RETURN   }; --now set/reset desired booleans -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   IF Cd.CmdDescriptionArray[index].setStartOfCmdChain THEN inCmdChain¬ TRUE; IF Cd.CmdDescriptionArray[index].getParamsCmd THEN inCmdChain¬ FALSE;  IF Cd.CmdDescriptionArray[index].setNeedsLabelOpr THEN NeedsLabelOpr¬ TRUE   ELSE NeedsLabelOpr¬ FALSE; IF Cd.CmdDescriptionArray[index].setNeedsDataOpr THEN NeedsDataOpr¬ TRUE   ELSE NeedsDataOpr¬ FALSE; IF Cd.CmdDescriptionArray[index].setStartLogging THEN StartedLogging¬ TRUE; IF Cd.CmdDescriptionArray[index].resetStartLogging THEN StartedLogging¬ FALSE; IF Cd.CmdDescriptionArray[index].setTracing THEN StartedTracing¬ TRUE; IF Cd.CmdDescriptionArray[index].resetTracing THEN StartedTracing¬ FALSE; IF Cd.CmdDescriptionArray[index].setLooping THEN InLoop¬ TRUE; IF Cd.CmdDescriptionArray[index].resetLooping THEN InLoop¬ FALSE; IF Cd.CmdDescriptionArray[index].setEndOfCommandFile THEN endOfCommandFile¬ TRUE; -- now update the command array and the display with the command UpdateArrayAndDisplay [index: index]; -- now get the required parameters IF Cd.CmdDescriptionArray[index].needLoopCount		THEN GetLoopCount []; IF Cd.CmdDescriptionArray[index].needDelay		THEN GetDelay []; IF Cd.CmdDescriptionArray[index].needRecalFirst	THEN GetIfRecalFirst []; IF Cd.CmdDescriptionArray[index].needUseSameDataBuff	THEN GetIfUseSameDataBuff []; IF Cd.CmdDescriptionArray[index].needTryCount	THEN GetTryCount [];  IF Cd.CmdDescriptionArray[index].needUnit		THEN GetUnit [];  IF Cd.CmdDescriptionArray[index].needCylinder		THEN GetCylinder []; IF Cd.CmdDescriptionArray[index].needHead		THEN GetHead []; IF Cd.CmdDescriptionArray[index].needSector		THEN GetSector []; IF Cd.CmdDescriptionArray[index].needSectorCount	THEN GetSectorCount []; IF Cd.CmdDescriptionArray[index].needTrackCount	THEN GetTrackCount []; IF NeedLabelData AND Cd.CmdDescriptionArray[index].getParamsCmd THEN { GetLabelData []; NeedLabelData¬ FALSE; }; IF Cd.CmdDescriptionArray[index].needLabelData	THEN NeedLabelData¬ TRUE; IF Cd.CmdDescriptionArray[index].needData		THEN GetData []; IF GotAParameter THEN { tempStr.length¬ 0;   String.AppendChar[tempStr, 10C]; --delete the space after the comma   String.AppendChar[tempStr, 10C]; --delete the comma   String.AppendString[tempStr, mkIOCmd[paramEnd]]; --append "];"   Odi.PutData[data: tempStr]; --output the string   GotAParameter¬ FALSE; }; END; --DecipherCommand   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- display all the commands in the Command File -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   DisplayCommandOptions: PROCEDURE RETURNS [LONG POINTER TO Odi.OptionsRecord]    = BEGIN cmdArrayLength:	CARDINAL¬ LENGTH[Cd.CmdDescriptionArray]; cmdStringLength:	CARDINAL; numberOfLines:		CARDINAL; count:			CARDINAL; lineCount:		CARDINAL; columns:		CARDINAL; optionsPerLine:	CARDINAL; cmdRcrdPtr:		LONG POINTER TO Odi.OptionsRecord; optionLinePtr:		LONG POINTER TO Odi.AnOptionLine; selectionNumber:	CARDINAL;  --first get the longest command name and calculate the columns of commands cmdStringLength¬ 0; count¬ 1; --bypass the NoOp command UNTIL count= cmdArrayLength DO   IF Cd.CmdDescriptionArray[count].commandName.length > cmdStringLength THEN     cmdStringLength¬ Cd.CmdDescriptionArray[count].commandName.length;   count¬ count + 1; ENDLOOP; cmdStringLength¬ cmdStringLength + 6; -- add the selection number columns¬ OfflineDiagTTYDove.rightEdge/cmdStringLength; --now calculate the number of lines numberOfLines¬ (cmdArrayLength- 1)/columns; IF cmdArrayLength- 1 MOD columns> 0 THEN   numberOfLines¬ numberOfLines + 1; cmdRcrdPtr¬  Odi.GetAnOptionsRecord[numberOfLines: numberOfLines]; cmdRcrdPtr.optionMenuTiTle¬ mkIOCmd[commandS];  lineCount¬ 0; UNTIL lineCount= numberOfLines DO      --set up options per line   optionsPerLine¬ 0;   UNTIL optionsPerLine= columns DO     IF (lineCount+1)+(optionsPerLine*numberOfLines)>     	cmdArrayLength- 1 THEN EXIT;      optionsPerLine¬ optionsPerLine + 1;   ENDLOOP;         optionLinePtr ¬ Odi.GetAnOptionLine [optionsPerLine: optionsPerLine];   cmdRcrdPtr.linesOfOptions[lineCount] ¬ optionLinePtr;   count¬ 0;   UNTIL count= optionsPerLine DO     selectionNumber¬ (count*numberOfLines)+(lineCount);      optionLinePtr.optionsOnALine[count].position ¬ count*cmdStringLength + 1;     optionLinePtr.optionsOnALine[count].selectionNumberForThisItem¬	selectionNumber+ 1;     optionLinePtr.optionsOnALine[count].option¬	Cd.CmdDescriptionArray[selectionNumber+ 1].commandName;     optionLinePtr.optionsOnALine[count].helpForThisOption¬     	Cd.CmdDescriptionArray[selectionNumber+ 1].explanation;     count¬ count + 1;   ENDLOOP;   lineCount¬ lineCount + 1; ENDLOOP; RETURN [cmdRcrdPtr] END; --DisplayCommandOptions  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to get the Command File -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetCommandFile: PUBLIC PROCEDURE   = BEGIN helpPtr:		LONG POINTER TO Odi.HelpText; num:			CARDINAL; cmdRcrdPtr:		LONG POINTER TO Odi.OptionsRecord;	 CommandArrayPtr	¬ 0; CommandArray		¬ ALL[0]; endOfCommandFile	¬ FALSE; GotAParameter		¬ FALSE; inCmdChain		¬ FALSE; NeedLabelData		¬ FALSE; StartedLogging		¬ FALSE; InLoop			¬ FALSE; StartedTracing		¬ FALSE; StatusToDisplay	¬ FALSE; NeedsDataOpr		¬ FALSE; NeedsLabelOpr		¬ FALSE; VerifyLabel		¬ FALSE; VerifyData		¬ FALSE;      helpPtr¬ Odi.GetAHelpText[numberOfLines: 1]; helpPtr.textBody [0] ¬ mkMisc[enterChoiceNumExpl];  cmdRcrdPtr¬ DisplayCommandOptions[];  UNTIL endOfCommandFile DO   -- get the command number   num ¬ Odi.GetAnOption [optionTable: cmdRcrdPtr,    			  optionPrompt: mkIOCmd[command],			  optionHelp: helpPtr];   DecipherCommand [index: num];   cmdRcrdPtr¬ NIL; ENDLOOP;  -- display the entered command file «IF Cd.Rigid AND DiagRDTests.Switch[21]   --OR  Cd.Floppy AND DiagFDTests.Switch[21]-- THEN { index:	CARDINAL¬ 0;   cnt:		CARDINAL¬ 0;   UNTIL Cd.CmdDescriptionArray[index].setEndOfCommandFile=TRUE DO     index¬index+1;   ENDLOOP;   tempStr.length¬ 0;   String.AppendString[tempStr, "["];   UNTIL CommandArray[cnt]=index DO     String.AppendNumber[tempStr, CommandArray[cnt]];     String.AppendString[tempStr, ","];     cnt¬cnt+1;   ENDLOOP;   String.AppendNumber[tempStr, CommandArray[cnt]];   String.AppendString[tempStr, "]"];   Odi.PutMessage[message: tempStr, 		  clearMessageAreaFirst: TRUE];   Odi.HitAnyKeyToContinue[]; };»  END; --GetCmdFile		  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the cylinder including the +/-count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		  GetCylinder: PROCEDURE = BEGIN helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; pOrMHelpTextPtr:	LONG POINTER TO Odi.HelpText				¬ Odi.GetAHelpText[numberOfLines: 1]; tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[cylindersExpl]]; String.AppendNumber[tempStr, Cd.MinCylinder]; String.AppendString[tempStr, mkMisc[to]]; String.AppendNumber[tempStr, Cd.MaxCylinder]; helpTextPtr.textBody[0]¬ tempStr;  pOrMHelpTextPtr.textBody[0]¬ mkIOCmd[cylindersPMExpl]; GetParameter [	prompt:			mkIOCmd[cylinder],	minNumber:		Cd.MinCylinder,	maxNumber:		Cd.MaxCylinder,	explanation:		helpTextPtr,	getPlusOrMinus:		TRUE,	plusOrMinusExpl:	pOrMHelpTextPtr];	 END; --GetCylinder -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the hexadecimal data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetData: PROCEDURE = BEGIN helpTextPtr:	LONG POINTER TO Odi.HelpText;  helpTextPtr  ¬ Odi.GetAHelpText[numberOfLines: 1]; helpTextPtr.textBody[0]¬ mkIOCmd[hexDataExpl];    GetParameter [	prompt:			mkIOCmd[hexData],	minNumber:		0,	maxNumber:		65535,	dataInHex:		TRUE,	explanation:		helpTextPtr];	  END; --GetData  	 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the time delay count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	 GetDelay: PROCEDURE = BEGIN helpTextPtr:	LONG POINTER TO Odi.HelpText;  helpTextPtr  ¬ Odi.GetAHelpText[numberOfLines: 1]; helpTextPtr.textBody[0]¬ mkIOCmd[timeIncrementEquals]; GetParameter [	prompt:			mkIOCmd[delayCnt],	minNumber:		1,	maxNumber:		65535,	explanation:		helpTextPtr];  END; --GetDelay -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the head plus the +/-count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		  GetHead: PROCEDURE = BEGIN helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; pOrMHelpTextPtr:	LONG POINTER TO Odi.HelpText				¬ Odi.GetAHelpText[numberOfLines: 1];  tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[headExpl]]; String.AppendNumber[tempStr, Cd.MinHead]; String.AppendString[tempStr, mkMisc[to]]; String.AppendNumber[tempStr, Cd.MaxHead]; helpTextPtr.textBody[0]¬ tempStr;  pOrMHelpTextPtr.textBody[0]¬ mkIOCmd[headPMExpl];		   GetParameter [	prompt:			mkIOCmd[head],	minNumber:		Cd.MinHead,	maxNumber:		Cd.MaxHead,	explanation:		helpTextPtr,	getPlusOrMinus:		TRUE,	plusOrMinusExpl:	pOrMHelpTextPtr];	 END; --GetHead -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets wether to recalibrate first  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		  GetIfRecalFirst: PROCEDURE = BEGIN yes: BOOLEAN;  yes¬ Odi.GetYesNo[prompt: mkIOCmd[recalFirstYN]]; -- diplay the entered number Odi.PutData [data: mkIOCmd[recalFirst]]; IF yes THEN Odi.PutData [data: DiagDiskMkMisc.mkMisc[yes]] ELSE   Odi.PutData [data: DiagDiskMkMisc.mkMisc[no]]; Odi.PutData [data: mkIOCmd[paramSeparator]]; --update command array IF yes THEN CommandArray [CommandArrayPtr]¬ 1 ELSE    CommandArray [CommandArrayPtr]¬ 0; CommandArrayPtr¬ CommandArrayPtr+ 1;  GotAParameter¬ TRUE;  END; --GetIfRecalFirst -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets wether to recalibrate first  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		  GetIfUseSameDataBuff: PROCEDURE = BEGIN yes: BOOLEAN;  yes¬ Odi.GetYesNo[prompt: mkIOCmd[useSameDataBuffYN]];  -- diplay the entered number Odi.PutData [data: mkIOCmd[useSameDataBuff]]; IF yes THEN { Odi.PutData [data: DiagDiskMkMisc.mkMisc[yes]];   singleBuff¬ TRUE; } ELSE { Odi.PutData [data: DiagDiskMkMisc.mkMisc[no]];   singleBuff¬ FALSE; }; Odi.PutData [data: mkIOCmd[paramSeparator]]; --update command array  IF yes THEN CommandArray [CommandArrayPtr]¬ 1 ELSE    CommandArray [CommandArrayPtr]¬ 0; CommandArrayPtr¬ CommandArrayPtr+ 1;  GotAParameter¬ TRUE; END; --GetIfUseSameDataBuff      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- gets the sector plus the +/-count   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetSector: PROCEDURE = BEGIN helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; pOrMHelpTextPtr:	LONG POINTER TO Odi.HelpText				¬ Odi.GetAHelpText[numberOfLines: 1];  tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[sectorExpl]]; String.AppendNumber[tempStr, Cd.MinSector]; String.AppendString[tempStr, mkMisc[to]]; String.AppendNumber[tempStr, Cd.MaxSector]; helpTextPtr.textBody[0]¬ tempStr;  pOrMHelpTextPtr.textBody[0]¬ mkIOCmd[sectorPMExpl]; GetParameter [	prompt:			mkIOCmd[sector],	minNumber:		Cd.MinSector,	maxNumber:		Cd.MaxSector,	explanation:		helpTextPtr,	getPlusOrMinus:		TRUE,	plusOrMinusExpl:	pOrMHelpTextPtr];	 END; --GetSector   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the label data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetLabelData: PROCEDURE = BEGIN helpTextPtr:	LONG POINTER TO Odi.HelpText;  helpTextPtr  ¬ Odi.GetAHelpText[numberOfLines: 1]; helpTextPtr.textBody[0]¬ mkIOCmd[hexDataExpl]; GetParameter [	prompt:			mkIOCmd[hexLabelData],	minNumber:		0,	maxNumber:		65535,	dataInHex:		TRUE,	explanation:		helpTextPtr]; END; --GetLabelData	  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- gets the loop count   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetLoopCount: PROCEDURE	= BEGIN str:		LONG STRING¬ [20]; helpTextPtr:	LONG POINTER TO Odi.HelpText; num:		LONG CARDINAL;  helpTextPtr  ¬ Odi.GetAHelpText[numberOfLines: 1]; helpTextPtr.textBody[0]¬ mkIOCmd[loopCntExpl]; str.length¬ 0; [longNumber: num, number: , foreward: , numberInStringFormat: str]¬  Odi.GetANumber [	prompt:		mkIOCmd[loopCnt],	lowLimit:	1,	upperLimit:	1000000000,	help:		helpTextPtr,	numberIsLong:	TRUE]; -- diplay the entered number Odi.PutData [data: mkIOCmd[loopCnt]]; Odi.PutData [data: str];	 -- update command array CommandArray [CommandArrayPtr]¬ Inline.HighHalf[num]; CommandArrayPtr¬ CommandArrayPtr+ 1; CommandArray [CommandArrayPtr]¬ Inline.LowHalf[num]; CommandArrayPtr¬ CommandArrayPtr+ 1; Odi.PutData[data: mkIOCmd[paramSeparator]]; GotAParameter¬ TRUE;  -- GetParameter [--	prompt:			mkIOCmd[loopCnt],--	minNumber:		1,--	maxNumber:		LAST[LONG CARDINAL],--	explanation:		helpTextPtr,--	getPlusOrMinus:		FALSE];	 END; --GetLoopCount -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the sector count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetSectorCount: PROCEDURE = BEGIN sectorCnt:		CARDINAL; helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[sectorCntExpl]]; String.AppendNumber[tempStr, Cd.MinSectorCount]; String.AppendString[tempStr, mkMisc[to]]; IF singleBuff THEN   String.AppendNumber[tempStr, Cd.MaxSectorCount] ELSE     String.AppendNumber[tempStr, maxReadBuffs]; helpTextPtr.textBody[0]¬ tempStr; IF singleBuff THEN   sectorCnt¬ Cd.MaxSectorCount ELSE     sectorCnt¬ maxReadBuffs; GetParameter [	prompt:			mkIOCmd[sectorCnt],	minNumber:		Cd.MinSectorCount,	maxNumber:		sectorCnt,	explanation:		helpTextPtr];	 END; --GetSectorCount -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the track count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetTrackCount: PROCEDURE = BEGIN trackCnt:		CARDINAL; helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[trackCntExpl]]; String.AppendNumber[tempStr, 1]; String.AppendString[tempStr, mkMisc[to]]; trackCnt¬ (Cd.MaxCylinder+1)*(Cd.MaxHead+1); String.AppendNumber[tempStr, trackCnt]; helpTextPtr.textBody[0]¬ tempStr; GetParameter[	prompt:			mkIOCmd[trackCnt],	minNumber:		Cd.MinSectorCount,	maxNumber:		trackCnt,	explanation:		helpTextPtr];	 END; --GetTrackCount -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the Try count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetTryCount: PROCEDURE = BEGIN helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[tryCntExpl]]; String.AppendNumber[tempStr, Cd.MinTryCount]; String.AppendString[tempStr, mkMisc[to]]; String.AppendNumber[tempStr, Cd.MaxTryCount]; helpTextPtr.textBody[0]¬ tempStr;   GetParameter [	prompt:			mkIOCmd[tryCnt],	minNumber:		Cd.MinTryCount,	maxNumber:		Cd.MaxTryCount,	explanation:		helpTextPtr];	 END; --GetTryCount  		  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- gets the unit+/-count   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		 GetUnit: PROCEDURE = BEGIN helpTextPtr:		LONG POINTER TO Odi.HelpText 				 ¬ Odi.GetAHelpText[numberOfLines: 1]; pOrMHelpTextPtr:	LONG POINTER TO Odi.HelpText				¬ Odi.GetAHelpText[numberOfLines: 1];   tempStr.length¬ 0; String.AppendString[tempStr, mkIOCmd[unitExpl]]; String.AppendNumber[tempStr, Cd.MinUnit]; String.AppendString[tempStr, mkMisc[to]]; String.AppendNumber[tempStr, Cd.MaxUnit]; helpTextPtr.textBody[0]¬ tempStr;  pOrMHelpTextPtr.textBody[0]¬ mkIOCmd[unitPMExpl]; GetParameter [	prompt:			mkIOCmd[unit],	minNumber:		Cd.MinUnit,	maxNumber:		Cd.MaxUnit,	explanation:		helpTextPtr,  	getPlusOrMinus:		TRUE,	plusOrMinusExpl:	pOrMHelpTextPtr];   END; --GetUnit  	 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the head+/-count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		  GetParameter: PROCEDURE [      prompt:		LONG STRING¬ NIL,      dataInHex:	BOOLEAN¬ FALSE,      numWithin:	BOOLEAN¬ TRUE,      minNumber:	CARDINAL¬ 0,      maxNumber:	CARDINAL¬ LAST[CARDINAL],      explanation:	LONG POINTER TO Odi.HelpText ¬ NIL,      getPlusOrMinus:	BOOLEAN¬ FALSE,      plusOrMinusExpl:	LONG POINTER TO Odi.HelpText ¬ NIL,      minModifier:	CARDINAL¬ 0,      maxModifier:	CARDINAL¬ 65535]	 =BEGIN str:		LONG STRING¬ [20]; num:		CARDINAL; plus:		BOOLEAN;     str.length¬ 0; [longNumber: , number: num, foreward: , numberInStringFormat: str]¬   Odi.GetANumber [       prompt:			prompt,       numberIsHexadecimal:	dataInHex,       lowLimit:		minNumber,       upperLimit:		maxNumber,       help:			explanation];    -- diplay the entered number Odi.PutData [data: prompt]; Odi.PutData [data: str];	 -- update command array CommandArray [CommandArrayPtr]¬ num; CommandArrayPtr¬ CommandArrayPtr+ 1;     --get the +or- head number IF InLoop AND getPlusOrMinus THEN { str.length¬ 0;   [longNumber: , number: num, foreward: plus, numberInStringFormat: str]¬      Odi.GetANumber [         prompt:	mkIOCmd[plusOrMinus],         lowLimit:	minModifier,         upperLimit:	maxModifier,         help:		plusOrMinusExpl];     -- display the entered number including plus of minus   IF plus THEN Odi.PutData[data: mkIOCmd[plus]] ELSE     Odi.PutData[data: mkIOCmd[minus]];   Odi.PutData [data: str];        -- update command array    IF plus THEN CommandArray [CommandArrayPtr]¬ 1 ELSE      CommandArray [CommandArrayPtr]¬ 0;    CommandArrayPtr¬ CommandArrayPtr+ 1;    CommandArray [CommandArrayPtr]¬ num;    CommandArrayPtr¬ CommandArrayPtr+ 1; };        Odi.PutData[data: mkIOCmd[paramSeparator]]; GotAParameter¬ TRUE; END; --GetParameter  END...   16-Jan-85 18:29:32 Added GetTrackCount: PROC 10-Dec-85 11:56:37	MXT: Commented out DiagRD*    
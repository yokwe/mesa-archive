-- SysConfigChannelImpl.mesa  -Last edited:-- STC	 2-Oct-88 14:35:36, convert to Labelless.-- KXW	17-Feb-87 14:27:32	Avoide multiple calling of Initialize.-- RDM	 6-Feb-87 12:00:24	Fix daisy 4meg memory configuration.-- RDM	 2-Feb-87 13:04:28	Change VERSION to Version in ProcessorFaceExtras.-- RDM	30-Jan-87 14:47:45	Add CheckMemoryConfig.-- edited:	17-Oct-85 13:41:56	by: AMR-- edited:	  12-Sep-85  9:34:15	by: AMR-- edited:	 7-Aug-85  9:55:46	by: AMR-- edited: 6-Aug-85 16:39:24	by: JPM-- Created	15-May-85 10:07:38	by: AMR<<	Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  Checksum USING [ ComputeChecksum],  DoveInputOutput USING [ ByteSwap ],  EEpromDefs USING [ EEpromConfig ],  Inline USING [ BITNOT ],--  ProcessorFaceExtras	USING [Version, VersionResult],  ProcessorFaceExtras2	USING [DoveMachineType, DoveMachineTypeInfo],  SpecialRuntime USING [AllocateNakedCondition],  SysConfigFace USING [UpStatusCndt, eePromImage,				sysConfigUpDoneFlag, upStatus,  				Initialize, ReadEEprom,				WriteEEpromEntry],  SysConfigChannelDefs USING [Status];  SysConfigChannelImpl: MONITOR  IMPORTS Checksum, DoveInputOutput, Inline, --  ProcessorFaceExtras,   ProcessorFaceExtras2,   SysConfigFace, SpecialRuntime  EXPORTS SysConfigChannelDefs =  BEGIN     init: BOOLEAN _ FALSE;  upStatusIO: SysConfigFace.UpStatusCndt;  wakeUpMask: WORD;  wakeUpConditionPtr: LONG POINTER TO CONDITION;    tempChecksum: CARDINAL;  tempInvertedChecksum:WORD;       checkSumOverride: PUBLIC BOOLEAN _ FALSE;    eePromImageArray: ARRAY [0..64) OF WORD;  eePromImageCopyArray: ARRAY [0..64) OF WORD;  eePromImage: PUBLIC LONG POINTER TO EEpromDefs.EEpromConfig _ LOOPHOLE[LONG[@eePromImageArray]];  eePromPointer: PUBLIC LONG POINTER TO ARRAY [0..64) OF WORD _ @eePromImageArray;  eePromImageCopy: PUBLIC LONG POINTER TO EEpromDefs.EEpromConfig _ LOOPHOLE[LONG[@eePromImageCopyArray]];      WriteEEPromImage: PUBLIC ENTRY PROC RETURNS [ SysConfigChannelDefs.Status] =    BEGIN    memStatusOK: BOOLEAN _ TRUE;    IF checkSumOverride = FALSE THEN         BEGIN	 eePromImageArray[62] _ Checksum.ComputeChecksum[, 62, eePromPointer];	 eePromImageArray[63]  _ Inline.BITNOT[eePromImageArray[62]];	 END;    FOR i:CARDINAL IN [0..64)      DO      eePromImageCopyArray[i] _ eePromImageArray[i];      SysConfigFace.eePromImage[i] _ DoveInputOutput.ByteSwap[eePromImageArray[i]];      SysConfigFace.WriteEEpromEntry[i];      	DO	WAIT wakeUpConditionPtr^;	IF SysConfigFace.sysConfigUpDoneFlag^ = done THEN EXIT;	ENDLOOP;		upStatusIO _	  DoveInputOutput.ByteSwap[SysConfigFace.upStatus^];		SELECT upStatusIO FROM	  eePromError => RETURN[eePromError];	  badCommand => RETURN[badCommand];	  success => NULL;	  ENDCASE => RETURN[unKnown];      ENDLOOP;    memStatusOK _ CheckMemoryConfig[];    IF memStatusOK THEN { RETURN[success]; }    ELSE { RETURN[badMemConfig]; };    END;       ReadEEPromImage: PUBLIC ENTRY PROC RETURNS [status:SysConfigChannelDefs.Status] =    BEGIN     memStatusOK: BOOLEAN _ TRUE;    SysConfigFace.ReadEEprom;    	DO	WAIT wakeUpConditionPtr^;	IF SysConfigFace.sysConfigUpDoneFlag^ = done  THEN EXIT;	ENDLOOP;        upStatusIO _       DoveInputOutput.ByteSwap[SysConfigFace.upStatus^];    SELECT upStatusIO FROM	success => {  FOR i:CARDINAL IN [0..64)			DO			eePromImageArray[i] _ DoveInputOutput.ByteSwap[SysConfigFace.eePromImage[i]];			eePromImageCopyArray[i] _ eePromImageArray[i];			ENDLOOP;		  tempChecksum _ Checksum.ComputeChecksum[, 62, eePromPointer];		  tempInvertedChecksum  _ Inline.BITNOT[tempChecksum];		  memStatusOK _ CheckMemoryConfig[];		  IF memStatusOK THEN 		    BEGIN		    IF tempChecksum # eePromImageArray[62] OR tempInvertedChecksum # eePromImageArray[63]		      THEN	{ RETURN [checkSumError ]; }		    ELSE	{ RETURN [success]; }		    END		  ELSE 		{ RETURN[badMemConfig]; }};	eePromError =>  RETURN[eePromError];	badCommand => RETURN[badCommand];	ENDCASE => RETURN[unKnown];    END;    Initialize: PUBLIC ENTRY PROC =    BEGIN    IF init = TRUE THEN RETURN;    [wakeUpConditionPtr, wakeUpMask] _ SpecialRuntime.AllocateNakedCondition [];    SysConfigFace.Initialize [wakeUpMask];    init _ TRUE;    END;    CheckMemoryConfig: PUBLIC PROCEDURE RETURNS [configOk: BOOLEAN] =    BEGIN--    version: ProcessorFaceExtras.VersionResult _ ProcessorFaceExtras.Version[];    machineType: ProcessorFaceExtras2.DoveMachineType ¬ ProcessorFaceExtras2.DoveMachineTypeInfo[];--    SELECT version.machineType FROM    SELECT machineType FROM      daisy =>	 {        -- if MainMemoryExpansion = mega3 in a daisy, 	-- it could have 3.5 or 4.0 megabytes total.        couldBe4Meg: BOOLEAN _ eePromImage.MainMemoryExpansion = mega3;        IF eePromImage.MainMemory0 # present OR	  eePromImage.MainMemory1 # present OR	  eePromImage.MainMemory2 # present OR	  eePromImage.MainMemory3 # present OR	  eePromImage.MainMemory4 # present OR	  eePromImage.MainMemory5 # present OR	  eePromImage.MainMemory6 # present OR	  eePromImage.MainMemory7 # present THEN { RETURN[FALSE] }	ELSE IF couldBe4Meg AND	  eePromImage.MainMemory8 = present AND	  eePromImage.MainMemory9 = present AND	  eePromImage.MainMemory10 = present AND	  eePromImage.MainMemory11 = present AND	  eePromImage.MainMemory12 = present AND	  eePromImage.MainMemory13 = present AND	  eePromImage.MainMemory14 = present AND	  eePromImage.MainMemory15 = present THEN { RETURN[TRUE] }	ELSE IF eePromImage.MainMemory8 = notPresent AND	  eePromImage.MainMemory9 = notPresent AND	  eePromImage.MainMemory10 = notPresent AND	  eePromImage.MainMemory11 = notPresent AND	  eePromImage.MainMemory12 = notPresent AND	  eePromImage.MainMemory13 = notPresent AND	  eePromImage.MainMemory14 = notPresent AND	  eePromImage.MainMemory15 = notPresent THEN { RETURN[TRUE] }	ELSE { RETURN[FALSE] }};      duke, diana => {        IF eePromImage.MainMemory0 = present AND	  eePromImage.MainMemory1 = present AND	  eePromImage.MainMemory2 = present AND	  eePromImage.MainMemory3 = present AND	  eePromImage.MainMemory4 = present AND	  eePromImage.MainMemory5 = present AND	  eePromImage.MainMemory6 = present AND	  eePromImage.MainMemory7 = present AND	  eePromImage.MainMemory8 = present AND	  eePromImage.MainMemory9 = present AND	  eePromImage.MainMemory10 = present AND	  eePromImage.MainMemory11 = present AND	  eePromImage.MainMemory12 = present AND	  eePromImage.MainMemory13 = present AND	  eePromImage.MainMemory14 = present AND	  eePromImage.MainMemory15 = present THEN { RETURN[TRUE] }	ELSE { RETURN [FALSE] }}      ENDCASE => {        IF eePromImage.MainMemory0 = present AND	  eePromImage.MainMemory1 = present AND	  eePromImage.MainMemory2 = notPresent AND	  eePromImage.MainMemory3 = notPresent AND	  eePromImage.MainMemory4 = notPresent AND	  eePromImage.MainMemory5 = notPresent AND	  eePromImage.MainMemory6 = notPresent AND	  eePromImage.MainMemory7 = notPresent AND	  eePromImage.MainMemory8 = present AND	  eePromImage.MainMemory9 = present AND	  eePromImage.MainMemory10 = present AND	  eePromImage.MainMemory11 = present AND	  eePromImage.MainMemory12 = present AND	  eePromImage.MainMemory13 = present AND	  eePromImage.MainMemory14 = present AND	  eePromImage.MainMemory15 = present THEN { RETURN[TRUE] }	ELSE { RETURN [FALSE] }}    END;	-- of CheckMemoryConfig.  END.
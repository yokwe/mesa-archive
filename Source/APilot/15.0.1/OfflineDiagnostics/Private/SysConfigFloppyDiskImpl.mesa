-- File SysConfigFloppyDiskImpl.mesa-- Last edited:--  1-Feb-88  9:10:37	STC	Add fad5000 in FloppyTypes, change Headings.-- 5-Jan-87 10:57:26	RDM	Add badMemConfig message.--  9-Dec-86  9:20:19	RDM Add EEprom error messages.-- 29-Jan-86 18:06:26	by: RRP changes for 12.2-- 			 1-Oct-85 15:25:17	by: AMR-- Created		18-Jun-85 14:57:42	by: AMR<<	Copyright(C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig, FloppyDiskTypeBits ],  Inline		USING [ LowHalf, LowByte ],  OfflineDiagInterface  USING [ AbortCurrentTest, AnOptionLine, ARow,				DisplayFixedPositionData,			        FixedPositionDisplayRecord, 				GetAnOptionsRecord,				GetAnOptionLine, GetAnOption,				GetAFixedPositionDisplayRecord, GetARow,				GetANumber, GetYesNo,  				OfflineDiagnosticProc, OptionsRecord,			        PutMessage],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, statusPtr],  SysConfigChannelDefs  USING [ eePromImage];    SysConfigFloppyDiskImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureFloppyDisk:--******************************************************************************ConfigureFloppyDisk: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN  -- Disk types supported. Whenever new types are encountered, simply add   DiskTypes: TYPE = {none, diskA, diskB, newDiskType}; -- is this being used?  -- Disk Drives supported. kb360, kb1200, fad500  -- This option table presents the various disk types to the user for selection.  --   numberOfDiskTypes: CARDINAL = ORD[LAST[DiskTypes]] + 1;  optionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [3];  -- Three row of option here  optionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [3]; -- was 2, STC  optionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];  optionRow2: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2];    --  -- This fixed-position display record holds the drive information as being  -- displayed at the top of the data area. The rest of the data area still can  -- be used to print normal data (PutData still retains its full power)  --  information: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [4];  -- 2 single-itemed rows of data    infoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  infoRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row    leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 12;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  selected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN ¬ TRUE;  GetFloppySize: PROCEDURE[currentSize: EEpromDefs.FloppyDiskTypeBits,  			   prompt: LONG STRING ¬ NIL]      RETURNS [diskTypeSelected: EEpromDefs.FloppyDiskTypeBits] =    BEGIN    [] ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: IF initialEntry THEN optionTable ELSE NIL,	optionPrompt: msgKey[blanks], justDisplayTable:TRUE];    Odi.DisplayFixedPositionData [  -- Display the information	 displayData: information, upDateOnly: FALSE];    selected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL,      optionPrompt: prompt, 	defaultOption: IF SysConfigControlDefs.statusPtr­ = checkSumError		   THEN 6 --defaultConfiguration--		   ELSE 7 --doNotChange-- ]; -- Example default    [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable:  NIL,      optionPrompt: msgKey[blanks], justDisplayTable:TRUE,  -- erase option prompt        defaultOption: 0];        IF initialEntry THEN         Odi.DisplayFixedPositionData [  -- Display the drive information         displayData: information, upDateOnly: FALSE];	     initialEntry ¬ FALSE;        -- Update fixed-position display record. selected is always valid    diskTypeSelected ¬ SELECT selected FROM  	1,6 => kb360,	2 => kb1200,	3 => fad5000,        4 => none,	5 => LOOPHOLE[Inline.LowByte[Inline.LowHalf[Odi.GetANumber [       	  prompt: msgKey[newDisk],	  lowLimit: 0,	  upperLimit: 0FH,	  numberIsLong: TRUE,	  defaultNumber: LONG[LOOPHOLE[currentSize]]].longNumber]]],	7 => currentSize,	ENDCASE => LOOPHOLE[15];        END; --GetFloppySize  -- Fill in the information record fields  information.displayTitle ¬ msgKey[generalFixedInfoTitle];  information.rows[0] ¬ infoRow0;  -- First row  information.rows[1] ¬ infoRow1;  -- Second row  information.rows[2] ¬ infoRow2;  -- First row  information.rows[3] ¬ infoRow3;  -- Second row    -- Now fill in the static fields of the display record  --  -- Fill in first row static data  infoRow0.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow0.rowItems[0].name ¬ msgKey[driveZero];  infoRow0.rowItems[0].valuePosition ¬ noNumericData;    infoRow1.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow1.rowItems[0].name ¬ msgKey[driveOne];  infoRow1.rowItems[0].valuePosition ¬ noNumericData;    infoRow2.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow2.rowItems[0].name ¬ msgKey[driveTwo];  infoRow2.rowItems[0].valuePosition ¬ noNumericData;    infoRow3.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow3.rowItems[0].name ¬ msgKey[driveThree];  infoRow3.rowItems[0].valuePosition ¬ noNumericData;      -- Now construct the type option table  --  optionTable.optionMenuTiTle ¬ msgKey[configFloppyDisk];  optionTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row  optionTable.linesOfOptions[1] ¬ optionRow1; -- Save pointer to row  optionTable.linesOfOptions[2] ¬ optionRow2; -- Save pointer to row    optionRow0.optionsOnALine[0].position ¬ leftEdge;  optionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  optionRow0.optionsOnALine[0].option ¬ msgKey[kb360];    xPosition ¬ leftEdge + msgKey[defaultConfiguration].length + 8;  optionRow0.optionsOnALine[1].position ¬ xPosition;  optionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  optionRow0.optionsOnALine[1].option ¬ msgKey[kb1200];    xPosition ¬ leftEdge + (msgKey[defaultConfiguration].length + 8)*2;  optionRow0.optionsOnALine[2].position ¬ xPosition;  optionRow0.optionsOnALine[2].selectionNumberForThisItem ¬ 3;  optionRow0.optionsOnALine[2].option ¬ msgKey[fad5000];    optionRow1.optionsOnALine[0].position ¬ leftEdge;  optionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 4;  optionRow1.optionsOnALine[0].option ¬ msgKey[notPresent];    xPosition ¬ leftEdge + msgKey[defaultConfiguration].length + 8;  optionRow1.optionsOnALine[1].position ¬ xPosition;  optionRow1.optionsOnALine[1].selectionNumberForThisItem ¬ 5;  optionRow1.optionsOnALine[1].option ¬ msgKey[newDisk];  optionRow2.optionsOnALine[0].position ¬ leftEdge;  optionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 6;  optionRow2.optionsOnALine[0].option ¬ msgKey[defaultConfiguration];  xPosition ¬ leftEdge + msgKey[defaultConfiguration].length + 8;  optionRow2.optionsOnALine[1].position ¬ xPosition;  optionRow2.optionsOnALine[1].selectionNumberForThisItem ¬ 7;  optionRow2.optionsOnALine[1].option ¬ msgKey[doNotChange];  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN ¬ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue _ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  IF initialEntry THEN {    infoRow0.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive0      FROM        none => msgKey[none],  	kb360 => msgKey[kb360],	kb1200 => msgKey[kb1200],	fad5000 => msgKey[fad5000]	ENDCASE => NIL;	    IF infoRow0.rowItems[0].stringValue = NIL THEN    	{infoRow0.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow0.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length + 	   msgKey[driveZero].length + aSpace;	 infoRow0.rowItems[0].value ¬	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive0]]; };        infoRow1.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive1       FROM        none => msgKey[none],  	kb360 => msgKey[kb360],	kb1200 => msgKey[kb1200],	fad5000 => msgKey[fad5000]	ENDCASE => NIL;	    IF infoRow1.rowItems[0].stringValue = NIL THEN    	{infoRow1.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow1.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +	   aSpace;	 infoRow1.rowItems[0].value ¬	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive1]]; };        infoRow2.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive2       FROM        none => msgKey[none],  	kb360 => msgKey[kb360],	kb1200 => msgKey[kb1200],	fad5000 => msgKey[fad5000]	ENDCASE => NIL;	    IF infoRow2.rowItems[0].stringValue = NIL THEN    	{infoRow2.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow2.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +	   aSpace;	 infoRow2.rowItems[0].value ¬	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive2]]; };        infoRow3.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive3       FROM        none => msgKey[none],  	kb360 => msgKey[kb360],	kb1200 => msgKey[kb1200],	fad5000 => msgKey[fad5000]	ENDCASE => NIL;	    IF infoRow3.rowItems[0].stringValue = NIL THEN    	{infoRow3.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow3.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +	   aSpace;	 infoRow3.rowItems[0].value ¬ 	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive3]]; };  };                    -- Get floppyDiskTypeByte info                eePromImage.FloppyDiskTypeDrive0 ¬     GetFloppySize[currentSize: eePromImage.FloppyDiskTypeDrive0,		  prompt: msgKey[forDriveZero]];  infoRow0.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive0        FROM          none => msgKey[none],  	  kb360 => msgKey[kb360],	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]	  ENDCASE => NIL;  IF infoRow0.rowItems[0].stringValue = NIL THEN         {infoRow0.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow0.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length + 	   msgKey[driveZero].length + aSpace;	 infoRow0.rowItems[0].value ¬ 	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive0]]; };  Odi.DisplayFixedPositionData [  -- Display the drive information           displayData: information, upDateOnly: TRUE];  eePromImage.FloppyDiskTypeDrive1 ¬     GetFloppySize[currentSize: eePromImage.FloppyDiskTypeDrive1,		   prompt: msgKey[forDriveOne]];  infoRow1.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive1      FROM          none => msgKey[none],  	  kb360 => msgKey[kb360],	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]	  ENDCASE => NIL;	  IF infoRow1.rowItems[0].stringValue = NIL THEN        {infoRow1.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow1.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +            msgKey[driveOne].length + aSpace;	 infoRow1.rowItems[0].value ¬	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive1]]; };  Odi.DisplayFixedPositionData [  -- Display the drive information           displayData: information, upDateOnly: TRUE];         eePromImage.FloppyDiskTypeDrive2 ¬      GetFloppySize[currentSize: eePromImage.FloppyDiskTypeDrive2,		   prompt: msgKey[forDriveTwo]];  infoRow2.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive2       FROM          none => msgKey[none],  	  kb360 => msgKey[kb360],	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]	  ENDCASE => NIL;      	  IF infoRow2.rowItems[0].stringValue = NIL THEN    	{infoRow2.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow2.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +            msgKey[driveTwo].length + aSpace;	 infoRow2.rowItems[0].value ¬	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive2]]; };  Odi.DisplayFixedPositionData [  -- Display the drive information           displayData: information, upDateOnly: TRUE];	   eePromImage.FloppyDiskTypeDrive3 ¬     GetFloppySize[currentSize: eePromImage.FloppyDiskTypeDrive3,		   prompt: msgKey[forDriveThree]];  infoRow3.rowItems[0].stringValue ¬ SELECT eePromImage.FloppyDiskTypeDrive3       FROM          none => msgKey[none],  	  kb360 => msgKey[kb360],	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]	  ENDCASE => NIL;  IF infoRow3.rowItems[0].stringValue = NIL THEN    	{infoRow3.rowItems[0].stringValue ¬ msgKey[unknown];	 infoRow3.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +            msgKey[driveThree].length + aSpace;	 infoRow3.rowItems[0].value ¬	   LONG[LOOPHOLE[eePromImage.FloppyDiskTypeDrive3]]; };  Odi.DisplayFixedPositionData [  -- Display the drive information           displayData: information, upDateOnly: TRUE];         END;  -- ConfigureFloppyDiskEND.logcreated on 18-Jun-85 14:57:42 by Allen Roberts
-- File SysConfigEEPromImpl.mesa-- Last edited:	-- TXM	12-Oct-89 18:45:32  add copying to eePromImageCopy in ReadEEProm-- TXM	 6-Oct-89 17:04:34  change Unknown DiskType to SysConfigRigidDiskDefs.rigidDisks-- TXM	19-May-89 20:12:10  change Unknown DiskType to 36 in ReadEEProm-- STC	10-Nov-88 12:51:45  fix bug in write incorrect DiskType the first time-- STC	11-Mar-88  9:34:27  move StartInit front of DO loop-- STC	 5-Feb-88 16:38:55  StartInit before display menu of WriteEEPromImage-- STC	16-Oct-87 17:34:46  convert to 14.0  -- JPM	28-May-87 12:27:11   Replace temporary string with new msgKey1 string-- JPM	12-May-87 15:47:59   Read/write self-describing disk shape when reading/writing EEPROM.-- RDM	 6-Feb-87 14:49:47	result ¬ passed even if bad memory configuration.-- RDM	30-Jan-87 15:00:26   Add badMemConfig message.-- RDM	 9-Dec-86 10:36:53   Add beep upon Checksum fault, & explicitly set result indicator..-- RRP  14-May-86 16:27:03 -- RRP  21-Mar-86 12:42:09	-- RRP  2-Feb-86 14:03:08  changes for 12.2-- edited:	15-Oct-85 15:30:24	by: AMR-- Edited:	29-Aug-85 17:11:38	by: MR-- edited:	27-Sep-85 14:04:40	by: AMR-- Created	18-Jun-85 15:06:41	by: AMR<<	Copyright (C) 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  Device		USING [ nullType ],  DeviceTypes		USING [anyPilotDisk],  DiskChannel		USING [ IOStatus ],  DiskUtilSelfDescr	USING [ WriteDiskShapeToDisk ],  Checksum		USING [ ComputeChecksum ],  EEpromDefs	        USING [ EEpromConfig, VersionNumberROM,  				VersionNumberRAM,  				VersionNumberBadPages, VMSizeBits ],  Inline	        USING [ LowHalf, BITNOT ],  DiskUtilityMiscDove   USING [ InitStarted, StartInit],  OfflineDiagInterface  USING [ OfflineDiagnosticProc,			        AbortCurrentTest,				OptionsRecord, AnOptionLine,				GetAnOptionsRecord,				GetAnOptionLine, GetAnOption, GetYesNo,				GetAFixedPositionDisplayRecord, GetARow,				HitAnyKeyToContinue,			        FixedPositionDisplayRecord, ARow, 				DisplayFixedPositionData,				PutTestParameters,			        PutMessage, GetANumber],  PilotDiskFace		USING [ DeviceHandle, GetNextDevice, nullDeviceHandle ],  SpecialPilotDiskFace	USING [ GetDiskShape, SetDiskShape ],  SysConfigEEPromDefs	USING [],  SysConfigRigidDiskDefs USING [ arraySize, diskShapeImage, rigidDiskArray,				 rigidDisks ],  SysConfigChannelDefs  USING [ CheckMemoryConfig, WriteEEPromImage,				ReadEEPromImage, checkSumOverride, eePromImage,				eePromImageCopy, eePromPointer, Status ],  SysConfigSubDefs USING [ShowAllEEprom, ComputeMinumumVMSize],  SysConfigControlDefs  USING [ msgKey, msgKey1, NumberToHex, statusPtr];      SysConfigEEPromImpl: PROGRAM	IMPORTS Checksum, DiskUtilSelfDescr, Inline,	DiskUtilityMiscDove, OfflineDiagInterface,	PilotDiskFace, SpecialPilotDiskFace,SysConfigControlDefs,	SysConfigChannelDefs, SysConfigRigidDiskDefs, SysConfigSubDefs			EXPORTS SysConfigEEPromDefs, SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- Update EEPROM--******************************************************************************WriteEEPromImage: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN  -- Output the current IORegion configuration for the entire EEProm  --  --  -- Get confirmation before actually updating  writeOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [1];  -- Just one row of option here  writeOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2]; -- Extra option is for EXIT  <<writeOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1]; >>  --      leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 5;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  writeOptionSelected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN ¬ TRUE;  <<versionBoolean: BOOLEAN;  unusedBoolean: BOOLEAN; >>  computedVMSize: EEpromDefs.VMSizeBits;  status: SysConfigChannelDefs.Status ¬ success;  memStatusOK: BOOLEAN ¬ TRUE;  continue: BOOLEAN ¬ TRUE;    result ¬ none;  writeOptionTable.linesOfOptions[0] ¬ writeOptionRow0; -- Save pointer to row  <<writeOptionTable.linesOfOptions[1] ¬ writeOptionRow1; -- Save pointer to row>>  writeOptionTable.optionMenuTiTle ¬ msgKey[writeEEPromImage];    writeOptionRow0.optionsOnALine[0].position ¬ leftEdge;  writeOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  writeOptionRow0.optionsOnALine[0].option ¬ msgKey1[writeEEPromConfirm];    <<xPosition ¬ leftEdge + msgKey1[writeEEPromConfirm].length + 8;  -- %Change  writeOptionRow0.optionsOnALine[1].position ¬ xPosition;  writeOptionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  writeOptionRow0.optionsOnALine[1].option ¬ msgKey1[overRideConfirm];    writeOptionRow1.optionsOnALine[0].position ¬ leftEdge;  writeOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  writeOptionRow1.optionsOnALine[0].option ¬ msgKey[returnToTopLevel]; >>    xPosition ¬ leftEdge + msgKey1[writeEEPromConfirm].length + 8;  -- %Change  writeOptionRow0.optionsOnALine[1].position ¬ xPosition;  writeOptionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  writeOptionRow0.optionsOnALine[1].option ¬ msgKey[returnToTopLevel];    IF ~DiskUtilityMiscDove.InitStarted THEN -- STC  	DiskUtilityMiscDove.StartInit [];  -- STC  DO    <<versionBoolean ¬ FALSE;  unusedBoolean ¬ FALSE;  SysConfigChannelDefs.checkSumOverride ¬ FALSE; >>    IF initialEntry THEN  {    [] ¬ Odi.GetAnOption [  -- Always returns a valid option        optionTable: writeOptionTable,        optionPrompt: msgKey[blanks], justDisplayTable:TRUE]; -- Change screen or Exit	    Odi.PutMessage [msgKey1[question1WriteEEProm]];   };      writeOptionSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL,      optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit              initialEntry ¬ FALSE;  IF writeOptionSelected = 2 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested   << IF writeOptionSelected = 2  	THEN {	[] ¬ Odi.GetAnOption [optionTable: NIL,			optionPrompt: msgKey[blanks], 			justDisplayTable:TRUE]; -- erase option prompt before go to next question					IF Odi.GetYesNo [prompt: msgKey1[versionNumberOverride], defaultSpecified: TRUE, default: FALSE] THEN versionBoolean ¬ TRUE;		IF Odi.GetYesNo [prompt: msgKey1[unusedNumberOverride], defaultSpecified: TRUE, default: FALSE] THEN unusedBoolean ¬ TRUE;		IF Odi.GetYesNo [prompt: msgKey1[checksumOverride], defaultSpecified: TRUE, default: FALSE] THEN SysConfigChannelDefs.checkSumOverride ¬ TRUE; }; >>    memStatusOK ¬ SysConfigChannelDefs.CheckMemoryConfig[];  IF ~memStatusOK THEN {    Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];    continue ¬ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  computedVMSize ¬ SysConfigSubDefs.ComputeMinumumVMSize[];  IF computedVMSize > eePromImage.VMMSizeInPages THEN    {Odi.PutMessage [message: msgKey1[warningForTooSmallVM1],       beep: TRUE,       clearMessageAreaFirst:TRUE];     Odi.PutMessage [message: SELECT computedVMSize FROM    	     		vm8mega => msgKey[vm8mb],	     		vm16mega => msgKey[vm16mb],			vm32mega => msgKey[vm32mb],	     		ENDCASE => msgKey[unknown],        clearMessageAreaFirst:FALSE];      Odi.PutMessage [message: msgKey1[warningForTooSmallVM2],        clearMessageAreaFirst:FALSE];      Odi.PutMessage [message: SELECT eePromImage.VMMSizeInPages FROM    	     		vm8mega => msgKey[vm8mb],	     		vm16mega => msgKey[vm16mb],			vm32mega => msgKey[vm32mb],	     		ENDCASE => msgKey[unknown],        clearMessageAreaFirst:FALSE];      IF ~Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]]           THEN SIGNAL Odi.AbortCurrentTest}  ELSE IF computedVMSize < eePromImage.VMMSizeInPages THEN    {Odi.PutMessage [message: msgKey1[warningForTooLargeVM1],       beep: TRUE,       clearMessageAreaFirst:TRUE];     Odi.PutMessage [message: SELECT computedVMSize FROM    	     		vm8mega => msgKey[vm8mb],	     		vm16mega => msgKey[vm16mb],			vm32mega => msgKey[vm32mb],	     		ENDCASE => msgKey[unknown],        clearMessageAreaFirst:FALSE];      Odi.PutMessage [message: msgKey1[warningForTooLargeVM2],        clearMessageAreaFirst:FALSE];      Odi.PutMessage [message: SELECT eePromImage.VMMSizeInPages FROM    	     		vm8mega => msgKey[vm8mb],	     		vm16mega => msgKey[vm16mb],			vm32mega => msgKey[vm32mb],	     		ENDCASE => msgKey[unknown],        clearMessageAreaFirst:FALSE];      IF ~Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]]           THEN SIGNAL Odi.AbortCurrentTest};  [] ¬ Odi.GetAnOption [optionTable: NIL,        optionPrompt: msgKey[blanks], 	justDisplayTable:TRUE]; -- erase option prompt before go to next question    IF Odi.GetYesNo [prompt: msgKey1[question2WriteEEProm]]           THEN {	   	  eePromImage.VersionEProm ¬ EEpromDefs.VersionNumberROM;		  eePromImage.VersionRAM ¬ EEpromDefs.VersionNumberRAM;		  eePromImage.VersionBadPages ¬ EEpromDefs.VersionNumberBadPages;	   	<<IF versionBoolean = FALSE THEN 	   		{ eePromImage.VersionEProm ¬ EEpromDefs.VersionNumberROM;	   		  eePromImage.VersionRAM ¬ EEpromDefs.VersionNumberRAM;	   		  eePromImage.VersionBadPages ¬ EEpromDefs.VersionNumberBadPages; };		IF unusedBoolean = FALSE THEN	   		{ eePromImage.BootingSpare ¬ 0;	--THIS CODE IS ALSO IN SysConfigUserImpl.mesa			  eePromImage.unused4 ¬ 0;	--and must be changed in **BOTH** places			  eePromImage.SpareRomRam1 ¬ 0;	--if there is to be a change.			  eePromImage.DefaultSpares ¬ 0;			  eePromImage.SpareRomRam2 ¬ 0;			  eePromImage.SpareRomRam3 ¬ 0;			  eePromImage.SpareRomRam4 ¬ 0;			  eePromImage.SpareRomRam5 ¬ 0;			  eePromImage.SpareRomRam6 ¬ 0;			  eePromImage.SpareRomRam7 ¬ 0;			  eePromImage.SpareRomRam8 ¬ 0;			  eePromImage.SpareRomRam9 ¬ 0;			  eePromImage.SpareRomRam10 ¬ 0;			  eePromImage.SpareRomRam11 ¬ 0;			  eePromImage.SpareRomRam12 ¬ 0;			  eePromImage.SpareRomRam13 ¬ 0; }; >>				status ¬ WriteEEProm [];		IF status = success OR status = badMemConfig		  THEN {-- even a badMemConfig gets written to EEProm, so result ¬ passed.		    result ¬ passed; 		    Odi.PutMessage [msgKey1[eePromUpdated]]}		  ELSE {result ¬ failed; 		    Odi.PutMessage [msgKey1[eePromUpdateFailed], TRUE]}}  ELSE {Odi.PutMessage [msgKey1[eePromUpdateAborted], TRUE]; };    ENDLOOP;    END;  -- WriteEEPromImage--******************************************************************************-- ReadSysConfig:--******************************************************************************ReadSysConfig: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN  -- Read the current EEProm configuration into IORegion  --  -- Get confirmation before actually updating  continue: BOOLEAN ¬ TRUE;  readOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [1];  -- Just one row of option here  readOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [2]; -- Extra option is for EXIT  --      leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 5;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  readOptionSelected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN ¬ TRUE;  result ¬ none;    readOptionTable.linesOfOptions[0] ¬ readOptionRow0; -- Save pointer to row  readOptionTable.optionMenuTiTle ¬ msgKey[readSysConfigExpl];    readOptionRow0.optionsOnALine[0].position ¬ leftEdge;  readOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  readOptionRow0.optionsOnALine[0].option ¬ msgKey1[readEEPromConfirm];  -- %Change    xPosition ¬ leftEdge + msgKey1[readEEPromConfirm].length + 8;  -- %Change  readOptionRow0.optionsOnALine[1].position ¬ xPosition;  readOptionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  readOptionRow0.optionsOnALine[1].option ¬ msgKey[returnToTopLevel];  -- %Change    DO           IF initialEntry THEN  {     readOptionSelected ¬ Odi.GetAnOption [  -- Always returns a valid option        optionTable: readOptionTable,        optionPrompt: msgKey[blanks], justDisplayTable:TRUE]; -- Change screen or Exit     Odi.PutMessage [msgKey1[question1ReadEEProm]];    };    readOptionSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable:  NIL,      optionPrompt: msgKey[respondToPrompt], defaultOption: 0,      justDisplayTable: FALSE]; -- Change screen or Exit       initialEntry ¬ FALSE;    IF readOptionSelected = 2 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested       statusPtr­ ¬ ReadEEProm [];   SELECT statusPtr­ FROM      success =>{result  ¬ passed;      		 Odi.PutTestParameters[parameters: NIL]; --clear screen      		 Odi.PutMessage [msgKey1[eePromReadSuccess]];      		 [] ¬ SysConfigSubDefs.ShowAllEEprom[];		 Odi.HitAnyKeyToContinue[beep: FALSE];		 RETURN};      eePromError => Odi.PutMessage [message: msgKey1[eePromReadFailed], beep: TRUE];      badCommand => Odi.PutMessage [message: msgKey1[eePromBadCommand], beep: TRUE];      checkSumError => Odi.PutMessage [message: msgKey1[eePromCheckSumError], beep: TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [message: msgKey1[eePromUnknownError], beep: TRUE];  continue ¬ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];  IF ~continue THEN SIGNAL Odi.AbortCurrentTest ELSE RETURN;  ENDLOOP;    END;  -- ReadSysConfig    --******************************************************************************-- VerifyEEPROMCheckSum:--******************************************************************************VerifyEEPROMCheckSum: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    --   CheckSumTypes: TYPE = {checkSumData, checkSumOverRide};  -- This option table presents the various disk types to the user for selection.  --   numberOfCheckSumTypes: CARDINAL = ORD[LAST[CheckSumTypes]] + 1;  checkSumTypeOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [1];  -- Just one row of option here  checkOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [numberOfCheckSumTypes + 1]; -- Extra option is for EXIT    -- This fixed-position display record holds the check sum information as being  -- displayed at the top of the data area. The rest of the data area still can  -- be used to print normal data (PutData still retains its full power)  --  checkInformation: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [2];  -- 2 single-itemed rows of data    checkInfoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item on row  checkInfoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];  -- 1 item    leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 12;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  checkTypeSelected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN ¬ TRUE;    string1: LONG STRING ¬ [5];string2: LONG STRING ¬ [5];  string1[4] ¬ 'H; string2[4] ¬ 'H;    -- Fill in the checkInformation record fields  checkInformation.displayTitle ¬ msgKey1[checkInfoTitle];  checkInformation.rows[0] ¬ checkInfoRow0;  -- First row  checkInformation.rows[1] ¬ checkInfoRow1;  -- Second row    -- Now fill in the static fields of the display record  --  -- Fill in first row static data  checkInfoRow0.rowItems[0].namePosition ¬ leftEdge;  -- Name position  checkInfoRow0.rowItems[0].name ¬ msgKey1[checkSum];  checkInfoRow0.rowItems[0].stringValue ¬ string1;  checkInfoRow0.rowItems[0].valuePosition ¬ noNumericData;    -- Fill in second row static data  checkInfoRow1.rowItems[0].namePosition ¬ leftEdge;  -- Name position  checkInfoRow1.rowItems[0].name ¬ msgKey1[invertedCheckSum];  checkInfoRow1.rowItems[0].stringValue ¬ string2;  checkInfoRow1.rowItems[0].valuePosition ¬ noNumericData;    --Check Options table    checkSumTypeOptionTable.linesOfOptions[0] ¬ checkOptionRow0; -- Save pointer to row  checkSumTypeOptionTable.optionMenuTiTle ¬ msgKey1[checkSumOptions];    checkOptionRow0.optionsOnALine[0].position ¬ leftEdge;  checkOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  checkOptionRow0.optionsOnALine[0].option ¬ msgKey1[checkSumOverrideFALSE];  -- %Change    xPosition ¬ leftEdge + msgKey1[checkSumOverrideFALSE].length + 8;  checkOptionRow0.optionsOnALine[1].position ¬ xPosition;  checkOptionRow0.optionsOnALine[1].selectionNumberForThisItem ¬ 2;  checkOptionRow0.optionsOnALine[1].option ¬ msgKey1[checkSumOverrideTRUE];  -- %Change    xPosition ¬ xPosition + msgKey1[checkSumOverrideTRUE].length + 8;  -- %Change  checkOptionRow0.optionsOnALine[2].position ¬ xPosition;  checkOptionRow0.optionsOnALine[2].selectionNumberForThisItem ¬ 3;  checkOptionRow0.optionsOnALine[2].option ¬ msgKey[exitSelection];  IF statusPtr­ # success THEN {    continue: BOOLEAN ¬ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue ¬ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until exit is requested      checkTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: IF initialEntry THEN checkSumTypeOptionTable ELSE NIL,      optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Example default    initialEntry ¬ FALSE;    IF checkTypeSelected = 3 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested        eePromPointer[62] ¬ Checksum.ComputeChecksum[, 62, eePromPointer];    eePromPointer[63]  ¬ Inline.BITNOT[eePromPointer[62]];        NumberToHex[eePromImage.EEpromCheckSum,string1];    string1.length ¬ 5;    NumberToHex[eePromImage.EEpromInvertedCheckSum,string2];    string2.length ¬ 5;        Odi.DisplayFixedPositionData [  -- Display the check information       displayData: checkInformation];        SELECT checkTypeSelected FROM      1 =>  SysConfigChannelDefs.checkSumOverride ¬ FALSE;      2 =>  SysConfigChannelDefs.checkSumOverride ¬ TRUE;      ENDCASE;            IF checkTypeSelected = 2 THEN           -- Get sectorsPerTrack info      { Odi.PutMessage [msgKey[respondToPrompt]];              checkInfoRow0.rowItems[0].value ¬ eePromImage.EEpromCheckSum;		checkInfoRow0.rowItems[0].value ¬ Odi.GetANumber [       	  prompt: msgKey1[enterHexValue],	  lowLimit: 0,	  upperLimit: 0FFFFH,	  numberIsHexadecimal: TRUE,	  numberIsLong: TRUE,	  defaultNumber: checkInfoRow0.rowItems[0].value].longNumber;       eePromImage.EEpromCheckSum ¬ Inline.LowHalf[checkInfoRow0.rowItems[0].value];       NumberToHex[eePromImage.EEpromCheckSum,string1];       string1.length ¬ 5;       Odi.DisplayFixedPositionData [checkInformation];  -- Update display              -- Get numberOfHeads              checkInfoRow1.rowItems[0].value ¬ eePromImage.EEpromInvertedCheckSum;              checkInfoRow1.rowItems[0].value ¬ Odi.GetANumber [       	  prompt: msgKey1[enterHexValue],	  lowLimit: 0,	  upperLimit: 0FFFFH,	  numberIsHexadecimal: TRUE,	  numberIsLong: TRUE,	  defaultNumber: checkInfoRow1.rowItems[0].value].longNumber;       eePromImage.EEpromInvertedCheckSum ¬ Inline.LowHalf[checkInfoRow1.rowItems[0].value];       NumberToHex[eePromImage.EEpromInvertedCheckSum,string2];       string2.length ¬ 5;       Odi.DisplayFixedPositionData [checkInformation];  -- Update display	};              ENDLOOP; -- Outer loop    END;  -- VerifyEEPROMCheckSum-- PROCs exported to SysConfigEEPromDefs  ReadEEProm: PUBLIC PROC RETURNS [status: SysConfigChannelDefs.Status] =    BEGIN    diskDevice: PilotDiskFace.DeviceHandle;    status ¬ SysConfigChannelDefs.ReadEEPromImage [];    diskDevice ¬ PilotDiskFace.GetNextDevice [PilotDiskFace.nullDeviceHandle];    SysConfigRigidDiskDefs.diskShapeImage ¬ SpecialPilotDiskFace.GetDiskShape [diskDevice];    IF ((SysConfigRigidDiskDefs.diskShapeImage.type = Device.nullType) OR       (SysConfigRigidDiskDefs.diskShapeImage.type = DeviceTypes.anyPilotDisk))    	 THEN {    -- not a self-describing disk; bring the disk shape image up-to-date      index: CARDINAL ¬ ORD[eePromImage.RigidDiskType] - 1;      IF (index > SysConfigRigidDiskDefs.rigidDisks)	THEN index ¬ SysConfigRigidDiskDefs.rigidDisks; -- Unknown DiskType      SysConfigRigidDiskDefs.diskShapeImage.type ¬        SysConfigRigidDiskDefs.rigidDiskArray[index].type;      SysConfigRigidDiskDefs.diskShapeImage.rpm ¬        SysConfigRigidDiskDefs.rigidDiskArray[index].rpm;      SysConfigRigidDiskDefs.diskShapeImage.vcmDisk ¬        SysConfigRigidDiskDefs.rigidDiskArray[index].vcmDisk}    ELSE {    -- a self-describing disk; override the EEProm      eePromImage.RigidDiskSectorsPerTrack ¬        SysConfigRigidDiskDefs.diskShapeImage.pagesPerTrack;      eePromImage.RigidDiskHeadsPerCylinder ¬        SysConfigRigidDiskDefs.diskShapeImage.headsPerCylinder;      eePromImage.RigidDiskHeadsCylinderCount ¬        SysConfigRigidDiskDefs.diskShapeImage.cylinderCount;      eePromImage.RigidDiskReducedWriteCylinder ¬        SysConfigRigidDiskDefs.diskShapeImage.reducedWriteCylinder;      eePromImage.RigidDiskPreCompensationCylinder ¬        SysConfigRigidDiskDefs.diskShapeImage.preCompensationCylinder;      eePromImage.RigidDiskHeadLandingZone ¬        SysConfigRigidDiskDefs.diskShapeImage.headLandingZone;      FOR index: CARDINAL IN [0 .. SysConfigRigidDiskDefs.arraySize) DO        IF SysConfigRigidDiskDefs.rigidDiskArray[index].type =	  SysConfigRigidDiskDefs.diskShapeImage.type THEN {	    eePromImage.RigidDiskType ¬ VAL[index + 1];	    EXIT};	ENDLOOP;      eePromImageCopy.RigidDiskSectorsPerTrack ¬	eePromImage.RigidDiskSectorsPerTrack;      eePromImageCopy.RigidDiskHeadsPerCylinder ¬	eePromImage.RigidDiskHeadsPerCylinder;      eePromImageCopy.RigidDiskHeadsCylinderCount ¬	eePromImage.RigidDiskHeadsCylinderCount;      eePromImageCopy.RigidDiskReducedWriteCylinder ¬	eePromImage.RigidDiskReducedWriteCylinder;      eePromImageCopy.RigidDiskPreCompensationCylinder ¬	eePromImage.RigidDiskPreCompensationCylinder;      eePromImageCopy.RigidDiskHeadLandingZone ¬	eePromImage.RigidDiskHeadLandingZone;      eePromImageCopy.RigidDiskType ¬	eePromImage.RigidDiskType};    END;  WriteEEProm: PUBLIC PROC RETURNS [status: SysConfigChannelDefs.Status] =    BEGIN    diskDevice: PilotDiskFace.DeviceHandle;    ioStatus: DiskChannel.IOStatus;    status ¬ SysConfigChannelDefs.WriteEEPromImage [];    IF status = success OR status = badMemConfig -- even a badMemConfig gets written      THEN {Odi.PutMessage [msgKey1[eePromUpdated]]}      ELSE {Odi.PutMessage [msgKey1[eePromUpdateFailed], TRUE]};    diskDevice ¬ PilotDiskFace.GetNextDevice [PilotDiskFace.nullDeviceHandle];    SpecialPilotDiskFace.SetDiskShape [diskDevice, SysConfigRigidDiskDefs.diskShapeImage];    ioStatus ¬ DiskUtilSelfDescr.WriteDiskShapeToDisk [FALSE];    WITH ioStatus SELECT FROM      disk => IF status # goodCompletion		THEN Odi.PutMessage [msgKey1[diskUpdateFailed], TRUE];      ENDCASE;    END;END.logcreated on 18-Jun-85 15:06:41 by Allen Roberts
-- Copyright (C) 1985, 1986, 1987, 1988 Xerox Corporation. All rights reserved.-- File: OfflineDiskUtilitiesDove.mesa	-Last edited:-- STC, 11-Oct-88 20:43:44, Labelless--DIRECTORY  CompatibilityDiskFace USING [Command, SetLabelFilePage, zeroLabel],  DiskChannel	       USING [ DirectOperation, IOStatus, defaultTries,  			       DoDirectIO],  DiagDiskMkTime       USING [ DiagDiskMkTimeImpl, mkTime],  DiagDiskTime	       USING [ SetRealTimeClock, RealTimeClockFailure],  DiskUtilityMiscDove  USING [ RamBadPageTable, GetABlankBadPageTable,  			       NoQuitsYesReturns, ConvertDiskAddressToPage,			       PauseAndQuit, firstAllowableBP,			       PrintExpandedPageHeading, ExpandPageNumber,			       DisplayBPTable, PrintStatus, RepairABadPage,			       saveStatusPosition, restoreStatusPosition,			       leftEdge, TestABadPage, InBadPageTable,			       pagesPerCylinder, 			       pvHandle, pvID, deviceHandle, cylinders, 			       movingHeads, sectorsPerTrack, 			       totalPagesOnADisk, ForceDriveOffline,			       SubVolumeTable, CheckCylinderZero, AddABadPage,			       ReadCurrentBPTFromDisk, pagesPerTrack,			       ConvertPageToDiskAddress, SaveATrack, 			       TestPagesInBadPageTable, AddBadPageTable,			       ResetBadPageTable, SetDriveStateTo, saveOpStatus,			       GetADisplayRecord, op, dataPages, labels,			       InitOpPtrs, ManufDskCkOut, CollectNewBadPage,			       DisplayBadPageTable, PrintBadPageTable,			       CheckPVPages, HeadRetraction,			       labeledOp, AddADamagedPage],  DiskUtilityMiscImplDove,  DiskUtilityMsgKeysDove USING [duMessage, InitializeDiskUtilMsgKeys],  DiskUtilityMsgKeysImplDove,  DiskUtilSelfDescr USING [VerifyDiskShape, WriteDiskShapeToDisk],  Environment	       USING [ bitsPerByte],  FormatPilotDisk      USING [ RetryLimit, Format, Scan, BadPage,			       PassDone, SetUserAbort],  Inline	       USING [ LongMult],  OfflineDiagInterface USING [ OfflineDiagnosticProc, ResultType, userType,			       PutTestParameters, LookForAbort,			       TestItemsForThisNode, GetATestItemsForThisNode,			       TestItem, GetATestItem, ClientPackage,			       AMenuOfSelections, GetAMenuOfSelections,			       Selections, GetASelectionArray, DiagHeap,			       HelpText, GetAHelpText, AbortCurrentTest,			       FixedPositionDisplayRecord, ARow,			       PutMessage, PutData, HitAnyKeyToContinue,			       GetYesNo, GetANumber, abortSensed],  PhysicalVolume       USING [ Handle, ID, PageNumber, VolumeType, 			       nullID, Error, maxSubvolumesOnPhysicalVolume,			       RepairType, ScavengerStatus, DamageStatus,			       RepairStatus, noProblems, NeedsScavenging,			       GetHints, CreatePhysicalVolume, Scavenge,			       AssertNotAPilotVolume],  PilotDiskFace	       USING [ DeviceHandle,   			       DiskAddress, Status],  Process	       USING [ Yield],  Runtime	       USING [ StartFault],  SysConfigHeadDove;OfflineDiskUtilitiesDove: PROGRAM	 IMPORTS CompatibilityDiskFace,	 	 PhysicalVolume, FormatPilotDisk, Runtime, Process,	 	 DiagDiskMkTime, DiskUtilSelfDescr,	 	 DiskChannel, Inline, DiagDiskTime, DiskUtilityMiscDove,	 	 OfflineDiagInterface, DiskUtilityMsgKeysDove,--	         Messages: DiskUtilityMsgKeysImplDove,		 SupportPackage: DiskUtilityMiscImplDove,		 SysConfigHeadDove --, SysConfigChannelDefs		 	 EXPORTS OfflineDiagInterface, DiskUtilityMiscDove =BEGIN OPEN DiskUtilityMsgKeysDove,	   Odi: OfflineDiagInterface,  -- ODI stands for OfflineDiagInterface.	   PV: PhysicalVolume, FPD: FormatPilotDisk, Misc: DiskUtilityMiscDove;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- First declare various structures and constants that will be used.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~  --  -- topLevelMenuNode points to a RECORD, AMenuOfSelections, containing pointers    -- to various elements of the top level menu node.   --  -- Each menu item may be a real test or a submenu. Each submenu is also a  -- AMenuOfSelections.  --    topLevelMenuNode: LONG POINTER TO Odi.AMenuOfSelections;    -- topLevelMenuSelections points to a SEQUENCE containing pointers to all    -- TestItems in the topmenu.  topLevelMenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;     -- Test numbers for the topLevelMenuNode defined for clarity convenience.   -- These correspond to the topLevelMenuSelections indices into which   -- the pointers to TestItems are to be stored. They will be assigned  -- to the selections arrays for each class of user  --  formatARigidDisc: CARDINAL = 0;  --  topLevelMenuSelections.nodeItems [0]   scavengePhyscalVolume: CARDINAL = 1; --  topLevelMenuSelections.nodeItems [1]  badPageUtility: CARDINAL = 2; -- topLevelMenuSelections.nodeItems [2]  headRetraction: CARDINAL = 3; -- topLevelMenuSelections.nodeItems [3]--~~~~~~~~~~~~~~~~~~~~~~~~~~-- Second level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~~~~  --  -- secondLevelMenuNode is for the bad page utilities  --  secondLevelMenuNode: LONG POINTER TO Odi.AMenuOfSelections;  secondLevelMenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;    -- Constants declared for clarity and convenience  -- Test selections (secondLevelMenuSelections indices) for secondLevelMenuNode  displayBadPageTable: CARDINAL = 0; -- secondLevelMenuSelections.nodeItems [0]  manualBadPageEntry: CARDINAL = 1; -- secondLevelMenuSelections.nodeItems [1]  fixBadPageheader: CARDINAL = 2; -- secondLevelMenuSelections.nodeItems [2]  checkDriveForBadPages: CARDINAL = 3; -- secondLevelMenuSelections.nodeItems [3]  scavengeAPage: CARDINAL = 4; -- secondLevelMenuSelections.nodeItems [4]  resetBPT: CARDINAL = 5; -- secondLevelMenuSelections.nodeItems [5]  testSuspectPages: CARDINAL = 6; -- secondLevelMenuSelections.nodeItems [6]  printBadPageTable: CARDINAL = 7; -- secondLevelMenuSelections.nodeItems [7]--~~~~~~~~~~~~~~~~~~~~~~~~~~-- Third level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~~~~  -- thirdLevelMenuNode is for manual bad page entry utilities selectable from  -- the secondLevelMenuNode  thirdLevelMenuNode: LONG POINTER TO Odi.AMenuOfSelections;  -- Node object  thirdLevelMenuSelections: LONG POINTER TO Odi.TestItemsForThisNode; -- 2    -- Test selections (thirdLevelMenuSelections indices) for thirdLevelMenuNode  enterByPageNumber: CARDINAL = 0; -- thirdLevelMenuSelections.nodeItems [0]  enterByErrorLog: CARDINAL = 1; -- thirdLevelMenuSelections.nodeItems [1]  -- pTestItem points to a RECORD containing all the components of a TestItem.  pTestItem: LONG POINTER TO Odi.TestItem;  -- The following pointers point to SEQUENCES specifying tests for the various-- user classes.  pAdminSelections, pUserSelections: LONG POINTER TO Odi.Selections;  pDangerSelections, pManufacturingSelections: LONG POINTER TO Odi.Selections;  	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Declarations for convenience--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  nullResult: Odi.ResultType = none;  goodResult: Odi.ResultType = passed;  badResult: Odi.ResultType = failed;  ambiguousResult: Odi.ResultType = ambiguous;    formatDone: BOOLEAN¬ FALSE;  defaultToYes: BOOLEAN = TRUE;  defaultToNo: BOOLEAN = FALSE;  firstPage: CARDINAL = 0;  p: PROCESS;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common definitions --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Rigid disc info    wasOnline: BOOLEAN ¬ FALSE;  -- TRUE => Drive was online  virginDisk: PUBLIC BOOLEAN; -- TRUE => Brand new disk that must first be formatted  preFormatBPTSaved: BOOLEAN;  -- TRUE => original bad page table saved  -- VolumeType: TYPE = { notPilot, probablyNotPilot, probablyPilot, isPilot }  volumeType: PhysicalVolume.VolumeType;    -- Subvolume info for physical volume  subVolumeTable: PUBLIC LONG POINTER TO DiskUtilityMiscDove.SubVolumeTable;  volumeInfoValid: PUBLIC BOOLEAN ¬ FALSE;    -- The stati of the save operations for the pages on the track  ioStatus: DiskChannel.IOStatus;    -- Save and restore a page  saveData: CompatibilityDiskFace.Command = [verify, read, read];  restoreData: CompatibilityDiskFace.Command = [verify, write, write];  verifyData: CompatibilityDiskFace.Command = [verify, verify, verify];    --for head retraction    -- ERRORs  ChangeCountMisMatch: ERROR = CODE;  IllegalDriveState: ERROR = CODE;  ImpossibleEndCase: ERROR = CODE;  -- Bad-page related items  badPageCount: CARDINAL ¬ 0; -- Number of bad pages  cyl0badPageCount: CARDINAL ¬ 0; -- Number of bad pages in Cylinder 0  badPage: PV.PageNumber;  maxNumberOfBadPages: CARDINAL = 200; -- Artificial upper limit. Can modify.    -- Bad page tables  preFormatBPT: PUBLIC LONG POINTER TO Misc.RamBadPageTable;  formatGeneratedBPT: LONG POINTER TO Misc.RamBadPageTable;  scanGeneratedBPT: LONG POINTER TO Misc.RamBadPageTable;  currentBPTOnDisk: PUBLIC LONG POINTER TO Misc.RamBadPageTable;   trackBadPages: LONG POINTER TO Misc.RamBadPageTable;    bptFull: BOOLEAN ¬ FALSE;  -- TRUE => maxNumberOfBadPages in RAM Bad Page Table  firstOverFlowPageEncountered: BOOLEAN ¬ FALSE; -- First page not entered in RBPT-- Help texts  repairHelp: LONG POINTER TO Odi.HelpText;  helpText, addHelp: LONG POINTER TO Odi.HelpText;-- Positionally-fixed data    scanTopDisplay, errorLogInfo: LONG POINTER TO Odi.FixedPositionDisplayRecord;  fmtTopDisplay, paramsForFBH: LONG POINTER TO Odi.FixedPositionDisplayRecord;    -- Scratch variables to be re-used thru-out package  lin1, lin2, lin3: LONG POINTER TO Odi.ARow;  item2Pos, item3Pos: CARDINAL;-- flags indicating initiation and in RDDiagnostics  RigidDiskDiag: PUBLIC BOOLEAN;    InitStarted: PUBLIC BOOLEAN;    UserWantsToAbort: BOOLEAN;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common support procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--*****************************************************************-- Check if pvID is valid; if not, get it from Pilot. Also, make -- sure that we are not operating on a virgin disk.--*****************************************************************ValidateIDandCheckVirginity: PUBLIC PROC = {  IF virginDisk THEN {     Odi.PutMessage[message: duMessage[canNotOpOnVirginDisk], beep: TRUE];     volumeInfoValid ¬ FALSE; Misc.PauseAndQuit[];};  [] ¬ Misc.CheckPVPages []; -- STC, 9-Oct-88 17:21:11   IF Misc.pvID = PV.nullID THEN { -- May be a virgin disk     [Misc.pvID, volumeType] ¬ PhysicalVolume.GetHints [Misc.pvHandle       ! PV.Error => { Odi.PutMessage[message: duMessage[problemAccessingDrive],               beep: TRUE];       volumeInfoValid ¬ FALSE;}];};  IF Misc.pvID # PV.nullID THEN volumeInfoValid ¬ TRUE;};--*****************************************************************-- Collect bad pages. The bad pages are stored in increasing order--*****************************************************************CollectABadPage: PROC [bpCollector: LONG POINTER TO Misc.RamBadPageTable,		       newBadPage: PhysicalVolume.PageNumber] =  BEGIN    tmp: PhysicalVolume.PageNumber;    IF badPageCount >= maxNumberOfBadPages THEN { -- RAM table is full       bptFull ¬ TRUE;        Odi.PutMessage[message: duMessage[tooManyBadPages], beep: TRUE,                       numOfBlankLines: 1] };  -- Give warning    FOR i: CARDINAL IN [0..maxNumberOfBadPages) DO { -- Each page goes thru table    -- If a user specifies more than 1 scan, a bad page may have already been        -- logged.       Odi.LookForAbort[]; -- Enable abort       SELECT bpCollector.badPages[i] FROM  -- 	  = newBadPage => RETURN;  -- Already in bad page table          < newBadPage => LOOP; -- Store in increasing order	  = LAST[LONG CARDINAL] => { -- An empty slot has LAST[LONG CARDINAL]	      bpCollector.badPages[i] ¬ newBadPage;	      badPageCount ¬ badPageCount + 1; EXIT };          > newBadPage => {	      badPageCount ¬ badPageCount + 1;	      IF bptFull THEN { -- Table full, just display page number	      -- This is a case where a bad page was not found by previous scans	         IF NOT firstOverFlowPageEncountered THEN { -- fisrt overflow page		    firstOverFlowPageEncountered ¬ TRUE;		    Odi.PutData[data: duMessage[overflowedPages], 		                clearDataAreaOnly: TRUE] };	         Odi.PutData[numberAfterData: newBadPage, blankSpaces: 2];		 EXIT };  -- Displays page number only if not in table	      tmp ¬ bpCollector.badPages[i];	      bpCollector.badPages[i] ¬ newBadPage;	      -- Now shift everything by 1	      FOR j: CARDINAL IN [(i+1) .. badPageCount) DO	          newBadPage ¬ bpCollector.badPages[j];  -- Save temporarily	          bpCollector.badPages[j] ¬ tmp; -- Shift by 1 location		  tmp ¬ newBadPage;		  ENDLOOP;	      EXIT};	  	  ENDCASE => ERROR ImpossibleEndCase };       ENDLOOP;  -- Bad page loop       bpCollector.badPageCount ¬ badPageCount;    END;  -- CollectABadPage--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Procedures menu selections invoke--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--************************-- Formats the rigid disk--************************FormatRigidDisK: Odi.OfflineDiagnosticProc =  BEGIN       GoFormatDisk[];  END; -- FormatRigidDisK--****************************************************************************GoFormatDisk: PUBLIC PROCEDURE =  BEGIN    passes, retries: CARDINAL;    cylinder0: CARDINAL = 0;    pattern: CARDINAL ¬ 0FFFFH;    cannotSave: BOOLEAN ¬ FALSE;  -- TRUE => Cannot save BPT    cyl0Problem: BOOLEAN ¬ FALSE;        GetStatusMsg: PROC [status: PilotDiskFace.Status] RETURNS [LONG STRING];    IF ~InitStarted THEN StartInit[];        -- First, give warning of data destruction    IF ~(RigidDiskDiag AND Misc.ManufDskCkOut) THEN      {       DiskUtilSelfDescr.VerifyDiskShape[];       helpText.helpTitle ¬ duMessage [retryHelpTitle];       helpText.textBody[0] ¬ duMessage [retryHelp0];       helpText.textBody[1] ¬ duMessage [retryHelp1];       helpText.textBody[2] ¬ NIL;           IF ~RigidDiskDiag THEN         { Misc.NoQuitsYesReturns [duMessage[fmtWarning], TRUE];	  passes ¬ Odi.GetANumber [    		prompt: duMessage[passCount],    		help: helpText,    		defaultNumber: 25,    -- was 10 ¬ 25 ¬ 100 ¬ 25		upperLimit: LAST[CARDINAL]].number} ELSE         {passes ¬ Odi.GetANumber [    		prompt: duMessage[passCount],    		help: helpText,    		defaultNumber: 96,    -- for manufacture		upperLimit: LAST[CARDINAL]].number};      };    IF RigidDiskDiag THEN   	{ IF Misc.ManufDskCkOut THEN {passes ¬ 12};	  retries ¬ 0;};        fmtTopDisplay.displayTitle ¬ duMessage[formattingInfo];    lin2 ¬ fmtTopDisplay.rows[1];    lin2.rowItems[0].name ¬ duMessage[passCount];    lin2.rowItems[0].valuePosition ¬ Misc.leftEdge + duMessage[passCount].length + 2;    lin2.rowItems[0].value ¬ passes;        -- Number of attempts to verify a page if problems encountered with a page.    -- A page will be declared bad only if all retries failed    IF ~RigidDiskDiag THEN	{retries ¬ Odi.GetANumber[prompt: duMessage[retryCount],    		  	     lowLimit: 0, upperLimit: 253,     		 	     help: helpText, defaultNumber: 0].number};		      lin3 ¬ fmtTopDisplay.rows[2];     lin3.rowItems[0].name ¬ duMessage[retryCount];    lin3.rowItems[0].valuePosition ¬ Misc.leftEdge + duMessage[retryCount].length+2;    lin3.rowItems[0].value ¬ retries;        item2Pos ¬ MAX [lin2.rowItems[0].name.length,    	            lin3.rowItems[0].name.length] + 6 + Misc.leftEdge;-- was 2    BEGIN -- Save the current bad page table contents    ENABLE PV.NeedsScavenging => {       Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE];       cannotSave ¬ TRUE; preFormatBPTSaved ¬ FALSE; CONTINUE };    IF ~Misc.ManufDskCkOut AND ~virginDisk THEN  -- Attempt to save existing BPT          preFormatBPT ¬ Misc.ReadCurrentBPTFromDisk[preFormatBPT];    IF preFormatBPT.badPageCount # 0 THEN {          preFormatBPTSaved ¬ TRUE; cannotSave ¬ FALSE };    END;        lin1 ¬ fmtTopDisplay.rows[0];     lin1.rowItems[0].name ¬ duMessage[preFormatBPT];    lin1.rowItems[0].stringValue ¬ SELECT TRUE FROM         virginDisk =>  duMessage[unformattedDisk],	 preFormatBPTSaved => duMessage[savePlusCount],	 ENDCASE => duMessage[notSaved];    IF preFormatBPTSaved THEN    { lin1.rowItems[0].valuePosition ¬ lin1.rowItems[0].name.length +        lin1.rowItems[0].stringValue.length + 6;      lin1.rowItems[0].value ¬ preFormatBPT.badPageCount;    };    lin2.rowItems[1].name ¬ duMessage[remainPassCount];    lin2.rowItems[1].namePosition ¬ item2Pos;    lin2.rowItems[1].valuePosition ¬          item2Pos + duMessage[remainPassCount].length + 2;    lin2.rowItems[1].value ¬ passes;    lin3.rowItems[1].name ¬ duMessage[newBadPageCount];    lin3.rowItems[1].namePosition ¬ item2Pos;    lin3.rowItems[1].valuePosition ¬          item2Pos + duMessage[newBadPageCount].length + 2;    lin3.rowItems[1].value ¬ 0;        item3Pos ¬ MAX [lin2.rowItems[1].name.length,    	            lin3.rowItems[1].name.length] + 10 + item2Pos;    pattern ¬ 0FFFFH;    lin2.rowItems[2].name ¬ duMessage[pattern];    lin2.rowItems[2].namePosition ¬ item3Pos;    lin2.rowItems[2].valuePosition ¬          item3Pos + duMessage[pattern].length + 2;    lin2.rowItems[2].value ¬ pattern;    Odi.PutTestParameters [fmtTopDisplay, FALSE];        IF preFormatBPTSaved THEN {        Odi.PutData[data: duMessage[preFormatBPT], clearHeadingAndData: TRUE ];       Misc.DisplayBPTable [preFormatBPT] };           -- Last warning    IF ~RigidDiskDiag THEN        {Misc.NoQuitsYesReturns[duMessage[areYouStillSure], defaultToNo]};        -- Format drive    Misc.ForceDriveOffline [Misc.pvHandle];    PhysicalVolume.AssertNotAPilotVolume [Misc.pvHandle  -- Enable direct access    		   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE];    { ENABLE UNWIND => Misc.SetDriveStateTo[inactive];      UserWantsToAbort¬ FALSE;      formatDone ¬ FALSE;      cyl0Problem ¬ FALSE;      p¬ FORK CheckForUserAbort[];      Odi.PutMessage [duMessage[formatting]];      bptFull ¬ FALSE; firstOverFlowPageEncountered ¬ FALSE; badPageCount ¬ 0;      Misc.ResetBadPageTable[formatGeneratedBPT];      Misc.ResetBadPageTable[scanGeneratedBPT];      FPD.Format [      	h: Misc.pvHandle,	firstPage: firstPage,	count: Misc.totalPagesOnADisk, 	passes: passes,	retries: retries,	returnOnUserAbort: TRUE,	signalPassDone: TRUE        ! FPD.BadPage =>	    { IF p< Misc.pagesPerCylinder THEN --if in cylinder zero	      { oldBadPageCnt: CARDINAL ¬ cyl0badPageCount;	        cyl0badPageCount ¬ Misc.CollectNewBadPage[scanGeneratedBPT,	      			       scanGeneratedBPT, cyl0badPageCount, p];		IF (passes < 401) AND ((cyl0badPageCount > 6) OR		      (oldBadPageCnt = cyl0badPageCount)) THEN		   { cyl0Problem ¬ TRUE;		     Odi.PutMessage [message: duMessage [badCylZero],		   	numOfBlankLines: 1, beep: TRUE]; Misc.PauseAndQuit[]};		RESUME;	      } ELSE	      { badPageCount ¬ Misc.CollectNewBadPage[formatGeneratedBPT,	      			       preFormatBPT, badPageCount, p];	        lin3.rowItems[1].value ¬ badPageCount;	        Odi.PutTestParameters [fmtTopDisplay]; RESUME;	      };	    };	  FPD.PassDone => 	      { lin2.rowItems[1].value ¬ passesLeft; -- STC	        IF passesLeft > 0 THEN -- STC		   {SELECT ((passes - passesLeft) MOD 12) FROM			0 => pattern ¬ 0FFFFH;			1 => pattern ¬ 0;			2 => pattern ¬ 0AAAAH;			3 => pattern ¬ 5555H;			4 => pattern ¬ 6DB6H;			5 => pattern ¬ 9249H;			6 => pattern ¬ 0B6DBH;			7 => pattern ¬ 4924H;			8 => pattern ¬ 0DB6DH;			9 => pattern ¬ 2492H;			ENDCASE => pattern ¬ 3039H;	        lin2.rowItems[2].value ¬ pattern;};	        Odi.PutTestParameters [fmtTopDisplay]; RESUME;	      }];      formatDone¬ TRUE;      FOR i: CARDINAL IN [0..cyl0badPageCount) DO	  badPage: PhysicalVolume.PageNumber ¬ scanGeneratedBPT.badPages[i];	  FOR j: CARDINAL IN [0..100) DO	      FPD.Scan[h: Misc.pvHandle, firstPage: badPage, count: 1, retries: 0		       ! FPD.BadPage => { -- An error encoutered			      	cyl0Problem ¬ TRUE; RESUME;}];	      IF cyl0Problem THEN EXIT;	      ENDLOOP;	  FOR j: CARDINAL IN [0..100) DO	      FPD.Scan[h: Misc.pvHandle, firstPage: badPage - 1, count: 3,	               retries: 0		       ! FPD.BadPage => { -- An error encoutered			      	cyl0Problem ¬ TRUE; RESUME;}];	      IF cyl0Problem THEN EXIT;	      ENDLOOP;	  IF cyl0Problem THEN EXIT;	  ENDLOOP;      IF cyl0Problem THEN 		   { Odi.PutMessage [message: duMessage [badCylZero],		   	numOfBlankLines: 1, beep: TRUE]; Misc.PauseAndQuit[]};      JOIN p;      -- Return to inactive state      Misc.SetDriveStateTo[inactive] }; -- End ENABLE        -- following 2 statments are changed by STC    IF UserWantsToAbort THEN        Odi.PutMessage[message: duMessage[forceStop]] ELSE	   Odi.PutMessage[message: duMessage[completed], startWithNewLine: FALSE ];    UserWantsToAbort¬ FALSE;    IF badPageCount > 0 THEN {       Odi.PutData[data: duMessage[badPageList], numOfBlankLines: 1];       Misc.DisplayBPTable [formatGeneratedBPT] }; -- Print BPT      -- Now create a Pilot Physical Volume so that logical volumes can be created    -- upon it. The intial name is "RD0", which is defined in the message keys    --    Odi.PutMessage [duMessage[createPV]];     Misc.pvID ¬ PhysicalVolume.CreatePhysicalVolume [Misc.pvHandle, duMessage[RD0]];    virginDisk ¬ FALSE;     volumeInfoValid ¬ TRUE; -- STC     Odi.PutMessage [message: duMessage[completed], startWithNewLine: FALSE];    Odi.PutMessage [message: duMessage[writeDiskShape]];    ioStatus ¬ DiskUtilSelfDescr.WriteDiskShapeToDisk[];    WITH ioStatus SELECT FROM      disk =>        IF status # goodCompletion          THEN Odi.PutMessage [message: GetStatusMsg[status],	  	 startWithNewLine: FALSE]	  ELSE Odi.PutMessage [message: duMessage[completed],	  	 startWithNewLine: FALSE];      ENDCASE => Odi.PutMessage [message: duMessage[unknown],      		 startWithNewLine: FALSE];    IF preFormatBPT.badPageCount > 0 THEN         Misc.AddBadPageTable [preFormatBPT, FALSE];        IF badPageCount > 0 THEN { -- Handle old bad pages       combine: CARDINAL = 1;       discard: CARDINAL = 2;       test: CARDINAL = 3;       helpText.helpTitle ¬ duMessage [badPageDisposition];       helpText.textBody[0] ¬ duMessage [combineExp];       helpText.textBody[1] ¬ duMessage [discardExp];       helpText.textBody[2] ¬ duMessage [testExp];              DO       ENABLE Odi.AbortCurrentTest =>       IF Odi.GetYesNo[duMessage[areYouSure],,TRUE,FALSE]          THEN EXIT ELSE LOOP;                action: CARDINAL;	 IF badPageCount > 0 THEN	 action ¬ Odi.GetANumber[prompt: duMessage[desiredAction],	 	  help: helpText, upperLimit: 4, defaultNumber: combine].number;		           SELECT action FROM             combine => { Misc.AddBadPageTable [formatGeneratedBPT, 	  	         Odi.GetYesNo[duMessage[combineBPTs],,TRUE,FALSE]];   			 currentBPTOnDisk ¬     			 Misc.ReadCurrentBPTFromDisk [currentBPTOnDisk       			 ! PV.NeedsScavenging => {           		 Odi.PutMessage[message: duMessage[unableToAccessPDS],		     		beep: TRUE]; Misc.PauseAndQuit[] }];			 Misc.DisplayBPTable [currentBPTOnDisk];-- Print BPT			 EXIT};	    test => { -- Examine each page individually	      	      Misc.TestPagesInBadPageTable [formatGeneratedBPT]; LOOP };	    ENDCASE => -- discard	    	    {IF preFormatBPT.badPageCount > 0 THEN		    	Misc.DisplayBPTable [preFormatBPT];		     EXIT;};	 ENDLOOP };    Misc.ForceDriveOffline[Misc.pvHandle]; -- Return volume to offline state    IF firstOverFlowPageEncountered THEN Odi.PutMessage[ -- More bad pages left       message: duMessage[needToScanDisk], beep: TRUE, numOfBlankLines: 1];    IF RigidDiskDiag THEN InitStarted ¬ FALSE;    IF ~(RigidDiskDiag AND DiskUtilityMiscDove.ManufDskCkOut) THEN    			Odi.HitAnyKeyToContinue[];  END; -- GoFormatDisk--******************************************************************************--CheckForUserAbort: is FORKed in FormatRigidDisK: to look for the 'STOP key--******************************************************************************CheckForUserAbort: PROC =  BEGIN    stopcount: CARDINAL ¬ 0;    done: BOOLEAN¬ FALSE;    UNTIL formatDone OR done DO -- formatDone is set in FormatRigidDisK:      IF Odi.abortSensed THEN      { Odi.abortSensed¬ FALSE; --we don't want a SIGNAL here        FPD.SetUserAbort[];        UserWantsToAbort¬ TRUE; -- tell the formatter to stop        IF stopcount = 0 THEN	   Odi.PutMessage [duMessage[stopKeyAckn]] --tell user "got the message"	   ELSE Odi.PutMessage [duMessage[knownStopKey]];        stopcount ¬ stopcount + 1;	IF stopcount = 3 THEN done¬ TRUE;      };      Process.Yield [];    ENDLOOP;  END; -- of CheckForUserAbort  --******************************************************************************-- Responsible for integrity of physical volume.-- Allows Pilot to place its internal physical volume data structures in order--******************************************************************************ScavengePhysicalVolume: Odi.OfflineDiagnosticProc =  BEGIN     driveID: PV.ID ¬ PV.nullID;    doRepair: BOOLEAN ¬ FALSE;    doRiskyRepair: BOOLEAN ¬ FALSE;    repairType: PV.RepairType;    scavengerStatus: PV.ScavengerStatus;    doConversion: BOOLEAN ¬ FALSE;    errorMessage: LONG STRING;    -- Outputs diagnostic status    PrintReport: PROC [text: LONG STRING, damage: PV.DamageStatus] =       BEGIN        SELECT damage FROM           okay => RETURN;	   damaged => errorMessage ¬ duMessage[damaged];	   lost => errorMessage ¬ duMessage[lost];	   ENDCASE => ERROR ImpossibleEndCase;	         Odi.PutData[data: text, startWithNewLine: TRUE];        Odi.PutData[data: errorMessage, blankSpaces: 2];	END;  -- PrintReport    --    IF ~volumeInfoValid THEN--    	{Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];--	Misc.PauseAndQuit[];};--    ValidateIDandCheckVirginity[];    helpText.helpTitle ¬ duMessage [PVShelp];    helpText.textBody[0] ¬ duMessage [PVShelp0];    helpText.textBody[1] ¬ duMessage [PVShelp1];    helpText.textBody[2] ¬ NIL;        doRepair ¬ Odi.GetYesNo [duMessage[normalRepair], helpText, TRUE, TRUE];        IF Odi.userType > NormalUser AND doRepair THEN doRiskyRepair ¬            Odi.GetYesNo[duMessage[riskyRepair], helpText, TRUE, FALSE];        BEGIN -- Scavenge block     ENABLE PhysicalVolume.Error => {    	   IF error = needsConversion THEN {	      IF (doConversion ¬ Odi.GetYesNo [duMessage[convertFormat]]) 	         AND ([] ¬ Odi.GetYesNo [duMessage[areYouSure]]) THEN RETRY;	      Odi.PutMessage [duMessage[cannotScavenge]];	      Misc.PauseAndQuit[] };	   IF error = alreadyAsserted THEN CONTINUE };             Misc.ForceDriveOffline [Misc.pvHandle]; -- Physical volume must be offline      	         repairType ¬ SELECT TRUE FROM      		     doRiskyRepair => riskyRepair,		     doRepair => safeRepair,		     ENDCASE => checkOnly;      Odi.PutMessage [clearMessageAreaFirst: TRUE, message: duMessage[scavenging]];      scavengerStatus ¬ PV.Scavenge[Misc.pvHandle, repairType, doConversion];      END; -- Scavenge block          IF doRiskyRepair OR doRepair THEN       Odi.PutMessage[message: duMessage[completed],startWithNewLine: FALSE,beep: TRUE];          IF scavengerStatus = PV.noProblems THEN {       Odi.PutMessage [duMessage[noProblemFound]]; RETURN [nullResult] };	     -- Problem detected by scavenger. Print the problem report.    Odi.PutMessage [duMessage[problemsFound]];  -- "Damage detected"    -- Print scavenger report, internalStructures first    IF scavengerStatus.internalStructures # okay THEN { -- Print report if bad       Odi.PutData [dataAreaHeading: duMessage[damageReport], -- "Damage Report"      		    data: duMessage[internalStruct]];  -- "Internal Structures: "       errorMessage ¬ SELECT scavengerStatus.internalStructures FROM      		         damaged => IF repairType < riskyRepair 			     THEN duMessage[doRiskyRepair] ELSE duMessage[damaged],      		         repaired => duMessage[hasBeenRepaired],			 ENDCASE => NIL;       Odi.PutData [data: errorMessage, blankSpaces: 2] };	     -- Print the results of the other files    PrintReport [duMessage[badPageList], scavengerStatus.badPageList];    PrintReport [duMessage[bootFile], scavengerStatus.bootFile];    PrintReport [duMessage[germ], scavengerStatus.germ];    PrintReport [duMessage[pilotMicrocode], scavengerStatus.softMicrocode];    PrintReport [duMessage[diagnosticMicrocode], scavengerStatus.hardMicrocode];        RETURN [nullResult];    END;  -- ScavengePhysicalVolume--*************************************************************-- Scans the disk for new bad pages.  A user has the option to -- automatically insert bad pages in the BPT.--*************************************************************CheckDrive: Odi.OfflineDiagnosticProc =  BEGIN  ENABLE ANY => { firstOverFlowPageEncountered ¬ bptFull ¬ FALSE; REJECT };    userDesigatedTries, retryCount: CARDINAL;        IF ~volumeInfoValid THEN    	{Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];	Odi.HitAnyKeyToContinue[];};--    ValidateIDandCheckVirginity [];        -- Set up top display    scanTopDisplay.displayTitle ¬ duMessage[scanInfo];    lin1 ¬ scanTopDisplay.rows[0];    lin2 ¬ scanTopDisplay.rows[1];        lin1.rowItems[0].name ¬ duMessage[desiredScanCount];    lin1.rowItems[0].valuePosition ¬          Misc.leftEdge + duMessage[desiredScanCount].length + 2;        lin2.rowItems[0].name ¬ duMessage[scansCompleted];        item2Pos ¬ MAX [lin1.rowItems[0].name.length,  	            lin2.rowItems[0].name.length] + 15 + Misc.leftEdge;		        lin1.rowItems[0].valuePosition ¬         Misc.leftEdge + duMessage[desiredScanCount].length + 2;        lin1.rowItems[1].name ¬ duMessage[retryCount];    lin1.rowItems[1].namePosition ¬ item2Pos;    lin1.rowItems[1].valuePosition ¬ item2Pos + lin1.rowItems[1].name.length + 2;    lin2.rowItems[1].name ¬ duMessage[newBadPageCount];    lin2.rowItems[1].namePosition ¬ item2Pos;    lin2.rowItems[1].valuePosition ¬ item2Pos + lin2.rowItems[1].name.length + 2;    lin2.rowItems[1].value ¬ 0;    lin2.rowItems[0].valuePosition ¬         Misc.leftEdge + duMessage[scansCompleted].length + 2;    lin2.rowItems[0].value ¬ 0;        helpText.helpTitle ¬ duMessage [retryHelpTitle];    helpText.textBody[0] ¬ duMessage [retryHelp0];    helpText.textBody[1] ¬ duMessage [retryHelp1];    helpText.textBody[2] ¬ NIL;        userDesigatedTries ¬ Odi.GetANumber[prompt: duMessage[numberOfScans],        help: helpText,    	upperLimit: LAST[CARDINAL], defaultNumber: 1].number;    lin1.rowItems[0].value ¬ userDesigatedTries;--******************************-- %McQ    Add when approved  IF OfflineDiagInterface.userType = Manufacturing THEN {retryCount ¬ 9} ELSE    {retryCount ¬ Odi.GetANumber[prompt: duMessage[retryCount], help: helpText,    	lowLimit: 0, upperLimit: LAST[CARDINAL], defaultNumber: 9].number;};-- *****************************    lin1.rowItems[1].value ¬ retryCount;        Odi.PutTestParameters [scanTopDisplay, FALSE];        -- Get last confirmation    IF NOT Odi.GetYesNo[duMessage[areYouSure],,TRUE,TRUE] THEN {        Odi.PutMessage[duMessage[aborted]]; RETURN [nullResult] };    Misc.CheckCylinderZero[]; -- Check cylinder 0 first. Stop if defect found            -- Get current table    currentBPTOnDisk ¬ Misc.ReadCurrentBPTFromDisk [currentBPTOnDisk       ! PV.NeedsScavenging => {            Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE];            Misc.PauseAndQuit[] }];    DO -- Loop for case of RAM bad page table overflow      lin2.rowItems[0].value ¬ badPageCount ¬ 0;       bptFull ¬ firstOverFlowPageEncountered ¬ FALSE;      Odi.PutTestParameters [scanTopDisplay];            Odi.PutData [data: duMessage[badPageList], clearHeadingAndData: TRUE];      badPageCount ¬ 0;      Misc.ResetBadPageTable[scanGeneratedBPT];      FOR i: CARDINAL IN [0 .. userDesigatedTries) DO         Odi.LookForAbort[];         Odi.PutMessage[duMessage[scanning]];         FPD.Scan[Misc.pvHandle, 0, -- Misc.pagesPerCylinder, 	          -- Do not test diagnostic cylinder	 	  Misc.totalPagesOnADisk - Misc.pagesPerCylinder, retryCount             ! FPD.BadPage => { -- Save the bad pages for later use	           IF NOT Misc.InBadPageTable[p, currentBPTOnDisk] THEN {	              CollectABadPage [scanGeneratedBPT,p];		      Odi.PutData [numberAfterData: p, blankSpaces: 2];		      lin2.rowItems[1].value ¬ badPageCount;		      Odi.PutTestParameters [scanTopDisplay]};		   RESUME}];         lin2.rowItems[0].value ¬ i + 1; -- Update "Scans Completed:"         Odi.PutTestParameters [scanTopDisplay];          IF bptFull THEN EXIT;         ENDLOOP;             -- Give completion notice      Odi.PutMessage[message: IF bptFull THEN duMessage[overflowAbort]    		     ELSE duMessage[completed], beep: TRUE];      -- Handle bad page table      IF badPageCount=0 THEN Odi.PutData [data: duMessage[bptEmpty], blankSpaces: 1]      ELSE { DO -- Loop until exit      	     ENABLE Odi.AbortCurrentTest => 	            IF Odi.GetYesNo[duMessage[areYouSure],,TRUE,FALSE]		       THEN REJECT ELSE LOOP;		                      SELECT Odi.GetANumber [prompt: duMessage[badPageOptions],      			  upperLimit: 3, defaultNumber: 2 ].number FROM		  1 => { Odi.PutData[data: duMessage[badPageList], -- Redisplay BPT		                     clearHeadingAndData: TRUE];			 Misc.DisplayBPTable[scanGeneratedBPT]; LOOP };			   		  2 => { Misc.TestPagesInBadPageTable[scanGeneratedBPT]; LOOP};		    		  ENDCASE => SIGNAL Odi.AbortCurrentTest;  	       ENDLOOP };            Misc.NoQuitsYesReturns [IF bptFull THEN duMessage[overFlowRescan] 	 	              ELSE duMessage[repeatOp], bptFull];      ENDLOOP;    END; -- CheckDrive--******************************************************************-- Marking a page bad renders the page inaccessable to applications--******************************************************************EnterBadPagesIntoBadPageTable: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    ENABLE PV.NeedsScavenging => {    Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];    Misc.PauseAndQuit[] };        IF ~InitStarted THEN StartInit[];    ValidateIDandCheckVirginity[];    Misc.PrintExpandedPageHeading[FALSE, FALSE, FALSE];    DO -- Loop forever      badPage ¬ Odi.GetANumber[prompt: duMessage[pageToBeAdd], help: addHelp,            lowLimit: Misc.firstAllowableBP, upperLimit: Misc.totalPagesOnADisk-1,      	    numberIsLong: TRUE].longNumber;      Misc.ExpandPageNumber[badPage];--    IF Odi.GetYesNo[duMessage[areYouStillSure], addHelp,TRUE,TRUE] --       THEN Misc.AddABadPage [badPage] ELSE Odi.PutMessage [duMessage[aborted]];      Misc.AddABadPage [badPage];      IF ~Odi.GetYesNo[duMessage[anyMore], , TRUE, TRUE] THEN EXIT;      ENDLOOP;    IF RigidDiskDiag THEN InitStarted ¬ FALSE;    END; -- EnterBadPagesIntoBadPageTable--**********************************************-- Attempts to make an unreadable page readable--**********************************************PageScavengerProc: Odi.OfflineDiagnosticProc =  BEGIN    pageToBeScavenged: PhysicalVolume.PageNumber;    --    ValidateIDandCheckVirginity[];    pageToBeScavenged ¬ Odi.GetANumber[        prompt: duMessage[getPgToBeScavenged], help: repairHelp, lowLimit: 0,    	numberIsLong: TRUE, upperLimit: Misc.totalPagesOnADisk-1].longNumber;    Misc.PrintExpandedPageHeading [FALSE,FALSE,TRUE];    Misc.ExpandPageNumber [pageToBeScavenged];    Misc.RepairABadPage [pageToBeScavenged];     END; --PageScavengerProc<<  %KL  used to test PageScavenger problemPageScavengerProc: Odi.OfflineDiagnosticProc =  BEGIN    pageToBeScavenged: PhysicalVolume.PageNumber;    diskAddress: PilotDiskFace.DiskAddress;    ioStatus: DiskChannel.IOStatus;    msg: LONG STRING;        PrintScavengeStatus: PROC [status: PilotDiskFace.Status] = {       msg ¬ SELECT status FROM      		goodCompletion => duMessage[goodCompletion],		headerCRCError => duMessage[headerCRCError],		labelCRCError => duMessage[labelError],		labelVerifyError => duMessage[labelDoesNotMatch],		dataCRCError => duMessage[dataError],		dataVerifyError => duMessage[dataVerifyError],		headerNotFound => duMessage[headerNotFound],		notReady => duMessage[driveNotReady],		seekTimeout => duMessage[seekFailed],		ENDCASE =>  duMessage[unknown];      Odi.PutMessage [message: msg, startWithNewLine: FALSE] };        ValidateIDandCheckVirginity[];    pageToBeScavenged ¬ Odi.GetANumber[        prompt: duMessage[getPgToBeScavenged], help: repairHelp,    	numberIsLong: TRUE, upperLimit: Misc.totalPagesOnADisk-1].longNumber;    Misc.PrintExpandedPageHeading [FALSE,FALSE,FALSE];    Misc.ExpandPageNumber [pageToBeScavenged];        diskAddress ¬ Misc.ConvertPageToDiskAddress [pageToBeScavenged];        PhysicalVolume.AssertNotAPilotVolume [Misc.pvHandle -- Initiate direct access    	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];        -- Initialize operation control block    Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		      command: saveData,      		      device: Misc.deviceHandle,		      clientHeader: diskAddress,		      pageCount: 1,  -- Do it one at a time		      tries: DiskChannel.defaultTries, 		      labelPtr: Misc.labels[0],		      dataPtr: Misc.dataPages[0],		      incrementDataPtr: FALSE];        ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;    Odi.PutMessage["Reading result:"];    WITH ioStatus SELECT FROM          disk => PrintScavengeStatus[status];	 ENDCASE => NULL;    	       -- Initialize operation control block    Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		      command: restoreData,      		      device: Misc.deviceHandle,		      clientHeader: diskAddress,		      pageCount: 1,  -- Do it one at a time		      tries: DiskChannel.defaultTries, 		      labelPtr: Misc.labels[0],		      dataPtr: Misc.dataPages[0],		      incrementDataPtr: FALSE];        ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;    Odi.PutMessage["Restore result:"];    WITH ioStatus SELECT FROM          disk => PrintScavengeStatus[status];	 ENDCASE => NULL;        -- Initialize operation control block    Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		      command: saveData,      		      device: Misc.deviceHandle,		      clientHeader: diskAddress,		      pageCount: 1,  -- Do it one at a time		      tries: DiskChannel.defaultTries, 		      labelPtr: Misc.labels[0],		      dataPtr: Misc.dataPages[0],		      incrementDataPtr: FALSE];    ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;    Odi.PutMessage["Read result:"];    WITH ioStatus SELECT FROM          disk => PrintScavengeStatus[status];	 ENDCASE => NULL;        -- Initialize operation control block to verify data    Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		      command: verifyData,      		      device: Misc.deviceHandle,		      clientHeader: diskAddress,		      pageCount: 1,  -- Do it one at a time		      tries: DiskChannel.defaultTries, 		      labelPtr: Misc.labels[0],		      dataPtr: Misc.dataPages[0],		      incrementDataPtr: FALSE];    ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;    Odi.PutMessage["Verify result:"];    WITH ioStatus SELECT FROM       invalidChannel => ERROR ChangeCountMisMatch;       invalidDriveState => ERROR IllegalDriveState;       disk => PrintScavengeStatus[status];       ENDCASE ;  -- WITH case        END;>>--*****************************************-- Enter error log from manufactures' list--*****************************************EnterNewDiskErrorMap: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN   ENABLE PV.NeedsScavenging => {    Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];    Misc.PauseAndQuit[] };  --  -- Hardware dependent information hard-coded here  --  -- Dove rigid disk track layout (Per Dove Rigid Disk Layout by Bob Swenson):  --     --      Index								    Index  --        |leadig gap|sector 1|sector 2| ... |sector 15|sector 16|trailing gap|  -- Size     50 bytes    631	   631		  631       615	     181 - 286  --  --  Bytes per track = 50 + 631*15 + 615 + trailing gap = 10130 + trailing gap  --  Nominal track length = 10416 bytes.  --  trailing gap (nominal) = 286 bytes.  --  trailing gap (minimum) = 181 bytes.  --  bytesPerSector: LONG CARDINAL = 631; -- Bytes per sector except sector 16,  -- which is the last byte. Does not require a sector-trailing gap of 16 bytes  bytesPerTrack: LONG CARDINAL = 10130; -- Useful bytes on a track  leadingGap: --LONG--CARDINAL = 50; -- Bytes between physical index and first sector  trailingGapMax: LONG CARDINAL = 286;  maxTrackLength: --LONG-- CARDINAL = 10416;   beginningOfTrailingGap: LONG CARDINAL = 50 + 631*15 + 615;  byteOffset: --LONG--CARDINAL; -- Bad spot's offset from the index pulse in bytes  -- Starting sector of bad spot ((byteOffset-leadingGap)/bytesPerSector)  startingBadPage: LONG CARDINAL; -- First bad page of bad apot  firstTrackPage: LONG CARDINAL; -- First bad page of track [0..sectorsPerTrack)  badPageCount: LONG CARDINAL; -- Number of contiguous bad pages in bad spot  badSpotSize: LONG CARDINAL;  endOfBadSpot: LONG CARDINAL; -- End of a bad spot  fudge: CARDINAL ¬ 0;  -- Bad spot fudge factor   errorMapEntry: PilotDiskFace.DiskAddress; -- PageNumber in [cyl, head, sector]  lengthInBits: BOOLEAN; -- Length of bad spots can be in bits or bytes.  			 -- TRUE => unit is in bits; FALSE => unit is in bytes  inGap: BOOLEAN; -- Bad spot is in an unused gap  firstLoop: BOOLEAN ¬ TRUE;  firstSec: CARDINAL;  secondSec: CARDINAL;    IF ~InitStarted THEN StartInit[];  ValidateIDandCheckVirginity[];  IF ~volumeInfoValid THEN RETURN;    -- Set up help  helpText.helpTitle ¬ duMessage[bitsVersesBytes];  helpText.textBody[0] ¬ duMessage[inBits];  helpText.textBody[1] ¬ duMessage[inBytes];  helpText.textBody[2] ¬ NIL;    -- Information displayed on top of the data area   errorLogInfo.displayTitle ¬ duMessage[diskErrorLogInfo];  lin1 ¬ errorLogInfo.rows[0];  lin2 ¬ errorLogInfo.rows[1];    lin1.rowItems[0].name ¬ duMessage[cylinder]; -- Track info  lin1.rowItems[0].valuePosition ¬ Misc.leftEdge + duMessage[cylinder].length + 2;  lin2.rowItems[0].name ¬ duMessage[head]; -- Head info  lin2.rowItems[0].valuePosition ¬ Misc.leftEdge + duMessage[head].length + 2;    item2Pos ¬ MAX [lin1.rowItems[0].name.length,  	          lin2.rowItems[0].name.length] + 15 + Misc.leftEdge;    lengthInBits ¬ Odi.GetYesNo[duMessage[isLengthInBits], helpText, TRUE, TRUE];    -- Set up rest of display record  lin1.rowItems[1].name ¬ duMessage[byteFromIndex]; -- Starting byte  lin1.rowItems[1].namePosition ¬ item2Pos;  lin1.rowItems[1].valuePosition ¬ item2Pos + duMessage[byteFromIndex].length + 2;    lin2.rowItems[1].name ¬ -- Length of bad spot        IF lengthInBits THEN duMessage[lengthInBits] ELSE duMessage[lengthInBytes];  lin2.rowItems[1].namePosition ¬ item2Pos;  lin2.rowItems[1].valuePosition ¬ item2Pos + lin2.rowItems[1].name.length + 2;   -- Clear screen and put test bad spot info on screen  Odi.PutTestParameters [errorLogInfo, FALSE];    Odi.PutMessage [duMessage[enterData]]; -- Direction  DO -- Now loop forever until abort    originalOffset: LONG CARDINAL ¬ 0;    IF firstLoop THEN firstLoop ¬ FALSE     ELSE IF NOT Odi.GetYesNo[duMessage[anyMore],,TRUE,TRUE] THEN EXIT;         inGap ¬ FALSE; -- Initialize      -- Get the cylinder    lin1.rowItems[0].value ¬ errorMapEntry.cylinder ¬ Odi.GetANumber [      prompt: duMessage[cylinder], lowLimit: 1 ,       upperLimit: Misc.cylinders-1].number;    Odi.PutTestParameters [errorLogInfo];        -- Head    lin2.rowItems[0].value ¬ errorMapEntry.head ¬ Odi.GetANumber [        prompt: duMessage[head], lowLimit: 0, upperLimit: Misc.movingHeads-1].number;    Odi.PutTestParameters [errorLogInfo];    -- Get the byte offset from the index. This is starting point of bad spot    lin1.rowItems[1].value ¬ byteOffset ¬ Odi.GetANumber [prompt:        duMessage[byteFromIndex],lowLimit: 0, upperLimit: maxTrackLength].number;    originalOffset ¬ byteOffset;  -- Save for later use    Odi.PutTestParameters [errorLogInfo];    -- If bad spot falls in the trailing gap of the track, ignore it    IF byteOffset > beginningOfTrailingGap + 202 THEN -- Can ignore bad spot        {Odi.PutMessage [duMessage[badSpotInGap]]; LOOP };    -- Get the size of the bad spot    lin2.rowItems[1].value ¬ badSpotSize ¬ 16;    IF Odi.userType # Manufacturing THEN       {lin2.rowItems[1].value ¬ badSpotSize ¬ Odi.GetANumber [       prompt: lin2.rowItems[1].name, upperLimit: IF lengthInBits THEN         Inline.LongMult [maxTrackLength - byteOffset, Environment.bitsPerByte]         ELSE maxTrackLength - byteOffset, numberIsLong: TRUE,	 defaultNumber: 16].longNumber};    Odi.PutTestParameters [errorLogInfo];        -- Convert badSpotSize to bytes and add in a fudge factor for safety    IF lengthInBits THEN badSpotSize ¬ (badSpotSize/Environment.bitsPerByte);    -- The end point for the bad spot.    IF (originalOffset + badSpotSize) < leadingGap - 1THEN { -- In leading gap       Odi.PutMessage [duMessage[badSpotInGap]]; LOOP }; -- OK to ignore it.        -- Now calculate the end of the bad spot    endOfBadSpot ¬ badSpotSize + byteOffset;    IF endOfBadSpot >= beginningOfTrailingGap THEN -- Ignore anything beyond       endOfBadSpot ¬ beginningOfTrailingGap;	   -- beginningOfTrailingGap    fudge ¬ CARDINAL[(byteOffset*2)/100]; -- 1% plus 1% safety    -- Starting sector of bad spot on the track     firstSec ¬        CARDINAL[(byteOffset - leadingGap - fudge)/bytesPerSector];    secondSec ¬        CARDINAL[(byteOffset - leadingGap + fudge)/bytesPerSector];    IF firstSec > 14 THEN firstSec ¬ 15;    IF secondSec > 14 THEN secondSec ¬ 15;        errorMapEntry.sector ¬ firstSec;           -- Now convert starting bad sector into a Pilot page    startingBadPage ¬ Misc.ConvertDiskAddressToPage [errorMapEntry];    firstTrackPage ¬ startingBadPage MOD Misc.sectorsPerTrack;        -- Number of contiguous bad pages    badPageCount ¬ 1 + secondSec - firstSec;            Odi.PutData [dataAreaHeading: duMessage[pilotBadPages], -- Resultant Bad Pages:    		 clearHeadingAndData: TRUE]; -- Data Area heading     FOR i: LONG CARDINAL IN [0 .. badPageCount) DO  -- Display pages      IF (firstTrackPage + i) = Misc.sectorsPerTrack THEN EXIT;      Odi.PutData [  -- Display the resultant bad pages    	  numberAfterData: startingBadPage + i, blankSpaces: 2];      ENDLOOP;    IF RigidDiskDiag THEN InitStarted ¬ FALSE;--    IF Odi.GetYesNo [duMessage[enterIntoBPT],,TRUE,TRUE] THEN --       IF Odi.GetYesNo [duMessage[areYouStillSure],,TRUE,FALSE] THEN {          Odi.PutData [data: duMessage[pagesMarkedBad], numOfBlankLines: 1];          FOR j: LONG CARDINAL IN [0..badPageCount) DO	     IF (firstTrackPage + j) = Misc.sectorsPerTrack THEN EXIT;	     Misc.AddABadPage [startingBadPage + j];             Odi.PutData [  -- Display the pages marked bad	         numberAfterData: startingBadPage + j, blankSpaces: 2];--	     ENDLOOP }	     ENDLOOP;--       ELSE Odi.PutData[data: duMessage[noBPwritten], numOfBlankLines: 1]--    ELSE Odi.PutData[data: duMessage[noBPwritten], numOfBlankLines: 1];    ENDLOOP;    IF RigidDiskDiag THEN InitStarted ¬ FALSE;        RETURN[nullResult];    END;  -- EnterNewDiskErrorMap        --******************************************************************************-- Reformats the track containing the bad page. Store a page back only if the-- sector containing the bad page is successfully formatted and found good.--******************************************************************************FixABrokenHeader: Odi.OfflineDiagnosticProc =  BEGIN  ENABLE PV.NeedsScavenging => {          Odi.PutMessage[message: duMessage[unableToAccessPDS],beep: TRUE];	 CONTINUE };--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Declare pointers, variables, types  and operations--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    -- Saves a page in ram    saveCommand: CompatibilityDiskFace.Command = [verify, read, read];    -- Restores the  page saved in ram back to the disk after rewriting (format)    -- header on the track containing the page with the bad header    restoreCommand: CompatibilityDiskFace.Command = [verify, write, write];    -- formatCommand: CompatibilityDiskFace.Command = [write, write, write];        pageToBeFixed: PV.PageNumber; -- Obtained from the user     firstPageOnTrack: PV.PageNumber; -- First page of track containing bad page    diskAddress: PilotDiskFace.DiskAddress; -- PageNumber in [cyl, head, sector]    saveLabelBootLinks: ARRAY [0..2) OF WORD;    firstLoop: BOOLEAN ¬ TRUE;  -- First loop--  ValidateIDandCheckVirginity[];   -- Prepare positionally fixed display data  item2Pos ¬ Misc.leftEdge;  paramsForFBH.displayTitle ¬ duMessage[brokenPageInfo];  lin1 ¬ paramsForFBH.rows[0];  lin1.rowItems[0].namePosition ¬ item2Pos;  lin1.rowItems[0].name ¬ duMessage[page];  item2Pos ¬ item2Pos + duMessage[page].length + 1;  lin1.rowItems[0].valuePosition ¬ item2Pos;    item2Pos ¬item2Pos + 10;  lin1.rowItems[1].namePosition ¬ item2Pos;  lin1.rowItems[1].name ¬ duMessage[header];    item2Pos ¬ item2Pos + duMessage[header].length +     MAX[duMessage[lost].length, duMessage[saved].length, duMessage[damaged].length] + 3;	           lin1.rowItems[2].namePosition ¬ item2Pos;  lin1.rowItems[2].name ¬ duMessage[data];      DO  -- Loop until abort  ENABLE UNWIND => Misc.SetDriveStateTo[inactive];     -- Clear RAM bad page table    Misc.ResetBadPageTable[trackBadPages];        -- Get page to be fixed from user    pageToBeFixed ¬ Odi.GetANumber[prompt: duMessage[enterAPageNumber],    	  numberIsLong: TRUE, lowLimit: 0, 	  upperLimit: Misc.totalPagesOnADisk-1].longNumber;    diskAddress ¬ Misc.ConvertPageToDiskAddress[pageToBeFixed];    firstPageOnTrack ¬ pageToBeFixed - diskAddress.sector;        lin1.rowItems[0].value ¬ pageToBeFixed;    lin1.rowItems[1].stringValue ¬ NIL;    lin1.rowItems[2].stringValue ¬ NIL;    Odi.PutTestParameters [paramsForFBH, FALSE];  -- Clear screen and print info<<    PhysicalVolume.AssertNotAPilotVolume [Misc.pvHandle -- Initiate direct access    	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];>>    Misc.SetDriveStateTo[direct];    Misc.SaveATrack[pageToBeFixed];           DO  -- Give user a chance to review save status    abort: CARDINAL = 1; review: CARDINAL = 2; continue: CARDINAL = 3;    SELECT Odi.GetANumber[prompt: duMessage[trackOption],upperLimit: 3,                          defaultNumber: continue].number FROM       abort => SIGNAL Odi.AbortCurrentTest;       review => { Odi.PutData[clearDataAreaOnly: TRUE];       		   FOR sectorNumber: CARDINAL IN [0..Misc.sectorsPerTrack) DO       		       Misc.ExpandPageNumber[firstPageOnTrack+sectorNumber];		       Misc.PrintStatus[Misc.saveOpStatus[sectorNumber],		                        Misc.saveStatusPosition];		       Odi.HitAnyKeyToContinue[];		       ENDLOOP };       ENDCASE => EXIT;       ENDLOOP;		           -- Format track containing the bad page    Misc.NoQuitsYesReturns[duMessage[fmtTrack], defaultToNo];    Odi.PutMessage[duMessage[formatting]];    badPageCount ¬ 0;        Misc.ForceDriveOffline[Misc.pvHandle];    PhysicalVolume.AssertNotAPilotVolume [Misc.pvHandle -- Initiate direct access    	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];    FPD.Format[h: Misc.pvHandle, firstPage: firstPageOnTrack,     	       count: Misc.pagesPerTrack	! FPD.BadPage => { CollectABadPage[trackBadPages,p]; RESUME }];    Odi.PutMessage[message: duMessage[completed], startWithNewLine: FALSE];        -- Check 20 times to make sure cylinder is good    FOR k: CARDINAL IN [0..20) DO      FPD.Scan[Misc.pvHandle, firstPageOnTrack, Misc.sectorsPerTrack, 0        ! FPD.BadPage => { CollectABadPage[trackBadPages,p]; RESUME }];      ENDLOOP;        IF badPageCount # 0 THEN {  -- Found bad pages on the track       ENABLE Odi.AbortCurrentTest => CONTINUE;  -- Must carry out RESTORE op       markBad: CARDINAL = 1; test: CARDINAL = 2;       Odi.PutMessage[message: duMessage[badPagesFound]];       Odi.PutData[data: duMessage[badPageList], clearDataAreaOnly: TRUE];       Misc.DisplayBPTable [trackBadPages];       SELECT Odi.GetANumber[prompt: duMessage[trackBPdisposition], upperLimit: 2,      			     defaultNumber: 2].number FROM	      markBad => Misc.AddBadPageTable[trackBadPages, TRUE];	      ENDCASE => Misc.TestPagesInBadPageTable[trackBadPages] }; -- Test        -- RESTORE track pages     Odi.PutMessage[duMessage[restoringData]];    Misc.PrintExpandedPageHeading [TRUE,TRUE,FALSE];    Misc.labeledOp­ ¬ [command: restoreCommand, -- [verify, write, write]      		      device: Misc.deviceHandle,		      clientHeader: diskAddress,		      pageCount: 1,  -- Do it one at a time		      tries: DiskChannel.defaultTries,   		      labelPtr: Misc.labels[0],		      dataPtr: Misc.dataPages[0],		      incrementDataPtr: FALSE];		          -- Initiate direct access again to restore the data<<    Misc.SetDriveStateTo[inactive];    PhysicalVolume.AssertNotAPilotVolume [Misc.pvHandle];>>    Misc.SetDriveStateTo[direct];    FOR trackPage: CARDINAL IN [0..Misc.pagesPerTrack) DO  -- Restore loop      thisPage: LONG CARDINAL;      damagedPage: BOOLEAN;      thisPage ¬ firstPageOnTrack + trackPage;      Misc.ExpandPageNumber[thisPage];      Misc.labeledOp­.clientHeader.sector ¬ trackPage;      Misc.labeledOp­.labelPtr ¬ Misc.labels[trackPage];  -- label      Misc.labeledOp­.dataPtr ¬ Misc.dataPages[trackPage];  -- data      Misc.labeledOp­.pageCount ¬ 1;  -- Restore page at a time      Misc.PrintStatus[Misc.saveOpStatus[trackPage], Misc.saveStatusPosition];      -- build a new correct label, keeping only a possible bootLink  SPL      << IF (Misc.saveOpStatus[trackPage] # goodCompletion) THEN  >>       saveLabelBootLinks ¬ Misc.labels[trackPage].dontCare;      Misc.labeledOp.labelPtr­ ¬ LOOPHOLE[CompatibilityDiskFace.zeroLabel];      CompatibilityDiskFace.SetLabelFilePage[Misc.labeledOp.labelPtr, thisPage];      Misc.labeledOp.labelPtr.dontCare ¬ saveLabelBootLinks;      -- Restore whatever that was saved      ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;      damagedPage ¬ FALSE;      WITH ioStatus SELECT FROM	invalidChannel => ERROR ChangeCountMisMatch;	invalidDriveState => ERROR IllegalDriveState;	disk => { 	  Misc.PrintStatus[status, Misc.restoreStatusPosition];	    IF thisPage = pageToBeFixed THEN { -- Print page result	    -- Header status	    -- fooXXX this SELECT status stuff needs more thought	    --	    lin1.rowItems[1].stringValue ¬ SELECT status FROM	    --	      goodCompletion, labelVerifyError, labelCRCError,	      goodCompletion, reserved9, reserved6,	      dataVerifyError, dataCRCError => duMessage[saved],		 	      headerCRCError, headerNotFound => duMessage[damaged],	      	      ENDCASE => duMessage[unknown];	    -- Status of data	    lin1.rowItems[2].stringValue ¬ SELECT status FROM	      goodCompletion => duMessage[saved],	      --	      dataCRCError, dataVerifyError, labelVerifyError, labelCRCError	      dataCRCError, dataVerifyError, reserved9, reserved6	      => duMessage[damaged],		 	      ENDCASE => duMessage[unknown];	      IF status = goodCompletion THEN {damagedPage ¬ FALSE}	      					ELSE {damagedPage ¬ TRUE};};};	      	ENDCASE ;  -- WITH case	-- fooXXX	-- perform damagedPage logging stuff here, and do not procede if        -- any logging problems occur.        -- also need to post to the user which Logical Volume needs scavenging.        -- also, are we catching PhysicalVolumeExtras.Error      correctly????        -- fooXXX	IF damagedPage THEN 	  Misc.AddADamagedPage[thisPage];       ENDLOOP;  -- Restore loop    Odi.PutMessage[message: duMessage[completed], startWithNewLine: FALSE];    Odi.PutTestParameters[paramsForFBH];    Misc.SetDriveStateTo[inactive];    Misc.NoQuitsYesReturns [duMessage[anyMore], defaultToYes];    ENDLOOP;  -- Repeat operation loop    END; -- FixABrokenHeader--******************************************************************************-- ResetBadPageTable creates a new bad page table by creating a new physical-- volume. All data are destroyed.--******************************************************************************ResetBadPageTable: Odi.OfflineDiagnosticProc =  BEGIN   ENABLE PV.NeedsScavenging => {         Odi.PutMessage[message: duMessage[unableToAccessPDS],beep: TRUE];	 Misc.PauseAndQuit[] };        ValidateIDandCheckVirginity[];    IF NOT Odi.GetYesNo [duMessage[destroyContents],,TRUE,TRUE] THEN {       Odi.PutMessage[message: duMessage[aborted]]; RETURN [nullResult] };    -- First try to save bad page table    currentBPTOnDisk ¬ Misc.ReadCurrentBPTFromDisk [currentBPTOnDisk];    IF currentBPTOnDisk.badPageCount # 0 THEN       Odi.PutMessage[duMessage[originalBPSaved]];    Misc.NoQuitsYesReturns[duMessage[areYouStillSure], defaultToNo];    Odi.PutMessage [duMessage[createPV]];    Misc.pvID ¬ PhysicalVolume.CreatePhysicalVolume [Misc.pvHandle, duMessage[RD0]];    volumeInfoValid ¬ FALSE;    Odi.PutMessage [message: duMessage[completed], startWithNewLine: FALSE ];        IF currentBPTOnDisk.badPageCount # 0 THEN {       ENABLE Odi.AbortCurrentTest => CONTINUE;              Odi.PutData[data: duMessage[badPageList], clearHeadingAndData: TRUE];       Misc.DisplayBPTable [currentBPTOnDisk];       IF NOT Odi.GetYesNo[duMessage[discardOldBPT],,TRUE,FALSE] THEN -- Select bp          Misc.TestPagesInBadPageTable[currentBPTOnDisk] };        Misc.ForceDriveOffline [Misc.pvHandle]; -- Offline drive           RETURN [nullResult];    END; -- ResetBadPageTable--******************************************************************************-- Test bad pages--******************************************************************************TestBadPages: Odi.OfflineDiagnosticProc =  BEGIN    pageUnderTest: PV.PageNumber;    --    ValidateIDandCheckVirginity[];    Misc.PrintExpandedPageHeading[FALSE,FALSE,FALSE];      DO -- Loop until abort      pageUnderTest ¬ Odi.GetANumber[prompt: duMessage[enterAPageNumber],  	 numberIsLong: TRUE, upperLimit: Misc.totalPagesOnADisk-1].longNumber;      Misc.ExpandPageNumber[pageUnderTest];      Misc.TestABadPage[pageUnderTest];      Misc.NoQuitsYesReturns[duMessage[anyMore],defaultToYes];      ENDLOOP;    END; -- TestBadPages--******************************************************************************-- Build up all the data structures for this package, which has three menu nodes--******************************************************************************InitializePackage: PROCEDURE = BEGIN--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Third level menu - for entering bad pages manually--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Create the test items for this node  -- Get a TestItemsForThisNode to hold all the TestItems for this node  thirdLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [2]; -- 2 selections    -- Enter Bad Pages Into Bad Page Table Manually  pTestItem ¬ Odi.GetATestItem [];  -- A test container  pTestItem.itemName ¬ duMessage [enterBadPageIntoBPT];  -- Test name  pTestItem.test ¬ EnterBadPagesIntoBadPageTable;  -- Actual test procedure  pTestItem.itemExplanation ¬ duMessage [enterBadPageIntoBPTExp]; -- Online help  thirdLevelMenuSelections.nodeItems [0] ¬ pTestItem;  -- Store test item  -- Enter A New Disk's Error Map Into The Bad Page Table  pTestItem ¬ Odi.GetATestItem [];  -- A test container  pTestItem.itemName ¬ duMessage [enterManufacturerEM];  -- Test name  pTestItem.test ¬ EnterNewDiskErrorMap;  -- Actual test procedure  pTestItem.itemExplanation ¬ duMessage [enterManufacturerEMExp]; -- Online help  thirdLevelMenuSelections.nodeItems [1] ¬ pTestItem;  -- Store test item-- Assign tests to each user class. The same for all except for normal users  -- System Administrator selections... Same for all other user classes  pAdminSelections ¬ Odi.GetASelectionArray [2];  -- 2 selections  pAdminSelections.selections[0] ¬ enterByPageNumber;  -- First menu item  pAdminSelections.selections[1] ¬ enterByErrorLog;  -- Second.    -- Encapsulate all the items in an AMenuOfSelections object  thirdLevelMenuNode ¬ Odi.GetAMenuOfSelections [];  -- Node container  thirdLevelMenuNode.menuTitle ¬ duMessage [manualBadPageEntry];  thirdLevelMenuNode.menuHelp ¬ NIL;  -- Not needed here  thirdLevelMenuNode.userSelections ¬ NIL; -- None allowed  thirdLevelMenuNode.adminSelections ¬ pAdminSelections;  thirdLevelMenuNode.seSelections ¬ pAdminSelections;  thirdLevelMenuNode.manufacturingSelections ¬ pAdminSelections;  thirdLevelMenuNode.programmerSelections ¬ pAdminSelections;  thirdLevelMenuNode.testItemsForThisNode ¬ thirdLevelMenuSelections;--~~~~~~~~~~~~~~~~~~~~~~~~~~-- Second level menu stuffs --~~~~~~~~~~~~~~~~~~~~~~~~~~-- secondLevelMenuSelections ­ holds pointers to all the data structures/item in -- this menu node   --8 selections in secondLevelMenuNode  secondLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [8];  -- 8 selections  -- Display Bad Page Table         pTestItem ¬ Odi.GetATestItem [];  -- A test container  pTestItem.itemName ¬ duMessage [displayBPT];  -- Test name     pTestItem.test ¬ DiskUtilityMiscDove.DisplayBadPageTable;  -- Actual test procedure  pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ duMessage [displayBPTExp]; -- Online help  secondLevelMenuSelections.nodeItems [0] ¬ pTestItem; -- Store test item    -- Enter Bad Pages Into Bad Page Table Manually. Selects a submenu  pTestItem ¬ Odi.GetATestItem [];  -- A test container  pTestItem.itemName ¬ duMessage [manualBadPageEntry];  -- Test name  pTestItem.test ¬ NIL;  -- Actual test procedure  pTestItem.subMenu ¬ thirdLevelMenuNode;  -- Maunal bad page entry procedures  pTestItem.itemExplanation ¬ duMessage [byPageNumberOrEM]; -- Online help  secondLevelMenuSelections.nodeItems [1] ¬ pTestItem;  -- Store test item    -- Reconstruct Bad Page Header  pTestItem ¬  Odi.GetATestItem [];  -- A test container  pTestItem.itemName ¬ duMessage [rewriteBadPageHeader];  -- Test name  pTestItem.test ¬ FixABrokenHeader;   -- Procedure   pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ duMessage [rewriteBadPageExp]; -- Online help.  secondLevelMenuSelections.nodeItems [2] ¬ pTestItem;  -- Store TestItem.    -- Check Drive For New Bad Pages  pTestItem ¬  Odi.GetATestItem [];  -- CheckDrive  pTestItem.itemName ¬ duMessage[checkDrive]; --"Scan Drive For Bad Pages"  pTestItem.test ¬ CheckDrive;  -- Proc  pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ duMessage [checkDriveExpl];  -- Online help.  secondLevelMenuSelections.nodeItems [3] ¬ pTestItem;  -- Store TestItem pointer.    -- Page Scavenger  pTestItem ¬  Odi.GetATestItem [];  -- PageScavengerProc  pTestItem.itemName ¬ duMessage[pageScavenger];  pTestItem.test ¬ PageScavengerProc;  -- Proc  pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ duMessage [pageScavengerExp];  secondLevelMenuSelections.nodeItems [4] ¬ pTestItem;    -- Reset Bad Page Table  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ duMessage[resetBadPageTable];  pTestItem.test ¬ ResetBadPageTable;  pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ duMessage [resetExpl];  secondLevelMenuSelections.nodeItems [5] ¬ pTestItem;    -- Test Bad Pages  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ duMessage[testBadPages];  pTestItem.test ¬ TestBadPages;  pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ duMessage[testBadPagesExp];  secondLevelMenuSelections.nodeItems [6] ¬ pTestItem;  -- Print Bad Page Table  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ duMessage[printBadPageTable];  --"Print Bad Page Table"  pTestItem.test ¬ DiskUtilityMiscDove.PrintBadPageTable;  pTestItem.subMenu ¬ NIL;  pTestItem.itemExplanation ¬ NIL;  secondLevelMenuSelections.nodeItems [7] ¬ pTestItem;  -- Assign second level tests for the different classes of users.  -- Normal Users  pUserSelections ¬ Odi.GetASelectionArray [3];  -- 3 selection.  pUserSelections.selections[0] ¬ displayBadPageTable;  pUserSelections.selections[1] ¬ checkDriveForBadPages;  pUserSelections.selections[2] ¬ scavengeAPage;-- System Administrators    pAdminSelections ¬ Odi.GetASelectionArray [7]; -- 7 selections.  pAdminSelections.selections[0] ¬ displayBadPageTable;  pAdminSelections.selections[1] ¬ checkDriveForBadPages;  pAdminSelections.selections[2] ¬ manualBadPageEntry;  pAdminSelections.selections[3] ¬ scavengeAPage;  pAdminSelections.selections[4] ¬ fixBadPageheader;  pAdminSelections.selections[5] ¬ resetBPT;  pAdminSelections.selections[6] ¬ testSuspectPages;  -- Manufacturing and Programmers have same selections  pManufacturingSelections ¬ Odi.GetASelectionArray [8]; -- 8 selections.  pManufacturingSelections.selections[0] ¬ displayBadPageTable;  pManufacturingSelections.selections[1] ¬ checkDriveForBadPages;  pManufacturingSelections.selections[2] ¬ manualBadPageEntry;  pManufacturingSelections.selections[3] ¬ scavengeAPage;  pManufacturingSelections.selections[4] ¬ fixBadPageheader;  pManufacturingSelections.selections[5] ¬ resetBPT;  pManufacturingSelections.selections[6] ¬ testSuspectPages;  pManufacturingSelections.selections[7] ¬ printBadPageTable;  -- Wrap up all the items in secondLevelMenuNode ­. This will be assigned to-- the subMenu field of the selection that will select the Bad Page Utilities-- menu.  secondLevelMenuNode ¬ Odi.GetAMenuOfSelections [];  -- Node container  secondLevelMenuNode.menuTitle ¬ duMessage [badPageUtilities];  secondLevelMenuNode.menuHelp ¬ NIL; -- None  secondLevelMenuNode.userSelections ¬ pUserSelections;  secondLevelMenuNode.adminSelections ¬ pAdminSelections;  secondLevelMenuNode.seSelections ¬ pAdminSelections;  secondLevelMenuNode.manufacturingSelections ¬ pManufacturingSelections;  secondLevelMenuNode.programmerSelections ¬ pManufacturingSelections;  secondLevelMenuNode.testItemsForThisNode ¬ secondLevelMenuSelections;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs - 3 possible selections--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Get a container to hold all items of the top menu node. This is passed to the-- Control Module.  topLevelMenuNode ¬ Odi.GetAMenuOfSelections [];-- There are 4 selections for the top menu; so we need a TestItemsForThisNode -- that can hold 4 pointers to the different TestItems.  topLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [4];  -- For each of the selections, an instance of TestItem is needed.-- We start with FormatRigidDisK.  -- Format A Rigid Disk  pTestItem ¬  Odi.GetATestItem []; -- FormatRigidDisK  pTestItem.itemName ¬ duMessage [formatDisk];  -- "Format Rigid Disk"  pTestItem.test ¬ FormatRigidDisK; -- The actual procedure  pTestItem.itemExplanation ¬ duMessage [formatDiskExp]; -- Online help.  topLevelMenuSelections.nodeItems [0] ¬ pTestItem; -- Store TestItem pointer.  -- Run Physical Volume Scavenger  pTestItem ¬  Odi.GetATestItem []; -- ScavengePhysicalVolume  pTestItem.itemName ¬ duMessage [runPVScavenger]; -- "Run Physical Volume Scavenger"  pTestItem.test ¬ ScavengePhysicalVolume; -- Procedure  pTestItem.itemExplanation ¬ duMessage [PVScavengerExp];  -- Online help.  topLevelMenuSelections.nodeItems [1] ¬ pTestItem;  -- Store TestItem pointer.  -- Bad Page Utilities  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ duMessage [badPageUtilities];   pTestItem.test ¬ NIL; -- Not a test. Selects a submenu.   pTestItem.subMenu ¬ secondLevelMenuNode; -- Bad Page Utilities submenu  pTestItem.itemExplanation ¬ duMessage [badPageUtilitiesExp]; -- Online help.  topLevelMenuSelections.nodeItems [2] ¬ pTestItem; -- Store TestItem pointer.  -- Head Retraction Utility	  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ duMessage [headRetract]; --"Head Retraction"   pTestItem.test ¬ DiskUtilityMiscDove.HeadRetraction; -- Procedure   pTestItem.itemExplanation ¬ duMessage [headRetractExp]; -- Online help.  topLevelMenuSelections.nodeItems [3] ¬ pTestItem; -- Store TestItem pointer.-- Assign tests to different classes of users.  -- Normal Users - 3 selections. STC, add headRetraction 14-Sep-87  9:37:25  pUserSelections ¬ Odi.GetASelectionArray [3];  -- 3 selections  pUserSelections.selections[0] ¬ scavengePhyscalVolume;  pUserSelections.selections[1] ¬ badPageUtility;  pUserSelections.selections[2] ¬ headRetraction;-- System Administrators - 4 selections.  pAdminSelections ¬ Odi.GetASelectionArray [4]; -- Allowed to make 4 selections.  pAdminSelections.selections[0] ¬ formatARigidDisc;  pAdminSelections.selections[1] ¬ scavengePhyscalVolume;  pAdminSelections.selections[2] ¬ badPageUtility;  pAdminSelections.selections[3] ¬ headRetraction; -- STC, 14-Sep-87  9:36:47    -- Danger - 4 selections. (manufacturingSelections, programmerSelections)  pDangerSelections ¬ Odi.GetASelectionArray [4]; -- Allowed to make 4 selections.  pDangerSelections.selections[0] ¬ formatARigidDisc;  pDangerSelections.selections[1] ¬ scavengePhyscalVolume;  pDangerSelections.selections[2] ¬ badPageUtility;  pDangerSelections.selections[3] ¬ headRetraction;  -- Field service, Manufacturing personnel and programmers have same selections.-- Wrap all top level menu items up in topLevelMenuNode.  topLevelMenuNode.menuTitle ¬ duMessage [topLevelMenuTitle]; -- Optional.  topLevelMenuNode.menuHelp ¬ NIL;  topLevelMenuNode.userSelections ¬ pUserSelections;  topLevelMenuNode.adminSelections ¬ pAdminSelections;  topLevelMenuNode.seSelections ¬ pAdminSelections;  topLevelMenuNode.manufacturingSelections ¬ pDangerSelections;  topLevelMenuNode.programmerSelections ¬ pDangerSelections;  topLevelMenuNode.testItemsForThisNode ¬ topLevelMenuSelections;-- Allocate RAM bad page tables  preFormatBPT ¬ Misc.GetABlankBadPageTable[maxNumberOfBadPages];  formatGeneratedBPT ¬ Misc.GetABlankBadPageTable[maxNumberOfBadPages];  scanGeneratedBPT ¬ Misc.GetABlankBadPageTable[maxNumberOfBadPages];  currentBPTOnDisk ¬ Misc.GetABlankBadPageTable[maxNumberOfBadPages];  trackBadPages ¬ Misc.GetABlankBadPageTable[Misc.sectorsPerTrack];-- Prepare help texts here    addHelp ¬ Odi.GetAHelpText [3]; -- Help text for adding bad pages  addHelp.helpTitle ¬ duMessage [addHelpTitle];  addHelp.textBody[0] ¬ duMessage [addHelp0];  addHelp.textBody[1] ¬ duMessage [addHelp1];  addHelp.textBody[2] ¬ duMessage [addHelp2];    repairHelp ¬ Odi.GetAHelpText [2]; -- Help text for Page Scavenger  repairHelp.helpTitle ¬ duMessage [repairHelpTitle];  repairHelp.textBody[0] ¬ duMessage [repairHelp0];  repairHelp.textBody[1] ¬ duMessage [repairHelp1];-- Prepare positionally fixed display data  fmtTopDisplay ¬ Misc.GetADisplayRecord[3,3];  -- For FormatRigidDisK  scanTopDisplay ¬ Misc.GetADisplayRecord[2,2];  -- For CheckDrive  errorLogInfo ¬ Misc.GetADisplayRecord[2,2];  -- For EnterNewDiskErrorMap  paramsForFBH ¬ Misc.GetADisplayRecord [1,3]; -- For FixABrokenHeader  END;  -- InitializePackage.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- added by STC to start initiation--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~StartInit: PUBLIC PROCEDURE =    BEGIN    DiskUtilityMsgKeysDove.InitializeDiskUtilMsgKeys[! Runtime.StartFault => CONTINUE];--    START Messages [! Runtime.StartFault => CONTINUE]; Fire up Msg Key System    helpText ¬ Odi.GetAHelpText [3]; -- General help text used everywhere            -- Ask user if disk is virgin    helpText.helpTitle ¬ duMessage[unformattedDisk];    helpText.textBody[0] ¬ duMessage[neverFormatted];    helpText.textBody[1] ¬ duMessage[formatFirst];    helpText.textBody[2] ¬ NIL;    IF ~RigidDiskDiag THEN        {virginDisk ¬ NOT Odi.GetYesNo [duMessage[isDiskFormatted], helpText, TRUE, TRUE]};        START SupportPackage [! Runtime.StartFault => CONTINUE];    InitializePackage [];  -- Build up the menu tree and procedural data base        Misc.InitOpPtrs [];  -- set up arrays of label and data ptrs  START DiagDiskMkTime.DiagDiskMkTimeImpl [! Runtime.StartFault => CONTINUE];    DiagDiskTime.SetRealTimeClock [displayMsg: TRUE        ! DiagDiskTime.RealTimeClockFailure => {	     Odi.PutData[data: DiagDiskMkTime.mkTime[rTCFailure],	                 clearHeadingAndData: TRUE] }];    START SysConfigHeadDove [! Runtime.StartFault => CONTINUE];	--added for head retraction    InitStarted ¬ TRUE;-- Ask user if the disk is a virgin disk or not    subVolumeTable ¬ Odi.DiagHeap.NEW [ -- Allocate storage for new table  		   Misc.SubVolumeTable[PV.maxSubvolumesOnPhysicalVolume]];    IF Misc.ManufDskCkOut THEN virginDisk ¬ TRUE;  IF NOT virginDisk THEN  -- Try to check PV pages     volumeInfoValid ¬ Misc.CheckPVPages[];  END;  -- StartInit--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDURE exported to the Control Module.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RunFormatterScavengerBPU: PUBLIC Odi.ClientPackage =  BEGIN      --~~~~~~~~~~~~~~~~~    -- Main line code.    --~~~~~~~~~~~~~~~~~    RigidDiskDiag ¬ FALSE;    Misc.ManufDskCkOut ¬ FALSE;    StartInit[];        RETURN [topLevelMenuNode];  -- Pass pointer to root node to Control Module  END; -- Main line code  END...  OfflineDiskUtilitiesDove.mesa    LOGCreated by KL on 1-Apr-85 5-Dec-85: PrintBadPageTable added by RRP 3-Jan-86: 12.2 (1.2) changes made by KL (Ignore bad pages in current BPT, etc)16-Dec-86: SPL, comment for RigidDiskFormat changes made by PJT 9-Jan-87 SPL fold pre-release changes made by SPL & RK into PJTs new version  INCLUDING 12-Sep-86 by rk:  Added HeadRetraction procedure            17-Sep-86 by SPL:  Added call to InitOpPtrs.            26-Sep-86 by rk:  Fixed HeadRetraction procedure.12-Jan-87: SPL, TC: defaultNumber to 2512-Jan-87: SPL: made headRetraction available only to manufacturingSelections and programmerSelections13-Jan-87: SPL, STC: merge changes in stop formatting2-Mar-87  9:49:03 by STC, changed FormatRigidDisK to GoFormatDisk 3-Mar-87 11:18:30 by STC, added InitStarted and StartInit 5-Mar-87 14:41:59 by STC, added RigidDiskDiag to skip many pauses for use14-Mar-87 16:25:23 by STC, match Bad Page address calculate with hardware. 17-Mar-87 20:05:45 by STC, make preFormatBPT, virginDisk, StartInit PUBLIC. 24-Mar-87 10:49:41 by STC, change messages system24-Mar-87 21:28:00 by STC, set virginDisk when ManufDskCkOut & NeedsScavenging28-Mar-87 15:44:47 by STC, set EnterBadPagesIntoBadPageTable is PUBLIC28-Mar-87 15:44:47 by STC, set EnterBadPagesIntoBadPageTable is PUBLIC 6-Apr-87 16:15:33 STC, add more patterns in FormatRigidDisk 8-Apr-87 10:36:55, make default bad spot length 16 bits 9-Apr-87 10:51:08, reset InitStarted if RigidDiskDiag, use EXIT 1-May-87 15:44:49, fix bug in CollectABadPage STOP when badPageCount too big12-May-87 10:23:49, Allow to start Diagnostics even unableToAccessPDS, cut size13-May-87  7:48:42, PUBLIC currentBPTOnDisk15-May-87  7:17:09, use CollectNewBadPage for formatGeneratedBPT23-May-87 16:19:16, use CheckPVPages to initialize Diag26-May-87  4:54:24, display preBPT only if not empty, fix bug in ScavengePV29-May-87 15:38:16, removed ValidateIDandCheckVirginity in PageScavengerProc and TestBadPages 9-Jun-87 14:36:10, Allow to Scavenge page 030-Jun-87 15:11:25, Correct Formatter message display space 6-Jul-87 17:18:46, make HeadRetraction Public 9-Jul-87 15:24:46, surface retries count in Formatter26-Aug-87 14:53:38, ReRead badPages in Cylinder0, remove EnterBadPage confirmation 1-Sep-87 16:58:10, STC, default passcount of Formatter is 12 or 100 8-Sep-87 16:01:29, STC, default passcount of Formatter back to 2513-Sep-87 11:30:14, move HeadRetraction to DiskUtilityMiscImplDove, use seek first13-Sep-87 11:30:14, STC, HeadRetraction for everyone18-Sep-87 15:27:08, STC, Formatter in Diag, Format default 96 passes19-Sep-87 17:39:56, STC, hold display of the Formatter result until hit a key21-Sep-87  9:10:03, STC, init ManufDskCkOut in RunFormatterScavengerBPU21-Sep-87 18:13:42, STC, passes is also optional for Manufacture's Formatter30-Sep-87 10:36:39, STC, convert to 14.0, changes in FormatPilotDisk15-Oct-87 10:03:02, STC, add DiskUtilSelfDescr stuff, GetStatusMsg15-Oct-87 10:03:02, STC, adjust to passesLeft of Format18-Nov-87 11:06:30, STC, optional retryCount (Scan bad page)if ~Manufacturing17-Dec-87 16:22:20, STC, initialize badPageCount, cyl0badPageCount28-Jan-88 14:48:51, STC, volumeInfoValid = TRUE after Format23-Sep-88  9:46:21, STC, convert to Labelless from SPL, 19-Nov-86 16:26:21 9-Oct-88 17:24:50, STC, add CheckPVPages in ValidateIDandCheckVirginity
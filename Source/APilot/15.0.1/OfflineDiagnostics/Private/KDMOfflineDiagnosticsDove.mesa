-- File: KDMOfflineDiagnosticsDove.mesa - last edit:-- KXW		       12-Mar-87 17:54:23---- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.---- This file contains Dove offline diagnostics for the keyboard, display and-- mouse.-- -- Special note: KDMMessagesDove.mesa and KDMMessagesImplDove.mesa (message keys-- 		 and there implementations) must be compiled before this module--		 is compiled.--DIRECTORY  DisplaySpecialFaceDaisy,  DisplayIOFaceDove,  DoveInputOutput,  DoveHandlerIDs,  Environment,  Inline,  ProcessorFace,  String,  SysConfigChannelDefs,  TTY			USING [ PutChar],  UserTerminal 	USING [ Background, Coordinate, CursorArray,  				GetBitBltTable, GetCursorPattern, 				SetBackground,SetBorder, SetCursorPattern,				screenWidth, screenHeight, Beep],  Runtime		USING [ ControlFault, StartFault, UnboundProcedure],				  OfflineDiagInterface	USING [ -- Imported types  				OfflineDiagnosticProc, ResultType, ClientPackage,				DiagHeap,								-- Imported data structures and their allocation				-- procedures			        TestItemsForThisNode, GetATestItemsForThisNode,				TestItem, GetATestItem, 				AMenuOfSelections, GetAMenuOfSelections,				Selections, GetASelectionArray,				HelpText, GetAHelpText, GetYesNo,				GetANumber, PutData,				PutMessage, userType,				 				-- Input/Output				abortSensed, hDiagTTY, inputChar, inputSensed, LookForAbort,				AbortCurrentTest],				  KeyStations		USING [ KeyStation, KeyBits],    OfflineDiagTTYDove	USING [ SetTTYMode, TTYMode, DrawALine, DrawKBDLine,  			        FillScreenWithObject, FillRectangle, PutObject,			        oldKeys, newKeys, DiagPutText, bottomLine,			        rightEdge, diagKeyBoard, KeyDescriptor],     KDMMessagesDove 	USING [ message ],   			         KDMMsgesAndKBDsImplDove;   -- For starting up message keysKDMOfflineDiagnosticsDove: PROGRAM 	IMPORTS DisplaySpecialFaceDaisy, DoveInputOutput, Inline, OfflineDiagInterface, OfflineDiagTTYDove, KDMMessagesDove, 		ProcessorFace, Runtime, SysConfigChannelDefs, UserTerminal, TTY,		MessagesAndKeyboard: KDMMsgesAndKBDsImplDove, String	EXPORTS OfflineDiagInterface =BEGIN OPEN Odi: OfflineDiagInterface, 	   KDMmsg: KDMMessagesDove,	   Dtty: OfflineDiagTTYDove,	   Term: UserTerminal;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Pointers (declarations) to the various structures that will be used.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- pAMenuOfSelections points to a RECORD containing pointers to various   -- elements of a menu. Several may be needed depending on how many submenus  -- there are in any particular menu. The number of pointers needed equals the  -- largest number of submenus any menu has. For this template, only 1 is  -- needed.  pAMenuOfSelections: LONG POINTER TO Odi.AMenuOfSelections;    -- This points to a SEQUENCE contains pointers to all TestItems in a menu.  pTestItemsForThisNode: LONG POINTER TO Odi.TestItemsForThisNode;     -- pTestItem points to a RECORD containing all the components of a TestItem.  pTestItem: LONG POINTER TO Odi.TestItem;  <<  -- pSelections points to a SEQUENCE contains indices of pointers stored in   -- TestItemsForThisNode. The indices are those of pointers pointing to tests   -- a class of user is allowed to run.   pSelections: LONG POINTER TO Odi.Selections; >>    -- The following pointers point to SEQUENCES specifying tests for the various  -- user classes.  pUserSelections, pAdminSelections, pSESelections, pManufacturingSelections, pProgrammerSelections:  LONG POINTER TO Odi.Selections;    --  This points to a SEQUENCE containing STRINGs of help text.  pHelpText: LONG POINTER TO Odi.HelpText;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Various result declarations for convenience:--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  nullResult: Odi.ResultType = none;  goodResult: Odi.ResultType = passed;  badResult: Odi.ResultType = failed;  ambiguousResult: Odi.ResultType = ambiguous;  scratch: CARDINAL;  -- Temporary scratchpad  -- Miscellaneous global declarations.   line, lineX: CARDINAL;  width, height: CARDINAL;  clearLineFromCursor: CHAR = 34C;  ttyMode: Dtty.TTYMode ¬ normal;  -- Mode of TTY operation  space: CHAR = ' ;  -- A SPACE  controlZ: CHARACTER = 'Z - 100B; -- Home and clear screen  cantTalkToEEProm: BOOLEAN ¬ FALSE;  xAlign: DisplaySpecialFaceDaisy.Alignments;  yAlign: DisplaySpecialFaceDaisy.Alignments;  Direction: TYPE = {up, down, left, right, clear};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Mouse related definitions--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--******************************************************************************-- The mouse is represented by a 16X16 pixel square for diagnostics. The mouse-- buttons are represented by 2 sqares, each of which is inverted when depressed. -- --       point => darken left square;--	 adjust => darken right square;--	 chord => darken both sqares.----******************************************************************************  fifteenBits: CARDINAL = 15;  -- heightMinusOne  newCursor: UserTerminal.CursorArray = [      15731B, 115733B, 21441B, 151112B, 140004B, 140007B, 60010B, 60010B,       170034B, 0000, 73751B, 22651B, 0000, 23617B, 22251B, 72351B];      idleMouse: Term.CursorArray = [  -- Mouse with no button down      177777B, 100001B, 100001B, 117171B, 111111B, 111111B, 111111B, 111111B,      117171B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B];        pointMouse: Term.CursorArray = [  -- Mouse with left button down      177777B, 100001B, 100001B, 117171B, 117111B, 117111B, 117111B, 117111B,      117171B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B];        adjustMouse: Term.CursorArray = [  -- Mouse with right button down      177777B, 100001B, 100001B, 117171B, 111171B, 111171B, 111171B, 111171B,      117171B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B];  chordMouse: Term.CursorArray = [  -- Mouse with both buttons down      177777B, 100001B, 100001B, 117171B, 117171B, 117171B, 117171B, 117171B,      117171B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B];  textPointerMouse: Term.CursorArray = [ -- Tajo pointer      100000B, 140000B, 160000B, 170000B, 174000B, 176000B, 177000B, 170000B,      154000B, 114000B, 006000B, 006000B, 003000B, 003000B, 001400B, 001400B];        mousePointButton: CARDINAL = 13;  mouseAdjustButton: CARDINAL = 14;  mousePointDown: BOOLEAN ¬ FALSE;  mouseAdjustDown: BOOLEAN ¬ FALSE;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Various display objects--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  letterH: UserTerminal.CursorArray ¬ [      0B, 0B, 30014B, 30014B, 30014B, 30014B, 30014B, 37774B, 37774B, 30014B,      30014B, 30014B, 30014B, 30014B, 0B, 0B];    letterE: UserTerminal.CursorArray ¬ [      0B, 77776B, 77776B, 60000B, 60000B, 60000B, 60000B, 77776B, 77776B,       60000B, 60000B, 60000B, 60000B, 77776B, 77776B, 0B];    CinU: UserTerminal.CursorArray ¬ [      0B, 63776B, 67776B, 74016B, 70006B, 60006B, 60006B,60006B, 60006B, 60006B,      60006B, 70006B, 74016B, 77776B, 37770B, 0B];  dlosAtSign: UserTerminal.CursorArray ¬ [      0B, 3760B, 4010B, 10004B, 20004B, 43742B, 42102B, 44102B, 44104B, 44104B,      44310B, 43560B, 40004B, 20030B, 17740B, 0B];  LizsAtSign: UserTerminal.CursorArray ¬ [      0B, 0B, 1700B, 3740B, 7160B, 6360B, 6660B, 6660B, 6760B, 6340B, 7000B,      3700B, 1700B, 0B, 0B, 0B];<<  staggeredGray: UserTerminal.CursorArray ¬ [      125252B, 052525B, 125252B, 052525B, 125252B, 052525B, 125252B, 052525B,      125252B, 052525B, 125252B, 052525B, 125252B, 052525B, 125252B, 052525B];  rightArrow: UserTerminal.CursorArray ¬ [      076000B, 002000B, 074100B, 002140B, 002160B, 076170B, 000174B, 177776B,      177777B, 177777B, 177776B, 000174B, 000170B, 000160B, 000140B, 000100B];        leftArrow: UserTerminal.CursorArray ¬ [       000010B, 000030B, 001010B, 003010B, 007030B, 017034B, 037000B, 077777B,       177777B, 177777B, 077777B, 037000B, 017000B, 007000B, 003000B, 001000B];        upArrow: UserTerminal.CursorArray ¬ [       000600B, 001700B, 003740B, 007760B, 017770B, 037774B, 077776B, 001700B,      001700B, 001717B, 001710B, 001717B, 001701B, 001701B, 001721B, 001737B];        downArrow: UserTerminal.CursorArray ¬ [      001717B, 001711B, 001701B, 001701B, 001737B, 001720B, 001737B, 001700B,      001700B, 077776B, 037774B, 017770B, 007760B, 003740B, 001700B, 000600B];>>  anX: UserTerminal.CursorArray ¬ [ -- This is an X      100001B, 040002B, 020004B, 010010B, 004020B, 002040B, 001100B, 000600B,      000600B, 001100B, 002040B, 004020B, 010010B, 020004B, 040002B, 100001B];  upArrow: UserTerminal.CursorArray ¬ [      177777B, 100601B, 103741B, 117771B, 177777B, 100001B, 107761B, 110011B,       110011B, 107761B, 110011B, 120005B, 120005B, 117771B, 100001B, 177777B];        invertedUpArrow: UserTerminal.CursorArray ¬ [      000000B, 077176B, 074036B, 060006B, 000000B, 077776B, 070016B, 067766B,      067766B, 070016B, 067766B, 057772B, 057772B, 060006B, 077776B, 000000B];         downArrow: UserTerminal.CursorArray ¬ [      177777B, 100001B, 103761B, 104011B, 100011B, 103761B, 104001B, 110001B,      110011B, 117771B, 100001B, 177777B, 117771B, 103741B, 100601B, 177777B];  invertedDownArrow: UserTerminal.CursorArray ¬ [      000000B, 077776B, 074016B, 073766B, 077766B, 074016B, 073776B, 067776B,      067766B, 060006B, 077776B, 000000B, 060006B, 074036B, 077176B, 000000B];        leftArrow: UserTerminal.CursorArray ¬ [       177777B, 104001B, 104011B, 114031B, 114051B, 134111B, 134211B, 174411B,      175011B, 135775B, 134011B, 114011B, 114011B, 104011B, 104001B, 177777B];  invertedLeftArrow: UserTerminal.CursorArray ¬ [      000000B, 073776B, 073766B, 063746B, 063726B, 043666B, 043566B, 004466B,      002766B, 042002B, 043766B, 063766B, 063766B, 073766B, 073776B, 000000B];        rightArrow: UserTerminal.CursorArray ¬ [      177777B, 100021B, 103421B, 104231B, 110031B, 120035B, 120035B, 123437B,       124237B, 130135B, 120135B, 120131B, 110231B, 107421B, 100021B, 177777B];  invertedRightArrow: UserTerminal.CursorArray ¬ [      000000B, 077756B, 074356B, 073546B, 067746B, 057742B, 057742B, 054340B,       053540B, 047642B, 057642B, 057646B, 067546B, 070356B, 077756B, 000000B];        blackPaint: CARDINAL = 177777B;   whitePaint: CARDINAL = 0;  background: Term.Background ¬ white;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Various parameters used by various procedures in this module--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  horizontal: BOOLEAN = TRUE;  -- TRUE => horizontal, FALSE => vertical  vertical: BOOLEAN = FALSE;  length: CARDINAL;  -- Length of a line  mousePattern: UserTerminal.CursorArray;    -- The actual bit maps of the keys  new: LONG POINTER TO KeyStations.KeyBits;  -- The current key states  old: LONG POINTER TO KeyStations.KeyBits;  -- The previous key states    --******************************************************************************--  Clear screen and set the mouse to all 0's--******************************************************************************ClearScreen: PROCEDURE =   BEGIN    Term.SetCursorPattern [ALL[0]];  -- Make cursor invisible    TTY.PutChar [Odi.hDiagTTY, controlZ];  -- Clear screen    background ¬ white;    [] ¬ Term.SetBackground[background];    END;        --******************************************************************************--  Look for input. NEXT advances; STOP => quit test; SPACE inverts --******************************************************************************AdvanceToNextPattern: PROC =  BEGIN    NEXTKey: CARDINAL = 63; -- NEXT advances to next pattern    NEXTsensed: BOOLEAN ¬ FALSE; -- TRUE => NEXT was down    oldBackground: Term.Background ¬ IF background = white THEN black ELSE white;    new ¬ Dtty.newKeys;  -- Get keyboard    DO  -- NEXT advances to next pattern      Odi.LookForAbort[];      IF NEXTsensed AND new [NEXTKey] = up THEN {  -- Advance to next pattern         [] ¬ Term.SetBackground [background]; RETURN };      IF new [NEXTKey] = down THEN NEXTsensed ¬ TRUE;            IF Odi.inputSensed THEN {          Odi.inputSensed ¬ FALSE;          IF Odi.inputChar = space THEN  -- Invert screen	    oldBackground ¬ Term.SetBackground [oldBackground] };	      new ¬ Dtty.newKeys;      ENDLOOP;    END;  -- AdvanceToNextPattern	 --******************************************************************************--  Draws vertical bars on the screen.--******************************************************************************DoVerticals: PROCEDURE [startAtX, numberOfBars, barWidth, spacing: CARDINAL] =   BEGIN    lastVerticalBar: BOOLEAN ¬ FALSE;    FOR j: CARDINAL IN [0..numberOfBars) DO        IF (scratch ¬ (startAtX + j*(barWidth + spacing) + barWidth))          >= Term.screenWidth THEN lastVerticalBar ¬ TRUE;       IF lastVerticalBar THEN barWidth ¬ scratch - Term.screenWidth;              Dtty.DrawALine [x: startAtX + j*(barWidth + spacing),		       y: 0,  -- Always start at the top		       thickness: Term.screenHeight,		       lineLength: barWidth,		       ink: blackPaint];        IF lastVerticalBar THEN RETURN;       ENDLOOP;    END;--******************************************************************************--  Draws horizontal bars on the screen starting at scanline startAtY.--******************************************************************************DoHorizontals: PROCEDURE [startAtY, numberOfBars, barWidth, spacing: CARDINAL] =  BEGIN    lastHorizontalBar: BOOLEAN ¬ FALSE;    FOR k: CARDINAL IN [0..numberOfBars] DO        IF (scratch ¬ (startAtY + k*(barWidth + spacing) + barWidth))          >= Term.screenHeight THEN lastHorizontalBar ¬ TRUE;       IF lastHorizontalBar THEN barWidth ¬ scratch - Term.screenHeight;              Dtty.DrawALine [x: 0,  -- Always start at the left edge		       y: startAtY + k*(barWidth + spacing), 		       thickness: barWidth,		       lineLength: Term.screenWidth,                       ink: blackPaint];       IF lastHorizontalBar THEN RETURN;       ENDLOOP;    END;  -- DoHorizontals    --******************************************************************************-- This procedure displays a keyboard and a mouse. Each mouse and keyboard-- key has an associated rectangle. The rectangle is white when undepressed, -- dark when depressed.--******************************************************************************KeyboardAndMouseTest: Odi.OfflineDiagnosticProc =  BEGIN    pKey: LONG POINTER TO Dtty.KeyDescriptor;    edgeWidth: CARDINAL = 2;   -- All lines are 2 pixels wide    RETURNkey: CARDINAL = 60;    LOCKKey: CARDINAL = 72;  -- For continuous beeping    STOPkey:    CARDINAL =  77;    STOPtyped: BOOLEAN ¬ FALSE;  -- The STOP key has been typed    -- Factor added to width if key is a right edge key      rightEdgeIndicator: CARDINAL = 1000;       none: CARDINAL = 0;    oneItem: CARDINAL = 1;    lastKey: CARDINAL = LAST[KeyStations.KeyStation];    key: CARDINAL;    -- Representations of keys in terms of rectangles.    keyRep: LONG POINTER TO ARRAY KeyStations.KeyStation OF Dtty.KeyDescriptor;-- Get keyboard representation.    keyRep ¬ Dtty.diagKeyBoard;    -- Set TTYMode and print user directions        Dtty.SetTTYMode [kbdDiagnostic];  -- Also initializes keyBoardBitAddress     TTY.PutChar [Odi.hDiagTTY, controlZ];    Dtty.DiagPutText [3, 3, KDMmsg.message [kbdAndMouseHelpTitle]];    Dtty.DiagPutText [6, 5, KDMmsg.message [normalCondition]];    Dtty.DiagPutText [6, 7, KDMmsg.message [rectangleStates]];    Dtty.DiagPutText [6, 9, KDMmsg.message [exitCondition]];    Dtty.DiagPutText [3, 11, KDMmsg.message [beeperTests]];    -- Draw key outlines        -- Draw the outlines for the keyboard    FOR key IN [0 .. lastKey] DO              fudge: CARDINAL = 1;  -- For patching       pKey ¬ @keyRep [key];   -- Pointer to key descriptor       line ¬ pKey.y;  -- Line to start drawing rectangle       lineX ¬ pKey.x;  -- Position on line       width ¬ pKey.width;  -- Width of rectangle       IF width > rightEdgeIndicator THEN width ¬ width - rightEdgeIndicator;       height ¬ pKey.height;  -- Height of rectangle              -- 0 => The keystation is not implemented. mousePointButton is used by       IF lineX = 0 OR key = mousePointButton THEN LOOP;  -- lower half of RETURN              -- Don't bother if RETURN key.       IF key # RETURNkey THEN { -- For the return key, draw the right edge only.          -- Top edge       	  Dtty.DrawKBDLine [lineX, line, width, blackPaint, horizontal];	  -- Bottom edge          Dtty.DrawKBDLine [lineX, height + line, width, blackPaint, horizontal];          -- Do left edge of rectangle.          Dtty.DrawKBDLine [lineX, line, height, blackPaint, vertical]}       ELSE height ¬ 2*height;       -- Now do right edge of rectangle.       Dtty.DrawKBDLine [lineX + width, line, height + 2*fudge,        		         blackPaint, vertical];       ENDLOOP;  -- Keyboard outline drawn        Term.SetCursorPattern [idleMouse];  -- Set the mouse pattern    new ¬ Dtty.newKeys;    old ¬ Dtty.oldKeys;        DO -- Loop until abort      FOR key IN [0 .. lastKey] DO         SELECT key FROM           mousePointButton => { -- Point	     IF new[key] = down THEN mousePointDown ¬ TRUE };	       	   mouseAdjustButton => {  -- Adjust	     IF new[key] = down THEN mouseAdjustDown ¬ TRUE };	                  STOPkey => { -- STOP key quits test	     IF new[key] = up AND STOPtyped THEN { -- Quit requested	        ttyMode ¬ Dtty.TTYMode [normal];		STOPtyped ¬ FALSE;	        SIGNAL Odi.AbortCurrentTest };	     IF new[key]=down THEN { -- First depression	        STOPtyped ¬TRUE; 		Dtty.FillRectangle [key, blackPaint] }};	              ENDCASE =>  { -- All other keys	     IF key = lastKey THEN { -- Last key position. Take care of mouse.	        mousePattern ¬ SELECT TRUE FROM	           mousePointDown AND mouseAdjustDown => chordMouse,	           mousePointDown => pointMouse,	           mouseAdjustDown => adjustMouse,	           ENDCASE => idleMouse;	        Term.SetCursorPattern [mousePattern];		mousePointDown ¬ FALSE;		mouseAdjustDown ¬ FALSE;		old ¬ new;		new ¬ Dtty.newKeys };	      	     IF keyRep [key].x = 0 THEN LOOP;  -- The key is unassigned 	     IF new [key] = down THEN {	        Dtty.FillRectangle [key, blackPaint];		IF (key = LOCKKey) OR (key = RETURNkey) THEN Term.Beep[] }	     ELSE  Dtty.FillRectangle [key, whitePaint] };		  	 ENDLOOP;  -- Loop thru all key stations      ENDLOOP;  -- Forever loop        END;  -- KeyboardAndMouseTest--******************************************************************************-- This proc varies the border color and prints thin lines on the screen.-- The partterns are cycled each time a NEXT is depressed. STOP exits test. --******************************************************************************ScreenAndBorders: Odi.OfflineDiagnosticProc =  BEGIN     border: CARDINAL [0 .. 377B];     whiteBorder: CARDINAL = 0B;    darkBorder: CARDINAL = 377B;    stripedBorder: CARDINAL = 170B;    paintBackGround: BOOLEAN;        Dtty.SetTTYMode [abnormalMode];        DO      ClearScreen [];      FOR i: CARDINAL IN [0..4] DO        SELECT i FROM 	  0 => {border ¬ darkBorder; background ¬ white; paintBackGround ¬ TRUE};	  1 => {border ¬ whiteBorder;	        DoVerticals [startAtX: 0, numberOfBars: Term.screenWidth/4,		             barWidth: 1, spacing: 3]; 	  	paintBackGround ¬ FALSE};	  2 => {ClearScreen[];	        DoHorizontals [startAtY: 0, numberOfBars: Term.screenHeight/4,	  		       barWidth: 1, spacing: 3]};	  3 => {DoVerticals [startAtX: 0, numberOfBars: Term.screenWidth/4,		             barWidth: 1, spacing: 3]};	  4 => {ClearScreen[];	        Dtty.FillScreenWithObject [@anX]};	  ENDCASE;		IF paintBackGround THEN [] ¬ Term.SetBackground [background];        Term.SetBorder[evenPairs: border, oddPairs: border];	AdvanceToNextPattern [];	ENDLOOP;      ENDLOOP;        END;   -- ScreenAndBorders--******************************************************************************-- This proc draws vertical and horizontal bars. First horizontals, then-- verticals, finally both. NEXT causes cycling. STOP quits, SPACE inverts--******************************************************************************DrawBars: Odi.OfflineDiagnosticProc =  BEGIN    nHorizontalLines: CARDINAL = Term.screenHeight/16;    nVerticalLines: CARDINAL = Term.screenWidth/16;        Dtty.SetTTYMode [abnormalMode];    ClearScreen[];    DO  -- Endless loop. STOP is only means to exit      FOR i: CARDINAL IN [1..8] DO        ClearScreen[];        DoVerticals [startAtX: 0,  -- left edge of screen		     numberOfBars: nVerticalLines,		     barWidth: i,		     spacing: 16 - i];        AdvanceToNextPattern[];        ClearScreen[];        DoHorizontals [startAtY: 0,	               numberOfBars: nHorizontalLines,		       barWidth: i,		       spacing: 16 - i];        AdvanceToNextPattern[];	DoVerticals [startAtX: 0,  -- left edge of screen		     numberOfBars: nVerticalLines,		     barWidth: i,		     spacing: 16 - i];	AdvanceToNextPattern[];        ENDLOOP;      ENDLOOP;  END;  -- DrawBars--******************************************************************************-- This proc prints a crosshair pattern on the screen for alignment purposes.--******************************************************************************PrintCrossHairPattern: Odi.OfflineDiagnosticProc =  BEGIN    --    -- Hair line lengths    shortHairLine: CARDINAL = 16;  -- For short hair lines    longHairLine: CARDINAL = 24; -- For long hair lines        -- Starting points for drawing horizontal hair lines (y)    centerVertLine: CARDINAL = Term.screenWidth/2;    centerVertLineShort: CARDINAL = centerVertLine - shortHairLine/2;     centerVertLineLong: CARDINAL = centerVertLine - longHairLine/2;        -- Starting points for drawing vertical hair lines (y)    centerHorLine: CARDINAL = Term.screenHeight/2;    centerHorLineShort: CARDINAL = centerHorLine - shortHairLine/2;  -- Short    centerHorLineLong: CARDINAL = centerHorLine - longHairLine/2;  -- Long        startPoint: CARDINAL;  -- Scratch variable        -- 1 inch = 2.54 cm    -- 75 pixelsPerInch/2.54 cmPerInch = 29.52 pixelsPerCM    << pixelsPerCM: CARDINAL = 30;   -- Rounded up >>    pixelsPerHalfCM: CARDINAL = 15;  -- Round up    numberOfVerticalBars: CARDINAL = Term.screenWidth/pixelsPerHalfCM;    numberOfHorizontalBars: CARDINAL = Term.screenHeight/pixelsPerHalfCM;        white: CARDINAL = 0;    stripe: CARDINAL = 170B;        Dtty.SetTTYMode [abnormalMode];        DO  -- Loop forever    FOR lineWidth: CARDINAL IN [1..10] DO        -- Clear screen and borders        ClearScreen [];        Term.SetBorder[0,0];  -- White borders	Dtty.DiagPutText [6, 7, KDMmsg.message [varyWidths]];	        -- Draw 4 lines around the edges        --        -- Top edge         Dtty.DrawALine [x: 0,  y: 0, 		        thickness: lineWidth, 		        lineLength: Term.screenWidth, 		        ink: blackPaint];        -- Bottom edge        Dtty.DrawALine [x: 0, y: Term.screenHeight - lineWidth, 		        thickness: lineWidth, 		        lineLength: Term.screenWidth,    		        ink: blackPaint];        -- Left edge        Dtty.DrawALine [x: 0,     		        y: 0, 		        thickness: Term.screenHeight, 		        lineLength: lineWidth, 		        ink: blackPaint];            -- Right edge        Dtty.DrawALine [x: Term.screenWidth - lineWidth,     		        y: 0, 		        thickness: Term.screenHeight, 		        lineLength: lineWidth,         	        ink: blackPaint];                -- Draw vertical hair lines about the horizontal center line        --	-- Center horizontal line (x-Axis)        Dtty.DrawALine [x: 0, y: centerHorLine-lineWidth/2, thickness: lineWidth,                         lineLength: Term.screenWidth, ink: blackPaint];	-- Right half        FOR i: CARDINAL IN [1 .. numberOfVerticalBars/2] DO -- Hair lines            IF i MOD 2 = 0 THEN {  -- Draw a long hair line               length ¬ longHairLine; 	       line ¬ centerHorLineLong }            ELSE {  -- Draw a short hair line               length ¬ shortHairLine; 	       line ¬ centerHorLineShort };	       	    startPoint ¬ centerVertLine + i*pixelsPerHalfCM - lineWidth/2;	    IF startPoint + lineWidth > Term.screenWidth THEN EXIT;	                Dtty.DrawALine [x: startPoint,       		            y: line, 		            thickness: length, 		            lineLength: lineWidth, 		            ink: blackPaint];            ENDLOOP;	    	-- Left half	FOR i: CARDINAL IN [1 .. numberOfVerticalBars/2] DO             IF i MOD 2 = 0 THEN {  -- Draw a long hair line               length ¬ longHairLine; 	       line ¬ centerHorLineLong }            ELSE {  -- Draw a short hair line               length ¬ shortHairLine; 	       line ¬ centerHorLineShort };	    	    startPoint ¬ i*pixelsPerHalfCM + lineWidth/2; 	    IF startPoint > centerVertLine THEN EXIT 	    ELSE startPoint ¬ centerVertLine - startPoint; 	                   Dtty.DrawALine [x: startPoint,       		            y: line, 		            thickness: length, 		            lineLength: lineWidth, 		            ink: blackPaint];            ENDLOOP;            -- Draw horizontal hair lines about vertical line, each separated by .5 cm        --	-- Center vertical line (y-Axis)        Dtty.DrawALine [x: centerVertLine - lineWidth/2, y: 0, 	                thickness: Term.screenHeight,       		        lineLength: lineWidth, ink: blackPaint];	-- Top half        FOR i: CARDINAL IN [1 .. numberOfHorizontalBars/2] DO             IF i MOD 2 = 0 THEN {  -- Draw a long hair line               length ¬ longHairLine; 	       line ¬ centerVertLineLong  -- x-position to start painting -- }            ELSE {  -- Draw a short hair line               length ¬ shortHairLine; 	       line ¬ centerVertLineShort  -- x-position to start painting  -- };	    	    startPoint ¬ i*pixelsPerHalfCM + lineWidth/2;	    IF startPoint > centerHorLine THEN EXIT	    ELSE startPoint ¬ centerHorLine - startPoint;	                Dtty.DrawALine [x: line,       		            y: startPoint, 		            thickness: lineWidth, 		            lineLength: length, 		            ink: blackPaint];            ENDLOOP;	    	-- Bottom half        FOR i: CARDINAL IN [0 .. numberOfHorizontalBars/2] DO             IF i MOD 2 = 0 THEN {  -- Draw a long hair line               length ¬ longHairLine; 	       line ¬ centerVertLineLong  -- x-position to start painting -- }            ELSE {  -- Draw a short hair line               length ¬ shortHairLine; 	       line ¬ centerVertLineShort  -- x-position to start painting  -- };	       	    startPoint ¬ i*pixelsPerHalfCM - lineWidth/2 + centerHorLine;	    IF (startPoint + lineWidth) > Term.screenHeight THEN EXIT;            Dtty.DrawALine [x: line,       		            y: startPoint, 		            thickness: lineWidth, 		            lineLength: length, 		            ink: blackPaint];            ENDLOOP;            AdvanceToNextPattern[];      ENDLOOP; -- FOR loop (for all allowable line widths)    ENDLOOP; -- Forever loop        END;  -- PrintCrossHairPattern--******************************************************************************-- This procedure prints H's and @'s--******************************************************************************PrintCharacters: Odi.OfflineDiagnosticProc =  BEGIN     Dtty.SetTTYMode [abnormalMode];    ClearScreen [];    DO      Dtty.FillScreenWithObject [@letterH];      AdvanceToNextPattern[];      Dtty.FillScreenWithObject [@letterE];      AdvanceToNextPattern[];      Dtty.FillScreenWithObject [@dlosAtSign];      AdvanceToNextPattern[];      Dtty.FillScreenWithObject [@LizsAtSign];      AdvanceToNextPattern[];<<      Dtty.FillScreenWithObject [@CinU];      AdvanceToNextPattern[];>>      Dtty.FillScreenWithObject [@anX];      AdvanceToNextPattern[];      ENDLOOP;    END;  -- PrintCharacters--******************************************************************************-- This procedure allows one to move the active display area left, right, up or-- down.--******************************************************************************AdjustDataField: Odi.OfflineDiagnosticProc =  BEGIN     upKey1: CARDINAL = 82;  -- numeric 8 moves screen up by an increment    upKey2: CARDINAL = 69;  -- another 8 moves screen up by an increment    upSensed: BOOLEAN ¬ FALSE;    downKey1: CARDINAL = 5; -- numeric 2 moves screen down by a decrement    downKey2: CARDINAL = 33; -- another 2 moves screen down by a decrement    downSensed: BOOLEAN ¬ FALSE;    leftKey1: CARDINAL = 84; -- numeric 4 moves screen left by an increment    leftKey2: CARDINAL = 17; -- another 4 moves screen left by an increment    leftSensed: BOOLEAN ¬ FALSE;    rightKey1: CARDINAL = 87;  -- numeric 6 moves screen right by an increment    rightKey2: CARDINAL = 18;  -- another 6 moves screen right by an increment    rightSensed: BOOLEAN ¬ FALSE;    clearKey: CARDINAL = 12;    clearSensed: BOOLEAN ¬ FALSE;    exitKey1: CARDINAL = 94;  -- numeric 1 causes same effect as stop key    exitKey2: CARDINAL = 48;  -- another 1 causes same effect as stop key    anchorLine: CARDINAL = Term.screenHeight/2 + spacing * 2; -- Position for upArrow    leftRightLine: CARDINAL = anchorLine + spacing;    downArrowLine: CARDINAL = leftRightLine + spacing;    spacing: CARDINAL = 32;        upArrowLE: CARDINAL = Term.screenWidth/2 + spacing; -- upArrow Left edge.    leftArrowLE: CARDINAL = upArrowLE - spacing; -- leftArrow Left edge    rightArrowLE: CARDINAL = upArrowLE + spacing;    downArrowLE: CARDINAL = upArrowLE; -- downArrow Left edge.        -- Display alignment bounds    rightAlignBound: CARDINAL = 16;    leftAlignBound: CARDINAL = 20;    upAlignBound: CARDINAL = 8;    downAlignBound: CARDINAL = 6;        -- saved alignment    savedXAlign, savedYAlign: DisplaySpecialFaceDaisy.Alignments;     -- ***** TEST STRINGs *****    leftArrowSelected: LONG STRING = "Left Arrow";    rightArrowSelected: LONG STRING = "Right Arrow";    upArrowSelected: LONG STRING = "Up Arrow";    downArrowSelected: LONG STRING = "Down Arrow";        -- For DEBUGGING    PutAlignInfo: PROCEDURE[dX, dY: DisplaySpecialFaceDaisy.Alignments, all: BOOLEAN ¬ TRUE] = {      str: LONG STRING ¬ [256];      String.Copy[to: str, from: "X Align: [dir: "L];      String.AppendString[to: str, from:        SELECT xAlign.dir FROM         leftUp => "Left, "L, rightDown => "Right, "L, ENDCASE => "???, "L];      String.AppendString[to: str, from: "nibbleOffset: "L];      String.AppendDecimal[s: str, n: INTEGER[xAlign.nibbleOffset]];      String.AppendString[to: str, from: "];  Y Align: [dir: "L];      String.AppendString[to: str, from:        SELECT yAlign.dir FROM         leftUp => "Up, "L, rightDown => "Down, "L, ENDCASE => "???, "L];      String.AppendString[to: str, from: "nibbleOffset: "L];      String.AppendDecimal[s: str, n: INTEGER[yAlign.nibbleOffset]];      String.AppendString[to: str, from: "];"L];      Dtty.DiagPutText[6, 21, "                                                                                    "L];      Dtty.DiagPutText[6, 21, str];      IF NOT all THEN RETURN;      String.Copy[to: str, from: "Delta X: [dir: "L];      String.AppendString[to: str, from:        SELECT dX.dir FROM         leftUp => "Left, "L, rightDown => "Right, "L, ENDCASE => "???, "L];      String.AppendString[to: str, from: "nibbleOffset: "L];      String.AppendDecimal[s: str, n: INTEGER[dX.nibbleOffset]];      String.AppendString[to: str, from: "];  Delta Y: [dir: "L];      String.AppendString[to: str, from:        SELECT dY.dir FROM         leftUp => "Up, "L, rightDown => "Down, "L, ENDCASE => "???, "L];      String.AppendString[to: str, from: "nibbleOffset: "L];      String.AppendDecimal[s: str, n: INTEGER[dY.nibbleOffset]];      String.AppendString[to: str, from: "];"L];      Dtty.DiagPutText[6, 23, "                                                                                    "L];      Dtty.DiagPutText[6, 23, str];      };          MoveInternal: PROCEDURE[dir: Direction] = {      deltaX, deltaY: DisplaySpecialFaceDaisy.Alignments;      xByte, yByte: Environment.Byte;            IF dir = clear THEN {xAlign ¬ [detail [dir: rightDown, nibbleOffset: 0]];        yAlign ¬ [detail [dir: rightDown, nibbleOffset: 0]];	IF Odi.userType = Programmer THEN PutAlignInfo[deltaX, deltaY, FALSE];}      ELSE {      deltaY ¬ [detail [dir: yAlign.dir, nibbleOffset: 0]];      deltaX ¬ [detail [dir: xAlign.dir, nibbleOffset: 0]];        SELECT dir FROM	up => deltaY ¬ [detail [dir: leftUp, nibbleOffset: 1]];	down => deltaY ¬ [detail [dir: rightDown, nibbleOffset: 1]];	-- right => deltaX ¬ [detail [dir: rightDown, nibbleOffset: 1]];	right => deltaX ¬ [detail [dir: rightDown, nibbleOffset: 4]];  -- Temp until nibble alignment works	-- left => deltaX ¬ [detail [dir: leftUp, nibbleOffset: 1]];	left => deltaX ¬ [detail [dir: leftUp, nibbleOffset: 4]];  -- Temp until nibble alignment works	ENDCASE;            IF Odi.userType = Programmer THEN PutAlignInfo[deltaX, deltaY, TRUE];            IF xAlign.dir = deltaX.dir THEN -- same direction        xAlign.nibbleOffset ¬ xAlign.nibbleOffset + deltaX.nibbleOffset      ELSE -- different direction        SELECT TRUE FROM	  xAlign.nibbleOffset < deltaX.nibbleOffset => 	    xAlign ¬ [detail [dir: deltaX.dir, nibbleOffset: deltaX.nibbleOffset - xAlign.nibbleOffset]];	  xAlign.nibbleOffset = deltaX.nibbleOffset =>	    xAlign ¬ [detail [dir: rightDown, nibbleOffset: 0]];	  xAlign.nibbleOffset > deltaX.nibbleOffset=>	    xAlign.nibbleOffset ¬ xAlign.nibbleOffset - deltaX.nibbleOffset;	  ENDCASE;	           IF yAlign.dir = deltaY.dir THEN -- same direction        yAlign.nibbleOffset ¬ yAlign.nibbleOffset + deltaY.nibbleOffset      ELSE -- different direction        SELECT TRUE FROM	  yAlign.nibbleOffset < deltaY.nibbleOffset => 	    yAlign ¬ [detail [dir: deltaY.dir, nibbleOffset: deltaY.nibbleOffset - yAlign.nibbleOffset]];	  yAlign.nibbleOffset = deltaY.nibbleOffset =>	    yAlign ¬ [detail [dir: rightDown, nibbleOffset: 0]];	  yAlign.nibbleOffset > deltaY.nibbleOffset =>	    yAlign.nibbleOffset ¬ yAlign.nibbleOffset - deltaY.nibbleOffset;	  ENDCASE;	        -- Bound limitation       xAlign.nibbleOffset ¬ IF xAlign.dir = rightDown THEN MIN[rightAlignBound, xAlign.nibbleOffset] ELSE MIN[leftAlignBound, xAlign.nibbleOffset];      yAlign.nibbleOffset ¬ IF yAlign.dir = rightDown THEN MIN[downAlignBound, yAlign.nibbleOffset] ELSE MIN[upAlignBound, yAlign.nibbleOffset];                    IF Odi.userType = Programmer THEN PutAlignInfo[deltaX, deltaY, FALSE];      }; -- of dir # clear      [xByte, yByte] ¬ DisplaySpecialFaceDaisy.GetDisplayAlignmentData[x: xAlign, y: yAlign];      IF UpdateEEPROM[xByte, yByte].stat # success THEN       	{Odi.PutMessage["EEPROM cannot be written with new value.  Display cannot be adjusted."L];	RETURN};      [] ¬ DisplaySpecialFaceDaisy.NotifyDisplayAlignment[];      };    MoveDisplayUp: PROCEDURE = {      Dtty.PutObject [upArrowLE, anchorLine, @invertedUpArrow];      MoveInternal[up];      Dtty.PutObject [upArrowLE, anchorLine, @upArrow];       RETURN };         MoveDisplayDown: PROCEDURE = {      Dtty.PutObject [downArrowLE, downArrowLine, @invertedDownArrow];      MoveInternal[down];      Dtty.PutObject [downArrowLE, downArrowLine, @downArrow];       RETURN };	    MoveDisplayLeft: PROCEDURE = {      Dtty.PutObject [leftArrowLE, leftRightLine, @invertedLeftArrow];      MoveInternal[left];      Dtty.PutObject [leftArrowLE, leftRightLine, @leftArrow];       RETURN };	    MoveDisplayRight: PROCEDURE = {      Dtty.PutObject [rightArrowLE, leftRightLine, @invertedRightArrow];      MoveInternal[right];      Dtty.PutObject [rightArrowLE, leftRightLine, @rightArrow];       RETURN };	    DefaultDisplay: PROCEDURE = {      MoveInternal[clear]};    UpdateEEPROM: PROCEDURE[x, y: Environment.Byte] RETURNS[stat: SysConfigChannelDefs.Status] = {      IF cantTalkToEEProm THEN RETURN[unKnown];            stat ¬ ReadEEProm[];      IF stat # success THEN RETURN[stat];            SysConfigChannelDefs.eePromImage.DisplayxAlignment ¬ x;      SysConfigChannelDefs.eePromImage.DisplayyAlignment ¬ y;      stat ¬ SysConfigChannelDefs.WriteEEPromImage[];      };          ReadEEProm: PROCEDURE RETURNS[stat: SysConfigChannelDefs.Status] =      BEGIN      IF cantTalkToEEProm THEN RETURN[unKnown];            stat ¬ SysConfigChannelDefs.ReadEEPromImage[];      END;        GetCurrentAlignment: PROCEDURE =      BEGIN      stat: SysConfigChannelDefs.Status ¬ ReadEEProm[];            IF stat # success OR cantTalkToEEProm THEN {	xAlign ¬ [detail [dir: rightDown, nibbleOffset: 0]];	yAlign ¬ [detail [dir: rightDown, nibbleOffset: 0]];	savedXAlign ¬ xAlign;	savedYAlign ¬ yAlign;	Odi.PutMessage["EEPROM cannot be read. "L];	RETURN};	      [xAlign, yAlign] ¬ DisplaySpecialFaceDaisy.GetAlignmentsFromBytes[	SysConfigChannelDefs.eePromImage.DisplayxAlignment,	SysConfigChannelDefs.eePromImage.DisplayyAlignment];	      savedXAlign ¬ xAlign;      savedYAlign ¬ yAlign;      END;    WorkstationMayBeDaisy: PROCEDURE RETURNS[yes: BOOLEAN ¬ FALSE] = {      IF DoveInputOutput.GetMicrocodeVersion[].machineType = daisy THEN RETURN[TRUE];      IF Odi.userType # Programmer THEN RETURN[FALSE];      yes ¬ Odi.GetYesNo["Is the workstation Daisy?"L];      IF NOT yes THEN {        Odi.PutMessage["Warning: This test is only applicable to Daisy workstation."L];	RETURN[Odi.GetYesNo["Do you want to continue?"L]];	}      ELSE RETURN[yes];      };    IF NOT WorkstationMayBeDaisy[].yes THEN {      Odi.PutMessage [        message: "The Display alignment command is not supported for this system."L, beep: TRUE, 	clearMessageAreaFirst: TRUE];      RETURN[none];      };        GetCurrentAlignment[]; -- to get current alignment value.    Dtty.SetTTYMode [abnormalMode];    ClearScreen[]; -- Clear screen, set CursorPattern white and print directions    Term.SetBorder [377B, 377B];   -- Set borders dark    [] ¬ Term.SetBackground [white];        -- Print directions    Dtty.DiagPutText [3, 3, KDMmsg.message [properPosition]];    Dtty.DiagPutText [3, 5, KDMmsg.message [alignDisplayHelp]];    Dtty.DiagPutText [6, 9, KDMmsg.message [alignDisplayExit]];    Dtty.DiagPutText [6, 11, KDMmsg.message [alignDisplayDown]];    Dtty.DiagPutText [6, 13, KDMmsg.message [alignDisplayLeft]];    Dtty.DiagPutText [6, 15, KDMmsg.message [alignDisplayRight]];    Dtty.DiagPutText [6, 17, KDMmsg.message [alignDisplayUp]];    Dtty.DiagPutText [6, 19, KDMmsg.message [alignDisplayDefault]];        -- Draw the arrows    Dtty.PutObject [upArrowLE, anchorLine, @upArrow];    Dtty.PutObject [leftArrowLE, leftRightLine, @leftArrow];    Dtty.PutObject [rightArrowLE, leftRightLine, @rightArrow];    Dtty.PutObject [downArrowLE, downArrowLine, @downArrow];        -- Get keyboard    new ¬ Dtty.newKeys;    old ¬ Dtty.oldKeys;    DO  --      ENABLE Odi.AbortCurrentTest => {REJECT};      SELECT TRUE FROM         new[upKey1] = down OR new[upKey2] = down  => upSensed ¬ TRUE;	 new[downKey1] = down OR new[downKey2] = down => downSensed ¬ TRUE;	 new[leftKey1] = down OR new[leftKey2] = down => leftSensed ¬ TRUE;	 new[rightKey1] = down OR new[rightKey2] = down => rightSensed ¬ TRUE;	 new[clearKey] = down => clearSensed ¬ TRUE;	 ENDCASE;       SELECT TRUE FROM         upSensed AND new[upKey1] = up AND new[upKey2] = up => {	    upSensed ¬ FALSE; MoveDisplayUp []};	 downSensed AND new[downKey1] = up AND new[downKey2] = up => {	    downSensed ¬ FALSE; MoveDisplayDown [] };	 leftSensed AND new[leftKey1] = up AND new[leftKey2] = up => {	    leftSensed ¬ FALSE; MoveDisplayLeft [] };	 rightSensed AND new[rightKey1] = up AND new[rightKey2] = up  => {	    rightSensed ¬ FALSE; MoveDisplayRight [] };	 clearSensed AND new[clearKey] = up => {	   clearSensed ¬ FALSE; DefaultDisplay[]};	 ENDCASE;       IF new[exitKey1] = down OR new[exitKey2] = down THEN Odi.abortSensed ¬ TRUE;            Odi.LookForAbort[];      ENDLOOP;  END;  -- AdjustDataField--******************************************************************************-- Fill the screen with all the displayable characters. Each line is skewed by -- one character.--******************************************************************************PrinterTestPattern: Odi.OfflineDiagnosticProc =  BEGIN       startingChar: CHAR;  -- First character on line    charToBePrinted: CHAR;        firstPrintableChar: CHAR = 41C;  -- !    lastPrintableChar: CHAR = 176C;  --  ~      Dtty.SetTTYMode [abnormalMode];    ClearScreen [];        startingChar ¬ firstPrintableChar;    FOR line: CARDINAL IN [0..Dtty.bottomLine) DO            -- Print a line      charToBePrinted ¬ startingChar;      FOR i: CARDINAL IN [0..Dtty.rightEdge) DO         IF line = Dtty.bottomLine - 1 AND i = Dtty.rightEdge - 1 THEN EXIT;	 TTY.PutChar[Odi.hDiagTTY, charToBePrinted];         IF charToBePrinted = lastPrintableChar             THEN charToBePrinted ¬ firstPrintableChar         ELSE charToBePrinted ¬ charToBePrinted + 1;	 	 ENDLOOP; -- Print a line loop            IF startingChar = lastPrintableChar THEN startingChar ¬ firstPrintableChar      ELSE startingChar ¬ startingChar + 1;            ENDLOOP; -- UNTIL loop        DO AdvanceToNextPattern[] ENDLOOP;        END;  -- PrinterPattern        --******************************************************************************-- Draw a big cicle at the center of the screen and a small circle in each of -- the four corners.--******************************************************************************DrawCircles: Odi.OfflineDiagnosticProc =  BEGIN  ErrorCode: TYPE = {unknown};   Bug: ERROR [code: ErrorCode] = CODE;  screenWidth: CARDINAL = Term.screenWidth;    screenHeight: CARDINAL = Term.screenHeight;     Bit: TYPE = [0..1];  Line: TYPE = LONG POINTER TO PACKED ARRAY [0..0) OF Bit;  LineArray: TYPE = ARRAY [0..1000) OF Line;  lines: LONG POINTER TO LineArray _ NIL;  lineArray: LineArray;  j: INTEGER ¬ 0;    InitLineArray: PROC =    BEGIN    wordsPerScanLine: CARDINAL = screenWidth/16;    lp: LONG POINTER _ Term.GetBitBltTable[].dst.word;    lines _ @lineArray;    FOR i: CARDINAL IN [0..screenHeight) DO      lines[i] _ lp + i * wordsPerScanLine ENDLOOP    END;  -- of InitLineArray      DisplayCircle: PROC [center: Term.Coordinate, radius: NAT] =    BEGIN    vx: NAT _ 0;    vy: NAT _ radius;    error: INTEGER _ 2 - 2 * radius;    direction: {n, nw, w};        WHILE vy # 0 DO      lines[center.y + vy][center.x + vx] _ lines[center.y + vx][center.x - vy] _        lines[center.y - vy][center.x - vx] _ lines[center.y - vx][center.x + vy] _        1;      IF error < 0 THEN        IF 2 * error + 2 * vy - 1 > 0 THEN direction _ nw ELSE direction _ w      ELSE IF 2 * error - 2 * vx - 1 > 0 THEN direction _ n ELSE direction _ nw;      SELECT direction FROM        w => {vx _ vx + 1; error _ error + 2 * vx + 1};        nw => {vx _ vx + 1; vy _ vy - 1; error _ error + 2 * (vx - vy + 1)};        n => {vy _ vy - 1; error _ error - 2 * vy + 1}        ENDCASE => ERROR Bug[unknown]      ENDLOOP    END;  -- of DisplayCircle      Init: PROC[k: INTEGER] = {    i: NAT ¬ IF screenWidth = 832 THEN 80 ELSE 110;    leftX: NAT ¬ i;    rightX: NAT ¬ screenWidth - i - 1;    topY: NAT ¬ leftX;    bottomY: NAT ¬ screenHeight - i - 1;    InitLineArray[];      DisplayCircle[[x: screenWidth/2, y: screenHeight/2 ], (screenHeight-1)/2 - k];      DisplayCircle[[x: leftX, y: topY], i - k];      DisplayCircle[[x: rightX, y: topY], i - k];      DisplayCircle[[x: leftX, y: bottomY], i - k];      DisplayCircle[[x: rightX, y: bottomY], i - k];          };    Dtty.SetTTYMode [abnormalMode];  ClearScreen [];  DO    ClearScreen[];    FOR j IN [0..10) DO      Init[j];      AdvanceToNextPattern[];      ENDLOOP;    ENDLOOP;  END;    --******************************************************************************-- ChangeMixRule----******************************************************************************  ChangeMixRule: Odi.OfflineDiagnosticProc =    BEGIN    cursor: UserTerminal.CursorArray;    displayFCB: LONG POINTER TO DisplayIOFaceDove.displayFunctionContextBlock ¬        DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.display];    oldRule, newRule : CARDINAL;    oldCursor: UserTerminal.CursorArray ¬ Term.GetCursorPattern[];    oldRule ¬ displayFCB.displCntl.dataCursor;    newRule ¬ oldRule;    Term.SetCursorPattern[newCursor];    FOR i: CARDINAL IN [0..15] DO      cursor[i] ¬ newCursor[i];      ENDLOOP;        DO -- loop until hit STOP.      ENABLE Odi.AbortCurrentTest => {        IF NOT Odi.GetYesNo[prompt: "Keep current mix rule?"L] THEN           SetAndNotify[displayFCB, oldRule]; 	Term.SetCursorPattern [oldCursor];        REJECT};            [number: newRule] ¬ Odi.GetANumber [prompt: "[0..15]: Mix rule, 16: Invert cursor, 17: Resume cursor, 18: Put MP = "L, help: NIL,         lowLimit: 0, upperLimit: 18, defaultNumber: oldRule];      SELECT newRule FROM        16 => {	  n: LONG CARDINAL ¬ 0;	  FOR j: CARDINAL IN [0..15] DO	    cursor[j] ¬ Inline.BITXOR[cursor[j], 177777B];	    ENDLOOP;	  Term.SetCursorPattern [cursor];	  Odi.PutMessage["Cursor was inverted."L];	  };	17 => {-- resume cursor	  Term.SetCursorPattern [cursor];	  Odi.PutMessage["Cursor was resumed."L];	  };	18 => {--Put MP Code	  mp: CARDINAL;	  [number: mp] ¬ Odi.GetANumber [prompt: "Set MP Code: Code = "L, help: NIL,             lowLimit: 0, upperLimit: 9999, defaultNumber: 990];	  ProcessorFace.SetMP [mp];	  };	ENDCASE => {	  SetAndNotify[displayFCB, newRule];	  Odi.PutData[	    data: "Current mix rule = "L, numberAfterData: newRule,	    clearHeadingAndData: TRUE, startWithNewLine: TRUE];	  };      ENDLOOP;    END;              SetAndNotify: PROCEDURE[fcb: LONG POINTER TO DisplayIOFaceDove.displayFunctionContextBlock ¬ NIL, new: CARDINAL] =      BEGIN      backGrndChangedMask:  DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[4096];      IF fcb = NIL THEN RETURN;      fcb.displCntl.dataCursor ¬ new;      fcb.mixRule ¬ new;      [] ¬ DoveInputOutput.LockMem        [or, DoveInputOutput.GetIORegionOffset[@fcb.chngdInfo], backGrndChangedMask, fcb.displayLock];      END;--******************************************************************************-- Builds up and initialize all the data structures for the KeyBoard, Dispaly-- and Mouse diagnostics.--******************************************************************************InitializePackage: PROCEDURE = BEGIN  -- For this node, there are 9 selections; so we need a TestItemsForThisNode that-- can hold 9 pointers to 9 different TestItems.  numberOfTests: CARDINAL = 9;   pTestItemsForThisNode ¬ Odi.GetATestItemsForThisNode [numberOfTests];-- For each of the selections, an instance of TestItem is needed.-- We start with menu selection 1.  pTestItem ¬ Odi.GetATestItem [];  -- KeyboardAndMouseTest  pTestItem.itemName ¬ KDMmsg.message[keyboardAndMouseTest];  pTestItem.test ¬ KeyboardAndMouseTest; -- Procedure  pTestItem.itemExplanation ¬ KDMmsg.message[keyboardAndMouseExplanation];  pTestItemsForThisNode.nodeItems [0] ¬ pTestItem; -- Store in first location.-- Selection number 2.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[screenAndBorders];  pTestItem.test ¬ ScreenAndBorders;  -- Procedure  pTestItem.itemExplanation ¬ KDMmsg.message[screenAndBordersHelp];  pTestItemsForThisNode.nodeItems [1] ¬ pTestItem;  -- Store TestItem pointer.-- For Test3.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[drawBars];  pTestItem.test ¬ DrawBars;  pTestItem.itemExplanation ¬ KDMmsg.message[drawBarExplanation];  pTestItemsForThisNode.nodeItems [2] ¬ pTestItem;  -- Store TestItem pointer.-- For Test4.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[crossHair];  pTestItem.test ¬ PrintCrossHairPattern;   -- Procedure  pTestItem.itemExplanation ¬  KDMmsg.message[crossHairHelp];    pTestItemsForThisNode.nodeItems [3] ¬ pTestItem;  -- Store TestItem pointer.   -- For Test5.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[printCharacters];  pTestItem.test ¬ PrintCharacters; -- Procedure  pTestItem.itemExplanation ¬ KDMmsg.message[helpText0];    pTestItemsForThisNode.nodeItems [4] ¬ pTestItem;  -- Store TestItem pointer.    -- For Test6.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[printerTestPattern];  pTestItem.test ¬ PrinterTestPattern; -- Procedure  pTestItem.itemExplanation ¬ KDMmsg.message[printerTestHelp];  pTestItemsForThisNode.nodeItems [5] ¬ pTestItem;  -- Store TestItem pointer.-- For Test7.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[circles];  pTestItem.test ¬ DrawCircles; -- Procedure  pTestItem.itemExplanation ¬ KDMmsg.message[circlesHelp];  pTestItemsForThisNode.nodeItems [6] ¬ pTestItem;-- For Test8.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ KDMmsg.message[alignDisplay];  pTestItem.test ¬ AdjustDataField;   -- Procedure  pTestItem.itemExplanation ¬ KDMmsg.message[moveDataField];    pTestItemsForThisNode.nodeItems [7] ¬ pTestItem;  -- Store TestItem pointer.-- For Test9.  pTestItem ¬  Odi.GetATestItem [];  pTestItem.itemName ¬ String.CopyToNewString [s: "Change Mix Rule"L, z: Odi.DiagHeap];  pTestItem.test ¬ ChangeMixRule;   -- Procedure  pTestItem.itemExplanation ¬ NIL;    pTestItemsForThisNode.nodeItems [8] ¬ pTestItem;  -- Store TestItem pointer.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Assign various tests for the different classes of users.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- For this package, there are 6 tests, all of which are available to all users.----   1) Get an array of 8 entries for holding indices of tests for each--      class of users.--   2) Assign the indices of the TestItemsForThisNode slots that hold the --      pointers to the TestItems corresponding to those tests.--   3) Note the order of entry. The order corresponds to the ordering of the --	displayed menu items.-- Get a UserSelections to hold the indices of tests for the Normal Users.  pUserSelections ¬ Odi.GetASelectionArray [4];  -- 4 selections are allowed.  pUserSelections.selections[0] ¬ 0;  -- First test = KeyboardAndMouseTest.    pUserSelections.selections[1] ¬ 4;  -- Second = ScreenAndBorders.  pUserSelections.selections[2] ¬ 3;  -- Third = PrintCrossHairPattern.  pUserSelections.selections[3] ¬ 7;  -- Fourth = AdjustDataField.   --  Get an array for holding indices of tests for the System Administrator.  pAdminSelections ¬ Odi.GetASelectionArray [4];  -- Make same selections.  pAdminSelections.selections[0] ¬ 0;  -- First to appear on the menu.    pAdminSelections.selections[1] ¬ 4;  -- Second.  pAdminSelections.selections[2] ¬ 3;  -- Third.  pAdminSelections.selections[3] ¬ 7;  -- Fourth = AdjustDataField.--  Get an array for holding indices of tests for the Service Engineers.  pSESelections ¬ Odi.GetASelectionArray [6];  -- All selections.  pSESelections.selections[0] ¬ 0;  -- First to appear on the menu.    pSESelections.selections[1] ¬ 1;  -- Second.  pSESelections.selections[2] ¬ 2;  -- Third.  pSESelections.selections[3] ¬ 3;  -- Fourth.  pSESelections.selections[4] ¬ 4;  -- Fifth.  pSESelections.selections[5] ¬ 7;  -- Sixth.--  Get an array for holding indices of tests for the Manufacturing.  pManufacturingSelections ¬ Odi.GetASelectionArray [8]; -- Make same selection  pManufacturingSelections.selections[0] ¬ 0;  -- First to appear on the menu.    pManufacturingSelections.selections[1] ¬ 1;  -- Second.  pManufacturingSelections.selections[2] ¬ 2;  -- Third.  pManufacturingSelections.selections[3] ¬ 3;  -- Fourth.  pManufacturingSelections.selections[4] ¬ 4;  -- Fifth.  pManufacturingSelections.selections[5] ¬ 5;  -- Sixth.  pManufacturingSelections.selections[6] ¬ 6;  -- Seventh.  pManufacturingSelections.selections[7] ¬ 7;  -- Eighth.--  Get an array for holding indices of tests for the Programmers.  pProgrammerSelections ¬ Odi.GetASelectionArray [9];  -- All selections.  pProgrammerSelections.selections[0] ¬ 0;  -- First to appear on the menu.    pProgrammerSelections.selections[1] ¬ 1;  -- Second.  pProgrammerSelections.selections[2] ¬ 2;  -- Third.  pProgrammerSelections.selections[3] ¬ 3;  -- Fourth.  pProgrammerSelections.selections[4] ¬ 4;  -- Fifth.  pProgrammerSelections.selections[5] ¬ 5;  -- Sixth.  pProgrammerSelections.selections[6] ¬ 6;  -- Seventh.  pProgrammerSelections.selections[7] ¬ 7;  -- Eighth.  pProgrammerSelections.selections[8] ¬ 8;  -- Ninth.  -- Get a menu-wide help text for this package.  pHelpText ¬ Odi.GetAHelpText [1];  pHelpText.helpTitle ¬ KDMmsg.message[helpTitle];  pHelpText.textBody [0] ¬ KDMmsg.message[helpText0];  --  Now get an AMenuOfSelections to hold all the pointers and menu title.  pAMenuOfSelections ¬ Odi.GetAMenuOfSelections [];   pAMenuOfSelections.menuTitle ¬ KDMmsg.message[menuTitle];  pAMenuOfSelections.menuHelp ¬ pHelpText;  -- Help for entire menu  pAMenuOfSelections.userSelections ¬ pUserSelections;  pAMenuOfSelections.adminSelections ¬ pAdminSelections;  pAMenuOfSelections.seSelections ¬ pSESelections;  pAMenuOfSelections.manufacturingSelections ¬ pManufacturingSelections;  pAMenuOfSelections.programmerSelections ¬ pProgrammerSelections;  pAMenuOfSelections.testItemsForThisNode ¬ pTestItemsForThisNode;    END;  -- InitialaizePackage.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDURE exported to the Control Module.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RunKbdDsplMouseTests: PUBLIC Odi.ClientPackage =  BEGIN      --~~~~~~~~~~~~~~~~~    -- Main line code.    --~~~~~~~~~~~~~~~~~    START MessagesAndKeyboard [! Runtime.StartFault => CONTINUE];    cantTalkToEEProm ¬ FALSE;    SysConfigChannelDefs.Initialize[!       Runtime.UnboundProcedure, Runtime.ControlFault => {        cantTalkToEEProm ¬ TRUE; CONTINUE}];    InitializePackage [];		    RETURN [pAMenuOfSelections];    END;  END... KDMOfflineDiagnosticsDove.mesa  LOGCreated  on 22-Feb-85 7:47:42 by KLEdited 24-Sep-86 11:50:10 by JGE Added Circles subroutine.Edited 6-Jan-87 15:04:12 by KXW  Fixed bugs in AdjustDataField and modified User Interface of Display Alignment Adjusting.Edited 10-Feb-87 15:33:13 by KXW, Make common this diagnostics for Daybreak and Daisy.Edited 17-Feb-87 16:02:41 by KXW, Added to put alignDisplayDefault in AdjustDataField.Edited 23-Feb-87 18:03:28 by KXW, AR10295 Fixed.Edited 26-Feb-87 11:12:21 by KXW, Change upAlignBound in AdjustDataField.Edited 12-Mar-87 17:53:47 by KXW, Fixed bug in DoVerticals.
-- File: OfflineFloppyDiskUtilitiesDove.mesa-- Last edited  9-Jun-89 19:15:30  by TXM ---- Copyright (C) 1985 Xerox Corporation. All rights reserved.--DIRECTORY  Runtime	       USING [ StartFault],  Volume               USING [ ID, Open, Close, NeedsScavenging, nullID,  			       InsufficientSpace],  SpecialVolume        USING [ SubVolume, nullSubVolume],  PhysicalVolume       USING [ Handle, ID, nullID, GetNextLogicalVolume,			       Error, maxSubvolumesOnPhysicalVolume,			       NeedsScavenging, Offline, FinishWithNonPilotVolume,			       AssertPilotVolume, GetNextDrive, GetNext,			       nullDeviceIndex, GetAttributes, GetHandle],  FloppyChannel	       USING [ Context, SetContext, GetHandle, Status,   			       FormatTracks, Error, DiskAddress, ReadSectors,			       WriteSectors, Drive, Handle, Attributes, 			       GetNextDrive, nullDrive, GetDeviceAttributes],  File                 USING [ Create, Delete, File, PageCount],  FileTypes            USING [ tUntypedFile],  Space	               USING [ Interval, Allocate, wordsPerPage, UnmapAt, MapAt,  			       virtualMemory],  DiagDiskTime	       USING [ SetRealTimeClock, RealTimeClockFailure],  DiagDiskMkTime       USING [ DiagDiskMkTimeImpl, mkTime],    OfflineDiagInterface USING [ OfflineDiagnosticProc, ResultType,			       TestItemsForThisNode, GetATestItemsForThisNode,			       TestItem, GetATestItem, ClientPackage,			       AMenuOfSelections, GetAMenuOfSelections,			       Selections, GetASelectionArray,			       HelpText, GetAHelpText, AbortCurrentTest,			       FixedPositionDisplayRecord, ARow, GetARow,			       DisplayFixedPositionData,			       GetAFixedPositionDisplayRecord,			       PutMessage, PutData, HitAnyKeyToContinue,			       GetYesNo, GetANumber],  FloppyDiskUtilMessagesDove   USING [ FloppyUtilMessages, fuMsgPointer],  FloppyDiskUtilMessagesImplDove,  OfflineDiagInterfaceExtra USING [];  -- Export this OfflineFloppyDiskUtilitiesDove: PROGRAM	 IMPORTS PhysicalVolume, Runtime, Volume, 		 FloppyChannel, File, Space, 	 	 OfflineDiagInterface, DiagDiskTime, DiagDiskMkTime,		 FloppyDiskUtilMessagesDove,		 MessageKeyFile: FloppyDiskUtilMessagesImplDove		 	 	 EXPORTS OfflineDiagInterfaceExtra =BEGIN OPEN Odi: OfflineDiagInterface,	   PV: PhysicalVolume,	   FC: FloppyChannel;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- First declare various structures and constants that will be used.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~  --  -- topLevelMenuNode points to a RECORD, AMenuOfSelections, containing pointers    -- to various elements of the top level menu node.   --  -- Each menu item may be a real test or a submenu. Each submenu is also a  -- AMenuOfSelections.  --    topLevelMenuNode: LONG POINTER TO Odi.AMenuOfSelections;    -- topLevelMenuSelections points to a SEQUENCE containing pointers to all    -- TestItems in the topmenu.  topLevelMenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;     -- Test numbers for the topLevelMenuNode defined for clarity convenience.   -- These correspond to the topLevelMenuSelections indices into which   -- the pointers to TestItems are to be stored. They will be assigned  -- to the selections arrays for each class of user  --  copyAndDupFloppy: CARDINAL = 0;  --  topLevelMenuSelections.nodeItems [0]-- pTestItem points to a RECORD containing all the components of a TestItem.  pTestItem: LONG POINTER TO Odi.TestItem;  -- The following pointers point to SEQUENCES specifying tests for the various-- user classes.  pUserSelections: LONG POINTER TO Odi.Selections;  	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Declarations for convenience--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  nullResult: Odi.ResultType = none;  goodResult: Odi.ResultType = passed;  badResult: Odi.ResultType = failed;  ambiguousResult: Odi.ResultType = ambiguous;    defaultToYes: BOOLEAN = TRUE;  defaultToNo: BOOLEAN = FALSE;  noValue: CARDINAL = 0;    leftEdge: CARDINAL = 3;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Floppy disk info/definitions --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Density:          TYPE = {single, double};  density: Density = double;    trackZeroSectors: CARDINAL = 9;  trackZeroPages:   CARDINAL;  wordsPerPage: CARDINAL = Space.wordsPerPage;  -- 256  trackZeroContext: FloppyChannel.Context =     [protect: FALSE, format: IBM, density: single, sectorLength: 64];  cylinders: CARDINAL;    trackOneSectors:   CARDINAL = 9;  trackOnePages:     CARDINAL;  trackOneContext:   ARRAY Density OF FloppyChannel.Context = [     single: [protect: FALSE, format: IBM, density: single, sectorLength: 64],     double: [protect: FALSE, format: IBM, density: double, sectorLength: 128]];    cylinderZeroPages: CARDINAL;  dataTracksContext: ARRAY Density OF FloppyChannel.Context = [     single: [protect: FALSE, format: IBM, density: single, sectorLength: 256],     double: [protect: FALSE, format: IBM, density: double, sectorLength: 256]];  dataSectorsPerTrack: CARDINAL ¬ 9; -- maybe 15    -- dataSectorsPerTrack: ARRAY Density OF CARDINAL = [single: 8, double: 15];<< fileSize: ARRAY Density OF ARRAY [1..2] OF  File.PageCount = [     single: [        cylinderZeroPages+dataSectorsPerTrack[single]*(cylinders-1)*1,	cylinderZeroPages+dataSectorsPerTrack[single]*(cylinders-1)*2],     double: [        cylinderZeroPages+dataSectorsPerTrack[double]*(cylinders-1)*1,	cylinderZeroPages+dataSectorsPerTrack[double]*(cylinders-1)*2]];>>  fileSize: File.PageCount;  space: Space.Interval = Space.Allocate[count: 40, within: Space.virtualMemory];    -- one double d track      Error: ERROR [err: FloppyError] = CODE;    FloppyError: TYPE = {accessProblem, formatError, lvNeedsScavenging, noFDD, noLVAvailable, readError, useDoubleSidedDisk, useSingleSidedDisk, writeError, writeProtected};    floppyDrive: FC.Drive;  floppyHandle0: FC.Handle;  heads:  CARDINAL;  floppyAttributes: FC.Attributes;    file:  File.File;  fileCreated: BOOLEAN ¬ FALSE;  duplicating: BOOLEAN;  -- TRUE => Copying master image to floppy  checksum: CARDINAL;  masterChecksum: CARDINAL;  -- Checksum of the master image  copyChecksum: CARDINAL;  -- Checksum of the dupicated diskette  masterDisketteCS: LONG POINTER TO Odi.FixedPositionDisplayRecord;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Rigid disk info/definitions --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  rigidDiskIndex: CARDINAL;  -- Index associated with a drive  pvHandle: PhysicalVolume.Handle;  -- Handle for accessing the drive  pvID: PhysicalVolume.ID ¬ PhysicalVolume.nullID;    masterCopyVolume: Volume.ID;  -- Volume where the master copy is stored-- Help texts  dupAndCSHelp: LONG POINTER TO Odi.HelpText;  fuMsg: LONG POINTER TO ARRAY FloppyDiskUtilMessagesDove.FloppyUtilMessages  	 		 OF LONG STRING;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common support procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Print error message encountered --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~PrintErrorMsg: PROC [err: FloppyError] =  BEGIN    Odi.PutMessage[      SELECT err FROM        accessProblem => fuMsg[problemAccessingFloppy],	formatError => fuMsg[floppyFormatError],	lvNeedsScavenging => fuMsg[lvNeedsScavenging],	noFDD => fuMsg[noFDD],	noLVAvailable => fuMsg[noLVAvailable],	readError => fuMsg[readError],	useDoubleSidedDisk => fuMsg[useDoubleSidedDisk],	useSingleSidedDisk => fuMsg[useSingleSidedDisk],	writeError => fuMsg[writeError],	writeProtected => fuMsg[writeProtected],	ENDCASE => fuMsg[unexpectedError]]    END;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PauseAndQuit--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~PauseAndQuit: PROCEDURE =   BEGIN    Odi.HitAnyKeyToContinue[]; SIGNAL Odi.AbortCurrentTest;    END;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Get rigid disk parameters and put disk online--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GetRigidDiskParamsAndOnlineIt: PROCEDURE = {   ENABLE { PV.Error => {               Odi.PutMessage[ message:fuMsg[unableToAccesssRD], beep: TRUE];     	       PauseAndQuit[] };	    PV.NeedsScavenging => {	       Odi.PutMessage[message: fuMsg[RDneedsScavenging], beep: TRUE];	       PauseAndQuit[] }};   -- Set up rigid disk drive parameters   rigidDiskIndex ¬ PV.GetNextDrive [PV.nullDeviceIndex]; -- Unit 0      -- Check for drive existence   IF rigidDiskIndex = PV.nullDeviceIndex THEN {      Odi.PutMessage[message: fuMsg[noRDconfigured]]; PauseAndQuit[] };      pvHandle ¬ PhysicalVolume.GetHandle [rigidDiskIndex];   PhysicalVolume.FinishWithNonPilotVolume [pvHandle -- Offline just in case   	! PV.Error => IF error = hasPilotVolume THEN {	                 ForceDriveOffline [pvHandle]; CONTINUE }];      pvID ¬ PV.AssertPilotVolume [pvHandle];   }; -- GetRigidDiskParamsAndOnlineIt		   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Get floppy drive exits and get floppy parameters  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GetFloppyDriveParamters: PROCEDURE = {  IF (floppyDrive ¬ FC.GetNextDrive[FC.nullDrive]) = FC.nullDrive THEN {     Odi.PutMessage[fuMsg[noFloppyDrive]]; PauseAndQuit[] };       floppyHandle0 ¬ FC.GetHandle[floppyDrive];  -- Handle to floppy drive  floppyAttributes ¬ FC.GetDeviceAttributes[floppyHandle0];  heads ¬ floppyAttributes.numberOfHeads;  cylinders ¬ floppyAttributes.numberOfCylinders;  IF cylinders > 114B THEN -- 1.2MB  	dataSectorsPerTrack ¬ 17B;    trackZeroPages ¬ (trackZeroSectors*trackZeroContext.sectorLength +     wordsPerPage-1)/wordsPerPage;    trackOnePages ¬ (trackOneSectors*trackOneContext[double].sectorLength +     wordsPerPage-1)/wordsPerPage;        cylinderZeroPages ¬ trackZeroPages + trackOnePages;     fileSize ¬ cylinderZeroPages + dataSectorsPerTrack*(cylinders)*heads  };--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Offline physical volume	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ForceDriveOffline: PROCEDURE [h: PhysicalVolume.Handle] =  BEGIN    p: PhysicalVolume.ID ¬ PhysicalVolume.nullID;    DO      p ¬ PhysicalVolume.GetNext[p]; -- Get the ID of the drive (Only one ... 0)      IF p = PhysicalVolume.nullID THEN EXIT;  -- No drive exits      IF h = PhysicalVolume.GetAttributes[p].instance THEN { -- Compare 	 PhysicalVolume.Offline [p 	   ! PV.Error => IF error = physicalVolumeUnknown THEN CONTINUE];	 EXIT};      ENDLOOP;    END;   		   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- SetContext--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SetContext: PROC [c: FloppyChannel.Context, readOnly: BOOLEAN ¬ FALSE] = {  c.protect ¬ readOnly;  IF NOT FloppyChannel.SetContext[floppyHandle0, c].ok THEN Error[accessProblem]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Reads in an image of the diskette and calculates its checksum--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ReadFloppy: PROC = {  -- ReadFloppy3     UNTIL Odi.GetYesNo[prompt: fuMsg[insertSource], defaultSpecified: TRUE,  	default: defaultToYes] DO {} ENDLOOP;       floppyHandle0 ¬ FloppyChannel.GetHandle[0];  copyChecksum ¬ masterChecksum ¬ checksum ¬ 0B;    Odi.PutMessage[fuMsg[readingSource]];  SetContext[trackZeroContext, TRUE];  ReadFloppySectors[[cylinder: 0, head: 0, sector: 1], trackZeroSectors,  		    space.pointer, 0];		      IF heads=2 THEN {  -- Need to read in track 1 of cylinder 0     SetContext[trackOneContext[density], TRUE];     ReadFloppySectors[        [cylinder: 0, head: 1, sector: 1],	trackOneSectors, << p, >> space.pointer, trackZeroPages]};	  SetContext[dataTracksContext[density], TRUE];  -- The rest of the diskette  FOR hd: CARDINAL IN [0..heads) DO     FOR c: CARDINAL IN [1..cylinders) DO         ReadFloppySectors[          [cylinder: c, head: hd, sector: 1],	  dataSectorsPerTrack,	  space.pointer,	  (cylinderZeroPages + ((hd*cylinders + (c-1)) * dataSectorsPerTrack))];       ENDLOOP;    ENDLOOP;       Odi.PutMessage[message: fuMsg[completed], beep: TRUE, startWithNewLine: FALSE];  }; -- ReadFloppy--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Copy the contents of the diskette image file on the rigid disk to the-- destination diskette. The diskette is formatted first--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~CopyMasterToFloppy: PROC = {   status: FloppyChannel.Status;      UNTIL Odi.GetYesNo[prompt: fuMsg[insertDestination], defaultSpecified: TRUE,   	 default: defaultToYes] DO {} ENDLOOP;          floppyHandle0 ¬ FloppyChannel.GetHandle[0];   SetContext[dataTracksContext[density]];      Odi.PutMessage[fuMsg[copyingMaster]];   [status: status] ¬ FloppyChannel.FormatTracks[                      floppyHandle0, [1, 0, 1], (cylinders-1)*heads                      ! FloppyChannel.Error => Error[formatError]];		         IF status # goodCompletion THEN      Error[IF status = writeFault THEN writeProtected ELSE writeError];         FOR hd: CARDINAL IN [0..heads) DO     FOR c: CARDINAL IN [1..cylinders) DO        WriteFloppySectors[	 [cylinder: c, head: hd, sector: 1], 	 dataSectorsPerTrack,	 space.pointer, 	 (cylinderZeroPages + ((hd*cylinders + (c-1)) * dataSectorsPerTrack))];       ENDLOOP;     ENDLOOP;   IF heads=2 THEN {      SetContext[trackOneContext[density]];      [] ¬ FloppyChannel.FormatTracks[floppyHandle0, [0, 1, 1], 1           ! FloppyChannel.Error => Error[formatError]];      WriteFloppySectors[           [cylinder: 0, head: 1, sector: 1], 	   trackOneSectors, 	   space.pointer, trackZeroPages]};      SetContext[trackZeroContext];   [] ¬ FloppyChannel.FormatTracks[floppyHandle0, [0, 0, 1], 1        ! FloppyChannel.Error => Error[formatError]];   WriteFloppySectors[[cylinder: 0, head: 0, sector: 1], trackZeroSectors,        space.pointer, 0];   Odi.PutMessage[message: fuMsg[completed], startWithNewLine: FALSE];      Odi.PutMessage[fuMsg[verifyingDiskette]];   SetContext[dataTracksContext[density]];   duplicating ¬ TRUE;   ReadFloppySectors[ -- First verify data tracks      [cylinder: 1, head: 0, sector: 1],      dataSectorsPerTrack*heads*(cylinders-1), NIL, 0];         -- Now verify cylynder 0   SetContext[trackZeroContext];  -- Track 0   ReadFloppySectors[[cylinder: 0, head: 0, sector: 1], trackZeroSectors, NIL, 0];      IF heads=2 THEN {  -- Track 1      SetContext[trackOneContext[density]];      ReadFloppySectors[[cylinder: 0,head: 1,sector: 1],trackOneSectors,NIL,0]};         Odi.PutMessage[message:fuMsg[disketteCopied], beep:TRUE];   };  -- CopyMasterToFloppy      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- ReadFloppySectors--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ReadFloppySectors: PROC [a: FloppyChannel.DiskAddress, count: CARDINAL, 			 p: LONG POINTER,			 fileOffset: CARDINAL] = {  done: CARDINAL; -- Number of   status: FloppyChannel.Status;  sectorLength: CARDINAL;  temp: CARDINAL;    IF p#NIL THEN [] ¬      Space.MapAt[at: space, window: [file: file, base: fileOffset, count: count]];   BEGIN  -- Read count sectors from the diskette  ENABLE UNWIND => IF p#NIL THEN [] ¬ Space.UnmapAt[pointer: space.pointer];        [status, done] ¬ FloppyChannel.ReadSectors[floppyHandle0, a, p, count, p#NIL    				   ! FloppyChannel.Error => Error[readError]];    END; -- ENABLE block       IF p#NIL THEN {  -- Now calculate a checksum for the data read     sectorLength ¬        IF a.cylinder=0 THEN	   IF a.head=0 THEN trackZeroContext.sectorLength	   ELSE trackOneContext[density].sectorLength	ELSE dataTracksContext[density].sectorLength;     FOR offset: CARDINAL IN [0..count*sectorLength) DO        -- Per PrincOps        data: CARDINAL = (LOOPHOLE[p+offset, LONG POINTER TO UNSPECIFIED])­;	temp ¬ checksum + data;	IF checksum > temp THEN temp ¬ temp + 1;	IF temp >= 100000B THEN temp ¬ temp*2 + 1 ELSE temp ¬ temp*2;	checksum ¬ temp;	ENDLOOP;     };  IF duplicating THEN copyChecksum ¬ checksum ELSE masterChecksum ¬ checksum;  IF p#NIL THEN [] ¬ Space.UnmapAt[pointer: space.pointer];  IF done # count OR status # goodCompletion THEN Error[readError]    }; -- ReadFloppySectors    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- WriteFloppySectors--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~WriteFloppySectors: PROC [   a: FloppyChannel.DiskAddress, count: CARDINAL,   p: LONG POINTER, fileOffset: CARDINAL] = {      done: CARDINAL; status: FloppyChannel.Status;   THROUGH [0..10) DO  -- 9 sectors per track     [] ¬ Space.MapAt[at: space,           window: [file: file, base: fileOffset, count: count], access: readOnly];          BEGIN      ENABLE UNWIND => [] ¬ Space.UnmapAt[pointer: space.pointer];        	[status, done] ¬ FloppyChannel.WriteSectors[floppyHandle0,a,p,count,TRUE			 ! FloppyChannel.Error => Error[writeError]];	END;  -- ENABLE block          [] ¬ Space.UnmapAt[pointer: space.pointer];     IF done=count AND status = goodCompletion THEN EXIT;     [status, done] ¬ FloppyChannel.FormatTracks[floppyHandle0, a, heads        ! FloppyChannel.Error => Error[writeError]];	     REPEAT FINISHED => Error[writeError]     ENDLOOP};  -- WriteFloppySectors--*****************************************************************************-- Main procedures selectable from menu--*****************************************************************************--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Read the contents of a floppy diskette, store it on the rigid disk,-- calculates a checksum and make a copy of it.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~FloppyDuplicationAndCSFacility: PUBLIC Odi.OfflineDiagnosticProc =   BEGIN    lv:       Volume.ID;  -- System.VolumeID;    subVolume: SpecialVolume.SubVolume ¬ SpecialVolume.nullSubVolume;    masterAvailable: BOOLEAN;    needScavenging: BOOLEAN ¬ FALSE;    exitRequested: BOOLEAN ¬ FALSE;        masterDisketteCS.displayTitle ¬ NIL;    masterDisketteCS.rows[0].rowItems[0].namePosition ¬ 5;    masterDisketteCS.rows[0].rowItems[0].name ¬ fuMsg[masterCopyCS];    masterDisketteCS.rows[0].rowItems[0].stringValue ¬ NIL;    masterDisketteCS.rows[0].rowItems[0].valuePosition ¬         7 + masterDisketteCS.rows[0].rowItems[0].name.length;  BEGIN -- Main block   ENABLE UNWIND => { IF fileCreated THEN {  			File.Delete[file]; Volume.Close[lv]; 			PhysicalVolume.Offline [pvID]}};    fileCreated ¬ FALSE;     masterAvailable ¬ FALSE;        IF pvID # PV.nullID THEN ForceDriveOffline[pvHandle];    GetRigidDiskParamsAndOnlineIt[];    -- First find a good volume with enough space to store the diskette image    lv ¬ Volume.nullID;     FOR i: CARDINAL IN [0 .. PV.maxSubvolumesOnPhysicalVolume) DO    ENABLE UNWIND => Odi.PutMessage[fuMsg[unableToAccesssRD]];              lv ¬ PV.GetNextLogicalVolume[ pvID, lv       	       ! PV.Error => IF error = noSuchLogicalVolume THEN LOOP];              IF lv = Volume.nullID THEN {  -- Unable to locate a logical volume           IF i = 0 THEN Odi.PutMessage[fuMsg[noLVonRD]]	      ELSE Odi.PutMessage[fuMsg[insufficientSpaceOnRD]];	  PhysicalVolume.Offline [pvID];	  RETURN[nullResult] };	         Volume.Open[lv ! Volume.NeedsScavenging => LOOP];            file ¬ File.Create[volume: lv, initialSize: fileSize,        			  type: FileTypes.tUntypedFile	           ! Volume.InsufficientSpace => { Volume.Close[lv]; LOOP }];       fileCreated ¬ TRUE; masterCopyVolume ¬ lv; EXIT;       ENDLOOP;    -- From this point on, we know the floppy exits and a file has been    -- successfully created to hold the floppy disk image.    -- Now we need to find out all about the floppy drive characteristics    --    DO  -- Loop here until quit    ENABLE { Error => { PrintErrorMsg[err]; LOOP };    	     Odi.AbortCurrentTest => IF exitRequested THEN REJECT ELSE LOOP };        read: CARDINAL = 1; makeCopy: CARDINAL = 2; calculateCS: CARDINAL = 3;        duplicating ¬ FALSE;    SELECT Odi.GetANumber[prompt:fuMsg[specifyAction], help: dupAndCSHelp,       			  upperLimit: 4, defaultNumber: calculateCS].number FROM              read => { -- Read in the master diskette          ReadFloppy[];          Odi.PutMessage[fuMsg[masterRead]]; 	  masterAvailable ¬ TRUE; 	  masterDisketteCS.rows[0].rowItems[0].value ¬	  	 LONG[LOOPHOLE[masterChecksum]];	  Odi.DisplayFixedPositionData [masterDisketteCS, TRUE, FALSE]; LOOP };              makeCopy => {           IF ~masterAvailable THEN {Odi.PutMessage[fuMsg[readMasterFirst]]; LOOP};      	  CopyMasterToFloppy [];	  Odi.PutData[data: fuMsg[destinationCS], startWithNewLine:TRUE,		      numberAfterData: LONG[LOOPHOLE[copyChecksum]]]; LOOP };              calculateCS => {          ReadFloppy[];	  masterAvailable ¬ FALSE;	  Odi.PutData[data: fuMsg[sourceCS], startWithNewLine:TRUE,		      numberAfterData: LONG[LOOPHOLE[checksum]]];	  LOOP };			       ENDCASE => { exitRequested ¬ TRUE; SIGNAL Odi.AbortCurrentTest };       ENDLOOP;    END;  -- of ENABLE block    END; -- FloppyDuplicationAndCSFacility --******************************************************************************-- Build up all the data structures for this package--******************************************************************************InitializePackage: PROCEDURE = BEGIN--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Get a container to hold all items of the top menu node. This is passed to the-- Control Module.  topLevelMenuNode ¬ Odi.GetAMenuOfSelections [];-- There is 1 selection only; so we need a TestItemsForThisNode -- that can hold 1 pointers to the different TestItems.  topLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [1];  -- For each of the selections, an instance of TestItem is needed.  -- Diskette duplication and checksum utility  pTestItem ¬  Odi.GetATestItem [];   pTestItem.itemName ¬ fuMsg[copyAndCheckSumUtility];  pTestItem.test ¬ FloppyDuplicationAndCSFacility; -- The actual procedure  pTestItem.itemExplanation ¬ fuMsg[copyAndCheckSumUtilityExp]; -- Online help.  topLevelMenuSelections.nodeItems [0] ¬ pTestItem; -- Store TestItem pointer.-- Normal Users - 2 selections.  pUserSelections ¬ Odi.GetASelectionArray [1];  -- 1 selection only  pUserSelections.selections[0] ¬ copyAndDupFloppy;  -- Index  topLevelMenuNode.menuTitle ¬ fuMsg[topLevelMenuTitle]; -- Optional.  topLevelMenuNode.menuHelp ¬ NIL;  topLevelMenuNode.userSelections ¬ pUserSelections;  topLevelMenuNode.adminSelections ¬ pUserSelections;  topLevelMenuNode.seSelections ¬ pUserSelections;  topLevelMenuNode.manufacturingSelections ¬ pUserSelections;  topLevelMenuNode.programmerSelections ¬ pUserSelections;  topLevelMenuNode.testItemsForThisNode ¬ topLevelMenuSelections;-- Prepare help texts here    dupAndCSHelp ¬ Odi.GetAHelpText [3]; -- Help text for adding bad pages  dupAndCSHelp.helpTitle ¬ fuMsg[dupAndCSHelpTitle];  dupAndCSHelp.textBody[0] ¬ fuMsg[readMaster];  dupAndCSHelp.textBody[1] ¬ fuMsg[makeCopy];  dupAndCSHelp.textBody[2] ¬ fuMsg[calculateCS];-- Prepare positionally fixed display data  -- For displaying checksum for floppy image master  masterDisketteCS ¬ Odi.GetAFixedPositionDisplayRecord [1];  masterDisketteCS.rows[0] ¬ Odi.GetARow [1];  GetFloppyDriveParamters[];  END;  -- InitialaizePackage.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDURE exported to the Control Module.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RunFloppyDiscUtilities: PUBLIC Odi.ClientPackage =  BEGIN      --~~~~~~~~~~~~~~~~~    -- Main line code.    --~~~~~~~~~~~~~~~~~        START MessageKeyFile [! Runtime.StartFault => CONTINUE];      fuMsg ¬ FloppyDiskUtilMessagesDove.fuMsgPointer; -- Get pointer to messages    InitializePackage [];  -- Build up the menu tree and procedural data base    START DiagDiskMkTime.DiagDiskMkTimeImpl [! Runtime.StartFault => CONTINUE];    DiagDiskTime.SetRealTimeClock [displayMsg: TRUE        ! DiagDiskTime.RealTimeClockFailure => {	     Odi.PutData[data: DiagDiskMkTime.mkTime[rTCFailure],	                 clearHeadingAndData: TRUE] }];    RETURN [topLevelMenuNode];  -- Pass pointer to root node to Control Module    END;  -- Main line code  END...  OfflineFloppyDiskUtilitiesDove.mesa    LOGCreated by KL 11-Oct-85 7-Jan-86 14:14:07  by KL30-Jan-86  8:18:14 by ?12-Jan-88 11:55:48 by STC, fix bugs 1.2 MB CopyDisk, fileSize, SecSize, Write-loop 9-Jun-89 19:15:30 by TXM, added PhysicalVolume.Offline in FloppyDuplicationAndCSFacility
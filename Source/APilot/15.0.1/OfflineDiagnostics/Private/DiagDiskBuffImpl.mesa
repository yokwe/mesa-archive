-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: DiagDiskBuffImpl.mesa,   Last edited --- STC, 19-Sep-88 11:24:44, convert Labelless-- TXM, 17-Apr-89 10:13:34, change label data-- DIRECTORY CompatibilityDiskFace  USING	[Operation], DiagDiskCmdDrive	USING	[Cylinder, Head, Sector, SectorCount, Unit,				 MaxSector, MaxHead, UseSameDataBuff], DiagDiskTestControl	USING	[UseDiagData, UseFormatData], DiagRDCmds		USING	[DataSize, OpPtr], Inline			USING	[BITROTATE, BITSHIFT, HighHalf, LowByte,				 LowHalf], PhysicalVolume		USING	[PageNumber], PilotDiskFace		USING	[DiskAddress --, Operation --], DiagDiskBuff		USING	[]; DiagDiskBuffImpl: PROGRAM    IMPORTS	DiagDiskCmdDrive,	DiagDiskTestControl,	DiagRDCmds,	Inline    EXPORTS	DiagDiskBuff  =BEGIN -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears a buffer to all 0's  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ZeroBuffer:		PUBLIC PROCEDURE [			   ptr: LONG POINTER TO ARRAY OF WORD¬ NIL,			   size: CARDINAL¬ 0]  = BEGIN wordptr: CARDINAL¬ 0;  IF ptr= NIL THEN RETURN;  UNTIL wordptr>= size DO    ptr­ [wordptr] ¬ 0;    wordptr¬ wordptr+1; ENDLOOP;  END; --ZeroBuffer   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to compare read data against the written data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CompareData: PUBLIC PROCEDURE [		 goodDataPtr:	LONG POINTER TO ARRAY OF WORD¬ NIL,		 compareDataPtr:LONG POINTER TO ARRAY OF WORD¬ NIL,		 size:		CARDINAL¬ 0]	RETURNS [dataError:	BOOLEAN¬ FALSE,		 index:		CARDINAL¬0,		 expected:	CARDINAL,		 observed:	CARDINAL] = BEGIN dat1:		CARDINAL; dat2:		CARDINAL;  IF DiagDiskTestControl.UseFormatData THEN   GenFormatDataBuffer[ptr: goodDataPtr, size: size]   ELSE IF DiagDiskTestControl.UseDiagData THEN     GenDiagDataBuffer[ptr: goodDataPtr, size: size]; UNTIL index>= size OR dataError DO   dat1¬ compareDataPtr­ [index];   dat2¬ goodDataPtr­ [index];   index¬ index+1;   IF dat1# dat2 THEN   { dataError¬ TRUE; expected¬ dat2; observed¬ dat1;   }; ENDLOOP; END; --CompareData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to compare header data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   CompareHeader: PUBLIC PROCEDURE RETURNS [		multiBitError:	BOOLEAN¬ FALSE,		cylinderError:	BOOLEAN¬ FALSE,		headError:	BOOLEAN¬ FALSE,		sectorError:	BOOLEAN¬ FALSE,		failsLow:	BOOLEAN¬ FALSE,		bit:		CARDINAL¬ 0] = BEGIN   diskadr:	PilotDiskFace.DiskAddress; opptr:	LONG POINTER TO CompatibilityDiskFace.Operation¬ DiagRDCmds.OpPtr;   diskadr¬ opptr­.diskHeader;   IF diskadr.sector# DiagDiskCmdDrive.Sector THEN { sectorError¬ TRUE;   [multiBitFailure:	multiBitError,    failsLow:		failsLow,    failingBit:	bit]¬ GetBadBit [number: DiagDiskCmdDrive.Sector,		badNumber: diskadr.sector] }; IF multiBitError THEN RETURN;   IF diskadr.head# DiagDiskCmdDrive.Head THEN { headError¬ TRUE;   IF sectorError THEN   { multiBitError¬ TRUE; RETURN;   };    [multiBitFailure:	multiBitError,    failsLow:		failsLow,    failingBit:	bit]¬ GetBadBit [number: DiagDiskCmdDrive.Head,		badNumber: diskadr.head] }; IF multiBitError THEN RETURN;   IF diskadr.cylinder# DiagDiskCmdDrive.Cylinder THEN { cylinderError¬ TRUE;   IF sectorError OR headError THEN   { multiBitError¬ TRUE; RETURN   };    [multiBitFailure:	multiBitError,    failsLow:		failsLow,    failingBit:	bit]¬ GetBadBit [number: DiagDiskCmdDrive.Cylinder,		badNumber: diskadr.cylinder] }; bit¬ bit+ 1; END; --CompareHeader -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to compare read data against the written data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CompareLabel: PUBLIC PROCEDURE [		 data:		CARDINAL,		 goodDataPtr:	LONG POINTER TO ARRAY OF WORD,		 compareDataPtr:LONG POINTER TO ARRAY OF WORD,		 size:		CARDINAL]	RETURNS [labelError:	BOOLEAN¬ FALSE,		 index:		CARDINAL¬0,		 expected:	CARDINAL,		 observed:	CARDINAL] = BEGIN -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckData: PROCEDURE = BEGIN IF dat1# dat2 THEN { labelError¬ TRUE;   expected¬ dat2;   observed¬ dat1;   RETURN; }; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckPageNumber: PROCEDURE = BEGIN   pageNumber¬ AddrToPage[	cylinder:	DiagDiskCmdDrive.Cylinder,	head:		DiagDiskCmdDrive.Head,	sector:		DiagDiskCmdDrive.Sector];   pageNumber¬ pageNumber+ (DiagDiskCmdDrive.SectorCount- 1);   dat1¬ compareDataPtr­ [5];   dat2¬ Inline.LowHalf[pageNumber];   CheckData[];   dat1¬ compareDataPtr­ [6];   dat2¬ Inline.BITSHIFT[Inline.HighHalf[pageNumber], 9];   CheckData[]; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ptr:		CARDINAL¬ 0; dat1:		CARDINAL; dat2:		CARDINAL; pageNumber:	PhysicalVolume.PageNumber;  --first generate a good data compare buffer IF DiagDiskTestControl.UseDiagData OR DiagDiskTestControl.UseFormatData THEN   GenDiagLabelBuffer[	ptr:		goodDataPtr,	size:		size,	plusSectorCount:DiagDiskCmdDrive.SectorCount- 1] ELSE     GenLabelBuffer[	data:		data,	ptr:		goodDataPtr,	size:		size,	plusSectorCount:DiagDiskCmdDrive.SectorCount- 1]; IF DiagDiskTestControl.UseDiagData OR DiagDiskTestControl.UseFormatData THEN { UNTIL index >= size DO     dat1¬ compareDataPtr­ [index];     dat2¬ index;     IF index= 4 THEN index¬ 7 ELSE index¬ index+ 1;     CheckData[];   ENDLOOP;   CheckPageNumber[]; } ELSE { UNTIL index >= size DO     dat1¬ compareDataPtr­ [index];     dat2¬ goodDataPtr­ [index];     IF index= 4 THEN index¬ 7 ELSE index¬ index+ 1;     CheckData[];   ENDLOOP;   CheckPageNumber[]; }; END; --CompareLabel -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to generate data in a given buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GenDataBuffer: PUBLIC PROCEDURE [		data: CARDINAL¬ 0,		ptr:  LONG POINTER TO ARRAY OF WORD¬ NIL,		size: CARDINAL¬ 256] = BEGIN 		 FOR wordptr: CARDINAL IN [0..size) DO   ptr­ [wordptr] ¬ data ENDLOOP; END; --GenDataBuffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to generate special diagnostic data to be written -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GenDiagDataBuffer: PUBLIC PROCEDURE [ptr: LONG POINTER TO ARRAY OF WORD¬ NIL,				  size:	CARDINAL¬ 256] = BEGIN  cylinder:	CARDINAL¬ DiagDiskCmdDrive.Cylinder; head:		CARDINAL¬ DiagDiskCmdDrive.Head; sector:	CARDINAL¬ DiagDiskCmdDrive.Sector; sectorCount:	CARDINAL; data1:		CARDINAL; data2:		CARDINAL; wordptr:	CARDINAL; pageNumber:	PhysicalVolume.PageNumber;  --set up the sector count IF DiagDiskCmdDrive.UseSameDataBuff= 1 THEN  sectorCount¬ 1 ELSE sectorCount¬ size/DiagRDCmds.DataSize; wordptr¬ 0; UNTIL sectorCount<= 0 DO   pageNumber¬ AddrToPage[cylinder: cylinder, head: head, sector: sector];   ptr­ [wordptr]¬ DiagDiskCmdDrive.Unit;   wordptr¬ wordptr+1;   ptr­ [wordptr]¬  cylinder;   wordptr¬ wordptr+1;   ptr­ [wordptr] ¬ head;   wordptr¬ wordptr+1;   ptr­ [wordptr] ¬ sector;   wordptr¬ wordptr+1;   data1¬ data2¬ DiagDiskCmdDrive.Unit+ cylinder+ head+ sector;   UNTIL wordptr>= 256 DO     ptr­ [wordptr] ¬ data1;     data1¬ data1+ data2;     wordptr¬ wordptr+1;   ENDLOOP; --wordptr>= 256   pageNumber¬ pageNumber+ 1;   [cylinder: cylinder, head: head, sector: sector]¬ PageToAddr[pageNumber];   sectorCount¬ sectorCount- 1; ENDLOOP; --sectorCount<= 0 END; --GenDiagDataBuffer  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to generate data in a given buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GenFormatDataBuffer: PUBLIC PROCEDURE [		ptr:  LONG POINTER TO ARRAY OF WORD¬ NIL,		size: CARDINAL¬ 256] = BEGIN data: CARDINAL¬ 0;		 FOR wordptr: CARDINAL IN [0..size) DO   ptr­ [wordptr] ¬ 0;   ptr­ [wordptr] ¬ Inline.LowByte[data];   ptr­ [wordptr]¬ Inline.BITROTATE[value: ptr­ [wordptr], count: 8];   data¬ data+1;   ptr­ [wordptr] ¬ ptr­ [wordptr] + Inline.LowByte[data];   ptr­ [wordptr]¬ Inline.BITROTATE[value: ptr­ [wordptr], count: 8];   data¬ data+1; ENDLOOP; END; --GenFormatDataBuffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to generate data in a diagnostic label buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GenDiagLabelBuffer: PUBLIC PROCEDURE [		ptr:  LONG POINTER TO ARRAY OF WORD¬ NIL,		size: CARDINAL¬ 10,		plusSectorCount: CARDINAL¬ 0] = BEGIN pageNumber:	PhysicalVolume.PageNumber;		 FOR wordptr: CARDINAL IN [0..size) DO   ptr­ [wordptr] ¬ wordptr ENDLOOP;	 pageNumber¬ AddrToPage[	cylinder:	DiagDiskCmdDrive.Cylinder,	head:		DiagDiskCmdDrive.Head,	sector:		DiagDiskCmdDrive.Sector]; pageNumber¬ pageNumber+ plusSectorCount; ptr­ [5] ¬ Inline.LowHalf[pageNumber]; ptr­ [6] ¬ Inline.BITSHIFT[Inline.HighHalf[pageNumber], 9]; END; --GenDiagLabelBuffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to generate a standard label buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GenLabelBuffer: PUBLIC PROCEDURE [		data: CARDINAL¬ 0,		ptr:  LONG POINTER TO ARRAY OF WORD¬ NIL,		size: CARDINAL¬ 10,		plusSectorCount: CARDINAL¬ 0] = BEGIN pageNumber:	PhysicalVolume.PageNumber;		 FOR wordptr: CARDINAL IN [0..size) DO   ptr­ [wordptr] ¬ data ENDLOOP;	 pageNumber¬ AddrToPage[	cylinder:	DiagDiskCmdDrive.Cylinder,	head:		DiagDiskCmdDrive.Head,	sector:		DiagDiskCmdDrive.Sector]; pageNumber¬ pageNumber+ plusSectorCount; ptr­ [5] ¬ Inline.LowHalf[pageNumber]; ptr­ [6] ¬ Inline.BITSHIFT[Inline.HighHalf[pageNumber], 9]; END; --GenLabelBuffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- returns the picked or dropped bit between the given numbers -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      GetBadBit: PROCEDURE  [number:		CARDINAL,			 badNumber:		CARDINAL]		RETURNS [multiBitFailure:	BOOLEAN¬ FALSE,			 failsLow:		BOOLEAN¬ FALSE,			 failingBit:		CARDINAL¬ 0]  = BEGIN  bitArray:	ARRAY [0..15] OF BOOLEAN¬ ALL [TRUE];  bitErrorCnt:	CARDINAL¬ 0;  count:	CARDINAL¬ 16;  tempNum:	CARDINAL;  valueArray:	ARRAY [0..15] OF CARDINAL= [		  1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768];    tempNum¬ number;  UNTIL count= 0 DO    count¬ count- 1;    IF tempNum>= valueArray [count] THEN    { bitArray [count]¬ FALSE; tempNum¬ tempNum- valueArray [count] };  ENDLOOP;    IF number> badNumber THEN  { tempNum¬ number- badNumber; failsLow¬ TRUE;    count¬ 16;    UNTIL count= 0 DO      count¬ count- 1;      IF tempNum>= valueArray [count] AND NOT bitArray [count] THEN      { failingBit¬ count;        bitErrorCnt¬ bitErrorCnt+ 1;        tempNum¬ tempNum- valueArray [count] };    ENDLOOP };  IF number< badNumber THEN  { tempNum¬ badNumber- number; failsLow¬ FALSE;    count¬ 16;    UNTIL count= 0 DO      count¬ count- 1;      IF tempNum>= valueArray [count] AND bitArray [count] THEN      { failingBit¬ count;        bitErrorCnt¬ bitErrorCnt+ 1;        tempNum¬ tempNum- valueArray [count] };    ENDLOOP };  IF bitErrorCnt>1 THEN multiBitFailure¬ TRUE;     END; --GetBadBit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- convert a rigid disk address to a page number -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AddrToPage:  PUBLIC PROCEDURE[ 		cylinder: CARDINAL, head: CARDINAL, sector: CARDINAL]	RETURNS[pageNumber: PhysicalVolume.PageNumber] = BEGIN pageNumber¬ DiagDiskCmdDrive.Cylinder; pageNumber¬ (pageNumber*(DiagDiskCmdDrive.MaxHead+1)	*(DiagDiskCmdDrive.MaxSector+ 1)); pageNumber¬ pageNumber     +(DiagDiskCmdDrive.Head* (DiagDiskCmdDrive.MaxSector+ 1))     +(DiagDiskCmdDrive.Sector); END; --AddrToPage  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- convert  a page number to a rigid disk address -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PageToAddr:  PUBLIC PROCEDURE [pageNumber: PhysicalVolume.PageNumber] RETURNS 			[cylinder: CARDINAL, head: CARDINAL, sector: CARDINAL] =  BEGIN  cnt: CARDINAL¬ 0;  UNTIL pageNumber< ((DiagDiskCmdDrive.MaxHead+1)*(DiagDiskCmdDrive.MaxSector+1)) DO	pageNumber¬ pageNumber- ((DiagDiskCmdDrive.MaxHead+1)*(DiagDiskCmdDrive.MaxSector+1));	cnt¬ cnt+ 1; ENDLOOP; cylinder¬ cnt; cnt¬ 0; UNTIL pageNumber< (DiagDiskCmdDrive.MaxSector+1) DO	pageNumber¬ pageNumber- (DiagDiskCmdDrive.MaxSector+1);	cnt¬ cnt+ 1; ENDLOOP; head¬ cnt; cnt¬ 0; UNTIL cnt>= pageNumber DO    cnt¬ cnt+ 1; ENDLOOP; sector¬ cnt; END; --PageToAddr  END...  	 
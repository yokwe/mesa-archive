-- File: OfflineDiagnosticControlModuleA.mesa -- Last edited on 16-Oct-88 19:49:21  by STC---- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.--DIRECTORY  PilotClient	     	  USING [],  -- Exporting it  Runtime	          USING [ControlLink, IsBound,  				GetBuildTime, UnboundProcedure],  Time			  USING [Append, Unpack],  TTY                 	  USING [PutChar, GetChar, Handle, Create,  			   	 PutLongDecimal, UserAbort, ResetUserAbort],  UserTerminal	      	  USING [BlinkDisplay, Beep, Background,  				 SetBackground, SetBorder],   String	          USING [AppendChar, Equal, StringToNumber,  				 AppendNumber,  				 StringBoundsFault, InvalidNumber, Compare,				 AppendLongNumber, Copy, StringToLongNumber,				 AppendString],  Process             	  USING [Yield, Detach],  Heap			  USING [Create, Delete, systemZone, systemMDSZone],  Space			  USING [ScratchMap, Unmap, Error],  Inline		  USING [LowHalf],  System		  USING [GreenwichMeanTime],  CMDiagMsgKeysDove       USING [cmMsgKeys, InitializeCMDiagMsgKeys],  OfflineDiagTTYDove      USING [DiagPutText, charPos, currentLine,  				 SetTTYMode, rightEdge, bottomLine],  <<  DebuggerSubstituteImpl,  -- Replacement for debugger >>  OfflineDiagInterface 	  USING [ResultType, TestItem, LoginType, Selections,		      	     	 TestItemsForThisNode, OfflineDiagnosticProc,				 AMenuOfSelections, HelpText, OptionsRecord,				 ARow, AnOptionLine,				 FixedPositionDisplayRecord],    OfflineDiagInterfaceExtra USING [ ReadDiagnosticsPackage,				   GetVersion,				   EraseLoadedConfig, ValidateClients],  OfflineDiagnosticControlInternal;			     UtilityPilotClientImpl: PROGRAM  IMPORTS OfflineDiagTTYDove, TTY, Process, String, CMDiagMsgKeysDove,  	  UserTerminal, Inline, Heap, Space, Runtime, Time,	  OfflineDiagInterfaceExtra, OfflineDiagnosticControlInternal 	    EXPORTS PilotClient, OfflineDiagInterface =BEGIN  OPEN Msg: CMDiagMsgKeysDove, Dtty: OfflineDiagTTYDove,	    Odi: OfflineDiagInterface, Term: UserTerminal,	    OdiExtra: OfflineDiagInterfaceExtra, 	    Odci: OfflineDiagnosticControlInternal;  -- Context switching signals  AbortCurrentTest:		 PUBLIC SIGNAL = CODE;  -- Public SIGNAL  AbortToLoginMenu:		 SIGNAL = CODE;  AbortToSubsystemSelectionMenu: SIGNAL = CODE;  AbortToTopOfMenuForSubsystem:  SIGNAL = CODE;  EmptyDisplayTable:		 SIGNAL = CODE;  -- Menu is too large for display  MenuTooLarge:			SIGNAL;-- Off-Line Diagnostic Identifiaction  kernelVersion:		LONG STRING = "3.0";-- System Components:  ProgressStates: TYPE = { selfIDState, loginState, subsystemSelectionState,  			   runClientTestsState };  state: ProgressStates;  -- Source of help request 	   HelpContext: TYPE = { menuSelection, optionSelection, getNumber };-- Cursor-positioning and screen-partitioning markers  bMenuA: PUBLIC CARDINAL;  -- Beginning of Menu Area  msgX, msgY, bOfMA, endOfMA, dirtyML: CARDINAL;  -- Message Area Markers  bOfDA: PUBLIC CARDINAL;  -- Beginning of Data Area   dX, dY, dirtyDL, dataOffSet: CARDINAL;  spX, spY: CARDINAL;  -- Main selection prompt markers  auxPY, auxPX: CARDINAL;  -- Auxiliary prompt markers  pSPX: LONG POINTER TO CARDINAL ¬ @spX;  -- Position on prompt line  pAPX: LONG POINTER TO CARDINAL ¬ @auxPX;  -- Position on aux prompt line  RepositioningType: TYPE = { mainPromptLine, auxPromptLine, helpPromptLine };  homeLine: RepositioningType;  testNameX: CARDINAL;  -- Position to print test name  testNameY: CARDINAL = 2;  defaultPrinted: BOOLEAN ¬ FALSE; -- Default printed on prompt line  headingPrinted: BOOLEAN ¬ FALSE; -- Data area has a heading printed    leftEdge, topLine: CARDINAL = 0;   rightEdge, bottomLine: CARDINAL;  noDataWritten: BOOLEAN ¬ TRUE; -- TRUE => msg can overlap into Data Area  noMsgWritten: BOOLEAN ¬ TRUE;  linesPerItem: CARDINAL;  -- Spacing between menu items  fixedDataPrinted: BOOLEAN ¬ FALSE; -- Fixed Position data  pHelp, loginHelp: LONG POINTER TO Odi.HelpText ¬ NIL;  testN: CARDINAL;  -- Test number  clientRunning: BOOLEAN ¬ FALSE; -- TRUE => Client is in control  selectedExit: BOOLEAN ¬ FALSE; -- TRUE => "Return To Previous Menu" selected  -- Display control variables  CR: CHAR = 15C;  backSpace: CHAR = 10C;  space: CHAR  = 40C;  rubItOut: CHAR = 177C;   clearScreen: CHAR = 32C;    clearLineFromCursor: CHAR = 34C;  star: CHAR = 52C;  plus: CHAR = 53C;  minus: CHAR = 55C;  invertScreen: CHAR = 07C;  -- BEL. Used here to invert screen-- Selection-related variables    cSelection: CARDINAL; -- Current selection  menuCount: CARDINAL ¬ 0; -- Selections in a menu  cTest: LONG STRING ¬ NIL; -- Current test name.  globalOptionRecord: LONG POINTER TO Odi.OptionsRecord ¬ NIL;   globalParamRecord: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬ NIL;    userType: PUBLIC Odi.LoginType;  subSystem: LONG STRING ¬ NIL;  -- String indicating selected subsystem  selectionHelp: LONG POINTER TO Odi.HelpText;		    -- General system stuffs  -- System-wide strings  inputString: LONG STRING ¬ Heap.systemMDSZone.NEW [StringBody[110]];  userString: LONG STRING; -- For GetAString  auxPrompt: LONG STRING; -- Current prompt for axiliary prompt line  mainPrompt: LONG STRING; -- Current prompt for main prompt line(GetAnOption)  savedOptionHelp: LONG POINTER TO Odi.HelpText; -- For GetAnOption    hDiagTTY:  PUBLIC TTY.Handle; -- TTY Handle  inputChar: PUBLIC CHAR;  oldBackground: Term.Background;  background: Term.Background ¬ white;  abortSensed: PUBLIC BOOLEAN ¬ FALSE; -- TRUE => STOP hit  inputSensed: PUBLIC BOOLEAN ¬ FALSE; -- TRUE => An input char received  reDisplayMenu: BOOLEAN ¬ FALSE; -- TRUE => Reprint menu  DiagHeap: PUBLIC UNCOUNTED ZONE; -- Client spaces  spaceAllocated: BOOLEAN ¬ FALSE; -- TRUE => Deallocate spaces at exit  spacePtr: LONG POINTER; -- Pointer to allocated spaces  StringHeap: UNCOUNTED ZONE; -- For GetAString  recreateDiagHeap: BOOLEAN ¬ TRUE; -- TRUE => DiagHeap does not exit  nullResult: Odi.ResultType = none;  instanceName: LONG STRING = "DiagnosticTTY";  signPrinted: BOOLEAN ¬ FALSE; -- +/- is printed  positive: BOOLEAN ¬ FALSE;    getString: BOOLEAN ¬ FALSE; -- in GetAString  gettingANumber: BOOLEAN ¬ FALSE; -- in GetANumber  passWordMode: BOOLEAN ¬ FALSE;  UserProfile: TYPE = RECORD [ privilege: Odi.LoginType ¬ NormalUser,    	       testSubsystemSelected: LONG STRING ];		        userProfile: LONG POINTER TO UserProfile;  -- DiagContext defines a menu.  DiagContext: TYPE = RECORD [ menuTitle: LONG STRING,   -- Title for this menu.  	       menuHelp: LONG POINTER TO Odi.HelpText ¬ NIL,  	       backPointer: LONG POINTER TO DiagContext ¬ NIL,  	       itemSelected: CARDINAL ¬ 0,  -- Test selected.  	       contextMenu: LONG POINTER TO ContextMenu];  ContextMenu: TYPE = RECORD    [count: CARDINAL, menu: SEQUENCE menuSize: CARDINAL OF MenuItem];    MenuItem: TYPE = RECORD [    selectionNumber: CARDINAL,    selection: LONG POINTER TO Odi.TestItem,     selectionResult: Odi.ResultType,    pointerToContext: LONG POINTER TO DiagContext];			    currentContext, parentContext: LONG POINTER TO DiagContext ¬ NIL;--~~~~~~~~~~~~~~~~~~-- Public Procedures     --~~~~~~~~~~~~~~~~~~-- Allocates space for a TestItemGetATestItem: PUBLIC PROC RETURNS [pTestItem: LONG POINTER TO Odi.TestItem] = {  RETURN [DiagHeap.NEW [Odi.TestItem]]};-- Allocates space to hold all TestItems of a menu node GetATestItemsForThisNode: PUBLIC PROCEDURE [numberOfTestItemsInNode: CARDINAL]   RETURNS [pTestItemsForThisNode: LONG POINTER TO Odi.TestItemsForThisNode] = {   pTestItemsForThisNode ¬ DiagHeap.NEW    		 [Odi.TestItemsForThisNode[numberOfTestItemsInNode]];  pTestItemsForThisNode.count ¬ numberOfTestItemsInNode };	 -- Allocates space for the indices of pointers to TestItems GetASelectionArray: PUBLIC PROCEDURE [numberOfSelections: CARDINAL]  RETURNS [selectionsForClass: LONG POINTER TO Odi.Selections] = {  selectionsForClass ¬ DiagHeap.NEW [Odi.Selections[numberOfSelections]];  selectionsForClass.count ¬ numberOfSelections };-- AMenuOfSelections defines the content of a menu nodeGetAMenuOfSelections: PUBLIC PROCEDURE   RETURNS [pAMenuOfSelections: LONG POINTER TO Odi.AMenuOfSelections] = {  RETURN [DiagHeap.NEW [Odi.AMenuOfSelections]] };-- Help text spaceGetAHelpText: PUBLIC PROCEDURE [numberOfStrings: CARDINAL ¬ 0]  RETURNS [pHelpText: LONG POINTER TO Odi.HelpText] = {  pHelpText ¬ DiagHeap.NEW [Odi.HelpText[numberOfStrings]];  pHelpText.count ¬ numberOfStrings }; -- Fixed-location dataGetAFixedPositionDisplayRecord: PUBLIC PROCEDURE [rowCount: CARDINAL]  RETURNS [pDisplayRecord: LONG POINTER TO Odi.FixedPositionDisplayRecord] = {  pDisplayRecord ¬ DiagHeap.NEW [Odi.FixedPositionDisplayRecord[rowCount]];  pDisplayRecord.numberOfRows ¬ rowCount };-- Allocates space for a row of fixed-position display dataGetARow: PUBLIC PROCEDURE [numberOfDisplayItemsInARow: CARDINAL]  RETURNS [pARow: LONG POINTER TO Odi.ARow] = {  pARow ¬ DiagHeap.NEW [Odi.ARow[numberOfDisplayItemsInARow]];  pARow.itemsInARow ¬ numberOfDisplayItemsInARow };    -- Option menu spaceGetAnOptionsRecord: PUBLIC PROCEDURE [numberOfLines: CARDINAL]  RETURNS [pAnOptionLine: LONG POINTER TO Odi.OptionsRecord]= {  pAnOptionLine ¬ DiagHeap.NEW [Odi.OptionsRecord[numberOfLines]];  pAnOptionLine.numberOfOptionLines ¬ numberOfLines };-- Space for a line of options GetAnOptionLine: PUBLIC PROCEDURE [optionsPerLine: CARDINAL]  RETURNS [pAnOptionLine: LONG POINTER TO Odi.AnOptionLine] = {  pAnOptionLine ¬ DiagHeap.NEW [Odi.AnOptionLine[optionsPerLine]];  pAnOptionLine.numberOfOptionsPerLine ¬ optionsPerLine };-- Allocate memory in terms of pagesGetSpace: PUBLIC PROCEDURE [pageCount: CARDINAL] RETURNS [LONG POINTER] = {  spaceAllocated ¬ TRUE;  spacePtr ¬ Space.ScratchMap [count: pageCount]; RETURN [spacePtr] };--  Looks for the Abort KeyLookForAbort: PUBLIC PROC = {  IF abortSensed THEN {      abortSensed ¬ FALSE; -- STOP hit -- [] ¬ BackTrack[] };  Process.Yield [] }; -- Display an options menu for selectionGetAnOption: PUBLIC PROC [optionTable: LONG POINTER TO Odi.OptionsRecord ¬ NIL,  			  defaultOption: CARDINAL ¬ 0, -- 0 => No default			  optionPrompt: LONG STRING,			  optionHelp: LONG POINTER TO Odi.HelpText ¬ NIL,			  justDisplayTable: BOOLEAN ¬ FALSE]  	         RETURNS [selectedOption: CARDINAL] = {  thisLine: LONG POINTER TO Odi.AnOptionLine;  homeLine ¬ mainPromptLine; signPrinted ¬ FALSE;  IF optionTable # NIL THEN { -- Print option menu     tmpString: STRING ¬ [3];     linesPerItem ¬ IF optionTable.numberOfOptionLines >= 15 THEN 1 ELSE 2;     globalOptionRecord ¬ optionTable; -- Save globally     ClearScreenAndPutTitle [];     reDisplayMenu ¬ TRUE; -- Redisplay menu at end of test     IF globalOptionRecord.optionMenuTiTle # NIL THEN {         PositionAndPrint [0, bMenuA, globalOptionRecord.optionMenuTiTle];	bMenuA ¬ Dtty.currentLine + 2 };     -- Do for every line of options     FOR i: CARDINAL IN [0..globalOptionRecord.numberOfOptionLines) DO        thisLine ¬ globalOptionRecord.linesOfOptions[i];        -- Do for every option on a line        FOR j: CARDINAL IN [0..thisLine.numberOfOptionsPerLine) DO	   -- Print an option selection	   tmpString.length ¬ 0;	   String.AppendNumber [tmpString, -- Selection number	     thisLine.optionsOnALine[j].selectionNumberForThisItem];	   PositionAndPrint [thisLine.optionsOnALine[j].position,	     		     bMenuA + linesPerItem*i, tmpString];	   PositionAndPrint [Dtty.charPos + 1, Dtty.currentLine,	     		     Msg.cmMsgKeys[dash]]; -- Option	   PositionAndPrint [Dtty.charPos + 1, Dtty.currentLine,	     		     thisLine.optionsOnALine[j].option];	   ENDLOOP; -- thisLine loop        ENDLOOP; -- for the entire menu     savedOptionHelp ¬ optionHelp;     InitializePositionalMarkers [] };  mainPrompt ¬ optionPrompt; -- For ClearDefault  PrintPrompt [optionPrompt, spY, pSPX];  IF NOT justDisplayTable THEN     selectedOption ¬ GetSelection [defaultSelection: defaultOption,        pHelp: IF optionHelp = NIL THEN savedOptionHelp ELSE optionHelp,        helpContext: optionSelection];  inputString.length ¬ 0; RepositionCursor[] };-- Each datum has 3 fields: name, string-value, numberDisplayFixedPositionData: PUBLIC PROCEDURE [  displayData: LONG POINTER TO Odi.FixedPositionDisplayRecord,  clearDataArea: BOOLEAN ¬ FALSE, -- TRUE clears the Data Area 1st  upDateOnly: BOOLEAN ¬ TRUE -- FALSE => first time -- ] = {   offSet: CARDINAL; reprintHeading: BOOLEAN ¬ FALSE;    IF noDataWritten THEN PutData [];  IF clearDataArea THEN { dataOffSet ¬ 0; ClearDataArea[] };  IF displayData = NIL THEN RETURN; -- Nothing to display  fixedDataPrinted ¬ TRUE; -- Clears Data Area after test  IF NOT upDateOnly THEN  { -- First time/reprint hdg     dataOffSet ¬ 0; PutData [dataAreaHeading: displayData.displayTitle] };  -- Print rest of record   offSet ¬ IF displayData.displayTitle = NIL THEN 0 ELSE 1; -- was ELSE 2, STC  PrintRecord [displayData, bOfDA + offSet];    <<           IF clearDataArea THEN FALSE ELSE upDateOnly]; >>  IF NOT upDateOnly THEN { -- First time     dataOffSet ¬ dataOffSet + displayData.numberOfRows + 1;      dY ¬ bOfDA + dataOffSet; dirtyDL ¬ dY; dX ¬ 0 }};-- Display and update test parameters in the menu/option area.PutTestParameters: PUBLIC PROCEDURE   [parameters: LONG POINTER TO Odi.FixedPositionDisplayRecord,  upDateOnly: BOOLEAN ¬ TRUE -- FALSE => first time -- ] = {  IF parameters = NIL THEN { -- NIL => Clear everything     ClearScreenAndPutTitle[]; InitializePositionalMarkers[]; RETURN };  IF NOT upDateOnly THEN { -- "upDateOnly: FALSE" => first time through      ClearScreenAndPutTitle [];      reDisplayMenu ¬ TRUE; -- re-PutMenu at end of test     IF parameters.displayTitle # NIL THEN {        PositionAndPrint [0, bMenuA, parameters.displayTitle];        bMenuA ¬ Dtty.currentLine + 2 }}; -- Beginning of parameter area  -- Rest of record   PrintRecord [parameters, bMenuA --, upDateOnly -- ];  IF NOT upDateOnly THEN InitializePositionalMarkers [] };  -- First time only--  Y/N is defined in the Message Key fileGetYesNo:  PUBLIC PROCEDURE [    prompt: LONG STRING ¬ NIL,  help: LONG POINTER TO Odi.HelpText ¬ NIL,     defaultSpecified: BOOLEAN ¬ TRUE, default: BOOLEAN ¬ FALSE]  RETURNS [YesReturnsTrue: BOOLEAN ¬ TRUE] = {  String.Copy [inputString, -- Temporarily borrow this               IF prompt = NIL THEN Msg.cmMsgKeys[enterYesNoPrompt] ELSE prompt];    IF defaultSpecified THEN {      String.AppendChar [inputString, space];     String.AppendString [     	    inputString, IF default THEN Msg.cmMsgKeys[Yes] ELSE Msg.cmMsgKeys[No]] };  homeLine ¬ auxPromptLine;  PrintPrompt [inputString, auxPY, pAPX];  inputString.length ¬ 0;  DO  -- Loop until a vaild input is obtained.    RepositionCursor[]; GetAnInputChar[];    SELECT inputChar FROM      = '? => {  -- Help wanted.	IF help = NIL THEN PutMessage [message: Msg.cmMsgKeys[enterYesNoPrompt]]	   ELSE PrintHelp [helpText: help, reposX: auxPX, reposY: auxPY] };      = Msg.cmMsgKeys[Yes][0], Msg.cmMsgKeys[yes][0] => EXIT;      = Msg.cmMsgKeys[No][0], Msg.cmMsgKeys[no][0] => { YesReturnsTrue ¬ FALSE; EXIT };      = CR => { -- Valid only if defaultSpecified        IF defaultSpecified THEN { YesReturnsTrue ¬ default; EXIT }	ELSE { PutMessage [message: Msg.cmMsgKeys[enterYesNoPrompt]];	       defaultPrinted ¬ FALSE; inputString.length ¬ 0 }};      ENDCASE => { -- Illegal input        PutMessage [message: Msg.cmMsgKeys[enterYesNoPrompt]];	defaultPrinted ¬ FALSE };    ENDLOOP;  PositionAndPrint [0, auxPY]; -- Clean up line  ScreenTask [clearLineFromCursor] };-- Get STRING input from userGetAString:  PUBLIC PROCEDURE [prompt: LONG STRING ¬ NIL, -- Personalizeable msg    defaultString: LONG STRING ¬ NIL, help: LONG POINTER TO Odi.HelpText ¬ NIL,    echoWithStar: BOOLEAN ¬ FALSE]  RETURNS [LONG STRING] = {    ENABLE AbortCurrentTest => { getString ¬ FALSE; userString.length ¬ 0;     			       defaultPrinted ¬ FALSE; REJECT };  userString ¬ StringHeap.NEW [StringBody[80]]; getString ¬ TRUE;  signPrinted ¬ FALSE; defaultPrinted ¬ FALSE; homeLine ¬ auxPromptLine;  auxPrompt ¬ IF prompt=NIL THEN Msg.cmMsgKeys[enterNamePrompt] ELSE prompt;  PrintPrompt [auxPrompt, auxPY, pAPX];  passWordMode ¬ echoWithStar;  IF defaultString # NIL THEN { -- Print default     String.Copy [userString, defaultString];     PositionAndPrint [pAPX­, auxPY, userString]; defaultPrinted ¬ TRUE };  DO     RepositionCursor[]; ScreenTask [clearLineFromCursor]; GetAnInputChar[];     SELECT inputChar FROM       '? => {  -- Help request	  IF help = NIL	     THEN PutMessage [message: Msg.cmMsgKeys[enterNamePrompt]] -- Default help             ELSE PrintHelp [helpText: help, reposX: 	        auxPX + userString.length, reposY: auxPY] }; -- Help text       CR => { getString ¬ FALSE; passWordMode ¬ FALSE; RETURN [userString] };       ENDCASE => { -- Valid char	  String.AppendChar [userString, inputChar 	    ! String.StringBoundsFault => {PutMessage [Msg.cmMsgKeys[nameTooBig]];			      userString.length ¬ 0; LOOP }];	  IF defaultPrinted THEN ClearDefault[] }     ENDLOOP };-- Get a CARDINAL, LONG CARDINAL, desired direction from userGetANumber: PUBLIC PROCEDURE [prompt: LONG STRING ¬ NIL, -- Personalized prompt.    help: LONG POINTER TO Odi.HelpText, lowLimit: LONG CARDINAL,    upperLimit: LONG CARDINAL, numberIsHexadecimal: BOOLEAN ¬ FALSE,    numberIsLong: BOOLEAN ¬ FALSE,    defaultNumber: LONG CARDINAL ¬ LAST[LONG CARDINAL]]  RETURNS [longNumber: LONG CARDINAL, number: CARDINAL,    foreward: BOOLEAN ¬ TRUE, -- Directional default is foreward (+)    numberInStringFormat: LONG STRING] = {  ENABLE AbortCurrentTest => {gettingANumber ¬ FALSE; defaultPrinted ¬ FALSE;    	 inputString.length ¬ 0; signPrinted ¬ FALSE; positive ¬ FALSE; REJECT};  base: CARDINAL; maxShortCardinal: STRING = "65535";  maxLongCardinal: STRING = "4294967295"; maxShortHexNumber: STRING = "FFFF";  maxLongHexNumber: STRING = "FFFFFFFF"; outOfLimit: BOOLEAN ¬ FALSE;  maxShortNumber: CARDINAL ¬ Inline.LowHalf [upperLimit];  minShortNumber: CARDINAL ¬ Inline.LowHalf [lowLimit];  gettingANumber ¬ TRUE; positive ¬ FALSE;  homeLine ¬ auxPromptLine;   numberInStringFormat ¬ StringHeap.NEW [StringBody[10]];      auxPrompt ¬ SELECT TRUE FROM     prompt # NIL => prompt,     numberIsHexadecimal => Msg.cmMsgKeys [enterHexNumber],     ENDCASE => Msg.cmMsgKeys [enterDecimalNumber];  PrintPrompt [prompt, auxPY, pAPX]; inputString.length ¬ 0;      -- Default specified ?  IF defaultNumber # LAST[LONG CARDINAL] THEN { -- Yes     defaultPrinted ¬ TRUE; base ¬ IF numberIsHexadecimal THEN 16 ELSE 10;     String.AppendLongNumber [inputString, defaultNumber, base];     PositionAndPrint [pAPX­, auxPY, inputString] }  ELSE defaultPrinted ¬ FALSE;  DO  -- Loop until a valid number is obtained  ENABLE String.StringBoundsFault => { -- Too big    GiveRange [error: TRUE, helpContext: getNumber];    inputString.length ¬ 0; CONTINUE};  RepositionCursor[]; ScreenTask [clearLineFromCursor]; GetAnInputChar[];  SELECT inputChar FROM    IN ['0..'9] => { -- legal input       String.AppendChar[inputString, inputChar];       IF defaultPrinted THEN ClearDefault []};     '+, '-  => { -- Direction indicators       signPrinted ¬ TRUE; foreward ¬ IF inputChar = '- THEN FALSE ELSE TRUE;       positive ¬ foreward; PrintPrompt [auxPrompt, auxPY, pAPX];       ScreenTask [inputChar]; PositionAndPrint[auxPX + 1, auxPY, inputString] };	     IN ['A..'F] => {  -- Hex digits.        IF numberIsHexadecimal THEN { String.AppendChar [inputString, inputChar];	  IF defaultPrinted THEN ClearDefault [] }       ELSE { PutMessage [message: Msg.cmMsgKeys[decimalDigitsOnly]];       	      RepositionCursor[] }};    '? => { -- Display help text.       base ¬ IF signPrinted THEN 1 ELSE 0;       IF help = NIL -- No help text provided	  THEN { PutMessage [message: Msg.cmMsgKeys[legalDigits]];	         PositionAndPrint [auxPX + inputString.length + base, auxPY] }          ELSE PrintHelp [helpText: help,	       reposX: auxPX + inputString.length + base, reposY: auxPY] };    CR, space => { -- End of input       SELECT TRUE FROM -- Check upper bounds	 numberIsHexadecimal AND numberIsLong => {	   IF inputString.length > maxLongHexNumber.length THEN outOfLimit ¬ TRUE;	   IF String.Compare [inputString, maxLongHexNumber] = 1 	      THEN outOfLimit ¬ TRUE };	 numberIsHexadecimal => {	   IF inputString.length > maxShortHexNumber.length	      THEN outOfLimit ¬ TRUE;	   IF String.Compare [inputString, maxShortHexNumber] = 1	      THEN outOfLimit ¬ TRUE };	 numberIsLong => {	   IF inputString.length > maxLongCardinal.length THEN outOfLimit ¬ TRUE;	   IF String.Compare [inputString, maxLongHexNumber] = 1	      THEN outOfLimit ¬ TRUE };	 ENDCASE => -- Number is short Cardinal	   IF inputString.length > maxShortCardinal.length THEN outOfLimit ¬ TRUE;       IF inputString.length = 0 THEN outOfLimit ¬ TRUE;       IF NOT outOfLimit THEN {  -- Convert and check numeric bounds          longNumber ¬ IF numberIsHexadecimal THEN HexStringToLong [inputString]	               ELSE String.StringToLongNumber [inputString];	  number ¬ Inline.LowHalf [longNumber];          SELECT TRUE FROM -- Check numeric bounds	    numberIsLong => { IF (longNumber > upperLimit) OR	      (longNumber < lowLimit) THEN outOfLimit ¬ TRUE; number ¬ 0 };	    ENDCASE => { IF (number < minShortNumber) OR 	      (number > maxShortNumber) THEN outOfLimit ¬ TRUE; longNumber ¬ 0 }};       IF outOfLimit THEN { -- Input out of limit	  outOfLimit ¬ FALSE; PutMessage [message: inputString];	  PutMessage [message: Msg.cmMsgKeys[isOutOfRange], startWithNewLine: FALSE];	  inputString.length ¬ 0; LOOP};         -- Good number       IF NOT signPrinted THEN foreward ¬ TRUE;       String.Copy [numberInStringFormat, inputString]; EXIT};    ENDCASE => { -- Illegal inputChar       PutMessage [message: Msg.cmMsgKeys[illegalInput]];       PutMessage [message: Msg.cmMsgKeys[legalDigits]];       base ¬ auxPX + inputString.length;       IF signPrinted THEN base ¬ base + 1; PositionAndPrint [base, auxPY] };	     ENDLOOP; -- End input loop  -- Clear GetANumber prompt  PositionAndPrint [0, auxPY]; ScreenTask [clearLineFromCursor];  gettingANumber ¬ signPrinted ¬ positive ¬ FALSE };-- Display data in the Data AreaPutData: PUBLIC PROCEDURE [    data: LONG STRING ¬ NIL,    numberAfterData: LONG CARDINAL ¬ LAST[LONG CARDINAL],     dataAreaHeading: LONG STRING ¬ NIL, -- Permanent heading    clearHeadingAndData: BOOLEAN ¬ FALSE, -- Clears data and heading    clearDataAreaOnly: BOOLEAN ¬ FALSE, -- Clear below heading only    startWithNewLine: BOOLEAN ¬ FALSE,    numOfBlankLines: CARDINAL ¬ 0, blankSpaces: CARDINAL ¬ 0, -- Before printing    xPosition: CARDINAL ¬ 0,    pauseAtBottomOfDataArea: BOOLEAN ¬ FALSE] = {    rightEdgeMinus1: CARDINAL;  numString: LONG STRING ¬ [10];       IF startWithNewLine THEN  -- If at beginning of line, do not skip     IF dX # 0 THEN {dY ¬ dY + 1; dX ¬ 0 };  IF numOfBlankLines # 0 THEN {      dY ¬ dY + numOfBlankLines; IF dX > 0 THEN dY ¬ dY + 1; dX ¬ 0 };  IF noMsgWritten THEN { noMsgWritten ¬ FALSE; PrintBorder [bOfMA] };  IF noDataWritten THEN { noDataWritten ¬ FALSE;-- First time     endOfMA ¬ bOfDA - 2;  -- Change end of Message Area     IF msgY > endOfMA THEN { ClearDisplayRegion [endOfMA, bottomLine];        msgY ¬ endOfMA; msgX ¬ 0 };     PrintBorder [bOfDA] }; -- ='s  IF clearHeadingAndData THEN { -- Does not clear fixed-position data     headingPrinted ¬ FALSE;      dataOffSet ¬ IF dataOffSet >= 2 THEN dataOffSet - 2 ELSE 0;     ClearDataArea []; dY ¬ bOfDA + dataOffSet; dX ¬ 0 };  -- Heading, if already printed, must be cleared before a new one can be printed  IF dataAreaHeading # NIL AND NOT headingPrinted THEN {     headingPrinted ¬ TRUE; ClearDataArea [];      PositionAndPrint [0, bOfDA + dataOffSet, dataAreaHeading];     -- Constraint: dataAreaHeading must be less than a line wide     dataOffSet ¬ dataOffSet + 2; dY ¬ bOfDA + dataOffSet; dX ¬ 0;     ClearDataArea[] };  IF clearDataAreaOnly THEN ClearDataArea [];  rightEdgeMinus1 ¬ rightEdge - 1;  IF dX # 0 THEN dX ¬ dX + blankSpaces;  IF xPosition > 0 THEN dX ¬ xPosition;  IF data # NIL THEN {     IF dX + data.length >= rightEdgeMinus1 THEN { dY ¬ dY + 1; dX ¬ 0 };     IF dY >= bottomLine THEN { -- At bottom        IF pauseAtBottomOfDataArea THEN HitAnyKeyToContinue[Msg.cmMsgKeys[moreData]];        ClearDataArea [] };      PositionAndPrint [dX, dY, data]; dY ¬ Dtty.currentLine;     dirtyDL ¬ dY; dX ¬ Dtty.charPos };  -- See if any number to be appended to data  IF numberAfterData # LAST[LONG CARDINAL] THEN { -- Print number     numString.length ¬ 0; String.AppendLongNumber[numString, numberAfterData];     IF dX + numString.length >= rightEdgeMinus1 THEN {         dY ¬ dY + 1; dX ¬ 0 };     IF dY >= bottomLine THEN { -- At bottom        IF pauseAtBottomOfDataArea THEN HitAnyKeyToContinue[Msg.cmMsgKeys[moreData]];        ClearDataArea [] };      PositionAndPrint [dX, dY, numString];     dirtyDL ¬ dY; dX ¬ Dtty.charPos }};-- Put messages in Message RegionPutMessage: PUBLIC PROCEDURE [    message: LONG STRING ¬ NIL, beep: BOOLEAN ¬ FALSE,    startWithNewLine: BOOLEAN ¬ TRUE, -- Overrides spacing    numOfBlankLines: CARDINAL ¬ 0, -- Before printing    blankSpaces: CARDINAL ¬ 1,    -- Overrides lines and spaces    clearMessageAreaFirst: BOOLEAN ¬ FALSE] = {  IF noMsgWritten THEN {noMsgWritten ¬ FALSE; PrintBorder [bOfMA]}; -- First msg  SELECT TRUE FROM    (msgX = 0) AND (msgY = bOfMA) => msgY ¬ bOfMA;    numOfBlankLines # 0 => { msgY ¬ msgY + numOfBlankLines;       IF msgX # 0 THEN  msgY ¬ msgY + 1; msgX ¬ 0 };    startWithNewLine => { msgY ¬ msgY + 1; msgX ¬ 0 };    ENDCASE => msgX ¬ msgX + blankSpaces;  IF clearMessageAreaFirst THEN ClearMessageArea [];  -- Now see if we are at the bottom line.  IF msgY > endOfMA THEN ClearMessageArea[];  IF msgY = endOfMA AND (msgX + message.length) >= rightEdge      THEN ClearMessageArea[];  IF message = NIL THEN RETURN;  PositionAndPrint [msgX,msgY,message]; msgX ¬ Dtty.charPos;   msgY ¬ Dtty.currentLine; dirtyML ¬ msgY; IF beep THEN Term.Beep[] };-- Pause until an inputHitAnyKeyToContinue: PUBLIC PROCEDURE [  prompt: LONG STRING ¬ NIL, beep: BOOLEAN ¬ TRUE] = {  PrintPrompt [IF prompt = NIL THEN Msg.cmMsgKeys[anyKeyToContinue] ELSE prompt,  	       auxPY, pAPX];  IF beep THEN Term.Beep[]; inputSensed ¬ abortSensed ¬ FALSE;  UNTIL inputSensed DO    IF abortSensed THEN [] ¬ BackTrack[]; Process.Yield [] ENDLOOP;  inputSensed ¬ FALSE; RETURN };--~~~~~~~~~~~~~~~~~~~~-- Private procedures --~~~~~~~~~~~~~~~~~~~~PauseAndReturn: PROCEDURE = {  -- Pause for an input  inputSensed ¬ FALSE;  abortSensed ¬ FALSE;  UNTIL inputSensed DO      IF abortSensed THEN [] ¬ BackTrack[]; Process.Yield []; ENDLOOP;  inputSensed ¬ FALSE };-- Initialize markersInitializePositionalMarkers: PROCEDURE = {  spY ¬ Dtty.currentLine + 2;  -- Main selection prompt line   auxPY ¬ spY + 1;  -- Axilliary prompt line  noMsgWritten ¬ TRUE; -- Message Area empty  bOfMA ¬ spY + 4; -- Beginning of Message Area   msgY ¬ bOfMA; -- Current message line  msgX ¬ 0; -- Current position on message line  dirtyML ¬ bOfMA; -- Dirty message line  endOfMA ¬ bottomLine - 1; -- End of Message Area  noDataWritten ¬ TRUE; -- Data Area empty  bOfDA ¬ bOfMA + (bottomLine - bOfMA)/3;  -- Beginning of Data Area  dataOffSet ¬ 0; -- Offset into Data Area  fixedDataPrinted ¬ FALSE;  headingPrinted ¬ FALSE;  dY ¬ bOfDA;  -- Current data line   dX ¬ 0;  -- Position to start printing data on data line  dirtyDL ¬ dY };  -- Dirty data line-- Clear the default inputClearDefault: PROCEDURE = {  IF getString THEN  userString.length ¬ 0 ELSE inputString.length ¬ 0;   defaultPrinted ¬ FALSE;  PrintPrompt [IF homeLine = mainPromptLine THEN mainPrompt ELSE auxPrompt,  	       IF homeLine = mainPromptLine THEN spY ELSE auxPY,    	       IF homeLine = mainPromptLine THEN pSPX ELSE pAPX];  IF signPrinted THEN ScreenTask [IF positive THEN plus ELSE minus];  String.AppendChar [IF getString THEN userString ELSE inputString,inputChar];  ScreenTask [inputChar] }; -- Echo-- Print a record of fixed-position dataPrintRecord: PROCEDURE [record: LONG POINTER TO Odi.FixedPositionDisplayRecord,    startingRow: CARDINAL -- , valuesOnly: BOOLEAN  --] = {  line: CARDINAL ¬ startingRow; -- Current line  thisRow: LONG POINTER TO Odi.ARow; tmpString: STRING ¬ [10]; tmp: CARDINAL;  -- Once for each row   FOR i: CARDINAL IN [0 .. record.numberOfRows) DO     thisRow ¬ record.rows[i]; -- current row     IF line >= bottomLine THEN {         HitAnyKeyToContinue[Msg.cmMsgKeys[moreData]];	 ClearDisplayRegion [bOfDA + 2, line];	 line ¬ startingRow};     PositionAndPrint [1, line]; -- Start of new line                 -- Once for every item in row     IF thisRow.numberOfDisplayItemsInARow = 0 THEN LOOP; -- Empty row     FOR j: CARDINAL IN [0..thisRow.numberOfDisplayItemsInARow) DO        -- Print name if any	IF thisRow.rowItems[j].name # NIL THEN -- Name exits	   PositionAndPrint [thisRow.rowItems[j].namePosition, line,	      		     thisRow.rowItems[j].name];  -- Print name	-- Print STRING value	IF thisRow.rowItems[j].stringValue # NIL THEN { ScreenTask [space];	   PositionAndPrint[Dtty.charPos,line,thisRow.rowItems[j].stringValue]};	-- Need to clean up space between items        tmp ¬ SELECT TRUE FROM		thisRow.rowItems[j].valuePosition # 0 => -- value exits. Clear up		   thisRow.rowItems[j].valuePosition,  -- to value position		j < (thisRow.numberOfDisplayItemsInARow - 1) => -- More to go		   thisRow.rowItems[j+1].namePosition, -- Next item position	        j = (thisRow.numberOfDisplayItemsInARow - 1) => -- Last item	             rightEdge, 		ENDCASE => rightEdge; 	IF Dtty.charPos < tmp THEN FOR m: CARDINAL IN [Dtty.charPos..tmp)	   DO ScreenTask [space] ENDLOOP;	-- Print number		  	tmpString.length ¬ 0;		IF thisRow.rowItems[j].valuePosition # 0 THEN { -- value exits	   String.AppendLongNumber [tmpString, thisRow.rowItems[j].value];	   PositionAndPrint [thisRow.rowItems[j].valuePosition,line,tmpString];	   -- Blank over spaces not used	   IF j < (thisRow.numberOfDisplayItemsInARow - 1) AND -- Last item ?	      thisRow.rowItems[j+1].namePosition > Dtty.charPos THEN -- More	      FOR k: CARDINAL IN -- Clear to next item name		   [Dtty.charPos .. thisRow.rowItems[j+1].namePosition)		    DO ScreenTask [space] ENDLOOP }       ENDLOOP;  -- End of row loop       ScreenTask [clearLineFromCursor]; -- Clean up what ever is left       line ¬ line + 1;    ENDLOOP}; -- End of Record-- Ensure option exists and returns pointer to helpCheckOption: PROCEDURE [option: CARDINAL]    RETURNS [found: BOOLEAN, itemHelp: LONG STRING] = {  thisLine: LONG POINTER TO Odi.AnOptionLine;  FOR i: CARDINAL IN [0 .. globalOptionRecord.numberOfOptionLines) DO     -- Take care of every option on a line.     thisLine ¬ globalOptionRecord.linesOfOptions[i];     FOR j: CARDINAL IN [0 .. thisLine.numberOfOptionsPerLine) DO        IF option = thisLine.optionsOnALine[j].selectionNumberForThisItem THEN {	   found ¬ TRUE;itemHelp ¬ thisLine.optionsOnALine[j].helpForThisOption;	   RETURN}         ENDLOOP;  -- Line loop.     ENDLOOP;  -- Record loop.  found ¬ FALSE };   -- Option not found-- Get and Echo inputCharGetAnInputChar: PROCEDURE  = {  clearMessageArea: CHAR = 04C;  -- Clear  clearDataArea: CHAR = 05C;  -- Shift Clear  IF TTY.UserAbort [hDiagTTY] THEN TTY.ResetUserAbort[hDiagTTY];  DO    RepositionCursor[];    inputSensed ¬ FALSE; abortSensed ¬ FALSE;    UNTIL inputSensed DO { LookForAbort [] } ENDLOOP;    SELECT inputChar FROM      backSpace, rubItOut => {	defaultPrinted ¬ FALSE;	SELECT TRUE FROM	  getString => -- In GetAString	     IF userString.length # 0 THEN 	        userString.length ¬ userString.length - 1;	  inputString.length = 0 => {  	     IF signPrinted THEN PrintPrompt [auxPrompt, auxPY, pAPX];	     signPrinted ¬ FALSE };	  ENDCASE => inputString.length ¬ inputString.length - 1 };      '?, space, CR => { -- End of input	IF inputChar # '? THEN defaultPrinted ¬ FALSE; EXIT };      clearDataArea => {IF noDataWritten THEN LOOP; ClearDataArea[];      			RepositionCursor[] };      clearMessageArea => {IF noMsgWritten THEN LOOP; ClearMessageArea[];      			   RepositionCursor[] };      ENDCASE => { -- Echo only. Caller validates input 	SELECT TRUE FROM	   passWordMode => ScreenTask [star];	   gettingANumber => { -- Capitalize	      IF inputChar IN ['a .. 'f] THEN inputChar ¬ inputChar - 40B;	      ScreenTask [inputChar] };	   ENDCASE => ScreenTask [inputChar];         EXIT};    ENDLOOP };-- Detached process that senses inputsInputSensor: PROCEDURE = {  DO inputChar ¬ TTY.GetChar [hDiagTTY];      IF inputChar = invertScreen THEN {         background ¬ oldBackground;	oldBackground ¬ Term.SetBackground [oldBackground]; LOOP };     inputSensed ¬ TRUE; ENDLOOP };-- Reposition cursor and print stringPositionAndPrint: PROCEDURE [x, y: CARDINAL, prompt: LONG STRING ¬ NIL] = {  Dtty.DiagPutText [x, y, prompt]};-- Outputs a charScreenTask: PROCEDURE [task: CHAR] = {  TTY.PutChar [hDiagTTY, task]};-- Clear data areaClearDataArea: PROCEDURE = {  ClearDisplayRegion [bOfDA + dataOffSet, dirtyDL]; dY ¬ bOfDA + dataOffSet;  dirtyDL ¬ dY; dX ¬ 0};-- Prints a promptPrintPrompt: PROCEDURE [userPrompt: LONG STRING ¬ NIL, promptLine: CARDINAL ¬ spY,    ptrXPos: LONG POINTER TO CARDINAL] = {  PositionAndPrint [0, promptLine, IF userPrompt # NIL THEN userPrompt     ELSE Msg.cmMsgKeys[enterSelectionPrompt]];  ptrXPos­ ¬ Dtty.charPos + 1; -- Update line position  ScreenTask [clearLineFromCursor];  ScreenTask [space]}; -- SPACE once-- Move down the context treeGoDown: Odi.OfflineDiagnosticProc = {  parentContext ¬ currentContext;  currentContext ¬ parentContext.contextMenu[testN].pointerToContext;  PutMenu[]; RETURN [nullResult]};-- Go up the treeBackTrack: Odi.OfflineDiagnosticProc = {  SELECT state FROM     loginState => SIGNAL AbortToLoginMenu;  -- Top     subsystemSelectionState => {  	DeleteDiagHeap[]; SIGNAL AbortToLoginMenu };     runClientTestsState => {        IF currentContext # NIL AND clientRunning -- Not meaningful result	   THEN currentContext.contextMenu[testN].selectionResult ¬ nullResult;	IF clientRunning AND NOT selectedExit THEN SIGNAL AbortCurrentTest;	selectedExit ¬ FALSE;        IF parentContext = NIL THEN { -- At selected subsystem's top menu		   -- Exit will cause the loss of test data. Give warning	   IF subSystem # Msg.cmMsgKeys[sysConfigUtility] THEN {	      IF NOT GetYesNo [prompt: Msg.cmMsgKeys[exitWarning], default: FALSE]	         THEN { PutMessage [Msg.cmMsgKeys[testDataNotCleared]]; 	                SIGNAL AbortCurrentTest }}; -- Stay 				   -- Exit and reclaim space	   currentContext ¬ NIL;  -- Must NIL out for BuildContext	   DeleteDiagHeap []; state ¬ subsystemSelectionState;	   SIGNAL AbortToSubsystemSelectionMenu }	ELSE { -- Back up	   currentContext ¬ parentContext;	   parentContext ¬ currentContext.backPointer;	   reDisplayMenu ¬ TRUE; SIGNAL AbortCurrentTest}};     ENDCASE};-- Back up to previous menuUserSelectedBackUp: Odi.OfflineDiagnosticProc = {  selectedExit ¬ TRUE; [] ¬ BackTrack[] };  -- Detached process that looks for Abort'sAbortSensor: PROCEDURE = {  DO     IF TTY.UserAbort [hDiagTTY] THEN { -- User hit the stop key       TTY.ResetUserAbort [hDiagTTY]; abortSensed ¬ TRUE };    Process.Yield [];    ENDLOOP };-- Repositions cursor appropriatelyRepositionCursor: PROCEDURE = {  delta: CARDINAL;  -- length of string of concern  -- Caller handles first char if defaultPrinted. Need to check input validity  IF defaultPrinted THEN RETURN;  SELECT homeLine FROM    mainPromptLine => PositionAndPrint [spX + inputString.length, spY];    auxPromptLine => {      delta ¬ IF getString THEN userString.length ELSE inputString.length;      IF signPrinted THEN delta ¬ delta + 1;      PositionAndPrint [auxPX + delta, auxPY] };    ENDCASE;  ScreenTask [clearLineFromCursor] };-- Build a menu from TestItemsForThisMenu BuildContext: PROCEDURE [pSelections: LONG POINTER TO Odi.AMenuOfSelections] = {  --  -- Each context has certain EXIT selections made up from the following:  --  1)  Exit to higher level - Displayed when higher level is not the top menu  --                             for the current test subsystem selected.  --  2)  Exit to top of <current subsystem> - Displayed if below top menu for  --					        current subsystem selected.  --  3)  Exit to Subsystem Selection Menu. - This is top after LOGIN.  --  OPEN  sIN: pSelections.testItemsForThisNode, -- Allowable selections for user        cMenu: currentContext.contextMenu; -- Final context menu for user  arrayToUse: LONG POINTER TO Odi.Selections; -- Points to a class of users  numberOfSelections: CARDINAL; -- Size of context menu (number of tests)  exitSelection: CARDINAL = 1;    -- currentContext = NIL => At Subsystem Selection Menu  -- parentContext = NIL AND currentContext # NIL=>At top of selected Subsystem  IF currentContext # NIL THEN { -- Below Subsystem Selection Menu     -- NIL out subMenu. Do not want to build menu again for this selection     cMenu[testN].selection.subMenu ¬ NIL;     -- GoDown enables one to go back down the tree again later on     cMenu[testN].selection.test ¬ GoDown };       -- Get test array for person logged in  arrayToUse ¬ SELECT userType FROM     NormalUser => pSelections.userSelections,     Administrator => pSelections.adminSelections,     Services => pSelections.seSelections,     Manufacturing => pSelections.manufacturingSelections,     Programmer => pSelections.programmerSelections,     ENDCASE => NIL;       IF arrayToUse = NIL THEN { -- No test allowed for this user     HitAnyKeyToContinue[prompt: Msg.cmMsgKeys[noTestAllowed], beep: TRUE];     [] ¬ BackTrack[] };  numberOfSelections ¬ arrayToUse.count + exitSelection;  parentContext ¬ currentContext; -- Save old context  currentContext ¬ DiagHeap.NEW [DiagContext]; -- Create menu  currentContext.backPointer ¬ parentContext; -- backward pointer      -- Update link to this menu if appropriate (Below Top Level Menu)  IF parentContext # NIL THEN      parentContext.contextMenu[testN].pointerToContext ¬ currentContext;  -- Get menu title  currentContext.menuTitle ¬ IF pSelections.menuTitle = NIL     THEN Msg.cmMsgKeys[availableSelections] ELSE pSelections.menuTitle;  currentContext.menuHelp ¬ pSelections.menuHelp; -- Help for entire menu  -- Allocate space for the menuItems in this context   currentContext.contextMenu ¬ DiagHeap.NEW[ContextMenu[numberOfSelections]];  currentContext.contextMenu.count ¬ numberOfSelections;  -- Build ContextMenu according to order specified by programmer   FOR i: CARDINAL IN [0 ..  arrayToUse.count) DO     -- arrayToUse.selections[i] is the index into TestItemsForThisNode.     -- contextMenu[i].selection is pointer to TestItem     cMenu.menu[i].selection ¬ sIN[arrayToUse.selections[i]];     cMenu.menu[i].selectionNumber ¬ i + 1; -- Selection number of menu item.     cMenu.menu[i].selectionResult ¬ nullResult; -- Initialize result to none     ENDLOOP;  -- Add EXIT selection  numberOfSelections ¬ numberOfSelections - 1;  cMenu.menu[numberOfSelections].selection ¬ GetATestItem [];  cMenu.menu[numberOfSelections].selectionNumber ¬ numberOfSelections + 1;  cMenu.menu[numberOfSelections].selection.itemName ¬ Msg.cmMsgKeys[goToHigherMenu];  cMenu.menu[numberOfSelections].selection.itemExplanation ¬    Msg.cmMsgKeys[exitCurrentMenu];  cMenu.menu[numberOfSelections].selection.test ¬ UserSelectedBackUp;  cMenu.menu[numberOfSelections].selectionResult ¬ nullResult; -- Always null  reDisplayMenu ¬ TRUE };-- Display menu built by BuildContextPutMenu: PROCEDURE  = {  OPEN pMenu: currentContext.contextMenu; -- pMenu points to ContextMenu.  st: STRING ¬ [3];  -- Scratch pad.  numberOfMenuSelections: CARDINAL ¬ pMenu.count;  line: CARDINAL; reDisplayMenu ¬ FALSE;      ClearScreenAndPutTitle[];  PositionAndPrint [0, bMenuA, currentContext.menuTitle];      -- Single space if selections is >= 15.  IF numberOfMenuSelections < 15 THEN linesPerItem ¬ 2 ELSE linesPerItem ¬ 1;      FOR i: CARDINAL IN [ 0..numberOfMenuSelections ) DO -- Loop for every item     line ¬ bMenuA + linesPerItem * (1 + i); -- Where to print.     IF (Dtty.currentLine = bottomLine + 2) THEN SIGNAL MenuTooLarge;  -- %H     -- First print previous result, if any; none if item is a submenu or     -- menu is new. pContext.itemSelected = 0 => new menu with no results.     IF currentContext.itemSelected # 0 AND  -- 0 => Nothing ran from menu yet.        pMenu.menu[i].selection.subMenu = NIL THEN -- NIL => item is not a menu.        -- Display result of tests previousely ran.	PositionAndPrint [1, line, SELECT pMenu.menu[i].selectionResult FROM	    passed    => Msg.cmMsgKeys[PassedMark],  -- "P"	    failed    => Msg.cmMsgKeys[FailedMark],  -- "F"	    ambiguous => Msg.cmMsgKeys[ambiguousMark], -- "?"	    ENDCASE   => Msg.cmMsgKeys[blankIt] ];     -- Print selection number     st.length ¬ 0; String.AppendNumber [st, pMenu.menu[i].selectionNumber];     PositionAndPrint [4, line, st];     -- Print item name.     PositionAndPrint [Dtty.charPos + 1, line, Msg.cmMsgKeys[dash]];     PositionAndPrint [Dtty.charPos + 1, line, pMenu.menu[i].selection.itemName];     ENDLOOP;  -- End of printing menu.  InitializePositionalMarkers []; PrintPrompt [ptrXPos: pSPX];  -- Indicate last selection  IF currentContext.itemSelected # 0 THEN { --Something selected.     st.length ¬ 0;  -- Initialize temporary buffer.     String.AppendNumber [st, currentContext.itemSelected];     PutMessage [message: Msg.cmMsgKeys[lastSelection]];     PutMessage [message: st, startWithNewLine: FALSE]};  parentContext ¬ currentContext.backPointer; PositionAndPrint [spX, spY] };-- Print a line consisting of "="'sPrintBorder: PROCEDURE [startOfArea: CARDINAL] = {    borderLineChar: STRING = "="L;  FOR i: CARDINAL IN [leftEdge..rightEdge)      DO PositionAndPrint [i, startOfArea - 1, borderLineChar]; ENDLOOP};-- Prints test resultPrintResult: PROCEDURE = {  resultString: LONG STRING ¬ [3]; resultString.length ¬ 0;  resultString ¬ SELECT    currentContext.contextMenu[testN].selectionResult FROM      passed    => Msg.cmMsgKeys[PassedMark],  -- "P"      failed    => Msg.cmMsgKeys[FailedMark],  -- "F"      ambiguous => Msg.cmMsgKeys[ambiguousMark], -- "?"      ENDCASE   => Msg.cmMsgKeys[blankIt];  IF resultString = Msg.cmMsgKeys[blankIt] THEN RETURN;  -- Put result on menu  PositionAndPrint [1, bMenuA + linesPerItem * (testN + 1), resultString] };-- Get a valid selection from the user GetSelection: PROCEDURE [numberOfSelections: CARDINAL ¬ 0,    defaultSelection: CARDINAL ¬ 0,    pHelp: LONG POINTER TO Odi.HelpText ¬ NIL,    helpContext: HelpContext ¬ menuSelection] RETURNS [selection: CARDINAL] = {  OPEN CMenu: currentContext.contextMenu;  temp: CARDINAL; optionFound: BOOLEAN; requestedHelp: LONG STRING;      defaultPrinted ¬ FALSE; inputString.length ¬ 0; homeLine ¬ mainPromptLine;  IF defaultSelection # 0 THEN { -- Output default selection     String.AppendNumber [inputString, defaultSelection];     PositionAndPrint [spX, spY, inputString]; -- Always main prompt line     defaultPrinted ¬ TRUE };      DO  -- Loop until a valid input is obtained.  ENABLE AbortCurrentTest => {inputString.length ¬0;defaultPrinted ¬FALSE;REJECT};    RepositionCursor[]; ScreenTask [clearLineFromCursor]; GetAnInputChar[];    SELECT inputChar FROM      = '? => {  -- Help requested	 IF currentContext = NIL THEN { -- Control Module help	    PrintHelp [helpText: pHelp, reposX: spX, reposY: spY]; LOOP};	 -- currentContext # NIL => Client help	 IF (inputString.length = 0) THEN { -- Global menu help	    IF pHelp # NIL THEN PrintHelp [helpText: pHelp,	       reposX: spX, reposY: spY]	    ELSE GiveRange [numberOfSelections, FALSE, helpContext]; LOOP};	 -- Help for a specific item	 temp ¬ String.StringToNumber [inputString];	 IF helpContext = optionSelection THEN { -- Dealing with option menu	    inputString.length ¬ 0; defaultPrinted ¬ FALSE;	    [optionFound,requestedHelp] ¬ CheckOption [temp];	    PutMessage [message: IF optionFound AND requestedHelp # NIL THEN	      	        requestedHelp ELSE Msg.cmMsgKeys[noHelpForThisOption]]; LOOP};	 IF temp > numberOfSelections THEN { -- Dealing with selection menu	    GiveRange [numberOfSelections, TRUE, helpContext]; LOOP};	 -- Requesting help for a specific selection menu item	 temp ¬ temp - 1; -- Adjust index	 IF (CMenu.menu[temp].selection.itemExplanation = NIL)  	    THEN GiveRange [numberOfSelections, FALSE, helpContext] 	    ELSE PutMessage[message: CMenu.menu[temp].selection.itemExplanation];	    PositionAndPrint [spX+inputString.length, spY] };	      IN ['0..'9] => { -- Valid input. Save if not leading 0	  IF inputString.length = 0 AND inputChar = '0 THEN { -- No leading 0's	     GiveRange [numberOfSelections, TRUE, helpContext]; LOOP};	  String.AppendChar [inputString, inputChar! String.StringBoundsFault => {	     GiveRange [numberOfSelections, TRUE, helpContext]; LOOP}];	  IF defaultPrinted THEN ClearDefault[]};      = CR, space => {  -- Selection completed	 IF inputString.length = 0 THEN {	     GiveRange [numberOfSelections, TRUE, helpContext]; LOOP};	 selection ¬ String.StringToNumber[inputString !String.InvalidNumber => {	    GiveRange [numberOfSelections, TRUE, helpContext]; LOOP}];	 -- Check range limits	 IF helpContext = optionSelection THEN {	    IF CheckOption [selection].found THEN EXIT; defaultPrinted ¬ FALSE;	    GiveRange [numberOfSelections, TRUE, optionSelection]; LOOP };	 IF selection <= numberOfSelections THEN { -- Selection OK	    -- Update current context	    IF currentContext # NIL THEN { 	       currentContext.itemSelected ¬selection; selection ¬ selection-1};	    -- Adjust for indexing if running actual tests. Index = [0 .. n).	    EXIT}	 ELSE  GiveRange [numberOfSelections, TRUE, helpContext]};      ENDCASE => -- Illegal inputs	 GiveRange [numberOfSelections, TRUE, helpContext];    ENDLOOP };-- Give input rangeGiveRange: PROC [numOfSelections: LONG CARDINAL ¬ 0, error: BOOLEAN ¬ FALSE,		 helpContext: HelpContext ¬ menuSelection] = {  SELECT helpContext FROM    menuSelection => {       PutMessage [message: Msg.cmMsgKeys[helpForSelection]];      TTY.PutLongDecimal [hDiagTTY, IF currentContext = NIL 	 THEN numOfSelections ELSE currentContext.contextMenu.count]};    optionSelection => { -- Bad option input      PutMessage [message: Msg.cmMsgKeys[noSuchOption], beep: error];                  defaultPrinted ¬ FALSE;      PrintPrompt [mainPrompt, spY, pSPX]; ScreenTask [clearLineFromCursor] };    getNumber => {      PutMessage [message: inputString];      PutMessage [message: Msg.cmMsgKeys[isOutOfRange], startWithNewLine: FALSE] };    ENDCASE;  IF error THEN { inputString.length ¬ 0; Term.BlinkDisplay [] }};-- Print help arrayPrintHelp: PROCEDURE [helpText: LONG POINTER TO Odi.HelpText,		      reposX: CARDINAL, reposY: CARDINAL] = {  startOfHelpText: CARDINAL;  j: CARDINAL ¬ 0;  -- For positioning  noHelpTitle: BOOLEAN ¬ TRUE;      IF helpText = NIL THEN { GiveRange [numOfSelections: menuCount]; RETURN };      -- Enough space left to print help text ?  IF (msgY + helpText.count + 4) >= endOfMA THEN ClearMessageArea [];  -- Skip a line for easy reading  IF msgX # 0 OR msgY # bOfMA THEN msgY ¬ msgY + 1;   IF helpText.helpTitle # NIL THEN { PutMessage [message:helpText.helpTitle];        startOfHelpText ¬ Dtty.currentLine + 1; noHelpTitle ¬ FALSE };  IF noHelpTitle THEN startOfHelpText ¬ msgY;    -- Print help text.  FOR i: CARDINAL IN [0..helpText.count) DO     -- See if text fits into remaining space. If not stop and prompt     IF msgY = endOfMA - 1 THEN { -- At last line of Message Area	IF i < helpText.count - 1 THEN { -- Not last line of helpText	   PutMessage [message: Msg.cmMsgKeys[moreText]]; -- Prompt 	   homeLine ¬ helpPromptLine; GetAnInputChar [];	   SELECT inputChar FROM	      = space, CR, Msg.cmMsgKeys[Yes][0], Msg.cmMsgKeys[yes][0] => { 	          -- Clear text and display more text	          ClearDisplayRegion [IF noHelpTitle THEN bOfMA	      	      	              ELSE startOfHelpText, endOfMA]; j ¬ 0 };	      ENDCASE => { PositionAndPrint [reposX, reposY]; RETURN }}};     PositionAndPrint [3, startOfHelpText + j, helpText.textBody [i]];     dirtyML ¬ Dtty.currentLine; msgY ¬ dirtyML; -- Update line counter     j ¬ j + 1;      ENDLOOP;  msgY ¬ msgY + 1; -- Skip a line for clarity  PositionAndPrint [reposX, reposY]};--  Convert a hexadecimal string to a long numberHexStringToLong: PROCEDURE [hexString: LONG STRING] 		   RETURNS [hexValue: LONG CARDINAL] = {  hexChar: CHARACTER;  endChar: CHARACTER = 'Z;  stringIndex: CARDINAL ¬ 0;  digit: CARDINAL;  radix: CARDINAL = 16;      -- Local subproc that gets a hex char  GetHexChar: PROCEDURE = {    hexChar ¬ IF stringIndex >= hexString.length THEN endChar               ELSE hexString [stringIndex];    stringIndex ¬ stringIndex + 1 };  hexValue ¬ 0; GetHexChar [];   WHILE hexChar # endChar DO    digit ¬ SELECT hexChar FROM      	    'a,'A => 10,	    'b,'B => 11,	    'c,'C => 12,	    'd,'D => 13,	    'e,'E => 14,	    'f,'F => 15,	    ENDCASE => hexChar - '0;    hexValue ¬ hexValue * radix + digit;  GetHexChar[];    ENDLOOP };-- Clear the message area.ClearMessageArea: PROCEDURE = {  IF dirtyML > endOfMA THEN dirtyML ¬ endOfMA;  ClearDisplayRegion [bOfMA, dirtyML]; dirtyML ¬ bOfMA; msgX ¬ 0; msgY ¬ bOfMA };--  Clear specified portion of displayClearDisplayRegion: PROCEDURE [startOfRegion, endOfRegion: CARDINAL ] = {  IF startOfRegion > endOfRegion THEN RETURN;  FOR i: CARDINAL IN [startOfRegion .. endOfRegion] UNTIL i > bottomLine DO      PositionAndPrint [0, i]; ScreenTask [clearLineFromCursor]; ENDLOOP;  PositionAndPrint [0, startOfRegion] }; --  Clear screen and display bannerClearScreenAndPutTitle:  PROC = {    WriteTime: PROC [t: System.GreenwichMeanTime] RETURNS [ls: LONG STRING] =      BEGIN	temps: LONG STRING = [40];    	Time.Append[s: temps,     	 unpacked: Time.Unpack[time: t,	 	ltp: [useThese[[west, 8, 0, 121, 305]]]]];	 RETURN[temps];      END;  ScreenTask [clearScreen];  -- First line  PositionAndPrint [0, 0, Msg.cmMsgKeys [OfflineDiagTitle]];  PositionAndPrint [Dtty.charPos+1, 0, kernelVersion];  PositionAndPrint [Dtty.charPos+1, 0, Msg.cmMsgKeys[plainOf]];  PositionAndPrint [Dtty.charPos+1, 0, WriteTime[Runtime.GetBuildTime[]]];    -- Second line  PositionAndPrint [0, 1, Msg.cmMsgKeys[copyRight]];      -- Third line  PositionAndPrint [0, 2, Msg.cmMsgKeys[running]];    PositionAndPrint [Dtty.charPos+1, 2, subSystem];  -- Skip for Control Module  IF currentContext # NIL THEN {  -- NON-NIL => We are into the client tests     PositionAndPrint [Dtty.charPos + 2, 2, Msg.cmMsgKeys[testSelected]];     testNameX ¬ Dtty.charPos + 1;     PositionAndPrint [testNameX, testNameY, cTest] };			   -- Beginning of menu/option area		        bMenuA ¬ Dtty.currentLine + 2 };-- Display login menu.DisplayLoginMenu: PROC = {  ClearScreenAndPutTitle [];  PositionAndPrint [0,bMenuA,Msg.cmMsgKeys[userSelectionPrompt]];  PositionAndPrint [4,Dtty.currentLine + 2,Msg.cmMsgKeys[normalUser]];  PositionAndPrint [4,Dtty.currentLine + 2,Msg.cmMsgKeys[administrator]];  PositionAndPrint [4,Dtty.currentLine + 2,Msg.cmMsgKeys[techRep]];  InitializePositionalMarkers []; PrintPrompt [ptrXPos: pSPX];  state ¬ loginState; inputString.length ¬ 0 };-- Delete DiagHeapDeleteDiagHeap: PROC = {  ENABLE Space.Error => CONTINUE;  Heap.Delete [DiagHeap]; DiagHeap ¬ NIL; Heap.Delete [StringHeap];  StringHeap ¬ NIL; recreateDiagHeap ¬ TRUE;  IF spaceAllocated THEN {spaceAllocated ¬ FALSE;      spacePtr ¬ Space.Unmap [spacePtr] }};-- Create private heap and help for sysConfig and login screensInitializeDiagHeap: PROC = {  IF NOT recreateDiagHeap THEN RETURN;  DiagHeap ¬ Heap.Create [initial: 30];  StringHeap ¬ Heap.Create [initial: 1]; recreateDiagHeap ¬ FALSE;  -- Help for Login screen  loginHelp ¬ GetAHelpText[2]; loginHelp.helpTitle ¬ Msg.cmMsgKeys [loginHelpTitle];  loginHelp.textBody [0] ¬ Msg.cmMsgKeys [normalUserExplanation];  loginHelp.textBody [1] ¬ Msg.cmMsgKeys [otherUserClassExplanation];  -- Help for Subsystem Selection Menu  selectionHelp ¬ GetAHelpText[7];  selectionHelp.helpTitle ¬ Msg.cmMsgKeys [catSelectionHelpTitle];  selectionHelp.textBody [0] ¬ Msg.cmMsgKeys [catSelectionHelp0];  selectionHelp.textBody [1] ¬ Msg.cmMsgKeys [catSelectionHelp1];  selectionHelp.textBody [2] ¬ Msg.cmMsgKeys [catSelectionHelp2];  selectionHelp.textBody [3] ¬ Msg.cmMsgKeys [catSelectionHelp3];  selectionHelp.textBody [4] ¬ Msg.cmMsgKeys [catSelectionHelp4];  selectionHelp.textBody [5] ¬ Msg.cmMsgKeys [catSelectionHelp5];  selectionHelp.textBody [6] ¬ Msg.cmMsgKeys [catSelectionHelp6] };--***************--  Mainline code--***************Run: PUBLIC PROCEDURE = BEGIN     OPEN Menu: currentContext.contextMenu; -- Menu points to ContextMenu.--  Initialization      pTests: LONG POINTER TO Odi.AMenuOfSelections;  getTime: BOOLEAN ¬ FALSE;  clientVersion: LONG STRING;         hDiagTTY ¬ TTY.Create [instanceName]; -- Create diagnostic TTY  bottomLine ¬ Dtty.bottomLine; -- Initialize bottomLine  rightEdge ¬ Dtty.rightEdge; -- Initialize rightEdge  oldBackground ¬ IF background = white THEN black ELSE white;    -- Start message keys  Msg.InitializeCMDiagMsgKeys[]; -- Control module message keys  Process.Detach [FORK AbortSensor]; -- Spin off STOP/ABORT sensor  Process.Detach [FORK InputSensor]; -- Spin off input sensor  InitializeDiagHeap [];  -- Now determine if we are booting from the floppy or not. Load the other-- files from the other diskette if we are booting from the diskette  DO    -- See if we are dealing with floppy-based systems    IF Runtime.IsBound [LOOPHOLE[OdiExtra.ReadDiagnosticsPackage,       Runtime.ControlLink]] THEN {              ClearScreenAndPutTitle [];       InitializePositionalMarkers[];       OdiExtra.ReadDiagnosticsPackage[];       clientVersion ¬ OdiExtra.GetVersion[           ! Runtime.UnboundProcedure => { clientVersion ¬ ""; CONTINUE}];       IF String.Equal [kernelVersion, clientVersion] THEN EXIT;           -- Version mismatch       PutMessage[message: Msg.cmMsgKeys [veriosnMismatch], clearMessageAreaFirst: TRUE,    	          beep: TRUE];       PutMessage[message: Msg.cmMsgKeys [kernelVersion], startWithNewLine: FALSE];       PutMessage[message: kernelVersion, startWithNewLine: FALSE];       PutMessage[message: Msg.cmMsgKeys [clientVersion], startWithNewLine: FALSE];       PutMessage[message: clientVersion, startWithNewLine: FALSE];           IF GetYesNo[prompt: Msg.cmMsgKeys [mismatchOption]] THEN EXIT          ELSE OdiExtra.EraseLoadedConfig[] }  -- For floppy-based system	      ELSE EXIT;    ENDLOOP;  -- Now build internal client table for all the clients  [] ¬ OdiExtra.ValidateClients[checkOnly: FALSE];  -- checkOnly: FALSE builds client table  userProfile ¬ Heap.systemZone.NEW [UserProfile]; -- Create user profile -- Login Loop  BEGIN ENABLE AbortToLoginMenu => { InitializeDiagHeap []; RETRY };  TTY.ResetUserAbort [hDiagTTY];  -- Enable abort  subSystem ¬ NIL;  cTest ¬ NIL;  DisplayLoginMenu [];  IF Odci.clientCount = 0 THEN PutMessage[Msg.cmMsgKeys [noClients]];  DO     normalUser: CARDINAL = 1;    inputString.length ¬ 0;    userProfile.privilege ¬ NormalUser; -- Default    cSelection ¬ GetSelection [numberOfSelections: 3, pHelp: loginHelp];     IF cSelection = normalUser THEN EXIT  -- No login needed        ELSE { -- Need valid password       entryCompleted: BOOLEAN ¬ FALSE;       PositionAndPrint [0,auxPY,Msg.cmMsgKeys [passWordPrompt]];       auxPX ¬ Dtty.charPos; inputString.length ¬ 0;              -- Get password loop       UNTIL entryCompleted DO          passWordMode ¬ TRUE; homeLine ¬ auxPromptLine;          GetAnInputChar []; 	  IF inputChar=CR OR inputChar=space OR inputString.length=49	     THEN { entryCompleted ¬ TRUE; passWordMode ¬ FALSE }	     ELSE String.AppendChar [inputString,inputChar];	  ENDLOOP; -- Got password       -- Now see if password is correct. System Administrator ?       IF String.Equal [inputString, Msg.cmMsgKeys[administratorPWD]] THEN {	  userProfile.privilege ¬ Administrator; entryCompleted ¬ FALSE; EXIT };       -- TechRep/Field Service ?       IF String.Equal [inputString, Msg.cmMsgKeys[techRepPWD]] THEN {	  userProfile.privilege ¬ Services; EXIT};       -- Manufacturing ?         IF String.Equal [inputString, Msg.cmMsgKeys[manufacturePWD]] THEN {	  userProfile.privilege ¬ Manufacturing; EXIT};       -- Programmer ?         IF String.Equal [inputString, Msg.cmMsgKeys[diagProgrammerPWD]] THEN {	  userProfile.privilege ¬ Programmer; EXIT};       -- Bad Password       PutMessage [message: Msg.cmMsgKeys[inCorrectPassword]];       ClearDisplayRegion [auxPY, auxPY];       PositionAndPrint [0, spY, Msg.cmMsgKeys[enterSelectionPrompt]];       entryCompleted ¬ FALSE; LOOP};    ENDLOOP; -- End of login loop.        userType ¬ userProfile.privilege; passWordMode ¬ FALSE;-- Subsystem SelectionBEGIN ENABLE AbortToSubsystemSelectionMenu => { InitializeDiagHeap [];        IF Odci.clientCount = 1 THEN SIGNAL AbortToLoginMenu; RETRY };  s: LONG STRING ¬ [2];  -- Srcratch string  subSystem ¬ NIL;  cTest ¬ NIL;  state ¬ subsystemSelectionState;    clientRunning ¬ FALSE;-- Display subsystem selection menu    IF Odci.clientCount > 1 THEN {  -- Display client packages     menuCount ¬ Odci.clientCount;     ClearScreenAndPutTitle [];     PositionAndPrint [leftEdge, bMenuA, Msg.cmMsgKeys[availableSelections]];     FOR i: CARDINAL IN [1 .. Odci.clientCount] DO         s.length ¬ 0;        String.AppendNumber[s, i]; -- Print selection number        PositionAndPrint [4, Dtty.currentLine + 2, s];        PositionAndPrint [Dtty.charPos + 1, Dtty.currentLine, Msg.cmMsgKeys[dash]];        PositionAndPrint [Dtty.charPos + 1, Dtty.currentLine, Odci.clients[i].name];        ENDLOOP;          InitializePositionalMarkers [];      PrintPrompt[ptrXPos: pSPX]; -- Selection prompt     cSelection ¬ GetSelection [  -- Get selection        numberOfSelections: menuCount, pHelp: selectionHelp] }  ELSE cSelection ¬ 1;     -- Update profile.  userProfile.testSubsystemSelected ¬ Odci.clients[cSelection].name;     -- For banner  subSystem ¬ Odci.clients[cSelection].name; -- subsystem title  -- Start up client package   pTests ¬ Odci.clients[cSelection].startUpProc[];  -- Build a menu node for client  BuildContext [pTests];    -- State transition  state ¬ runClientTestsState; -- Running client testsDO ENABLE AbortCurrentTest => { -- STOP/Quit. Result not meaningful	  abortSensed ¬ FALSE; CONTINUE };   clientRunning ¬ FALSE;  [] ¬ Term.SetBackground [background]; passWordMode ¬ FALSE;  Term.SetBorder [oddPairs: 252B, evenPairs: 125B];  getString ¬ FALSE; gettingANumber ¬ FALSE; Dtty.SetTTYMode [normal];  IF reDisplayMenu THEN PutMenu[]  ELSE { -- Clean up     PositionAndPrint [0,auxPY]; ScreenTask [clearLineFromCursor];     IF fixedDataPrinted THEN {         fixedDataPrinted ¬ FALSE; dirtyDL ¬ bottomLine - 1;	DisplayFixedPositionData [displayData: NIL, clearDataArea: TRUE] }};  testN ¬ GetSelection [numberOfSelections: Menu.count,  		        pHelp: currentContext.menuHelp];    -- Save current test name for display  cTest ¬ Menu[testN].selection.itemName;  -- SubMenu ?  IF Menu[testN].selection.subMenu # NIL THEN {     -- Yes. Now build a new menu node     BuildContext [Menu[testN].selection.subMenu]; LOOP};  -- Update screen with selection  PositionAndPrint [testNameX, testNameY, cTest];  ScreenTask [clearLineFromCursor]; RepositionCursor[];  -- Execute test  IF userProfile.testSubsystemSelected = Msg.cmMsgKeys[runKbdDsplMouse]     THEN reDisplayMenu ¬ TRUE;  clientRunning ¬ TRUE;  Menu[testN].selectionResult ¬ Menu[testN].selection.test[]; cTest ¬ NIL;  -- Reconstruct menu if client hogged the screen  IF reDisplayMenu THEN PutMenu[];   PrintResult[];  -- Print result on menu   ENDLOOP;END; -- subsystem selection blockEND; -- login blockEND; -- RunEND. -- OfflineDiagnosticControlModuleALOGCreated: 25-Mar-85 by KL19-Jun-85 by KL - Added defaults to GetYesNo20-Jun-85 by KL - Replaced Analyst with Manufacturing as a valid LoginType.12-Sep-85 by KL - Bypass subsystem selection menu if only 1 client. Do not issue		  "Test data will be deleted, do you wish to continue." for		  System Configuration Utility.24-Jul-86 by RK - Added Tape Drive Client25-Aug-86 by SPL - changed version number to 1.3 9-Jan-87 13:34:31 by STC - changed version number to 1.3Ex13-Jan-87 15:15:09  by SPL, Set to 1.3c10-Feb-87 15:33:38  by SPL, Set version number to 1.512-Feb-87 20:26:34  by KXW, Modified for change of CMDiagMsgKeysDove, and separate OfflineDiagnosticControlModule into A and B.3-Mar-87 14:37:46  by KXW, Set version number to 1.5b5-Mar-87 16:34:25  by KXW, move copy right message to next line.16-Mar-87 18:15:05  by KXW, fix bug in PrintRecord.17-Mar-87  9:48:57  by KXW, Set version number to 1.5c. 6-Apr-87 14:20:43  by KXW, Set version number to 1.5d.16-Apr-87 14:02:53  by STC, Set version number to 1.5e.15-May-87 10:27:07  by STC, Set version number to 1.5f.23-Jul-87 16:29:17  by STC, Set version number to 1.5s.27-Aug-87 13:35:46  by STC, Set version number to 1.5g.17-Sep-87 11:08:15  by STC, Set version number to 1.5. 7-Oct-87 13:44:36  by STC, Set version number to 2.0e.17-Nov-87  8:59:34  by STC, Set version number to 2.0f. 4-Dec-87  8:53:52  by STC, Set version number to 2.0.17-Dec-87 11:24:43  by STC, Set version number to 2.0g.21-Jan-88  9:26:24  by STC, Set version number to 2.0, the official final 2.0.. 2-Oct-88 14:16:45  by STC, Set version number to 3.0, Labelless.16-Oct-88 19:24:13  by STC, show build time after version number
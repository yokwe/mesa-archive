-- File SysConfigUserShowAllImpl.mesa-- Last edited:-- TXM	 7-Oct-89 10:11:03, add 2MB memory-- TXM,  6-Oct-89 19:12:23, add swift94355100 and maxtorXT2190-- TXM, 14-Dec-88 14:30:58, add mitsubishiMR335 and mitsubishiMR548-- STC, 14-Oct-88  8:48:20, roll over fix bug in NormalUser's changing DiskTypes -- STC,  2-Oct-88 22:10:23, add 4MB, Labelless-- STC, 29-Jan-88 17:00:14, add fad5000, fix Show DiskTypes from SDD page-- STC, 17-Oct-87 19:19:25, convert to 14.0-- edited: RDM	 6-Feb-87 12:49:20	Fix daisy 4meg memory configuration.-- RDM	 3-Feb-87 12:41:35	Add daisy mem expansion.-- RDM	27-Jan-87 16:26:29	Add Horizon Disks.-- RDM  8-Jan-87 16:09:01	Added Mitsubishi, Fujitsu, & NEC disks. Check memory configuration.-- RDM	20-Nov-86 17:16:23  Explicitly set the result flag. Add printingScanningOption.-- RRP  14-May-86 13:42:00  added support for Turbo (extended) disks-- RRP   3-Mar-86 11:37:08  changed message displayed for seagateST225 from Mb202Displ to Mb204Displ-- RRP 30-Jan-86 13:56:15 changes for 12.2-- Created	5-Aug-85 		by: MR-- 	 2-Oct-85 13:45:25	by: AMR---- Copyright (C) 1985, 1986, 1987, 1988, 1989 Xerox Corporation. All rights reserved.--DIRECTORY  EEpromDefs,  OfflineDiagInterface  USING [ OptionsRecord, AnOptionLine, GetAnOption,  				GetAnOptionsRecord, GetAnOptionLine,				OfflineDiagnosticProc, PutMessage,				GetAFixedPositionDisplayRecord, GetARow,			        FixedPositionDisplayRecord, ARow,				DisplayFixedPositionData ],  ProcessorFaceExtras	USING [Version, VersionResult],  SysConfigControlDefs  USING [ msgKey, msgKey1, msgKey2, statusPtr, showConfig],  SysConfigSubDefs,  SysConfigChannelDefs  USING [ eePromImage, eePromImageCopy];      SysConfigUserShowAllImpl: PROGRAM	IMPORTS OfflineDiagInterface, ProcessorFaceExtras, SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs, EEpromDefs;  -- ODI stands for OfflineDiagInterface.ConfigureUserShowAllEEprom: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    optionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [1];  optionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];       selected: CARDINAL;  leftEdge: CARDINAL = 3;   -- For formatting display.    result ¬ none;  optionTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row  optionTable.optionMenuTiTle ¬ NIL;    optionRow0.optionsOnALine[0].position ¬ leftEdge;  optionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  optionRow0.optionsOnALine[0].option ¬ msgKey[exitSelection];  -- %Change     showConfig ¬ TRUE;    [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: optionTable,      optionPrompt: msgKey[blanks],      justDisplayTable:TRUE]; -- Example default      SELECT SysConfigControlDefs.statusPtr­ FROM    eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE,TRUE,,,TRUE];    badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE,,,TRUE];    checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE,TRUE,,, TRUE];    badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE,TRUE,,, TRUE];    unKnown => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE,,,TRUE];    ENDCASE;    IF eePromImage.VersionEProm > EEpromDefs.VersionNumberROM OR    eePromImage.VersionRAM > EEpromDefs.VersionNumberRAM OR    eePromImage.VersionBadPages > EEpromDefs.VersionNumberBadPages    THEN { Odi.PutMessage [msgKey1[badVersionNumber], TRUE, TRUE, , , FALSE]; };  [] ¬ UserShowAllEEprom[];  -- Display the information				  selected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL, optionPrompt:msgKey[respondToPrompt], defaultOption: 1 ];    		  END;  -- ConfigureUserShowAllEEprom   UserShowAllEEprom: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN  -- This fixed-position display record holds the screen information as being  -- displayed at the top of the data area. The rest of the data area still can  -- be used to print normal data (PutData still retains its full power)  version: ProcessorFaceExtras.VersionResult _ ProcessorFaceExtras.Version[];  leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 5;  -- Biggest number is 10 digits wide.   xPosition: CARDINAL;  -- Number for tracking position on current line  noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  tempValue:LONG CARDINAL;      information: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [10];  --  variable itemed rows of data       --PUT IN ALL THE CURRENT VALUES OUT OF THE TEMPORARY EEPROM IMAGE IN THE IOREGION        infoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow4: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow5: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow6: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow7: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow8: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  infoRow9: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row      -- Now fill in the static fields of the display record        -- Fill in the screen Information record fields    IF showConfig THEN         information.displayTitle ¬ msgKey1[showConfigHeader]  ELSE   information.displayTitle ¬ msgKey1[currentSetting];    information.rows[0] ¬ infoRow0;  -- First row  information.rows[1] ¬ infoRow1;  -- Second row  information.rows[2] ¬ infoRow2;  -- third row  information.rows[3] ¬ infoRow3;  -- Fourth row, floppy  information.rows[4] ¬ infoRow4;  -- Fifth row,  catridge tape  information.rows[5] ¬ infoRow5;  -- Sixth row  information.rows[6] ¬ infoRow6;--we assume, in the Normal User Mode, that we are dealing with a 6085, and so we only have the possibility of ONE universal option board installed  information.rows[7] ¬ infoRow7;  information.rows[8] ¬ infoRow8;  information.rows[9] ¬ infoRow9;  -- Now fill in the static fields of the display record  --  --  -- Fill in first row first item static data    xPosition ¬ leftEdge + msgKey[badPageVersionNumber].length + 5;        infoRow0.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow0.rowItems[0].name ¬ msgKey1[keyBoard];	--Keyboard  infoRow0.rowItems[0].valuePosition ¬ noNumericData;    infoRow1.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow1.rowItems[0].name ¬ msgKey1[disk];	--rigidDiskType  infoRow1.rowItems[0].valuePosition ¬ noNumericData;    infoRow2.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow2.rowItems[0].name ¬ msgKey1[memory];  infoRow2.rowItems[0].valuePosition ¬ noNumericData;    infoRow3.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow3.rowItems[0].name ¬ msgKey1[floppyDrive];  --FloppyDiskType  infoRow3.rowItems[0].valuePosition ¬ noNumericData;    infoRow4.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow4.rowItems[0].name ¬ msgKey1[cartridgetape];  --CartridgeTape  infoRow4.rowItems[0].valuePosition ¬ noNumericData;    infoRow5.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow5.rowItems[0].name ¬ msgKey1[etherOption];  --Ethernet  infoRow5.rowItems[0].stringValue ¬ NIL;  -- No string value    infoRow5.rowItems[0].valuePosition ¬ noNumericData;    infoRow6.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow6.rowItems[0].name ¬ msgKey1[pcOption];  --PCOptionBoard  infoRow6.rowItems[0].stringValue ¬ NIL;  -- No string value    infoRow6.rowItems[0].valuePosition ¬ noNumericData;    infoRow7.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow7.rowItems[0].name ¬ msgKey1[universalOption];  infoRow7.rowItems[0].stringValue ¬ NIL;  -- No string value  infoRow7.rowItems[0].valuePosition ¬ noNumericData;  infoRow8.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow8.rowItems[0].name ¬ msgKey1[runDiagAtTimeout];  infoRow8.rowItems[0].stringValue ¬ NIL;  -- No string value  infoRow8.rowItems[0].valuePosition ¬ noNumericData;  infoRow9.rowItems[0].namePosition ¬ leftEdge;  -- Name position  infoRow9.rowItems[0].name ¬ msgKey[VMMSizeInPages];  infoRow9.rowItems[0].stringValue ¬ NIL;  -- No string value  infoRow9.rowItems[0].valuePosition ¬ noNumericData;  IF showConfig THEN {  	infoRow0.rowItems[1].namePosition ¬ leftEdge + 45;  	infoRow0.rowItems[1].name ¬ msgKey[blanks];	--Keyboard	infoRow0.rowItems[1].stringValue ¬ NIL;	infoRow0.rowItems[1].valuePosition ¬ noNumericData;    	infoRow1.rowItems[1].namePosition ¬ leftEdge + 45;   	infoRow1.rowItems[1].name ¬ msgKey[blanks];	--rigidDiskType	infoRow1.rowItems[1].stringValue ¬ NIL;	infoRow1.rowItems[1].valuePosition ¬ noNumericData;	    	infoRow2.rowItems[1].namePosition ¬ leftEdge + 45;  	infoRow2.rowItems[1].name ¬ msgKey[blanks];	infoRow2.rowItems[1].stringValue ¬ NIL;  	infoRow2.rowItems[1].valuePosition ¬ noNumericData;	  	infoRow3.rowItems[1].namePosition ¬ leftEdge + 45; 	infoRow3.rowItems[1].name ¬ msgKey[blanks];  --FloppyDiskType	infoRow3.rowItems[1].stringValue ¬ NIL;	infoRow3.rowItems[1].valuePosition ¬ noNumericData;    	infoRow4.rowItems[1].namePosition ¬ leftEdge + 45; 	infoRow4.rowItems[1].name ¬ msgKey[blanks];  --CartridgeTape	infoRow4.rowItems[1].stringValue ¬ NIL;	infoRow4.rowItems[1].valuePosition ¬ noNumericData;    	infoRow5.rowItems[1].namePosition ¬ leftEdge + 45;	infoRow5.rowItems[1].name ¬ msgKey[blanks];  --Ethernet 	infoRow5.rowItems[1].stringValue ¬ NIL;  -- No string value 	infoRow5.rowItems[1].valuePosition ¬ noNumericData;     	infoRow6.rowItems[1].namePosition ¬ leftEdge + 45; 	infoRow6.rowItems[1].name ¬ msgKey[blanks];  --PCOptionBoard 	infoRow6.rowItems[1].stringValue ¬ NIL;  -- No string value 	infoRow6.rowItems[1].valuePosition ¬ noNumericData;   	infoRow7.rowItems[1].namePosition ¬ leftEdge + 45; 	infoRow7.rowItems[1].name ¬ msgKey[blanks];  --UniversalOptionBoard 	infoRow7.rowItems[1].stringValue ¬ NIL;  -- No string value 	infoRow7.rowItems[1].valuePosition ¬ noNumericData;      	infoRow8.rowItems[1].namePosition ¬ leftEdge + 45;  	infoRow8.rowItems[1].name ¬ msgKey[blanks];  	infoRow8.rowItems[1].stringValue ¬ NIL;  -- No string value	infoRow8.rowItems[1].valuePosition ¬ noNumericData;	infoRow9.rowItems[1].namePosition ¬ leftEdge + 45;  	infoRow9.rowItems[1].name ¬ msgKey[blanks];  	infoRow9.rowItems[1].stringValue ¬ NIL;  -- No string value	infoRow9.rowItems[1].valuePosition ¬ noNumericData;}    ELSE {  	xPosition ¬ leftEdge + msgKey1[keyBoard].length + 27;  	infoRow0.rowItems[1].namePosition ¬ xPosition;  -- Name position  	infoRow0.rowItems[1].name ¬ NIL;	--Keyboard  	infoRow0.rowItems[1].valuePosition ¬ noNumericData;    	infoRow1.rowItems[1].namePosition ¬ xPosition;  -- Name position  	infoRow1.rowItems[1].name ¬ NIL;	--rigidDiskType  	infoRow1.rowItems[1].valuePosition ¬ noNumericData;    	infoRow2.rowItems[1].namePosition ¬ xPosition;  -- Name position  	infoRow2.rowItems[1].name ¬ NIL;  	infoRow2.rowItems[1].valuePosition ¬ noNumericData;   	infoRow3.rowItems[1].namePosition ¬ xPosition;  -- Name position 	infoRow3.rowItems[1].name ¬ NIL;  --FloppyDiskType 	infoRow3.rowItems[1].valuePosition ¬ noNumericData;   	infoRow4.rowItems[1].namePosition ¬ xPosition;  -- Name position 	infoRow4.rowItems[1].name ¬ NIL;  --CartridgeTape 	infoRow4.rowItems[1].valuePosition ¬ noNumericData;   	infoRow5.rowItems[1].namePosition ¬ xPosition;  -- Name position	infoRow5.rowItems[1].name ¬ NIL;  --Ethernet 	infoRow5.rowItems[1].stringValue ¬ NIL;  -- No string value   	infoRow5.rowItems[1].valuePosition ¬ noNumericData;   	infoRow6.rowItems[1].namePosition ¬ xPosition;  -- Name position 	infoRow6.rowItems[1].name ¬ NIL;  --PCOptionBoard 	infoRow6.rowItems[1].stringValue ¬ NIL;  -- No string value   	infoRow6.rowItems[1].valuePosition ¬ noNumericData;    	infoRow7.rowItems[1].namePosition ¬ xPosition;  -- Name position  	infoRow7.rowItems[1].name ¬ NIL;  --UniversalOptionBoard  	infoRow7.rowItems[1].stringValue ¬ NIL;  -- No string value 	infoRow7.rowItems[1].valuePosition ¬ noNumericData;   	infoRow8.rowItems[1].namePosition ¬ xPosition;  -- Name position 	infoRow8.rowItems[1].name ¬ NIL; 	infoRow8.rowItems[1].stringValue ¬ NIL;  -- No string value   	infoRow8.rowItems[1].valuePosition ¬ noNumericData; 	infoRow9.rowItems[1].namePosition ¬ xPosition;  -- Name position 	infoRow9.rowItems[1].name ¬ NIL; 	infoRow9.rowItems[1].stringValue ¬ NIL;  -- No string value   	infoRow9.rowItems[1].valuePosition ¬ noNumericData;};  	    	infoRow0.rowItems[0].stringValue ¬ 	  SELECT eePromImageCopy.Keyboard FROM	    none => msgKey[none],	    english => msgKey1[usKeyboard],	    european => msgKey[europeanKeyboard],	    japanese => msgKey[japaneseKeyboard],	    learSiegler => msgKey[learSieglerKeyboard]	  ENDCASE => msgKey[unknown]; 								infoRow1.rowItems[0].stringValue  ¬	  SELECT eePromImageCopy.RigidDiskType FROM -- STC, 14-Oct-88  8:47:51	    none => msgKey[notPresent],	    seagateST212 => msgKey1[Mb101Displ],	    seagateST213 => msgKey1[Mb102Displ],	    tandonTM703 => msgKey1[Mb201Displ],	    tandonTM702AT => msgKey1[Mb202Displ],	    seagateST4026 => msgKey1[Mb202Displ],	    quantumQ530 => msgKey1[Mb203Displ],  	    seagateST225 => msgKey1[Mb204Displ],	    mitsubishiMR322US => msgKey1[Mb205Displ],	    necD3126US => msgKey1[Mb206Displ],	    quantumQ540 => msgKey1[Mb401Displ],	    micropolis1303 => msgKey1[Mb402Displ],  	    seagateST4051 => msgKey1[Mb403Displ],  	    seagateST251 => msgKey1[Mb404Displ],	    mitsubishiMR535US => msgKey1[Mb405Displ],	    necD5146HUS => msgKey1[Mb406Displ],	    micropolis1325 => msgKey1[Mb801Displ],  	    seagateST4096 => msgKey1[Mb802Displ],	    fujitsuM2243AS => msgKey1[Mb803Displ],	    toshibaMK56FB => msgKey1[Mb804Displ],	    toshibaMK134FA => msgKey2[toshibaMK134FA],	    extendedTandonTM703 => msgKey1[Mb20ADispl],	    extendedTandonTM702 => msgKey1[Mb20BDispl],	    extendedSeagateST4026 => msgKey1[Mb20BDispl],	    extendedQuantumQ530 => msgKey1[Mb20CDispl],	    extendedSeagateST225 => msgKey1[Mb20DDispl],	    extendedSeagateST4051 => msgKey1[Mb40CDispl],	    extendedSeagateST251 => msgKey1[Mb40DDispl],	    mitsubishiMR533 => msgKey[mitsubishiMR533],	    mitsubishiMR535 => msgKey[mitsubishiMR535],	    fujitsuM2225D => msgKey[fujitsuM2225D],	    fujitsuM2227D => msgKey[fujitsuM2227D],	    fujitsuM2243T => msgKey[fujitsuM2243T],	    necD5146H => msgKey[necD5146H],	    mitsubishiMR335 => msgKey2[mitsubishiMR335],	    mitsubishiMR548 => msgKey2[mitsubishiMR548],	    swift94355100 => msgKey2[Mb805Displ],	    maxtorXT2190 => msgKey2[Mb1501Displ],	  ENDCASE => msgKey[unknown];      IF version.machineType = daisy THEN {        infoRow2.rowItems[0].stringValue ¬	  SELECT eePromImageCopy.MainMemoryExpansion FROM	    mega1 => msgKey1[defaultMem],	    k1512 => msgKey1[mem1],	    mega2 => msgKey1[mem2],	    k2512 => msgKey1[mem3],	    mega3 => IF eePromImage.MainMemory8 = present AND		        eePromImage.MainMemory9 = present AND		        eePromImage.MainMemory10 = present AND			eePromImage.MainMemory11 = present AND			eePromImage.MainMemory12 = present AND			eePromImage.MainMemory13 = present AND			eePromImage.MainMemory14 = present AND			eePromImage.MainMemory15 = present THEN msgKey1[mem5]		      ELSE msgKey1[mem4]	  ENDCASE  => msgKey[unknown]}      ELSE {	IF eePromImage.MainMemory2 = notPresent AND	    eePromImage.MainMemory3 = notPresent AND	    eePromImage.MainMemory4 = notPresent AND	    eePromImage.MainMemory5 = notPresent AND	    eePromImage.MainMemory6 = notPresent AND	    eePromImage.MainMemory7 = notPresent	THEN {						-- Daybreak and Dahlia	  infoRow2.rowItems[0].stringValue ¬	    SELECT eePromImageCopy.MainMemoryExpansion FROM	      k512 => msgKey1[defaultMem],	      mega1 => msgKey1[mem1],	      k1512 => msgKey1[mem2],	      mega2 => msgKey1[mem3],	      k2512 => msgKey1[mem4],	      mega3 => msgKey1[mem5],	      ENDCASE  => msgKey[unknown]}	ELSE {						-- Duke and Diana	  infoRow2.rowItems[0].stringValue ¬	    SELECT eePromImageCopy.MainMemoryExpansion FROM	      k512 => msgKey1[defaultMem],	      mega1 => msgKey2[mem7],	      k1512 => msgKey1[mem2],	      mega2 => msgKey1[mem3],	      k2512 => msgKey1[mem4],	      mega3 => msgKey2[mem6],	      ENDCASE  => msgKey[unknown]}};	infoRow3.rowItems[0].stringValue  ¬	  SELECT eePromImageCopy.FloppyDiskTypeDrive0 FROM	    none => msgKey[notPresent],	    kb360 => msgKey[kb360],	    kb1200 => msgKey[kb1200],	  ENDCASE => msgKey[unknown];	     	infoRow4.rowItems[0].stringValue  ¬	  SELECT eePromImageCopy.FloppyDiskTypeDrive1 FROM	    fad5000 => msgKey1[yes]	  ENDCASE => msgKey1[no]; 	infoRow5.rowItems[0].stringValue  ¬	  SELECT eePromImageCopy.EthrenetBooting FROM	    notAllowed => msgKey1[no]	  ENDCASE => msgKey1[yes]; 	tempValue ¬ LONG[LOOPHOLE[eePromImageCopy.PCOptionBoard]];	infoRow6.rowItems[0].stringValue ¬ IF tempValue = 0  				THEN msgKey1[no]				ELSE msgKey1[yes];       	infoRow7.rowItems[0].stringValue ¬	   SELECT eePromImageCopy.OptionBoardOne.optionType FROM	     none =>			msgKey[notPresent],	     laserPrintingOption =>	msgKey[laserPrintingOption],	     printingScanningOption =>	msgKey[printingScanningOption],	     ENDCASE =>			msgKey[unknown];        infoRow8.rowItems[0].stringValue ¬ 	  SELECT eePromImageCopy.DefaultBootDiag FROM    	     	runDiags => msgKey1[yes]	  ENDCASE => msgKey1[no];        infoRow9.rowItems[0].stringValue ¬ 	  SELECT eePromImageCopy.VMMSizeInPages FROM	    vm8mega => msgKey1[twentyTwoBitsVM],	    vm16mega => msgKey1[twentyThreeBitsVM],	    vm32mega => msgKey1[twentyFourBitsVM],	ENDCASE => msgKey[unknown];  			IF NOT showConfig THEN {	infoRow0.rowItems[1].stringValue ¬ 	  SELECT eePromImage.Keyboard FROM    	none => msgKey[none],	    english => msgKey1[usKeyboard],	    european => msgKey[europeanKeyboard],	    japanese => msgKey[japaneseKeyboard],	    learSiegler => msgKey[learSieglerKeyboard]	    ENDCASE => msgKey[unknown]; 	    	infoRow1.rowItems[1].stringValue  ¬ SELECT eePromImage.RigidDiskType FROM    	    none => msgKey[notPresent],	    seagateST212 => msgKey1[Mb101Displ],	    seagateST213 => msgKey1[Mb102Displ],	    tandonTM703 => msgKey1[Mb201Displ],	    tandonTM702AT => msgKey1[Mb202Displ],	    seagateST4026 => msgKey1[Mb202Displ],	    quantumQ530 => msgKey1[Mb203Displ],  	    seagateST225 => msgKey1[Mb204Displ],	    mitsubishiMR322US => msgKey1[Mb205Displ],	    necD3126US => msgKey1[Mb206Displ],	    quantumQ540 => msgKey1[Mb401Displ],	    micropolis1303 => msgKey1[Mb402Displ],  	    seagateST4051 => msgKey1[Mb403Displ],  	    seagateST251 => msgKey1[Mb404Displ],	    mitsubishiMR535US => msgKey1[Mb405Displ],	    necD5146HUS => msgKey1[Mb406Displ],	    micropolis1325 => msgKey1[Mb801Displ],  	    seagateST4096 => msgKey1[Mb802Displ],	    fujitsuM2243AS => msgKey1[Mb803Displ],	    toshibaMK56FB => msgKey1[Mb804Displ],	    toshibaMK134FA => msgKey2[toshibaMK134FA],	    extendedTandonTM703 => msgKey1[Mb20ADispl],	    extendedTandonTM702 => msgKey1[Mb20BDispl],	    extendedSeagateST4026 => msgKey1[Mb20BDispl],	    extendedQuantumQ530 => msgKey1[Mb20CDispl],	    extendedSeagateST225 => msgKey1[Mb20DDispl],	    extendedSeagateST4051 => msgKey1[Mb40CDispl],	    extendedSeagateST251 => msgKey1[Mb40DDispl],	    mitsubishiMR533 => msgKey[mitsubishiMR533],	    mitsubishiMR535 => msgKey[mitsubishiMR535],	    fujitsuM2225D => msgKey[fujitsuM2225D],	    fujitsuM2227D => msgKey[fujitsuM2227D],	    fujitsuM2243T => msgKey[fujitsuM2243T],	    necD5146H => msgKey[necD5146H],	    mitsubishiMR335 => msgKey2[mitsubishiMR335],	    mitsubishiMR548 => msgKey2[mitsubishiMR548],	    swift94355100 => msgKey2[Mb805Displ],	    maxtorXT2190 => msgKey2[Mb1501Displ],	    ENDCASE => msgKey[unknown];      IF version.machineType = daisy THEN {        infoRow2.rowItems[1].stringValue ¬ SELECT eePromImage.MainMemoryExpansion FROM		mega1 => msgKey1[defaultMem],		k1512 => msgKey1[mem1],		mega2 => msgKey1[mem2],		k2512 => msgKey1[mem3],		mega3 => IF eePromImage.MainMemory8 = present AND			    eePromImage.MainMemory9 = present AND			    eePromImage.MainMemory10 = present AND			    eePromImage.MainMemory11 = present AND			    eePromImage.MainMemory12 = present AND			    eePromImage.MainMemory13 = present AND			    eePromImage.MainMemory14 = present AND			    eePromImage.MainMemory15 = present THEN msgKey1[mem5]			  ELSE msgKey1[mem4]		ENDCASE  => msgKey[unknown]}      ELSE {	IF eePromImage.MainMemory2 = notPresent AND	    eePromImage.MainMemory3 = notPresent AND	    eePromImage.MainMemory4 = notPresent AND	    eePromImage.MainMemory5 = notPresent AND	    eePromImage.MainMemory6 = notPresent AND	    eePromImage.MainMemory7 = notPresent	THEN {						-- Daybreak and Dahlia	  infoRow2.rowItems[1].stringValue ¬	    SELECT eePromImage.MainMemoryExpansion FROM	      k512 => msgKey1[defaultMem],	      mega1 => msgKey1[mem1],	      k1512 => msgKey1[mem2],	      mega2 => msgKey1[mem3],	      k2512 => msgKey1[mem4],	      mega3 => msgKey1[mem5],	      ENDCASE  => msgKey[unknown]}	ELSE {						-- Duke and Diana	  infoRow2.rowItems[1].stringValue ¬	    SELECT eePromImage.MainMemoryExpansion FROM	      k512 => msgKey1[defaultMem],	      mega1 => msgKey2[mem7],	      k1512 => msgKey1[mem2],	      mega2 => msgKey1[mem3],	      k2512 => msgKey1[mem4],	      mega3 => msgKey2[mem6],	      ENDCASE  => msgKey[unknown]}};						infoRow3.rowItems[1].stringValue  ¬ SELECT eePromImage.FloppyDiskTypeDrive0 FROM					none => msgKey[notPresent],					kb360 => msgKey[kb360],					kb1200 => msgKey[kb1200],					ENDCASE => msgKey[unknown];	infoRow4.rowItems[1].stringValue  ¬ SELECT eePromImage.FloppyDiskTypeDrive1 FROM					fad5000 => msgKey1[yes]					ENDCASE => msgKey1[no];				infoRow5.rowItems[1].stringValue  ¬ SELECT eePromImage.EthrenetBooting FROM					notAllowed => msgKey1[no]					ENDCASE => msgKey1[yes];				tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionBoard]];						infoRow6.rowItems[1].stringValue ¬ IF tempValue = 0  				THEN msgKey1[no]				ELSE msgKey1[yes];       	infoRow7.rowItems[1].stringValue ¬	   SELECT eePromImage.OptionBoardOne.optionType FROM	     none =>			msgKey[notPresent],	     laserPrintingOption =>	msgKey[laserPrintingOption],	     printingScanningOption =>	msgKey[printingScanningOption],	     ENDCASE =>			msgKey[unknown];            infoRow8.rowItems[1].stringValue ¬ 	  SELECT eePromImage.DefaultBootDiag FROM    	     	runDiags => msgKey1[yes]	  ENDCASE => msgKey1[no];         infoRow9.rowItems[1].stringValue ¬ 	  SELECT eePromImage.VMMSizeInPages FROM	    vm8mega => msgKey1[twentyTwoBitsVM],	    vm16mega => msgKey1[twentyThreeBitsVM],	    vm32mega => msgKey1[twentyFourBitsVM],	ENDCASE => msgKey[unknown];  			       };      Odi.DisplayFixedPositionData [  -- Display the drive information       				displayData: information, upDateOnly: FALSE];	        END; END.logcreated on 5-Aug-85 	by: MR
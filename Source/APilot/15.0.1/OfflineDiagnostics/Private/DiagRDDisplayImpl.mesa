-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. -- File: DiagRDDisplayImpl.mesa   - Last edited:-- STC, 29-Sep-88 11:01:17, Labelless conversion--DIRECTORY  CompatibilityDiskFace USING [Operation],  DiskIOFaceDuke USING [DeviceStatus, IOCB],  DiagDiskCmdDrive USING [    SectorCount, MinCylinder, MaxCylinder, MinHead, MaxHead, MinSector, MaxSector,    MinUnit, MaxUnit],  DiagDiskMkIOCmd USING [mkIOCmd],  DiagDiskMkMisc USING [mkMisc],  DiagRDCmds USING [OpPtr],  DiagRDErrorCheck USING [BadPageCount, BadPageSpace, BadPageSpaceCount,  			  ErrorCode, Recovery],  DiagRDPVStuff USING [BadPageCount, BadPageSpace, GetBadPages, PageToAddr],  DiagRDSurfaceVerify USING[],  DiagRDTestRec USING [Subtest, Subtests],  DiagRDTests USING [ReadDataBuffPtr, ReadLabelBuffPtr],--  Heap USING [Error],  PhysicalVolume USING [PageNumber],--  PilotDiskFace USING [Operation],  OfflineDiagInterface USING [    ARow, bOfDA, DisplayFixedPositionData, DiagHeap, FixedPositionDisplayRecord,    GetAFixedPositionDisplayRecord, GetARow, GetYesNo, HitAnyKeyToContinue,    PutData, PutMessage, PutTestParameters, ResultType, userType],  OfflineDiagTTYDove USING [bottomLine],  String USING [    AppendChar, AppendNumber, AppendLongNumber, AppendString, Copy, MakeString],  DiagRDDisplay USING [];DiagRDDisplayImpl: PROGRAM  IMPORTS    DiagDiskCmdDrive, DiagRDCmds, DiagDiskMkIOCmd, DiagDiskMkMisc, DiagRDErrorCheck, DiagRDPVStuff,    DiagRDTestRec, DiagRDTests, -- Heap, -- String, OfflineDiagInterface, OfflineDiagTTYDove  EXPORTS DiagRDDisplay, DiagRDSurfaceVerify =  BEGIN OPEN DiagDiskMkIOCmd, DiagDiskMkMisc, Odi: OfflineDiagInterface;  logDisplaySelection: TYPE = {errorLog, traceTable, stepCommandLog};  page: LONG CARDINAL;  badPageRecord: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬ NIL;  displayedBadPages: CARDINAL ¬ 0;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display a Bad Page  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BadPage: PUBLIC PROCEDURE [    pageNumber: PhysicalVolume.PageNumber, addTimesTriedFailed: BOOLEAN ¬ FALSE,    timesTried: CARDINAL ¬ 1, timesFailed: CARDINAL ¬ 1,    addErrorCount: BOOLEAN ¬ FALSE, errorCount: CARDINAL ¬ 1,    addRecovery: BOOLEAN ¬ FALSE,    recovery: DiagRDErrorCheck.Recovery ¬ notCorrectable] =    BEGIN    str1: STRING ¬ [110];    str2: STRING ¬ [110];    new: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    updateOnly: BOOLEAN ¬ TRUE;    position: CARDINAL ¬ 0;    numberOfLines: CARDINAL = OfflineDiagTTYDove.bottomLine - Odi.bOfDA - 1;    IF badPageRecord = NIL THEN {      updateOnly ¬ FALSE;      badPageRecord ¬ Odi.GetAFixedPositionDisplayRecord[1];      displayedBadPages ¬ 1}    ELSE {      IF displayedBadPages = numberOfLines THEN {  -- scroll up.        updateOnly ¬ TRUE;        Odi.DiagHeap.FREE[@badPageRecord.rows[0]];        FOR i: CARDINAL IN [1..displayedBadPages) DO          badPageRecord.rows[i - 1] ¬ badPageRecord.rows[i]; ENDLOOP;        }      ELSE {        temp: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬          Odi.GetAFixedPositionDisplayRecord[badPageRecord.rowCount];        updateOnly ¬ FALSE;        displayedBadPages ¬ badPageRecord.rowCount + 1;        FOR i: CARDINAL IN [0..badPageRecord.rowCount) DO          temp.rows[i] ¬ badPageRecord.rows[i]; ENDLOOP;        Odi.DiagHeap.FREE[@badPageRecord];        badPageRecord ¬ Odi.GetAFixedPositionDisplayRecord[displayedBadPages];        FOR i: CARDINAL IN [0..displayedBadPages - 1) DO          badPageRecord.rows[i] ¬ temp.rows[i]; ENDLOOP;        };      };    badPageRecord.displayTitle ¬ NIL; --"Encountered Bad Pages";    new.rowItems[0].namePosition ¬ 0;    new.rowItems[0].name ¬ FormattedBadPageString[      pageNumber: pageNumber, addTimesTriedFailed: addTimesTriedFailed,      timesTried: timesTried, timesFailed: timesFailed,      addErrorCount: addErrorCount, errorCount: errorCount,      addRecovery: addRecovery, recovery: recovery];    new.rowItems[0].stringValue ¬ NIL;    new.rowItems[0].valuePosition ¬ 0;    badPageRecord.rows[displayedBadPages - 1] ¬ new;    Odi.DisplayFixedPositionData[      displayData: badPageRecord, upDateOnly: updateOnly,      clearDataArea: badPageRecord.rowCount = 1];    END;  --BadPage  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the Bad Pages  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BadPages: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =    BEGIN    count: CARDINAL;    count1: CARDINAL;    empty: BOOLEAN;    string: STRING ¬ [10];    new: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    numberOfLines: CARDINAL = OfflineDiagTTYDove.bottomLine - Odi.bOfDA - 3;    -- get all bad pages    empty ¬ DiagRDPVStuff.GetBadPages[];    -- check if empty    IF empty THEN {      Odi.PutMessage[        message: mkMisc[badPageTableEmpty], beep: TRUE,        clearMessageAreaFirst: TRUE];      RETURN};    count ¬ 0;    IF badPageRecord # NIL THEN {      Odi.DiagHeap.FREE[@badPageRecord]; badPageRecord ¬ NIL};-- %KL    count ¬ DiagRDPVStuff.BadPageCount / numberOfLines + 1;    count ¬ DiagRDPVStuff.BadPageCount / numberOfLines;    -- %KL    IF DiagRDPVStuff.BadPageCount  MOD numberOfLines # 0 THEN count ¬ count + 1;    FOR i: CARDINAL IN [1..count] DO      count1 ¬ IF i = count THEN DiagRDPVStuff.BadPageCount MOD numberOfLines ELSE numberOfLines;      IF count1 = 0 THEN count1 ¬ numberOfLines;      badPageRecord ¬ Odi.GetAFixedPositionDisplayRecord[count1];      badPageRecord.displayTitle ¬ mkMisc[badPageDisplay];      -- Loop to get the display items      FOR j: CARDINAL IN [0..count1) DO        new ¬ Odi.GetARow[1];        page ¬ DiagRDPVStuff.BadPageSpace[(i - 1) * numberOfLines + j];        new.rowItems[0].namePosition ¬ 0;        new.rowItems[0].name ¬ FormattedBadPageString[pageNumber: page];        new.rowItems[0].stringValue ¬ NIL;        new.rowItems[0].valuePosition ¬ 0;        badPageRecord.rows[j] ¬ new;        ENDLOOP;      Odi.DisplayFixedPositionData[        displayData: badPageRecord, clearDataArea: (i = 1) OR (count1 # numberOfLines),        upDateOnly: i # 1];      Odi.DiagHeap.FREE[@badPageRecord];      badPageRecord ¬ NIL;      IF i # count THEN IF NOT Odi.GetYesNo[prompt: mkMisc[moreYN]] THEN RETURN;      ENDLOOP;    Odi.HitAnyKeyToContinue[];    DiagRDPVStuff.BadPageSpace ¬ ALL[0];    DiagRDPVStuff.BadPageCount ¬ 0;    result ¬ none;    END;  --BadPages  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the encountered softerrors.  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DisplaySoftErrors: PUBLIC -- DiagRDSurfaceVerify -- PROCEDURE    RETURNS [result: OfflineDiagInterface.ResultType] =    BEGIN    count: CARDINAL;    count1: CARDINAL;    page: PhysicalVolume.PageNumber;    string: STRING ¬ [10];    new: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    numberOfLines: CARDINAL = OfflineDiagTTYDove.bottomLine - Odi.bOfDA - 3;    -- check if empty    IF DiagRDErrorCheck.BadPageCount = 0 THEN {      Odi.PutMessage[        message: mkIOCmd[noErrs], beep: TRUE, clearMessageAreaFirst: TRUE];      RETURN};    count ¬ 0;    IF badPageRecord # NIL THEN {      Odi.DiagHeap.FREE[@badPageRecord]; badPageRecord ¬ NIL};    count ¬ DiagRDErrorCheck.BadPageCount / numberOfLines + 1;    FOR i: CARDINAL IN [1..count] DO      count1 ¬ IF i = count THEN DiagRDErrorCheck.BadPageCount MOD numberOfLines ELSE numberOfLines;      IF count1 = 0 THEN count1 ¬ numberOfLines;            badPageRecord ¬ Odi.GetAFixedPositionDisplayRecord[count1];      badPageRecord.displayTitle ¬ mkMisc[badPageDisplay];      -- Loop to get the display items      FOR j: CARDINAL IN [0..count1) DO        n: CARDINAL ¬ (i - 1) * numberOfLines + j;        new ¬ Odi.GetARow[1];        page ¬ DiagRDErrorCheck.BadPageSpace[n];        new.rowItems[0].namePosition ¬ 0;        new.rowItems[0].name ¬ 	  FormattedBadPageString[pageNumber: page, addErrorCount: TRUE, errorCount: DiagRDErrorCheck.BadPageSpaceCount[n]];        new.rowItems[0].stringValue ¬ NIL;        new.rowItems[0].valuePosition ¬ 0;        badPageRecord.rows[j] ¬ new;        ENDLOOP;      Odi.DisplayFixedPositionData[        displayData: badPageRecord, clearDataArea: (i = 1) OR (count1 # numberOfLines),        upDateOnly: i # 1];      Odi.DiagHeap.FREE[@badPageRecord];      badPageRecord ¬ NIL;      IF i # count THEN IF NOT Odi.GetYesNo[prompt: mkMisc[moreYN]] THEN RETURN;      ENDLOOP;    IF DiagRDErrorCheck.ErrorCode # 299 THEN Odi.HitAnyKeyToContinue[];    result ¬ none;    END;  --DisplaySoftErrors  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the Data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Data: PUBLIC PROCEDURE =    BEGIN    -- array number array and strings may need modifying    -- note: if no title is desired enter NIL    DumpMemory[      title: mkMisc[dataDisplay], ptr: DiagRDTests.ReadDataBuffPtr,      words: 256 * DiagDiskCmdDrive.SectorCount];    END;  --Data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to dump any portion of memory  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DumpMemory: PUBLIC PROCEDURE [    title: LONG STRING ¬ NIL, ptr: LONG POINTER TO ARRAY OF WORD ¬ NIL,    words: CARDINAL ¬ 0] =    BEGIN    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    NumToStr: PROCEDURE [number: CARDINAL] =      BEGIN      string.length ¬ 0;      string1.length ¬ 0;      String.AppendNumber[string1, number, 16];      SELECT string1.length FROM        1 => String.AppendString[string, "000"L];        2 => String.AppendString[string, "00"L];        3 => String.AppendString[string, "0"L];        ENDCASE;      String.AppendString[string, string1];      END;  --NumToStr    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    dataword: CARDINAL;    datawordptr: CARDINAL;    linecount: CARDINAL;    numsPerLine: CARDINAL;    string: STRING ¬ [8];    string1: STRING ¬ [8];    --output the title    Odi.PutTestParameters[upDateOnly: FALSE];    IF title # NIL THEN      Odi.PutData[dataAreaHeading: title, clearHeadingAndData: TRUE];    --output column headings    Odi.PutData[data: mkMisc[dataDisplay1], startWithNewLine: TRUE];    Odi.PutData[data: mkMisc[dataDisplay2], startWithNewLine: TRUE];    --output data    datawordptr ¬ 0;    UNTIL datawordptr >= words DO      linecount ¬ 0;      UNTIL linecount >= 16 OR datawordptr >= words DO        -- display the line number        NumToStr[datawordptr];        Odi.PutData[data: string, startWithNewLine: TRUE];        Odi.PutData[data: "  "];        numsPerLine ¬ 0;        UNTIL numsPerLine >= 16 OR datawordptr >= words DO          -- display eight hexadecimal numbers          dataword ¬ ptr­[datawordptr];          NumToStr[dataword];          Odi.PutData[data: string, blankSpaces: 1];          numsPerLine ¬ numsPerLine + 1;          datawordptr ¬ datawordptr + 1;          ENDLOOP;  --for numsPerLine>= 16        linecount ¬ linecount + 1;        ENDLOOP;  --for linecount      IF datawordptr >= words THEN {Odi.HitAnyKeyToContinue[]; RETURN; };      IF NOT Odi.GetYesNo[prompt: mkMisc[moreYN]] THEN RETURN      ELSE {        Odi.PutData[data: mkMisc[dataDisplay1], clearDataAreaOnly: TRUE];        Odi.PutData[data: mkMisc[dataDisplay2], startWithNewLine: TRUE];        };      ENDLOOP;  --for end of data words    END;  --DumpMemory  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the Header  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Header: PUBLIC PROCEDURE =    BEGIN    opptr: LONG POINTER TO CompatibilityDiskFace.Operation ¬ DiagRDCmds.OpPtr;    fixDataRecord: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord[4];    fixedDataRowTt: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    fixedDataRow00: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    fixedDataRow01: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    fixedDataRow02: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[1];    fixDataRecord.displayTitle ¬ mkMisc[headerDisplay1];    fixDataRecord.rows[0] ¬ fixedDataRowTt;    fixDataRecord.rows[1] ¬ fixedDataRow00;    fixDataRecord.rows[2] ¬ fixedDataRow01;    fixDataRecord.rows[3] ¬ fixedDataRow02;    fixedDataRowTt.rowItems[0].namePosition ¬ 0;    fixedDataRowTt.rowItems[0].name ¬ mkMisc[headerDisplay2];    fixedDataRowTt.rowItems[0].stringValue ¬ NIL;    fixedDataRowTt.rowItems[0].valuePosition ¬ 0;  -- No value    fixedDataRow00.rowItems[0].namePosition ¬ 3;    fixedDataRow00.rowItems[0].name ¬ mkIOCmd[cylinder];    fixedDataRow00.rowItems[0].stringValue ¬ NIL;    fixedDataRow00.rowItems[0].valuePosition ¬ 3 + mkIOCmd[cylinder].length;    fixedDataRow00.rowItems[0].value ¬      IF opptr­.command.header = read THEN opptr­.diskHeader.cylinder      ELSE opptr­.clientHeader.cylinder;    -- fixedDataRow00.rowItems[0].value		¬ opptr­.diskHeader.cylinder;    fixedDataRow01.rowItems[0].namePosition ¬ 3;    fixedDataRow01.rowItems[0].name ¬ mkIOCmd[head];    fixedDataRow01.rowItems[0].stringValue ¬ NIL;    fixedDataRow01.rowItems[0].valuePosition ¬ 3 + mkIOCmd[head].length;    fixedDataRow01.rowItems[0].value ¬      IF opptr­.command.header = read THEN opptr­.diskHeader.head      ELSE opptr­.clientHeader.head;    -- fixedDataRow01.rowItems[0].value		¬ opptr­.diskHeader.head;    fixedDataRow02.rowItems[0].namePosition ¬ 3;    fixedDataRow02.rowItems[0].name ¬ mkIOCmd[sector];    fixedDataRow02.rowItems[0].stringValue ¬ NIL;    fixedDataRow02.rowItems[0].valuePosition ¬ 3 + mkIOCmd[sector].length;    fixedDataRow02.rowItems[0].value ¬      IF opptr­.command.header = read THEN opptr­.diskHeader.sector      ELSE opptr­.clientHeader.sector;    -- fixedDataRow02.rowItems[0].value		¬ opptr­.diskHeader.sector;    Odi.DisplayFixedPositionData[displayData: fixDataRecord, upDateOnly: FALSE];    Odi.HitAnyKeyToContinue[];    END;  --Header  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to the display parameters before starting a test  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitDisplay: PUBLIC PROCEDURE =    BEGIN-- see if cure the 915 bug!--    IF badPageRecord # NIL THEN {--      Odi.DiagHeap.FREE[@badPageRecord ! Heap.Error => GOTO heapChanged];--      badPageRecord ¬ NIL};    displayedBadPages ¬ 0;    badPageRecord ¬ NIL--    EXITS heapChanged => badPageRecord ¬ NIL;    END;  --InitDisplay  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the Label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Label: PUBLIC PROCEDURE =    BEGIN    DumpMemory[      title: mkMisc[labelDisplay], ptr: DiagRDTests.ReadLabelBuffPtr, words: 10];    END;  --Label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the last read status  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LastReadStatus: PUBLIC PROCEDURE = BEGIN Status[]; END;  --Label  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the disk parameters  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DiskParameters: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =    BEGIN    testParmRecordPtr: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord[4];    paramRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[2];    paramRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[2];    paramRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[2];    paramRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow[2];    testParmRecordPtr.displayTitle ¬ mkMisc[dispDiskParam];    testParmRecordPtr.rows[0] ¬ paramRow0;  -- Pointer to first row    testParmRecordPtr.rows[1] ¬ paramRow1;  -- Pointer to second row    testParmRecordPtr.rows[2] ¬ paramRow2;  -- Pointer to third row    testParmRecordPtr.rows[3] ¬ paramRow3;  -- Pointer to forth row    --display the units    paramRow0.rowItems[0].namePosition ¬ 0;    paramRow0.rowItems[0].name ¬ mkIOCmd[minUnit];    paramRow0.rowItems[0].stringValue ¬ NIL;    paramRow0.rowItems[0].valuePosition ¬ mkIOCmd[minUnit].length;    paramRow0.rowItems[0].value ¬ DiagDiskCmdDrive.MinUnit;    paramRow0.rowItems[1].namePosition ¬ 50;    paramRow0.rowItems[1].name ¬ mkIOCmd[maxUnit];    paramRow0.rowItems[1].stringValue ¬ NIL;    paramRow0.rowItems[1].valuePosition ¬ 50 + mkIOCmd[maxUnit].length;    paramRow0.rowItems[1].value ¬ DiagDiskCmdDrive.MaxUnit;    --display the cylinders    paramRow1.rowItems[0].namePosition ¬ 0;    paramRow1.rowItems[0].name ¬ mkIOCmd[minCylinder];    paramRow1.rowItems[0].stringValue ¬ NIL;    paramRow1.rowItems[0].valuePosition ¬ mkIOCmd[minCylinder].length;    paramRow1.rowItems[0].value ¬ DiagDiskCmdDrive.MinCylinder;    paramRow1.rowItems[1].namePosition ¬ 50;    paramRow1.rowItems[1].name ¬ mkIOCmd[maxCylinder];    paramRow1.rowItems[1].stringValue ¬ NIL;    paramRow1.rowItems[1].valuePosition ¬ 50 + mkIOCmd[maxCylinder].length;    paramRow1.rowItems[1].value ¬ DiagDiskCmdDrive.MaxCylinder;    --display the heads    paramRow2.rowItems[0].namePosition ¬ 0;    paramRow2.rowItems[0].name ¬ mkIOCmd[minHead];    paramRow2.rowItems[0].stringValue ¬ NIL;    paramRow2.rowItems[0].valuePosition ¬ mkIOCmd[minHead].length;    paramRow2.rowItems[0].value ¬ DiagDiskCmdDrive.MinHead;    paramRow2.rowItems[1].namePosition ¬ 50;    paramRow2.rowItems[1].name ¬ mkIOCmd[maxHead];    paramRow2.rowItems[1].stringValue ¬ NIL;    paramRow2.rowItems[1].valuePosition ¬ 50 + mkIOCmd[maxHead].length;    paramRow2.rowItems[1].value ¬ DiagDiskCmdDrive.MaxHead;    --display the sectors    paramRow3.rowItems[0].namePosition ¬ 0;    paramRow3.rowItems[0].name ¬ mkIOCmd[minSector];    paramRow3.rowItems[0].stringValue ¬ NIL;    paramRow3.rowItems[0].valuePosition ¬ mkIOCmd[minSector].length;    paramRow3.rowItems[0].value ¬ DiagDiskCmdDrive.MinSector;    paramRow3.rowItems[1].namePosition ¬ 50;    paramRow3.rowItems[1].name ¬ mkIOCmd[maxSector];    paramRow3.rowItems[1].stringValue ¬ NIL;    paramRow3.rowItems[1].valuePosition ¬ 50 + mkIOCmd[maxSector].length;    paramRow3.rowItems[1].value ¬ DiagDiskCmdDrive.MaxSector;    Odi.DisplayFixedPositionData[      displayData: testParmRecordPtr, upDateOnly: FALSE];    Odi.HitAnyKeyToContinue[];    result ¬ none;    END;  --DiskParameters  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the device/controller status  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Status: PUBLIC PROCEDURE [    op: LONG POINTER TO CompatibilityDiskFace.Operation ¬ DiagRDCmds.OpPtr,    useLoggedStatus: BOOLEAN ¬ FALSE] =    BEGIN    OPEN deviceStatus: LOOPHOLE[op.deviceStatus, DiskIOFaceDuke.DeviceStatus];    IOCBPtr: LONG POINTER TO DiskIOFaceDuke.IOCB ¬ LOOPHOLE[op];    logPtr: LONG POINTER TO ARRAY OF WORD ¬ LOOPHOLE[op];    stat: CARDINAL;    str: STRING ¬ [100];    deviceStatus ¬ LOOPHOLE[op.deviceStatus];    Odi.PutData[data: mkMisc[statusDisplay], clearHeadingAndData: TRUE];    Odi.PutData[data: " ", startWithNewLine: TRUE];    str.length ¬ 0;    String.AppendString[str, mkIOCmd[statusHeading]];    String.AppendString[str, mkIOCmd[statusHeading]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 0    str.length ¬ 0;    String.AppendString[str, "00  "];    String.AppendString[str, mkIOCmd[word0Bit00]];    String.AppendString[      str, IF deviceStatus.inProgress THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "00  "];    String.AppendString[str, mkIOCmd[word1Bit00]];    String.AppendString[      str, IF deviceStatus.sectorNotFound THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 1    str.length ¬ 0;    String.AppendString[str, "01  "];    String.AppendString[str, mkIOCmd[word0Bit01]];    String.AppendString[      str, IF deviceStatus.complete THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "01  "];    String.AppendString[str, mkIOCmd[word1Bit01]];    String.AppendString[      str, IF deviceStatus.headerCRCError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 2    str.length ¬ 0;    String.AppendString[str, "02  "];    String.AppendString[str, mkIOCmd[word0Bit02]];    String.AppendString[      str, IF deviceStatus.errorDetected THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "02  "];    String.AppendString[str, mkIOCmd[word1Bit02]];    String.AppendString[      str,      IF deviceStatus.labelAddressMarkError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 3    str.length ¬ 0;    String.AppendString[str, "03  "];    String.AppendString[str, mkIOCmd[word0Bit03]];    String.AppendString[      str,      IF deviceStatus.communicationError THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "03  "];    String.AppendString[str, mkIOCmd[word1Bit03]];    String.AppendString[      str, IF deviceStatus.labelIDError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 4    str.length ¬ 0;    String.AppendString[str, "04  "];    String.AppendString[str, mkIOCmd[word0Bit04]];    String.AppendString[      str, IF deviceStatus.dmaTimeout THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "04  "];    String.AppendString[str, mkIOCmd[word1Bit04]];    String.AppendString[      str, IF deviceStatus.labelVerifyError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 5    str.length ¬ 0;    String.AppendString[str, "05  "];    String.AppendString[str, mkIOCmd[word0Bit05]];    String.AppendString[      str, IF deviceStatus.fifoError THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "05  "];    String.AppendString[str, mkIOCmd[word1Bit05]];    String.AppendString[      str, IF deviceStatus.labelCRCError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 6    str.length ¬ 0;    String.AppendString[str, "06  "];    String.AppendString[str, mkIOCmd[word0Bit06]];    String.AppendString[      str, IF deviceStatus.illegalOperation THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "06  "];    String.AppendString[str, mkIOCmd[word1Bit06]];    String.AppendString[      str,      IF deviceStatus.dataAddressMarkError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 7    str.length ¬ 0;    String.AppendString[str, "07  "];    String.AppendString[str, mkIOCmd[word0Bit07]];    String.AppendString[      str, IF deviceStatus.ready THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "07  "];    String.AppendString[str, mkIOCmd[word1Bit07]];    String.AppendString[      str, IF deviceStatus.dataIDError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 8    str.length ¬ 0;    String.AppendString[str, "08  "];    String.AppendString[str, mkIOCmd[word0Bit08]];    String.AppendString[      str, IF deviceStatus.protocolViolation THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "08  "];    String.AppendString[str, mkIOCmd[word1Bit08]];    String.AppendString[      str, IF deviceStatus.dataVerifyError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 9    str.length ¬ 0;    String.AppendString[str, "09  "];    String.AppendString[str, mkIOCmd[word0Bit09]];    String.AppendString[      str, IF deviceStatus.writeFault THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "09  "];    String.AppendString[str, mkIOCmd[word1Bit09]];    String.AppendString[      str, IF deviceStatus.dataCRCorECCError THEN mkMisc[truE] ELSE mkMisc[falsE]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 10    str.length ¬ 0;    String.AppendString[str, "10  "];    String.AppendString[str, mkIOCmd[word0Bit10]];    String.AppendString[      str, IF deviceStatus.illegalCylinder THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "10  "];    String.AppendString[str, mkIOCmd[word1Bit10]];    String.AppendString[str, mkMisc[nil]];    Odi.PutData[data: str, startWithNewLine: TRUE];    --bit 11    str.length ¬ 0;    String.AppendString[str, "11  "];    String.AppendString[str, mkIOCmd[word0Bit11]];    String.AppendString[      str, IF deviceStatus.track00 THEN mkMisc[truE] ELSE mkMisc[falsE]];    String.AppendString[str, "11  "];    String.AppendString[str, mkIOCmd[word1Bit11]];    String.AppendString[str, mkMisc[nil]];    Odi.PutData[data: str, startWithNewLine: TRUE];    IF Odi.userType = Programmer THEN {      str.length ¬ 0;      stat ¬ op.deviceStatus.a;      String.AppendString[str, "devicestatus.a: "];      String.AppendNumber[str, stat, 16];      String.AppendString[str, "     "];      stat ¬ op.deviceStatus.b;      String.AppendString[str, "devicestatus.b: "];      String.AppendNumber[str, stat, 16];      Odi.PutMessage[message: str, clearMessageAreaFirst: TRUE];      };    IF Odi.userType = Programmer THEN {      str.length ¬ 0;      IF useLoggedStatus THEN stat ¬ logPtr­[25]      ELSE stat ¬ LOOPHOLE[IOCBPtr.dob.headerError];      String.AppendString[str, mkIOCmd[headerStatus]];      String.AppendNumber[str, stat, 16];      Odi.PutMessage[message: str, startWithNewLine: TRUE];      str.length ¬ 0;      IF useLoggedStatus THEN stat ¬ logPtr­[26]      ELSE stat ¬ LOOPHOLE[IOCBPtr­.dob.labelError];      String.AppendString[str, mkIOCmd[labelStatus]];      String.AppendNumber[str, stat, 16];      Odi.PutMessage[message: str, startWithNewLine: TRUE];      str.length ¬ 0;      IF useLoggedStatus THEN stat ¬ logPtr­[27]      ELSE stat ¬ LOOPHOLE[IOCBPtr­.dob.dataError];      String.AppendString[str, mkIOCmd[dataStatus]];      String.AppendNumber[str, stat, 16];      Odi.PutMessage[message: str, startWithNewLine: TRUE];      str.length ¬ 0;      IF useLoggedStatus THEN stat ¬ logPtr­[28]      ELSE stat ¬ LOOPHOLE[IOCBPtr­.dob.lastError];      String.AppendString[str, mkIOCmd[lastErr]];      String.AppendNumber[str, stat, 16];      Odi.PutMessage[message: str, startWithNewLine: TRUE];      str.length ¬ 0;      IF useLoggedStatus THEN stat ¬ logPtr­[29]      ELSE stat ¬ LOOPHOLE[IOCBPtr­.dob.driveAndControllerStatus];      String.AppendString[str, mkIOCmd[driveAndContStatus]];      String.AppendNumber[str, stat, 16];      Odi.PutMessage[message: str, startWithNewLine: TRUE];      };    IF NOT useLoggedStatus THEN Odi.HitAnyKeyToContinue[prompt: NIL];    END;  --Status  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the names of the available subtests  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Subtests: PUBLIC PROCEDURE =    BEGIN    str: STRING ¬ [8];    cnt: CARDINAL;    sTcnt: CARDINAL ¬ 1;    -- display title    UNTIL sTcnt >= ORD[LAST[DiagRDTestRec.Subtest]] DO      Odi.PutMessage[        message: DiagDiskMkMisc.mkMisc[subtesT], clearMessageAreaFirst: TRUE];      cnt ¬ 0;      UNTIL cnt >= 15 OR sTcnt >= ORD[LAST[DiagRDTestRec.Subtest]] DO        str.length ¬ 0;        String.AppendNumber[str, sTcnt];        String.AppendString[str, "."];        Odi.PutMessage[message: str, startWithNewLine: TRUE];        Odi.PutMessage[          message: DiagRDTestRec.Subtests[VAL[sTcnt]].title,          startWithNewLine: FALSE, blankSpaces: 1];        cnt ¬ cnt + 1;        sTcnt ¬ sTcnt + 1;        ENDLOOP;      IF sTcnt < ORD[LAST[DiagRDTestRec.Subtest]] THEN        IF NOT Odi.GetYesNo[prompt: mkMisc[moreYN]] THEN EXIT;      ENDLOOP;    Odi.HitAnyKeyToContinue[];    END;  --Subtests  AppendSpaces: PROC [str: LONG STRING, spaces: CARDINAL ¬ 0] =    BEGIN    IF spaces = 0 THEN RETURN;    FOR i: CARDINAL IN [0..spaces) DO String.AppendChar[s: str, c: ' ]; ENDLOOP;    END;  FormattedBadPageString: PROC [    pageNumber: PhysicalVolume.PageNumber, addTimesTriedFailed: BOOLEAN ¬ FALSE,    timesTried: CARDINAL ¬ 1, timesFailed: CARDINAL ¬ 1,    addErrorCount: BOOLEAN ¬ FALSE, errorCount: CARDINAL ¬ 1,    addRecovery: BOOLEAN ¬ FALSE,    recovery: DiagRDErrorCheck.Recovery ¬ notCorrectable]    RETURNS [string: LONG STRING] =    BEGIN    str1: STRING ¬ [110];    str2: STRING ¬ [110];    cyl: CARDINAL;    head: CARDINAL;    sector: CARDINAL;    position: CARDINAL ¬ 0;    --change page number to cylinder/head/sector    [cyl, head, sector] ¬ DiagRDPVStuff.PageToAddr[pageNumber];    -- display bad page number    str1.length ¬ 0;    String.AppendString[str1, mkIOCmd[page]];    String.AppendLongNumber[str1, pageNumber, 10];    --Odi.PutData[data: str1, startWithNewLine: TRUE];    --spaces¬ 15-str1.length;    position ¬ 15;    AppendSpaces[str1, position - str1.length];    --display cylinder    --str.length ¬ 0;    String.AppendString[str1, mkIOCmd[cylinder]];    String.AppendNumber[str1, cyl, 10];    --Odi.PutData[data: str1, blankSpaces: spaces];    --spaces¬ 15-str1.length;    position ¬ position + 15;    AppendSpaces[str1, position - str1.length];    -- display head    --str.length ¬ 0;    String.AppendString[str1, mkIOCmd[head]];    String.AppendNumber[str1, head, 10];    --Odi.PutData[data: str1, blankSpaces: spaces];    --spaces¬ 15-str1.length;    position ¬ position + 15;    AppendSpaces[str1, position - str1.length];    -- display sector    --str.length ¬ 0;    String.AppendString[str1, mkIOCmd[sector]];    String.AppendNumber[str1, sector, 10];    --Odi.PutData[data: str1, blankSpaces: spaces];    --spaces¬ 15-str1.length;    position ¬ position + 15;    AppendSpaces[str1, position - str1.length];    IF addTimesTriedFailed THEN {  -- display times tried      str2.length ¬ 0;      String.AppendString[str2, mkIOCmd[tries]];      String.AppendNumber[str2, timesTried, 10];      --Odi.PutData[data: str2, blankSpaces: spaces];      --spaces¬ 15-str2.length;      position ¬ 15;      AppendSpaces[str2, position - str2.length];      -- display times failed      --str.length ¬ 0;      String.AppendString[str2, mkIOCmd[failures]];      String.AppendNumber[str2, timesFailed, 10];      --Odi.PutData[data: str2, blankSpaces: spaces];      --spaces¬ 15-str2.length;      position ¬ position + 15;      AppendSpaces[str2, position - str2.length];      };    IF addRecovery THEN {  -- display how recovered      --str.length ¬ 0;      SELECT recovery FROM        retryCorrectable => String.AppendString[str2, mkMisc[retries]];        eccCorrectable => String.AppendString[str2, mkMisc[ecc]];        notCorrectable => String.AppendString[str2, mkMisc[notCorrectable]];        ENDCASE;      position ¬ position + 15;      AppendSpaces[str2, position - str2.length];      --   Odi.PutData[data: str2, startWithNewLine: TRUE];      };    IF addErrorCount THEN {  --str.length ¬ 0;      String.AppendString[str2, mkIOCmd[errCount]];      String.AppendNumber[str2, errorCount, 10];      --Odi.PutData[data: str2, blankSpaces: spaces];      };    string ¬ String.MakeString[Odi.DiagHeap, str1.length + str2.length + 1];    String.Copy[to: string, from: str1];    String.AppendString[to: string, from: str2];    RETURN[string];    END;  END... --of DiagRDDisplayImplLOG25-Sep-85 11:10:49 by MXT, Changed Header to display correct value.27-Jan-86 16:49:19 by MXT, Changed BadPage and BadPages. Added DisplaySoftErrors EXPORTing to DiagRDSurfaceVerify.24-Apr-86  9:49:25 by KL, ???22-Mar-87 10:00:12 by STC, make DumpMemory.title LONG16-Apr-87 16:00:31 by STC, a 915 bug in InitDisplay 3-Sep-87 13:43:32 by STC, conditional HitAnyKeyToContinue in DisplaySoftErrors19-Sep-88 16:53:30, STC, Labelless, DiskIOFaceDove ¬ DiskIOFaceDuke 
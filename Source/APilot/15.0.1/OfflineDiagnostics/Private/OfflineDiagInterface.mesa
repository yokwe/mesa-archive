-- File: OfflineDiagInterface.mesa-- Last edited on  20-Jun-85 10:12:24  by KL---- Copyright (C) Xerox Corporation 1984, 1985. All rights reserved.---- This interface module provides the common utilities and definitions used by -- Dove offline diagnostic programmers.-- DIRECTORY  TTY	USING [Handle];OfflineDiagInterface: DEFINITIONS = BEGIN--~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC TYPE definitions--~~~~~~~~~~~~~~~~~~~~~~~~~	--~~~~~~~~~~~~~~~~~~~~~~~~~~--  AbortCurrentTest Signal--~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- A user can hit the Abort/Stop Key any time. This generates AbortCurrentTest.-- The consequence of hitting the Abort/Stop Key, as far as the Control Module-- is concerned, is one of the following:---- 	1) If the user is running a test, the test is aborted. The menu is--	   redisplayed if the aborted test hogged the entire screen.--	2) If the client is in the process of selecting a menu item, then the--	   parent menu will be re-entered after exiting the current menu.---- If a client has the need to do some clean up work before exiting, then this-- signal can be intercepted by the client. After performing the last minute-- tasks, the client should REJECT this signal; unless, of course, the client-- disallows aborting (ie. the test must run to a certain point in the program-- before aborting is allowed). If the latter is the case, then the client can-- simply ignore the signal or take whatever local action is appropriate; for a-- client has complete control as to what to do with this signal--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AbortCurrentTest: SIGNAL;  -- User has hit the STOP key.--~~~~~~~~~~~~~~~~~~-- Procedural types--~~~~~~~~~~~~~~~~~~  				         -- Offine diagnostic procedures take the following form:  OfflineDiagnosticProc: TYPE = PROCEDURE RETURNS [result: ResultType];  --~~~~~~~~~~~~~~~~~~-- Enumerated Types--~~~~~~~~~~~~~~~~~~   -- Every test returns a test result. The result is given to the user as follows:----	none - Nothing (blanks)--	passed - "P" printed next to the test selection number--	failed - "F" printed next to the test selection number--	ambiguous - "?" printed next to the test selection number   ResultType: TYPE = { none, passed, failed, ambiguous };  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC data structures and their allocation PROCEDUREs exported by the Control-- Module: These data structures are allocated from a private heap which will be-- deleted when one exits a test category.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Space is premium. In order to minimize the amount of allocated memory, the -- Control Module creates its own private heap. Common structures needed by the-- diagnostic programmers are allocated from this private heap, which can be-- readily destroyed or recreated by the Control Module. This mechanism gives-- the Control Module the ability to contain dynamic memory usage and access -- client structures and procedures.---- The following are the structures and the PUBLIC procedures for allocating them-- from the Control Module's private heap.   --~~~~~~~~~~-- TestItem--~~~~~~~~~~	      -- A TestItem identifies a menu selection and its attributes. It can identify an -- actual test or a submenu.		    TestItem: TYPE = RECORD [   	    itemName: LONG STRING ¬ NIL,  -- Name displayed in the menu.	    test: OfflineDiagnosticProc,  -- The actual test procedure.	    -- When no helpExplanation is provided, the Control Module	    -- will supply a generic help message such as "Please enter 1 to 9".	    itemExplanation: LONG STRING ¬ NIL,	    -- A TestItem can select another menu of tests.	    subMenu: LONG POINTER TO AMenuOfSelections ¬ NIL ];	      -- The procedure to get an instance of the structure is:			    GetATestItem: PROCEDURE RETURNS [LONG POINTER TO TestItem]; --~~~~~~~~~~~~~~~~~~~~~~-- TestItemsForThisNode--~~~~~~~~~~~~~~~~~~~~~~-- TestItemsForThisNode contain all the TestItems associated with this menu level.-- GetATestItemsForThisMenu allocates as much space as needed to hold all the -- TestItem that the various users can select at this node.  TestItemsForThisNode: TYPE = RECORD [    count:  CARDINAL,     nodeItems: SEQUENCE numOfTestItemsInNode: CARDINAL OF LONG POINTER TO TestItem    ];  -- The procedure to get an instance of the structure is:  GetATestItemsForThisNode: PROCEDURE [numberOfTestItemsInNode: CARDINAL ¬ 0]                  	      RETURNS [LONG POINTER TO TestItemsForThisNode];			      			      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- SubMenus for different classes of users      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Users are divided into 5 classes: Normal Users--				     System Administrators--				     Services Engineers--				     Manufacturing Personnel--				     Programmers---- Not all the TestItems in a node are selectable by all the classes of users.-- userSelections­, adminSelections­, seSelections­, manufacturingSelections­ and-- programmerSelections­ contain series of CARDINALs designating-- the TestItems each class of users can select and in what order these -- selections will appear when displayed for selection.---- Each number corresponds to the index of an entry in TestItemsForThisNode, which-- contains the pointers to the actual TestItems. The order in which the -- TestItemsForThisMenu indices are entered is the order in which the selections  -- will be presented on the display. For example, if seSelections­ has [9,7,1,8,5]-- as its sequence, then the displayed selection menu will appear as follows:----    Available Selections----	  1)  <TestItemsForThisNode[9]>--	  2)  <TestItemsForThisNode[7]>--	  3)  <TestItemsForThisNode[1]>--	  4)  <TestItemsForThisNode[8]>--	  5)  <TestItemsForThisNode[5]>----    Please Enter Selection:---- To save space, a common structure is used to contain the selections of a user-- class to avoid the use of variant records. This structure is Selections. An-- instance of this structure is needed for each user class for each menu.  Selections: TYPE = RECORD -- MACHINE DEPENDENT RECORD    	          [count:  CARDINAL,  -- The number of entries in the SEQUENCE.	           selections: SEQUENCE numberOfSelections: CARDINAL OF CARDINAL];--~~~~~~~~~~~~~~~~~-- User Selections   --~~~~~~~~~~~~~~~~~-- GetASelectionArray allocates space for an array to hold all the indices of -- pointers to TestItems stored in TestItemsForThisMenu. These indices designate-- the tests that a class of users can run.   GetASelectionArray: PROCEDURE [numberOfSelections: CARDINAL ¬ 0]  			RETURNS [selectionsForClass: LONG POINTER TO Selections];		    		    				--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- All the information that describe the contents of a menu node are contained -- in AMenuOfSelections, which is passed to the Control Module. Based on this,-- the Control Module builds an appropriate menu for the user.---- Run<mumble>Tests[pAMenuOfSelections] passes the pAMenuOfSelections for the-- AMenuOfSelections describing a client's top node.---- menuHelp is optional. The help text is displayed when a ? is entered alone.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AMenuOfSelections: TYPE = RECORD [   	 menuTitle: LONG STRING ¬ NIL,  -- Optional 	 menuHelp: LONG POINTER TO HelpText ¬ NIL, -- Optional	 userSelections: LONG POINTER TO Selections,	 adminSelections: LONG POINTER TO Selections,	 seSelections: LONG POINTER TO Selections,	 manufacturingSelections: LONG POINTER TO Selections,	 programmerSelections: LONG POINTER TO Selections,	 testItemsForThisNode: LONG POINTER TO TestItemsForThisNode ];					   -- The procedure to get an instance of the structure is:			   GetAMenuOfSelections: PROCEDURE  RETURNS -- AMenuOfSelections defines a node.    [pMenuOfSelections: LONG POINTER TO  AMenuOfSelections ¬ NIL];	    --~~~~~~~~~~-- HelpText    --~~~~~~~~~~-- HelpText contains STRINGs of help text for interacting with users. A user can-- receive help by typing in a question mark to read this text.  HelpText: TYPE = RECORD [  	    count:  CARDINAL,	    helpTitle: LONG STRING ¬ NIL,	    textBody: SEQUENCE numberOfLines: CARDINAL OF LONG STRING];   -- The procedure to get an instance of HelpText is	 	   GetAHelpText: PROCEDURE [numberOfLines: CARDINAL ¬ 0]  		  RETURNS [LONG POINTER TO HelpText];				--~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- FixedPositionDisplayRecord--~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Fixed-position display data are possible. The data to be dispalyed and the-- name associated with each datum are passed to the Control Module in the-- record FixedPositionDisplayRecord. The format of the display is as follows for -- a sample display with two-itemed rows:---- 	< Title for the displayed record >----	  Item1Title: Item1Value      Item2Title: Item2Value      --	  Item3Title: Item3Value      Item4Title: Item4Value      --		...			    ...----	  ItemnTitle: ItemnValue      Item(n+1)Title: Item(n+1)Value---- The fixed-position data are displayed in the Data Area by default, like all -- other data.---- Each displayed item can optionally have its own name.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  FixedPositionDisplayRecord: TYPE = RECORD [  	 displayTitle: LONG STRING ¬ NIL,  -- Heading for displayed data.	 numberOfRows: CARDINAL,  -- The number of rows of displayed data.	 rows: SEQUENCE rowCount: CARDINAL OF LONG POINTER TO ARow];	 	  -- The procedure to get an instance of FixedPositionDisplayRecord is:	   -- Client must specify the number of items on a line and the number of lines.  -- The LONG POINTER returned by GetARow is entered into desired SEQUENCE slot.  -- For example:  pFixedPositionDisplayRecord.rows[0] ¬ ptrToRow0  --		   pFixedPositionDisplayRecord.rows[1] ¬ ptrToRow1 ....  --   GetAFixedPositionDisplayRecord: PROCEDURE [rowCount: CARDINAL]	 RETURNS [LONG POINTER TO FixedPositionDisplayRecord];--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- A line of display can contain several items. In deciding how many items to-- put on a line, keep in mind the width of the 15" display.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~					       ARow: TYPE = RECORD [  	itemsInARow:  CARDINAL ¬ 1,  -- Number of items per row.	rowItems: SEQUENCE numberOfDisplayItemsInARow: CARDINAL OF DisplayItem];  -- The procedure to get an instance of ARow is:  GetARow: PROCEDURE [numberOfDisplayItemsInARow: CARDINAL ¬ 1]  	     -- Store returned pointer in FixedPositionDisplayRecord.rows[n]  	     RETURNS [LONG POINTER TO ARow];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- A displayed item is abstracted by DisplayItem. It allows a client to -- customize his/her display format.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	   DisplayItem: TYPE = RECORD [        -- Positional values must be non-zero.  	namePosition: CARDINAL ¬ 0,  -- Starting position... Must NOT be zero.	name: LONG STRING ¬ NIL,  -- Optional name for this item.	-- A value can be a STRING. If non-NIL, then it is printed after the name	-- with a space separating the two.	stringValue: LONG STRING ¬ NIL,  	valuePosition: CARDINAL ¬ 0,  -- Must be non-zero. 0 => no value	value: LONG CARDINAL];  -- The value for the displayed item.					     --~~~~~~~~~~~~~~~				     -- OptionsRecord --~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- There are occasions when it is desireable to have the user select an option-- from a list of many possible options. GetAnOption does this.---- The Option Menu occupies the top portion of the display. While the Option -- Menu is displayed, the public Message and client Data areas retain their-- normal properties.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  OptionsRecord: TYPE = RECORD [  	optionMenuTiTle: LONG STRING ¬ NIL, -- Heading for displayed options.	numberOfOptionLines: CARDINAL,  -- The number of lines of options.	-- linesOfOptions holds the pointers returned by GetAnOptionLine	linesOfOptions: SEQUENCE numberOfLines: CARDINAL 			OF LONG POINTER TO AnOptionLine];			   -- The procedure to get an instance of an OptionsRecord is:  GetAnOptionsRecord: PROCEDURE [numberOfLines: CARDINAL]  	                RETURNS [LONG POINTER TO OptionsRecord];						--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- A line of options may contain many items. Again , keep in mind the width of-- the 15" display.			--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AnOptionLine: TYPE = -- MACHINE DEPENDENT -- RECORD  	[numberOfOptionsPerLine: CARDINAL ¬ 1,  -- The number of options per line.	 optionsOnALine: SEQUENCE optionsPerLine: CARDINAL OF OptionItem];	 -- The procedure to get an instance of an OptionLine is GetAnOptionLine.-- GetAnOptionLine allocates space for a line of options. The pointer to this -- line of displayed options should be assigned to the appropriate slot in the-- SEQUENCE of pointers in OptionsRecord.   GetAnOptionLine: PROCEDURE [optionsPerLine: CARDINAL]  -- Store the returned pointers in the sequence linesOfOptions in OptionsRecord  	             RETURNS [LONG POINTER TO AnOptionLine];		     	 --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- An OptionItem is defined by OptionItem.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		  OptionItem: TYPE = -- MACHINE DEPENDENT -- RECORD  	[position:  CARDINAL,  -- Starting position of this option.	 selectionNumberForThisItem: CARDINAL, -- Number for selecting this item.	 option: LONG STRING,  -- The name for this option.	 helpForThisOption: LONG STRING ¬ NIL];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  GetSpace Gives a block of contiguous memory of <pageCount> pages.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetSpace: PROCEDURE [pageCount: CARDINAL] RETURNS [LONG POINTER];    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDUREs exported by clients of the Offline Diagnostic Subsystem.-- Each client must export a single procedure to this interface in order to-- access its facilities.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ClientPackage: TYPE = PROCEDURE RETURNS [LONG POINTER TO AMenuOfSelections];    RunEthernetTests: ClientPackage;		      RunFloppyDiscTests: ClientPackage;		    	  RunFormatterScavengerBPU: ClientPackage;    RunHardDiscTests: ClientPackage;    RunKbdDsplMouseTests: ClientPackage;    RunLaserDiscTests: ClientPackage;    RunManufacturingTests: ClientPackage;    RunPrinterTests: ClientPackage;		      RunRS232CTests: ClientPackage;  RunTapeDriveTests: ClientPackage;    -- System configuration utilities  RunSystemConfigurator: ClientPackage;    -- For miscellaneous uses  RunMiscTests: ClientPackage;    -- This is reserved for the self-test package that tests the various features  -- of the Offline Diagnostic Subsystem.    RunSelfTest: ClientPackage;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDUREs exported by the Control Module--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  << Screen Lay Out:  +===========================================================================+  I   ID   Xerox (C) Xerox Corporation 1984, 1985. All rights reserved.	      I  I   Running: <Test Category>,  Test Selected: <Test name> 		      I  I									      I  I   O  Menu/System-Config/Options/TestParameter Area			      I  I	 GetAnOption, PutTestParameters(Fixed-Position Data)		      I  I									      I  I   O  Interactive Selection Prompt Line - spX, spY, GetAnOption 	      I  I   O  Auxiliary Prompt - auxPX, auxPY, GetANumber, GetYesNo, GetAString    I  I									      I  I   O  Common Message Area - bOfMA, endOfMA,  msgX, msgY, dirtyML           I  I	 Help and error messages are displayed here (PutMessage)	      I  I									      I  I   O  Data Area - bOfDA, dX, dY, dirtyDL, endOfDA, dataOffSet 	      I  I		     DisplayFixedPosition, PutData,			      I	     I	 Fixed-Position Data is displayed here.     			      I  I	 This area is for client usage exclusively. 			      I  I            						   		      I  +===========================================================================+  >>--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PutData allows a user to display data in the Data Area, which is under the-- exclusive control of the client. ---- PutData displays the input string in the Data Region of the display. It is-- meant to display dynamic test data. The defaults print data in a tightly-- packed format.---- numberAfterData is a LONG CARDINAL that will be appended immediately to the-- data. If a separating space is desired, it is up to the client to add a space-- as the last character in the immediately preceding data string.---- If dataAreaHeading # NIL then the heading is printed and the rest of the data-- area is cleared. Subsequent scrolling will not clear this heading until an-- explicit "clearHeadingAndData: TRUE" is issued.  ---- Once a heading is printed, subsequent invocation of PutData should have -- dataAreaHeading set to NIL, until, of course, a new heading is desired. If not,-- the data area will be cleared and the heading printed.---- If fixed-position data is displayed, the entire Data Area is cleared when-- the fixed-position data is cleared.---- The Data Area is twice the size of the Message Area.----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PutData: PROCEDURE [data: LONG STRING ¬ NIL, -- String to be printed.  		      -- numberAfterData = LAST[LONG CARDINAL] => no number to		      -- be printed after the data STRING. Any other value will		      -- be printed after data.  		      numberAfterData: LONG CARDINAL ¬ LAST[LONG CARDINAL],  		      dataAreaHeading: LONG STRING ¬ NIL, -- This is not cleared  		      -- clearHeadingAndData TRUE clears the entire Data Area		      -- including dataAreaHeading. dataAreaHeading must be NIL.  		      clearHeadingAndData: BOOLEAN ¬ FALSE,		      -- clearDataAreaOnly does not clear the heading. Only the		      -- data below the heading is cleared.  		      clearDataAreaOnly: BOOLEAN ¬ FALSE, 		      		      -- Control variables for formatting dispaly data.  		      startWithNewLine: BOOLEAN ¬ FALSE, -- CRLF		      numOfBlankLines: CARDINAL ¬ 0, -- CRLF numOfBlankLine times.		      -- spaceBeforePrinting has effect only if startWithNewLine		      -- and clearDataAreaOnly are both FALSE.		      blankSpaces: CARDINAL ¬ 0,  -- Spaces before printing		      -- xPosition = 0 => Let Control module and blankSpaces		      -- specify the position on the line to print data.		      -- Non-Zero xPosition overrides automatic positioning.		      -- The Control Module will start printing at xPosition		      -- after calculating the current line.		      xPosition: CARDINAL ¬ 0, -- Position to start printing		      -- Pause at the bottom of the Data Area so that the user		      -- can review the data before they are cleared.		      pauseAtBottomOfDataArea: BOOLEAN ¬ FALSE]; 		      		      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PutMessage displays the input messages in the Message Region of the display.-- This is a public interactive area: both the client and Control Module write-- data into this region randomly.---- The default format is a new line per message.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PutMessage: PROCEDURE [message: LONG STRING ¬ NIL,  			 beep: BOOLEAN ¬ FALSE,			 -- startWithNewLine TRUE invalidates spaceBeforePrinting			 startWithNewLine: BOOLEAN ¬ TRUE,  -- CRLF			 -- One can insert numOfBlankLine blank lines.			 numOfBlankLines: CARDINAL ¬ 0,			 blankSpaces: CARDINAL ¬ 1,   			 --clearMessageAreaFirst TRUE invalidates startWithNewLine			 -- and spaceBeforePrinting			 clearMessageAreaFirst: BOOLEAN ¬ FALSE];--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- DisplayFixedPositionData is meant to give the client the ability to display-- data related to topics whose headings are fixed positionally.---- The fixed data are displayed at the beginning of the Data Area.---- In addition to a heading associated with each value, a permanent title can-- optionally be dispalyed at the very beginning of the Data Area. The title is-- contained in the displayData.displayTitle field of displayData­.---- The first invocation should have upDateOnly set to FALSE (upDateOnly: FALSE). -- Both the headings and values associated with each heading will be printed.---- Subsequent invocations should only update the VALUEs. The heading then would-- not be reprinted each time. This is achieved by setting "upDateOnly: TRUE",-- which is the default.---- clearDataArea clears the displayed data and re-initialize the Data Area,-- regardless what upDateOnly is. It gives the client the means to clear the-- Data Area without affecting the rest of the screen.---- While fixed-position data is displayed, the remainder of the Data Area is -- accessible to PutData and retains all its properties.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DisplayFixedPositionData: PROCEDURE 	[displayData: LONG POINTER TO FixedPositionDisplayRecord ¬ NIL,	 clearDataArea: BOOLEAN ¬ FALSE, -- TRUE clears before printing.	 upDateOnly:  BOOLEAN ¬ TRUE];  -- TRUE => Print values only.	 --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PutTestParameters displays and updates test parameters in the menu/option-- area. Each datum has two fields, a title (STRING) and a value (LONG CARDINAL).-- -- This procedures uses the same data structures as DisplayFixedPositionData.---- upDateOnly should be set to FALSE for the first call. "upDateOnly: FALSE" will-- cause the screen to be cleared and the title and name fields to be printed in-- addition to the initial value fields. "upDateOnly: TRUE" prints only the new-- values.---- parameters = NIL will clear and reformat the screen, regardless what upDateOnly-- is.---- Both Data and Message areas retain their normal properties while parameters-- are displayed.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PutTestParameters: PROCEDURE [  	parameters: LONG POINTER TO FixedPositionDisplayRecord ¬ NIL,	upDateOnly:  BOOLEAN ¬ TRUE];  -- TRUE => Print values only.			 		      	--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- GetYesNo gets a yes/no response from the user. A YES returns TRUE. NO returns-- FALSE.-- Yes(Y/y) and No(N/n) are defined in the Mesasage Keys. They can, therefore,-- take on any dissimilarly CHARACTER-valued pairs.-- The default: value is returned if CR is the only input and defaultSpecified-- is TRUE.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetYesNo: PROCEDURE [prompt: LONG STRING ¬ NIL, 		       help: LONG POINTER TO HelpText ¬ NIL,		       defaultSpecified: BOOLEAN ¬ FALSE,		       default: BOOLEAN ¬ FALSE]  	      RETURNS [YesReturnsTrue: BOOLEAN];    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- GetANumber gets a numeric input from the user. -- + and - are also allowed. These, however, are directional indicators. -- + sets foreward to TRUE, - sets foreward to FALSE.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetANumber: PROCEDURE [prompt: LONG STRING ¬ NIL,  -- Personalized prompt.  			 help: LONG POINTER TO HelpText ¬ NIL,  -- Explanation  			 lowLimit: LONG CARDINAL ¬ 1,			 upperLimit: LONG CARDINAL ¬ LAST [LONG CARDINAL],			 numberIsHexadecimal: BOOLEAN ¬ FALSE,			 numberIsLong: BOOLEAN ¬ FALSE,			 defaultNumber: LONG CARDINAL ¬ LAST[LONG CARDINAL]]  	        RETURNS [longNumber: LONG CARDINAL,  -- 0 if number is not long			 -- number is 0 if numberIsLong is TRUE.			 number: CARDINAL,			 -- Directional default is FOREWARD.			 foreward: BOOLEAN ¬ TRUE, -- FALSE => reverse		         numberInStringFormat: LONG STRING ]; -- In specified base--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- GetAnOption:---- There are occasions when it is desireable to have the user select an option-- from a list of many possible options. GetAnOption does this.---- An invocation with "optionTable: NIL" will get another option input from -- the user for the client from the currently displayed option list.---- optionTable # NIL will cause the option table to be printed.---- The client can specify a default option returned at the receipt of a CR. ---- The client can loop and get as many option selections as the client wishes.-- To prevent the reprinting of the option table, set optionTable to NIL after-- the first use of GetAnOption. The client determines when to terminate. This-- can be done be having one of the options be:  n) Terminate option input.---- The client can insert a customized help text for each use of GetAnOption.-- This also applies to the prompt. By knowing what has been entered, the user-- can be prevented from erroneous operations by inserting different prompts.---- 0 can not be used by the client as a selection number.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	   GetAnOption: PROCEDURE [optionTable: LONG POINTER TO OptionsRecord ¬ NIL,  			  defaultOption: CARDINAL ¬ 0, -- When CR = the only input			  optionPrompt: LONG STRING ¬ NIL,  -- Prompt for input.			  optionHelp: LONG POINTER TO HelpText ¬ NIL,			  justDisplayTable: BOOLEAN ¬ FALSE]  		 RETURNS [selectedOption: CARDINAL];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- GetAString is for getting a string input from the user. This procedure should-- not be used as a means to get a command from the user. All commands should be-- hidden behind menu/option selections. The idea is:----	 What you see is what you get... And if you don't see it, entering a --	 question mark should give you what you need.---- This procedure should be used to get a name ( ie. Host or whatever ) -- from the user, not for getting a command.---- 	prompt: a client-customizeable message given to the user when getting--	        an input from the user. If none is supplied, the following is--	        the default message:  "Please enter a name"----	defaultString: an optional prompt appended to the above prompt as --		       follows: [<defaultString>]----	help: a block of text explaining the current action. If help = NIL,--	      "Please enter a name" is given as the default----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetAString:  PROCEDURE [prompt: LONG STRING ¬ NIL, -- Personalized prompt  			  defaultString: LONG STRING ¬ NIL,	      	          help: LONG POINTER TO HelpText ¬ NIL, -- Help		 	  echoWithStar: BOOLEAN ¬ FALSE]	         RETURNS [LONG STRING];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- HitAnyKeyToContinue temporarily pauses the test until the user enters a key.-- If the key is the STOP key, the test is terminated; all other keys cause the-- test to continue at the point of pause.---- If prompt is NIL, the default prompt of "Enter any key to continue:" is -- displayed.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  HitAnyKeyToContinue: PROCEDURE [     prompt: LONG STRING ¬ NIL, beep: BOOLEAN ¬ TRUE];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- LookForAbort checks to see if the user has hit the "STOP" key. If the key is-- hit, AbortCurrentTest is raised. This signal can be used internally by the -- client by catching it; or, if eventually REJECTed by the client, passed back-- to the Control Module as a genuine request to abort the current test.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LookForAbort: PROCEDURE;   --~~~~~~~~~~~~~~~~~~~~~~~-- Miscellaneous exports--~~~~~~~~~~~~~~~~~~~~~~~  LoginType: TYPE = {              NormalUser, Administrator, Services, Manufacturing, Programmer };    userType: READONLY LoginType;  -- This is the class of the logged-in user.    bOfDA: READONLY CARDINAL;  -- Beginning of Data Area of display.    inputChar: READONLY CHAR;  -- Current user input    inputSensed: BOOLEAN;  -- TRUE => user has just entered an input.    abortSensed: BOOLEAN;  -- TRUE => user has hit the  STOP key.--~~~~~~~~~~~~~~~~~~~-- Handle to DiagTTY	--~~~~~~~~~~~~~~~~~~~  hDiagTTY: TTY.Handle;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- DiagHeap - All space allocation should be from this Heap. This makes it -- possible for the Control Module to delete spaces when it knows they are no-- longer needed.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DiagHeap: READONLY UNCOUNTED ZONE;		     <<--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Informational SIGNALS that will transfer control to the Debugger. These serve-- mainly to assist the client in interfacing with the Control Module.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  NoTestsInUserSelections => No selections for Normal User.  NoTestInAdminSelections => No selections for System Administrator  NoTestInSESelections => No selections for Service Engineer .  NoTestInManufacturingSelections => No selections for Manufacturing.  NoTestInProgrammerSelections => No selections for Programmer.  TestItemsForThisNodeIsEmpty => Node is void.  LineIsTooLong => Line is too long. Plan for 15" display.  MenuIsTooLargeForScreen => Menu is too large for display. Plan for 15" display.  >>    END.  -- OfflineDiagInterface    LOG:  Created: 10-Jul-84 by KL.19-Jun-85 by KL - Added defaults to GetYesNo20-Jun-85 by KL - Replaced Analyst with Manufacturing as a valid LoginType.
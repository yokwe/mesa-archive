-- File SysConfigBootDeviceImpl.mesa-- Last edited:	 5-Jan-87 10:43:55	RDM Add badMemConfig message.--  9-Dec-86  8:54:38	RDM	-- 10-Sep-85 11:36:31	by: MR-- Created	18-Jun-85 14:34:15	by: AMR<<	Copyright (C) 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig ],  Inline	        USING [ LowHalf, LowByte ],  OfflineDiagInterface  USING [ AbortCurrentTest, AnOptionLine, ARow,				DisplayFixedPositionData,			        FixedPositionDisplayRecord, 			        GetAFixedPositionDisplayRecord, GetAnOption, 				GetAnOptionLine, GetAnOptionsRecord,				GetANumber, GetARow, GetYesNo,				OfflineDiagnosticProc, OptionsRecord, 				PutMessage],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, statusPtr],  SysConfigChannelDefs  USING [ eePromImage];    SysConfigBootDeviceImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureBootDevice:  --******************************************************************************ConfigureBoot: PUBLIC  Odi.OfflineDiagnosticProc =  BEGIN    -- VMM    BootTypes: TYPE = {none, rigidDisk, floppyDisk, ethernet, newBootType};    numberBootTypes: CARDINAL = ORD[LAST[BootTypes]]+1;  bootTypeOptionTable: LONG POINTER TO Odi.OptionsRecord _      Odi.GetAnOptionsRecord [2];  -- Just one row of option here  bootOptionRow0: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [3];  bootOptionRow1: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [numberBootTypes-3+1]; -- Extra option is for EXIT    bootInformation: LONG POINTER TO Odi.FixedPositionDisplayRecord _      Odi.GetAFixedPositionDisplayRecord [6];  -- 1 2-itemed row of data    bootInfoRow0: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row  bootInfoRow1: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row  bootInfoRow2: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row  bootInfoRow3: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row  bootInfoRow4: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row  bootInfoRow5: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row    leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 3;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  bootTypeSelected: CARDINAL;  -- The option selected by the user  initialEntry: BOOLEAN _ TRUE;  -- Now construct the boot option table  --  bootTypeOptionTable.optionMenuTiTle _ msgKey[bootChoices];  bootTypeOptionTable.linesOfOptions[0] _ bootOptionRow0;  bootTypeOptionTable.linesOfOptions[1] _ bootOptionRow1;    bootOptionRow0.optionsOnALine[0].position _ leftEdge;  bootOptionRow0.optionsOnALine[0].selectionNumberForThisItem _ 1;  bootOptionRow0.optionsOnALine[0].option _ msgKey[none];  -- %Change    xPosition _ leftEdge + msgKey[ethernet].length + 8;  bootOptionRow0.optionsOnALine[1].position _ xPosition;  bootOptionRow0.optionsOnALine[1].selectionNumberForThisItem _ 2;  bootOptionRow0.optionsOnALine[1].option _ msgKey[rigidDisk];  -- %Change    xPosition _ xPosition + msgKey[newBootDevice].length + 8;  bootOptionRow0.optionsOnALine[2].position _ xPosition;  bootOptionRow0.optionsOnALine[2].selectionNumberForThisItem _ 3;  bootOptionRow0.optionsOnALine[2].option _ msgKey[floppyDisk];  -- %Change    bootOptionRow1.optionsOnALine[0].position _ leftEdge;  bootOptionRow1.optionsOnALine[0].selectionNumberForThisItem _ 4;  bootOptionRow1.optionsOnALine[0].option _ msgKey[ethernet];  -- %Change    xPosition _ leftEdge + msgKey[ethernet].length + 8;  bootOptionRow1.optionsOnALine[1].position _ xPosition;  bootOptionRow1.optionsOnALine[1].selectionNumberForThisItem _ 5;  bootOptionRow1.optionsOnALine[1].option _ msgKey[newBootDevice];  -- %Change    xPosition _ xPosition + msgKey[newBootDevice].length + 8;  -- %Change  bootOptionRow1.optionsOnALine[2].position _ xPosition;  bootOptionRow1.optionsOnALine[2].selectionNumberForThisItem _ 6;  bootOptionRow1.optionsOnALine[2].option _ msgKey[exitSelection];    -- Now fill in the static fields of the display record  bootInformation.displayTitle _ msgKey[bootParameters];  bootInformation.rows[0] _ bootInfoRow0;  bootInformation.rows[1] _ bootInfoRow1;  bootInformation.rows[2] _ bootInfoRow2;  bootInformation.rows[3] _ bootInfoRow3;  bootInformation.rows[4] _ bootInfoRow4;  bootInformation.rows[5] _ bootInfoRow5;  --  -- Fill in first row static data  bootInfoRow0.rowItems[0].namePosition _ leftEdge;  -- Name position  bootInfoRow0.rowItems[0].name _ msgKey[defaultBootDevice];    bootInfoRow1.rowItems[0].namePosition _ leftEdge;  -- Name position  bootInfoRow1.rowItems[0].name _ msgKey[displayicon];  bootInfoRow1.rowItems[0].valuePosition _ noNumericData;       bootInfoRow2.rowItems[0].namePosition _ leftEdge;  -- Name position  bootInfoRow2.rowItems[0].name _ msgKey[displayrigid];  bootInfoRow2.rowItems[0].valuePosition _ noNumericData;    bootInfoRow3.rowItems[0].namePosition _ leftEdge;  -- Name position  bootInfoRow3.rowItems[0].name _ msgKey[displayfloppy];  bootInfoRow3.rowItems[0].valuePosition _ noNumericData;       bootInfoRow4.rowItems[0].namePosition _ leftEdge;  -- Name position  bootInfoRow4.rowItems[0].name _ msgKey[displayethernet];  bootInfoRow4.rowItems[0].valuePosition _ noNumericData;    bootInfoRow5.rowItems[0].namePosition _ leftEdge;  -- Name position  bootInfoRow5.rowItems[0].name _ msgKey[displayrs232C];  bootInfoRow5.rowItems[0].valuePosition _ noNumericData;  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN _ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue _ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until exit is requested      bootInfoRow0.rowItems[0].valuePosition _ noNumericData;        IF initialEntry THEN {      bootInfoRow0.rowItems[0].stringValue _ SELECT eePromImage.BootDevice FROM  						none => msgKey[none],						rigidDisk => msgKey[rigidDisk],						floppyDisk => msgKey[floppyDisk],						ethernet => msgKey[ethernet]						ENDCASE  => msgKey[unknown];      bootInfoRow1.rowItems[0].stringValue _ SELECT eePromImage.DefaultIcons FROM  						normal => msgKey[present]						ENDCASE  => msgKey[notPresent];      bootInfoRow2.rowItems[0].stringValue _ SELECT eePromImage.RigidBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];      bootInfoRow3.rowItems[0].stringValue _ SELECT eePromImage.FloppyBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];      bootInfoRow4.rowItems[0].stringValue _ SELECT eePromImage.EthrenetBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];      bootInfoRow5.rowItems[0].stringValue _ SELECT eePromImage.RS232CBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];      };   				        bootTypeSelected _ Odi.GetAnOption [  -- Always returns a valid option      optionTable: IF initialEntry THEN bootTypeOptionTable ELSE NIL,      optionPrompt: msgKey[enterDefaultBootDevice], defaultOption: 0]; -- Change boot device or Exit        IF bootTypeSelected = 6 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested        eePromImage.BootDevice _ SELECT bootTypeSelected FROM     	1 => none,	2 => rigidDisk,	3 => floppyDisk,	4 => ethernet	ENDCASE => eePromImage.BootDevice;    bootInfoRow0.rowItems[0].stringValue _ SELECT bootTypeSelected FROM     	1 => msgKey[none],	2 => msgKey[rigidDisk],	3 => msgKey[floppyDisk],	4 => msgKey[ethernet]	ENDCASE => msgKey[unknown];    IF bootTypeSelected = 5 THEN 	    {	    bootInfoRow0.rowItems[0].value _ LONG[LOOPHOLE[eePromImage.BootDevice]];	    Odi.DisplayFixedPositionData [displayData: bootInformation, upDateOnly: FALSE];  -- Update            bootInfoRow0.rowItems[0].value _ Odi.GetANumber [            prompt: msgKey[newBootDevice],	    lowLimit: 0,	    upperLimit: 0FFH,            numberIsLong: TRUE,            defaultNumber: bootInfoRow0.rowItems[0].value].longNumber;              eePromImage.BootDevice _	    LOOPHOLE[Inline.LowByte[Inline.LowHalf[bootInfoRow0.rowItems[0].value]]]; --New Boot value	    bootInfoRow0.rowItems[0].valuePosition _ leftEdge + msgKey[defaultBootDevice].length + aSpace;	    bootInfoRow0.rowItems[0].stringValue _ NIL;	    }        ELSE        Odi.DisplayFixedPositionData [displayData: bootInformation,     		upDateOnly: ~initialEntry];  -- Update    initialEntry _ FALSE;    [] _ Odi.GetAnOption [  -- Always returns a valid option      optionTable: IF initialEntry THEN bootTypeOptionTable ELSE NIL,      optionPrompt: msgKey[blanks],  justDisplayTable:TRUE, defaultOption: 0]; -- Change boot device or Exit        IF [] _ Odi.GetYesNo [prompt:msgKey[iconsSetting]] THEN eePromImage.DefaultIcons _ normal    						ELSE  eePromImage.DefaultIcons _ fast;    bootInfoRow1.rowItems[0].stringValue _ SELECT eePromImage.DefaultIcons FROM  						normal => msgKey[present]						ENDCASE  => msgKey[notPresent];	    Odi.DisplayFixedPositionData [displayData: bootInformation,upDateOnly: TRUE];  -- Update									    IF [] _ Odi.GetYesNo [prompt:msgKey[rigidBooting]] THEN eePromImage.RigidBooting _ allowed    						ELSE eePromImage.RigidBooting _ notAllowed;    bootInfoRow2.rowItems[0].stringValue _ SELECT eePromImage.RigidBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];				    Odi.DisplayFixedPositionData [displayData: bootInformation,upDateOnly: TRUE];  -- Update								    IF [] _ Odi.GetYesNo [prompt:msgKey[floppyBooting]] THEN eePromImage.FloppyBooting _ allowed    					       ELSE  eePromImage.FloppyBooting _ notAllowed;    bootInfoRow3.rowItems[0].stringValue _ SELECT eePromImage.FloppyBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];				    Odi.DisplayFixedPositionData [displayData: bootInformation,upDateOnly: TRUE];  -- Update       					           IF [] _ Odi.GetYesNo [prompt:msgKey[ethernetBooting]] THEN eePromImage.EthrenetBooting _ allowed    					       ELSE  eePromImage.EthrenetBooting _ notAllowed;					           bootInfoRow4.rowItems[0].stringValue _ SELECT eePromImage.EthrenetBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];				    Odi.DisplayFixedPositionData [displayData: bootInformation,upDateOnly: TRUE];  -- Update  						         IF [] _ Odi.GetYesNo [prompt:msgKey[rs232CBooting]] THEN eePromImage.RS232CBooting _ allowed    					       ELSE  eePromImage.RS232CBooting _ notAllowed;     bootInfoRow5.rowItems[0].stringValue _ SELECT eePromImage.RS232CBooting FROM  						notAllowed => msgKey[notAllowed]						ENDCASE  => msgKey[allowed];    Odi.DisplayFixedPositionData [displayData: bootInformation,upDateOnly: TRUE];  -- Update											       ENDLOOP; -- Outer loop    END; -- ConfigureBoot  END.logCreated on 18-Jun-85 14:34:15 by Allen Roberts
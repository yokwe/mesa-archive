-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- File: DiagRDLogImpl.mesa    - Last edited:-- STC, 29-Sep-88 11:05:16, Labelless conversion-- DIRECTORY CompatibilityDiskFace  USING	[Command, OperationPtr], DiagDiskCmdDrive	USING	[Cylinder, Head,				 Sector, SectorCount, Unit], DiagDiskMkIOCmd	USING	[mkIOCmd], DiagDiskMkMisc		USING	[mkMisc], DiagRDCmds		USING	[OpPtr, CmdTimeOut, TimesRetried], DiagRDDisplay		USING	[Status], DiagRDErrorCheck	USING	[ErrorCode, HardError, SoftError], DiagRDTestRec		USING	[SubTestBeingExecuted], DiskIOFaceDuke		USING	[IOCB], Inline			USING	[DBITSHIFT, HighHalf, LongCOPY, LowHalf], OfflineDiagInterface	USING	[AnOptionLine, GetAnOption, GetAnOptionLine,				 GetAnOptionsRecord, GetAHelpText,				 GetYesNo, HelpText, 				 PutData, PutMessage,				 OptionsRecord, ResultType],-- PilotDiskFace		USING	[Command, OperationPtr], String			USING	[AppendLongNumber, AppendNumber], DiagRDLog		USING	[]; DiagRDLogImpl: PROGRAM    IMPORTS	DiagDiskCmdDrive,	DiagRDCmds,	DiagDiskMkIOCmd,	DiagDiskMkMisc,	DiagRDDisplay,	DiagRDErrorCheck,	DiagRDTestRec,	Inline,	OfflineDiagInterface,	String    EXPORTS	DiagRDLog =BEGIN     OPEN	DiagDiskMkIOCmd,	DiagDiskMkMisc,	Odi: OfflineDiagInterface;	  LogError:			PUBLIC BOOLEAN		¬ FALSE; ErrLogPtr:			PUBLIC LONG POINTER TO ARRAY OF WORD; ErrLogLength:			PUBLIC CARDINAL		¬ 0; ErrLogEntrySize:		PUBLIC CARDINAL		¬ 32; ErrEntryOffset:		PUBLIC CARDINAL		¬ 0; ErrLogEntryCount:		PUBLIC LONG CARDINAL	¬ 0; ErrEntriesWrappedAround:	PUBLIC BOOLEAN		¬ FALSE; ErrCountWrappedAround:		PUBLIC BOOLEAN		¬ FALSE;  LogStep:			PUBLIC BOOLEAN		¬ FALSE; StepLogPtr:			PUBLIC LONG POINTER TO ARRAY OF WORD; StepEntrySize:			PUBLIC CARDINAL		¬ 32;  Trace:				PUBLIC BOOLEAN		¬ FALSE; TracePtr:			PUBLIC LONG POINTER TO ARRAY OF WORD; TraceLength:			PUBLIC CARDINAL		¬ 0; TraceEntrySize:		PUBLIC CARDINAL		¬ 32; TraceEntryOffset:		PUBLIC CARDINAL		¬ 0; TraceEntryCount:		PUBLIC LONG CARDINAL	¬ 0; TraceEntriesWrappedAround:	PUBLIC BOOLEAN		¬ FALSE; TraceCountWrappedAround:	PUBLIC BOOLEAN		¬ FALSE;  logDisplaySelection:	TYPE = {errorLog, traceTable, stepCommandLog}; ptrToEntry: 		CompatibilityDiskFace.OperationPtr;   -- contence of data being logged  -- loc   0  =	EntryCount		 1 word  -- loc 1~13 =	IOCB (1rst 13 words)	13 words  -- loc  14  =	Unit			 1 word  -- loc  15  =	Cylinder		 1 word  -- loc  16  =	Head			 1 word  -- loc  17  =	Sector			 1 word  -- loc  18  =	Sector Count		 1 word  -- loc  19  =	DataErrorType		 1 word  -- loc  20  =	RetryCount		 1 word  -- loc  21  =	CmdTimeOut		 1 word  --					~~~~~~~  --					22 words Total    -- loc  XX  =	RecalibrateFlag ????   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears the error log -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ClearLog: PUBLIC PROCEDURE = BEGIN wordptr: CARDINAL;  wordptr ¬ 0; UNTIL wordptr>= ErrLogLength DO 	ErrLogPtr­ [wordptr] ¬ 0; 	wordptr ¬ wordptr+ 1; ENDLOOP; ErrEntriesWrappedAround ¬ FALSE;  ErrCountWrappedAround ¬ FALSE;  ErrEntryOffset ¬ 0; ErrLogEntryCount ¬ 0; END; --ClearLog  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the error log data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayErrorLog: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] = BEGIN DisplayLog[emptyMsg:		 mkMisc[errLogIsEmpty],	    logToBeDisplayed:	 errorLog, 	    entriesWordOffset:	 ErrEntryOffset,	    entriesWrappedAround:ErrEntriesWrappedAround,	    entryCount:		 ErrLogEntryCount,	    entrySize:		 ErrLogEntrySize,	    logLength:		 ErrLogLength,	    logPtr:		 ErrLogPtr]; result¬ none; END;  --ErrorLog -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the error log data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayErrorLogInCmdFile: PUBLIC PROCEDURE = BEGIN result: Odi.ResultType; result¬ DisplayErrorLog[]; END; --ErrorLogInCmdFile  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the temporary log   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayTempLog: PUBLIC PROCEDURE= BEGIN DisplayLog[emptyMsg:		 NIL,	    logToBeDisplayed:	 stepCommandLog,	    entriesWordOffset:	 StepEntrySize,	    entriesWrappedAround:FALSE,	    entryCount:		 1,	    entrySize:		 StepEntrySize,	    logLength:		 256,	    logPtr:		 StepLogPtr]; END;  --DisplayTempLog  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to display the trace table   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayTrace: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] = BEGIN DisplayLog[emptyMsg:		 mkMisc[traceTableEmpty],	    logToBeDisplayed:	 traceTable, 	    entriesWordOffset:	 TraceEntryOffset, 	    entriesWrappedAround:TraceEntriesWrappedAround, 	    entryCount:		 TraceEntryCount, 	    entrySize:		 TraceEntrySize, 	    logLength:		 TraceLength, 	    logPtr:		 TracePtr]; result¬ none; END;  --DisplayTrace -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the error log data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayTraceInCmdFile: PUBLIC PROCEDURE = BEGIN result: Odi.ResultType; result¬ DisplayTrace[]; END; --DisplayTraceInCmdFile -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the trace log  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayLog: PROCEDURE [emptyMsg:		LONG STRING ¬ NIL,			logToBeDisplayed:	logDisplaySelection,			entriesWordOffset: 	CARDINAL,			entriesWrappedAround:	BOOLEAN,			entryCount:		LONG CARDINAL,			entrySize:		CARDINAL,			logLength:		CARDINAL,			logPtr:			LONG POINTER TO ARRAY OF WORD] = BEGIN -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayEntry: PROCEDURE = BEGIN a:		CARDINAL; b:		CARDINAL; c:		CARDINAL; cmd:		CompatibilityDiskFace.Command; err:		BOOLEAN¬ FALSE; lc:		LONG CARDINAL; myp:		LONG POINTER TO ARRAY OF WORD ¬ LOOPHOLE[ptrToEntry]; string:	STRING ¬ [8]; t:		BOOLEAN; --get entry number or command display IF logToBeDisplayed= stepCommandLog THEN   Odi.PutData[data: mkIOCmd[command], clearHeadingAndData: TRUE] ELSE { lc¬ myp­[24];   lc¬ Inline.DBITSHIFT[lc, 16];   lc¬ lc+ myp­[23];   Odi.PutData[data: mkMisc[entryNumber], clearHeadingAndData: TRUE];   string.length ¬ 0;   String.AppendLongNumber[string, lc, 10];   Odi.PutData[data: string]; }; --get unit selected c ¬ myp­[13]; IF c# 0 THEN { Odi.PutData[data: mkIOCmd[testNumber],		startWithNewLine: TRUE];   string.length ¬ 0;   String.AppendNumber[string, c, 10];   Odi.PutData[data: string]; }; --get unit selected c ¬ myp­[14]; Odi.PutData[data: mkIOCmd[unitSelected],		startWithNewLine: TRUE]; string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string]; cmd ¬ ptrToEntry­.command; Odi.PutData[data: mkIOCmd[commandExecuted],		startWithNewLine: TRUE]; SELECT cmd.header FROM	noOp =>		Odi.PutData[data: mkIOCmd[noOpHeader]];	read =>		Odi.PutData[data: mkIOCmd[readHeader]];	write =>	Odi.PutData[data: mkIOCmd[writeHeader]];	verify =>	Odi.PutData[data: mkIOCmd[verifyHeader]]; ENDCASE; SELECT cmd.label FROM	noOp =>		Odi.PutData[data: mkIOCmd[noOpLabel]];	read =>	 	Odi.PutData[data: mkIOCmd[readLabel]];	write =>	Odi.PutData[data: mkIOCmd[writeLabel]];	verify =>	Odi.PutData[data: mkIOCmd[verifyLabel]]; ENDCASE; SELECT cmd.data FROM	noOp =>		Odi.PutData[data: mkIOCmd[noOpData]];	read =>		Odi.PutData[data: mkIOCmd[readData]];	write =>	Odi.PutData[data: mkIOCmd[writeData]];	verify =>	Odi.PutData[data: mkIOCmd[verifyData]]; ENDCASE; --get given parameters Odi.PutData[data: mkIOCmd[givenParams],		startWithNewLine: TRUE];		-- put cylinder c ¬ myp­[15]; Odi.PutData[data: mkIOCmd[cylinder],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string];  -- put head c ¬ myp­[16]; Odi.PutData[data: mkIOCmd[head],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string];  -- put sector c ¬ myp­[17]; Odi.PutData[data: mkIOCmd[sector],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string];  -- put sector count c ¬ myp­[18]; Odi.PutData[data: mkIOCmd[sectorCnt],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string];  --get returned parameters a ¬ ptrToEntry­.clientHeader.cylinder; b ¬ ptrToEntry­.clientHeader.head; c ¬ ptrToEntry­.clientHeader.sector; Odi.PutData[data: mkIOCmd[returnedParams],		startWithNewLine: TRUE];-- put cylinder Odi.PutData[data: mkIOCmd[cylinder],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, a, 10]; Odi.PutData[data: string];  -- put head Odi.PutData[data: mkIOCmd[head],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, b, 10]; Odi.PutData[data: string]; -- put sector Odi.PutData[data: mkIOCmd[sector],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string];  -- put sector count c ¬ ptrToEntry­.pageCount; Odi.PutData[data: mkIOCmd[remainingSectorCnt],		blankSpaces: 4];    string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string]; --get use same data buffer boolean (8) t ¬ ptrToEntry­.incrementDataPtr; Odi.PutData[data: mkIOCmd[useSameDataBuff],		startWithNewLine: TRUE]; IF t THEN Odi.PutData[data: mkMisc[falsE]] ELSE   Odi.PutData[data: mkMisc[truE]];  --get header data (7) IF cmd.header = read THEN { Odi.PutData[data: mkIOCmd[readHeaderData],		  startWithNewLine: TRUE];   a ¬ ptrToEntry­.diskHeader.cylinder;   b ¬ ptrToEntry­.diskHeader.head;   c ¬ ptrToEntry­.diskHeader.sector;   -- put cylinder   Odi.PutData[data: mkIOCmd[cylinder],		blankSpaces: 4];      string.length ¬ 0;   String.AppendNumber[string, a, 10];   Odi.PutData[data: string];    -- put head   Odi.PutData[data: mkIOCmd[head],		blankSpaces: 4];      string.length ¬ 0;   String.AppendNumber[string, b, 10];   Odi.PutData[data: string];   -- put sector   Odi.PutData[data: mkIOCmd[sector],		blankSpaces: 4];      string.length ¬ 0;   String.AppendNumber[string, c, 10];   Odi.PutData[data: string]; }; --put requested tries/retries done  b ¬ myp­[20]; c ¬ ptrToEntry­.tries; Odi.PutData[data: mkIOCmd[requestedTries],		  startWithNewLine: TRUE]; string.length ¬ 0; String.AppendNumber[string, c, 10]; Odi.PutData[data: string]; Odi.PutData[data: mkIOCmd[retriesDone],		blankSpaces: 12];    string.length ¬ 0; String.AppendNumber[string, b, 10]; Odi.PutData[data: string]; --data compare error display c ¬ myp­[19]; SELECT c FROM   1 => { Odi.PutData[data: mkIOCmd[headerDataErr],		      startWithNewLine: TRUE];	  err¬ TRUE;	};   2 => { Odi.PutData[data: mkIOCmd[labelDataErr],		      startWithNewLine: TRUE];	  err¬ TRUE;	};   3 => { Odi.PutData[data: mkIOCmd[dataErrDetected],		      startWithNewLine: TRUE];	  err¬ TRUE;	};   4 => { Odi.PutData[data: mkIOCmd[dataErrDetected],		      startWithNewLine: TRUE];	  err¬ TRUE;	};   5 => { Odi.PutData[data: mkIOCmd[softErrDetected],		      startWithNewLine: TRUE];	  err¬ TRUE;	 };   6 => { Odi.PutData[data: mkIOCmd[hardErrDetected],		      startWithNewLine: TRUE];	  err¬ TRUE;	 }; ENDCASE; IF err THEN { Odi.PutData[data: mkIOCmd[errCode], startWithNewLine: TRUE];   c ¬ myp­[22];   string.length ¬ 0;   String.AppendNumber[string, c, 10];   Odi.PutData[data: string]; }; -- put command timed out c ¬ myp­[21]; IF c = 1 THEN Odi.PutData[data: mkIOCmd[commandTimedOut],		startWithNewLine: TRUE]; t¬ FALSE; IF t¬ Odi.GetYesNo[prompt: mkMisc[moreYN]] THEN   DiagRDDisplay.Status[op: ptrToEntry,   	  useLoggedStatus: TRUE]; END; --DisplayEntry -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClrMsgAndDataArea: PROCEDURE = { Odi.PutMessage[clearMessageAreaFirst: TRUE];   Odi.PutData[clearHeadingAndData: TRUE]; }; --ClrMsgAndDataArea -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ entryIAmAt:	CARDINAL; exit:		BOOLEAN; firstEntry:	CARDINAL; lastEntry:	CARDINAL; maxEntries:	CARDINAL; maxPtr:	CompatibilityDiskFace.OperationPtr; minPtr:	CompatibilityDiskFace.OperationPtr; num:		CARDINAL; helpTextPtr:	LONG POINTER TO Odi.HelpText;   cmdRcrdPtr:	LONG POINTER TO Odi.OptionsRecord; opLPtr:	LONG POINTER TO Odi.AnOptionLine; IF NOT entriesWrappedAround AND entriesWordOffset = 0 THEN { Odi.PutMessage[message: emptyMsg,		  beep: TRUE,		  clearMessageAreaFirst: TRUE];   RETURN };  cmdRcrdPtr¬  Odi.GetAnOptionsRecord[numberOfLines: 6];  opLPtr ¬ Odi.GetAnOptionLine [optionsPerLine: 1]; cmdRcrdPtr.linesOfOptions[0] ¬ opLPtr;  opLPtr.optionsOnALine[0].position¬ 5; opLPtr.optionsOnALine[0].selectionNumberForThisItem¬ 1; opLPtr.optionsOnALine[0].option¬ mkMisc[earlierEntry]; opLPtr.optionsOnALine[0].helpForThisOption¬ mkMisc[earlierEntryExpl]; opLPtr ¬ Odi.GetAnOptionLine [optionsPerLine: 1]; cmdRcrdPtr.linesOfOptions[1] ¬ opLPtr;  opLPtr.optionsOnALine[0].position ¬ 5; opLPtr.optionsOnALine[0].selectionNumberForThisItem ¬ 2; opLPtr.optionsOnALine[0].option¬ mkMisc[laterEntry]; opLPtr.optionsOnALine[0].helpForThisOption¬ mkMisc[laterEntryExpl]; opLPtr ¬ Odi.GetAnOptionLine [optionsPerLine: 1]; cmdRcrdPtr.linesOfOptions[2] ¬ opLPtr;  opLPtr.optionsOnALine[0].position ¬ 5; opLPtr.optionsOnALine[0].selectionNumberForThisItem ¬ 3; opLPtr.optionsOnALine[0].option¬ mkMisc[sameEntry]; opLPtr.optionsOnALine[0].helpForThisOption¬ mkMisc[sameEntryExpl]; opLPtr ¬ Odi.GetAnOptionLine [optionsPerLine: 1]; cmdRcrdPtr.linesOfOptions[3] ¬ opLPtr;  opLPtr.optionsOnALine[0].position ¬ 5; opLPtr.optionsOnALine[0].selectionNumberForThisItem ¬ 4; opLPtr.optionsOnALine[0].option¬ mkMisc[firstEntry]; opLPtr.optionsOnALine[0].helpForThisOption¬ mkMisc[firstEntryExpl]; opLPtr ¬ Odi.GetAnOptionLine [optionsPerLine: 1]; cmdRcrdPtr.linesOfOptions[4] ¬ opLPtr;  opLPtr.optionsOnALine[0].position ¬ 5; opLPtr.optionsOnALine[0].selectionNumberForThisItem ¬ 5; opLPtr.optionsOnALine[0].option¬ mkMisc[lastEntry]; opLPtr.optionsOnALine[0].helpForThisOption¬ mkMisc[lastEntryExpl]; opLPtr ¬ Odi.GetAnOptionLine [optionsPerLine: 1]; cmdRcrdPtr.linesOfOptions[5] ¬ opLPtr;  opLPtr.optionsOnALine[0].position ¬ 5; opLPtr.optionsOnALine[0].selectionNumberForThisItem ¬ 6; opLPtr.optionsOnALine[0].option¬ mkMisc[exit]; opLPtr.optionsOnALine[0].helpForThisOption¬ mkMisc[exitExpl];       helpTextPtr¬ Odi.GetAHelpText[numberOfLines: 1]; helpTextPtr.textBody[0]¬ mkMisc[enterCoiceInQuestion]; ptrToEntry ¬ LOOPHOLE[logPtr]; IF entriesWrappedAround THEN maxEntries ¬ (logLength/entrySize)   ELSE maxEntries ¬ (entriesWordOffset/entrySize); IF entriesWordOffset = 0 THEN {  --ie wrapped around   lastEntry ¬ entryIAmAt ¬ maxEntries; firstEntry ¬ 1; } ELSE { lastEntry ¬ entryIAmAt ¬ (entriesWordOffset/entrySize);   IF NOT entriesWrappedAround THEN firstEntry ¬ 1 ELSE     firstEntry ¬ lastEntry + 1; }; minPtr ¬ ptrToEntry; maxPtr ¬ ptrToEntry + ((maxEntries - 1)*entrySize); -- go to and display last entry ptrToEntry ¬ minPtr + ((entryIAmAt - 1)*entrySize); IF logToBeDisplayed= stepCommandLog THEN { DisplayEntry[];   RETURN; }; exit ¬ FALSE; UNTIL exit DO   num ¬ Odi.GetAnOption [optionTable: cmdRcrdPtr,    			  optionPrompt: mkMisc[enterChoiceNum],			  optionHelp: helpTextPtr];   SELECT num FROM   1 => { ClrMsgAndDataArea[];          IF entryIAmAt = firstEntry THEN	    Odi.PutMessage[message: mkMisc[noEarlierEntries]] ELSE            IF entryIAmAt = 1 THEN	    { ptrToEntry ¬ maxPtr; entryIAmAt ¬ maxEntries; DisplayEntry[]	    } ELSE	    { ptrToEntry ¬ ptrToEntry - entrySize;	      entryIAmAt ¬ entryIAmAt - 1;	      DisplayEntry[]	    }	};   2 => { ClrMsgAndDataArea[];          IF entryIAmAt = lastEntry THEN 	    Odi.PutMessage[message: mkMisc[noLaterEntries]] ELSE	    IF entryIAmAt = maxEntries THEN	    { ptrToEntry ¬ minPtr; entryIAmAt ¬ 1; DisplayEntry[]	    } ELSE	    { ptrToEntry ¬ ptrToEntry + entrySize;	      entryIAmAt ¬ entryIAmAt + 1;	      DisplayEntry[]	    }	};   3 => { ClrMsgAndDataArea[];          DisplayEntry[];	};   4 => { ClrMsgAndDataArea[];          entryIAmAt ¬ firstEntry;	  ptrToEntry ¬ minPtr + ((entryIAmAt - 1)*entrySize);	  DisplayEntry[]	};   5 => { ClrMsgAndDataArea[];          entryIAmAt ¬ lastEntry;	  ptrToEntry ¬ minPtr + ((entryIAmAt - 1)*entrySize);	  DisplayEntry[]	};   6 => RETURN;   ENDCASE;   cmdRcrdPtr¬ NIL; ENDLOOP; END;  --DisplayLog  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- clears the Trace table  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   ClearTrace: PUBLIC PROCEDURE =  BEGIN  wordptr: CARDINAL ¬ 0;   UNTIL wordptr>= TraceLength DO    TracePtr­ [wordptr] ¬ 0;    wordptr ¬ wordptr+ 1;  ENDLOOP;  TraceEntriesWrappedAround ¬ FALSE;   TraceCountWrappedAround ¬ FALSE;   TraceEntryOffset ¬ 0;  TraceEntryCount ¬ 0;  END; --ClearTrace   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set log error boolean -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LogErrors: PUBLIC PROCEDURE  = BEGIN LogError¬ TRUE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to log 25 words of command data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LogEvent: PUBLIC PROCEDURE [			hardwareError:		BOOLEAN ¬ FALSE,			headerError:		BOOLEAN ¬ FALSE,			labelError:		BOOLEAN ¬ FALSE,			dataError:		BOOLEAN ¬ FALSE,			diagDataError:		BOOLEAN ¬ FALSE] = BEGIN tempLogLength:			CARDINAL	¬ 256; tempLogOffset:			CARDINAL	¬ 0; tempLogCount:			LONG CARDINAL	¬ 0; tempWrappedAround:		BOOLEAN		¬ FALSE; tempCountWrappedAround:	BOOLEAN		¬ FALSE;   IF LogStep THEN   Log	[headerError:		headerError,	 labelError:		labelError,	 dataError:		dataError,	 diagDataError:		diagDataError,	 pointer:		StepLogPtr,	 length:		@tempLogLength,	 entrySize:		@StepEntrySize,	 offset:		@tempLogOffset,	 entryCount:		@tempLogCount,	 wrappedAround:		@tempWrappedAround,	 countWrappedAround:	@tempCountWrappedAround]; IF LogError AND hardwareError THEN   Log	[headerError:		headerError,	 labelError:		labelError,	 dataError:		dataError,	 diagDataError:		diagDataError,	 pointer:		ErrLogPtr,	 length:		@ErrLogLength,	 entrySize:		@ErrLogEntrySize,	 offset:		@ErrEntryOffset,	 entryCount:		@ErrLogEntryCount,	 wrappedAround:		@ErrEntriesWrappedAround,	 countWrappedAround:	@ErrCountWrappedAround]; IF Trace THEN   Log	[headerError:		headerError,	 labelError:		labelError,	 dataError:		dataError,	 diagDataError:		diagDataError,	 pointer:		TracePtr,	 length:		@TraceLength,	 entrySize:		@TraceEntrySize,	 offset:		@TraceEntryOffset,	 entryCount:		@TraceEntryCount,	 wrappedAround:		@TraceEntriesWrappedAround,	 countWrappedAround:	@TraceCountWrappedAround];	  END; --	   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to log 25 words of data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Log: PROCEDURE [headerError:		BOOLEAN,		 labelError:		BOOLEAN,		 dataError:		BOOLEAN,		 diagDataError:		BOOLEAN,		 pointer:		LONG POINTER TO ARRAY OF WORD,		 length:		LONG POINTER TO CARDINAL,		 entrySize:		POINTER TO CARDINAL,		 offset:		POINTER TO CARDINAL,		 entryCount:		POINTER TO LONG CARDINAL,		 wrappedAround:		POINTER TO BOOLEAN,		 countWrappedAround:	POINTER TO BOOLEAN]	 = BEGIN IOCBPtr:	LONG POINTER TO DiskIOFaceDuke.IOCB¬ LOOPHOLE[DiagRDCmds.OpPtr]; count:		CARDINAL ¬ 0; -- location 0-12 (IOCB) Inline.LongCOPY [	from: DiagRDCmds.OpPtr,	nwords: 13,	to: pointer+ offset­]; offset­ ¬ offset­+ 13; -- location 13 = subtest being executed pointer­ [offset­] ¬ ORD[DiagRDTestRec.SubTestBeingExecuted]; offset­ ¬ offset­+ 1; -- location 14 (unit) pointer­ [offset­] ¬ DiagDiskCmdDrive.Unit; offset­ ¬ offset­+ 1;   -- location 15 pointer­ [offset­] ¬ DiagDiskCmdDrive.Cylinder; offset­ ¬ offset­+ 1; -- location 16 pointer­ [offset­] ¬ DiagDiskCmdDrive.Head; offset­ ¬ offset­+ 1;  -- location 17 pointer­ [offset­] ¬ DiagDiskCmdDrive.Sector; offset­ ¬ offset­+ 1; -- 18th location pointer­ [offset­] ¬ DiagDiskCmdDrive.SectorCount; offset­ ¬ offset­+ 1;   -- 19th location IF headerError THEN pointer­ [offset­] ¬ 1 ELSE   IF labelError THEN pointer­ [offset­] ¬ 2 ELSE     IF dataError THEN pointer­ [offset­] ¬ 3 ELSE       IF diagDataError THEN pointer­ [offset­] ¬ 4 ELSE         IF DiagRDErrorCheck.SoftError THEN pointer­ [offset­] ¬ 5 ELSE           IF DiagRDErrorCheck.HardError THEN pointer­ [offset­] ¬ 6 ELSE	     pointer­ [offset­] ¬ 0; offset­ ¬ offset­+ 1;   -- 20th location  pointer­ [offset­] ¬ DiagRDCmds.TimesRetried;  offset­ ¬ offset­+ 1;   -- 21th location (remember command timed out)  IF DiagRDCmds.CmdTimeOut THEN pointer­ [offset­] ¬ 1 ELSE    pointer­ [offset­] ¬ 0;  offset­ ¬ offset­+ 1;   --22th location = the error code and if no error the last status checked pointer­ [offset­] ¬ DiagRDErrorCheck.ErrorCode; offset­ ¬ offset­+ 1;  -- 23 & 24th location = entry count entryCount­ ¬ entryCount­+ 1; pointer­ [offset­] ¬ Inline.LowHalf[entryCount­]; offset­ ¬ offset­+ 1; pointer­ [offset­] ¬ Inline.HighHalf[entryCount­]; offset­ ¬ offset­+ 1; -- 25th location = headerError status pointer­ [offset­] ¬ LOOPHOLE[IOCBPtr.dob.headerError]; offset­ ¬ offset­+ 1; -- 26th location = labelError status pointer­ [offset­] ¬ LOOPHOLE[IOCBPtr.dob.labelError]; offset­ ¬ offset­+ 1; -- 27th location = dataError status pointer­ [offset­] ¬ LOOPHOLE[IOCBPtr.dob.dataError]; offset­ ¬ offset­+ 1; -- 28th location = lastError status pointer­ [offset­] ¬ LOOPHOLE[IOCBPtr.dob.lastError]; offset­ ¬ offset­+ 1; -- 29 th location = driveAndControllerStatus status pointer­ [offset­] ¬ LOOPHOLE[IOCBPtr.dob.driveAndControllerStatus]; offset­ ¬ offset­+ 3; --point to next entry  IF length­< offset­+ entrySize­ THEN { offset­ ¬ 0;   wrappedAround­ ¬ TRUE }; IF entryCount­= 177777B THEN countWrappedAround­ ¬ TRUE;  END; --EnterInTrace  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set log error boolean -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  StopLoggingErrors: PUBLIC PROCEDURE  = BEGIN LogError¬ FALSE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set log error boolean -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  StopTracingCommands: PUBLIC PROCEDURE  = BEGIN Trace¬ FALSE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to trace commands -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  TraceCommands: PUBLIC PROCEDURE = BEGIN Trace¬ TRUE; END; END...--of DiagRDLogImpl.mesaLOG22-Mar-87  9:17:11 by STC, make DisplayLog.emptyMsg LONG19-Sep-88 16:58:47, STC, Labelless, DiskIOFaceDove ¬ DiskIOFaceDuke 
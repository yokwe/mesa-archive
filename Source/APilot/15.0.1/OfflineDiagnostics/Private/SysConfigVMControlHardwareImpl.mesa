-- File SysConfigVMControlHardwareImpl.mesa	-Last edited:-- STC,  2-Oct-88 23:12:45, Labelless-- 29-Jan-87 10:41:06	RDM Add EEprom error message.--  1-Oct-85 15:06:00	by: AMR-- Created	18-Jun-85 14:42:47	by: AMR<<	Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs	        USING [ EEpromConfig ],  Inline	        USING [ LowByte ],  OfflineDiagInterface  USING [ OfflineDiagnosticProc,  				AbortCurrentTest, ARow,				OptionsRecord, AnOptionLine, GetAnOptionsRecord,				GetAnOptionLine, GetAnOption,				GetAFixedPositionDisplayRecord, GetARow,			        FixedPositionDisplayRecord, GetYesNo,				DisplayFixedPositionData, PutMessage],  ProcessorFaceExtras2	USING [DoveMachineType, DoveMachineTypeInfo],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, msgKey2, statusPtr],  SysConfigChannelDefs  USING [ eePromImage];    SysConfigVMControlHardwareImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, ProcessorFaceExtras2,	SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- SysConfigVMControlStoreImpl:--******************************************************************************ConfigureVMControlHardwareVersion: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    types: TYPE = {vm, controlStore};  vmSize: TYPE = {vm8MB, vm16MB, vm32MB};  controlSize:TYPE = {control4K, control8K, control16K};  machineType: ProcessorFaceExtras2.DoveMachineType _ ProcessorFaceExtras2.DoveMachineTypeInfo[];  --  numberOfTypes: CARDINAL = ORD[LAST[types]] + 1;  selectionOptionTable: LONG POINTER TO Odi.OptionsRecord _      Odi.GetAnOptionsRecord [2];  -- Just one row of option here  optionRow0: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [2];  optionRow1: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [numberOfTypes - 2 + 1];    numberOfvmSize: CARDINAL = ORD[LAST[vmSize]] + 1;  vmOptionTable: LONG POINTER TO Odi.OptionsRecord _      Odi.GetAnOptionsRecord [1];  -- Just one row of option here  vmOptionRow0: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [numberOfvmSize];       numberOfControl: CARDINAL = ORD[LAST[controlSize]] + 1;    controlOptionTable: LONG POINTER TO Odi.OptionsRecord _      Odi.GetAnOptionsRecord [1];  -- Just one row of option here  controlOptionRow0: LONG POINTER TO Odi.AnOptionLine _      Odi.GetAnOptionLine [       SELECT machineType FROM         duke => numberOfControl,	 ENDCASE => numberOfControl - 1];     -- VM ControlStore    leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 12;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line  selected: CARDINAL;  -- The option selected by the user  vmSelected: CARDINAL;   controlSelected: CARDINAL;   toggle:  {selection, hardware} _ hardware;  initialEntry: BOOLEAN _ TRUE;    information: LONG POINTER TO Odi.FixedPositionDisplayRecord _      Odi.GetAFixedPositionDisplayRecord [2];  -- 1 double-itemed row of data    infoRow0: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row  infoRow1: LONG POINTER TO Odi.ARow _ Odi.GetARow [1];  -- 1 item on row     -- Now fill in the static fields of the display record    information.displayTitle _ msgKey[vmControlStore];  information.rows[0] _ infoRow0;  -- First row  information.rows[1] _ infoRow1;  -- First row    --  -- Fill in first row static data  infoRow0.rowItems[0].namePosition _ leftEdge;  -- Name position  infoRow0.rowItems[0].name _ msgKey[VMMSizeInPages];    infoRow0.rowItems[0].valuePosition _ noNumericData;      infoRow1.rowItems[0].namePosition _ leftEdge;  -- Name position  infoRow1.rowItems[0].name _ msgKey[controlStoreK];  infoRow1.rowItems[0].valuePosition _ noNumericData;      -- Now fill in the option table    selectionOptionTable.optionMenuTiTle _ msgKey[configVMControlStore];  selectionOptionTable.linesOfOptions[0] _ optionRow0; -- Save pointer to row  selectionOptionTable.linesOfOptions[1] _ optionRow1; -- Save pointer to row    optionRow0.optionsOnALine[0].position _ leftEdge;  optionRow0.optionsOnALine[0].selectionNumberForThisItem _ 1;  optionRow0.optionsOnALine[0].option _ msgKey[vmPages];  -- %Change    xPosition _ leftEdge + msgKey[vmPages].length + 8;  optionRow0.optionsOnALine[1].position _ xPosition;  optionRow0.optionsOnALine[1].selectionNumberForThisItem _ 2;  optionRow0.optionsOnALine[1].option _ msgKey[controlStore];  -- %Change    optionRow1.optionsOnALine[0].position _ leftEdge;  optionRow1.optionsOnALine[0].selectionNumberForThisItem _ 3;  optionRow1.optionsOnALine[0].option _ msgKey[returnToTopLevel];  -- %Change    vmOptionTable.linesOfOptions[0] _ vmOptionRow0; -- Save pointer to row  vmOptionTable.optionMenuTiTle _ msgKey[vmPages];    vmOptionRow0.optionsOnALine[0].position _ leftEdge;  vmOptionRow0.optionsOnALine[0].selectionNumberForThisItem _ 1;  vmOptionRow0.optionsOnALine[0].option _ msgKey[vm8mb];  -- %Change    xPosition _ leftEdge + msgKey[vm8mb].length + 8;  vmOptionRow0.optionsOnALine[1].position _ xPosition;  vmOptionRow0.optionsOnALine[1].selectionNumberForThisItem _ 2;  vmOptionRow0.optionsOnALine[1].option _ msgKey[vm16mb];  -- %Change    xPosition _ xPosition + msgKey[vm16mb].length + 8;  vmOptionRow0.optionsOnALine[2].position _ xPosition;  vmOptionRow0.optionsOnALine[2].selectionNumberForThisItem _ 3;  vmOptionRow0.optionsOnALine[2].option _ msgKey[vm32mb];  -- %Change       controlOptionTable.linesOfOptions[0] _ controlOptionRow0; -- Save pointer to row  controlOptionTable.optionMenuTiTle _ msgKey[controlStore];    controlOptionRow0.optionsOnALine[0].position _ leftEdge;  controlOptionRow0.optionsOnALine[0].selectionNumberForThisItem _ 1;  controlOptionRow0.optionsOnALine[0].option _ msgKey[control4k];  -- %Change    xPosition _ leftEdge + msgKey[control4k].length + 8;  controlOptionRow0.optionsOnALine[1].position _ xPosition;  controlOptionRow0.optionsOnALine[1].selectionNumberForThisItem _ 2;  controlOptionRow0.optionsOnALine[1].option _ msgKey[control8k];  -- %Change   xPosition _ xPosition + msgKey[control8k].length + 8;  IF machineType = duke THEN {    controlOptionRow0.optionsOnALine[2].position _ xPosition;    controlOptionRow0.optionsOnALine[2].selectionNumberForThisItem _ 3;    controlOptionRow0.optionsOnALine[2].option _ msgKey2[control16k] };  -- %Change   IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN _ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue _ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO  -- Loop until STOP or AbortCurrentTest {   infoRow0.rowItems[0].stringValue _ SELECT eePromImage.VMMSizeInPages FROM	     vm8mega => msgKey[vm8mb],	     vm16mega => msgKey[vm16mb],	     vm32mega => msgKey[vm32mb],	     ENDCASE => msgKey[unknown];	        infoRow1.rowItems[0].stringValue _  SELECT eePromImage.ControlStoreSize FROM	     cs4k => msgKey[control4k],	     cs8k => msgKey[control8k],	     cs16k => msgKey2[control16k],	     ENDCASE => msgKey[unknown];   initialEntry _ FALSE;   [] _ Odi.GetAnOption [  -- Always returns a valid option           optionTable: selectionOptionTable,           optionPrompt: msgKey[blanks], justDisplayTable:TRUE]; -- Change screen or Exit        Odi.DisplayFixedPositionData [  -- Display the drive information       displayData: information, upDateOnly: FALSE];        selected _ Odi.GetAnOption [  -- Always returns a valid option    optionTable: NIL,    optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit            IF selected = 3 THEN SIGNAL Odi.AbortCurrentTest;  -- Exit requested               SELECT selected FROM         -- Get virtual memory info    1 => { vmSelected _ Odi.GetAnOption [  -- Always returns a valid option          optionTable: vmOptionTable,              optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit	  infoRow0.rowItems[0].stringValue _ SELECT vmSelected FROM	     1 => msgKey[vm8mb],	     2 => msgKey[vm16mb],	     ENDCASE => msgKey[vm32mb];          eePromImage.VMMSizeInPages _ LOOPHOLE[Inline.LowByte[vmSelected]];};                     -- Get Control store info    2 => {controlSelected _ Odi.GetAnOption [  -- Always returns a valid option          optionTable: controlOptionTable,              optionPrompt: msgKey[respondToPrompt], defaultOption: 0]; -- Change screen or Exit	  infoRow1.rowItems[0].stringValue _  SELECT controlSelected FROM	  	     1 => msgKey[control4k],	     2 => msgKey[control8k],	     ENDCASE => msgKey2[control16k];--    	  eePromImage.ControlStoreSize _ LOOPHOLE[Inline.LowByte[controlSelected]];};        	  eePromImage.ControlStoreSize _ SELECT controlSelected FROM	     1 => cs4k,	     2 => cs8k,	     ENDCASE => cs16k;};                 ENDCASE;                     ENDLOOP;     END; -- ConfigureVMMEND.logCreated on 18-Jun-85 14:42:47 by Allen Roberts
-- Copyright (C) Xerox Corporation 1985, 1986, 1987, 1988. All rights reserved.-- File: DiskUtilityMiscImplDove.mesa	-Last edited:-- TXM,  8-Jun-89 11:46:03-- This module contains a collection of miscellaneous utilities used by -- OfflineDiskUtilitiesDove.DIRECTORY  CompatibilityDiskFace  USING [ Command, labelSize, Operation, OperationPtr,				 SetLabelFilePage, zeroLabel],  Device USING [Type],  OfflineDiagInterface   USING [ AbortCurrentTest, HitAnyKeyToContinue,  			         PutData, GetYesNo, HelpText, ARow, DiagHeap,				 LookForAbort, GetAString, abortSensed,				 FixedPositionDisplayRecord, GetSpace,				 GetAFixedPositionDisplayRecord, GetARow,				 PutMessage, GetANumber, userType,				 OfflineDiagnosticProc, ResultType],  DiskUtilityMiscDove    USING [ leftEdge, --subVolumeTable,  				 volumeInfoValid,  				 RamBadPageTable, SubVolumeTable, ASubVolume,				 Labels, DataPages, SaveOpStatus,				 op, dataPages, labels, labeledOp,				 SetDriveStateTo, 				 InitStarted, RigidDiskDiag, StartInit,				 currentBPTOnDisk, ValidateIDandCheckVirginity],  DiskUtilityMsgKeysDove USING [ duMessage],  PhysicalVolume         USING [ PageNumber, lastPageNumber,  				 nullDeviceIndex, nullID, Handle, ID,				 PageCount, GetHandle, InterpretHandle,				 FinishWithNonPilotVolume,				 GetNextDrive, maxSubvolumesOnPhysicalVolume,				 AssertPilotVolume, Error, maxNameLength,				 GetNext, GetAttributes, Offline, nullBadPage,				 GetNextBadPage, MarkPageBad,				 AssertNotAPilotVolume, NeedsScavenging],  PhysicalVolumeExtras   USING [ ErrorExtras, MarkDataLostPage],  PhysicalVolumeFormat	 USING [ Handle, Seal],  SpecialVolume       	 USING [ SubVolume, nullSubVolume, GetNextSubVolume,  				 SubVolumeUnknown],   PageScavenger       	 USING [ DiskStatus, Action, Error, Scavenge],  Volume	         USING [ GetLabelString, NeedsScavenging],  Inline	         USING [ LongDivMod],  Environment       	 USING [ Base, first64K, wordsPerPage],  Zone	         	 USING [ Status],  ResidentHeap       	 USING [ MakeNode],  File			 USING [ ID, PageNumber, Type],  PilotDiskFace          USING [ dataSize, DiskAddress, DeviceHandle,  				 GetNextDevice,				 GetDeviceAttributes, nullDeviceHandle, 				 Operation, Status],  FormatPilotDisk        USING [ DiskInfo, Scan, BadPage, RetryLimit],   DiskChannel	         USING [ DirectOperation, operationSize, IOStatus,   				 diskOpWordAlignment, DiskChannelPrivate,				 DoDirectIO, defaultTries, DriveState, Drive,				 nullDrive, GetNextDrive, GetDriveAttributes,				 SetDriveState, DriveStatus, goodCompletion],  Format		 USING [Date, HostNumber, StringProc],  Process		 USING [Ticks, Pause],  String		 USING [AppendChar, AppendDecimal, AppendLongDecimal,  				AppendLongNumber, AppendString,				StringBoundsFault],  SysConfigChannelDefs USING [eePromImage, Status, Initialize,  			      ReadEEPromImage],  System		 USING [HostNumber, localHostNumber],  Time			 USING [Current, Packed],  TTYPort		 USING [ChannelHandle, GetStatus, Delete, Create,   				NoTTYPortHardware, InvalidLineNumber, Put,				ChannelAlreadyExists, SetParameter,				TransferStatus],  TTYPortEnvironment	 USING [CharacterLength, LineSpeed, Parity, StopBits];DiskUtilityMiscImplDove: PROGRAM  IMPORTS CompatibilityDiskFace, OfflineDiagInterface, DiskUtilityMsgKeysDove,  	  String, ResidentHeap, Inline, DiskChannel, FormatPilotDisk,	  PilotDiskFace, PhysicalVolume, Volume, SpecialVolume, PageScavenger,	  DiskUtilityMiscDove, SysConfigChannelDefs, PhysicalVolumeExtras,	  Format, Process, System, Time, TTYPort  EXPORTS DiskUtilityMiscDove = BEGIN OPEN DiskUtilityMsgKeysDove,	   Odi: OfflineDiagInterface, PV: PhysicalVolume, 	   Misc: DiskUtilityMiscDove, FPD: FormatPilotDisk;-- Pointer to message file--  msgKey: LONG POINTER TO ARRAY DiskUtilityMsgKeysDove.DUMessages OF LONG STRING;  message: LONG STRING;  -- General purpose string  longestVolNameLength: CARDINAL¬ 10;   -- For positioning purposes, ¬ 10, STC  errorStatusPosition: CARDINAL;  -- Exported items  restoreStatusPosition: PUBLIC CARDINAL;  -- Position to print restore status  saveStatusPosition: PUBLIC CARDINAL;  -- Position to print save status    driveIndex: PUBLIC CARDINAL;  -- Index associated with a drive  drive: DiskChannel.Drive;  pvHandle: PUBLIC PhysicalVolume.Handle;  -- Handle for accessing the drive  pvID: PUBLIC PV.ID ¬ PV.nullID; -- System.UniversalID  deviceHandle: PUBLIC PilotDiskFace.DeviceHandle; -- Handle to the drive  changeCount: CARDINAL;  -- State changes associated with handle instance  oldState: DiskChannel.DriveState;  -- Original drive state  restoreOldState: BOOLEAN ¬ FALSE;    cylinders: PUBLIC CARDINAL;  -- Number of cylinders on the disk  movingHeads: PUBLIC CARDINAL;  -- Number of moving heads the disk has  fixedHeads: PUBLIC CARDINAL;  -- Number of fixed heads the disk has  sectorsPerTrack: PUBLIC CARDINAL;  -- The number of sectors on a track    firstPilotPage: PUBLIC PhysicalVolume.PageNumber;  totalPagesOnADisk: PUBLIC PhysicalVolume.PageCount; -- Total pages on the disk  pagesPerTrack: PUBLIC CARDINAL;  -- The number of pages on a track.  pagesPerCylinder: PUBLIC CARDINAL;  -- The number of pages per cylinder.  firstAllowableBP: PUBLIC CARDINAL;  -- The first page of cylinder 1.-- for DisplayBadPageTable and PrintBadPageTable, from OfflineDiskUtilitiesDove  nullResult: Odi.ResultType = none;-- Direct operations    saveData: CompatibilityDiskFace.Command = [verify, read, read];  restoreData: CompatibilityDiskFace.Command = [verify, write, write];  verifyData: CompatibilityDiskFace.Command = [verify, verify, verify];  formatTrack: CompatibilityDiskFace.Command = [write, write, write];  diskNoOp: CompatibilityDiskFace.Command = [verify, noOp, noOp];  -- ERRORs  ChangeCountMisMatch: ERROR = CODE;  IllegalDriveState: ERROR = CODE;  ImpossibleEndCase: ERROR = CODE;--******************************************************************************-- More to go or quit? Yes returns, no raises AbortCurrentTest--******************************************************************************NoQuitsYesReturns: PUBLIC PROCEDURE [prompt: LONG STRING, default: BOOLEAN] = {  IF Odi.GetYesNo[prompt,, TRUE, default] THEN RETURN      ELSE SIGNAL Odi.AbortCurrentTest };<<--******************************************************************************-- Allocates space for a disk operation and returns a pointer to the space for-- dealocation purposes. --******************************************************************************PrepareForDirectOperation: PUBLIC PROCEDURE RETURNS [                pOp: LONG POINTER TO DiskChannel.DirectOperation,              -- pOp will be aligned per requirements of DiskChannel.DoDirectIO              pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] =              -- pStorage should be used when freeing  BEGIN    rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;    status: Zone.Status;    residentHeapError: ERROR = CODE;    diskOpAlign: CARDINAL ¬ DiskChannel.diskOpWordAlignment;     [pStorage, status] ¬ ResidentHeap.MakeNode[      n: DiskChannel.operationSize + diskOpAlign - 1,      alignment: a1];    IF status ~= okay THEN ERROR residentHeapError;    rpDirOp ¬ pStorage;    pOp ¬ @Environment.first64K[rpDirOp];    pOp ¬ LOOPHOLE[((LOOPHOLE[pOp, LONG CARDINAL] +                     SIZE[DiskChannel.DiskChannelPrivate] + diskOpAlign - 1) / 		    diskOpAlign) * diskOpAlign - 		    SIZE[DiskChannel.DiskChannelPrivate]] }    END;  -- PrepareForDirectOperation>>--******************************************************************************-- Converts a physical disk address to a Pilot page number.--******************************************************************************ConvertDiskAddressToPage: PUBLIC PROCEDURE [         diskAddress: PilotDiskFace.DiskAddress] RETURNS [page: LONG CARDINAL] =   BEGIN    page ¬ diskAddress.cylinder*LONG[pagesPerCylinder] +            diskAddress.head*LONG[pagesPerTrack] + diskAddress.sector    END; -- ConvertDiskAddressToPage--******************************************************************************-- Converts a Pilot page to its physical address in cylinder, head and sector--******************************************************************************ConvertPageToDiskAddress: PUBLIC PROCEDURE [page: LONG CARDINAL]                          RETURNS [diskAddress: PilotDiskFace.DiskAddress] =  BEGIN    temp: CARDINAL;    -- First calculate the cylinder    [quotient: diskAddress.cylinder, remainder: temp] ¬        Inline.LongDivMod[num: page, den: pagesPerCylinder];       -- Now figure out the head and sector    diskAddress.sector ¬ temp MOD sectorsPerTrack;    diskAddress.head ¬ temp / sectorsPerTrack;    END;  -- ConvertPageToDiskAddress--******************************************************************************-- Print expanded heading for page information at top of Data Area--******************************************************************************PrintExpandedPageHeading: PUBLIC PROCEDURE			  [appendSaveStatus, appendRestoreStatus,			   appendErrorStatus: BOOLEAN] =  BEGIN    tempString: LONG STRING ¬ [110];    aSpace: LONG STRING = " ";  -- A blank    twoSpaces: LONG STRING = "  ";  -- 2 blanks    tenSpaces: LONG STRING = "          ";  -- 10 blanks    temp: CARDINAL;    tempString.length ¬ 0;    String.AppendString[tempString, duMessage[page]];    String.AppendString[tempString, twoSpaces];    String.AppendString[tempString, duMessage[cylinder]];    String.AppendString[tempString, twoSpaces];    String.AppendString[tempString, duMessage[head]];    String.AppendString[tempString, twoSpaces];    String.AppendString[tempString, duMessage[sector]];    String.AppendString[tempString, twoSpaces];    temp ¬ tempString.length;  -- V's position    String.AppendString[tempString, duMessage[volume]];        IF appendErrorStatus THEN {       IF longestVolNameLength < (duMessage[volume].length + 2) THEN { -- leave 2 sp          String.AppendString[tempString, twoSpaces];	  errorStatusPosition ¬ tempString.length}       ELSE {          temp ¬ (longestVolNameLength + 1) - duMessage[volume].length;          FOR i: CARDINAL IN [0..temp]  -- Leave 2 spaces             DO String.AppendString[tempString, aSpace] ENDLOOP;	  errorStatusPosition ¬ tempString.length};       String.AppendString[tempString, duMessage[errorStatus]] };    IF appendSaveStatus THEN {       String.AppendString[tempString, tenSpaces];       saveStatusPosition ¬ tempString.length;       String.AppendString[tempString, duMessage[saveStatus]] };        IF appendRestoreStatus THEN {       String.AppendString[tempString, tenSpaces];       restoreStatusPosition ¬ tempString.length;       String.AppendString[tempString, duMessage[restoreStatus]] };    Odi.PutData [dataAreaHeading: tempString, clearHeadingAndData: TRUE];    END;  -- PrintExpandedPageHeading--******************************************************************************-- Explode a Pilot page number into cylinder, head, sector and volume. Display -- it in Data Area below the heading printed by PrintExpandedPageHeading.--******************************************************************************ExpandPageNumber: PUBLIC PROCEDURE [pageToBeExpanded: PV.PageNumber,				    getStatus: BOOLEAN ¬ FALSE] =  BEGIN    page: PilotDiskFace.DiskAddress;    volume: LONG STRING ¬ NIL;    position: CARDINAL ¬ 1;    spacing: CARDINAL = 2;  -- = twoSpaces.length    errorStatus: LONG STRING;        page ¬ ConvertPageToDiskAddress[pageToBeExpanded];    Odi.PutData[numberAfterData: pageToBeExpanded, startWithNewLine: TRUE,    	        xPosition: position];    position ¬ position + duMessage[page].length + spacing;    Odi.PutData[numberAfterData: page.cylinder, xPosition: position];    position ¬ position + duMessage[cylinder].length + spacing;    Odi.PutData[numberAfterData: page.head, xPosition: position];    position ¬ position + duMessage[head].length + spacing;    Odi.PutData[numberAfterData: page.sector, xPosition: position];    position ¬ position + duMessage[sector].length + spacing - 1;    volume ¬ GetSubVolumeName[pageToBeExpanded];    Odi.PutData[data: IF volume = NIL THEN duMessage[unKnown] ELSE volume,    	        xPosition: position];    IF getStatus THEN {  -- %AR 8587       SetDriveStateTo[inactive];       errorStatus ¬ SELECT ScavengeAPage[pageToBeExpanded,FALSE].discStatus FROM       		     goodCompletion => duMessage[intermittent],		     -- labelDoesNotMatch => duMessage[labelDoesNotMatch],		     noSuchPage => duMessage[noSuchPage],		     seekFailed => duMessage[seekFailed],		     checkError => duMessage[checkError],		     dataError => duMessage[dataError],		     -- labelError => duMessage[labelError],		     ENDCASE => duMessage[unknown];       Odi.PutData[data: errorStatus, xPosition: errorStatusPosition] };           END; -- ExpandPageNumber--******************************************************************************-- Print bad page table contents in the Data Area --******************************************************************************DisplayBPTable: PUBLIC PROCEDURE [bpt: LONG POINTER TO Misc.RamBadPageTable] =  BEGIN    IF -- bpt = NIL OR -- bpt.badPageCount = 0 THEN {       Odi.PutData[data: duMessage[bptEmpty], blankSpaces: 2]; RETURN };         FOR i: CARDINAL IN [0..bpt.badPageCount) DO       IF bpt.badPages[i] = LAST[LONG CARDINAL] THEN EXIT;  -- No more       Odi.PutData[numberAfterData: bpt.badPages[i], blankSpaces: 2,                   startWithNewLine: IF i=0 THEN TRUE ELSE FALSE, 	           pauseAtBottomOfDataArea: TRUE];       ENDLOOP;    END;--******************************************************************************-- Print bad page table contents on a local printer --******************************************************************************TTYPrintBadPageTable: PUBLIC PROCEDURE	[bpt: LONG POINTER TO Misc.RamBadPageTable] =  BEGIN  ENABLE Volume.NeedsScavenging => {    Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];    PauseAndQuit[]};  --TTYPort information for the local printer  characterLength: TTYPortEnvironment.CharacterLength ¬ lengthIs8bits;  lineSpeed: TTYPortEnvironment.LineSpeed ¬ bps9600;  parity: TTYPortEnvironment.Parity ¬ none;  stopBits: TTYPortEnvironment.StopBits ¬ one;  ttyPortLineNumber: CARDINAL ¬ 0;  ttyPortStatus: TTYPort.TransferStatus;  time: Time.Packed;  inputString: LONG STRING ¬ [100];  --this will work for now!  lineCount: CARDINAL ¬ 0;  --to count the number of lines on the printed page  linesPerPage: CARDINAL = 66;  outputString: LONG STRING ¬ [80]; --80 =maximum length of string to print  diskAddress: PilotDiskFace.DiskAddress; -- PageNumber in [cyl, head, sector]  ttyPortChannel: TTYPort.ChannelHandle ¬ NIL;  ticks: Process.Ticks ¬ 15;      PrintBPTable: PROCEDURE[bpt: LONG POINTER TO Misc.RamBadPageTable] =    BEGIN       i:CARDINAL ¬ 0;      --This code follows the logic of DisplayBPTable      IF -- bpt = NIL OR -- bpt.badPageCount = 0 THEN {        Odi.PutData[data: duMessage[bptEmpty], blankSpaces: 2];         PrintString["                                    NONE"L]; RETURN };            WHILE i < bpt.badPageCount DO	 IF bpt.badPages[i] = LAST[LONG CARDINAL] THEN EXIT;  -- No more	 outputString.length ¬ 0;	 SkipToPosition[outputString, 5];	 String.AppendLongDecimal[outputString, bpt.badPages[i]];	 diskAddress ¬ ConvertPageToDiskAddress[bpt.badPages[i]];	 SkipToPosition[outputString, 16];	 String.AppendDecimal[outputString, diskAddress.cylinder];	 SkipToPosition[outputString, 23];	 String.AppendDecimal[outputString, CARDINAL[diskAddress.head]];	 SkipToPosition[outputString, 29];	 String.AppendDecimal[outputString, CARDINAL[diskAddress.sector]];	--2 columns	 IF bpt.badPages[i+1] = LAST[LONG CARDINAL] THEN	   {PrintLine[outputString]; lineCount ¬ lineCount+1; EXIT};  -- No more	 SkipToPosition[outputString, 43];	 String.AppendLongDecimal[outputString, bpt.badPages[i+1]];	 diskAddress ¬ ConvertPageToDiskAddress[bpt.badPages[i+1]];	 SkipToPosition[outputString, 54];	 String.AppendDecimal[outputString, diskAddress.cylinder];	 SkipToPosition[outputString, 61];	 String.AppendDecimal[outputString, CARDINAL[diskAddress.head]];	 SkipToPosition[outputString, 67];	 String.AppendDecimal[outputString, CARDINAL[diskAddress.sector]];	 PrintLine[outputString];	 lineCount ¬ lineCount+1;	 i ¬ i+2;       ENDLOOP;    END;  SkipToPosition: PROCEDURE[s: LONG STRING, pos: CARDINAL] =    {j: CARDINAL ¬ s.length;     WHILE j < pos DO --append a blank       String.AppendChar[s, ' !String.StringBoundsFault => CONTINUE];       j ¬ j +1;     ENDLOOP;    };  PrintLine: PROCEDURE[s: LONG STRING] =    {PrintString[s]; PrintCR[]; WaitForPrinter[]};  PrintCR: PROCEDURE[] =     {s: LONG STRING ¬ [2] ; String.AppendChar[s, '\n];      String.AppendChar[s, '\l]; PrintString[s]};  WaitForPrinter: PROCEDURE[] =    {Process.Pause[ticks] --wait for printer-- };  PrintString:PROCEDURE[s: LONG STRING] =    BEGIN      IF s = NIL THEN RETURN;      FOR i:CARDINAL IN [0..s.length) DO	WHILE ~TTYPort.GetStatus[ttyPortChannel].stat.readyToPut DO	  Odi.LookForAbort[];	ENDLOOP;	ttyPortStatus ¬ TTYPort.Put[ttyPortChannel, s[i]];	IF ttyPortStatus # success THEN	  {Odi.PutMessage[message: SELECT ttyPortStatus FROM		  parityError => "parityError"L,		  asynchFramingError => "asynchFramingError"L,		  dataLost => "dataLost"L,		  breakDetected => "breakDetected"L,		  aborted => "aborted"L,		  abortedByDelete => "abortedByDelete"L,	 	ENDCASE => "unknownError"L,		beep: TRUE ];	    PauseAndQuit[]};      ENDLOOP;    END;  PrinterReady: PROCEDURE[] RETURNS[status: BOOLEAN] =    {RETURN[TTYPort.GetStatus[ttyPortChannel].stat.dataTerminalReady]};  FormatPrintString: Format.StringProc = {PrintString[s]}; --to satisfy Format  --main routine  BEGIN  ENABLE Odi.AbortCurrentTest => {IF ttyPortChannel # NIL THEN TTYPort.Delete[ttyPortChannel]};    --open the TTYPort channel    ttyPortChannel ¬ TTYPort.Create[ttyPortLineNumber !      TTYPort.NoTTYPortHardware => 	{Odi.PutMessage[message: "No TTY Hardware present"L, beep: TRUE];	   PauseAndQuit[]};      TTYPort.InvalidLineNumber =>	{Odi.PutMessage[message: "Invalid Line Number"L, beep: TRUE];	   PauseAndQuit[]};      TTYPort.ChannelAlreadyExists =>	{Odi.PutMessage[message: "Channel Already Exists"L, beep: TRUE];	   PauseAndQuit[]}];    IF ttyPortChannel = NIL THEN      {Odi.PutMessage[message: "Channel Handle is nil"L, beep: TRUE];	 PauseAndQuit[]};    IF ~PrinterReady[] THEN      Odi.PutMessage[message: "printer must be turned on"L, beep: TRUE];    WHILE ~PrinterReady[] DO Odi.LookForAbort[]; ENDLOOP;  --wait for printer ready or STOP key    TTYPort.SetParameter[ttyPortChannel,      [breakDetectedClear [TRUE]]];    TTYPort.SetParameter[ttyPortChannel,[characterLength [VAL[characterLength]]]];    TTYPort.SetParameter[ttyPortChannel, [clearToSend[TRUE]]];    TTYPort.SetParameter[ttyPortChannel, [dataSetReady [TRUE]]];    TTYPort.SetParameter[ttyPortChannel, [lineSpeed[VAL[lineSpeed]]]];    TTYPort.SetParameter[ttyPortChannel, [parity [VAL[parity]]]];    TTYPort.SetParameter[ttyPortChannel, [stopBits [VAL[stopBits]]]];    --print the page header    PrintLine["                                *** Bad Page Log ***"L];    PrintCR[];    PrintString["Processor ID: "L];    Format.HostNumber[FormatPrintString, System.localHostNumber, octal,];    PrintString["  Model:  6085"L];    PrintCR[];    PrintString["Date: "L];    time ¬ Time.Current[];    Format.Date[FormatPrintString, time, dateOnly,,];    PrintCR[];    PrintString["RD Mfg Name: "L];    inputString ¬ Odi.GetAString["Please enter the rigid disk manufacturer's name: "L,,,];    PrintString[inputString];    PrintString["  Model: "L];    inputString ¬ Odi.GetAString["Please enter the rigid disk's model number"L,,,];    PrintString[inputString];    PrintString["  Serial#: "L];    inputString ¬ Odi.GetAString["Please enter the rigid disk's serial number"L,,,];    PrintString[inputString];    PrintCR[];    PrintCR[];    PrintString["     Page       Cyl    Hd    Sector        Page       Cyl    Hd    Sector"L];    PrintCR[];    PrintCR[];    lineCount ¬ 10;    PrintBPTable[bpt];    --print the page footer    FOR i:CARDINAL IN [lineCount..linesPerPage-5) DO PrintCR[]; ENDLOOP; --skip to bottom    PrintLine["Test Operator:                          QA Inspector:"L];    inputString.length ¬ 0;    String.AppendChar[inputString, '\F]; --give it a form feed    PrintString[inputString];    WaitForPrinter[];    --delete the TTYPort channel.    IF ttyPortChannel # NIL THEN TTYPort.Delete[ttyPortChannel];   END;  END;  --TTYPrintBadPageTable--******************************************************************************-- See if a page is in the bad page table--******************************************************************************InBadPageTable: PUBLIC PROC[page: PV.PageNumber, 		            table: LONG POINTER TO Misc.RamBadPageTable]		RETURNS [foundInTable: BOOLEAN ¬ FALSE] =  BEGIN    IF table = NIL THEN RETURN;     FOR i: CARDINAL IN [0..table.badPageCount) DO       IF table.badPages[i] = LAST[LONG CARDINAL] THEN RETURN;       IF table.badPages[i] = page THEN foundInTable ¬ TRUE;       ENDLOOP    END;--******************************************************************************--  Allocate space for a bad page table and initialize it to all 1's.--******************************************************************************GetABlankBadPageTable: PUBLIC PROCEDURE [numberOfSlots: CARDINAL] 		       RETURNS [aNewBPT: LONG POINTER TO Misc.RamBadPageTable] =  BEGIN    aNewBPT ¬ Odi.DiagHeap.NEW [Misc.RamBadPageTable[numberOfSlots]];    aNewBPT.badPageCount ¬ 0;    FOR i: CARDINAL IN [0 .. numberOfSlots)  -- Fill with all 1's       DO aNewBPT.badPages[i] ¬ LAST[LONG CARDINAL] ENDLOOP;    END;--******************************************************************************-- Resets a table to all ones--******************************************************************************ResetBadPageTable: PUBLIC PROC [bpt: LONG POINTER TO Misc.RamBadPageTable] =  BEGIN    FOR i: CARDINAL IN [0 .. bpt.tableSize)  -- Set to all ones       DO bpt.badPages[i] ¬ LAST[LONG CARDINAL] ENDLOOP;    END;--******************************************************************************-- Display the bad page table on the drive--******************************************************************************ReadCurrentBPTFromDisk: PUBLIC PROC [bpt: LONG POINTER TO Misc.RamBadPageTable]			RETURNS [LONG POINTER TO Misc.RamBadPageTable] =  BEGIN  ENABLE PV.Error => IF (error=notReady) OR (error=invalidHandle) THEN {  			Odi.PutMessage[message: duMessage[problemAccessingDrive],			   	       beep: TRUE]; PauseAndQuit[] };    bpCount: CARDINAL ¬ 0;    page: PV.PageNumber ¬ PhysicalVolume.nullBadPage;        IF Misc.RigidDiskDiag AND (~Misc.InitStarted)    	 THEN Misc.StartInit[]; -- to initialize    SetDriveStateTo[inactive];  -- Just in case    pvID ¬ PV.AssertPilotVolume [pvHandle     	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];        -- Get the page count    WHILE (page ¬ PV.GetNextBadPage [pvID, page]) # PV.nullBadPage       DO bpCount ¬ bpCount + 1  ENDLOOP;        ResetBadPageTable[bpt];  -- Clear table first    IF bpCount > bpt.tableSize THEN {       Odi.DiagHeap.FREE[@bpt]; bpt ¬ GetABlankBadPageTable[bpCount] };        -- Get BPT    page ¬ PV.nullBadPage;    FOR i: CARDINAL IN [0 .. bpCount)    WHILE (page ¬ PV.GetNextBadPage [pvID, page]) # PV.nullBadPage       DO bpt.badPages[i] ¬ page ENDLOOP;    bpt.badPageCount ¬ bpCount;    PhysicalVolume.Offline [pvID];    RETURN [bpt];    END;  -- ReadCurrentBPTFromDisk--******************************************************************************-- Add a bad page into the bad page table on the drive--******************************************************************************AddABadPage: PUBLIC PROCEDURE [pageToBeAdded: PV.PageNumber] =  BEGIN    -- Eho the page    pageInString: LONG STRING ¬ [10];    pageInString.length ¬ 0;    IF pageToBeAdded = LAST[LONG CARDINAL] THEN RETURN;    String.AppendLongNumber[pageInString, pageToBeAdded];    Odi.PutMessage [pageInString];        IF Odi.userType < Administrator THEN {       Odi.PutMessage[message: duMessage[insufficentPriv], beep: TRUE,           startWithNewLine: FALSE]; RETURN };    IF pageToBeAdded < firstAllowableBP THEN {  -- Page is in cylinder 0       Odi.PutMessage[message: duMessage[pageInCylZero], beep: TRUE,           startWithNewLine: FALSE]; RETURN };	       SetDriveStateTo[inactive];    pvID ¬ PV.AssertPilotVolume [pvHandle     	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];    PV.MarkPageBad [pvID, pageToBeAdded       ! PV.Error => IF error = badSpotTableFull THEN {	 	     Odi.PutMessage [message: duMessage[bptFull], beep: TRUE]; 		     PauseAndQuit[] } ];    PV.Offline [pvID];    Odi.PutMessage [message: duMessage[markedBad], startWithNewLine: FALSE];    END; -- AddABadPage--******************************************************************************-- Add a bad page into the bad page table on the drive--******************************************************************************AddADamagedPage: PUBLIC PROCEDURE [pageToBeAdded: PV.PageNumber] =  BEGIN   ENABLE      PhysicalVolumeExtras.ErrorExtras => {         Odi.PutMessage[message: duMessage[pilotTableFullMsg0],beep: FALSE,	    startWithNewLine:TRUE];	 Odi.PutMessage[message: duMessage[pilotTableFullMsg1],beep: TRUE,	    startWithNewLine:TRUE];	 PauseAndQuit[] };   type: Device.Type;   card: CARDINAL;   IF pageToBeAdded = LAST[LONG CARDINAL] THEN RETURN;            <<   copied from AddABadPage    IF Odi.userType < Administrator THEN {       Odi.PutMessage[message: duMessage[insufficentPriv], beep: TRUE,           startWithNewLine: FALSE]; RETURN };    IF pageToBeAdded < firstAllowableBP THEN {  -- Page is in cylinder 0       Odi.PutMessage[message: duMessage[pageInCylZero], beep: TRUE,           startWithNewLine: FALSE]; RETURN };    >>           SetDriveStateTo[inactive];    pvID ¬ PV.AssertPilotVolume [pvHandle     	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];    [type, card] ¬ PV.InterpretHandle[pvHandle]; -- to get the index    PhysicalVolumeExtras.MarkDataLostPage [card, pageToBeAdded];        --  PV.Offline [pvID];    --  Odi.PutMessage [message: duMessage[markedBad], startWithNewLine: FALSE];        SetDriveStateTo[direct];      -- fooXXX is this ok, resetting state ??    END; -- AddADamagedPage--******************************************************************************-- Get the subvolume information on the drive. --******************************************************************************GetSubVolumeInfo: PUBLIC PROCEDURE [table: LONG POINTER TO Misc.SubVolumeTable] 	 	 	   RETURNS [tableValid: BOOLEAN ¬ FALSE] =   BEGIN  ENABLE PV.Error =>  -- Trap error that indicate problems         IF (error=notReady) OR (error=invalidHandle) THEN {  	    Odi.PutMessage[message: duMessage[problemAccessingDrive],	        beep: TRUE];	    Misc.volumeInfoValid ¬ FALSE; PauseAndQuit[] };  CheckWithUser: PROC [firstPage: PhysicalVolume.PageNumber]  			RETURNS [TorF: BOOLEAN] =    BEGIN    ioStatus: DiskChannel.IOStatus;    Odi.PutMessage[message: duMessage[unableToAccessPDS], beep:TRUE];    IF ((Odi.GetYesNo[duMessage[riskWarning],,TRUE, FALSE]) AND	      		(Odi.userType > Services))	 THEN {ioStatus ¬ DoAPageOp[firstPage, restoreData];	 	IF (ioStatus = DiskChannel.goodCompletion)		    THEN Odi.PutMessage[message: duMessage[pageRepaired]]		    ELSE Odi.PutMessage[message: duMessage[pageNotRepaired]];		    RETURN[TRUE];}	 ELSE {Odi.PutMessage[message: duMessage[doRiskyRepair],		     beep:TRUE]; RETURN[FALSE];};    END;  subVolume: SpecialVolume.SubVolume ¬ SpecialVolume.nullSubVolume;  longestVolNameLength ¬ duMessage[unKnown].length;  -- For positioning error status  pvID ¬ PV.AssertPilotVolume [pvHandle            ! PV.Error => IF error = alreadyAsserted THEN CONTINUE];    FOR svCount: CARDINAL IN [0..PV.maxSubvolumesOnPhysicalVolume) DO      table.sv[svCount].svName ¬ -- Allocate space for subvolume name       Odi.DiagHeap.NEW[StringBody[PV.maxNameLength]];    subVolume ¬ SpecialVolume.GetNextSubVolume[pvID, subVolume       ! SpecialVolume.SubVolumeUnknown =>       	  IF CheckWithUser[subVolume.firstPVPageNumber] THEN CONTINUE	  	ELSE EXIT;];  -- Problems ...		      IF subVolume = SpecialVolume.nullSubVolume THEN EXIT; -- No more subvolumes        -- Have a valid subVolume. Save subvolume info    table.sv[svCount].svInfo ¬ subVolume;    -- Get the name of the subvolume and put it in table    Volume.GetLabelString[subVolume.lvID, table.sv[svCount].svName       ! Volume.NeedsScavenging =>       	 IF CheckWithUser[subVolume.firstPVPageNumber] THEN CONTINUE	 	ELSE EXIT;];    IF longestVolNameLength < table.sv[svCount].svName.length THEN       longestVolNameLength ¬ table.sv[svCount].svName.length;	     tableValid ¬ TRUE;    table.validSVCount ¬ svCount + 1; -- Increment count only after saving !!!    ENDLOOP;      ForceDriveOffline[pvHandle];  END;  -- GetSubVolumeInfo--*****************************************************************-- Set up drive to the correct state--*****************************************************************SetDriveStateTo: PUBLIC PROCEDURE [newState: DiskChannel.DriveState] =   BEGIN    setStatus: DiskChannel.DriveStatus;        -- Get the drive and the current state of the drive    drive ¬ DiskChannel.GetNextDrive[DiskChannel.nullDrive];    [state: oldState, changeCount: changeCount] ¬    	    DiskChannel.GetDriveAttributes[drive];<<    SELECT newState FROM  -- Return drive to offline state      direct => { -- Direct I/O (AssertNotAPilotVolume)         SELECT oldState FROM            inactive => PV.AssertNotAPilotVolume[pvHandle];	    channel => { PhysicalVolume.Offline[pvID];  -- Was online	    		 PV.AssertNotAPilotVolume[pvHandle] };	    ENDCASE };  -- OK, already in direct i/o state      channel => {  -- Channel I/O (AssertPilotVolume)         SELECT oldState FROM            direct => {PV.FinishWithNonPilotVolume[pvHandle];	    	       pvHandle ¬ PV.GetHandle[driveIndex];		       pvID ¬ PV.AssertPilotVolume[pvHandle] };	    inactive => pvID ¬ PhysicalVolume.AssertPilotVolume[pvHandle];	    ENDCASE };  -- OK, already in Pilot access state	          inactive => {  -- Force drive into inactive state         SELECT oldState FROM	    direct => { PV.FinishWithNonPilotVolume[pvHandle];	    	        pvHandle ¬ PV.GetHandle[driveIndex] };	    channel => PhysicalVolume.Offline[pvID];  -- Was online	    ENDCASE };  -- OK, already inactive       ENDCASE;>>    setStatus ¬ DiskChannel.SetDriveState[drive,changeCount,newState];    IF setStatus # ok THEN {       SELECT setStatus FROM          illegalState =>  -- Force the drive offline	     setStatus ¬ DiskChannel.SetDriveState[drive, changeCount, inactive];          wrongChangeCount => ERROR ChangeCountMisMatch;          ENDCASE;       setStatus ¬ DiskChannel.SetDriveState[drive,changeCount,newState] };          END;  -- SetDriveStateTo    --******************************************************************************-- Get the volume name of the page--******************************************************************************GetSubVolumeName: PROCEDURE [page: PV.PageNumber] 		    RETURNS [name: LONG STRING ¬ NIL] =  BEGIN--    firstPage, lastPage: PV.PageNumber;--    volumeInfo: Misc.ASubVolume; Logical volume information    RETURN; -- STC, a temporarily fix, see below for the fix.    -- subVolumeTable was supposed to be loaded by GetSubVolumeInfo,-- but no one call GetSubVolumeInfo. So subVolumeTable has garbages.-- No time to do right thing, temporarily return name = NIL!<<    IF NOT Misc.volumeInfoValid THEN RETURN;        FOR i: CARDINAL IN [0 .. Misc.subVolumeTable.validSVCount) DO       volumeInfo ¬ Misc.subVolumeTable.sv[i];       firstPage ¬ volumeInfo.svInfo.firstPVPageNumber;       lastPage ¬ firstPage + volumeInfo.svInfo.subVolumeSize;       IF page IN [firstPage..lastPage) THEN RETURN [volumeInfo.svName];       ENDLOOP;       >>           END; -- GetSubVolumeName--******************************************************************************-- Pause for an input. At the receipt of an input, Quit.--******************************************************************************PauseAndQuit: PUBLIC PROCEDURE =   BEGIN    Odi.HitAnyKeyToContinue[]; SIGNAL Odi.AbortCurrentTest;    END;--******************************************************************************-- Allocate and initializes fixed display records--******************************************************************************GetADisplayRecord: PUBLIC PROCEDURE [numberOfRows, itemsOnARow: CARDINAL]		   RETURNS [rp: LONG POINTER TO Odi.FixedPositionDisplayRecord] =  BEGIN    aRow: LONG POINTER TO Odi.ARow;    rp ¬ Odi.GetAFixedPositionDisplayRecord [numberOfRows];        FOR i: CARDINAL IN [0 .. numberOfRows) DO       rp.rows[i] ¬ aRow ¬ Odi.GetARow [itemsOnARow];       FOR j: CARDINAL IN [0 .. itemsOnARow) DO           aRow.rowItems[j].name ¬ NIL;           aRow.rowItems[j].namePosition ¬ Misc.leftEdge;	   aRow.rowItems[j].stringValue ¬ NIL;	   aRow.rowItems[j].valuePosition ¬ 0;	   aRow.rowItems[j].value ¬ 0;	   ENDLOOP;  -- Row loop       ENDLOOP;  -- Record loop    END;  -- GetADisplayRecord  --******************************************************************************-- Make sure cylinder 0 is ok. Cylinder 0 can not have bad pages--******************************************************************************CheckCylinderZero: PUBLIC PROCEDURE  =   BEGIN    cylinderZeroBad: BOOLEAN ¬ FALSE;--    ForceDriveOffline[pvHandle];    SetDriveStateTo[inactive];    PV.AssertNotAPilotVolume[pvHandle   	! PV.Error => IF error = alreadyAsserted THEN CONTINUE];    FPD.Scan[pvHandle, 0, pagesPerCylinder	! FPD.BadPage => { -- Cylinder 0 can not have any bad pages	                   Odi.PutMessage[message: duMessage[badCylZero],	                                  beep: TRUE, numOfBlankLines: 1];--	                   CONTINUE;}];	      Odi.PutData [data: duMessage[badCylZeroPage], clearHeadingAndData: TRUE];	      Odi.PutData [numberAfterData: p, blankSpaces: 2];  -- fix AR 10022	      		   PauseAndQuit[] }];    RETURN;    END;--******************************************************************************-- Offline volume--******************************************************************************ForceDriveOffline: PUBLIC PROCEDURE [h: PhysicalVolume.Handle] =  BEGIN    p: PhysicalVolume.ID ¬ PhysicalVolume.nullID;    DO      p ¬ PhysicalVolume.GetNext[p]; -- Get the ID of the drive (Only one ... 0)      IF p = PhysicalVolume.nullID THEN EXIT;  -- No drive exits      IF h = PhysicalVolume.GetAttributes[p].instance THEN { -- Compare 	 <<wasOnline ¬ TRUE;   -- The handles match => was on-line>>	 PhysicalVolume.Offline [p 	   ! PV.Error => IF error = physicalVolumeUnknown THEN CONTINUE];	 EXIT};      ENDLOOP;    END;--******************************************************************************-- Test a RAM bad page table. Actions: testPage, repairPage, markPageBad--******************************************************************************TestPagesInBadPageTable: PUBLIC PROC[bpt: LONG POINTER TO Misc.RamBadPageTable] =  BEGIN    testPage: CARDINAL = 1;    repairPage: CARDINAL = 2;    markPageBad: CARDINAL = 3;    nextPage: CARDINAL = 4;        IF -- (bpt = NIL) OR -- bpt.badPageCount = 0 THEN {       Odi.PutMessage[duMessage[bptEmpty]]; RETURN };        -- Take care of every page in table    FOR i: CARDINAL IN [0..bpt.badPageCount) DO {       -- Explode page into cylinder, head, sector and volume.         PrintExpandedPageHeading[FALSE,FALSE,TRUE];  -- Error status %AR 8587       ExpandPageNumber[bpt.badPages[i],TRUE]; -- Does a PageScavenger.Scavenge              DO -- Loop here for every page until exit       ENABLE Odi.AbortCurrentTest => LOOP;                 SELECT Odi.GetANumber [prompt: duMessage[testAction],	             upperLimit: 5, defaultNumber: testPage].number FROM	      testPage => { -- Scan page, give hard failure/softerror	        TestABadPage [bpt.badPages[i]]; LOOP };	     	      repairPage => { -- Run PageScavenger.Scavenge	        RepairABadPage [bpt.badPages[i]]; LOOP };	      markPageBad => { AddABadPage [bpt.badPages[i]]; EXIT };	      	      nextPage => EXIT;  -- Skip to next page 	      	      ENDCASE => RETURN; -- Exit	      	  ENDLOOP };  -- Page loop       ENDLOOP; -- Table loop           Odi.PutMessage[message: duMessage[endOfBPT], beep: TRUE];    END;  -- TestPagesInBadPageTable--*********************************-- Add RAM bad page table to disk--*********************************AddBadPageTable: PUBLIC PROCEDURE [bpt: LONG POINTER TO Misc.RamBadPageTable, 		       		   getConfirmation: BOOLEAN] = {  addPage: BOOLEAN;  IF -- bpt = NIL OR -- bpt.badPageCount = 0 THEN {     Odi.PutMessage [message: duMessage[bptEmpty], beep: TRUE]; PauseAndQuit[]};  PrintExpandedPageHeading [FALSE,FALSE,getConfirmation];  FOR i: CARDINAL IN [0..bpt.badPageCount) DO {     addPage ¬ TRUE;     IF bpt.badPages[i] = LAST[LONG CARDINAL] THEN EXIT;  -- Finished     ExpandPageNumber [bpt.badPages[i],getConfirmation];     IF getConfirmation THEN      	addPage ¬ Odi.GetYesNo[duMessage[addThisPage],,TRUE,FALSE];     IF addPage THEN AddABadPage [bpt.badPages[i]] };     ENDLOOP };--******************************************************************************-- Scans a given page to see how reliable it is. Give hardFailureCount and-- softErrorCount--******************************************************************************TestABadPage: PUBLIC PROCEDURE [pageToBeTested: PV.PageNumber] =  BEGIN    testCount: LONG CARDINAL;    hardFailureCount, softErrorCount: LONG CARDINAL ¬ 0;    retryCount: FormatPilotDisk.RetryLimit;    innerLoopBadCount: FormatPilotDisk.RetryLimit;        testCount ¬ Odi.GetANumber[prompt: duMessage[passCount],    		               lowLimit: 0, -- allow to test Root page			       defaultNumber: 10].number;    retryCount ¬ Odi.GetANumber[prompt: duMessage[retryCount],     		     lowLimit: 0,                     upperLimit: LAST[FormatPilotDisk.RetryLimit],		     defaultNumber: 10].number;--    ForceDriveOffline [pvHandle];   PV.AssertNotAPilotVolume[pvHandle   	! PV.Error => IF error = alreadyAsserted THEN CONTINUE];    FOR i: LONG CARDINAL IN [1 .. testCount] DO  -- Outer loop       innerLoopBadCount ¬ 0;  -- Number of failures in retryCount scans       FOR j: FormatPilotDisk.RetryLimit IN [0..retryCount] DO -- Inner loop          -- Scan does not return a retryCount          FPD.Scan[pvHandle, pageToBeTested, 1, 0	      ! FPD.BadPage => { -- An error encoutered	            innerLoopBadCount ¬ innerLoopBadCount+1; RESUME}];	  -- Now determine what kind of error is the error	  IF j=retryCount THEN	    SELECT TRUE FROM	      innerLoopBadCount = 0 => LOOP;  -- No error detected for loop	      -- A soft error is anything less than failure at every retry	      innerLoopBadCount < retryCount => softErrorCount ¬ softErrorCount+1;	      ENDCASE => hardFailureCount ¬ hardFailureCount + 1;	  ENDLOOP;  -- End Inner (retry loop)       ENDLOOP;  -- Outer (testCount) loop    Odi.PutData[data: duMessage[passCount], numberAfterData: testCount,                startWithNewLine: TRUE, xPosition: 4];    Odi.PutData[data: duMessage[retryCount], numberAfterData: retryCount,                blankSpaces: 3];    Odi.PutData[data: duMessage[softErrors], numberAfterData: softErrorCount,                blankSpaces: 3];    Odi.PutData[data: duMessage[hardErrors], numberAfterData: hardFailureCount,                blankSpaces: 3];    SetDriveStateTo[inactive];  -- Just in case    END;  -- TestABadPage--******************************-- Attempt to repair a bad page--******************************RepairABadPage: PUBLIC PROCEDURE [pageToBeRepaired: PV.PageNumber] =  BEGIN    -- Items return by Scavenge    action: PageScavenger.Action;    repaired: BOOLEAN;    contentsOK: BOOLEAN;    diskStatus: PageScavenger.DiskStatus;    fileID: File.ID;    filePage: File.PageNumber;    type: File.Type;    diskPage: PilotDiskFace.DiskAddress;    firstPageOnTrack: PV.PageNumber; -- First page of track containing bad page    overwrite: BOOLEAN;    bootChainLinks: ARRAY [0..2) OF WORD;        -- Get permission to over-write data field if Scavenge finds it necessary    overwrite ¬ Odi.GetYesNo [prompt: duMessage[overWritePage],    		  	      defaultSpecified: TRUE, default: TRUE];			          -- Convert Pilot page to disk address    diskPage ¬ ConvertPageToDiskAddress[pageToBeRepaired];    firstPageOnTrack ¬ pageToBeRepaired - diskPage.sector;        -- Scavenge the page    SetDriveStateTo[inactive];        -- fooXXX    -- SPL had comment out this "workaround" and test in Pilot13    -- This is workaround to problem of scavenger being unable to repair a page    IF overwrite THEN {  -- Force an overwrite       ioStatus: DiskChannel.IOStatus;              PhysicalVolume.AssertNotAPilotVolume [pvHandle -- Initiate direct access       	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];       [] ¬ DoAPageOp[pageToBeRepaired, saveData];       bootChainLinks ¬ labeledOp.labelPtr.dontCare;       labeledOp.labelPtr­ ¬ LOOPHOLE[CompatibilityDiskFace.zeroLabel];       labeledOp.labelPtr.dontCare ¬ bootChainLinks;       CompatibilityDiskFace.SetLabelFilePage[labeledOp.labelPtr, pageToBeRepaired];       [] ¬ DoAPageOp[pageToBeRepaired, restoreData];       [] ¬ DoAPageOp[pageToBeRepaired, saveData];       ioStatus ¬ DoAPageOp[pageToBeRepaired, verifyData];       PhysicalVolume.FinishWithNonPilotVolume[pvHandle];              WITH ioStatus SELECT FROM          invalidChannel => ERROR ChangeCountMisMatch;          invalidDriveState => ERROR IllegalDriveState;          disk => { PrintStatus[status, errorStatusPosition, TRUE];	  	    Odi.PutData[data: IF status = goodCompletion THEN		    	    duMessage[pageRepaired] ELSE duMessage[pageNotRepaired],			    startWithNewLine: TRUE, xPosition: 4] };           ENDCASE;       RETURN };            -- fooXXX end comment out this "workaround" and test in Pilot13    [action, contentsOK, diskStatus, fileID, filePage, type] ¬      ScavengeAPage [pageToBeRepaired, overwrite];     -- Action: TYPE={fixDataCRCError, fixHardware, boot, lvScavenge, pvScavenge};    repaired ¬ action IN [boot..pvScavenge];        IF repaired THEN  -- Successful repair       Odi.PutData [data: duMessage[pageRepaired], startWithNewLine: TRUE,        		    xPosition: 4];<<    -- If contentsReliable, but data CRC Error exits, then try to reapair CRC    IF contentsOK AND (action = fixDataCRCError) THEN {       [action, contentsOK, diskStatus, fileID, filePage, type] ¬         ScavengeAPage [pageToBeRepaired, TRUE];       IF (repaired ¬ action IN [boot..pvScavenge]) THEN           Odi.PutData [data: duMessage[pageRepaired], startWithNewLine: TRUE,	  	       xPosition: 4] };>>    IF NOT repaired THEN { -- Unable to repair page       Odi.PutData [data: duMessage[pageNotRepaired], startWithNewLine: TRUE,    		    xPosition: 4];       -- Display scavenge result       Odi.PutData[data: duMessage[repairStatus], numOfBlankLines: 1, xPosition: 4];       Odi.PutData[data: duMessage[diskStatus],startWithNewLine: TRUE,xPosition: 7];       message ¬ SELECT diskStatus FROM    		        goodCompletion => duMessage[goodCompletion],		        noSuchPage => duMessage[noSuchPage],		        -- labelDoesNotMatch => duMessage[labelDoesNotMatch],		        seekFailed => duMessage[seekFailed],		        checkError => duMessage[checkError],		        dataError => duMessage[dataError],		        hardwareError => duMessage[hardwareError],		        notReady => duMessage[driveNotReady],		        -- labelError => duMessage[labelError],		        ENDCASE => duMessage[unKnown];       Odi.PutData[data: message, blankSpaces: 1];       -- Reliability of the contents       Odi.PutData[data: duMessage[pageContents],startWithNewLine:TRUE,xPosition: 7];       Odi.PutData[data: IF contentsOK THEN duMessage[reliable]        			 ELSE duMessage[unReliable], blankSpaces: 1] };    -- Now the action to be taken by the requestor    Odi.PutData[data: duMessage[userAction], startWithNewLine: TRUE, xPosition: 4];    message ¬ SELECT action FROM     		     fixDataCRCError => duMessage[fixDataCRCError],		     fixHardware => duMessage[fixHardware],		     boot => duMessage[boot],		     lvScavenge => duMessage[lvScavenge],		     pvScavenge => duMessage[pvScavenge],		     ENDCASE => duMessage[unKnown];    Odi.PutData [data: message, blankSpaces: 1];        END;  -- RepairABadPage--*********************************************-- Saves the data off of a physical track--*********************************************SaveATrack: PUBLIC PROC [page: PV.PageNumber, displayStatus: BOOLEAN ¬ TRUE] =   BEGIN      diskPage: PilotDiskFace.DiskAddress;    firstPageOnTrack: PV.PageNumber; -- First page of track containing bad page    saveCommand: CompatibilityDiskFace.Command = [verify, read, read];    ioStatus: DiskChannel.IOStatus;    thisPage: PV.PageNumber;        diskPage ¬ ConvertPageToDiskAddress[page];    firstPageOnTrack ¬ page - diskPage.sector;    thisPage ¬ firstPageOnTrack;    IF displayStatus THEN { -- Display the status of operation       PrintExpandedPageHeading [TRUE,FALSE,FALSE];       ExpandPageNumber[page] };        labeledOp­ ¬ [command: saveCommand,  -- Set up operation block    		 device: deviceHandle,		 clientHeader: diskPage,		 pageCount: 1,  -- Do it one at a time		 tries: DiskChannel.defaultTries,		 labelPtr: labels[0],		 dataPtr: dataPages[0],		 incrementDataPtr: FALSE];		     Odi.PutMessage [message: duMessage[savingData], clearMessageAreaFirst: TRUE];    FOR sectorNumber: CARDINAL IN [0 .. sectorsPerTrack) DO        IF displayStatus THEN ExpandPageNumber[firstPageOnTrack+sectorNumber];	labeledOp.clientHeader.sector ¬ sectorNumber;	labeledOp.labelPtr ¬ labels[sectorNumber];	labeledOp.dataPtr ¬ dataPages[sectorNumber];	labeledOp.pageCount ¬ 1;  -- Read page at a time	-- Now save the data on the track on which the bad page is located	-- op.diskOp ¬ LOOPHOLE[labeledOp, PilotDiskFace.Operation];	thisPage ¬ firstPageOnTrack + sectorNumber;	ioStatus ¬ DiskChannel.DoDirectIO[op].status;	WITH ioStatus SELECT FROM	  invalidChannel => ERROR ChangeCountMisMatch;	  invalidDriveState => ERROR IllegalDriveState;    	  disk => { -- Disk operation	      saveOpStatus[sectorNumber] ¬ status;	      IF displayStatus THEN PrintStatus[status, saveStatusPosition];	      IF status # goodCompletion THEN	        AddADamagedPage[thisPage] };	  ENDCASE => ERROR ImpossibleEndCase;	ENDLOOP;	    Odi.PutMessage[message: duMessage[completed], startWithNewLine: FALSE];    END;  -- SaveATrack    <<--*********************************************-- Restores the data off of a physical track--*********************************************RestoreATrack: PUBLIC PROC [page: PV.PageNumber] =    BEGIN      diskPage: PilotDiskFace.DiskAddress;    firstPageOnTrack: PV.PageNumber; -- First page of track containing bad page    restoreCommand: CompatibilityDiskFace.Command = [verify, write, write];    ioStatus: DiskChannel.IOStatus;        Odi.PutMessage[duMessage[restoringData]];    diskPage ¬ ConvertPageToDiskAddress[page];    firstPageOnTrack ¬ page - diskPage.sector;        PrintExpandedPageHeading [TRUE,TRUE,FALSE];    ExpandPageNumber[page];    labeledOp ¬ [command: restoreCommand, -- [verify, write, write]      		 device: deviceHandle,		 clientHeader: diskPage,		 pageCount: 1,  -- Do it one at a time		 tries: DiskChannel.defaultTries,   		 labelPtr: labels[0],		 dataPtr: dataPages[0],		 incrementDataPtr: FALSE];        Odi.PutMessage[duMessage[restoringData]];    FOR trackPage: CARDINAL IN [0 .. pagesPerTrack) DO  -- Restore loop        thisPage: LONG CARDINAL;		thisPage ¬ firstPageOnTrack + trackPage;	ExpandPageNumber[thisPage];	labeledOp.clientHeader.sector ¬ trackPage;	labeledOp.labelPtr ¬ labels[trackPage];  -- label	labeledOp.dataPtr ¬ dataPages[trackPage];  -- data	labeledOp.pageCount ¬ 1;  -- Restore page at a time	PrintStatus[saveOpStatus[trackPage], saveStatusPosition]; --Save op status		-- Restore whatever that was saved	-- op.diskOp ¬ LOOPHOLE[labeledOp, PilotDiskFace.Operation];	ioStatus ¬ DiskChannel.DoDirectIO[op].status;	WITH ioStatus SELECT FROM	   invalidChannel => ERROR ChangeCountMisMatch;	   invalidDriveState => ERROR IllegalDriveState;	   disk => PrintStatus[status, restoreStatusPosition];	   ENDCASE => ERROR ImpossibleEndCase;	   	ENDLOOP;    Odi.PutMessage[message: duMessage[completed], startWithNewLine: FALSE];    END;  -- RestoreATrack>> --*******************************************************************-- Prints the status of a direct operation (DiskChannel.DoDirectIO)--*******************************************************************PrintStatus: PUBLIC PROC [opStatus: PilotDiskFace.Status, 		          position: CARDINAL, newLine: BOOLEAN ¬ FALSE] =   BEGIN    message: LONG STRING;        message ¬ SELECT opStatus FROM      		goodCompletion => duMessage[goodCompletion],		headerCRCError => duMessage[headerCRCError],--		labelCRCError => duMessage[labelError],--		labelVerifyError => duMessage[labelDoesNotMatch],		reserved6 => duMessage[labelError],		reserved9 => duMessage[labelDoesNotMatch],		dataCRCError => duMessage[dataError],		dataVerifyError => duMessage[dataVerifyError],		headerNotFound => duMessage[headerNotFound],		notReady => duMessage[driveNotReady],		seekTimeout => duMessage[seekFailed],		ENDCASE =>  duMessage[unknown];    Odi.PutData[data: message, startWithNewLine: newLine,    		xPosition: IF newLine THEN 4 ELSE position];    END;    --*********************************************-- Attempts to repair data or label CRC errors--*********************************************ScavengeAPage: PROC [pageToBeScavenged: PV.PageNumber, overwriteData: BOOLEAN]	       RETURNS [userAction: PageScavenger.Action, dataReliable: BOOLEAN,	       		discStatus: PageScavenger.DiskStatus, fileID: File.ID,			filePage: File.PageNumber, type: File.Type] =  BEGIN  ENABLE PV.Error => { Odi.PutMessage[message: duMessage[problemAccessingDrive],			   	      beep: TRUE]; PauseAndQuit[] };    SetDriveStateTo[inactive];    pvID ¬ PV.AssertPilotVolume [pvHandle        	               -- fooXXX    	   ! PV.Error => IF error = alreadyAsserted THEN CONTINUE ];   -- per RSV--    [userAction, dataReliable, discStatus, fileID, filePage, type] ¬    [userAction, dataReliable, discStatus] ¬     PageScavenger.Scavenge [      device: 0, diskPage: pageToBeScavenged, overwrite: overwriteData       ! PageScavenger.Error => {	     message ¬ SELECT errorType FROM	        	driveNotAvailable => duMessage[driveNotAvailable],			driveNotReady => duMessage[driveNotReady],			invalidPageNumber => duMessage[invalidPageNumber],			unknownDrive => duMessage[unknownDrive],			ENDCASE => duMessage[unKnown];	     Odi.PutMessage [message: message, beep: TRUE];	      	     PV.Offline [pvID];	     PauseAndQuit[] } ];  -- End PageScavenger.Scavenge    PV.Offline [pvID];    END;--***************************************************************************-- For some reason, PageScavenger.Scavenge can not repair a page. This is a-- temporary work-around to force the repair of a bad page by a VWW--***************************************************************************DoAPageOp: PUBLIC PROC[page: PV.PageNumber, operation: CompatibilityDiskFace.Command]	          RETURNS [DiskChannel.IOStatus] = {   diskAddress: PilotDiskFace.DiskAddress;      diskAddress ¬ ConvertPageToDiskAddress [page];--   op.diskOp ¬ [ diskOp has the info needed to carry out an operation   labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		command: operation,      		device: deviceHandle,		clientHeader: diskAddress,		pageCount: 1,  -- Do it one at a time		tries: DiskChannel.defaultTries, 		labelPtr: labels[0],		dataPtr: dataPages[0],		incrementDataPtr: FALSE];   RETURN[DiskChannel.DoDirectIO[op].status] };   --***************************************************************************-- DisplayBadPageTable--***************************************************************************DisplayBadPageTable: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN  ENABLE PV.NeedsScavenging => {    Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];    PauseAndQuit[] };        Misc.ValidateIDandCheckVirginity[];    Misc.currentBPTOnDisk ¬ ReadCurrentBPTFromDisk [Misc.currentBPTOnDisk];    Odi.PutData [data: duMessage[badPageList], clearHeadingAndData: TRUE];    DisplayBPTable [Misc.currentBPTOnDisk];    RETURN [nullResult];    END;  -- DisplayBadPageTable--***************************************************************************-- PrintBadPageTable--***************************************************************************PrintBadPageTable: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN        IF ~Misc.InitStarted THEN Misc.StartInit[];    Misc.ValidateIDandCheckVirginity[];        Misc.currentBPTOnDisk ¬ ReadCurrentBPTFromDisk [Misc.currentBPTOnDisk       ! PV.NeedsScavenging => { -- Can not read table         Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE];	 PauseAndQuit[]}];	     TTYPrintBadPageTable[Misc.currentBPTOnDisk];    IF Misc.RigidDiskDiag THEN Misc.InitStarted ¬ FALSE;    RETURN [nullResult];  END;  -- PrintBadPageTable--***************************************************************************-- --***************************************************************************CollectNewBadPage: PUBLIC PROC	[bpCollector: LONG POINTER TO Misc.RamBadPageTable,	 oldBPTable: LONG POINTER TO Misc.RamBadPageTable,	 badPageCount: CARDINAL, newBadPage: PhysicalVolume.PageNumber]	RETURNS [CARDINAL] =  BEGIN    tmp: PhysicalVolume.PageNumber;    maxNumberOfBadPages: CARDINAL = 200;    bptFull: BOOLEAN ¬ FALSE;    firstOverFlowPageEncountered: BOOLEAN ¬ FALSE;    AddToNewBPT: PROC RETURNS [CARDINAL] =       BEGIN       FOR i: CARDINAL IN [0..maxNumberOfBadPages) DO          {          Odi.LookForAbort[]; -- Enable abort	  SELECT bpCollector.badPages[i] FROM	     = newBadPage => RETURN[badPageCount]; -- Already in bad page table	     < newBadPage => LOOP; -- Store in increasing order	     = LAST[LONG CARDINAL] =>  -- An empty slot has LAST[LONG CARDINAL]	     	{bpCollector.badPages[i] ¬ newBadPage;	    	 badPageCount ¬ badPageCount + 1; EXIT };	     > newBadPage =>	         {badPageCount ¬ badPageCount + 1;	         IF badPageCount >= maxNumberOfBadPages THEN	            { -- Table full, just display page number		    bptFull ¬ TRUE;	      -- This is a case where a bad page was not found by previous scans	            IF NOT firstOverFlowPageEncountered THEN		       { -- fisrt overflow page		       firstOverFlowPageEncountered ¬ TRUE;		       Odi.PutData[data: duMessage[overflowedPages], 		                clearDataAreaOnly: TRUE] };	            Odi.PutData[numberAfterData: newBadPage, blankSpaces: 2];		    EXIT };  -- Displays page number only if not in table	         tmp ¬ bpCollector.badPages[i];	         bpCollector.badPages[i] ¬ newBadPage;	         -- Now shift everything by 1	         FOR j: CARDINAL IN [(i+1) .. badPageCount) DO	            newBadPage ¬ bpCollector.badPages[j];  -- Save temporarily	            bpCollector.badPages[j] ¬ tmp; -- Shift by 1 location		    tmp ¬ newBadPage;		    ENDLOOP;	         EXIT};	      ENDCASE => ERROR ImpossibleEndCase };	   ENDLOOP;       bpCollector.badPageCount ¬ badPageCount;       RETURN[badPageCount];       END;    IF badPageCount >= maxNumberOfBadPages THEN { -- RAM table is full       bptFull ¬ TRUE;        Odi.PutMessage[message: duMessage[tooManyBadPages], beep: TRUE,                       numOfBlankLines: 1] };  -- Give warning    FOR i: CARDINAL IN [0..maxNumberOfBadPages) DO { -- Each page goes thru table    -- If a user specifies more than 1 scan, a bad page may have already been        -- logged.       Odi.LookForAbort[]; -- Enable abort       SELECT oldBPTable.badPages[i] FROM  -- 	  = newBadPage => RETURN[badPageCount]; -- Already in bad page table          < newBadPage => LOOP; -- Store in increasing order	  = LAST[LONG CARDINAL] =>  -- An empty slot has LAST[LONG CARDINAL]	      {badPageCount ¬ AddToNewBPT[];}; -- exhaust oldBPTable          > newBadPage =>	      {badPageCount ¬ AddToNewBPT[];};-- newBadPage not in oldBPTable	  ENDCASE => ERROR ImpossibleEndCase };       ENDLOOP;  -- Bad page loop    RETURN[badPageCount];    END;  -- CollectNewBadPage--***************************************************************************-- Are PVRoot, BPT, and SubVolumeRoot pages readable?--***************************************************************************CheckPVPages: PUBLIC PROC RETURNS [goodPV: BOOLEAN ¬ TRUE] =   BEGIN-- check PVRoot, BPT's, get subVCnt and check each subVRoot's-- This is just a quick simple fix so one may have the DiskDiag OnLine.   PVRoot: PhysicalVolume.PageNumber ¬ 0; -- PV Root page   BPTpage: PhysicalVolume.PageNumber ¬ 1; -- BPT page   badRootPage: BOOLEAN ¬ FALSE;   aPage: PhysicalVolume.PageNumber;   subVCnt: CARDINAL ¬ 0;   BPCnt: CARDINAL ¬ 0;   PVRootpage: PhysicalVolumeFormat.Handle; -- PV Root page      ReadPVpages: PROC [page: PhysicalVolume.PageNumber]   		RETURNS [valid: BOOLEAN ¬ FALSE] =     BEGIN     ioStatus: DiskChannel.IOStatus;     IF page = PhysicalVolume.lastPageNumber THEN RETURN[valid];     labeledOp.device ¬ deviceHandle;     labeledOp.command ¬ saveData;     labeledOp.clientHeader ¬ ConvertPageToDiskAddress[page];     labeledOp.labelPtr ¬ labels[0];     labeledOp.dataPtr ¬ IF (page = 0) THEN dataPages[0] ELSE dataPages[2];     labeledOp.pageCount ¬ 1;  -- Read page at a time     ioStatus ¬ DiskChannel.DoDirectIO[op].status;     WITH ioStatus SELECT FROM	invalidChannel => ERROR ChangeCountMisMatch;	invalidDriveState => ERROR IllegalDriveState;	disk =>	   {valid ¬ (status = goodCompletion);	    IF ((status = goodCompletion) AND (page = 0)) THEN	       subVCnt ¬ PVRootpage.subVolumeCount;	    IF status # goodCompletion THEN	      {pageInString: LONG STRING ¬ [30];    	       pageInString.length ¬ 0;	       String.AppendString[pageInString, duMessage[foundOnPage]];	       String.AppendLongNumber[pageInString, page];	       PrintStatus[status, saveStatusPosition, TRUE];	       Odi.PutData [data: pageInString,		  pauseAtBottomOfDataArea: TRUE];	       IF page = 0 THEN badRootPage ¬ TRUE;	       BPCnt ¬ BPCnt + 1;};	    };	ENDCASE => ERROR ImpossibleEndCase;      RETURN[valid];      END;   PV.AssertNotAPilotVolume[pvHandle   	! PV.Error => IF error = alreadyAsserted THEN CONTINUE];   SetDriveStateTo[direct];  -- Just in case   PVRootpage ¬ dataPages[0];   IF ~ReadPVpages[PVRoot] THEN goodPV ¬ FALSE ELSE      {IF (PVRootpage.seal = PhysicalVolumeFormat.Seal) AND          (PVRootpage.pvID # PhysicalVolume.nullID) THEN	    IF (PVRootpage.version < 7) THEN	      {Odi.PutMessage[message: duMessage[sysnotmatch], beep: TRUE ];	       Odi.PutMessage[message: duMessage[warndamage]];	       IF NOT Odi.GetYesNo[duMessage[wishContinue],,TRUE,FALSE]	  	THEN {Odi.abortSensed ¬ TRUE; Odi.LookForAbort[]};	       IF NOT Odi.GetYesNo[duMessage[areYouSure],,TRUE,FALSE]	  	THEN {Odi.abortSensed ¬ TRUE; Odi.LookForAbort[]};	       };	  	IF ((~ReadPVpages[BPTpage]) OR		(PVRootpage.seal # PhysicalVolumeFormat.Seal) OR	  	(PVRootpage.pvID = PhysicalVolume.nullID))       			THEN goodPV ¬ FALSE;};   IF (PVRootpage.version = 7) THEN	{IF (goodPV AND (subVCnt # 0)) THEN		FOR i: CARDINAL IN [0..subVCnt) DO			aPage ¬ PVRootpage.subVolumes[i].pvPage;			IF ~ReadPVpages[aPage] THEN goodPV ¬ FALSE;			ENDLOOP;};      SetDriveStateTo[inactive];  -- Just in case   IF ~goodPV THEN      {       Odi.PutMessage[message: duMessage[unableToAccessPDS], beep: TRUE ];       Odi.PutMessage[message: duMessage[doRiskyRepair], beep:FALSE];       Odi.HitAnyKeyToContinue[];};   RETURN[goodPV];   END; -- CheckPVPages--***************************************************************************-- --***************************************************************************--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Head Retraction Procedure --(Moves heads to safe landing zone.  To be used before shipping machines.)	--Puts help text message on screen.  Gets user confirmations to continue.	--Reads EEProm and gets headLandingZone value.	--For nonzero values it does a disk operation(MoveHeads) to retract the	--heads to the head landing zone.	--FreezeMachine procedure is called to put the machine in a state	--where the user cannot do any other operation.  The user is prompted	--to turn off the machine.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~HeadRetraction: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    headLandingZone: CARDINAL;    sysConStatus: SysConfigChannelDefs.Status;        IF ~DiskUtilityMiscDove.InitStarted THEN DiskUtilityMiscDove.StartInit[];    Odi.PutMessage[message: duMessage[headRetractExp],    		   clearMessageAreaFirst: TRUE];    Odi.PutMessage[message: duMessage[chooseContinue],    		   clearMessageAreaFirst: FALSE];    IF NOT Odi.GetYesNo[duMessage[wishContinue],,TRUE,]       THEN SIGNAL Odi.AbortCurrentTest;    IF NOT Odi.GetYesNo[duMessage[areYouSure],,TRUE,]       THEN SIGNAL Odi.AbortCurrentTest;        FOR i:CARDINAL IN [0..2]      DO      SysConfigChannelDefs.Initialize;      sysConStatus ¬ SysConfigChannelDefs.ReadEEPromImage[];      IF sysConStatus = success THEN EXIT;      ENDLOOP;    IF sysConStatus # success      THEN BEGIN 	       	   Odi.PutMessage[message: duMessage[invalidEEProm],	   	          numOfBlankLines: 1,			  clearMessageAreaFirst: FALSE];	   Odi.PutMessage[message: duMessage[notRetracted],			  clearMessageAreaFirst: FALSE];	   RETURN[result ¬ none];	   END;	     headLandingZone ¬ SysConfigChannelDefs.eePromImage.RigidDiskHeadLandingZone;    IF headLandingZone # 0 THEN       IF NOT MoveHeads[headLandingZone] THEN RETURN[result ¬ none];    FreezeMachine [];    result ¬ none;    END;MoveHeads: PRIVATE PROCEDURE [landingCyl: CARDINAL]	   RETURNS [BOOLEAN] =   BEGIN  diskAddress: PilotDiskFace.DiskAddress;  ioStatus: DiskChannel.IOStatus;    --First do disk operation on cylinder 0 to check out disk subsystem  diskAddress.cylinder ¬ 0;  diskAddress.head ¬ 0;  diskAddress.sector ¬ 0;  Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation         	    command: saveData,      		    device: deviceHandle,		    clientHeader: diskAddress,		    pageCount: 1,  -- Do it one at a time		    tries: DiskChannel.defaultTries, 		    labelPtr: Misc.labels[0],		    dataPtr: Misc.dataPages[0],		    incrementDataPtr: FALSE];      ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;    IF ioStatus # [disk[status:goodCompletion]]    THEN BEGIN         Odi.PutMessage[message: duMessage[diskError],	 	        numOfBlankLines: 1,			clearMessageAreaFirst: FALSE];	 Odi.PutMessage[message: duMessage[notRetracted],			clearMessageAreaFirst: FALSE];	 RETURN [FALSE];	 END;	   --If test operation was successful, do head retraction operation.  --In order to get the heads to the landing zone and remain there,  --may have to use a format track operation if seek if not successful.   diskAddress.cylinder ¬ landingCyl;  diskAddress.head ¬ 0;  diskAddress.sector ¬ 0;  -- Try seek to landingCyl first, if fail then use formatTrack!  Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation         	    command: diskNoOp,      		    device: deviceHandle,		    clientHeader: diskAddress,		    pageCount: 1,  -- Do it one at a time		    tries: DiskChannel.defaultTries, 		    labelPtr: Misc.labels[0],		    dataPtr: Misc.dataPages[0],		    incrementDataPtr: FALSE];      ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;    IF ioStatus # [disk[status:goodCompletion]] THEN     { -- Odi.PutMessage[message: duMessage[seekFailed], numOfBlankLines: 1,     	--	 clearMessageAreaFirst: FALSE];      Misc.labeledOp­ ¬ [ -- diskOp has the info needed to carry out an operation       		    command: formatTrack,      		    device: deviceHandle,		    clientHeader: diskAddress,		    pageCount: 16,  -- 16 for format		    tries: 1,       -- was DiskChannel.defaultTries 		    labelPtr: Misc.labels[0],		    dataPtr: Misc.dataPages[0],		    incrementDataPtr: FALSE];       Misc.SetDriveStateTo[direct]; 	--allows format command      ioStatus ¬ DiskChannel.DoDirectIO[Misc.op].status;};    IF ioStatus # [disk[status:goodCompletion]]    THEN BEGIN         Odi.PutMessage[message: duMessage[diskError],	 	        numOfBlankLines: 1,			clearMessageAreaFirst: FALSE];	 Odi.PutMessage[message: duMessage[notRetracted],			clearMessageAreaFirst: FALSE];	 RETURN [FALSE];	 END;  RETURN [TRUE];  END;  FreezeMachine: PRIVATE PROCEDURE [] =   BEGIN  loop: BOOLEAN ¬ FALSE;  Odi.PutMessage[message: duMessage[powerOff],  		 numOfBlankLines: 1,    		 clearMessageAreaFirst: FALSE];  UNTIL loop = TRUE DO    -- Intended to be Nothing    ENDLOOP;        END;--***************************************************************************-- --***************************************************************************InitOpPtrs: PUBLIC PROC = {    opStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED;    rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;    residentHeapError: ERROR = CODE;    status: Zone.Status;    diskOpAlign: CARDINAL ¬ DiskChannel.diskOpWordAlignment;             -- Set up global DiskChannel.DirectOperation data structure    [opStorage, status] ¬ ResidentHeap.MakeNode[      n: DiskChannel.operationSize + diskOpAlign - 1,      alignment: a1];    IF status = okay THEN { -- Successfully allocated space       rpDirOp ¬ opStorage;       op ¬ @Environment.first64K[rpDirOp];       op ¬ LOOPHOLE[((LOOPHOLE[op, LONG CARDINAL] +                      SIZE[DiskChannel.DiskChannelPrivate] + diskOpAlign - 1) / 		     diskOpAlign) * diskOpAlign - 		     SIZE[DiskChannel.DiskChannelPrivate]] }    ELSE ERROR residentHeapError;        labeledOp ¬ LOOPHOLE[@op.diskOp, CompatibilityDiskFace.OperationPtr];    firstAllowableBP ¬ pagesPerTrack*movingHeads;    labelSpaceSize ¬ -- The size of the label space       (sectorsPerTrack*CompatibilityDiskFace.labelSize/Environment.wordsPerPage)+1;    pointerToLabelSpace ¬ Odi.GetSpace[labelSpaceSize];    pointerToDataSpace ¬ Odi.GetSpace[sectorsPerTrack];        -- Allocate containers to hold pointers to data pages and labels    dataPages ¬ Odi.DiagHeap.NEW [Misc.DataPages[sectorsPerTrack]];    labels ¬ Odi.DiagHeap.NEW [Misc.Labels[sectorsPerTrack]];    saveOpStatus ¬ Odi.DiagHeap.NEW [Misc.SaveOpStatus[sectorsPerTrack]];    restoreOpStatus ¬ Odi.DiagHeap.NEW [Misc.SaveOpStatus[sectorsPerTrack]];        -- Now assign the pointers to the arrays    FOR i: CARDINAL IN [0 .. sectorsPerTrack) DO        labels[i] ¬ pointerToLabelSpace + i*CompatibilityDiskFace.labelSize;        dataPages[i] ¬ pointerToDataSpace + i*PilotDiskFace.dataSize        ENDLOOP;  };   --~~~~~~~~~~~~~~~~-- Main Line Code--~~~~~~~~~~~~~~~~    labelSpaceSize: PUBLIC CARDINAL;  -- Pages for holding the labels on a track    pointerToLabelSpace: PUBLIC LONG POINTER;  -- For holding labels on a track    pointerToDataSpace: PUBLIC LONG POINTER;  -- For holding data off a track    labels: PUBLIC LONG POINTER TO Misc.Labels;    dataPages: PUBLIC LONG POINTER TO Misc.DataPages;    saveOpStatus: PUBLIC LONG POINTER TO Misc.SaveOpStatus;  -- Save status    restoreOpStatus: PUBLIC LONG POINTER TO Misc.SaveOpStatus;  -- Restore status        op: PUBLIC LONG POINTER TO DiskChannel.DirectOperation;    labeledOp: PUBLIC LONG POINTER TO CompatibilityDiskFace.Operation;         BEGIN  -- Get disk parameters    ENABLE ANY => { Odi.PutMessage[message: duMessage[problemAccessingDrive],    				   beep: TRUE]; PauseAndQuit[] };      -- Set up drive parameters      driveIndex ¬ PV.GetNextDrive [PV.nullDeviceIndex];        IF driveIndex = PV.nullDeviceIndex THEN {  -- No drive configured         Odi.PutMessage[ message: duMessage[problemAccessingDrive], beep: TRUE];          PauseAndQuit[] };      pvHandle ¬ PhysicalVolume.GetHandle [driveIndex];        -- totalPagesOnADisk = total pages on physical volume.      -- Total number of pages for holding Pilot volumes is:      --      (totalPagesOnADisk - firstPilotPage)      --      [firstPilotPage, totalPagesOnADisk, pagesPerTrack, pagesPerCylinder]          ¬ FormatPilotDisk.DiskInfo[pvHandle];      deviceHandle ¬ PilotDiskFace.GetNextDevice[PilotDiskFace.nullDeviceHandle];      [cylinders, movingHeads, fixedHeads, sectorsPerTrack]  -- Drive specifics          ¬ PilotDiskFace.GetDeviceAttributes [deviceHandle]      END;  -- Get drive info block                -- Get pointer to message key file--    duMessage ¬ DiskUtilityMsgKeysDove.duMessage;       END...  DiskUtilitiesMiscImplDove  LOGCreated by KL on 26-Jul-855-Dec-85: Print bad page stuffs added by RRP17-Sep-86 12:23:01: InitOpPtrs added by SPL18-Mar-87  8:44:24 by STC, added StartInit in ReadCuurentBPT22-Mar-87 12:16:45 by STC, change message system12-May-87 11:15:03 by STC, move DisplayBadPageTable, PrintBadPageTable here15-May-87  7:15:54 by STC, add CollectNewBadPage22-May-87 10:12:00 by STC, add CheckPVPages and repair the bad page29-May-87 12:42:28 by STC, allow fix bad pages even PVPages is no good 5-Jun-87 13:25:44, fix bug in garbage PVRootPage 6-Jul-87 17:19:08, Allow test Root page13-Sep-87 11:43:29, STC, move HeadRetraction from OfflineDiskUtilitiesDove, seek 1st 1-Oct-87  8:55:27, STC, remove seekFailed message from HeadRetraction17-Dec-87 11:02:17, STC, initialize longestVolNameLength with 10 to avoid CRASH11-Mar-88 16:05:25, STC, initialize page, volume in ExpandPageNumber15-Mar-88 12:18:35, STC, remove trouble maker in GetSubVolumeName21-Sep-88  9:01:18, STC, merge to Labelless from SPL 21-Nov-86 16:07:2328-Sep-88  9:50:26, STC, use InterpretHandle to get the PV index 9-Oct-88 15:10:44, STC, check for Labeled system12-Oct-88 13:47:11, STC, Labelless, MarkDataLostPage, check Labeled Sytem 8-Jun-89 10:22:14, TXM, changed to use diskOpWordAlignment instead of constants			   in InitOpPtrs for labelless 8-Jun-89 11:42:26, TXM, added PV.Offline in ScavengeAPage 8-Jun-89 11:46:03, TXM, added label repair in RepairABadPage
-- File: DiagRDBasicTestImpl.mesa-- last edit: STC, 12-Oct-88  9:03:36-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY DiagDiskCmdDrive	USING	[MaxCylinder, MaxHead, MaxSector], DiagDiskMkIOCmd	USING	[mkIOCmd], DiagDiskMkMisc		USING	[mkMisc], DiagDiskTestControl	USING	[SetUpTestControl, TCSurfVer2], DiagRDErrorCheck	USING	[ECStandard1, ErrorCode, PublicErrorCheckArray, 				SoftErrorCount], DiagRDPVStuff, DiagRDSurfaceVerify	USING	[BadPageCount, SurfaceVerify,				DisplaySoftErrors], DiagRDTestRec		USING	[RunTestArray, Subtest], DiagRDTests		USING	[InitializeTestStuff, CallService,				 PassCount, PutGoodCompletion, Switch,				 DisplayTestParameters], DiskUtilityMiscDove	USING	[CheckPVPages, InitStarted, 	StartInit, virginDisk], OfflineDiagInterface	USING	[AbortCurrentTest, 	GetAHelpText, GetYesNo, HelpText, HitAnyKeyToContinue,	PutData, PutMessage, ResultType, userType], OthelloOps		USING	[GetNextSubVolume, nullSubVolume, SubVolume], PhysicalVolume		USING	[AssertPilotVolume, Error, FinishWithNonPilotVolume, GetNext, Handle, ID, nullID, Offline], DiagRDBasicTest	USING	[];  DiagRDBasicTestImpl: PROGRAM    IMPORTS        DiagDiskCmdDrive,	DiagDiskMkIOCmd,	DiagDiskMkMisc,	DiagDiskTestControl,	DiagRDErrorCheck,	DiagRDPVStuff,	DiagRDSurfaceVerify,	DiagRDTestRec,	DiagRDTests,	DiskUtilityMiscDove,	OfflineDiagInterface,	OthelloOps,	PhysicalVolume   EXPORTS	DiagRDBasicTest = BEGIN    OPEN	DiagDiskMkIOCmd,	DiagDiskMkMisc,	Odi: OfflineDiagInterface;	  runTimeForSmallDisk: CARDINAL = 110;  runTimeForMidDisk: CARDINAL = 170;  runTimeForLargeDisk: CARDINAL = 240;  diagCylinderExists: PUBLIC BOOLEAN ¬ FALSE;  InRunUnit: PUBLIC BOOLEAN ¬ FALSE;   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to verify the operation of all units -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ConfidenceTest: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] = BEGIN runTime: LONG CARDINAL ¬ IF DiagDiskCmdDrive.MaxCylinder < 700 THEN runTimeForMidDisk ELSE runTimeForLargeDisk; getPassCnt: BOOLEAN¬ TRUE; PassCntTotal: CARDINAL ¬ 0; softErrorAllow: CARDINAL ¬ 0; stopOnError: BOOLEAN ¬ FALSE; cntDiff: ARRAY [0..7] OF CARDINAL ¬ [0,0,0,0,0,0,0,0];  GetAllowCnt: PROC =   BEGIN   SELECT ((DiagDiskCmdDrive.MaxCylinder + 1)*   		(DiagDiskCmdDrive.MaxHead + 1)) FROM      < 1300 => cntDiff ¬ [0,0,0,0,0,0,0,1]; -- 10MB      < 3500 => cntDiff ¬ [0,0,0,2,2,1,3,2]; -- 20MB      < 5000 => cntDiff ¬ [0,0,2,4,3,4,14,4]; -- 40MB      < 10000 => cntDiff ¬ [0,2,4,5,6,15,36,8]; -- 80MB      < 15000 => cntDiff ¬ [3,5,9,13,15,26,58,12]; -- 120MB      ENDCASE => cntDiff ¬ [4,8,11,13,17,37,80,16];   -- 160MB   END; CkSoftError: PROC RETURNS [Pass: BOOLEAN ¬ TRUE] =   BEGIN   SELECT (PassCntTotal - DiagRDTests.PassCount) FROM      < 11 => softErrorAllow ¬ 3;      < 26 => softErrorAllow ¬ 3 + cntDiff[1];      < 51 => softErrorAllow ¬ 3 + cntDiff[2];      < 101 => softErrorAllow ¬ 3 + cntDiff[3];      < 201 => softErrorAllow ¬ 5 + cntDiff[4];      < 401 => softErrorAllow ¬ 7 + cntDiff[5];      < 801 => softErrorAllow ¬ 8 + cntDiff[6];      ENDCASE => softErrorAllow ¬       		((PassCntTotal - DiagRDTests.PassCount)/130)*cntDiff[7];   RETURN [Pass ¬ (softErrorAllow >= DiagRDErrorCheck.SoftErrorCount)];   END;  DiagRDTests.InitializeTestStuff[]; IF ~DiskUtilityMiscDove.InitStarted THEN DiskUtilityMiscDove.StartInit ELSE [] ¬ DiskUtilityMiscDove.CheckPVPages []; -- STC, 9-Oct-88 17:21:11   IF DiagRDTests.Switch[52] THEN {   Odi.PutMessage[message: IF diagCylinderExists THEN "Diag Cylinder exists"L ELSE "No Diag cylinder on this disk"L];   Odi.HitAnyKeyToContinue[];   };  GetAllowCnt[]; DiagRDErrorCheck.SoftErrorCount ¬ 0; DiagRDSurfaceVerify.BadPageCount ¬ 0; IF (Odi.userType = Programmer) THEN 	{IF (Odi.GetYesNo[mkMisc[continueOnErr], , TRUE, TRUE]) THEN		{stopOnError ¬ FALSE}} ELSE {stopOnError ¬ TRUE;}; IF NOT ((Odi.userType = Programmer) OR (Odi.userType = Manufacturing)) THEN 	stopOnError ¬ FALSE; -- FS don't want to stop the test!-- At first, verify PV.  IF NOT DiagRDPVStuff.VerifyPV[].ok THEN SIGNAL Odi.AbortCurrentTest;  -- Error message was already posted in VerifyPV.  IF NOT diagCylinderExists THEN Odi.PutMessage[message: mkIOCmd[diagCylinder], 		 beep: TRUE, clearMessageAreaFirst: TRUE]; DiagRDTests.PassCount¬ 1; UNTIL DiagRDTests.PassCount<= 0 DO   DiagRDTests.DisplayTestParameters[		getPassCount:		getPassCnt,		secondsPerPass:		runTime,		putTotalPassCount:	TRUE,		putPassesLeftToRun:	TRUE,		putTimePerPass:		TRUE,		putRunTimeLeft:		TRUE];   IF getPassCnt THEN PassCntTotal ¬ DiagRDTests.PassCount;   RunUnit[];   DiagRDTests.PassCount ¬ DiagRDTests.PassCount - 1;   getPassCnt¬ FALSE;   IF (NOT (CkSoftError[])) AND stopOnError THEN EXIT;    ENDLOOP; IF (((Odi.userType = Programmer) OR (Odi.userType = Manufacturing)) AND (NOT (CkSoftError[]))) THEN   	{	 Odi.PutMessage[message: mkMisc[spare2], beep: TRUE,	 	clearMessageAreaFirst: TRUE];	 DiagRDErrorCheck.ErrorCode ¬ 299;	 [] ¬ DiagRDSurfaceVerify.DisplaySoftErrors[];	 DiagRDErrorCheck.ErrorCode ¬ 270;	 DiagRDTests.CallService[fruCode: 2];	 result¬ none;} ELSE {IF DiagRDSurfaceVerify.BadPageCount = 0 THEN DiagRDTests.PutGoodCompletion[] ELSE DiagRDTests.CallService[fruCode: 4];}; -- BP found and not in BPT result¬ none; END; --BasicTest       -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to do a basic verification on a given Unit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  RunUnit: PROCEDURE[] = BEGIN subtestSelectArray1:	ARRAY [0..28] OF DiagRDTestRec.Subtest¬   [-- STClearLog,    STStartLog,			--start trace and error logging    STClearTrace,    STStartTrace,      STVrRdRdCyl0,		--verifies head and sector addressing(needs rrr)    STVrRdRdAllCyls,		--cylinder address test(needs rrr)       STVrWrWr0sLstScTrk0,	--write and read data pattern tests     STVrRdRdCmpLbDtLstScTrk0,	--  last sector on cylinder 0    STVrWrWr1sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWr5sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWrAsLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,   --label verify error logic test--    STVrVrRdLstScTrk0,--    STVrVrVrLstScTrk0,	--data verify error logic test--    STPassedLstCyl,	    	--read passed last cylinder    STIllegalOpr,	    	--check illegal operation       STVrRdNpLstScTrk0,		--different legal command test    STVrVrWrLstScTrk0,    STRecalCn,			--test recalibrate    STVrWrWr0sCylLstCn,		--VWW, VRR data pattern tests last cylinder    STVrAndRDAndCmpCylLstCn,	    STVrWrWr1sCylLstCn,	    STVrAndRDAndCmpCylLstCn,	    STVrWrWr5sCylLstCn,    STVrAndRDAndCmpCylLstCn,	    STWrWrWrLstCyl,		--format last cylinder    STVrWrWrAsCylLstCn,    STVrAndRDAndCmpCylLstCn,	    STWrAndRdAndVrCylLstCn,	--VWW, VRR, VVR, VVV data pattern last cylinder       STSeekRand1Cn,		--random seek test (double sector)    STSeekRand2Cn		--random seek test (single sector)   ]; subtestSelectArray2:	ARRAY [0..18] OF DiagRDTestRec.Subtest¬   [-- STClearLog,    STStartLog,			--start trace and error logging    STClearTrace,    STStartTrace,      STVrRdRdCyl0,		--verifies head and sector addressing(needs rrr)    STVrRdRdAllCyls,		--cylinder address test(needs rrr)       STVrWrWr0sLstScTrk0,	--write and read data pattern tests     STVrRdRdCmpLbDtLstScTrk0,	--  last sector on cylinder 0    STVrWrWr1sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWr5sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWrAsLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,   --label verify error logic test--    STVrVrRdLstScTrk0,--    STVrVrVrLstScTrk0,	--data verify error logic test--    STPassedLstCyl,	    	--read passed last cylinder    STIllegalOpr,	    	--check illegal operation       STVrRdNpLstScTrk0,		--different legal command test    STVrVrWrLstScTrk0,    STRecalCn,			--test recalibrate    STSeekRand1Cn,		--random seek test (double sector)    STSeekRand2Cn		--random seek test (single sector)   ];    InRunUnit ¬ TRUE; DiagRDTestRec.RunTestArray [	subtestSelectArray: 	  IF diagCylinderExists THEN DESCRIPTOR [subtestSelectArray1]	  ELSE DESCRIPTOR [subtestSelectArray2]]; DiagDiskTestControl.SetUpTestControl[controlData: 					DiagDiskTestControl.TCSurfVer2]; DiagRDErrorCheck.PublicErrorCheckArray¬ 					DESCRIPTOR [DiagRDErrorCheck.ECStandard1];   -- display title Odi.PutMessage[message: mkMisc[subtesT],		clearMessageAreaFirst: TRUE]; Odi.PutMessage[message: mkMisc[surfaceVerification], 		startWithNewLine: FALSE,		blankSpaces: 1]; DiagRDSurfaceVerify.SurfaceVerify[ 			retryCount: 9, 			displayData: TRUE,			returnOnError: FALSE,			callServiceOnError: FALSE,			showSoftError: FALSE]; InRunUnit ¬ FALSE; END; --RunUnit  CheckDiagCylinder: PUBLIC PROCEDURE =   BEGIN   diagCylinderExists ¬ DiagCylinderExists[!     ANY => GOTO exit];            EXITS exit => {       IF Odi.userType = NormalUser THEN diagCylinderExists ¬ FALSE       ELSE {         help: LONG POINTER TO Odi.HelpText ¬ Odi.GetAHelpText[1];         help.textBody[0] ¬ mkIOCmd[diagCylinderExpl];         diagCylinderExists ¬ Odi.GetYesNo[mkIOCmd[diagCylinder], help, TRUE, FALSE];	 };       };   END;    DiagCylinderExists: PROCEDURE RETURNS[exist: BOOLEAN] =    BEGIN    h: PhysicalVolume.Handle;    thisPVID: PhysicalVolume.ID ¬ PhysicalVolume.nullID;    pvID: PhysicalVolume.ID ¬ PhysicalVolume.nullID;    totalVolumeSize: LONG CARDINAL ¬ 0;    pvFound: BOOLEAN ¬ FALSE;    svFound: BOOLEAN ¬ FALSE;    expectedPages: LONG CARDINAL ¬ (DiagDiskCmdDrive.MaxCylinder - 2) *      (DiagDiskCmdDrive.MaxSector + 1) * (DiagDiskCmdDrive.MaxHead + 1);        IF DiskUtilityMiscDove.virginDisk  THEN RETURN[TRUE];      -- The rigid disk is unformatted. Return with TRUE to       -- do full test in confidence test.          h ¬ DiagRDPVStuff.GetVolumeHandle[];    PhysicalVolume.FinishWithNonPilotVolume[h];    thisPVID ¬ PhysicalVolume.AssertPilotVolume[h !      PhysicalVolume.Error => SELECT error FROM        alreadyAsserted => CONTINUE;	ENDCASE => GOTO exit];        DO      sV: OthelloOps.SubVolume ¬ OthelloOps.nullSubVolume;      IF (pvID ¬ PhysicalVolume.GetNext[pvID]) = PhysicalVolume.nullID THEN EXIT;      pvFound ¬ TRUE;      DO -- FOR Counting total volume size.	sV ¬ OthelloOps.GetNextSubVolume[pvID, sV];        IF sV = OthelloOps.nullSubVolume THEN EXIT;	svFound ¬ TRUE;	totalVolumeSize ¬ totalVolumeSize + sV.subVolumeSize + 1;        ENDLOOP;      ENDLOOP;        IF DiagRDTests.Switch[52] THEN {      Odi.PutData[data: "Threshold = "L, numberAfterData: expectedPages, startWithNewLine: TRUE];      Odi.PutData[data: "Actual Count = "L, numberAfterData: totalVolumeSize, startWithNewLine: TRUE];      Odi.PutData[data: "PVFound: "L, startWithNewLine: TRUE]; Odi.PutData[data: IF pvFound THEN "Yes"L ELSE "No"L];      Odi.PutData[data: "SVFound: "L, startWithNewLine: TRUE]; Odi.PutData[data: IF svFound THEN "Yes"L ELSE "No"L];      Odi.HitAnyKeyToContinue[];      };          PhysicalVolume.Offline[thisPVID];    RETURN[totalVolumeSize >= expectedPages OR totalVolumeSize = 0];        EXITS exit => RETURN[FALSE];    END; END....--of DiagRDBasicTestImpl.mesa LOG24-Sep-85 13:42:01, MXT	Corrected runtime of ConfidenceTest.27-Sep-85 13:17:01, MXT	Added CheckDiagCylinder.27-Feb-86  9:52:09, KL 9-Apr-86 19:19:23, MXT 1-Jul-87 14:36:10, STC	Fix UnFormat bug in CheckDiagCylinder.28-Aug-87 10:21:05, STC	remove STClearLog in RunUnit, add CkSoftError. 8-Sep-87 15:23:31, STC	remove TryCount, diagCylinderExists PUBLIC, = ¬ >=.11-Sep-87  7:11:30, STC	add InRunUnit, warning if NOT diagCylinderExists. 13-Sep-87 10:15:44, STC	use DiagRDSurfaceVerify.BadPageCount in Confidence Test.19-Sep-87 16:08:43, STC	VerifyPV only once in Confidence Test, add CkSoftError. 13-Nov-87 12:59:04, STC	CkSoftError only if Programmer or Manufacturing.  4-Oct-88 14:55:45, STC	Labelless11-Oct-88 20:13:19, STC	add CheckPVPages in ConfidenceTest    
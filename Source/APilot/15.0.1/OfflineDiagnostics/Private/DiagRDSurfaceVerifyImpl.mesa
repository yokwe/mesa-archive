-- File: DiagRDSurfaceVerifyImpl.mesa-- Last edited: STC, 13-Nov-87 16:06:44-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved. --DiagRDSurfaceVerifyImpl.mesaDIRECTORY  DiagDiskCmdDrive USING [    Cylinder, Head, Sector, MaxCylinder, MaxHead, MaxSector, SectorCount, TryCount,    RecalFirst, UseSameDataBuff],  DiagRDLog USING [ClearLog, ClearTrace, LogErrors, TraceCommands],  DiagDiskMkIOCmd USING [mkIOCmd],  DiagDiskMkMisc USING [mkMisc],  DiagDiskTestControl USING [    SetUpTestControl, ReturningOnSoftError, ReturningOnSoftErrorInTable,    TCSurfVer1],  DiagRDCmds USING [DataDataPtr, DiskCommand, DiskOpr, LabelDataPtr],  DiagRDDisplay USING [BadPage],  DiagRDErrorCheck USING [    BadPageNumber,    RemainingSectorCount, CheckStatus, ECStandard1, PublicErrorCheckArray,    Recovery, SoftErrorCount],  DiagRDPVStuff USING [PageToAddr],  DiagRDTests USING [    CallService, DisplayTestParameters, InitializeTestStuff, PassCount,    ReadDataBuffPtr, ReadLabelBuffPtr],  OfflineDiagInterface USING [GetANumber,    HitAnyKeyToContinue, PutMessage, ResultType],  DiagRDSurfaceVerify USING [];DiagRDSurfaceVerifyImpl: PROGRAM  IMPORTS    DiagDiskCmdDrive, DiagRDLog, DiagDiskMkMisc, DiagDiskMkIOCmd,    DiagDiskTestControl, DiagRDCmds, DiagRDDisplay, DiagRDErrorCheck,    DiagRDPVStuff, DiagRDTests, OfflineDiagInterface  EXPORTS DiagRDSurfaceVerify =  BEGIN OPEN DiagDiskMkMisc, DiagDiskMkIOCmd, Odi: OfflineDiagInterface;  BadPageCount: PUBLIC CARDINAL ¬ 0;  InSurfaceVerify: PUBLIC BOOLEAN ¬ FALSE;  LastRunUnit: PUBLIC CARDINAL;  LastRunUnitMaxHead: PUBLIC CARDINAL;  PassCountMem: CARDINAL;  runTime: CARDINAL ¬ 0;  --in seconds  runTimeForSmallDisk: CARDINAL = 70;  runTimeForMidDisk: CARDINAL = 110;  runTimeForLargeDisk: CARDINAL = 150;    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- verifies the disk surface and looks for bad pages not in the bad page table  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  VerifySurface: PUBLIC PROCEDURE    RETURNS [result: OfflineDiagInterface.ResultType] =    BEGIN    getPassCnt: BOOLEAN ¬ TRUE;    RetryCount: CARDINAL;    runTime ¬      SELECT TRUE FROM        DiagDiskCmdDrive.MaxCylinder = 305 => runTimeForSmallDisk,        DiagDiskCmdDrive.MaxCylinder IN [306..700] => runTimeForMidDisk,        ENDCASE => runTimeForLargeDisk;    -- clear the errors and trace    DiagRDTests.InitializeTestStuff[];    DiagRDLog.ClearLog[];    DiagRDLog.ClearTrace[];    DiagRDLog.LogErrors[];    DiagRDLog.TraceCommands[];    DiagDiskTestControl.SetUpTestControl[      controlData: DiagDiskTestControl.TCSurfVer1];    DiagRDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[      DiagRDErrorCheck.ECStandard1];    BadPageCount ¬ 0; -- STC, added 13-Sep-87 10:26:35    DiagRDTests.PassCount ¬ 1;    RetryCount ¬ Odi.GetANumber[prompt: "Enter RetryCount for checking the bad page: "L,	 	  lowLimit: 1, upperLimit: LAST[CARDINAL],		  defaultNumber: 9].number;    UNTIL DiagRDTests.PassCount <= 0 DO      DiagRDTests.DisplayTestParameters[        getPassCount: getPassCnt, secondsPerPass: runTime,        putPassesLeftToRun: TRUE, putTotalPassCount: TRUE, putTimePerPass: TRUE,        putRunTimeLeft: TRUE];      SurfaceVerify[retryCount: RetryCount];      DiagRDTests.PassCount ¬ DiagRDTests.PassCount - 1;      getPassCnt ¬ FALSE;      ENDLOOP;    IF BadPageCount = 0 THEN      Odi.PutMessage[message: mkMisc[noBadPageS], clearMessageAreaFirst: TRUE]    ELSE Odi.PutMessage[message: mkMisc[donE], clearMessageAreaFirst: TRUE];    Odi.HitAnyKeyToContinue[];    result ¬ none;    END;  --VerifySurface  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- does surface verification  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SurfaceVerify: PUBLIC PROCEDURE [    retryCount: CARDINAL ¬ 1, displayData: BOOLEAN ¬ TRUE,    returnOnError: BOOLEAN ¬ FALSE, callServiceOnError: BOOLEAN ¬ FALSE, showSoftError: BOOLEAN ¬ TRUE]     =    BEGIN    goodcompletion: BOOLEAN;    intable: BOOLEAN ¬ FALSE;    sectorsLeft: CARDINAL;    softError: BOOLEAN ¬ FALSE;    softErrInTable: BOOLEAN ¬ FALSE;    string: STRING ¬ [10];    CylinderCnt: CARDINAL;    InSurfaceVerify ¬ TRUE;    -- set up command parameters    DiagDiskCmdDrive.TryCount ¬ 1;    DiagDiskCmdDrive.UseSameDataBuff ¬ 1;    DiagDiskCmdDrive.RecalFirst ¬ 0;    DiagRDCmds.DiskCommand.header ¬ verify;    DiagRDCmds.DiskCommand.label ¬ read;    DiagRDCmds.DiskCommand.data ¬ read;    DiagRDCmds.LabelDataPtr ¬ DiagRDTests.ReadLabelBuffPtr;    DiagRDCmds.DataDataPtr ¬ DiagRDTests.ReadDataBuffPtr;    PassCountMem ¬ DiagRDTests.PassCount;    IF ((DiagRDTests.PassCount MOD 2) = 0) THEN DiagDiskCmdDrive.Cylinder ¬ 0      	ELSE DiagDiskCmdDrive.Cylinder ¬ DiagDiskCmdDrive.MaxCylinder;    	--    BadPageCount ¬ 0;    CylinderCnt ¬ 0;    UNTIL CylinderCnt >= DiagDiskCmdDrive.MaxCylinder + 1 DO      softError ¬ FALSE;      softErrInTable ¬ FALSE;      DiagDiskCmdDrive.Head ¬ 0;      DiagDiskCmdDrive.Sector ¬ 0;      sectorsLeft ¬ DiagDiskCmdDrive.SectorCount ¬        (DiagDiskCmdDrive.MaxSector + 1) * (DiagDiskCmdDrive.MaxHead + 1);      goodcompletion ¬ FALSE;      UNTIL goodcompletion DO        DiagDiskCmdDrive.SectorCount ¬ sectorsLeft;        DiagRDCmds.DiskOpr[];        DiagRDErrorCheck.CheckStatus[          !          DiagDiskTestControl.ReturningOnSoftError => {            softError ¬ TRUE;            «Odi.PutMessage[              message: mkIOCmd[softErrDetected], clearMessageAreaFirst: TRUE];»            CONTINUE;            };          DiagDiskTestControl.ReturningOnSoftErrorInTable => {            softErrInTable ¬ TRUE; CONTINUE; }];        IF softErrInTable THEN {  -- set up cylinder/head/sector for bypassing bad page          sectorsLeft ¬ DiagRDErrorCheck.RemainingSectorCount - 1;          IF sectorsLeft = 0 THEN goodcompletion ¬ TRUE --i.e. last sector failed          ELSE [cylinder: DiagDiskCmdDrive.Cylinder, head: DiagDiskCmdDrive.Head,            sector: DiagDiskCmdDrive.Sector] ¬ DiagRDPVStuff.PageToAddr[            DiagRDErrorCheck.BadPageNumber + 1];          softErrInTable ¬ FALSE;          LOOP;          };        IF softError THEN {          failureCount: CARDINAL ¬ 0;          recovery: DiagRDErrorCheck.Recovery ¬ notCorrectable;          retryCountDown: CARDINAL ¬ retryCount;          MaxFailure: CARDINAL ¬ retryCount;          -- set up cylinder/head/sector from failing page number          [cylinder: DiagDiskCmdDrive.Cylinder, head: DiagDiskCmdDrive.Head,            sector: DiagDiskCmdDrive.Sector] ¬ DiagRDPVStuff.PageToAddr[            DiagRDErrorCheck.BadPageNumber];          sectorsLeft ¬ DiagRDErrorCheck.RemainingSectorCount - 1;          DiagDiskCmdDrive.SectorCount ¬ 1;          -- retry operation retryCountDown times          UNTIL retryCountDown = 0 DO            softError ¬ FALSE;            DiagRDCmds.DiskOpr[];            DiagRDErrorCheck.CheckStatus[              !              DiagDiskTestControl.ReturningOnSoftError => {                softError ¬ TRUE; CONTINUE; }];            IF softError THEN {failureCount ¬ failureCount + 1;	    		DiagRDErrorCheck.SoftErrorCount ¬	    			DiagRDErrorCheck.SoftErrorCount + 1};            retryCountDown ¬ retryCountDown - 1;            ENDLOOP;          -- **retry operation using ECC correction (not available yet)          <<	 softError¬ FALSE;	 DiagDiskCmdDrive.SectorCount¬ 2;	 DiagRDCmds.DiskOpr[];	 DiagRDErrorCheck.CheckStatus [	 ! DiagDiskTestControl.ReturningOnSoftError=>	   { softError¬ TRUE; CONTINUE;	   }];>>--          IF retryCountMem > failureCount THEN recovery ¬ retryCorrectable;          IF MaxFailure > failureCount THEN	  	 recovery ¬ retryCorrectable; -- The soft error is recoverble.          [cylinder: DiagDiskCmdDrive.Cylinder, head: DiagDiskCmdDrive.Head,            sector: DiagDiskCmdDrive.Sector] ¬ DiagRDPVStuff.PageToAddr[            DiagRDErrorCheck.BadPageNumber + 1];	  	  IF recovery = notCorrectable THEN { -- The page is really bad.	    BadPageCount ¬ BadPageCount + 1;	    IF displayData THEN { -- show the information and continue the test.	      Odi.PutMessage[	        message: mkIOCmd[softErrDetected], clearMessageAreaFirst: TRUE];	      DiagRDDisplay.BadPage[		pageNumber: DiagRDErrorCheck.BadPageNumber,		addTimesTriedFailed: TRUE, addRecovery: FALSE,		timesTried: retryCount + 1, timesFailed: failureCount + 1,		recovery: recovery];	       } -- of displayData # none	    ELSE -- quit the test as soon as possible.	      IF callServiceOnError THEN		DiagRDTests.CallService[fruCode: 4];	    } -- of recovery = notCorrectable	  ELSE	    IF showSoftError THEN {	      Odi.PutMessage[	      message: mkIOCmd[softErrDetected], clearMessageAreaFirst: TRUE];	      DiagRDDisplay.BadPage[		pageNumber: DiagRDErrorCheck.BadPageNumber,		addTimesTriedFailed: TRUE, addRecovery: FALSE,		timesTried: retryCount + 1, timesFailed: failureCount + 1,		recovery: recovery];	      };          IF sectorsLeft = 0 THEN goodcompletion ¬ TRUE;  --i.e. last sector failed          softError ¬ FALSE;          LOOP;          };        goodcompletion ¬ TRUE;        ENDLOOP;  --goodcompletion      IF ((DiagRDTests.PassCount MOD 2) = 0) THEN      	  {DiagDiskCmdDrive.Cylinder ¬ DiagDiskCmdDrive.Cylinder + 1}	ELSE {DiagDiskCmdDrive.Cylinder ¬ DiagDiskCmdDrive.Cylinder - 1};      CylinderCnt ¬ CylinderCnt + 1;      IF (DiagDiskCmdDrive.Cylinder > DiagDiskCmdDrive.MaxCylinder) THEN EXIT      ENDLOOP;  -- CylinderCnt >= DiagDiskCmdDrive. MaxCylinder    InSurfaceVerify ¬ FALSE;    END;  END... -- of DiagRDSurfaceVerifyImpl.mesa	LOG27-Jan-86 18:06:03, MXT, Removed DisplaySoftErrors to DiagRDDisplayImpl17-Mar-86 11:55:04, MXT, Added showSoftError in SurfaceVerify to permit to show the soft error. 9-Apr-86 19:12:24, MXT, Added BadPageCount in SurfaceVerify.29-Apr-87  9:17:28, STC, Alternative direction in SurfaceVerify. 5-May-87 14:15:37, STC, SurfaceVerify called by RunUnit.31-Aug-87 17:20:48, STC, Pass-Fail on FailCounts.13-Sep-87 10:29:55, STC, use right BadPageCount in VerifySurface12-Nov-87 16:57:12, STC, fix cylinder overflow, and option retryCount
-- File SysConfigShowAllImpl.mesa-- Last edited:-- TXM	 7-Oct-89  9:53:27	add 2MB memory-- STC	 2-Oct-88 22:05:16	add add 4MB memory, Labelless-- STC	28-Jan-88 15:28:59	add cartridge tape in Floppy Drivers-- STC	17-Oct-87 18:29:59	convert to 14.0-- JPM	28-May-87 12:39:10	Replace temporary strings with new msgKey and msgKey1 strings.-- JPM	13-May-87 12:05:43	Add extra disk shape parms.-- RDM	 6-Feb-87 12:44:28	Fix daisy 4meg memory configuration.-- RDM	 3-Feb-87 12:09:31	Add daisy mem expansion.-- RDM	29-Jan-87 10:38:08	Add Horizon Disks.-- RDM  20-Jan-87 17:00:25	Add Mitsubishi, Fujitsu, & NEC rigid disks and printingScanningOption.-- RDM   9-Dec-86 13:03:46	Add error message for invalid EEProm read.-- RRP  14-May-86 13:21:51	added support for Turbo (extended) disks-- RRP  28-Jan-86 18:35:00	changes for 12.2-- Created		30-Jun-85 12:45:38	by: AMR-- Last edited:		 2-Oct-85 13:46:15	by: AMR<<	Copyright (C) 1985, 1986, 1987, 1988, 1989 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  EEpromDefs,  OfflineDiagInterface  USING [ OfflineDiagnosticProc,   				AbortCurrentTest,				DisplayItem,				OptionsRecord, AnOptionLine, GetAnOptionsRecord,				GetAnOptionLine, GetAnOption, GetYesNo,				GetAFixedPositionDisplayRecord, GetARow,			        FixedPositionDisplayRecord, ARow, 				DisplayFixedPositionData, PutMessage],  ProcessorFaceExtras	USING [Version, VersionResult],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, msgKey2, NumberToHex, statusPtr],  SysConfigChannelDefs  USING [ eePromPointer, eePromImage, Status],  SysConfigRigidDiskDefs USING [diskShapeImage, GetRigidDiskTypeString];    SysConfigShowAllImpl: PROGRAM	IMPORTS OfflineDiagInterface, ProcessorFaceExtras, SysConfigControlDefs, SysConfigChannelDefs, SysConfigRigidDiskDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs, EEpromDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- ConfigureShowAllEEprom:--******************************************************************************ConfigureShowAllEEprom: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    selected: CARDINAL;  initialEntry: BOOLEAN ¬ TRUE;  leftEdge: CARDINAL = 3;   -- For formatting display.   optionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [1];  -- Just one row of option here  optionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];       optionTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row    optionRow0.optionsOnALine[0].position ¬ leftEdge;  optionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  optionRow0.optionsOnALine[0].option ¬ msgKey[exitSelection];  -- %Change  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN ¬ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue ¬ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};  DO       [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: IF initialEntry THEN optionTable ELSE NIL,      optionPrompt: msgKey[blanks],      justDisplayTable:TRUE]; -- Example default           initialEntry ¬ FALSE;      [] ¬ ShowAllEEprom[];  -- Display the drive information    IF eePromImage.VersionEProm > EEpromDefs.VersionNumberROM OR    eePromImage.VersionRAM > EEpromDefs.VersionNumberRAM OR    eePromImage.VersionBadPages > EEpromDefs.VersionNumberBadPages    					THEN { Odi.PutMessage [msgKey1[badVersionNumber], TRUE, TRUE, , , FALSE]; };    					    selected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: IF initialEntry THEN optionTable ELSE NIL,      optionPrompt: msgKey[respondToPrompt], defaultOption: 1]; -- Example default            IF selected = 1 THEN Odi.AbortCurrentTest;  -- Exit requested      	    ENDLOOP;	  END;  -- ConfigureShowAllEEprom    ShowAllEEprom: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    SetUpRow: PROCEDURE[namePosition: CARDINAL, name: LONG STRING,			<<stringValue: LONG POINTER TO LONG STRING>>			valuePosition: CARDINAL]         RETURNS [displayItem: Odi.DisplayItem] =      BEGIN        displayItem.namePosition ¬ namePosition;	displayItem.name ¬ name;	displayItem.stringValue ¬ NIL;       	displayItem.valuePosition ¬ valuePosition;	RETURN[displayItem];      END;  leftEdge: CARDINAL = 3;   -- For formatting display.  maxNumberWidth: CARDINAL = 5;  -- Biggest number is 10 digits wide.   noNumericData: CARDINAL = 0;  aSpace: CARDINAL = 1;  xPosition: CARDINAL;  -- Number for tracking position on current line    information: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [23];  --  variable itemed rows of data       --PUT IN ALL THE CURRENT VALUES OUT OF THE TEMPORARY EEPROM IMAGE IN THE IOREGION      infoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 1 item on row  infoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 3 item  infoRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 3 item on row  infoRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 2 item  infoRow4: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 3 item on row  infoRow5: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 3 item  infoRow6: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 3 item  infoRow7: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  -- 3 item on row  infoRow8: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 2 item  infoRow9: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 2 item on row  infoRow10: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow11: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow12: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow13: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow14: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow15: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow16: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow17: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [3];  infoRow18: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  infoRow19: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [7];  infoRow20: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [7];  infoRow21: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [7];  infoRow22: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [5];    string1: LONG STRING ¬ [5];string2: LONG STRING ¬ [5];  string1[4] ¬ 'H; string2[4] ¬ 'H;        -- Now fill in the static fields of the display record        -- Fill in the screen Information record fields  information.displayTitle ¬ msgKey[contentsEEProm];  information.rows[0] ¬ infoRow0;  information.rows[1] ¬ infoRow1;  information.rows[2] ¬ infoRow2;  information.rows[3] ¬ infoRow3;  information.rows[4] ¬ infoRow4;  information.rows[5] ¬ infoRow5;  information.rows[6] ¬ infoRow6;  information.rows[7] ¬ infoRow7;  information.rows[8] ¬ infoRow8;  information.rows[9] ¬ infoRow9;  information.rows[10] ¬ infoRow10;  information.rows[11] ¬ infoRow11;  information.rows[12] ¬ infoRow12;  information.rows[13] ¬ infoRow13;  information.rows[14] ¬ infoRow14;  information.rows[15] ¬ infoRow15;  information.rows[16] ¬ infoRow16;  information.rows[17] ¬ infoRow17;  information.rows[18] ¬ infoRow18;  information.rows[19] ¬ infoRow19;  information.rows[20] ¬ infoRow20;  information.rows[21] ¬ infoRow21;  information.rows[22] ¬ infoRow22;    -- Now fill in the static fields of the display record  --  --  -- Fill in first row first item static data  infoRow0.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[ePromVersionNumber],    leftEdge + msgKey[ePromVersionNumber].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow0.rowItems[1] ¬ SetUpRow[xPosition, msgKey[ramVersionNumber],    xPosition + msgKey[ramVersionNumber].length + aSpace];  xPosition ¬ xPosition + 34;    infoRow0.rowItems[2] ¬ SetUpRow[xPosition, msgKey[badPageVersionNumber],    xPosition + msgKey[badPageVersionNumber].length + aSpace];  infoRow1.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[defaultBootDevice],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow1.rowItems[1] ¬ SetUpRow[xPosition, msgKey[defaultIcons],    noNumericData];  xPosition ¬ xPosition + 34;  infoRow1.rowItems[2] ¬ SetUpRow[xPosition, msgKey[displayrigid],    noNumericData];  infoRow2.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[displayfloppy],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow2.rowItems[1] ¬ SetUpRow[xPosition, msgKey[displayethernet],    noNumericData];  xPosition ¬ xPosition + 34;    infoRow2.rowItems[2] ¬ SetUpRow[xPosition, msgKey[rS232CBooting],    noNumericData];  infoRow3.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[screen],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow3.rowItems[1] ¬ SetUpRow[xPosition, msgKey[screentype],    noNumericData];  infoRow4.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[Xalignment],    leftEdge + msgKey[Xalignment].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow4.rowItems[1] ¬ SetUpRow[xPosition, msgKey[Yalignment],    xPosition + msgKey[Yalignment].length + aSpace];  xPosition ¬ xPosition + 34;    infoRow4.rowItems[2] ¬ SetUpRow[xPosition, msgKey[currentKeyboard],    noNumericData];  infoRow5.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[sectorsPerTrack],    leftEdge + msgKey[sectorsPerTrack].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow5.rowItems[1] ¬ SetUpRow[xPosition, msgKey[numberOfHeads],    xPosition + msgKey[numberOfHeads].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow5.rowItems[2] ¬ SetUpRow[xPosition, msgKey[cylindersPerDrive],    xPosition + msgKey[cylindersPerDrive].length + aSpace];  infoRow6.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[reduceWrCurCylinder],    leftEdge + msgKey[reduceWrCurCylinder].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow6.rowItems[1] ¬ SetUpRow[xPosition, msgKey[precompCylinder],    xPosition + msgKey[precompCylinder].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow6.rowItems[2] ¬ SetUpRow[xPosition, msgKey[displayRigid],    noNumericData];  infoRow7.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[landingZone],    leftEdge + msgKey[landingZone].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow7.rowItems[1] ¬ SetUpRow[xPosition, msgKey1[rpm],    xPosition + msgKey1[rpm].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow7.rowItems[2] ¬ SetUpRow[xPosition, msgKey1[vcmDisk],    noNumericData];  infoRow8.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[driveZero],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow8.rowItems[1] ¬ SetUpRow[xPosition, msgKey[driveOne],    noNumericData];  infoRow9.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[driveTwo],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow9.rowItems[1] ¬ SetUpRow[xPosition, msgKey[driveThree],    noNumericData];  infoRow10.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[hardwareVersion],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow10.rowItems[1] ¬ SetUpRow[xPosition, msgKey[checksum],    noNumericData];  xPosition ¬ xPosition + 34;  infoRow10.rowItems[2] ¬ SetUpRow[xPosition, msgKey[invertedChecksum],    noNumericData];  infoRow11.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[lowMemoryMPB],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow11.rowItems[1] ¬ SetUpRow[xPosition, msgKey[virtualMemorySize],    noNumericData];  xPosition ¬ xPosition + 34;  infoRow11.rowItems[2] ¬ SetUpRow[xPosition, msgKey[controlStoreSize],    noNumericData];  infoRow12.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[defaultBootDiag],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow12.rowItems[1] ¬ SetUpRow[xPosition, msgKey[defaultDiagnostics],    noNumericData];  xPosition ¬ xPosition + 34;  infoRow12.rowItems[2] ¬ SetUpRow[xPosition, msgKey[DCEdeviceType],    xPosition + msgKey[DCEdeviceType].length + aSpace];  infoRow13.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[DCEattributes],    leftEdge + msgKey[DCEattributes].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow13.rowItems[1] ¬ SetUpRow[xPosition, msgKey[DTEdeviceType],    xPosition + msgKey[DTEdeviceType].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow13.rowItems[2] ¬ SetUpRow[xPosition, msgKey[DTEattributes],    xPosition + msgKey[DTEattributes].length + aSpace];  infoRow14.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[PCOptionBoard],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow14.rowItems[1] ¬ SetUpRow[xPosition, msgKey[PCOptionHardware1],    xPosition + msgKey[PCOptionHardware1].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow14.rowItems[2] ¬ SetUpRow[xPosition, msgKey[PCOptionHardware2],    xPosition + msgKey[PCOptionHardware2].length + aSpace];  infoRow15.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[OptionBoardOne],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow15.rowItems[1] ¬ SetUpRow[xPosition, msgKey[attributes],    xPosition + msgKey[attributes].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow15.rowItems[2] ¬ SetUpRow[xPosition, msgKey[interruptAllocation],    xPosition + msgKey[interruptAllocation].length + aSpace];  infoRow16.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[OptionBoardTwo],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow16.rowItems[1] ¬ SetUpRow[xPosition, msgKey[attributes],    xPosition + msgKey[attributes].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow16.rowItems[2] ¬ SetUpRow[xPosition, msgKey[interruptAllocation],    xPosition + msgKey[interruptAllocation].length + aSpace];  infoRow17.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[OptionBoardThree],    noNumericData];  xPosition ¬ leftEdge + 34;  infoRow17.rowItems[1] ¬ SetUpRow[xPosition, msgKey[attributes],    xPosition + msgKey[attributes].length + aSpace];  xPosition ¬ xPosition + 34;  infoRow17.rowItems[2] ¬ SetUpRow[xPosition, msgKey[interruptAllocation],    xPosition + msgKey[interruptAllocation].length + aSpace];  infoRow18.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[addressLastParity1],    leftEdge + msgKey[addressLastParity1].length + aSpace];  xPosition ¬ leftEdge + 34;  infoRow18.rowItems[1] ¬ SetUpRow[xPosition, msgKey[addressLastParity2],    xPosition + msgKey[addressLastParity2].length + aSpace];  infoRow19.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[word1],    leftEdge + msgKey[word1].length + aSpace];  xPosition ¬ leftEdge + msgKey[word1].length + 8;  infoRow19.rowItems[1] ¬ SetUpRow[xPosition, msgKey[word2],    xPosition + msgKey[word2].length + aSpace];  xPosition ¬ xPosition + msgKey[word2].length + 8;  infoRow19.rowItems[2] ¬ SetUpRow[xPosition, msgKey[word3],    xPosition + msgKey[word3].length + aSpace];  xPosition ¬ xPosition + msgKey[word3].length + 8;  infoRow19.rowItems[3] ¬ SetUpRow[xPosition, msgKey[word4],    xPosition + msgKey[word4].length + aSpace];  xPosition ¬ xPosition + msgKey[word4].length + 8;  infoRow19.rowItems[4] ¬ SetUpRow[xPosition, msgKey[word5],    xPosition + msgKey[word5].length + aSpace];  xPosition ¬ xPosition + msgKey[word5].length + 8;  infoRow19.rowItems[5] ¬ SetUpRow[xPosition, msgKey[word6],    xPosition + msgKey[word6].length + aSpace];  xPosition ¬ xPosition + msgKey[word6].length + 8;  infoRow19.rowItems[6] ¬ SetUpRow[xPosition, msgKey[word7],    xPosition + msgKey[word7].length + aSpace];  infoRow20.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[word8],    leftEdge + msgKey[word8].length + aSpace];  xPosition ¬ leftEdge + msgKey[word8].length + 8;  infoRow20.rowItems[1] ¬ SetUpRow[xPosition, msgKey[word9],    xPosition + msgKey[word9].length + aSpace];  xPosition ¬ xPosition + msgKey[word9].length + 8;  infoRow20.rowItems[2] ¬ SetUpRow[xPosition, msgKey[word10],    xPosition + msgKey[word10].length + aSpace];  xPosition ¬ xPosition + msgKey[word10].length + 8;  infoRow20.rowItems[3] ¬ SetUpRow[xPosition, msgKey[word11],    xPosition + msgKey[word11].length + aSpace];  xPosition ¬ xPosition + msgKey[word11].length + 8;  infoRow20.rowItems[4] ¬ SetUpRow[xPosition, msgKey[word12],    xPosition + msgKey[word12].length + aSpace];  xPosition ¬ xPosition + msgKey[word12].length + 8;  infoRow20.rowItems[5] ¬ SetUpRow[xPosition, msgKey[word13],    xPosition + msgKey[word13].length + aSpace];  xPosition ¬ xPosition + msgKey[word13].length + 8;  infoRow20.rowItems[6] ¬ SetUpRow[xPosition, msgKey[word14],    xPosition + msgKey[word14].length + aSpace];  infoRow21.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[word15],    leftEdge + msgKey[word15].length + aSpace];  xPosition ¬ leftEdge + msgKey[word15].length + 8;  infoRow21.rowItems[1] ¬ SetUpRow[xPosition, msgKey[word16],    xPosition + msgKey[word16].length + aSpace];  xPosition ¬ xPosition + msgKey[word16].length + 8;  infoRow21.rowItems[2] ¬ SetUpRow[xPosition, msgKey[word17],    xPosition + msgKey[word17].length + aSpace];  xPosition ¬ xPosition + msgKey[word17].length + 8;  infoRow21.rowItems[3] ¬ SetUpRow[xPosition, msgKey[word18],    xPosition + msgKey[word18].length + aSpace];  xPosition ¬ xPosition + msgKey[word18].length + 8;  infoRow21.rowItems[4] ¬ SetUpRow[xPosition, msgKey[word19],    xPosition + msgKey[word19].length + aSpace];  xPosition ¬ xPosition + msgKey[word19].length + 8;  infoRow21.rowItems[5] ¬ SetUpRow[xPosition, msgKey[word20],    xPosition + msgKey[word20].length + aSpace];  xPosition ¬ xPosition + msgKey[word20].length + 8;  infoRow21.rowItems[6] ¬ SetUpRow[xPosition, msgKey[word21],    xPosition + msgKey[word21].length + aSpace];  infoRow22.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[word22],    leftEdge + msgKey[word22].length + aSpace];  xPosition ¬ leftEdge + msgKey[word22].length + 8;  infoRow22.rowItems[1] ¬ SetUpRow[xPosition, msgKey[word23],    xPosition + msgKey[word23].length + aSpace];  xPosition ¬ xPosition + msgKey[word23].length + 8;  infoRow22.rowItems[2] ¬ SetUpRow[xPosition, msgKey[word24],    xPosition + msgKey[word24].length + aSpace];  xPosition ¬ xPosition + msgKey[word24].length + 8;  infoRow22.rowItems[3] ¬ SetUpRow[xPosition, msgKey[word25],    xPosition + msgKey[word25].length + aSpace];  xPosition ¬ xPosition + msgKey[word25].length + 8;  infoRow22.rowItems[4] ¬ SetUpRow[xPosition, msgKey[word26],    xPosition + msgKey[word26].length + aSpace];  SetUpValues [infoRow0, infoRow1, infoRow2, infoRow3, infoRow4, infoRow5, infoRow6, infoRow7, infoRow8, infoRow9, infoRow10, infoRow11, infoRow12, infoRow13, infoRow14, infoRow15, infoRow16, infoRow17, infoRow18, infoRow19, infoRow20, infoRow21, infoRow22]; --isn't this a disgusting thing to do?        Odi.DisplayFixedPositionData [  -- Display the drive information       				displayData: information, upDateOnly: FALSE];				    END;	-- ShowAllEEprom  SetUpValues: PROCEDURE[infoRow0, infoRow1, infoRow2, infoRow3, infoRow4, infoRow5, infoRow6, infoRow7, infoRow8, infoRow9, infoRow10, infoRow11, infoRow12, infoRow13, infoRow14, infoRow15, infoRow16, infoRow17, infoRow18, infoRow19, infoRow20, infoRow21, infoRow22: LONG POINTER TO Odi.ARow] =    BEGIN    version: ProcessorFaceExtras.VersionResult ¬ ProcessorFaceExtras.Version[];        leftEdge: CARDINAL = 3;   -- For formatting display.    noNumericData: CARDINAL = 0;    aSpace: CARDINAL = 1;    tempValue:LONG CARDINAL;      string1: LONG STRING ¬ [5];string2: LONG STRING ¬ [5];    string1[4] ¬ 'H; string2[4] ¬ 'H;      infoRow0.rowItems[0].value ¬ eePromImage.VersionEProm;      infoRow1.rowItems[0].stringValue ¬	SELECT eePromImage.BootDevice FROM    	  none => msgKey[none],	  rigidDisk => msgKey[rigidDisk],	  floppyDisk => msgKey[floppyDisk],	  ethernet => msgKey[ethernet]	ENDCASE => msgKey[unknown];    IF infoRow1.rowItems[0].stringValue.length > 11    		THEN infoRow1.rowItems[0].stringValue.length ¬ 11;    infoRow1.rowItems[1].stringValue ¬       SELECT eePromImage.DefaultIcons FROM    	 normal => msgKey[present]       ENDCASE => msgKey[notPresent];    infoRow1.rowItems[2].stringValue ¬ 	SELECT eePromImage.RigidBooting FROM    	  notAllowed => msgKey[notAllowed]	ENDCASE => msgKey[allowed];    infoRow2.rowItems[0].stringValue ¬	SELECT eePromImage.FloppyBooting FROM    	  notAllowed => msgKey[notAllowed]	ENDCASE => msgKey[allowed];    infoRow2.rowItems[1].stringValue ¬ 	SELECT eePromImage.EthrenetBooting FROM    	  notAllowed => msgKey[notAllowed]	ENDCASE => msgKey[allowed];    infoRow2.rowItems[2].stringValue ¬	SELECT eePromImage.RS232CBooting FROM    	notAllowed => msgKey[notAllowed]	ENDCASE => msgKey[allowed];    infoRow3.rowItems[0].stringValue ¬	SELECT eePromImage.DisplayPresent FROM    	  none => msgKey[notPresent]	ENDCASE => msgKey[present];    infoRow3.rowItems[1].stringValue ¬	SELECT eePromImage.DisplayBWColor FROM    	  blackAndWhite => SELECT eePromImage.DisplaySize FROM	    small => SELECT eePromImage.DisplayMap FROM  	      bitMapType => msgKey1[smallBlackWhiteBitMapped],	    ENDCASE => msgKey1[smallBlackWhiteNotBitMapped],	  ENDCASE => SELECT eePromImage.DisplayMap FROM  	      bitMapType => msgKey1[largeBlackWhiteBitMapped],	    ENDCASE => msgKey1[largeBlackWhiteNotBitMapped],	ENDCASE => SELECT eePromImage.DisplaySize FROM	    small => SELECT eePromImage.DisplayMap FROM  	      bitMapType => msgKey1[smallColorBitMapped],	    ENDCASE => msgKey1[smallColorNotBitMapped],	  ENDCASE => SELECT eePromImage.DisplayMap FROM  	      bitMapType => msgKey1[largeColorBitMapped],	    ENDCASE => msgKey1[largeColorNotBitMapped];    infoRow4.rowItems[0].value ¬ LONG[eePromImage.DisplayxAlignment];    infoRow4.rowItems[1].value ¬ LONG[eePromImage.DisplayyAlignment];    infoRow4.rowItems[2].stringValue ¬	SELECT eePromImage.Keyboard FROM	  none => msgKey[none],  	  english => msgKey[englishKeyboard],  	  european => msgKey[europeanKeyboard],  	  japanese => msgKey[japaneseKeyboard],  	  learSiegler => msgKey[learSieglerKeyboard]	ENDCASE => msgKey[unknown];    infoRow5.rowItems[0].value ¬ LONG[eePromImage.RigidDiskSectorsPerTrack];    infoRow5.rowItems[1].value ¬ LONG[eePromImage.RigidDiskHeadsPerCylinder];    infoRow5.rowItems[2].value ¬ LONG[eePromImage.RigidDiskHeadsCylinderCount];    infoRow6.rowItems[0].value ¬ LONG[eePromImage.RigidDiskReducedWriteCylinder];    infoRow6.rowItems[1].value ¬      LONG[eePromImage.RigidDiskPreCompensationCylinder];    infoRow6.rowItems[2].stringValue ¬ SysConfigRigidDiskDefs.GetRigidDiskTypeString [eePromImage.RigidDiskType];    infoRow7.rowItems[0].value ¬ LONG[eePromImage.RigidDiskHeadLandingZone];    infoRow7.rowItems[1].value ¬ LONG[SysConfigRigidDiskDefs.diskShapeImage.rpm];    infoRow7.rowItems[2].stringValue ¬        IF SysConfigRigidDiskDefs.diskShapeImage.vcmDisk	  THEN msgKey1[yes]	  ELSE msgKey1[no];    infoRow8.rowItems[0].stringValue  ¬	SELECT eePromImage.FloppyDiskTypeDrive0 FROM      	  none => msgKey[notPresent],  	  kb360 => msgKey[kb360],  	  kb1200 => msgKey[kb1200],  	  fad5000 => msgKey[fad5000]  	ENDCASE => msgKey[unknown];    infoRow8.rowItems[1].stringValue  ¬	SELECT eePromImage.FloppyDiskTypeDrive1 FROM      	  none => msgKey[notPresent],  	  kb360 => msgKey[kb360],  	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]  	  ENDCASE => msgKey[unknown];    infoRow9.rowItems[0].stringValue  ¬	SELECT eePromImage.FloppyDiskTypeDrive2 FROM      	  none => msgKey[notPresent],  	  kb360 => msgKey[kb360],  	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]  	ENDCASE => msgKey[unknown];    infoRow9.rowItems[1].stringValue  ¬	SELECT eePromImage.FloppyDiskTypeDrive3 FROM      	  none => msgKey[notPresent],  	  kb360 => msgKey[kb360],  	  kb1200 => msgKey[kb1200],	  fad5000 => msgKey[fad5000]  	ENDCASE => msgKey[unknown];    infoRow0.rowItems[1].value ¬ eePromImage.VersionRAM;    NumberToHex[eePromImage.EEpromCheckSum,string1];    string1.length ¬ 5;    NumberToHex[eePromImage.EEpromInvertedCheckSum,string2];    string2.length ¬ 5;    IF version.machineType = daisy THEN {      infoRow11.rowItems[0].stringValue ¬	SELECT eePromImage.MainMemoryExpansion FROM	  mega1 => msgKey1[defaultMem],	  k1512 => msgKey1[mem1],	  mega2 => msgKey1[mem2],	  k2512 => msgKey1[mem3],	  mega3 => IF eePromImage.MainMemory8 = present AND	  	       eePromImage.MainMemory9 = present AND		       eePromImage.MainMemory10 = present AND		       eePromImage.MainMemory11 = present AND		       eePromImage.MainMemory12 = present AND		       eePromImage.MainMemory13 = present AND		       eePromImage.MainMemory14 = present AND		       eePromImage.MainMemory15 = present THEN msgKey1[mem5]		    ELSE msgKey1[mem4]	ENDCASE  => msgKey[unknown]}    ELSE {      IF eePromImage.MainMemory2 = notPresent AND	  eePromImage.MainMemory3 = notPresent AND	  eePromImage.MainMemory4 = notPresent AND	  eePromImage.MainMemory5 = notPresent AND	  eePromImage.MainMemory6 = notPresent AND	  eePromImage.MainMemory7 = notPresent      THEN {						-- Daybreak and Dahlia	infoRow11.rowItems[0].stringValue ¬	  SELECT eePromImage.MainMemoryExpansion FROM	    k512 => msgKey1[defaultMem],	    mega1 => msgKey1[mem1],	    k1512 => msgKey1[mem2],	    mega2 => msgKey1[mem3],	    k2512 => msgKey1[mem4],	    mega3 => msgKey1[mem5],	    ENDCASE  => msgKey[unknown]}      ELSE {						-- Duke and Diana	infoRow11.rowItems[0].stringValue ¬	  SELECT eePromImage.MainMemoryExpansion FROM	    k512 => msgKey1[defaultMem],	    mega1 => msgKey2[mem7],	    k1512 => msgKey1[mem2],	    mega2 => msgKey1[mem3],	    k2512 => msgKey1[mem4],	    mega3 => msgKey2[mem6],	    ENDCASE  => msgKey[unknown]}};    infoRow10.rowItems[0].stringValue ¬ SELECT eePromImage.HardwareVersion FROM    				       none => msgKey[none],				       B0B1 => msgKey[b0b1],				       B2 => msgKey[b2]				       ENDCASE => msgKey[unknown];    infoRow10.rowItems[1].stringValue ¬ string1;    infoRow10.rowItems[2].stringValue ¬ string2;<<    infoRow11.rowItems[0].stringValue ¬	SELECT eePromImage.MainMemoryExpansion FROM	  k512 => msgKey1[defaultMem],	  mega1 => msgKey1[mem1],	  k1512 => msgKey1[mem2],	  mega2 => msgKey1[mem3],	  k2512 => msgKey1[mem4],	  mega3 => msgKey1[mem5]	ENDCASE  => msgKey[unknown];>>    infoRow11.rowItems[1].stringValue ¬ SELECT eePromImage.VMMSizeInPages FROM    	     		vm8mega => msgKey[vm8mb],	     		vm16mega => msgKey[vm16mb],			vm32mega => msgKey[vm32mb]	     		ENDCASE => msgKey[unknown];    infoRow11.rowItems[2].stringValue ¬  SELECT eePromImage.ControlStoreSize FROM    	     		cs4k => msgKey[control4k],			cs16k => msgKey2[control16k],			cs8k => msgKey[control8k]	     		ENDCASE => msgKey[unknown];    infoRow12.rowItems[0].stringValue ¬ SELECT eePromImage.DefaultBootDiag FROM    							noDiags => msgKey[none]							ENDCASE => msgKey[run];    infoRow12.rowItems[1].stringValue ¬ SELECT eePromImage.DefaultDiagnostics FROM    							normal => msgKey[normal]							ENDCASE => msgKey[fast];    infoRow12.rowItems[2].value ¬ LONG[LOOPHOLE[eePromImage.DCEdeviceType]];    infoRow13.rowItems[0].value ¬ eePromImage.DCEattributes;    infoRow13.rowItems[1].value ¬ LONG[LOOPHOLE[eePromImage.DTEdeviceType]];    infoRow13.rowItems[2].value ¬ eePromImage.DTEattributes;        tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionBoard]];    infoRow14.rowItems[0].stringValue ¬ IF tempValue = 0  					THEN msgKey[notPresent]					ELSE msgKey[present];        tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionHardware1]];    IF tempValue = 0 THEN {       infoRow14.rowItems[1].valuePosition ¬ noNumericData;       infoRow14.rowItems[1].stringValue ¬ msgKey[none];}    ELSE       infoRow14.rowItems[1].value ¬ LOOPHOLE[LONG[eePromImage.PCOptionHardware1]];           tempValue ¬ LONG[LOOPHOLE[eePromImage.PCOptionHardware2]];    IF tempValue = 0 THEN {       infoRow14.rowItems[2].valuePosition ¬ noNumericData;       infoRow14.rowItems[2].stringValue ¬ msgKey[none];}    ELSE       infoRow14.rowItems[2].value ¬ eePromImage.PCOptionHardware2;           infoRow15.rowItems[0].stringValue ¬      SELECT eePromImage.OptionBoardOne.optionType FROM	none => msgKey[notPresent],	laserPrintingOption => msgKey[laserPrintingOption],	printingScanningOption => msgKey[printingScanningOption],      ENDCASE => NIL;    IF infoRow15.rowItems[0].stringValue = NIL THEN      {infoRow15.rowItems[0].stringValue ¬ msgKey[unknown];       infoRow15.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +         msgKey[OptionBoardOne].length + aSpace;       infoRow15.rowItems[0].value ¬          LONG[LOOPHOLE[eePromImage.OptionBoardOne.optionType]]};    infoRow15.rowItems[1].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardOne.optionSpecificData]];    infoRow15.rowItems[2].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardOne.expansionInterruptAllocation]];    infoRow16.rowItems[0].stringValue ¬      SELECT eePromImage.OptionBoardTwo.optionType FROM	none => msgKey[notPresent],	laserPrintingOption => msgKey[laserPrintingOption],	printingScanningOption => msgKey[printingScanningOption],      ENDCASE => NIL;    IF infoRow16.rowItems[0].stringValue = NIL THEN      {infoRow16.rowItems[0].stringValue ¬ msgKey[unknown];       infoRow16.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +         msgKey[OptionBoardTwo].length + aSpace;       infoRow16.rowItems[0].value ¬          LONG[LOOPHOLE[eePromImage.OptionBoardTwo.optionType]]};    infoRow16.rowItems[1].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardTwo.optionSpecificData]];    infoRow16.rowItems[2].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardTwo.expansionInterruptAllocation]];    infoRow17.rowItems[0].stringValue ¬      SELECT eePromImage.OptionBoardThree.optionType FROM	none => msgKey[notPresent],	laserPrintingOption => msgKey[laserPrintingOption],	printingScanningOption => msgKey[printingScanningOption],      ENDCASE => NIL;    IF infoRow17.rowItems[0].stringValue = NIL THEN      {infoRow17.rowItems[0].stringValue ¬ msgKey[unknown];       infoRow17.rowItems[0].valuePosition ¬ leftEdge + msgKey[unknown].length +         msgKey[OptionBoardThree].length + aSpace;       infoRow17.rowItems[0].value ¬          LONG[LOOPHOLE[eePromImage.OptionBoardThree.optionType]]};    infoRow17.rowItems[1].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardThree.optionSpecificData]];    infoRow17.rowItems[2].value ¬       LONG[LOOPHOLE[eePromImage.OptionBoardThree.expansionInterruptAllocation]];           infoRow0.rowItems[2].value ¬ eePromImage.VersionBadPages;    infoRow18.rowItems[0].value ¬ eePromImage.AddressLastParity[0];    infoRow18.rowItems[1].value ¬ eePromImage.AddressLastParity[1];    FOR i: CARDINAL IN [0..7) DO infoRow19.rowItems[i].value ¬      eePromPointer[i+eepromBadPageOffset]; ENDLOOP;    FOR i: CARDINAL IN [0..7) DO infoRow20.rowItems[i].value ¬      eePromPointer[i+eepromBadPageOffset+7]; ENDLOOP;    FOR i: CARDINAL IN [0..7) DO infoRow21.rowItems[i].value ¬      eePromPointer[i+eepromBadPageOffset+14]; ENDLOOP;    FOR i: CARDINAL IN [0..5) DO infoRow22.rowItems[i].value ¬      eePromPointer[i+eepromBadPageOffset+21]; ENDLOOP;    END;	-- SetUpValuesEND.logcreated on 30-Jun-85 12:45:38 by Allen Roberts
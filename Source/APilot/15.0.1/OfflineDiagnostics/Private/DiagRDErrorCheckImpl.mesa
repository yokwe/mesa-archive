-- File: DiagRDErrorCheckImpl.mesa-- Copyright (C) 1984, 1985 , 1986, 1986, 1986, 1986, 1986, 1986, 1986 by Xerox Corporation. All rights reserved. -- Last edited: STC, 5-Oct-88 10:46:02, Lebelless----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--FAILURE CODE DESCRIPTION--	1= Replace IOP, Cable, Drive--	2= Replace Drive, IOP, Cable--	3= Drive media problem (repairable with scavenger?.--	   if not Replace Drive, IOP, Cable)--	4= Bad page not in bad page table (repairable with scavenger? or--	   bad page utility? if not Replace Drive, IOP, Cable)--	5= Reserved--	6= Physical Volume problem (possibly repairable with--	   physical volume scavenger?)--	7= Software problem (get analyst help)--	8= Real time clock error, Run Ethernet Diagnostic--	915(in cursor)= Software problem (get analyst help)--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~DIRECTORY  DiagDiskBuff USING [CompareHeader, -- CompareLabel,-- CompareData],  DiagDiskCmdDrive USING [Cylinder, Head, MaxCylinder,    MaxSector, MaxHead, ParamArrayL1, Sector, SectorCount, UseSameDataBuff],  DiagDiskTestControl USING [    CheckBadPageTable, CheckForError, CheckSoftErrorCount, ContinueOnHardError,    ContinueOnSoftError, CountSubtestSoftErrors, DisplaySoftErrors,    IgnoreSoftErrors, MaxErrorsPerHead, MaxSoftErrorsTotal, RepeatCommand,    RetryOnSameSector, ReturnAfterCommand, ReturnOnHardError, ReturningOnHardError,    ReturnOnSoftError, ReturningOnSoftError, ReturnOnSoftErrorInTable,    ReturningOnSoftErrorInTable, ReturningAfterCommand, SectorPlus1OnSoftError,    VerifyHeader, -- VerifyLabel,-- VerifyData],  DiagRDCmds USING [    CmdTimeOut, DiskCommand, DiskChannelStatus, DataSize,--LabelSize,-- OpPtr],  DiagRDDisplay USING [BadPage],  DiagRDLog USING [LogEvent],  DiagRDPVStuff USING [BadPageInTable],  DiagRDTests USING [CallService,ReadDataBuffPtr,--ReadLabelBuffPtr,-- Switch],  DiskIOFaceDuke USING [DeviceStatus],  PhysicalVolume USING [lastPageNumber, PageNumber],  OfflineDiagInterface USING [    AbortCurrentTest, PutData --, HitAnyKeyToContinue, PutMessage-- ],  --String			USING	[AppendNumber],  DiagRDErrorCheck USING [expectedStatus];DiagRDErrorCheckImpl: PROGRAM  IMPORTS    DiagDiskBuff, DiagDiskCmdDrive, DiagRDDisplay, DiagRDLog, DiagDiskTestControl,    DiagRDCmds, DiagRDPVStuff, DiagRDTests, OfflineDiagInterface  EXPORTS DiagRDErrorCheck =  BEGIN OPEN Odi: OfflineDiagInterface;  BadPageNumber: PUBLIC PhysicalVolume.PageNumber;  BadPageCount: PUBLIC CARDINAL ¬ 0;  BadPageSpace: PUBLIC ARRAY [0..256) OF PhysicalVolume.PageNumber;  BadPageSpaceCount: PUBLIC ARRAY [0..256) OF CARDINAL;  DataError: BOOLEAN ¬ FALSE;  DataErrorIndex: PUBLIC CARDINAL;  DataErrorExpected: PUBLIC CARDINAL;  DataErrorObserved: PUBLIC CARDINAL;  DiagDataError: BOOLEAN ¬ FALSE;  ErrorCode: PUBLIC CARDINAL ¬ 0;  FruCode: PUBLIC CARDINAL ¬ 0;  HardError: PUBLIC BOOLEAN ¬ FALSE;  HeaderError: BOOLEAN ¬ FALSE;  LabelError: BOOLEAN ¬ FALSE;  PublicErrorCheckArray: PUBLIC LONG DESCRIPTOR FOR PACKED ARRAY OF    DiagRDErrorCheck.expectedStatus;  HeadErrorArray: PUBLIC ARRAY [0..18] OF CARDINAL ¬ ALL[0];  RemainingSectorCount: PUBLIC CARDINAL;  SoftError: PUBLIC BOOLEAN ¬ FALSE;  SoftErrorInTable: PUBLIC BOOLEAN ¬ FALSE;  SoftErrorCount: PUBLIC CARDINAL ¬ 0;  SubtestSoftErrorCount: PUBLIC CARDINAL ¬ 0;  SoftErrorsInAPass: CARDINAL ¬ 0;  abortAfterErrorLog: BOOLEAN ¬ FALSE;  HeadErrorArrayInAPass: ARRAY [0..18] OF CARDINAL ¬ ALL[0];  prevPage: PhysicalVolume.PageNumber ¬ PhysicalVolume.lastPageNumber;  retryCount: CARDINAL ¬ 0;  -- for checking previous write op  BadWrCount: PUBLIC CARDINAL ¬ 0;  BadWrSpace: PUBLIC ARRAY [0..128) OF PhysicalVolume.PageNumber;  -- error masks arrays  ECStandard1: PUBLIC PACKED ARRAY [0..26] OF DiagRDErrorCheck.expectedStatus;  ECDtVrErr: PUBLIC PACKED ARRAY [0..23] OF DiagRDErrorCheck.expectedStatus;  ECLbVrErr: PUBLIC PACKED ARRAY [0..23] OF DiagRDErrorCheck.expectedStatus;  ECIllegalCylErr: PUBLIC PACKED ARRAY [0..12] OF DiagRDErrorCheck.expectedStatus;  ECTrack00True: PUBLIC PACKED ARRAY [0..12] OF DiagRDErrorCheck.expectedStatus;  ECTrack00False: PUBLIC PACKED ARRAY [0..12] OF DiagRDErrorCheck.expectedStatus;  ECIllegalOpr: PUBLIC PACKED ARRAY [0..09] OF DiagRDErrorCheck.expectedStatus;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to verify the given status bits in the given sequence  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CheckStatus: PUBLIC PROCEDURE [    errorArray: LONG DESCRIPTOR FOR PACKED ARRAY OF      DiagRDErrorCheck.expectedStatus ¬ PublicErrorCheckArray] =    BEGIN    OPEN      deviceStatus: LOOPHOLE[DiagRDCmds.OpPtr.deviceStatus,        DiskIOFaceDuke.DeviceStatus];    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    DoSoftErrorStuff: PROCEDURE [softErr: BOOLEAN]      RETURNS [softError: BOOLEAN ¬ FALSE, exit: BOOLEAN ¬ FALSE] =      BEGIN      IF softErr AND DiagDiskTestControl.IgnoreSoftErrors THEN RETURN;--      IF softErr AND DiagDiskTestControl.CountSubtestSoftErrors THEN {--        SubtestSoftErrorCount ¬ SubtestSoftErrorCount - 1; };      IF softErr AND DiagDiskTestControl.CheckBadPageTable THEN {        GenBadPageNumber[];  --puts the bad page number into BadPageNumber        SoftErrorInTable ¬ DiagRDPVStuff.BadPageInTable[          badPage: BadPageNumber !          Odi.AbortCurrentTest => {            SoftErrorInTable ¬ FALSE; abortAfterErrorLog ¬ TRUE; CONTINUE}];        IF NOT SoftErrorInTable THEN		{ SoftErrorCount ¬ SoftErrorCount + 1;		  IF DiagDiskTestControl.CountSubtestSoftErrors THEN		     {SubtestSoftErrorCount ¬ SubtestSoftErrorCount - 1;};		 softError ¬ TRUE; FruCode ¬ 2; exit ¬ TRUE; }        ELSE exit ¬ TRUE;        };      IF softErr AND NOT DiagDiskTestControl.CheckBadPageTable THEN {        GenBadPageNumber[];  --puts the bad page number into BadPageNumber        softError ¬ TRUE;        FruCode ¬ 2;        exit ¬ TRUE;        };      END;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Keep Tracking pages unsuccessfully written    LogBadWr: PROC =      BEGIN      c: CARDINAL ¬ 0;      alreadyLog: BOOLEAN ¬ FALSE;      badPage: PhysicalVolume.PageNumber;      --first check if it has allready been detected      GenBadPageNumber[];      UNTIL c = BadWrCount DO        badPage ¬ BadWrSpace[c];	IF badPage = BadPageNumber THEN {alreadyLog ¬ TRUE; EXIT};	c ¬ c + 1;	ENDLOOP;      IF NOT alreadyLog THEN        { IF BadWrCount < 128 THEN	   { BadWrSpace[BadWrCount] ¬ BadPageNumber;	     BadWrCount ¬ BadWrCount + 1;}	   ELSE {HardError ¬ TRUE; ErrorCode ¬ 270; FruCode ¬ 1; };};      END;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- If page in the BadWr list then skip the verification    InBadWrList: PROC RETURNS [yes: BOOLEAN ¬ FALSE] =      BEGIN      c: CARDINAL ¬ 0;      badPage: PhysicalVolume.PageNumber;      --first check if it has allready been detected      GenBadPageNumber[];      UNTIL c = BadWrCount DO        badPage ¬ BadWrSpace[c];	IF badPage = BadPageNumber THEN {yes ¬ TRUE; EXIT};	c ¬ c + 1;	ENDLOOP;      RETURN [yes];      END;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    cnt: CARDINAL ¬ 0;    exit: BOOLEAN ¬ FALSE;    VWWOp: BOOLEAN ¬ FALSE;    statusPtr: DiagRDErrorCheck.expectedStatus;    ErrorCode ¬ 0;    FruCode ¬ 0;    HardError ¬ FALSE;    HeaderError ¬ FALSE;    LabelError ¬ FALSE;    DataError ¬ FALSE;    DiagDataError ¬ FALSE;    SoftError ¬ FALSE;    SoftErrorInTable ¬ FALSE;    abortAfterErrorLog ¬ FALSE;    deviceStatus ¬ LOOPHOLE[DiagRDCmds.OpPtr.deviceStatus];    -- return if nothing to check    IF BASE[errorArray] = NIL THEN RETURN;    -- return if not checking for errors    IF NOT DiagDiskTestControl.CheckForError THEN {ErrorReport[]; RETURN; };    «IF DiagRDTests.Switch [2] THEN { ptr:	CARDINAL ¬ 0;   str: STRING¬ [8];   Odi.PutMessage[message: "STATUS SELECTION ARRAY: ",		clearMessageAreaFirst: TRUE];   UNTIL ptr= LENGTH [errorArray] DO     str.length¬ 0;     String.AppendNumber[str, ORD[errorArray [ptr]], 10];     Odi.PutMessage[message: str];     Odi.PutMessage[message: ", "];     ptr¬ ptr+ 1;   ENDLOOP;   Odi.HitAnyKeyToContinue[]; };»    VWWOp ¬ ((DiagRDCmds.DiskCommand.header = verify)	      AND (DiagRDCmds.DiskCommand.label = write)	      AND (DiagRDCmds.DiskCommand.data = write)	      AND ((DiagDiskCmdDrive.Cylinder = 0) OR		(DiagDiskCmdDrive.Cylinder = DiagDiskCmdDrive.MaxCylinder)));    UNTIL cnt = LENGTH[errorArray] OR HardError OR SoftError OR exit DO      statusPtr ¬ errorArray[cnt];      SELECT statusPtr FROM        -- 0        inProgressFalse => {          IF deviceStatus.inProgress THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 1        inProgressTrue => {          IF NOT deviceStatus.inProgress THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 2        completeFalse => {          IF deviceStatus.complete THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 3        completeTrue => {          IF NOT deviceStatus.complete THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        errorDetectedFalse => {        -- 4 	  IF deviceStatus.errorDetected THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 5        errorDetectedTrue => {          IF NOT deviceStatus.errorDetected THEN {HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 6        communicationErrorFalse => {          IF deviceStatus.communicationError THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 7        communicationErrorTrue => {          IF NOT deviceStatus.communicationError THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 8        dmaTimeoutFalse => {          IF deviceStatus.dmaTimeout THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 9 not used        -- 10        fifoErrorFalse => {          IF deviceStatus.fifoError THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 11 not used        -- 12        illegalOperationFalse => {          IF deviceStatus.illegalOperation THEN {HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 13        illegalOperationTrue => {          IF NOT deviceStatus.illegalOperation THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 14        readyFalse => {          IF deviceStatus.ready THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 15 not used        -- 16        protocolViolationFalse => {          IF deviceStatus.protocolViolation THEN {HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 17 not used        -- 18        writeFaultFalse => {          IF deviceStatus.writeFault THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 19 not used        -- 20        illegalCylinderFalse => {          IF deviceStatus.illegalCylinder THEN {HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 21        illegalCylinderTrue => {          IF NOT deviceStatus.illegalCylinder THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 22        track00False => {          IF deviceStatus.track00 THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 23        track00True => {          IF NOT deviceStatus.track00 THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 32        sectorNotFoundFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.sectorNotFound];	  IF SoftError AND VWWOp THEN LogBadWr[];          };        -- 33 not used        -- 34        headerCRCErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.headerCRCError];	  IF SoftError AND VWWOp THEN LogBadWr[];          };        -- 35        headerCRCErrorTrue => {          IF NOT deviceStatus.headerCRCError THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 36        labelAddressMarkErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.labelAddressMarkError];	  IF SoftError AND VWWOp THEN LogBadWr[];          };        -- 37 not used        -- 38        labelIDErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.labelIDError];          };        -- 39 not used        -- 40        labelVerifyErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.labelVerifyError];          };        -- 41        labelVerifyErrorTrue => {          IF NOT deviceStatus.labelVerifyError THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 42        labelCRCErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.labelCRCError];          };        -- 43        labelCRCErrorTrue => {          IF NOT deviceStatus.labelCRCError THEN {HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 44        dataAddressMarkErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.dataAddressMarkError];	  IF SoftError AND VWWOp THEN LogBadWr[];          };        -- 45 not used        -- 46        dataIDErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.dataIDError];          };        -- 47 not used        -- 48        dataVerifyErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.dataVerifyError];          };        -- 49        dataVerifyErrorTrue => {          IF NOT deviceStatus.dataVerifyError THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 50        dataCRCorECCErrorFalse => {          [softError: SoftError, exit: exit] ¬ DoSoftErrorStuff[            softErr: deviceStatus.dataCRCorECCError];          };        -- 51        dataCRCorECCErrorTrue => {          IF NOT deviceStatus.dataCRCorECCError THEN {            HardError ¬ TRUE; FruCode ¬ 1; };          };        -- 66        cmdTimedOutFalse => {          IF DiagRDCmds.CmdTimeOut THEN {HardError ¬ TRUE; FruCode ¬ 1; }; };        -- 68        invalidChannelFalse => {          WITH s: DiagRDCmds.DiskChannelStatus SELECT FROM            invalidChannel => {HardError ¬ TRUE; FruCode ¬ 4};            ENDCASE;          };        -- 69        invalidDriveStateFalse => {          WITH s: DiagRDCmds.DiskChannelStatus SELECT FROM            invalidDriveState => {HardError ¬ TRUE; FruCode ¬ 4};            ENDCASE;          };        -- 70        goodCompletionFalse => {          WITH s: DiagRDCmds.DiskChannelStatus SELECT FROM            disk =>              IF s.status = goodCompletion THEN {HardError ¬ TRUE; FruCode ¬ 4};            ENDCASE;          };        -- 71        goodCompletionTrue => {          WITH s: DiagRDCmds.DiskChannelStatus SELECT FROM            disk =>              IF s.status # goodCompletion THEN {HardError ¬ TRUE; FruCode ¬ 4};            ENDCASE;          };        -- 80        verifyHeader => {          IF DiagDiskTestControl.VerifyHeader            AND DiagRDCmds.DiskCommand.header = read            AND NOT deviceStatus.sectorNotFound	    AND NOT deviceStatus.headerCRCError            THEN {            multi: BOOLEAN;            se: BOOLEAN;            he: BOOLEAN;            ce: BOOLEAN;            fl: BOOLEAN;            bit: CARDINAL;            [multiBitError: multi, cylinderError: ce, headError: he,              sectorError: se, failsLow: fl, bit: bit] ¬              DiagDiskBuff.CompareHeader[];            IF multi THEN {HeaderError ¬ TRUE; HardError ¬ TRUE; FruCode ¬ 1; }            ELSE {              IF se THEN  -- sector error                {                HeaderError ¬ TRUE;                ErrorCode ¬ 250 + bit * 2;                IF NOT fl THEN ErrorCode ¬ ErrorCode + 1;                HardError ¬ TRUE;                FruCode ¬ 1;                };              IF he THEN  -- head error                {                HeaderError ¬ TRUE;                ErrorCode ¬ 230 + bit * 2;                IF NOT fl THEN ErrorCode ¬ ErrorCode + 1;                HardError ¬ TRUE;                FruCode ¬ 1;                };              IF ce THEN  -- cylinder error                {                HeaderError ¬ TRUE;                ErrorCode ¬ 200 + bit * 2;                IF NOT fl THEN ErrorCode ¬ ErrorCode + 1;                HardError ¬ TRUE;                FruCode ¬ 1;                };              };            };          };        -- STC, Labelless removed this	-- 81        <<verifyLabel => {          IF DiagDiskTestControl.VerifyLabel            AND DiagRDCmds.DiskCommand.label = read            AND NOT deviceStatus.labelAddressMarkError            AND NOT deviceStatus.labelIDError	    AND NOT deviceStatus.labelCRCError	    AND NOT InBadWrList[] THEN            {IF DiagDiskBuff.CompareLabel[              data: DiagDiskCmdDrive.ParamArrayL1[0].LabelDataMem,              goodDataPtr: DiagDiskCmdDrive.ParamArrayL1[0].WriteLabelPtr,              compareDataPtr: DiagRDTests.ReadLabelBuffPtr,              size: DiagRDCmds.LabelSize].labelError THEN {              LabelError ¬ TRUE; HardError ¬ TRUE; FruCode ¬ 1; };};          };>>        -- 82        verifyData => {          IF DiagDiskTestControl.VerifyData	    AND DiagRDCmds.DiskCommand.data = read            AND NOT deviceStatus.dataAddressMarkError            AND NOT deviceStatus.dataIDError	    AND NOT deviceStatus.dataCRCorECCError            AND NOT InBadWrList[] THEN	    {IF DiagDiskBuff.CompareData[              goodDataPtr: DiagDiskCmdDrive.ParamArrayL1[0].WriteDataPtr,              compareDataPtr: DiagRDTests.ReadDataBuffPtr,              size:              IF DiagDiskCmdDrive.UseSameDataBuff = 1 THEN DiagRDCmds.DataSize              ELSE DiagDiskCmdDrive.SectorCount*DiagRDCmds.DataSize].dataError                THEN {DataError ¬ TRUE; HardError ¬ TRUE; FruCode ¬ 1; };};          };        -- 200: Cylinder Address Bit 001 fails low        -- 201: Cylinder Address Bit 001 fails high        -- 202: Cylinder Address Bit 002 fails low        -- 203: Cylinder Address Bit 002 fails high        -- 204: Cylinder Address Bit 004 fails low        -- 205: Cylinder Address Bit 004 fails high        -- 206: Cylinder Address Bit 008 fails low        -- 207: Cylinder Address Bit 008 fails high        -- 208: Cylinder Address Bit 016 fails low        -- 219: Cylinder Address Bit 016 fails high        -- 210: Cylinder Address Bit 032 fails low        -- 211: Cylinder Address Bit 032 fails high        -- 212: Cylinder Address Bit 064 fails low        -- 213: Cylinder Address Bit 064 fails high        -- 214: Cylinder Address Bit 128 fails low        -- 215: Cylinder Address Bit 128 fails high        -- 216: Cylinder Address Bit 256 fails low        -- 217: Cylinder Address Bit 256 fails high        -- 218: Cylinder Address Bit 512 fails low        -- 219: Cylinder Address Bit 512 fails high        -- 220: Cylinder Address Bit 1024 fails low        -- 221: Cylinder Address Bit 1024 fails high        -- 230: Head Address Bit 01 fails low        -- 231: Head Address Bit 01 fails high        -- 232: Head Address Bit 02 fails low        -- 233: Head Address Bit 02 fails high        -- 234: Head Address Bit 04 fails low        -- 235: Head Address Bit 04 fails high        -- 236: Head Address Bit 08 fails low        -- 237: Head Address Bit 08 fails high        -- 238: Head Address Bit 16 fails low        -- 239: Head Address Bit 16 fails high        -- 250: Sector Address Bit 01 fails low        -- 251: Sector Address Bit 01 fails high        -- 252: Sector Address Bit 02 fails low        -- 253: Sector Address Bit 02 fails high        -- 254: Sector Address Bit 04 fails low        -- 255: Sector Address Bit 04 fails high        -- 256: Sector Address Bit 08 fails low        -- 257: Sector Address Bit 08 fails high        -- 258: Sector Address Bit 16 fails low        -- 259: Sector Address Bit 16 fails high        -- 260: Sector Address Bit 32 fails low        -- 261: Sector Address Bit 32 fails high        -- 270: too many total soft errors        -- 271: too many soft errors in last subtest        -- 280: Head  0 too many soft errors        -- 281: Head  1 too many soft errors        -- 282: Head  2 too many soft errors        -- 283: Head  3 too many soft errors        -- 284: Head  4 too many soft errors        -- 285: Head  5 too many soft errors        -- 286: Head  6 too many soft errors        -- 287: Head  7 too many soft errors        -- 288: Head  8 too many soft errors        -- 289: Head  9 too many soft errors        -- 290: Head 10 too many soft errors        -- 291: Head 11 too many soft errors        -- 292: Head 12 too many soft errors        -- 293: Head 13 too many soft errors        -- 294: Head 14 too many soft errors        -- 295: Head 15 too many soft errors        -- 296: Head 16 too many soft errors        -- 297: Head 17 too many soft errors        -- 298: Head 18 too many soft errors        -- 299: Head 19 too many soft errors        ENDCASE;      cnt ¬ cnt + 1;      ENDLOOP;    IF ErrorCode = 0 THEN ErrorCode ¬ ORD[statusPtr];    ErrorReport[];    END;  --CheckStatus  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- reports the given error  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ErrorReport: PROCEDURE =    BEGIN    intable: BOOLEAN ¬ FALSE;    IF SoftError THEN      --keep the bad page if not already kept      {      c: CARDINAL ¬ 0;      badPage: PhysicalVolume.PageNumber;      --first check if it has allready been detected      UNTIL c = BadPageCount DO        badPage ¬ BadPageSpace[c];        IF badPage = BadPageNumber THEN {          intable ¬ TRUE; BadPageSpaceCount[c] ¬ BadPageSpaceCount[c] + 1; EXIT; };        c ¬ c + 1;        ENDLOOP;      IF NOT intable «OR DiagDiskTestControl.RetryOnSameSector» THEN {        SoftErrorsInAPass ¬ SoftErrorsInAPass + 1;        IF BadPageCount < 256 THEN {          BadPageSpace[BadPageCount] ¬ BadPageNumber;          BadPageSpaceCount[c] ¬ BadPageSpaceCount[c] + 1;          BadPageCount ¬ BadPageCount + 1;          HeadErrorArrayInAPass[DiagRDCmds.OpPtr.clientHeader.head] ¬            HeadErrorArrayInAPass[DiagRDCmds.OpPtr.clientHeader.head] + 1;          HeadErrorArray[DiagRDCmds.OpPtr.clientHeader.head] ¬            HeadErrorArray[DiagRDCmds.OpPtr.clientHeader.head] + 1;          };        }; -- of NOT intable	      -- BadPageNumber is a current page.      -- Retry Check.      IF DiagDiskTestControl.RetryOnSameSector THEN {	IF BadPageNumber = prevPage THEN {  -- retry	  retryCount ¬ retryCount + 1}	ELSE {  -- start of retry	  retryCount ¬ 0; prevPage ¬ BadPageNumber; };	};      --display soft error?      IF NOT intable AND DiagDiskTestControl.DisplaySoftErrors THEN        DiagRDDisplay.BadPage[pageNumber: BadPageNumber];      --too many soft errors?      IF DiagDiskTestControl.CheckSoftErrorCount THEN {        IF SoftErrorsInAPass >= DiagDiskTestControl.MaxSoftErrorsTotal          OR            (DiagDiskTestControl.RetryOnSameSector              AND retryCount >= DiagDiskTestControl.MaxSoftErrorsTotal) THEN {          ErrorCode ¬ 270; FruCode ¬ 2; SoftError ¬ FALSE; HardError ¬ TRUE; };        IF HeadErrorArrayInAPass[DiagRDCmds.OpPtr.clientHeader.head] >=          DiagDiskTestControl.MaxErrorsPerHead THEN {          ErrorCode ¬ 280 + DiagRDCmds.OpPtr.clientHeader.head;          FruCode ¬ 2;          SoftError ¬ FALSE;          HardError ¬ TRUE;          };        IF DiagDiskTestControl.CountSubtestSoftErrors AND SubtestSoftErrorCount = 0          THEN {          ErrorCode ¬ 271; FruCode ¬ 2; SoftError ¬ FALSE; HardError ¬ TRUE; };        };      };  --end of soft error stuff    -- For debugging.    IF DiagRDTests.Switch[1] THEN {      GenBadPageNumber[]; DiagRDDisplay.BadPage[pageNumber: BadPageNumber]};    DiagRDLog.LogEvent[      hardwareError: HardError OR SoftError, headerError: HeaderError,      labelError: LabelError, dataError: DataError, diagDataError: DiagDataError];    IF abortAfterErrorLog THEN SIGNAL Odi.AbortCurrentTest;--    IF DiagDiskTestControl.RetryOnSameSector AND (SoftErrorInTable OR SoftError)    IF DiagDiskTestControl.RetryOnSameSector AND SoftError      THEN DiagDiskTestControl.RepeatCommand ¬ TRUE;    IF DiagDiskTestControl.RetryOnSameSector AND NOT SoftError      AND NOT SoftErrorInTable AND DiagDiskTestControl.RepeatCommand THEN      DiagDiskTestControl.RepeatCommand ¬ FALSE;    IF DiagDiskTestControl.SectorPlus1OnSoftError      AND (SoftErrorInTable OR SoftError) THEN {      DiagDiskTestControl.RepeatCommand ¬ TRUE;      DiagDiskCmdDrive.Sector ¬ DiagDiskCmdDrive.Sector + 1;      IF DiagDiskCmdDrive.Sector >= DiagDiskCmdDrive.MaxSector + 1 THEN {        HardError ¬ TRUE;        SoftError ¬ FALSE;        FruCode ¬ 1;        DiagDiskTestControl.RepeatCommand ¬ FALSE;        DiagDiskCmdDrive.Sector ¬ 0;        };      };    IF DiagDiskTestControl.SectorPlus1OnSoftError AND NOT SoftError      AND NOT SoftErrorInTable AND DiagDiskTestControl.RepeatCommand THEN {      DiagDiskTestControl.RepeatCommand ¬ FALSE; DiagDiskCmdDrive.Sector ¬ 0; };    IF DiagDiskTestControl.ReturnAfterCommand THEN      SIGNAL DiagDiskTestControl.ReturningAfterCommand;    IF DiagDiskTestControl.ReturnOnSoftErrorInTable AND SoftErrorInTable THEN      SIGNAL DiagDiskTestControl.ReturningOnSoftErrorInTable;    IF DiagDiskTestControl.ReturnOnSoftError AND SoftError THEN      SIGNAL DiagDiskTestControl.ReturningOnSoftError;    IF DiagDiskTestControl.ReturnOnHardError AND HardError THEN      SIGNAL DiagDiskTestControl.ReturningOnHardError;    IF HardError AND DiagDiskTestControl.ContinueOnHardError THEN RETURN;    IF SoftError AND DiagDiskTestControl.ContinueOnSoftError THEN RETURN;    -- call service    IF HardError OR SoftError THEN DiagRDTests.CallService[fruCode: FruCode];    END;  --ErrorReport  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- message operator that the unit is not found  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GenBadPageNumber: PUBLIC PROCEDURE =    BEGIN    RemainingSectorCount ¬ DiagRDCmds.OpPtr.pageCount;    BadPageNumber ¬ DiagDiskCmdDrive.Cylinder;    BadPageNumber ¬      (BadPageNumber * (DiagDiskCmdDrive.MaxSector + 1) *         (DiagDiskCmdDrive.MaxHead + 1));    BadPageNumber ¬      BadPageNumber + (DiagDiskCmdDrive.Head * (DiagDiskCmdDrive.MaxSector + 1)) +        (DiagDiskCmdDrive.Sector) +        (DiagDiskCmdDrive.SectorCount - RemainingSectorCount);    END;  --GenBadPageNumber--  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- message operator that the unit is not found  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitErrorCheck: PUBLIC PROCEDURE =    BEGIN    HeadErrorArray ¬ ALL[0];    BadPageCount ¬ 0;    BadPageSpace ¬ ALL[0];    BadPageSpaceCount ¬ ALL[0];    BadWrCount ¬ 0;    BadWrSpace ¬ ALL[0];    ResetIntermediateResults[];    END;  ResetIntermediateResults: PUBLIC PROCEDURE =    BEGIN    SoftErrorsInAPass ¬ 0;    HeadErrorArrayInAPass ¬ ALL[0];    retryCount ¬ 0;    prevPage ¬ PhysicalVolume.lastPageNumber    END;  ShowIntermediateResults: PUBLIC PROCEDURE =    BEGIN    Odi.PutData[      data: "Soft Error Count on this pass = "L,      numberAfterData: SoftErrorsInAPass, startWithNewLine: TRUE];    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Main line Code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ECStandard1 ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationFalse,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    writeFaultFalse,  -- 18    illegalCylinderFalse,  -- 20    --soft errors    sectorNotFoundFalse,  -- 32    headerCRCErrorFalse,  -- 34    labelAddressMarkErrorFalse,  -- 36    labelIDErrorFalse,  -- 38    labelVerifyErrorFalse,  -- 40    labelCRCErrorFalse,  -- 42    dataAddressMarkErrorFalse,  -- 44    dataIDErrorFalse,  -- 46    dataVerifyErrorFalse,  -- 48    dataCRCorECCErrorFalse,  -- 50    errorDetectedFalse,  --  4    inProgressFalse,  --  0    completeTrue,  --  3    verifyHeader,  -- 80    verifyLabel,  -- 81    verifyData];  -- 82  ECDtVrErr ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationFalse,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    writeFaultFalse,  -- 18    illegalCylinderFalse,  -- 20    --soft errors    sectorNotFoundFalse,  -- 32    headerCRCErrorFalse,  -- 34    labelAddressMarkErrorFalse,  -- 36    labelIDErrorFalse,  -- 38    labelVerifyErrorFalse,  -- 40    labelCRCErrorFalse,  -- 42    dataAddressMarkErrorFalse,  -- 44    dataIDErrorFalse,  -- 46    dataVerifyErrorTrue,  -- 49    dataCRCorECCErrorFalse,  -- 50    errorDetectedTrue,  --  5    inProgressFalse,  --  0    completeTrue];  --  3  ECLbVrErr ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationFalse,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    writeFaultFalse,  -- 18    illegalCylinderFalse,  -- 20    --soft errors    sectorNotFoundFalse,  -- 32    headerCRCErrorFalse,  -- 34    labelAddressMarkErrorFalse,  -- 36    labelIDErrorFalse,  -- 38    labelVerifyErrorTrue,  -- 41    labelCRCErrorFalse,  -- 42    dataAddressMarkErrorFalse,  -- 44    dataIDErrorFalse,  -- 46    dataVerifyErrorFalse,  -- 48    dataCRCorECCErrorFalse,  -- 50    errorDetectedTrue,  --  5    inProgressFalse,  --  0    completeTrue];  --  3  ECIllegalCylErr ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationFalse,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    illegalCylinderTrue,  -- 21    errorDetectedTrue,  --  5    inProgressFalse,  --  0    completeTrue];  --  1  ECTrack00True ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationFalse,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    track00True,  -- 23    errorDetectedTrue,  --  5    inProgressFalse,  --  0    completeTrue];  --  1  ECTrack00False ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationFalse,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    track00False,  -- 22    errorDetectedTrue,  --  5    inProgressFalse,  --  0    completeTrue];  --  1  ECIllegalOpr ¬ [    invalidChannelFalse,  -- 68    invalidDriveStateFalse,  -- 69    cmdTimedOutFalse,  -- 66    communicationErrorFalse,  --  6    dmaTimeoutFalse,  --  8    fifoErrorFalse,  -- 10    illegalOperationTrue,  -- 12    protocolViolationFalse,  -- 16    readyTrue,  -- 15    errorDetectedTrue];  --  5  InitErrorCheck[];  END....LOG27-Jan-86 12:31:29, MXT, 20-May-87  4:34:10, STC, Stop if SNF on VWW cylinders 0 or last20-May-87  7:03:36, STC, removed ErrorCode 426-May-87  5:30:50, STC, Stop if softerrors on some pages in Cylinder 012-Jun-87 11:49:37, STC, fix a bug in SoftError Reporting28-Aug-87 17:39:16, STC, redo 1-81, Pass-Fail, Cylinder011-Sep-87  8:35:00, STC, remove CkCyl0Pgs, add LogBadWr and InBadWrList12-Sep-87 14:14:33, STC, do not RepeatCommand IF SoftErrorInTable12-Sep-87 14:14:33, STC, SoftError ¬ softError29-Sep-88 11:02:48, STC, Labelless, DiskIOFaceDove ¬ DiskIOFaceDuke 5-Oct-88 10:42:06, STC, Labelless, removed VerifyLabel (81)
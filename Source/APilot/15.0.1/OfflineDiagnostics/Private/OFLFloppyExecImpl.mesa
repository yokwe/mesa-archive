-- File: OFLFloppyExecImpl.mesa - last edit:-- STC	 1-Feb-88 13:25:58-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  BackingStore USING [Run],  CMDiagMsgKeysDove USING[cmMsgKeys, DiagMessages],  File USING [Type],  FileTypes USING [tUntypedFile],  Floppy USING [    Close, Error, ErrorType, FileHandle, GetFileAttributes, GetNextFile,    nullFileID, nullVolumeHandle, Open, Read, VolumeHandle],  Environment USING [ «bitsPerWord, » PageNumber],  OfflineDiagInterface,  OfflineDiagInterfaceExtra,  Process USING [Pause, SecondsToTicks],  Runtime USING [    ConfigError, ControlLink,    UnNewConfig, VersionMismatch],  --GetBuildTime, ],  Space USING [    Deallocate, Interval, LongPointerFromPage, nullInterval, PageFromLongPointer,    virtualMemory],  SpecialLoader USING [LoadConfig, MapProcType, UnmapProcType],  SpecialSpace USING [AllocateForCode],  VM USING [GetMapUnitAttributes, Interval, ScratchMap, Unmap];OFLFloppyExecImpl: PROGRAM  IMPORTS    CMDiagMsgKeysDove, Floppy, OfflineDiagInterface, OfflineDiagInterfaceExtra,     Process, Runtime, Space, SpecialLoader,    SpecialSpace, VM  EXPORTS OfflineDiagInterfaceExtra =  BEGIN  OPEN CMDiagMsgKeysDove, ODI: OfflineDiagInterface,    OdiExtra: OfflineDiagInterfaceExtra;  TryAgain: SIGNAL = CODE;  GiveUp: SIGNAL = CODE;  NoFile: SIGNAL = CODE;  prevConfig: PROGRAM ¬ NIL;  nullFile: Floppy.FileHandle = [Floppy.nullVolumeHandle, Floppy.nullFileID];  -- ~~~~~~~~~~~~~~~~~~~~~~~~  -- PUBLIC PROCs for OdiExtra.  -- ~~~~~~~~~~~~~~~~~~~~~~~~  EraseLoadedConfig: PUBLIC PROCEDURE = {    IF prevConfig # NIL THEN {      ODI.PutMessage[        message: cmMsgKeys[unloading], clearMessageAreaFirst: TRUE];      Runtime.UnNewConfig[LOOPHOLE[prevConfig]];      ODI.PutMessage[message: cmMsgKeys[finished], startWithNewLine: FALSE]}    ELSE {      ODI.PutMessage[message: cmMsgKeys[cantErase], clearMessageAreaFirst: TRUE, beep: TRUE];       BlackHole[quit]};    };  ReadDiagnosticsPackage: PUBLIC PROCEDURE   = {    IF OdiExtra.ValidateClients[TRUE] THEN RETURN;    -- At least one Diagnostic client already exists.        ReadFloppy[];    };  -- ~~~~~~~~~~~~~~~~~~~~~~~~  -- Utility-Type Functions  -- ~~~~~~~~~~~~~~~~~~~~~~~~  Confirm: PROC [] = {    ODI.PutMessage[message: cmMsgKeys[insertDiskLabeled], numOfBlankLines: 1];    ODI.PutMessage[message: cmMsgKeys[diskForWSDiag], numOfBlankLines: 1];    ODI.PutMessage[message: cmMsgKeys[diskForScannerDiag], numOfBlankLines: 1];    ODI.PutMessage[message: cmMsgKeys[diskForCartTapeDiag], numOfBlankLines: 1];    UNTIL ODI.GetYesNo[prompt: cmMsgKeys[isDiskReady], defaultSpecified: TRUE, default: TRUE] DO ENDLOOP; };  PutNoFileMsgs: PROC = {    ODI.PutMessage[      message: cmMsgKeys[noDiagPkg], beep: TRUE,      clearMessageAreaFirst: TRUE];    ODI.PutMessage[cmMsgKeys[checkDisk]];    };  GetFloppyBcds: PROC RETURNS[link: PROGRAM, count: CARDINAL ¬ 0, validVersion: BOOLEAN ¬ TRUE] =    BEGIN    file: Floppy.FileHandle;    volume: Floppy.VolumeHandle ¬ Floppy.nullVolumeHandle;        volume ¬ Floppy.Open[      drive: 0 !      Floppy.Error =>        SELECT error FROM          notReady => {            ODI.PutMessage[cmMsgKeys[notReady]]; TryAgain[]};          noSuchDrive => {ODI.PutMessage[cmMsgKeys[noSuchDrive]]; TryAgain[]};          invalidFormat => {            ODI.PutMessage[cmMsgKeys[invalidFormat]]; TryAgain[]};          needsScavenging => {            ODI.PutMessage[cmMsgKeys[needsScavenging]]; TryAgain[]};          ENDCASE; ];    ODI.PutMessage[      message: cmMsgKeys[loading],      clearMessageAreaFirst: TRUE];    file ¬ [volume, Floppy.nullFileID];    count ¬ 0;    UNTIL (file ¬ GetNextFile[file]) = nullFile DO      ENABLE ANY => {	IF volume # Floppy.nullVolumeHandle THEN Floppy.Close[volume];	volume ¬ Floppy.nullVolumeHandle;	};      [link, validVersion] ¬ GetFloppyBcdsInternal[file];      count ¬ count + 1;      IF NOT validVersion THEN EXIT; -- the file just loaded contains invalid version.      ENDLOOP;    Floppy.Close[volume];    volume ¬ Floppy.nullVolumeHandle;    END;      GetFloppyBcdsInternal: PROC[file: Floppy.FileHandle] RETURNS [cLink: PROGRAM, valid: BOOLEAN] =    BEGIN    MapSpace: SpecialLoader.MapProcType =      -- pageOffset, pageCount: CARDINAL,      -- swapUnits: Space.SwapUnits, access: Space.Access]      --RETURNS [mapUnitPtr: LONG POINTER]      BEGIN      offset: CARDINAL ¬ 1;      interval: Space.Interval ¬ SpecialSpace.AllocateForCode[        pageCount, Space.virtualMemory];      -- read floppy file directly into resident VM      VM.ScratchMap[        interval: [Space.PageFromLongPointer[interval.pointer], interval.count] !        UNWIND => Space.Deallocate[interval]];      Floppy.Read[        file: file, first: offset + pageOffset, count: pageCount,        vm: interval.pointer !        Floppy.Error =>          SELECT error FROM            fileNotFound => {              ODI.PutMessage[cmMsgKeys[fileNotFound]]; GiveUp[]};	      -- The specified file was not found on floppy disk.             hardwareError => {              ODI.PutMessage[cmMsgKeys[hardwareError]]; GiveUp[]};            ENDCASE => SIGNAL NoFile];	      -- There happened some problem accessing the floppy disk but	      -- allow user to replace and try again.      RETURN[interval.pointer];      END;    UnmapSpace: SpecialLoader.UnmapProcType =      -- targetAddress: LONG POINTER]       -- RETURNS [mapUnit: Space.Interval]      BEGIN      mapUnit ¬ Space.nullInterval;      IF targetAddress # NIL THEN {        run: ARRAY [0..1) OF BackingStore.Run;        page: Environment.PageNumber = Space.PageFromLongPointer[targetAddress];        vmInterval: VM.Interval ¬ VM.GetMapUnitAttributes[          page, DESCRIPTOR[run]].mapUnit;        -- UnmapAt/Deallocate (vs. Unmap) done to get mapUnit.count        mapUnit ¬ [Space.LongPointerFromPage[vmInterval.page], vmInterval.count];        VM.Unmap[vmInterval.page];        Space.Deallocate[mapUnit]};      END;    valid ¬ TRUE;    cLink ¬ SpecialLoader.LoadConfig[MapSpace, UnmapSpace, TRUE !      Runtime.VersionMismatch => {        ODI.PutMessage[message: cmMsgKeys[cantFindConfig], clearMessageAreaFirst: TRUE];	valid ¬ FALSE; 	RESUME}];    END;  -- Of GetFloppyBcds  GetNextFile: PROC [file: Floppy.FileHandle]    RETURNS [Floppy.FileHandle] = {    type: File.Type ¬ FileTypes.tUntypedFile;    WHILE type = FileTypes.tUntypedFile DO      file ¬ Floppy.GetNextFile[file];      IF file.file = Floppy.nullFileID THEN RETURN[nullFile];      [, type] ¬ Floppy.GetFileAttributes[file];      ENDLOOP;    RETURN[file]};  «CheckModuleExistence: PROC RETURNS [isBound: BOOLEAN ¬ FALSE] =    BEGIN    isBound ¬ Runtime.IsBound[LOOPHOLE[ODI.RunEthernetTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunFloppyDiscTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunHardDiscTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunRS232CTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunKbdDsplMouseTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunPrinterTests, Runtime.ControlLink]]      OR Runtime.IsBound[        LOOPHOLE[ODI.RunFormatterScavengerBPU, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunSystemConfigurator, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunSelfTest, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunLaserDiscTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunManufacturingTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunTapeDriveTests, Runtime.ControlLink]]      OR Runtime.IsBound[LOOPHOLE[ODI.RunMiscTests, Runtime.ControlLink]];    END;»  «RunFloppyExec: PUBLIC ODI.ClientPackage = -- for Diagnotics menu.    BEGIN    menuPtr: LONG POINTER TO ODI.AMenuOfSelections ¬ NIL;    menuEntriesPtr: LONG POINTER TO ODI.TestItemsForThisNode;    menuEntryPtr: LONG POINTER TO ODI.TestItem;    userTestPtr: LONG POINTER TO ODI.Selections;    adminTestPtr: LONG POINTER TO ODI.Selections;    serviceTestPtr: LONG POINTER TO ODI.Selections;    manufacturingTestPtr: LONG POINTER TO ODI.Selections;    programerTestPtr: LONG POINTER TO ODI.Selections;    index: CARDINAL ¬ 0;    menuEntriesPtr ¬ ODI.GetATestItemsForThisNode[2];    menuEntryPtr ¬ ODI.GetATestItem[];    menuEntryPtr.itemName ¬ cmMsgKeys[menuName];    menuEntryPtr.test ¬ ReadDiagnosticsPackage;    menuEntriesPtr.nodeItems[0] ¬ menuEntryPtr;    menuEntryPtr ¬ ODI.GetATestItem[];    menuEntryPtr.itemName ¬ "Erase Loaded Config";    menuEntryPtr.test ¬ EraseLoadedConfig;    menuEntriesPtr.nodeItems[1] ¬ menuEntryPtr;    userTestPtr ¬ ODI.GetASelectionArray[1];    adminTestPtr ¬ ODI.GetASelectionArray[1];    serviceTestPtr ¬ ODI.GetASelectionArray[1];    manufacturingTestPtr ¬ ODI.GetASelectionArray[1];    programerTestPtr ¬ ODI.GetASelectionArray[2];    userTestPtr.selections[0] ¬ 0;    adminTestPtr.selections[0] ¬ 0;    serviceTestPtr.selections[0] ¬ 0;    manufacturingTestPtr.selections[0] ¬ 0;    programerTestPtr.selections[0] ¬ 0;    programerTestPtr.selections[1] ¬ 1;    menuPtr ¬ ODI.GetAMenuOfSelections[];    menuPtr.menuTitle ¬ cmMsgKeys[floppyExec];    menuPtr.userSelections ¬ userTestPtr;    menuPtr.adminSelections ¬ adminTestPtr;    menuPtr.seSelections ¬ serviceTestPtr;    menuPtr.manufacturingSelections ¬ manufacturingTestPtr;    menuPtr.programmerSelections ¬ programerTestPtr;    menuPtr.testItemsForThisNode ¬ menuEntriesPtr;    RETURN[menuPtr];    END;»  ReadFloppy: PROC =    BEGIN    ENABLE      BEGIN      TryAgain => {        Process.Pause[Process.SecondsToTicks[3]];        ODI.PutMessage[cmMsgKeys[tryAgain]];        Confirm[ ! TryAgain => GOTO iQuit];        CONTINUE};      GiveUp => GOTO iQuit;      ABORTED => GOTO aborted;      END;    count: CARDINAL ¬ 0;    link: PROGRAM;    found: BOOLEAN ¬ FALSE;    versionIsValid: BOOLEAN ¬ FALSE;  -- Intended to get the number of floppy disk to be read.  -- Currently the number is 1 and I commented out this.    --[number: count] ¬ ODI.GetANumber[    --  prompt: "How many floppys to insert?"L,    --  lowLimit: 0, upperLimit: 10, defaultNumber: 1];  UNTIL found DO    -- FOR i:CARDINAL IN [1..count] DO    -- ODI.PutMessage[cmMsgKeys[insertDisk]];    Confirm[];    versionIsValid ¬ FALSE;    [link, count, versionIsValid] ¬ GetFloppyBcds[      !      Runtime.ConfigError => { -- will be raised if the content is not the executable BCD.        PutNoFileMsgs[];        ODI.HitAnyKeyToContinue[];        LOOP};      NoFile => { -- Will be raised if no file with valid file type is on the floppy disk.        PutNoFileMsgs[];	LOOP}];    --ENDLOOP; <-- -- of FOR i: CARDINAL IN [1..count] DO        prevConfig ¬ link;            IF count = 0 THEN { -- no file was found of floppy disk.      PutNoFileMsgs[];      LOOP}    ELSE { -- count # 0      -- Some files were loaded.      -- first check the version is valid.      IF NOT versionIsValid THEN -- loaded bcd is version mismatched.        IF link = NIL THEN {ODI.PutMessage[message: cmMsgKeys[cantErase], beep: TRUE];	  ERROR GiveUp}	ELSE {-- try to unload the loaded bcd.	  Runtime.UnNewConfig[LOOPHOLE[link]];	  ODI.PutMessage[cmMsgKeys[checkDisk]];	  ODI.HitAnyKeyToContinue[];	  LOOP}; -- of versionIsValid.      -- Check loaded config instatnce.      found ¬ OdiExtra.ValidateClients[TRUE]; --CheckModuleExistence[];      IF NOT found THEN {	-- Loaded BCD doesn't have OfflineDiagnostics package.	PutNoFileMsgs[];	IF link = NIL THEN {	-- Unable to clean up the resident memory so the system must be rebooted.	  ODI.PutMessage[message: cmMsgKeys[cantErase], beep: TRUE];	  ERROR GiveUp}; -- of link = NIL	Runtime.UnNewConfig[LOOPHOLE[link]];	ODI.HitAnyKeyToContinue[];	LOOP} -- of NOT found      ELSE {-- at least one offline diagnostic package was loaded.	ODI.PutMessage[	  message: cmMsgKeys[finishLoading],	  clearMessageAreaFirst: TRUE];	  EXIT	}      }; -- of count # 0    ENDLOOP;    EXITS      iQuit => {BlackHole[quit]};      aborted => {BlackHole[aborted]};    END;      BlackHole: PROCEDURE[msg: CMDiagMsgKeysDove.DiagMessages] = {    ODI.PutMessage[cmMsgKeys[msg]]; DO ENDLOOP};  END..LOG25-Aug-85 22:44:33 	 ET   Created from Othello>VolumeInitCommandImpl.mesa10-Sep-85 14:54:12	MXT   Changed for OfflineDiagKernelDove 5-Nov-85 15:32:20	MXT	   Added read multiplu files from one floppy disk function.31-Jan-86 16:27:55	MXT	(Reason Not Given)14-Jan-86 17:48:32	MXT	Changed to use OdiExtra.ValidateClients.  5-Mar-87 11:39:37	KXW	Modified Confirm to post messages for scanner diagnostics. 27-Jan-88  9:54:26, STC, add diskForCartTapeDiag in Confirm
-- File: DiagRDPVStuffImpl.mesa - last edit:-- MXT                 14-Jan-86 16:14:43-- Copyright (C) 1985 , 1986, 1986, 1986, 1986, 1986, 1986, 1986, 1986 by Xerox Corporation. All rights reserved. --DiagRDPVStuffImpl.mesa--Remove all--***temporaryDIRECTORY  DiagDiskCmdDrive USING [    Unit, Cylinder, Sector, Head, MaxSector, MaxHead, ExecuteCommands],  DiagDiskTime USING [SetLTP],  DiagDiskMkMisc USING [mkMisc],  DiagDiskTestControl USING [    ReturningOnHardError, ReturningOnSoftError, TestControlRecord, SetUpTestControl],  DiagRDErrorCheck USING [PublicErrorCheckArray, ECStandard1],  DiagRDTests USING [CallService],  PhysicalVolume USING [    AssertNotAPilotVolume, FinishWithNonPilotVolume, ID, Handle, PageNumber,    Offline, CreatePhysicalVolume, Error, nullBadPage, GetHints, GetNextBadPage,    nullDeviceIndex, GetNextDrive, GetHandle, AssertPilotVolume, NeedsScavenging],  OfflineDiagInterface USING [GetYesNo, PutData, PutMessage],  String USING [AppendString],  DiagRDPVStuff USING [];DiagRDPVStuffImpl: PROGRAM  IMPORTS    DiagDiskCmdDrive, DiagDiskTime, DiagDiskMkMisc, DiagDiskTestControl,    DiagRDErrorCheck, DiagRDTests, PhysicalVolume, OfflineDiagInterface, String  EXPORTS DiagRDPVStuff =  BEGIN OPEN DiagDiskMkMisc, Odi: OfflineDiagInterface;  BadPageCount: PUBLIC CARDINAL ¬ 0;  BadPageSpace: PUBLIC ARRAY [0..128) OF PhysicalVolume.PageNumber ¬ ALL[0];  Cancel: PUBLIC SIGNAL = CODE;  DeletedCmd: BOOLEAN ¬ FALSE;  volumehandle: PhysicalVolume.Handle;  GoodVolumeID: PUBLIC BOOLEAN ¬ FALSE;  VolumeID: PUBLIC PhysicalVolume.ID;  --***temporary  indexSet: BOOLEAN ¬ FALSE;  index: CARDINAL;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- verifies that the given bad page is in the bad page table  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AddrToPage: PUBLIC PROCEDURE RETURNS [pageNumber: PhysicalVolume.PageNumber] =    BEGIN    pageNumber ¬ DiagDiskCmdDrive.Cylinder;    pageNumber ¬      (pageNumber * (DiagDiskCmdDrive.MaxHead + 1) *         (DiagDiskCmdDrive.MaxSector + 1));    pageNumber ¬      pageNumber + (DiagDiskCmdDrive.Head * (DiagDiskCmdDrive.MaxSector + 1)) +        (DiagDiskCmdDrive.Sector);    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- verifies that the given bad page is in the bad page table  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BadPageInTable: PUBLIC PROCEDURE [badPage: PhysicalVolume.PageNumber]    RETURNS [inTable: BOOLEAN] =    BEGIN    physicalVolume: PhysicalVolume.ID;    pageNumber: PhysicalVolume.PageNumber;    volumehandle ¬ GetVolumeHandle[];    PhysicalVolume.FinishWithNonPilotVolume[volumehandle];    GetVolumeID[volumehandle];  --asserts a pilot volume    physicalVolume ¬ VolumeID;    inTable ¬ FALSE;    pageNumber ¬ PhysicalVolume.nullBadPage;    pageNumber ¬ PhysicalVolume.GetNextBadPage[      pvID: physicalVolume, thisBadPageNumber: pageNumber];    IF pageNumber = badPage THEN {inTable ¬ TRUE; EnforceDiskOffline[]; RETURN; };    UNTIL pageNumber = PhysicalVolume.nullBadPage DO      pageNumber ¬ PhysicalVolume.GetNextBadPage[        pvID: physicalVolume, thisBadPageNumber: pageNumber];      IF pageNumber = badPage THEN {inTable ¬ TRUE; EXIT};      ENDLOOP;    -- put physicalVolume offline and assert not a pilot volume    EnforceDiskOffline[];    END;  --BadPageInTable  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- to generate a physical volume and log bad pages  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GenPhysicalVolume: PUBLIC PROCEDURE [logBadPages: BOOLEAN ¬ FALSE] =    BEGIN    string: STRING ¬ [4];    volumehandle ¬ GetVolumeHandle[];    PhysicalVolume.FinishWithNonPilotVolume[      instance: volumehandle !      PhysicalVolume.Error =>        SELECT error FROM          hasPilotVolume => {            Odi.PutData[              data: "Has a Pilot Volume???",  --***Test Only              clearHeadingAndData: TRUE];            GOTO exit;            };          invalidHandle => {            Odi.PutData[              data: "Invalid Handle???",  --***Test Only              clearHeadingAndData: TRUE];            GOTO exit;            };          ENDCASE => {            Odi.PutData[data: "???", clearHeadingAndData: TRUE]; GOTO exit; }];    -- create the physical volume    string.length ¬ 0;    SELECT DiagDiskCmdDrive.Unit FROM      0 => String.AppendString[string, DiagDiskMkMisc.mkMisc[RD0]];      1 => String.AppendString[string, DiagDiskMkMisc.mkMisc[RD1]];      2 => String.AppendString[string, DiagDiskMkMisc.mkMisc[RD2]];      3 => String.AppendString[string, DiagDiskMkMisc.mkMisc[RD3]];      ENDCASE;    VolumeID ¬ PhysicalVolume.CreatePhysicalVolume[      instance: volumehandle, name: string !      ANY => {        Odi.PutData[data: mkMisc[PVCreationErr], clearHeadingAndData: TRUE];        GOTO Cancel;        }];    GoodVolumeID ¬ TRUE;    -- verify that this is a pilot volume    IF PhysicalVolume.GetHints[volumehandle ! ANY => GOTO Cancel].volumeType #      isPilot THEN GOTO Cancel;    -- write the local time parameters on the disk    DiagDiskTime.SetLTP[pvID: VolumeID];    -- put physicalVolume offline and assert not a pilot volume    EnforceDiskOffline[];    EXITS      Cancel => {        EnforceDiskOffline[];        Odi.PutMessage[clearMessageAreaFirst: TRUE];        Odi.PutData[data: mkMisc[PVErr], clearHeadingAndData: TRUE];        DiagRDTests.CallService[fruCode: 6];        };      exit => {        Odi.PutMessage[clearMessageAreaFirst: TRUE];        DiagRDTests.CallService[fruCode: 6];        };    END;  --GenPhysicalVolume  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- loads the bad pages into BadPageSpace from a specified unit  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetBadPages: PUBLIC PROCEDURE RETURNS [empty: BOOLEAN] =    BEGIN    physicalVolume: PhysicalVolume.ID;    pageNumber: PhysicalVolume.PageNumber;    empty ¬ FALSE;    volumehandle ¬ GetVolumeHandle[];    PhysicalVolume.FinishWithNonPilotVolume[volumehandle];    GetVolumeID[volumehandle];  --asserts a pilot volume    physicalVolume ¬ VolumeID;    BadPageCount ¬ 0;    pageNumber ¬ PhysicalVolume.nullBadPage;    pageNumber ¬ PhysicalVolume.GetNextBadPage[      pvID: physicalVolume, thisBadPageNumber: pageNumber];    IF pageNumber = PhysicalVolume.nullBadPage THEN {      empty ¬ TRUE;      EnforceDiskOffline[];      RETURN;      };    BadPageSpace[BadPageCount] ¬ pageNumber;    BadPageCount ¬ BadPageCount + 1;    UNTIL pageNumber = PhysicalVolume.nullBadPage DO      pageNumber ¬ PhysicalVolume.GetNextBadPage[        pvID: physicalVolume, thisBadPageNumber: pageNumber];      BadPageSpace[BadPageCount] ¬ pageNumber;      BadPageCount ¬ BadPageCount + 1;      ENDLOOP;    BadPageCount ¬ BadPageCount - 1;    -- put physicalVolume offline and assert not a pilot volume    EnforceDiskOffline[];    END;  --GetBadPages  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- is used to get a volume handle  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetVolumeHandle: PUBLIC PROCEDURE RETURNS [handle: PhysicalVolume.Handle] =    BEGIN    --***temporary: needs to be changed to accept a changing handle    IF NOT indexSet THEN {      index ¬ PhysicalVolume.GetNextDrive[index: PhysicalVolume.nullDeviceIndex];      IF index # PhysicalVolume.nullDeviceIndex THEN        volumehandle ¬ handle ¬ PhysicalVolume.GetHandle[          index: index ! PhysicalVolume.Error => {GOTO Cancel}]      ELSE GOTO Cancel;      indexSet ¬ TRUE;      }    ELSE handle ¬ volumehandle;    EXITS      Cancel => {        Odi.PutMessage[clearMessageAreaFirst: TRUE];        Odi.PutData[data: mkMisc[softwareErr], clearHeadingAndData: TRUE];        DiagRDTests.CallService[fruCode: 7];        };    END;  --GetVolumeHandle  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- is used to get a volume ID  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetVolumeID: PUBLIC PROCEDURE [handle: PhysicalVolume.Handle] =    BEGIN    IF GoodVolumeID THEN RETURN    ELSE {      VolumeID ¬ PhysicalVolume.AssertPilotVolume[        handle !        PhysicalVolume.Error =>          SELECT error FROM            alreadyAsserted => CONTINUE;            diskReadError => {              Odi.PutData[data: mkMisc[diskReadErr], clearHeadingAndData: TRUE];              GOTO exit;              };            physicalVolumeUnknown => {              Odi.PutData[data: mkMisc[PVErr], clearHeadingAndData: TRUE];              GOTO exit;              };            ENDCASE => {              Odi.PutData[data: mkMisc[PVErr], clearHeadingAndData: TRUE];              ERROR;              };        PhysicalVolume.NeedsScavenging => {          Odi.PutData[data: mkMisc[PVNeedsScavenging], clearHeadingAndData: TRUE];          GOTO exit;          };        ANY => {          Odi.PutData[data: mkMisc[PVErr], clearHeadingAndData: TRUE];          GOTO exit;          }];      GoodVolumeID ¬ TRUE};    EXITS      exit => {        Odi.PutMessage[clearMessageAreaFirst: TRUE];        DiagRDTests.CallService[fruCode: 6];        };    END;  --GetVolumeID  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to convert pilot page numbers to cylinder/head/sector  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PageToAddr: PUBLIC PROCEDURE [pageNumber: PhysicalVolume.PageNumber]    RETURNS [cylinder: CARDINAL, head: CARDINAL, sector: CARDINAL] =    BEGIN    cnt: CARDINAL ¬ 0;    UNTIL pageNumber <      ((DiagDiskCmdDrive.MaxHead + 1) * (DiagDiskCmdDrive.MaxSector + 1)) DO      pageNumber ¬        pageNumber -          ((DiagDiskCmdDrive.MaxHead + 1) * (DiagDiskCmdDrive.MaxSector + 1));      cnt ¬ cnt + 1;      ENDLOOP;    cylinder ¬ cnt;    cnt ¬ 0;    UNTIL pageNumber < (DiagDiskCmdDrive.MaxSector + 1) DO      pageNumber ¬ pageNumber - (DiagDiskCmdDrive.MaxSector + 1);      cnt ¬ cnt + 1;      ENDLOOP;    head ¬ cnt;    cnt ¬ 0;    UNTIL cnt >= pageNumber DO cnt ¬ cnt + 1; ENDLOOP;    sector ¬ cnt;    END;  --PageToAddr  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to check formatted/unformatte disk.  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  IsDiskFormatted: PUBLIC PROCEDURE RETURNS [yes: BOOLEAN ¬ FALSE] =    BEGIN    -- When [v, v, v] operation was performed on the unformatted disk, the microcode    -- will hang and the rigid disk handler will be timed out about 5 seconds.    -- So I assumed if [v, v, v] operation finished before 5 seconds, the disk was     -- formatted otherwise unformatted.    testCommands: ARRAY [0..20] OF CARDINAL ¬ [      7, 0, 1,  --StartLoop[0,1];      20, 22, 26,  --VerifyHeader/ReadLabel/ReadData[      1,  --Recalibrate first: Yes      0,  --Single buffer: no      1,  --Try count: 1      0, 1, 0,  --Cylinder: 0+0      0, 1, 0,  --Head: 0+0      0, 1, 1,  --Sector: 0+1      1,  --SectorCount: 1      8,  --EndLoop;      29];  --EndOfFile;    testControl: DiagDiskTestControl.TestControlRecord = [      controlUnit: TRUE, controlLoopCount: FALSE, checkForError: TRUE,      returnOnHardError: TRUE, returnOnSoftError: TRUE];    Odi.PutMessage[message: DiagDiskMkMisc.mkMisc[checkFormat],      clearMessageAreaFirst: TRUE];        DiagDiskTestControl.SetUpTestControl[controlData: testControl];    DiagRDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[      DiagRDErrorCheck.ECStandard1];    DiagDiskCmdDrive.ExecuteCommands[      DESCRIPTOR[testCommands] !      DiagDiskTestControl.ReturningOnHardError, DiagDiskTestControl.ReturningOnSoftError => GOTO error];    RETURN[TRUE];    EXITS      error => {        Odi.PutMessage[          message: DiagDiskMkMisc.mkMisc[mayBeUnformatted],          clearMessageAreaFirst: TRUE, beep: TRUE];        RETURN[	  Odi.GetYesNo[prompt: DiagDiskMkMisc.mkMisc[formatQuestion]].YesReturnsTrue]};    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to verify PV.  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  VerifyPV: PUBLIC PROCEDURE RETURNS [ok: BOOLEAN ¬ FALSE] =    BEGIN    volumehandle ¬ GetVolumeHandle[];    PhysicalVolume.FinishWithNonPilotVolume[volumehandle];    GoodVolumeID ¬ FALSE;    GetVolumeID[volumehandle ! ANY => GOTO error];    EnforceDiskOffline[];    RETURN[TRUE];    EXITS error => RETURN[FALSE];    END;  EnforceDiskOffline: PROCEDURE = {    PhysicalVolume.Offline[pvID: VolumeID];    GoodVolumeID ¬ FALSE;    PhysicalVolume.AssertNotAPilotVolume[      instance: volumehandle !      PhysicalVolume.Error => IF error = alreadyAsserted THEN CONTINUE];    };  END...  Created: 13-Feb-82 12:49:37 16-Dec-85 11:16:05	MXT	Added IsDiskFormatted and VerifyPV. 20-Dec-85 12:18:34	MXT	Added EnforceDiskOffline. 14-Jan-86 12:16:08	MXT	Added catch phrase for DiagDiskTestControl.ReturningOnSoftError 	
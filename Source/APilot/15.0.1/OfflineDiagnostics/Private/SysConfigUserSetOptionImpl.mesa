-- File SysConfigUserSetOptionImpl.mesa-- Last edited:  7-Oct-89 13:56:56 by: TXM<<	Copyright (C) 1985, 1986, 1987, 1988, 1989 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  Device		USING [ nullType ],  EEpromDefs	        USING [ EEpromConfig,  				RigidDiskTypeBits, VersionNumberROM,				VersionNumberRAM,  				VersionNumberBadPages],  EEpromDefsExtras	USING [ ParallelPortOptionSpecificData],				  Inline	        USING [ LowByte ],  OfflineDiagInterface  USING [ OfflineDiagnosticProc, PutMessage,				OptionsRecord, AnOptionLine,				GetAnOptionsRecord,				GetAnOptionLine, GetAnOption, OptionItem],					 			--  ProcessorFaceExtras	USING [Version, VersionResult],  ProcessorFaceExtras2	USING [DoveMachineType, DoveMachineTypeInfo],  SysConfigChannelDefs  USING [ eePromImage],  SysConfigControlDefs  USING [ msgKey, msgKey1, msgKey2, statusPtr],  SysConfigRigidDiskDefs USING [arraySize, diskShapeImage, rigidDiskArray],  SysConfigSubDefs;    SysConfigUserSetOptionImpl: PROGRAM	IMPORTS Inline, OfflineDiagInterface, --	  ProcessorFaceExtras, 	  ProcessorFaceExtras2, 	  SysConfigRigidDiskDefs, SysConfigControlDefs, SysConfigChannelDefs			EXPORTS SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, 	SysConfigControlDefs, SysConfigChannelDefs;  -- ODI stands for OfflineDiagInterface.--******************************************************************************-- Get Floppy Size:--******************************************************************************GetFloppySize: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    FloppySizes: TYPE = {none, kb360, kb1200, fad5000};    numberFloppySizes: CARDINAL = ORD[LAST[FloppySizes]] + 1;  floppyOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [3];  -- Just one row of option here  floppyOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];  floppyOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];   floppyOptionRow2: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];        leftEdge: CARDINAL = 3;   -- For formatting display.  floppySelected: CARDINAL;  -- The option selected by the user         -- Now construct the floppy option table  --  floppyOptionTable.linesOfOptions[0] ¬ floppyOptionRow0; -- Save pointer to row  floppyOptionTable.linesOfOptions[1] ¬ floppyOptionRow1; -- Save pointer to row  floppyOptionTable.linesOfOptions[2] ¬ floppyOptionRow2; -- Save pointer to row  floppyOptionTable.optionMenuTiTle ¬ msgKey1[floppyUser];    floppyOptionRow0.optionsOnALine[0].position ¬ leftEdge;  floppyOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  floppyOptionRow0.optionsOnALine[0].option ¬ msgKey[none];  -- %Change    floppyOptionRow1.optionsOnALine[0].position ¬ leftEdge;  floppyOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;  floppyOptionRow1.optionsOnALine[0].option ¬ msgKey[kb360];  -- %Change    floppyOptionRow2.optionsOnALine[0].position ¬ leftEdge;  floppyOptionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  floppyOptionRow2.optionsOnALine[0].option ¬ msgKey[kb1200];  -- %Change        [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: floppyOptionTable,      optionPrompt: msgKey[blanks], justDisplayTable:TRUE];						      floppySelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL,      optionPrompt: msgKey1[enterResponse],      defaultOption: SELECT eePromImage.FloppyDiskTypeDrive0 FROM		      none => 1,		      kb360 => 2,		      kb1200 => 3		      ENDCASE => 2 ]; -- Change screen or Exit					         SELECT floppySelected FROM       1 => eePromImage.FloppyDiskTypeDrive0 ¬ none;       2 => eePromImage.FloppyDiskTypeDrive0 ¬ kb360;       3 => eePromImage.FloppyDiskTypeDrive0 ¬ kb1200;       ENDCASE;  IF eePromImage.FloppyDiskTypeDrive0 # none  		THEN eePromImage.FloppyBooting ¬ allowed  		ELSE eePromImage.FloppyBooting ¬ notAllowed;      END; -- GetFloppySize--******************************************************************************-- Get Keyboard Type:--******************************************************************************GetKeyboardType: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    KeyboardTypes: TYPE = {us, japanese, european};    numberKeyboardTypes: CARDINAL = ORD[LAST[KeyboardTypes]] + 1;  keyboardOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [3];  -- Just one row of option here  keyboardOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];  keyboardOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];   keyboardOptionRow2: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];        leftEdge: CARDINAL = 3;   -- For formatting display.  keyboardSelected: CARDINAL;  -- The option selected by the user         -- Now construct the keyboard option table  --  keyboardOptionTable.linesOfOptions[0] ¬ keyboardOptionRow0; -- Save pointer to row  keyboardOptionTable.linesOfOptions[1] ¬ keyboardOptionRow1; -- Save pointer to row  keyboardOptionTable.linesOfOptions[2] ¬ keyboardOptionRow2; -- Save pointer to row  keyboardOptionTable.optionMenuTiTle ¬ msgKey1[askKeyboard];    keyboardOptionRow0.optionsOnALine[0].position ¬ leftEdge;  keyboardOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  keyboardOptionRow0.optionsOnALine[0].option ¬ msgKey1[usKeyboard];  -- %Change    keyboardOptionRow1.optionsOnALine[0].position ¬ leftEdge;  keyboardOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;  keyboardOptionRow1.optionsOnALine[0].option ¬ msgKey[japaneseKeyboard];  -- %Change    keyboardOptionRow2.optionsOnALine[0].position ¬ leftEdge;  keyboardOptionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  keyboardOptionRow2.optionsOnALine[0].option ¬ msgKey[europeanKeyboard];  -- %Change     		      [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: keyboardOptionTable,      optionPrompt: msgKey[blanks], justDisplayTable:TRUE];						     SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE, , , TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE, , , TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE, , , TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE, , , TRUE];      unKnown => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE, , , TRUE];      ENDCASE;         IF eePromImage.VersionEProm > EEpromDefs.VersionNumberROM OR    eePromImage.VersionRAM > EEpromDefs.VersionNumberRAM OR    eePromImage.VersionBadPages > EEpromDefs.VersionNumberBadPages    					THEN { Odi.PutMessage [msgKey1[badVersionNumber], TRUE, TRUE, , , FALSE]; };                 keyboardSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL,      optionPrompt: msgKey1[enterResponse],      defaultOption: SELECT eePromImage.Keyboard FROM				english => 1,				japanese => 2,				european => 3				ENDCASE => 0 ]; -- Change screen or Exit					         SELECT keyboardSelected FROM       1 => eePromImage.Keyboard ¬ english;       2 => eePromImage.Keyboard ¬ japanese;       3 => eePromImage.Keyboard ¬ european;              ENDCASE;      END; -- ConfigureKeyboard   --******************************************************************************-- Get RigidDisk:--******************************************************************************GetRigidDiskType: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN    -- Disk types supported. Whenever new types are encountered, simply add   --   DiskTypes: TYPE = {Mb101, Mb102, Mb201, Mb202, Mb203, Mb204, Mb205, Mb206, Mb401, Mb402, Mb403, Mb404, Mb405, Mb406, Mb801, Mb802, Mb803, Mb804, Mb20A, Mb20B, Mb20C, Mb20D, Mb40C, Mb40D, Mb805, Mb1501};  --  -- This option table presents the various disk types to the user for selection.  --   index: CARDINAL ¬ 0;  numberOfRows: CARDINAL = 13;  numberOfDiskTypes: CARDINAL = ORD[LAST[DiskTypes]] + 1;  diskTypeOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [numberOfRows];  optionRow0: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow1: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow2: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];   optionRow3: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow4: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];   optionRow5: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow6: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow7: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow8: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow9: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow10: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow11: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];   optionRow12: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];         leftEdge: CARDINAL = 3;   -- For formatting display.  xOffset: CARDINAL = leftEdge + msgKey1[Mb20A].length + 8;  diskTypeSelected: CARDINAL;  -- The option selected by the user  SetUpOption: PROCEDURE[xPosition, selectionNumberForThisItem: CARDINAL,      string: LONG STRING]       RETURNS [optionItem: Odi.OptionItem] =    BEGIN      optionItem.position ¬ xPosition;      optionItem.selectionNumberForThisItem ¬ selectionNumberForThisItem;      optionItem.option ¬ string;      RETURN[optionItem];    END;  -- Now construct the Rigid disk type option table  --  diskTypeOptionTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row  diskTypeOptionTable.linesOfOptions[1] ¬ optionRow1;  diskTypeOptionTable.linesOfOptions[2] ¬ optionRow2;  diskTypeOptionTable.linesOfOptions[3] ¬ optionRow3;  diskTypeOptionTable.linesOfOptions[4] ¬ optionRow4;  diskTypeOptionTable.linesOfOptions[5] ¬ optionRow5;  diskTypeOptionTable.linesOfOptions[6] ¬ optionRow6;  diskTypeOptionTable.linesOfOptions[7] ¬ optionRow7;  diskTypeOptionTable.linesOfOptions[8] ¬ optionRow8;  diskTypeOptionTable.linesOfOptions[9] ¬ optionRow9;  diskTypeOptionTable.linesOfOptions[10] ¬ optionRow10;  diskTypeOptionTable.linesOfOptions[11] ¬ optionRow11;  diskTypeOptionTable.linesOfOptions[12] ¬ optionRow12;  diskTypeOptionTable.optionMenuTiTle ¬ msgKey1[askRigDisk];    optionRow0.optionsOnALine[0] ¬ SetUpOption[leftEdge, 1, msgKey1[Mb101]];  optionRow0.optionsOnALine[1] ¬ SetUpOption[xOffset, 2, msgKey1[Mb102]];  optionRow1.optionsOnALine[0] ¬ SetUpOption[leftEdge, 3, msgKey1[Mb201]];  optionRow1.optionsOnALine[1] ¬ SetUpOption[xOffset, 4, msgKey1[Mb202]];  optionRow2.optionsOnALine[0] ¬ SetUpOption[leftEdge, 5, msgKey1[Mb203]];  optionRow2.optionsOnALine[1] ¬ SetUpOption[xOffset, 6, msgKey1[Mb204]];  optionRow3.optionsOnALine[0] ¬ SetUpOption[leftEdge, 7, msgKey1[Mb205]];  optionRow3.optionsOnALine[1] ¬ SetUpOption[xOffset, 8, msgKey1[Mb206]];  optionRow4.optionsOnALine[0] ¬ SetUpOption[leftEdge, 9, msgKey1[Mb20A]];  optionRow4.optionsOnALine[1] ¬ SetUpOption[xOffset, 10, msgKey1[Mb20B]];  optionRow5.optionsOnALine[0] ¬ SetUpOption[leftEdge, 11, msgKey1[Mb20C]];  optionRow5.optionsOnALine[1] ¬ SetUpOption[xOffset, 12, msgKey1[Mb20D]];  optionRow6.optionsOnALine[0] ¬ SetUpOption[leftEdge, 13, msgKey1[Mb401]];  optionRow6.optionsOnALine[1] ¬ SetUpOption[xOffset, 14, msgKey1[Mb402]];  optionRow7.optionsOnALine[0] ¬ SetUpOption[leftEdge, 15, msgKey1[Mb403]];  optionRow7.optionsOnALine[1] ¬ SetUpOption[xOffset, 16, msgKey1[Mb404]];  optionRow8.optionsOnALine[0] ¬ SetUpOption[leftEdge, 17, msgKey1[Mb405]];  optionRow8.optionsOnALine[1] ¬ SetUpOption[xOffset, 18, msgKey1[Mb406]];  optionRow9.optionsOnALine[0] ¬ SetUpOption[leftEdge, 19, msgKey1[Mb40C]];  optionRow9.optionsOnALine[1] ¬ SetUpOption[xOffset, 20, msgKey1[Mb40D]];  optionRow10.optionsOnALine[0] ¬ SetUpOption[leftEdge, 21, msgKey1[Mb801]];  optionRow10.optionsOnALine[1] ¬ SetUpOption[xOffset, 22, msgKey1[Mb802]];  optionRow11.optionsOnALine[0] ¬ SetUpOption[leftEdge, 23, msgKey1[Mb803]];  optionRow11.optionsOnALine[1] ¬ SetUpOption[xOffset, 24, msgKey1[Mb804]];  optionRow12.optionsOnALine[0] ¬ SetUpOption[leftEdge, 25, msgKey2[Mb805]];  optionRow12.optionsOnALine[1] ¬ SetUpOption[xOffset, 26, msgKey2[Mb1501]];  diskTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: diskTypeOptionTable,      optionPrompt: msgKey1[enterResponse],      defaultOption:	SELECT eePromImage.RigidDiskType FROM	      seagateST212 => 1,	      seagateST213 => 2,	      tandonTM703 => 3,	      tandonTM702AT, seagateST4026 => 4,	      quantumQ530 => 5,	      seagateST225 => 6,	      mitsubishiMR322US => 7,	      necD3126US => 8,	      extendedTandonTM703 => 9,	      extendedTandonTM702, extendedSeagateST4026 => 10,	      extendedQuantumQ530 => 11,	      extendedSeagateST225 => 12,	      quantumQ540 => 13,	      micropolis1303 => 14,	      seagateST4051 => 15,	      seagateST251 => 16,	      mitsubishiMR535US => 17,	      necD5146HUS => 18,	      extendedSeagateST4051 => 19,	      extendedSeagateST251 => 20,	      micropolis1325 => 21,	      seagateST4096 => 22,	      fujitsuM2243AS => 23,	      toshibaMK56FB => 24,	      swift94355100 => 25,	      maxtorXT2190 => 26,	ENDCASE => 0 ];      diskTypeSelected ¬ LOOPHOLE[EEpromDefs.RigidDiskTypeBits[      SELECT diskTypeSelected FROM	1 => seagateST212,	2 => seagateST213,	3 => tandonTM703,	4 => seagateST4026, --also tandonTM702AT	5 => quantumQ530,	6 => seagateST225,	7 => mitsubishiMR322US,	8 => necD3126US,	9 => extendedTandonTM703,	10 => extendedSeagateST4026, --also extendedTandonTM702	11 => extendedQuantumQ530,	12 => extendedSeagateST225,	13 => quantumQ540,	14 => micropolis1303,	15 => seagateST4051,	16 => seagateST251,	17 => mitsubishiMR535US,	18 => necD5146HUS,	19 => extendedSeagateST4051,	20 => extendedSeagateST251,	21 => micropolis1325,	22 => seagateST4096,	23 => fujitsuM2243AS,	24 => toshibaMK56FB,	25 => swift94355100,	26 => maxtorXT2190,	ENDCASE => none ], CARDINAL];             eePromImage.RigidDiskType ¬ Inline.LowByte[diskTypeSelected];       eePromImage.RigidDiskSectorsPerTrack ¬ SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].SectorsPerTrack; -- sectorsPerTrack       eePromImage.RigidDiskHeadsPerCylinder ¬ SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].HeadsPerCylinder; -- numberOfHeads       eePromImage.RigidDiskHeadsCylinderCount ¬ SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].CylinderCount; -- cylindersPerDrive       eePromImage.RigidDiskReducedWriteCylinder ¬ SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].ReducedWriteCylinder; -- reduceWrCurCylinder       eePromImage.RigidDiskPreCompensationCylinder ¬ SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].PreCompensationCylinder; -- precompesationCylinder       eePromImage.RigidDiskHeadLandingZone ¬        SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].HeadLandingZone;-- STC, 9-Oct-88 10:51:30, modified diskSpape per User's input	SysConfigRigidDiskDefs.diskShapeImage.pagesPerTrack ¬ LOOPHOLE[eePromImage.RigidDiskSectorsPerTrack];	SysConfigRigidDiskDefs.diskShapeImage.headsPerCylinder ¬ LOOPHOLE[eePromImage.RigidDiskHeadsPerCylinder];	SysConfigRigidDiskDefs.diskShapeImage.cylinderCount ¬ LOOPHOLE[eePromImage.RigidDiskHeadsCylinderCount];	SysConfigRigidDiskDefs.diskShapeImage.reducedWriteCylinder ¬ LOOPHOLE[eePromImage.RigidDiskReducedWriteCylinder];	SysConfigRigidDiskDefs.diskShapeImage.preCompensationCylinder ¬ LOOPHOLE[eePromImage.RigidDiskPreCompensationCylinder];	SysConfigRigidDiskDefs.diskShapeImage.headLandingZone ¬ LOOPHOLE[eePromImage.RigidDiskHeadLandingZone];	index ¬ ORD[eePromImage.RigidDiskType] - 1;	IF (((index = 0) OR (index > 0)) AND		(index < SysConfigRigidDiskDefs.arraySize)) THEN	  BEGIN	    SysConfigRigidDiskDefs.diskShapeImage.type ¬	    	SysConfigRigidDiskDefs.rigidDiskArray[index].type;	    SysConfigRigidDiskDefs.diskShapeImage.rpm ¬	    	SysConfigRigidDiskDefs.rigidDiskArray[index].rpm;	    SysConfigRigidDiskDefs.diskShapeImage.vcmDisk ¬	    	SysConfigRigidDiskDefs.rigidDiskArray[index].vcmDisk;	  END	  ELSE SysConfigRigidDiskDefs.diskShapeImage.type ¬ Device.nullType;	SysConfigRigidDiskDefs.diskShapeImage.unused ¬ ALL[FALSE];  END;    --******************************************************************************-- Get Memory Size:--******************************************************************************GetMemorySize: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN-- Main types supported. Whenever new types are encountered, simply add  MainTypes: TYPE = {defaults, meb1, meb2, meb3, meb4, meb5};  MainTypes2: TYPE = {meb6, meb7};  -- This option table presents the various main types to the user for selection.  --  numberOfMainTypes: CARDINAL = ORD[LAST[MainTypes]] + 1;  numberOfMainTypes2: CARDINAL = ORD[LAST[MainTypes2]] + 1;  mainOptionTable: LONG POINTER TO Odi.OptionsRecord ¬     Odi.GetAnOptionsRecord [6];  -- Just one row of option here  mainOptionTable2: LONG POINTER TO Odi.OptionsRecord ¬     Odi.GetAnOptionsRecord [2];  -- Just one row of option here  mainOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬     Odi.GetAnOptionLine [1];  mainOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬     Odi.GetAnOptionLine [1];  mainOptionRow2: LONG POINTER TO Odi.AnOptionLine ¬     Odi.GetAnOptionLine [1];  mainOptionRow3: LONG POINTER TO Odi.AnOptionLine ¬     Odi.GetAnOptionLine [1];  mainOptionRow4: LONG POINTER TO Odi.AnOptionLine ¬     Odi.GetAnOptionLine [1];  mainOptionRow5: LONG POINTER TO Odi.AnOptionLine ¬     Odi.GetAnOptionLine [1];  -- This option table presents the various main types to the user for selection.  leftEdge: CARDINAL = 3;   -- For formatting display.  mainTypeSelected: CARDINAL;  -- The option selected by the user--  version: ProcessorFaceExtras.VersionResult _ ProcessorFaceExtras.Version[];  machineType: ProcessorFaceExtras2.DoveMachineType _ ProcessorFaceExtras2.DoveMachineTypeInfo[];  IF machineType = duke OR machineType = diana THEN {    mainOptionTable2.linesOfOptions[0] ¬ mainOptionRow0; -- Save pointer to row    mainOptionTable2.linesOfOptions[1] ¬ mainOptionRow1; -- Save pointer to row    mainOptionTable2.optionMenuTiTle ¬ msgKey2[askMemory2];    mainOptionRow0.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;    mainOptionRow0.optionsOnALine[0].option ¬ msgKey2[userMemory7];    mainOptionRow1.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;    mainOptionRow1.optionsOnALine[0].option ¬ msgKey2[userMemory6];    mainTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: mainOptionTable2,      optionPrompt: msgKey1[enterResponse],      defaultOption: SELECT eePromImage.MainMemoryExpansion FROM	  mega1 => 1,	  mega3 => 2	  ENDCASE => 0 ]; -- Example default    eePromImage.MainMemory0 ¬ present;    eePromImage.MainMemory1 ¬ present;    eePromImage.MainMemory2 ¬ present;    eePromImage.MainMemory3 ¬ present;    eePromImage.MainMemory4 ¬ present;    eePromImage.MainMemory5 ¬ present;    eePromImage.MainMemory6 ¬ present;    eePromImage.MainMemory7 ¬ present;    eePromImage.MainMemory8 ¬ present;    eePromImage.MainMemory9 ¬ present;    eePromImage.MainMemory10 ¬ present;    eePromImage.MainMemory11 ¬ present;    eePromImage.MainMemory12 ¬ present;    eePromImage.MainMemory13 ¬ present;    eePromImage.MainMemory14 ¬ present;    eePromImage.MainMemory15 ¬ present;    eePromImage.MainMemoryExpansion ¬ SELECT mainTypeSelected FROM	1 => mega1,	2 => mega3	ENDCASE => none }  ELSE {    mainOptionTable.linesOfOptions[0] ¬ mainOptionRow0; -- Save pointer to row    mainOptionTable.linesOfOptions[1] ¬ mainOptionRow1; -- Save pointer to row    mainOptionTable.linesOfOptions[2] ¬ mainOptionRow2; -- Save pointer to row    mainOptionTable.linesOfOptions[3] ¬ mainOptionRow3; -- Save pointer to row    mainOptionTable.linesOfOptions[4] ¬ mainOptionRow4; -- Save pointer to row    mainOptionTable.linesOfOptions[5] ¬ mainOptionRow5; -- Save pointer to row    mainOptionTable.optionMenuTiTle ¬ msgKey1[askMemory];    mainOptionRow0.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;    mainOptionRow0.optionsOnALine[0].option ¬ msgKey1[userDefaultMemory];  -- %Change    mainOptionRow1.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;    mainOptionRow1.optionsOnALine[0].option ¬ msgKey1[userMemory1];  -- %Change    mainOptionRow2.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 3;    mainOptionRow2.optionsOnALine[0].option ¬ msgKey1[userMemory2];  -- %Change    mainOptionRow3.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow3.optionsOnALine[0].selectionNumberForThisItem ¬ 4;    mainOptionRow3.optionsOnALine[0].option ¬ msgKey1[userMemory3];    mainOptionRow4.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow4.optionsOnALine[0].selectionNumberForThisItem ¬ 5;    mainOptionRow4.optionsOnALine[0].option ¬ msgKey1[userMemory4];    mainOptionRow5.optionsOnALine[0].position ¬ leftEdge;    mainOptionRow5.optionsOnALine[0].selectionNumberForThisItem ¬ 6;    mainOptionRow5.optionsOnALine[0].option ¬ msgKey1[userMemory5];  -- %Change    IF machineType = daisy THEN {      mainTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: mainOptionTable,	optionPrompt: msgKey1[enterResponse],	defaultOption: SELECT eePromImage.MainMemoryExpansion FROM	    mega1 => 1,	    k1512 => 2,	    mega2 => 3,	    k2512 => 4,	    mega3 => IF eePromImage.MainMemory8 = present AND			eePromImage.MainMemory9 = present AND			eePromImage.MainMemory10 = present AND			eePromImage.MainMemory11 = present AND			eePromImage.MainMemory12 = present AND			eePromImage.MainMemory13 = present AND			eePromImage.MainMemory14 = present AND			eePromImage.MainMemory15 = present THEN 6 ELSE 5	    ENDCASE => 0 ]; -- Example default      eePromImage.MainMemory0 _ present;      eePromImage.MainMemory1 _ present;      eePromImage.MainMemory2 _ present;      eePromImage.MainMemory3 _ present;      eePromImage.MainMemory4 _ present;      eePromImage.MainMemory5 _ present;      eePromImage.MainMemory6 _ present;      eePromImage.MainMemory7 _ present;      SELECT mainTypeSelected FROM	  6 => {	    eePromImage.MainMemory8 _ present;	    eePromImage.MainMemory9 _ present;	    eePromImage.MainMemory10 _ present;	    eePromImage.MainMemory11 _ present;	    eePromImage.MainMemory12 _ present;	    eePromImage.MainMemory13 _ present;	    eePromImage.MainMemory14 _ present;	    eePromImage.MainMemory15 _ present};	  ENDCASE => {	    eePromImage.MainMemory8 _ notPresent;	    eePromImage.MainMemory9 _ notPresent;	    eePromImage.MainMemory10 _ notPresent;	    eePromImage.MainMemory11 _ notPresent;	    eePromImage.MainMemory12 _ notPresent;	    eePromImage.MainMemory13 _ notPresent;	    eePromImage.MainMemory14 _ notPresent;	    eePromImage.MainMemory15 _ notPresent};      eePromImage.MainMemoryExpansion ¬ SELECT mainTypeSelected FROM	  1 => mega1,	  2 => k1512,	  3 => mega2,	  4 => k2512,	  5, 6 => mega3,	  ENDCASE => none}    ELSE {      mainTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: mainOptionTable,	optionPrompt: msgKey1[enterResponse],	defaultOption: SELECT eePromImage.MainMemoryExpansion FROM	    k512 => 1,	    mega1 => 2,	    k1512 => 3,	    mega2 => 4,	    k2512 => 5,	    mega3 => 6	    ENDCASE => 0 ]; -- Example default      eePromImage.MainMemory0 ¬ present;      eePromImage.MainMemory1 ¬ present;      eePromImage.MainMemory2 ¬ notPresent;      eePromImage.MainMemory3 ¬ notPresent;      eePromImage.MainMemory4 ¬ notPresent;      eePromImage.MainMemory5 ¬ notPresent;      eePromImage.MainMemory6 ¬ notPresent;      eePromImage.MainMemory7 ¬ notPresent;      eePromImage.MainMemory8 ¬ present;      eePromImage.MainMemory9 ¬ present;      eePromImage.MainMemory10 ¬ present;      eePromImage.MainMemory11 ¬ present;      eePromImage.MainMemory12 ¬ present;      eePromImage.MainMemory13 ¬ present;      eePromImage.MainMemory14 ¬ present;      eePromImage.MainMemory15 ¬ present;      eePromImage.MainMemoryExpansion ¬ SELECT mainTypeSelected FROM       		  1 => k512,	  2 => mega1,	  3 => k1512,	  4 => mega2,	  5 => k2512,	  6 => mega3	  ENDCASE => none }};  END;--******************************************************************************-- Get Universal Option:--******************************************************************************GetUniversalOption: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN  OptionTypes: TYPE = {none, lpo, spo};  numberOptionTypes: CARDINAL = ORD[LAST[OptionTypes]] + 1;  universalOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [3];  -- Just one row of option here  universalOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];  universalOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];  universalOptionRow2: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];  leftEdge: CARDINAL = 3;   -- For formatting display.  optionSelected: CARDINAL;  -- The option selected by the user  -- Now construct the universal option table  --  universalOptionTable.linesOfOptions[0] ¬ universalOptionRow0; -- Save pointer to row  universalOptionTable.linesOfOptions[1] ¬ universalOptionRow1; -- Save pointer to row  universalOptionTable.linesOfOptions[2] ¬ universalOptionRow2; -- Save pointer to row  universalOptionTable.optionMenuTiTle ¬ msgKey1[askUniversal];  universalOptionRow0.optionsOnALine[0].position ¬ leftEdge;  universalOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  universalOptionRow0.optionsOnALine[0].option ¬ msgKey[laserPrintingOption];  universalOptionRow1.optionsOnALine[0].position ¬ leftEdge;  universalOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;  universalOptionRow1.optionsOnALine[0].option ¬ msgKey[printingScanningOption];  universalOptionRow2.optionsOnALine[0].position ¬ leftEdge;  universalOptionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  universalOptionRow2.optionsOnALine[0].option ¬ msgKey[notPresent];  [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: universalOptionTable,      optionPrompt: msgKey[blanks], justDisplayTable:TRUE];  SELECT SysConfigControlDefs.statusPtr­ FROM    eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE, , , TRUE];    badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE, , , TRUE];    checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE, , , TRUE];    unKnown => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE, , , TRUE];    ENDCASE;    IF eePromImage.VersionEProm > EEpromDefs.VersionNumberROM OR    eePromImage.VersionRAM > EEpromDefs.VersionNumberRAM OR    eePromImage.VersionBadPages > EEpromDefs.VersionNumberBadPages    	THEN { Odi.PutMessage [msgKey1[badVersionNumber], TRUE, TRUE, , , FALSE]; };					  optionSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL,      optionPrompt: msgKey1[enterResponse],      defaultOption: SELECT eePromImage.OptionBoardOne.optionType FROM			laserPrintingOption	=> 1,			printingScanningOption	=> 2,			ENDCASE 		=> 3 ];			  -- there can only be one interrupt allocation			  eePromImage.OptionBoardOne.expansionInterruptAllocation ¬ ALL[FALSE];  -- set to default value  LOOPHOLE [eePromImage.OptionBoardOne.optionSpecificData,  	EEpromDefsExtras.ParallelPortOptionSpecificData] ¬ LPO;    SELECT optionSelected FROM    1 => { eePromImage.OptionBoardOne.optionType ¬ laserPrintingOption;    	   -- set option specific data to LPO    	   eePromImage.OptionBoardOne.expansionInterruptAllocation[ir0] ¬ TRUE };	         2 => { eePromImage.OptionBoardOne.optionType ¬ printingScanningOption;    	   -- set option specific data to SPO    	   LOOPHOLE [eePromImage.OptionBoardOne.optionSpecificData,	   	EEpromDefsExtras.ParallelPortOptionSpecificData] ¬ SPO;           eePromImage.OptionBoardOne.expansionInterruptAllocation[ir0] ¬ TRUE };	         ENDCASE => eePromImage.OptionBoardOne.optionType ¬ none;  END;	-- GetUniversalOption  --******************************************************************************-- Get VM Size:--******************************************************************************GetVMSize: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN-- VM types supported. Whenever new types are encountered, simply add   VMTypes: TYPE = {none, vm8mega, vm16mega,  vm32mega};    -- This option table presents the various VM types to the user for selection.  --   numberOfVMTypes: CARDINAL = ORD[LAST[VMTypes]] + 1;  vmOptionTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [3];  vmOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];   vmOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];        vmOptionRow2: LONG POINTER TO Odi.AnOptionLine ¬      Odi.GetAnOptionLine [1];   -- This option table presents the various vm types to the user for selection.  leftEdge: CARDINAL = 3;   -- For formatting display.  vmTypeSelected: CARDINAL;  -- The option selected by the user    vmOptionTable.linesOfOptions[0] ¬ vmOptionRow0; -- Save pointer to row  vmOptionTable.linesOfOptions[1] ¬ vmOptionRow1; -- Save pointer to row  vmOptionTable.linesOfOptions[2] ¬ vmOptionRow2; -- Save pointer to row    vmOptionTable.optionMenuTiTle ¬ msgKey1[askVMSize];    vmOptionRow0.optionsOnALine[0].position ¬ leftEdge;  vmOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  vmOptionRow0.optionsOnALine[0].option ¬ msgKey1[twentyTwoBitsVM];    vmOptionRow1.optionsOnALine[0].position ¬ leftEdge;  vmOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;  vmOptionRow1.optionsOnALine[0].option ¬ msgKey1[twentyThreeBitsVM];    vmOptionRow2.optionsOnALine[0].position ¬ leftEdge;  vmOptionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  vmOptionRow2.optionsOnALine[0].option ¬ msgKey1[twentyFourBitsVM];  vmTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: vmOptionTable,      optionPrompt: msgKey1[enterResponse],      	defaultOption: SELECT eePromImage.VMMSizeInPages FROM	  none => 0,	  vm8mega => 1,	  vm16mega => 2,	  vm32mega => 3,	ENDCASE => 1 ];        eePromImage.VMMSizeInPages ¬ SELECT vmTypeSelected FROM       	               	1 => vm8mega,          	2 => vm16mega,          	3 => vm32mega,        	ENDCASE => vm8mega;         END;END.LOG.created on 5-Sep-85 11:00:27	by: MR31-Jan-86 14:38:33	by: RRP	changes for 12.214-May-86 15:38:57	by: RRP	added support for Turbo (extended) disks23-Jan-87 16:03:55	by: RDM	Add daisy memory configuration & GetUniversalOption.29-Jan-87 16:28:15	by: RDM	Add Horizon disks.3-Feb-87 12:31:35	by: RDM	Change VERSION to Version in ProcessorFaceExtras.6-Feb-87 12:30:23	by: RDM	Fix daisy 4meg memory configuration.27-Mar-87 17:50:18	by: KXW	Fixed bug in GetUniversalOption. 8-Jun-87 14:56:27	by: JMA fixed SP option setting in EEPROM and added ref to EEpromDefsExtras27-Jan-88 13:23:50 by: STC add cartridge tape in DiskTypes 2-Oct-88 19:00:44 by: STC add 4MB, Labelless14-Oct-88  8:46:10 by: STC roll over the fix in normal user's Set Config10-Nov-88 12:30:13 by: STC roll over the fix in set diskShapeImage.type 6-Oct-89 18:59:13 by: TXM add swift94355100 and maxtorXT2190 7-Oct-89 13:56:56 by: TXM add Add separate 2MB and 4MB menu
-- File: DiagDiskRunCmdFileImpl.mesa - last edit:-- MXT                 10-Dec-85 11:53:47-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. ----DIRECTORY  DiagDiskCmdDrive USING [ExecuteCommands, Rigid--, Floppy--],  DiagRDDisplay USING [Subtests],  --DiagFDDisplay USING [TempLog],  DiagRDLog USING [LogStep, DisplayTempLog],  --DiagFDLog USING [LogStep],  DiagDiskGetCmdFile USING [CommandArray, GetCommandFile],  DiagDiskMkMisc USING [mkMisc],  DiagDiskTestControl USING [    LoopOnError, ReturningOnHardError, ReturningOnSoftError, ReturningAfterCommand,    SetUpTestControl, TCZipControl, TCRunCmdFile1, TCRunCmdFile2, TCRunCmdFile3],  --DiagFDErrorCheck USING [ECStandard1, Error, PublicErrorCheckArray],  DiagRDErrorCheck USING [ECStandard1, HardError, PublicErrorCheckArray],  DiagRDPVStuff USING [GenPhysicalVolume],  DiagRDTestRec USING [RunTestArray, Subtests, Subtest, SubTestBeingExecuted],  DiagRDTests USING [DisplayTestParameters, PassCount, PutGoodCompletion],  OfflineDiagInterface USING [    AbortCurrentTest, HitAnyKeyToContinue, OptionsRecord, GetAnOptionsRecord,    AnOptionLine, GetAnOptionLine, PutData, PutMessage, HelpText, GetAHelpText,    GetAnOption, GetANumber, GetYesNo, ResultType],  DiagDiskRunCmdFile USING [];DiagDiskRunCmdFileImpl: PROGRAM  IMPORTS    DiagDiskCmdDrive, DiagRDDisplay, DiagRDLog, --DiagFDDisplay, DiagFDLog,    DiagDiskGetCmdFile, DiagDiskMkMisc, DiagDiskTestControl, --DiagFDErrorCheck,    DiagRDErrorCheck, DiagRDPVStuff, DiagRDTestRec, DiagRDTests,    OfflineDiagInterface  EXPORTS DiagDiskRunCmdFile =  BEGIN OPEN DiagDiskMkMisc, Odi: OfflineDiagInterface;  SubtestArray: ARRAY [0..11] OF DiagRDTestRec.Subtest;  loopWhenError: BOOLEAN ¬ FALSE;  RunningUserCmdFile: PUBLIC BOOLEAN ¬ FALSE;  ValidCmdFile: PUBLIC BOOLEAN ¬ FALSE;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to build a new command file and run it  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BuildNewFile: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =    BEGIN    ValidCmdFile ¬ FALSE;    GetErrAction[];    DiagDiskGetCmdFile.GetCommandFile[];    ValidCmdFile ¬ TRUE;    IF DiagDiskCmdDrive.Rigid THEN      DiagRDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[        DiagRDErrorCheck.ECStandard1];    --IF DiagDiskCmdDrive.Floppy THEN      --DiagFDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[        --DiagFDErrorCheck.ECStandard1];    RunCmdFile[];    result ¬ none;    END;  --BuildNewFile  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to create a Physical Volume on the rigid disk  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CreatePhysicalVolume: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =    BEGIN    Odi.PutMessage[message: mkMisc[creatingPV], clearMessageAreaFirst: TRUE];    IF NOT Odi.GetYesNo[mkMisc[areYouSure]] THEN RETURN[none];    DiagRDPVStuff.GenPhysicalVolume[logBadPages: FALSE];    Odi.PutMessage[message: mkMisc[donE], clearMessageAreaFirst: TRUE];    result ¬ none;    END;  --CreatePhysicalVolume  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to run a prior build command file  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  RunPriorFile: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =    BEGIN    yes: BOOLEAN ¬ FALSE;    IF ValidCmdFile THEN {      GetErrAction[];      IF DiagDiskCmdDrive.Rigid THEN        DiagRDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[          DiagRDErrorCheck.ECStandard1];      --IF DiagDiskCmdDrive.Floppy THEN        --DiagFDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[          --DiagFDErrorCheck.ECStandard1];      RunCmdFile[];      }    ELSE      Odi.PutMessage[        message: mkMisc[noCmdFileToRerun], beep: TRUE,        clearMessageAreaFirst: TRUE];    result ¬ none;    END;  --RunPriorFile  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to get and execute allready built subtests  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  RunSubtests: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =    BEGIN    yes: BOOLEAN ¬ FALSE;    GetSubtests[];    DiagRDTests.DisplayTestParameters[      getPassCount: TRUE, secondsPerPass: 0, putTotalPassCount: TRUE,      putPassesLeftToRun: TRUE];    -- run the test    DiagRDTestRec.RunTestArray[subtestSelectArray: DESCRIPTOR[SubtestArray]];    DiagRDTests.PassCount ¬ DiagRDTests.PassCount - 1;    UNTIL DiagRDTests.PassCount = 0 DO      DiagRDTests.DisplayTestParameters[        secondsPerPass: 0, putPassesLeftToRun: TRUE, putTotalPassCount: TRUE];      DiagRDTestRec.RunTestArray[subtestSelectArray: DESCRIPTOR[SubtestArray]];      DiagRDTests.PassCount ¬ DiagRDTests.PassCount - 1;      ENDLOOP;    DiagRDTests.PutGoodCompletion[];    result ¬ none;    END;  --RunSubtests  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to get what to do with errors  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetErrAction: PROCEDURE =    BEGIN    num: CARDINAL ¬ 0;    helpTextPtr: LONG POINTER TO Odi.HelpText;    cmdRcrdPtr: LONG POINTER TO Odi.OptionsRecord;    optionLinePtr: LONG POINTER TO Odi.AnOptionLine;    cmdRcrdPtr ¬ Odi.GetAnOptionsRecord[numberOfLines: 5];    cmdRcrdPtr.optionMenuTiTle ¬ mkMisc[errActioN];    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 1;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[ignoreErrs];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[ignoreErrsExpl];    cmdRcrdPtr.linesOfOptions[0] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 2;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[continueOnErr];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[continueOnErrExpl];    cmdRcrdPtr.linesOfOptions[1] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 3;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[stopOnErr];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[stopOnErrExpl];    cmdRcrdPtr.linesOfOptions[2] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 4;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[loopOnErr];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[loopOnErrExpl];    cmdRcrdPtr.linesOfOptions[3] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 5;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[stepCmds];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[stepCmdsExpl];    cmdRcrdPtr.linesOfOptions[4] ¬ optionLinePtr;    helpTextPtr ¬ Odi.GetAHelpText[numberOfLines: 1];    helpTextPtr.textBody[0] ¬ mkMisc[enterChoiceNumExpl];    loopWhenError ¬ FALSE;    num ¬ Odi.GetAnOption[      optionTable: cmdRcrdPtr, optionPrompt: mkMisc[enterChoiceNum],      optionHelp: helpTextPtr];    SELECT num FROM      1 => {        DiagDiskTestControl.SetUpTestControl[          controlData: DiagDiskTestControl.TCZipControl];        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.LogStep ¬ FALSE;        --IF DiagDiskCmdDrive.Floppy THEN DiagFDLog.LogStep ¬ FALSE;        };      2 => {        DiagDiskTestControl.SetUpTestControl[          controlData: DiagDiskTestControl.TCRunCmdFile1];        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.LogStep ¬ FALSE;        --IF DiagDiskCmdDrive.Floppy THEN DiagFDLog.LogStep ¬ FALSE;        };      3 => {        DiagDiskTestControl.SetUpTestControl[          controlData: DiagDiskTestControl.TCRunCmdFile2];        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.LogStep ¬ TRUE;        --IF DiagDiskCmdDrive.Floppy THEN DiagFDLog.LogStep ¬ TRUE;        };      4 => {        DiagDiskTestControl.SetUpTestControl[          controlData: DiagDiskTestControl.TCRunCmdFile2];        loopWhenError ¬ TRUE;        IF DiagDiskCmdDrive.Rigid AND DiagRDErrorCheck.HardError THEN          DiagDiskTestControl.LoopOnError ¬ TRUE;        --IF DiagDiskCmdDrive.Floppy AND DiagFDErrorCheck.Error THEN          --DiagDiskTestControl.LoopOnError ¬ TRUE;        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.LogStep ¬ FALSE;        --IF DiagDiskCmdDrive.Floppy THEN DiagFDLog.LogStep ¬ FALSE;        };      5 => {        DiagDiskTestControl.SetUpTestControl[          controlData: DiagDiskTestControl.TCRunCmdFile3];        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.LogStep ¬ TRUE;        --IF DiagDiskCmdDrive.Floppy THEN DiagFDLog.LogStep ¬ TRUE;        };      ENDCASE;    END;  --GetErrAction  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to get what to do with errors  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetSubtests: PROCEDURE =    BEGIN    done: BOOLEAN ¬ FALSE;    num: CARDINAL ¬ 0;    cmdRcrdPtr: LONG POINTER TO Odi.OptionsRecord;    optionLinePtr: LONG POINTER TO Odi.AnOptionLine;    helpTextPtr: LONG POINTER TO Odi.HelpText ¬ Odi.GetAHelpText[numberOfLines: 1];    helpTextPtr.textBody[0] ¬ mkMisc[subtestExpl];    cmdRcrdPtr ¬ Odi.GetAnOptionsRecord[numberOfLines: 4];    cmdRcrdPtr.optionMenuTiTle ¬ mkMisc[subtestOptions];    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 1;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[displaySubtest];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[displaySubtestExpl];    cmdRcrdPtr.linesOfOptions[0] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 2;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[subtestSelection];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[      subtestSelectionExpl];    cmdRcrdPtr.linesOfOptions[1] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 3;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[runSubtest];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[runSubtestExpl];    cmdRcrdPtr.linesOfOptions[2] ¬ optionLinePtr;    optionLinePtr ¬ Odi.GetAnOptionLine[optionsPerLine: 1];    optionLinePtr.optionsOnALine[0].position ¬ 2;    optionLinePtr.optionsOnALine[0].selectionNumberForThisItem ¬ 4;    optionLinePtr.optionsOnALine[0].option ¬ mkMisc[exit];    optionLinePtr.optionsOnALine[0].helpForThisOption ¬ mkMisc[exitExpl];    cmdRcrdPtr.linesOfOptions[3] ¬ optionLinePtr;    helpTextPtr ¬ Odi.GetAHelpText[numberOfLines: 1];    helpTextPtr.textBody[0] ¬ mkMisc[enterChoiceNumExpl];    UNTIL done DO      num ¬ Odi.GetAnOption[        optionTable: cmdRcrdPtr, optionPrompt: mkMisc[enterChoiceNum],        optionHelp: NIL];      SELECT num FROM        1 => DiagRDDisplay.Subtests[];        2 => {          subtst: CARDINAL ¬ 1;          subtestPtr: CARDINAL ¬ 0;          Odi.PutData[data: " ", clearHeadingAndData: TRUE];          SubtestArray ¬ ALL[VAL[0]];  --NoOp subtests          UNTIL subtestPtr >= LENGTH[SubtestArray] OR subtst = 0 DO            subtst ¬ Odi.GetANumber[              prompt: mkMisc[subtest], lowLimit: 0,              upperLimit: ORD[LAST[DiagRDTestRec.Subtest]],              help: helpTextPtr].number;            SubtestArray[subtestPtr] ¬ VAL[subtst];            Odi.PutData[              data: DiagRDTestRec.Subtests[VAL[subtst]].title,              startWithNewLine: TRUE];            subtestPtr ¬ subtestPtr + 1;            ENDLOOP;          Odi.PutMessage[message: " ", clearMessageAreaFirst: TRUE];          };        3 => done ¬ TRUE;        4 => SIGNAL Odi.AbortCurrentTest;        ENDCASE;      ENDLOOP;    END;  --GetSubtests  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to run the command file  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  RunCmdFile: PROCEDURE =    BEGIN    RunningUserCmdFile ¬ TRUE;    DiagRDTestRec.SubTestBeingExecuted ¬ VAL[0];    DiagDiskCmdDrive.ExecuteCommands[      commandArray: DESCRIPTOR[DiagDiskGetCmdFile.CommandArray] !      DiagDiskTestControl.ReturningOnSoftError,        DiagDiskTestControl.ReturningOnHardError => {        IF loopWhenError THEN {DiagDiskTestControl.LoopOnError ¬ TRUE; RESUME ; };        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.DisplayTempLog[];        --IF DiagDiskCmdDrive.Floppy THEN DiagFDDisplay.TempLog[];        GetErrAction[];        RESUME        ;        };      DiagDiskTestControl.ReturningAfterCommand => {        IF DiagDiskCmdDrive.Rigid THEN DiagRDLog.DisplayTempLog[];        --IF DiagDiskCmdDrive.Floppy THEN DiagFDDisplay.TempLog[];        Odi.HitAnyKeyToContinue[];        GetErrAction[];        RESUME        }];    RunningUserCmdFile ¬ FALSE;    END;  --RunCmdFile  END.... --of DiagDiskRunCmdFileImpl.mesa    10-Dec-85 11:53:46	MXT: Floppy Disk related statements are commented out.	
-- File SysConfigRigidDiskImpl.mesa-- Last edited-- TXM,  6-Oct-89 18:47:51, add swift94355100 and maxtorXT2190-- TXM, 15-Dec-88 13:22:55, add mitsubishiMR335 and mitsubishiMR548-- STC,  2-Oct-88 23:02:04, Labelless add toshibaMK134FA-- STC, 17-Oct-87 19:26:44, convert to 14.0-- STC, 18-Sep-87 21:51:45, change Fuji disks-- STC, 17-Sep-87 17:17:46, fix bug if select "Return"-- STC, 7-Jul-87  9:48:09, changes in WriteManufDef-- STC, ****** SelfDecribing changes by JPM were merged after 10-Oct-87 *****-- JPM 28-May-87 12:23:18 Replace temporary strings with new msgKey strings-- JPM 15-May-87 10:02:50 Fix nits in disk type display/change code-- JPM 13-May-87 13:52:47 Add code to display/change disk shape parms-- JPM  1-May-87 11:49:37 Add GetRigidDiskTypeString-- STC,  1-May-87  8:27:13, remove defaultConfigDone-- STC, 28-Mar-87 11:05:27, use EXIT in GetDriveSelection-- STC, 27-Mar-87 15:27:31, merge 1.3e & 1.5c.-- 29-Jan-87 10:17:32	RDM Add Horizon disks.-- 27-Jan-87 13:47:34	RDM Add separate FX disk menu.-- 9-Dec-86 10:07:33	RDM Add EEprom error messages.-- RRP  14-May-86 15:59:14  added support for Turbo (extended) disks-- RRP	30-Jan-86 14:23:45	changes for 12.2-- edited:	17-Oct-85 14:31:04	by: AMR-- Created	18-Jun-85 14:49:03	by: AMR<<	Copyright (C) 1985, 1986, 1987, 1988, 1989 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  SysConfigRigidDiskDefs	USING [ diskShapeImage, rigidDiskArray,					rigidDisks ],  EEpromDefs	        USING [ EEpromConfig, RigidDiskTypeBits ],  Inline	        USING [ LowHalf, LowByte ],  OfflineDiagInterface  USING [ OfflineDiagnosticProc,			        AbortCurrentTest, DisplayItem,				OptionsRecord, AnOptionLine, GetAnOptionsRecord,				GetAnOptionLine, GetAnOption, OptionItem,				GetAFixedPositionDisplayRecord, GetARow,				GetANumber, GetYesNo, 			        FixedPositionDisplayRecord, ARow, 				DisplayFixedPositionData,			        PutMessage, PutTestParameters],  SysConfigSubDefs,  SysConfigControlDefs  USING [ msgKey, msgKey1, msgKey2, statusPtr],  SysConfigChannelDefs  USING [ eePromImage],  SysConfigEEPromDefs	USING [ WriteEEProm];    SysConfigRigidDiskImpl: PROGRAM	IMPORTS SysConfigRigidDiskDefs, Inline, OfflineDiagInterface,	    SysConfigControlDefs, SysConfigChannelDefs,	    SysConfigEEPromDefs, SysConfigSubDefs			EXPORTS SysConfigRigidDiskDefs, SysConfigSubDefs =	BEGIN OPEN Odi: OfflineDiagInterface, SysConfigControlDefs, SysConfigChannelDefs,	SysConfigSubDefs;  -- Odi stands for OfflineDiagInterface.--******************************************************************************-- GetRigidDiskTypeString:--******************************************************************************GetRigidDiskTypeString: PUBLIC PROCEDURE [type: EEpromDefs.RigidDiskTypeBits]    RETURNS [LONG STRING] =  {RETURN [SELECT type FROM	none => msgKey[notPresent],    	seagateST212 => msgKey[seagateST212],	seagateST213 => msgKey[seagateST213],	tandonTM703 => msgKey[tandonTM703],	tandonTM702AT => msgKey[tandonTM702AT],	seagateST4026 => msgKey[seagateST4026],	quantumQ530 => msgKey[quantumQ530],	seagateST225 => msgKey[seagateST225],	quantumQ540 => msgKey[quantumQ540],	micropolis1303 => msgKey[micropolis1303],	seagateST4051 => msgKey[seagateST4051],	seagateST251 => msgKey[seagateST251],	micropolis1325 => msgKey[micropolis1325],	seagateST4096 => msgKey[seagateST4096],	extendedTandonTM703 => msgKey[extendedTandonTM703],	extendedTandonTM702 => msgKey[extendedTandonTM702],	extendedSeagateST4026 => msgKey[extendedSeagateST4026],	extendedQuantumQ530 => msgKey[extendedQuantumQ530],	extendedSeagateST225 => msgKey[extendedSeagateST225],	extendedSeagateST4051 => msgKey[extendedSeagateST4051],	extendedSeagateST251 => msgKey[extendedSeagateST251],	mitsubishiMR533 => msgKey[mitsubishiMR533],	mitsubishiMR535 => msgKey[mitsubishiMR535],	fujitsuM2225D => msgKey[fujitsuM2225D],	fujitsuM2227D => msgKey[fujitsuM2227D],	fujitsuM2243T => msgKey[fujitsuM2243T],--	necD5146H => msgKey[necD5146H],	mitsubishiMR322US => msgKey1[mitsubishiMR322US],	mitsubishiMR535US => msgKey1[mitsubishiMR535US],	fujitsuM2243AS => msgKey1[fujitsuM2243AS],	toshibaMK56FB => msgKey1[toshibaMK56FB],	toshibaMK134FA => msgKey2[toshibaMK134FA],	necD3126US => msgKey1[necD3126US],	necD5146HUS => msgKey1[necD5146HUS],	mitsubishiMR335 => msgKey2[mitsubishiMR335],	mitsubishiMR548 => msgKey2[mitsubishiMR548],	swift94355100 => msgKey2[swift94355100],	maxtorXT2190 => msgKey2[maxtorXT2190],      ENDCASE => msgKey[unknown]]};--******************************************************************************-- ConfigureRigidDisk:--******************************************************************************ConfigureRigidDisk: PUBLIC Odi.OfflineDiagnosticProc =  BEGIN	     [] ¬ ConfigRDDisk [];  END; -- ConfigureRigidDisk -- for ManufDefault, by STCConfigRDDisk: PUBLIC PROCEDURE =  BEGIN   leftEdge: CARDINAL = 3;   -- For formatting display.  noNumericData: CARDINAL = 0;  menuSelection: CARDINAL;  -- The menu option selected by the user  nDisks: CARDINAL = SysConfigRigidDiskDefs.rigidDisks;  newDiskType: CARDINAL = nDisks + 1;  exit: CARDINAL = newDiskType + 1;  aSpace: CARDINAL = 1;  WrEEProm: BOOLEAN ¬ FALSE;  -- SetupMenu which determines whether to display the US/RX disk menu or the FX menu.  MenuSelections: TYPE = {USRXmenu, FXmenu};  numberOfRows: CARDINAL ¬ ORD[LAST[MenuSelections]] + 2; -- Need an extra 1 for the exit selection.  numberOfOptionsPerRow: CARDINAL ¬ 1;  menuOptionTable: LONG POINTER TO Odi.OptionsRecord ¬     Odi.GetAnOptionsRecord [numberOfRows];	-- numbered 0 to numberOfRows-1.  menuOptionRow0: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [numberOfOptionsPerRow];  menuOptionRow1: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [numberOfOptionsPerRow];  menuOptionRow2: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [numberOfOptionsPerRow];-- Setup menu table for displaying disk types.  numberOfUSDiskMenuRows: CARDINAL = 11;  numberOfFXDiskMenuRows: CARDINAL = 4;  usDiskTypeTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [numberOfUSDiskMenuRows];  fxDiskTypeTable: LONG POINTER TO Odi.OptionsRecord ¬      Odi.GetAnOptionsRecord [numberOfFXDiskMenuRows];  optionRow0: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3]; -- 3 options on this line.  optionRow1: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow2: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow3: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow4: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow5: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow6: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];   optionRow7: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow8: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [3];  optionRow9: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2]; -- 2 options on this line.  optionRow10: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [2];  optionRow11: LONG POINTER TO Odi.AnOptionLine ¬ Odi.GetAnOptionLine [1]; -- 1 options on this line.    -- Setup table for new disk info  driveInformation: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬      Odi.GetAFixedPositionDisplayRecord [10];  -- 10 single-itemed rows of data  driveInfoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item on row  driveInfoRow1: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow2: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow3: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow4: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow5: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow6: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow7: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow8: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  driveInfoRow9: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [2];  -- 1 item  SetUpOption: PROCEDURE[position, selectionNumberForThisItem: CARDINAL,      string: LONG STRING]       RETURNS [optionItem: Odi.OptionItem] =    BEGIN    optionItem.position ¬ position;    optionItem.selectionNumberForThisItem ¬ selectionNumberForThisItem;    optionItem.option ¬ string;    RETURN[optionItem];    END;	-- SetUpOption  SetUpRow: PROCEDURE[namePosition: CARDINAL, name: LONG STRING,			stringValue: LONG STRING]       RETURNS [displayItem: Odi.DisplayItem] =    BEGIN    displayItem.namePosition ¬ namePosition;    displayItem.name ¬ name;    displayItem.stringValue ¬ stringValue;    displayItem.valuePosition ¬ noNumericData;    RETURN[displayItem];    END;	-- SetUpRow.  SetupDriveInfoTable: PROCEDURE [diskTypeSelected, newDiskType: CARDINAL] = {    driveInfoRow1.rowItems[0].valuePosition ¬      leftEdge + msgKey[diskType].length + aSpace;    driveInfoRow1.rowItems[0].stringValue ¬      GetRigidDiskTypeString[VAL[diskTypeSelected]];    IF diskTypeSelected = newDiskType THEN {      driveInfoRow1.rowItems[0].value ¬        LONG[LOOPHOLE[SysConfigRigidDiskDefs.diskShapeImage.type]];      driveInfoRow2.rowItems[0].value ¬ eePromImage.RigidDiskSectorsPerTrack;      driveInfoRow3.rowItems[0].value ¬ eePromImage.RigidDiskHeadsPerCylinder;      driveInfoRow4.rowItems[0].value ¬ eePromImage.RigidDiskHeadsCylinderCount;      driveInfoRow5.rowItems[0].value ¬        eePromImage.RigidDiskReducedWriteCylinder;      driveInfoRow6.rowItems[0].value ¬        eePromImage.RigidDiskPreCompensationCylinder;      driveInfoRow7.rowItems[0].value ¬        eePromImage.RigidDiskHeadLandingZone;      driveInfoRow8.rowItems[0].value ¬        SysConfigRigidDiskDefs.diskShapeImage.rpm;      driveInfoRow9.rowItems[0].stringValue ¬        IF SysConfigRigidDiskDefs.diskShapeImage.vcmDisk THEN msgKey1[yes] ELSE msgKey1[no]}    ELSE {      driveInfoRow1.rowItems[0].value ¬	LONG[LOOPHOLE[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].type]]; --Word data      driveInfoRow2.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].SectorsPerTrack]; --Byte data      driveInfoRow3.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].HeadsPerCylinder]; --Byte data      driveInfoRow4.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].CylinderCount]; --Word data      driveInfoRow5.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].ReducedWriteCylinder]; --Word data      driveInfoRow6.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].PreCompensationCylinder]; --Word data      driveInfoRow7.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].HeadLandingZone]; --Word data      driveInfoRow8.rowItems[0].value ¬	LONG[SysConfigRigidDiskDefs.rigidDiskArray[	  diskTypeSelected-1].rpm]; --Word data      driveInfoRow9.rowItems[0].stringValue ¬	IF SysConfigRigidDiskDefs.rigidDiskArray[diskTypeSelected-1].vcmDisk	  THEN msgKey1[yes] ELSE msgKey1[no]}; --Boolean data    driveInfoRow1.rowItems[1].stringValue ¬      GetRigidDiskTypeString[eePromImage.RigidDiskType];    IF driveInfoRow1.rowItems[1].stringValue = msgKey[unknown] THEN {      driveInfoRow1.rowItems[1].value ¬        LONG[LOOPHOLE[SysConfigRigidDiskDefs.diskShapeImage.type]];      driveInfoRow1.rowItems[1].valuePosition ¬ leftEdge + 45 +        msgKey[diskType].length + aSpace; };    driveInfoRow2.rowItems[1].value ¬ eePromImage.RigidDiskSectorsPerTrack;    driveInfoRow3.rowItems[1].value ¬ eePromImage.RigidDiskHeadsPerCylinder;    driveInfoRow4.rowItems[1].value ¬ eePromImage.RigidDiskHeadsCylinderCount;    driveInfoRow5.rowItems[1].value ¬ eePromImage.RigidDiskReducedWriteCylinder;    driveInfoRow6.rowItems[1].value ¬      eePromImage.RigidDiskPreCompensationCylinder;    driveInfoRow7.rowItems[1].value ¬      eePromImage.RigidDiskHeadLandingZone;    driveInfoRow8.rowItems[1].value ¬      SysConfigRigidDiskDefs.diskShapeImage.rpm;    driveInfoRow9.rowItems[1].stringValue ¬      IF SysConfigRigidDiskDefs.diskShapeImage.vcmDisk THEN msgKey1[yes] ELSE msgKey1[no];    };	-- SetupDriveInfoTable.  GetNewDiskType: PROCEDURE [] =     BEGIN    emptyInformation: LONG POINTER TO Odi.FixedPositionDisplayRecord ¬        Odi.GetAFixedPositionDisplayRecord [1];    emptyInfoRow0: LONG POINTER TO Odi.ARow ¬ Odi.GetARow [1];    emptyInformation.displayTitle ¬ msgKey[configRigidDisk];    emptyInformation.rows[0] ¬ emptyInfoRow0;    emptyInfoRow0.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[blanks], NIL];     Odi.PutMessage [msgKey[dataSpaceBar]];     Odi.PutTestParameters [       parameters: emptyInformation,       upDateOnly: FALSE];     Odi.DisplayFixedPositionData [  -- Display the drive information       displayData: driveInformation, upDateOnly: FALSE];            driveInfoRow1.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[newDisk],	lowLimit: 0,	upperLimit: 0FFFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow1.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];   -- Update display        -- Get sectorsPerTrack info     driveInfoRow2.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[sectorsPerTrack],	lowLimit: 0,	upperLimit: 0FFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow2.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display        -- Get numberOfHeads     driveInfoRow3.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[numberOfHeads],	lowLimit: 0,	upperLimit: 0FFH, 	numberIsLong: TRUE,	defaultNumber: driveInfoRow3.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display        -- Get cylindersPerDrive     driveInfoRow4.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[cylindersPerDrive],	lowLimit: 0,	upperLimit: 0FFFFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow4.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display        -- Get reduceWrCurCylinder     driveInfoRow5.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[reduceWrCurCylinder],	lowLimit: 0,	upperLimit: 0FFFFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow5.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display        -- Get precompesationCylinder     driveInfoRow6.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[precompCylinder],	lowLimit: 0,	upperLimit: 7FFFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow6.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display     -- Get HeadLandingZone     driveInfoRow7.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey[landingZone],	lowLimit: 0,	upperLimit: 0FFFFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow7.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display       -- Get rpm     driveInfoRow8.rowItems[0].value ¬ Odi.GetANumber [	prompt: msgKey1[rpm],	lowLimit: 0,	upperLimit: 0FFFFH,	numberIsLong: TRUE,	defaultNumber: driveInfoRow8.rowItems[0].value].longNumber;     Odi.DisplayFixedPositionData [driveInformation];  -- Update display     -- Get vcmDisk     driveInfoRow9.rowItems[0].stringValue ¬ IF Odi.GetYesNo [	prompt: msgKey1[vcmDisk],	defaultSpecified: TRUE,	default: driveInfoRow9.rowItems[0].stringValue = msgKey1[yes]]	  THEN msgKey1[yes] ELSE msgKey1[no];     Odi.DisplayFixedPositionData [driveInformation];  -- Update display    END;	-- GetNewDiskType.GetDriveSelection: PROCEDURE [useFXmenu: BOOLEAN] =     BEGIN    initialEntry: BOOLEAN ¬ TRUE;    diskTypeSelected: CARDINAL;  -- The disk option selected by the user    MapUSMenuToEEPROM: PROCEDURE[diskTypeSelected: CARDINAL]       RETURNS [EEpromDefs.RigidDiskTypeBits] =      BEGIN      RETURN[SELECT diskTypeSelected FROM	  1 => seagateST212,	  2 => seagateST213,	  3 => tandonTM703,	  4 => tandonTM702AT,	  5 => seagateST4026,	  6 => quantumQ530,	  7 => seagateST225,	  8 => mitsubishiMR322US,	  9 => necD3126US,	  10 => extendedTandonTM703,	  11 => extendedTandonTM702,	  12 => extendedSeagateST4026,	  13 => extendedQuantumQ530,	  14 => extendedSeagateST225,	  15 => quantumQ540,	  16 => micropolis1303,	  17 => seagateST4051,	  18 => seagateST251,	  19 => mitsubishiMR535US,	  20 => necD5146HUS,	  21 => extendedSeagateST4051,	  22 => extendedSeagateST251,	  23 => micropolis1325,	  24 => seagateST4096,	  25 => fujitsuM2243AS,	  26 => toshibaMK56FB,	  27 => swift94355100,	  28 => maxtorXT2190,	  29 => LOOPHOLE[newDiskType],	  30 => LOOPHOLE[exit],	  ENDCASE => none];      END;	-- MapUSMenuToEEPROM.    MapFXMenuToEEPROM: PROCEDURE[diskTypeSelected: CARDINAL]       RETURNS [EEpromDefs.RigidDiskTypeBits] =      BEGIN      RETURN[SELECT diskTypeSelected FROM	1 => mitsubishiMR533,	2 => mitsubishiMR535,	3 => fujitsuM2225D,	4 => fujitsuM2227D,	5 => fujitsuM2243T,	6 => toshibaMK134FA,	7 => mitsubishiMR335,	8 => mitsubishiMR548,	9 => LOOPHOLE[newDiskType],	10 => LOOPHOLE[exit],	ENDCASE => none];      END;	-- MapFXMenuToEEPROM.    DO  -- Loop until exit is requested        diskTypeSelected ¬ Odi.GetAnOption [  -- Always returns a valid option	optionTable: (IF useFXmenu THEN fxDiskTypeTable ELSE usDiskTypeTable),	optionPrompt: msgKey[respondToPrompt], defaultOption: 0];      initialEntry ¬ FALSE;      diskTypeSelected ¬ (IF useFXmenu THEN LOOPHOLE[MapFXMenuToEEPROM[diskTypeSelected]]      			ELSE LOOPHOLE[MapUSMenuToEEPROM[diskTypeSelected]]);      IF diskTypeSelected = exit THEN {WrEEProm ¬ FALSE; EXIT;};<<	SIGNAL Odi.AbortCurrentTest; -- Exit requested, removed by STC >>      -- Update fixed-position display record. diskTypeSelected is always valid      SetupDriveInfoTable[diskTypeSelected, newDiskType];      IF diskTypeSelected = newDiskType THEN GetNewDiskType[];      -- Transfer drive info table to eePromImage.      SELECT diskTypeSelected FROM	IN [1..nDisks] => eePromImage.RigidDiskType ¬	  EEpromDefs.RigidDiskTypeBits[LOOPHOLE[diskTypeSelected]];        ENDCASE => eePromImage.RigidDiskType ¬	  Inline.LowByte[Inline.LowHalf[driveInfoRow1.rowItems[0].value]];      eePromImage.RigidDiskSectorsPerTrack ¬        Inline.LowByte[Inline.LowHalf[driveInfoRow2.rowItems[0].value]]; -- sectorsPerTrack      eePromImage.RigidDiskHeadsPerCylinder ¬        Inline.LowByte[Inline.LowHalf[driveInfoRow3.rowItems[0].value]]; -- numberOfHeads      eePromImage.RigidDiskHeadsCylinderCount ¬        Inline.LowHalf[driveInfoRow4.rowItems[0].value]; -- cylindersPerDrive      eePromImage.RigidDiskReducedWriteCylinder ¬        Inline.LowHalf[driveInfoRow5.rowItems[0].value]; -- reduceWrCurCylinder      eePromImage.RigidDiskPreCompensationCylinder ¬        Inline.LowHalf[driveInfoRow6.rowItems[0].value]; --precompensationCylinder      eePromImage.RigidDiskHeadLandingZone ¬        Inline.LowHalf[driveInfoRow7.rowItems[0].value]; --landing zone      SysConfigRigidDiskDefs.diskShapeImage ¬ [        type: Inline.LowHalf[driveInfoRow1.rowItems[0].value],	pagesPerTrack: Inline.LowHalf[driveInfoRow2.rowItems[0].value],	headsPerCylinder: Inline.LowHalf[driveInfoRow3.rowItems[0].value],	cylinderCount: Inline.LowHalf[driveInfoRow4.rowItems[0].value],	reducedWriteCylinder: Inline.LowHalf[driveInfoRow5.rowItems[0].value],	preCompensationCylinder: Inline.LowHalf[driveInfoRow6.rowItems[0].value],	headLandingZone: Inline.LowHalf[driveInfoRow7.rowItems[0].value],	rpm: Inline.LowHalf[driveInfoRow8.rowItems[0].value],	vcmDisk: (driveInfoRow9.rowItems[0].stringValue = msgKey1[yes]),	unused: ALL[FALSE]];           driveInfoRow1.rowItems[0].valuePosition ¬ noNumericData;      driveInfoRow1.rowItems[1].valuePosition ¬ noNumericData;             IF (initialEntry = FALSE) AND (diskTypeSelected IN [1..nDisks]) THEN EXIT;--        SIGNAL Odi.AbortCurrentTest;      ENDLOOP; -- Outer loop    END;	-- GetDriveSelection.-- for ManufDefault, STC  WriteManufDef: PROC =    BEGIN    stopcount: CARDINAL ¬ 0;    done: BOOLEAN¬ FALSE;    IF SysConfigEEPromDefs.WriteEEProm [] = success	THEN { Odi.PutTestParameters[parameters: NIL]; -- clean screen	      	      Odi.PutMessage [message:msgKey1[eePromUpdated],	     	clearMessageAreaFirst:TRUE];		 SysConfigSubDefs.ManufDef ¬ 0;		 UNTIL done DO		     ENDLOOP}	ELSE Odi.PutMessage [message:msgKey1[eePromUpdateFailed],	     	clearMessageAreaFirst:TRUE];  SysConfigSubDefs.ManufDef ¬ 0;  END; --WriteManufDefConfigureUSRigidDisk: PROCEDURE =     BEGIN    xPosition: CARDINAL;  -- Number for tracking position on current line    xOffset: CARDINAL;    -- Now construct the Rigid disk type option table    --    usDiskTypeTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row    usDiskTypeTable.linesOfOptions[1] ¬ optionRow1;    usDiskTypeTable.linesOfOptions[2] ¬ optionRow2;    usDiskTypeTable.linesOfOptions[3] ¬ optionRow3;    usDiskTypeTable.linesOfOptions[4] ¬ optionRow4;    usDiskTypeTable.linesOfOptions[5] ¬ optionRow5;    usDiskTypeTable.linesOfOptions[6] ¬ optionRow6;    usDiskTypeTable.linesOfOptions[7] ¬ optionRow7;    usDiskTypeTable.linesOfOptions[8] ¬ optionRow8;    usDiskTypeTable.linesOfOptions[9] ¬ optionRow11;    usDiskTypeTable.linesOfOptions[10] ¬ optionRow10;    usDiskTypeTable.optionMenuTiTle ¬ msgKey[diskTypesSupported];    xPosition ¬ leftEdge;    xOffset ¬ msgKey[extendedSeagateST4026].length + 8;    optionRow0.optionsOnALine[0] ¬ SetUpOption[xPosition, 1, msgKey[seagateST212]];        xPosition ¬ xPosition + xOffset;    optionRow0.optionsOnALine[1] ¬ SetUpOption[xPosition, 2, msgKey[seagateST213]];        xPosition ¬ xPosition + xOffset;    optionRow0.optionsOnALine[2] ¬ SetUpOption[xPosition, 3, msgKey[tandonTM703]];        xPosition ¬ leftEdge;    optionRow1.optionsOnALine[0] ¬ SetUpOption[xPosition, 4, msgKey[tandonTM702AT]];        xPosition ¬ xPosition + xOffset;    optionRow1.optionsOnALine[1] ¬ SetUpOption[xPosition, 5, msgKey[seagateST4026]];        xPosition ¬ xPosition + xOffset;    optionRow1.optionsOnALine[2] ¬ SetUpOption[xPosition, 6, msgKey[quantumQ530]];        xPosition ¬ leftEdge;    optionRow2.optionsOnALine[0] ¬ SetUpOption[xPosition, 7, msgKey[seagateST225]];    xPosition ¬ xPosition + xOffset;    optionRow2.optionsOnALine[1] ¬ SetUpOption[xPosition, 8,      msgKey1[mitsubishiMR322US]];        xPosition ¬ xPosition + xOffset;    optionRow2.optionsOnALine[2] ¬ SetUpOption[xPosition, 9,      msgKey1[necD3126US]];        xPosition ¬ leftEdge;    optionRow3.optionsOnALine[0] ¬ SetUpOption[xPosition, 10,      msgKey[extendedTandonTM703]];        xPosition ¬ xPosition + xOffset;    optionRow3.optionsOnALine[1] ¬ SetUpOption[xPosition, 11,      msgKey[extendedTandonTM702]];        xPosition ¬ xPosition + xOffset;    optionRow3.optionsOnALine[2] ¬ SetUpOption[xPosition, 12,      msgKey[extendedSeagateST4026]];        xPosition ¬ leftEdge;    optionRow4.optionsOnALine[0] ¬ SetUpOption[xPosition, 13, msgKey[extendedQuantumQ530]];        xPosition ¬ xPosition + xOffset;    optionRow4.optionsOnALine[1] ¬ SetUpOption[xPosition, 14,      msgKey[extendedSeagateST225]];        xPosition ¬ xPosition + xOffset;    optionRow4.optionsOnALine[2] ¬ SetUpOption[xPosition, 15,      msgKey[quantumQ540]];        xPosition ¬ leftEdge;    optionRow5.optionsOnALine[0] ¬ SetUpOption[xPosition, 16, msgKey[micropolis1303]];    xPosition ¬ xPosition + xOffset;    optionRow5.optionsOnALine[1] ¬ SetUpOption[xPosition, 17,      msgKey[seagateST4051]];        xPosition ¬ xPosition + xOffset;    optionRow5.optionsOnALine[2] ¬ SetUpOption[xPosition, 18,      msgKey[seagateST251]];    xPosition ¬ leftEdge;    optionRow6.optionsOnALine[0] ¬ SetUpOption[xPosition, 19,      msgKey1[mitsubishiMR535US]];    xPosition ¬ xPosition + xOffset;    optionRow6.optionsOnALine[1] ¬ SetUpOption[xPosition, 20,      msgKey1[necD5146HUS]];    xPosition ¬ xPosition + xOffset;    optionRow6.optionsOnALine[2] ¬ SetUpOption[xPosition, 21, msgKey[extendedSeagateST4051]];        xPosition ¬ leftEdge;    optionRow7.optionsOnALine[0] ¬ SetUpOption[xPosition, 22,      msgKey[extendedSeagateST251]];        xPosition ¬ xPosition + xOffset;    optionRow7.optionsOnALine[1] ¬ SetUpOption[xPosition, 23,      msgKey[micropolis1325]];        xPosition ¬ xPosition + xOffset;    optionRow7.optionsOnALine[2] ¬ SetUpOption[xPosition, 24, msgKey[seagateST4096]];        xPosition ¬ leftEdge;    optionRow8.optionsOnALine[0] ¬ SetUpOption[xPosition, 25,      msgKey1[fujitsuM2243AS]];        xPosition ¬ xPosition + xOffset;    optionRow8.optionsOnALine[1] ¬ SetUpOption[xPosition, 26,      msgKey1[toshibaMK56FB]];    xPosition ¬ xPosition + xOffset;    optionRow8.optionsOnALine[2] ¬ SetUpOption[xPosition, 27,      msgKey2[swift94355100]];    xPosition ¬ leftEdge;    optionRow11.optionsOnALine[0] ¬ SetUpOption[xPosition, 28,      msgKey2[maxtorXT2190]];    xPosition ¬ leftEdge;    optionRow10.optionsOnALine[0] ¬ SetUpOption[xPosition, 29, --newDiskType      msgKey[newDisk]];      xPosition ¬ xPosition + msgKey[newDisk].length + 8;    optionRow10.optionsOnALine[1] ¬ SetUpOption[xPosition, 30,      msgKey[exitSelection]];    GetDriveSelection[FALSE];    IF (WrEEProm AND (SysConfigSubDefs.ManufDef = 9753)) THEN WriteManufDef [];    END; -- ConfigureUSRigidDisk    ConfigureFXRigidDisk: PROCEDURE =     BEGIN    xPosition: CARDINAL;  -- Number for tracking position on current line    xOffset: CARDINAL;    fxDiskTypeTable.linesOfOptions[0] ¬ optionRow0; -- Save pointer to row    fxDiskTypeTable.linesOfOptions[1] ¬ optionRow1; -- was optionRow8    fxDiskTypeTable.linesOfOptions[2] ¬ optionRow9;    fxDiskTypeTable.linesOfOptions[3] ¬ optionRow10;    fxDiskTypeTable.optionMenuTiTle ¬ msgKey[diskTypesSupported];    xPosition ¬ leftEdge;    xOffset ¬ msgKey2[toshibaMK134FA].length + 8;    optionRow0.optionsOnALine[0] ¬ SetUpOption[xPosition, 1,       msgKey[mitsubishiMR533]];      xPosition ¬ xPosition + xOffset;    optionRow0.optionsOnALine[1] ¬ SetUpOption[xPosition, 2,       msgKey[mitsubishiMR535]];        xPosition ¬ xPosition + xOffset;    optionRow0.optionsOnALine[2] ¬ SetUpOption[xPosition, 3,      msgKey[fujitsuM2225D]];      xPosition ¬ leftEdge;    optionRow1.optionsOnALine[0] ¬ SetUpOption[xPosition, 4,      msgKey[fujitsuM2227D]];      xPosition ¬ xPosition + xOffset;    optionRow1.optionsOnALine[1] ¬ SetUpOption[xPosition, 5,      msgKey[fujitsuM2243T]];      xPosition ¬ xPosition + xOffset;    optionRow1.optionsOnALine[2] ¬ SetUpOption[xPosition, 6,      msgKey2[toshibaMK134FA]];    xPosition ¬ leftEdge;    optionRow9.optionsOnALine[0] ¬ SetUpOption[xPosition, 7,      msgKey2[mitsubishiMR335]];      xPosition ¬ xPosition + xOffset;    optionRow9.optionsOnALine[1] ¬ SetUpOption[xPosition, 8,      msgKey2[mitsubishiMR548]];    xPosition ¬ leftEdge;    optionRow10.optionsOnALine[0] ¬ SetUpOption[xPosition, 9,      msgKey[newDisk]];      xPosition ¬ xPosition + msgKey[newDisk].length + 8;    optionRow10.optionsOnALine[1] ¬ SetUpOption[xPosition, 10,      msgKey[exitSelection]];    GetDriveSelection[TRUE];    IF (WrEEProm AND (SysConfigSubDefs.ManufDef = 9753)) THEN WriteManufDef [];    END;		-- ConfigureFXRigidDisk.-- Begin main code for ConfigureRigidDisk.  IF SysConfigControlDefs.statusPtr­ # success THEN {    continue: BOOLEAN _ TRUE;    SELECT SysConfigControlDefs.statusPtr­ FROM      eePromError => Odi.PutMessage [msgKey1[eePromReadFailed], TRUE, TRUE];      badCommand => Odi.PutMessage [msgKey1[eePromBadCommand], TRUE, TRUE];      checkSumError => Odi.PutMessage [msgKey1[eePromCheckSumError], TRUE, TRUE];      badMemConfig => Odi.PutMessage [msgKey1[eePromMemConfigError], TRUE, TRUE];      ENDCASE => Odi.PutMessage [msgKey1[eePromUnknownError], TRUE, TRUE];    continue ¬ Odi.GetYesNo [prompt: msgKey1[doYouWishToContinue]];    IF ~continue THEN SIGNAL Odi.AbortCurrentTest};    -- Fill in the driveInformation record fields    driveInformation.displayTitle ¬ msgKey[FixedDataTitle];    driveInformation.rows[0] ¬ driveInfoRow0;  -- First row    driveInformation.rows[1] ¬ driveInfoRow1;  -- Second row    driveInformation.rows[2] ¬ driveInfoRow2;  -- Third row    driveInformation.rows[3] ¬ driveInfoRow3;  -- Fourth row    driveInformation.rows[4] ¬ driveInfoRow4;  -- Fifth row    driveInformation.rows[5] ¬ driveInfoRow5;  -- Sixth row    driveInformation.rows[6] ¬ driveInfoRow6;  -- Sixth row    driveInformation.rows[7] ¬ driveInfoRow7;  -- Eighth row    driveInformation.rows[8] ¬ driveInfoRow8;  -- Ninth row    driveInformation.rows[9] ¬ driveInfoRow9;  -- Tenth row    -- Now fill in the static fields of the display record    --    -- Fill in first row static data    driveInfoRow0.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[blanks], NIL];      driveInfoRow0.rowItems[1] ¬ SetUpRow[leftEdge+45, msgKey[blanks], NIL];        -- Fill in second row static data    driveInfoRow1.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[diskType], NIL];      driveInfoRow1.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey[diskType], NIL];      -- Fill in third row static data    driveInfoRow2.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[sectorsPerTrack], NIL];    driveInfoRow2.rowItems[0].valuePosition ¬        leftEdge + msgKey[sectorsPerTrack].length + aSpace;        driveInfoRow2.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey[sectorsPerTrack],      NIL];    driveInfoRow2.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey[sectorsPerTrack].length + aSpace;        -- Fill in fourth row static data    driveInfoRow3.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[numberOfHeads], NIL];    driveInfoRow3.rowItems[0].valuePosition ¬        leftEdge + msgKey[numberOfHeads].length + aSpace;        driveInfoRow3.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey[numberOfHeads], NIL];    driveInfoRow3.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey[numberOfHeads].length + aSpace;        -- Fill in fifth row static data    driveInfoRow4.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[cylindersPerDrive], NIL];    driveInfoRow4.rowItems[0].valuePosition ¬        leftEdge + msgKey[cylindersPerDrive].length + aSpace;        driveInfoRow4.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey[cylindersPerDrive],      NIL];    driveInfoRow4.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey[cylindersPerDrive].length + aSpace;      -- Fill in sixth row    driveInfoRow5.rowItems[0] ¬ SetUpRow[leftEdge,msgKey[reduceWrCurCylinder], NIL];    driveInfoRow5.rowItems[0].valuePosition ¬        leftEdge + msgKey[reduceWrCurCylinder].length + aSpace;        driveInfoRow5.rowItems[1] ¬ SetUpRow[leftEdge + 45,msgKey[reduceWrCurCylinder],      NIL];    driveInfoRow5.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey[reduceWrCurCylinder].length + aSpace;        -- Fill in seventh row    driveInfoRow6.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[precompCylinder], NIL];    driveInfoRow6.rowItems[0].valuePosition ¬        leftEdge + msgKey[precompCylinder].length + aSpace;        driveInfoRow6.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey[precompCylinder],      NIL];    driveInfoRow6.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey[precompCylinder].length + aSpace;      -- Fill in eighth row    driveInfoRow7.rowItems[0] ¬ SetUpRow[leftEdge, msgKey[landingZone], NIL];    driveInfoRow7.rowItems[0].valuePosition ¬        leftEdge + msgKey[landingZone].length + aSpace;        driveInfoRow7.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey[landingZone], NIL];    driveInfoRow7.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey[landingZone].length + aSpace;    -- Fill in ninth row    driveInfoRow8.rowItems[0] ¬ SetUpRow[leftEdge, msgKey1[rpm], NIL];    driveInfoRow8.rowItems[0].valuePosition ¬        leftEdge + msgKey1[rpm].length + aSpace;    driveInfoRow8.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey1[rpm], NIL];    driveInfoRow8.rowItems[1].valuePosition ¬        leftEdge + 45 + msgKey1[rpm].length + aSpace;    -- Fill in tenth row    driveInfoRow9.rowItems[0] ¬ SetUpRow[leftEdge, msgKey1[vcmDisk], NIL];    driveInfoRow9.rowItems[1] ¬ SetUpRow[leftEdge + 45, msgKey1[vcmDisk], NIL];-- Determine whether to display the US/RX disk selection or the FX disk selection.  menuOptionTable.linesOfOptions[0] ¬ menuOptionRow0;  menuOptionTable.linesOfOptions[1] ¬ menuOptionRow1;  menuOptionTable.linesOfOptions[2] ¬ menuOptionRow2;  menuOptionTable.optionMenuTiTle ¬ msgKey[selectRigidDiskMenu];  menuOptionRow0.optionsOnALine[0].position ¬ leftEdge;  menuOptionRow0.optionsOnALine[0].selectionNumberForThisItem ¬ 1;  menuOptionRow0.optionsOnALine[0].option ¬ msgKey[FXmenu];    menuOptionRow1.optionsOnALine[0].position ¬ leftEdge;  menuOptionRow1.optionsOnALine[0].selectionNumberForThisItem ¬ 2;  menuOptionRow1.optionsOnALine[0].option ¬ msgKey[USRXmenu];    menuOptionRow2.optionsOnALine[0].position ¬ leftEdge;  menuOptionRow2.optionsOnALine[0].selectionNumberForThisItem ¬ 3;  menuOptionRow2.optionsOnALine[0].option ¬ msgKey[exitSelection];  [] ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: menuOptionTable,      optionPrompt: msgKey[blanks], justDisplayTable:TRUE];  menuSelection ¬ Odi.GetAnOption [  -- Always returns a valid option      optionTable: NIL,      optionPrompt: msgKey1[enterResponse],      defaultOption: 1 ];  WrEEProm ¬ TRUE;  -- Call the appropriate menu.  SELECT menuSelection FROM    1 => ConfigureFXRigidDisk;    2 => ConfigureUSRigidDisk;    ENDCASE => SIGNAL Odi.AbortCurrentTest;  -- Exit requested  END;		-- ConfigRDDiskEND.logcreated on 18-Jun-85 14:49:03 by Allen Roberts 
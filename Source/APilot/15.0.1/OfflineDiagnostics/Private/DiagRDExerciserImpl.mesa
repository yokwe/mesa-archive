-- File: DiagRDExerciserImpl.mesa-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- Last edited: STC, 4-Oct-88  8:50:44 DIRECTORY DiagDiskCmdDrive	USING	[MaxCylinder, ExecuteCommands], DiagDiskMkMisc		USING	[mkMisc], DiagDiskMkSubtest, DiagRDTestCmdArrays, DiagDiskTestControl	USING	[SetUpTestControl, TCSurfVer3, 				 TestControlRecord, 				 ReturningOnHardError, ReturningOnSoftError], DiagRDErrorCheck	USING	[ECStandard1, PublicErrorCheckArray], DiagRDPVStuff		USING	[GenPhysicalVolume], DiagRDSurfaceVerify	USING	[SurfaceVerify], DiagRDTestRec		USING	[RunTestArray, Subtest], DiagRDTests		USING	[DisplayTestParameters, 				 InitializeTestStuff, PassCount,				 PutGoodCompletion], DiskUtilityMiscDove	USING	[GoFormatDisk, -- InitStarted, 				-- preFormatBPT, 				-- ReadCurrentBPTFromDisk, StartInit,				 virginDisk], OfflineDiagInterface	USING	[GetYesNo, GetANumber, HelpText, 				 PutMessage, ResultType], DiagRDExerciser	USING	[];  DiagRDExerciserImpl:  PROGRAM     IMPORTS	DiagDiskCmdDrive,	DiagDiskMkMisc,	DiagDiskTestControl,	DiagRDErrorCheck,	DiagRDPVStuff,	DiagRDSurfaceVerify,	DiagRDTestCmdArrays,	DiagRDTestRec,	DiagRDTests,	OfflineDiagInterface,	DiskUtilityMiscDove    EXPORTS	DiagRDExerciser, DiskUtilityMiscDove  = BEGIN     OPEN        DiagDiskMkMisc,        DiagRDTestCmdArrays,        DiagDiskTestControl,        DiagRDErrorCheck,        DiskUtilityMiscDove,	Odi: OfflineDiagInterface;     InExerciser:		PUBLIC BOOLEAN;  helpText: LONG POINTER TO Odi.HelpText;  ManufDskCkOut: PUBLIC BOOLEAN ¬ FALSE;   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- exercise the selected Unit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   RunNewDiskCheck:  PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] = BEGIN runTime:		LONG CARDINAL ¬ 255; getPassCnt:		BOOLEAN ¬ TRUE;  DiagRDTests.InitializeTestStuff[]; DiagRDTests.PassCount¬ 1;  --display warning IF NOT Odi.GetYesNo[prompt: mkMisc[destructiveWARNING]] THEN { result¬ none;   RETURN; };  UNTIL DiagRDTests.PassCount<= 0 DO   DiagRDTests.DisplayTestParameters[		getPassCount:		getPassCnt,		secondsPerPass:		runTime,		putTotalPassCount:	TRUE,		putPassesLeftToRun:	TRUE,		putTimePerPass:		TRUE,		putRunTimeLeft:		TRUE];     ExerciseUnit [];   DiagRDTests.PassCount¬ DiagRDTests.PassCount- 1;   getPassCnt¬ FALSE; ENDLOOP; DiagRDPVStuff.GenPhysicalVolume[logBadPages: FALSE]; DiagRDTests.PutGoodCompletion[]; result¬ none; END; --RunNewDiskCheck        -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to do a basic verification on a given Unit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ExerciseUnit: PROCEDURE = BEGIN  cylCnt:		CARDINAL¬ 1; subtestSelectArray1:	ARRAY [0..29] OF DiagRDTestRec.Subtest¬   [-- STClearLog,	    STClearTrace,		--start trace and error logging    STStartLog,    STStartTrace,       STWrWrWrDisk,		--format entire disk    STVrRdRdCyl0FmtDt,		--verifies head and sector addressing    STVrRdRdAllCylsFmtDt,	--cylinder address test       STVrWrWr0sLstScTrk0,	--write and read data pattern tests cylinder 0    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWr1sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWr5sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWrAsLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,   --    STVrVrRdLstScTrk0,	Labelless--label verify error logic test--    STVrVrVrLstScTrk0,	--data verify error logic test--    STPassedLstCyl,		--read passed last cylinder    STIllegalOpr,		--test illegal operation       STVrRdNpLstScTrk0,		--different legal command test    STVrVrWrLstScTrk0,    STRecal,			--test recalibrate    STVrWrWr0sCylLstEx,		--write and read data pattern tests last cylinder    STVrRdRdCmpLbDtCylLstEx,    STVrWrWr1sCylLstEx,    STVrRdRdCmpLbDtCylLstEx,    STVrWrWr5sCylLstEx,    STVrRdRdCmpLbDtCylLstEx,    STVrWrWrAsCylLstEx,    STVrRdRdCmpLbDtCylLstEx,       STRndWrVr1Ex,		--random VWW, VRR, verify data (double sector)    STRndWrVr2Ex,		--random VWW, VVR, verify data (double sector)    STRndWrVr3Ex,		--random VWW, VVV, verify data (double sector)    STRndWrVr4Ex		--random VWW, VVV, verify data (single sector)				--this last one check for max soft error count   ]; InExerciser¬ TRUE; DiagRDTestRec.RunTestArray [	subtestSelectArray: DESCRIPTOR [subtestSelectArray1]]; DiagDiskTestControl.SetUpTestControl[controlData: 					DiagDiskTestControl.TCSurfVer3]; DiagRDErrorCheck.PublicErrorCheckArray¬ 					DESCRIPTOR [DiagRDErrorCheck.ECStandard1];   -- display title Odi.PutMessage[message: mkMisc[subtesT],		clearMessageAreaFirst: TRUE]; Odi.PutMessage[message: mkMisc[surfaceVerification], 		startWithNewLine: FALSE,		blankSpaces: 1]; DiagRDSurfaceVerify.SurfaceVerify[ 			retryCount: 9, 			displayData: TRUE,			returnOnError: FALSE,			callServiceOnError: FALSE]; -- DiagRDPVStuff.GenPhysicalVolume[logBadPages: FALSE]; InExerciser ¬ FALSE; END; --ExerciseUnit			 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- exercise the selected Unit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   RunMfDiskCheck:  PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] = BEGIN   CkIfFormat: PROC RETURNS [yes: BOOLEAN ¬ FALSE] =	BEGIN	testCommands: ARRAY [0..20] OF CARDINAL ¬ [	   7, 0, 1,  --StartLoop[0,1];	   20, 22, 26,  --VerifyHeader/ReadLabel/ReadData[	   1,  --Recalibrate first: Yes	   0,  --Single buffer: no	   1,  --Try count: 1	   0, 1, 0,  --Cylinder: 0+0	   0, 1, 0,  --Head: 0+0	   0, 1, 1,  --Sector: 0+1	   1,  --SectorCount: 1	   8,  --EndLoop;	   29];  --EndOfFile;	testControl: DiagDiskTestControl.TestControlRecord = [	   controlUnit: TRUE, controlLoopCount: FALSE, checkForError: TRUE,	   returnOnHardError: TRUE, returnOnSoftError: TRUE];	Odi.PutMessage[message: DiagDiskMkMisc.mkMisc[checkFormat],	   clearMessageAreaFirst: FALSE];    	DiagDiskTestControl.SetUpTestControl[controlData: testControl];	DiagRDErrorCheck.PublicErrorCheckArray ¬ DESCRIPTOR[	   DiagRDErrorCheck.ECStandard1];	DiagDiskCmdDrive.ExecuteCommands[	   DESCRIPTOR[testCommands] !	      DiagDiskTestControl.ReturningOnHardError, 	   	      	      DiagDiskTestControl.ReturningOnSoftError => GOTO error];	RETURN[TRUE];	EXITS	   error => {	   Odi.PutMessage[		message: DiagDiskMkMisc.mkMisc[mayBeUnformatted],		clearMessageAreaFirst: FALSE];	   RETURN[FALSE]};	END; runTime: LONG CARDINAL ¬ 200; getPassCnt: BOOLEAN ¬ FALSE; ManufDskCkOut ¬ TRUE; DiskUtilityMiscDove.virginDisk ¬ TRUE; << IF CkIfFormat[] THEN {DiskUtilityMiscDove.virginDisk ¬ FALSE} 	 ELSE {DiskUtilityMiscDove.virginDisk ¬ TRUE}; IF ~DiskUtilityMiscDove.virginDisk AND ~DiskUtilityMiscDove.InitStarted THEN       DiskUtilityMiscDove.StartInit; IF ~DiskUtilityMiscDove.virginDisk  AND DiskUtilityMiscDove.InitStarted THEN       preFormatBPT ¬ DiskUtilityMiscDove.ReadCurrentBPTFromDisk[preFormatBPT];-- Odi.PutMessage[message: mkMisc[loadingWait],--		clearMessageAreaFirst: FALSE];   >> DiagRDTests.InitializeTestStuff[]; ManufDskCkOut ¬ TRUE; DiagRDTests.PassCount¬ 1; -- display warning if found not a virgin disk IF ~virginDisk THEN 	{IF NOT (Odi.GetYesNo[mkMisc[spare1], NIL,TRUE, FALSE]) THEN	   { result¬ none; RETURN;};}; DiagRDTests.DisplayTestParameters[ -- to reset a flag!		getPassCount:		FALSE,		secondsPerPass:		runTime,		putTotalPassCount:	FALSE,		putPassesLeftToRun:	FALSE,		putTimePerPass:		FALSE,		putRunTimeLeft:		FALSE];   UNTIL DiagRDTests.PassCount<= 0 DO   DiagRDTests.DisplayTestParameters[		getPassCount:		getPassCnt,		secondsPerPass:		runTime,		putTotalPassCount:	TRUE,		putPassesLeftToRun:	TRUE,		putTimePerPass:		TRUE,		putRunTimeLeft:		TRUE];     DiskCheck [];   DiagRDTests.PassCount¬ DiagRDTests.PassCount- 1;   getPassCnt¬ FALSE; ENDLOOP; DiskUtilityMiscDove.GoFormatDisk []; ManufDskCkOut ¬ FALSE; DiagRDTests.PutGoodCompletion[]; result¬ none; END; --RunMfDiskCheck        -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to do a basic verification on a given Unit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DiskCheck: PROCEDURE = BEGIN  cylCnt:		CARDINAL¬ 1; subtestSelectArray1:	ARRAY [0..18] OF DiagRDTestRec.Subtest¬   [-- STClearLog,	    STClearTrace,		--start trace and error logging    STStartLog,    STStartTrace,       STWrWrWrDisk,		--format entire disk    STVrRdRdCyl0FmtDt,		--verifies head and sector addressing    STVrRdRdAllCylsFmtDt,	--cylinder address test   <<    STVrWrWr0sLstScTrk0,	--write and read data pattern tests cylinder 0    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWr1sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWr5sLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,    STVrWrWrAsLstScTrk0,    STVrRdRdCmpLbDtLstScTrk0,>>   --    STVrVrRdLstScTrk0,		--label verify error logic test--    STVrVrVrLstScTrk0,		--data verify error logic test--    STPassedLstCyl,		--read passed last cylinder    STIllegalOpr,		--test illegal operation       STVrRdNpLstScTrk0,		--different legal command test    STVrVrWrLstScTrk0,    STRecal,			--test recalibrate    STVrWrWr0sCylLstEx,		--write and read data pattern tests last cylinder    STVrRdRdCmpLbDtCylLstEx,    STVrWrWr1sCylLstEx,    STVrRdRdCmpLbDtCylLstEx,    STVrWrWr5sCylLstEx,    STVrRdRdCmpLbDtCylLstEx,    STVrWrWrAsCylLstEx,    STVrRdRdCmpLbDtCylLstEx,       STRndWrVr1Mf		--random VWW, VRR, VVR, VVV (double sector)   ];		 InExerciser¬ TRUE; DiagRDTestRec.RunTestArray [	subtestSelectArray: DESCRIPTOR [subtestSelectArray1]]; DiagDiskTestControl.SetUpTestControl[controlData: 					DiagDiskTestControl.TCSurfVer3]; DiagRDErrorCheck.PublicErrorCheckArray¬ 					DESCRIPTOR [DiagRDErrorCheck.ECStandard1];   -- display title Odi.PutMessage[message: mkMisc[subtesT],		clearMessageAreaFirst: TRUE]; Odi.PutMessage[message: mkMisc[surfaceVerification], 		startWithNewLine: FALSE,		blankSpaces: 1];<< DiagRDSurfaceVerify.SurfaceVerify[ 			retryCount: 9, 			displayData: TRUE,			returnOnError: FALSE,			callServiceOnError: FALSE];>> Odi.PutMessage [message: mkMisc[creatingPV],    		     clearMessageAreaFirst: TRUE]; DiagRDPVStuff.GenPhysicalVolume[logBadPages: FALSE];  InExerciser ¬ FALSE; END; --DiskCheck			-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- This is actually the Formatter for Manufacture, should use the right name-- ******** Fix this on the next release! **********-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  TestAPage: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType] =   BEGIN   ManufDskCkOut ¬ FALSE;   DiagRDTests.InitializeTestStuff[];   DiskUtilityMiscDove.GoFormatDisk [];   END; --TestAPage  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to do a basic verification on a given cylinder -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  TestACylinder: PUBLIC PROCEDURE RETURNS [result: Odi.ResultType ¬ none] =   BEGIN   zero: CARDINAL = 0;   last: CARDINAL ¬ 1000;   CylinderNumb:  CARDINAL;       DiagRDTests.InitializeTestStuff[];   CylinderNumb ¬ Odi.GetANumber[prompt: mkMisc[desiredCylinder],	 	  help: helpText, lowLimit: 0, upperLimit: LAST[CARDINAL],		  defaultNumber: 32767].number;   IF CylinderNumb = 0 THEN     { IF Odi.GetYesNo [prompt: mkMisc[testCylin0],			defaultSpecified: TRUE,default: FALSE] THEN      		{CylinderNumb ¬ 0} ELSE RETURN};   IF (CylinderNumb > DiagDiskCmdDrive.MaxCylinder) THEN      CylinderNumb ¬ DiagDiskCmdDrive.MaxCylinder;   TestCyl [CylinderNumb];   END; --TestACylinder  TestCyl: PROCEDURE [cylNumber: CARDINAL] =   BEGIN   getPassCnt: BOOLEAN ¬ TRUE;   runTime: LONG CARDINAL ¬ 20; -- **** TBD ****   subtestArray1:	ARRAY [0..4] OF DiagRDTestRec.Subtest;   subtestArray2:	ARRAY [0..5] OF DiagRDTestRec.Subtest;   DiagRDTestCmdArrays.testLabel ¬ 0;   DiagRDTestCmdArrays.testData ¬ 0;   DiagRDTestCmdArrays.testCylinder ¬ cylNumber;   Cmds[CAWrWrWrCyl][6] ¬ cylNumber;   DiagRDTests.DisplayTestParameters[		getPassCount:		getPassCnt,		secondsPerPass:		runTime,		putTotalPassCount:	TRUE,		putPassesLeftToRun:	TRUE,		putTimePerPass:		TRUE,		putRunTimeLeft:		TRUE];   getPassCnt ¬ FALSE;   subtestArray1 ¬     [STClearLog,			--start trace and error logging      STClearTrace,      STStartLog,      STStartTrace,      STWrWrWrCyl];		--format entire cylinder   DiagRDTestRec.RunTestArray [	subtestSelectArray: DESCRIPTOR [subtestArray1]];--   DiagRDTests.PassCount ¬ 1; UNTIL DiagRDTests.PassCount<= 0 DO      DiagRDTestCmdArrays.testLabel ¬      	 DiagRDTestCmdArrays.testLabel + 28086; -- pattern 6DB6 hex      DiagRDTestCmdArrays.testData ¬      	 DiagRDTestCmdArrays.testData + 28086; -- pattern 6DB6 hex      DiagRDTestCmdArrays.Cmds[CAVrWrWrsCyl][9] ¬ cylNumber;      DiagRDTestCmdArrays.Cmds[CAVrWrWrsCyl][19] ¬ DiagRDTestCmdArrays.testLabel;      DiagRDTestCmdArrays.Cmds[CAVrWrWrsCyl][20] ¬ DiagRDTestCmdArrays.testData;      DiagRDTestCmdArrays.Cmds[CAVrVrWrsCyl][9] ¬ cylNumber;      DiagRDTestCmdArrays.Cmds[CAVrVrWrsCyl][19] ¬ DiagRDTestCmdArrays.testLabel;      DiagRDTestCmdArrays.Cmds[CAVrVrWrsCyl][20] ¬ DiagRDTestCmdArrays.testData;      DiagRDTestCmdArrays.Cmds[CAVrVrVrCyl][9] ¬ cylNumber;      subtestArray2 ¬        [STStartLog,         STStartTrace,         STVrWrWrsCyl,	-- write and read data pattern test cylinder         STVrVrVrCyl,         STVrVrWrsCyl,         STVrVrVrCyl];          DiagRDTestRec.RunTestArray [	   subtestSelectArray: DESCRIPTOR [subtestArray2]];      subtestArray1 ¬        [STStartLog,         STStartTrace,         STVrVrVrCyl,         STVrVrVrCyl,         STVrVrVrCyl];          DiagRDTestRec.RunTestArray [	   subtestSelectArray: DESCRIPTOR [subtestArray1]];       DiagRDTests.PassCount ¬ DiagRDTests.PassCount- 1;       DiagRDTests.DisplayTestParameters[		getPassCount:		getPassCnt,		secondsPerPass:		runTime,		putTotalPassCount:	TRUE,		putPassesLeftToRun:	TRUE,		putTimePerPass:		TRUE,		putRunTimeLeft:		TRUE];      ENDLOOP;-- ***** need some error checking???? ******   DiagRDTests.PutGoodCompletion[];   IF cylNumber = 0 THEN Odi.PutMessage[message: mkMisc[mustFormat],		clearMessageAreaFirst: FALSE];   END; -- TestCyl END... LOG13-Dec-85 13:45:43  MXT	Create Physical Volume at the end of New disk checkout.26-Feb-87 16:22:01  STC Added TestAPage, TestACylinder, GoFormatDisk 8-Mar-87 13:53:38 by STC, TestACylinder17-Mar-87 20:03:14 by STC, check BPT before Format24-Mar-87 10:47:21 by STC, add ManufDskCkOut and more SurfaceVerify after format 2-Apr-87  8:28:08 by STC, add Warning and wait for confirmation if not a virgin disk30-May-87 10:19:16 by STC, force virginDisk if RunMfDiskCheck 9-Jun-87 14:37:12 by STC, change lowLimit of GetANumber to 030-Jun-87 15:56:38 by STC, Manuf CkOut reset flag in DisplayTestParameters 7-Aug-87 11:35:17 by STC, move GenPhysicalVolume out of ExerciseUnit28-Aug-87 10:22:15, remove STClearLog in DiskCheck, add warning if ~virginDisk, simplified DiskCheck, add TryCount for Manufacturing 8-Sep-87 15:17:09 STC, remove userType, TryCount18-Sep-87 16:01:55 STC, add Formatter (use PROC TestAPage, fix it later!) 4-Oct-88  8:38:31, STC, Labelless
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- AuthAImpl.mesa-- JMaloney, 11-Jul-83 12:24:49.-- Last modified: JMaloney, 20-Jun-84 11:16:36.DIRECTORY  Auth USING [    AuthenticationProblem, CallProblem,    CheckOutCredsAndNextVerifier, CheckSimpleCredentials,    ConversationHandle, CopyCredentials, Credentials, FetchStrongCredentials,    Flavor, HashedPassword, HashSimplePassword, IdentityHandle, Key,    nullCredentials, nullHostNumber, nullKey,    nullVerifier, PasswordStringToKey, Verifier, WhichArg],  AuthInternal USING [    asStubHeap, CloneNSName, CloneNSString, CloneVerifier,    ConversationObject, EquivalentNames, FreeCredentials,    FreeNSName, FreeNSString, FreeVerifier, IdentityObject,    IncrementVerifierTicks, InternalAuthenticate,    InternalExtractCredentialsDetails, MakeEmptyNSName,    MakeVerifierFromHashedPassword, MakeSimpleCredentials,    NilOrNullName, PackStrongVerifier, Style, UnpackStrongVerifier],  AuthProtocol USING [StrongVerifier],  AuthSpecial USING [],  CH USING [    ConversationHandle, FreeConversationHandle,    LookupDistinguishedName, ReturnCode],  Courier USING [Error],  DESFace USING [CheckKeyParity, Key, nullKey],  Heap USING [Create, MakeNode],  NSName USING [    CopyNameFields, maxDomainLength, maxLocalLength, maxOrgLength, Name],  NSString USING [nullString, String],  NSStringExtras USING [EquivalentNames],  Process USING [InitializeMonitor, Pause, SecondsToTicks, Ticks],  Router USING [AssignAddress],  SharedKeys USING [asName, chsName, msName],  SpecialCHAuth USING [],  System USING [    GetClockPulses, GetGreenwichMeanTime, gmtEpoch,    GreenwichMeanTime, HostNumber, NetworkAddress,    nullHostNumber, SecondsSinceEpoch];AuthAImpl: MONITOR  LOCKS LOOPHOLE[identity, PrivateIdentityHandle]­ USING identity: Auth.IdentityHandle  IMPORTS    Auth, AuthInternal, CH, Courier, DESFace, Heap, NSName,    NSStringExtras, Process, Router, SharedKeys, System  EXPORTS Auth, AuthSpecial, SpecialCHAuth  SHARES Auth =BEGIN-- Globals and constants --cacheConversations: BOOLEAN ¬ TRUE;conversationCacheTimeout: LONG CARDINAL = LONG[12] * LONG[60] * LONG[60];  -- 12 hours, in seconds (half of the crentials lifetime).conversationHeap: UNCOUNTED ZONE ¬ Heap.Create[initial: 4, increment: 4];  -- All conversations and associated storage (creds, etc.) are allocated  -- from this heap. We no longer use the clients heap. This was  -- because conversation caching made it possible for one  -- client to lose storage owned by another.asStubHeap: UNCOUNTED ZONE = AuthInternal.asStubHeap;timesHaveHadToWaitForNextVerifier: CARDINAL ¬ 0;  -- This global is the number of times we've tried to create more than one  -- verifier within a given second and run out of ticks since the last boot.  -- It should be pretty small.thisMachinesAddress: System.NetworkAddress ¬ Router.AssignAddress[];-- Public errors --AuthenticationError: PUBLIC ERROR [reason: Auth.AuthenticationProblem] = CODE;CallError: PUBLIC ERROR [reason: Auth.CallProblem, whichArg: Auth.WhichArg] = CODE;OrphanConversation: PUBLIC ERROR = CODE;  -- This error is raised by Refresh only.-- Private errors --BadLineClock: PRIVATE ERROR = CODE;  -- Indicates that the line clock is not advancing.  -- Should never happen unless your hardware is broken.-- Identities --MakeIdentity: PUBLIC PROC [  myName: NSName.Name, password: NSString.String, z: UNCOUNTED ZONE,  style: Auth.Flavor, dontCheck: BOOLEAN]    RETURNS [identity: Auth.IdentityHandle] =  BEGIN    newIdentity: PrivateIdentityHandle;    newIdentity ¬  z.NEW[AuthInternal.IdentityObject];    newIdentity.style ¬ style;    newIdentity.myName ¬ AuthInternal.MakeEmptyNSName[z];  -- Assume: newIdentity.myName will be big enough to hold myName;  --   no heap will be needed by CopyNameFields.    NSName.CopyNameFields[      z: NIL, source: myName, destination: newIdentity.myName];    newIdentity.myPassword ¬ AuthInternal.CloneNSString[password, z];    newIdentity.myStrongKey ¬ PrivateKey[Auth.PasswordStringToKey[password]];    newIdentity.myHashedPassword ¬ Auth.HashSimplePassword[password];    newIdentity.nameHasBeenResolved ¬ FALSE;    newIdentity.conversationsInUse ¬ NIL;    newIdentity.cachedConversations ¬ NIL;    newIdentity.owningHeap ¬ z;    Process.InitializeMonitor[@newIdentity.LOCK];    identity ¬ PublicIdent[newIdentity];    IF ~dontCheck THEN SelfAuthenticate[      identity ! UNWIND => FreeIdentity[@identity, NIL]]; -- No heap needed.  END;MakeStrongIdentityUsingKey: PUBLIC PROC [  myName: NSName.Name, myKey: Auth.Key, z: UNCOUNTED ZONE,  dontCheck: BOOLEAN]    RETURNS [identity: Auth.IdentityHandle] =  BEGIN    IF ~DESFace.CheckKeyParity[LOOPHOLE[LONG[@myKey]]]      THEN ERROR CallError[badKey, notApplicable];    identity ¬ MakeIdentity[myName, NSString.nullString, z, strong, TRUE];    PrivateIdent[identity].myStrongKey ¬ PrivateKey[myKey];    IF ~dontCheck THEN SelfAuthenticate[      identity ! UNWIND => FreeIdentity[@identity, NIL]]; -- No heap needed.  END;FreeIdentity: PUBLIC PROC [  identityPtr: LONG POINTER TO Auth.IdentityHandle, z: UNCOUNTED ZONE] =  -- Note: z is no longer used.  BEGIN    CleanUpIdentity: ENTRY PROC [identity: Auth.IdentityHandle] =      BEGIN	ENABLE UNWIND => NULL;	thisOne: PrivateConversationHandle;	-- Clean up currently active conversations (making them orphans):	-- (These conversations are in use; they should not be freed.)	thisOne ¬ PrivateIdent[identity].conversationsInUse;	WHILE thisOne # NIL DO	  nextOne: PrivateConversationHandle ¬ thisOne.next;	  thisOne.owner ¬ NIL;	  thisOne.next ¬ NIL;	  thisOne ¬ nextOne;	ENDLOOP;	-- Clean up cached conversations:	-- (These conversations are not in use; they should be freed.)	thisOne ¬ PrivateIdent[identity].cachedConversations;	WHILE thisOne # NIL DO	  nextOne: PrivateConversationHandle ¬ thisOne.next;	  thisOne.owner ¬ NIL; -- Prevents monitor lock.	  InternalTerminate[LOOPHOLE[LONG[@thisOne]]];	  thisOne ¬ nextOne;	ENDLOOP;	AuthInternal.FreeNSName[	  @PrivateIdent[identity].myName, PrivateIdent[identity].owningHeap];	AuthInternal.FreeNSString[	  @PrivateIdent[identity].myPassword, PrivateIdent[identity].owningHeap];      END;    IF identityPtr­ = NIL THEN RETURN;    CleanUpIdentity[identityPtr­];      -- There is a tiny race here; we free the monitor lock before we      -- free the identity itself. This shouldn't matter; if the client      -- is calling FreeIdentity, he'd better not be using it!    PrivateIdent[identityPtr­].owningHeap.FREE[identityPtr];      -- Smashes NIL into identityPtr­.  END;-- Conversations --Initiate: PUBLIC PROC [  identity: Auth.IdentityHandle, recipientsName: NSName.Name,  recipientsHostNumber: System.HostNumber ¬ Auth.nullHostNumber,  z: UNCOUNTED ZONE]    RETURNS [conversation: Auth.ConversationHandle] =  -- Note: z is no longer used.  BEGIN    SELECT AuthInternal.Style[identity] FROM      simple => ResolveNameIfAlias[identity];      strong => CheckForValidName[PrivateIdent[identity].myName, strong];    ENDCASE => ERROR;    conversation ¬ InternalInitiate[identity, recipientsName, recipientsHostNumber];  END;Terminate: PUBLIC PROC [  conversationPtr: LONG POINTER TO Auth.ConversationHandle, z: UNCOUNTED ZONE] =  BEGIN    -- Note: z is no longer used.    InternalTerminate[conversationPtr, cacheConversations];  END;Refresh: PUBLIC PROC [conversation: Auth.ConversationHandle] =  BEGIN    MonitoredFetchStrongCredentials: ENTRY PROC [identity: Auth.IdentityHandle] =      -- If successful, sets values of newCreds and newConversationKey.      -- Assume: PrivateConv[conversation].owner = identity      BEGIN	ENABLE UNWIND => NULL;	[newCreds, newConversationKey] ¬	  Auth.FetchStrongCredentials[	    PrivateConv[conversation].owner.myName,	    PrivateConv[conversation].recipient,	    PublicKey[PrivateConv[conversation].owner.myStrongKey],	    PrivateConv[conversation].owningHeap];      END;    newConversationKey: Auth.Key ¬ Auth.nullKey;    newCreds: Auth.Credentials ¬ Auth.nullCredentials;    IF PrivateConv[conversation].owner = NIL THEN ERROR OrphanConversation;    SELECT AuthInternal.Style[PublicIdent[PrivateConv[conversation].owner]] FROM      simple => RETURN; -- Noop      strong =>	MonitoredFetchStrongCredentials[PublicIdent[PrivateConv[conversation].owner]];    ENDCASE => ERROR;    -- We fetched new credentials using the conversation's heap. We    -- may now free the old conversation credentials and replace them    -- with the one's we just fetched.    AuthInternal.FreeCredentials[      @PrivateConv[conversation].creds,      PrivateConv[conversation].owningHeap];    PrivateConv[conversation].creds ¬ newCreds;    newCreds ¬ Auth.nullCredentials;      -- We've saved these credentials, so forget 'em.    PrivateConv[conversation].conversationKey ¬ PrivateKey[newConversationKey];    PrivateConv[conversation].clearLastVerifier      ¬ [System.GetGreenwichMeanTime[], GetRandomTicksForVerifier[]];    PrivateConv[conversation].creationTime ¬ System.GetGreenwichMeanTime[];  END;CheckOutCredentials: PUBLIC PROC [conversation: Auth.ConversationHandle]  RETURNS [creds: Auth.Credentials] =  BEGIN    RETURN[PrivateConv[conversation].creds];  END;CheckOutNextVerifier: PUBLIC PROC [  conversation: Auth.ConversationHandle, recipientsHostNumber: System.HostNumber]    RETURNS [verifier: Auth.Verifier] =  BEGIN    recipientsHostNumber ¬      IF recipientsHostNumber # System.nullHostNumber	THEN recipientsHostNumber	ELSE PrivateConv[conversation].recipientsHostNumber;    RETURN[      ComputeNextVerifierForConversation[	PrivateConv[conversation],	recipientsHostNumber]      ];  END;CheckOutCredsAndNextVerifier: PUBLIC PROC [  conversation: Auth.ConversationHandle,  recipientsHostNumber: System.HostNumber]  RETURNS [creds: Auth.Credentials, verifier: Auth.Verifier] =  BEGIN    recipientsHostNumber ¬      IF recipientsHostNumber # System.nullHostNumber	THEN recipientsHostNumber	ELSE PrivateConv[conversation].recipientsHostNumber;    RETURN[      PrivateConv[conversation].creds,      ComputeNextVerifierForConversation[	PrivateConv[conversation],	recipientsHostNumber]];  END;-- Serialization --  -- NOTE: DescribeCredentials and DescribeVerifier are  --   exported by AuthProtocolImpl.-- Exports to AuthSpecial and SpecialCHAuth ---- AuthSpecial.--MakeNullCHConversation: PUBLIC PROC [z: UNCOUNTED ZONE]  RETURNS [nullCHConv: CH.ConversationHandle ¬ [NIL, NIL]] =  BEGIN    nullConv: PrivateConversationHandle ¬      z.NEW[AuthInternal.ConversationObject ¬ []];    nullConv.owningHeap ¬ z;    nullCHConv.conversation ¬ PublicConv[nullConv];  END;-- SpecialCHAuth.--MakeConversationFromCredsAndVerifier: PUBLIC ENTRY PROC [  identity: Auth.IdentityHandle, creds: Auth.Credentials, verifier: Auth.Verifier,  z: UNCOUNTED ZONE]    RETURNS [conversation: Auth.ConversationHandle] =  -- Note: z is no longer used.  BEGIN    ENABLE UNWIND => NULL;    newConversation: PrivateConversationHandle;    convKey: Auth.Key ¬ Auth.nullKey;    badCreds: BOOLEAN;    SELECT creds.flavor FROM      simple => NULL;      strong =>	BEGIN	  -- Assume: PrivateIdent[identity].style # simple 	  [ , convKey, , , badCreds, , ] ¬	    AuthInternal.InternalExtractCredentialsDetails[	      PublicKey[PrivateIdent[identity].myStrongKey], creds, NIL, FALSE];	  IF badCreds THEN ERROR AuthenticationError[credentialsInvalid];	END;    ENDCASE => ERROR AuthenticationError[credentialsInvalid];    newConversation ¬ conversationHeap.NEW[AuthInternal.ConversationObject];    newConversation.recipient ¬ NIL;    -- Assume: Noone will be interested in the recipient's name so why copy it?    -- NOTE: This is an orphan conversation.    newConversation.creds ¬ Auth.CopyCredentials[creds, conversationHeap];    newConversation.lastVerifier ¬ Auth.nullVerifier; -- Filled in below.    newConversation.conversationKey ¬ PrivateKey[convKey];    newConversation.incrementVerifierByTicks ¬ TRUE;    newConversation.clearLastVerifier ¬ [System.gmtEpoch, 0];    newConversation.recipientsHostNumber ¬ System.nullHostNumber;    newConversation.creationTime ¬ System.GetGreenwichMeanTime[];    newConversation.owner ¬ NIL;    newConversation.next ¬ NIL;    newConversation.owningHeap ¬ conversationHeap;    SELECT creds.flavor FROM      simple =>	newConversation.lastVerifier ¬	  AuthInternal.CloneVerifier[verifier, conversationHeap];      strong =>	BEGIN	  ENABLE UNWIND =>	    InternalTerminate[LOOPHOLE[LONG[@newConversation]]];	       -- No monitor problems because newConversation is an orphan.	  newConversation.clearLastVerifier ¬	    AuthInternal.UnpackStrongVerifier[	      verifier, PrivateKey[convKey], thisMachinesAddress.host	      ! Courier.Error => ERROR AuthenticationError[verifierInvalid]];	  newConversation.lastVerifier ¬	    DESCRIPTOR[	      Heap.MakeNode[conversationHeap, SIZE[AuthProtocol.StrongVerifier]],	      SIZE[AuthProtocol.StrongVerifier]];	END;    ENDCASE => ERROR AuthenticationError[credentialsInvalid];    RETURN[PublicConv[newConversation]];  END;-- Private stuff --CheckForValidName: PROC [name: NSName.Name, style: Auth.Flavor] =  -- Raises an error (according to style) if the name is NOT ok.  BEGIN    IF AuthInternal.NilOrNullName[name] OR      name.local.length > NSName.maxLocalLength OR      name.domain.length > NSName.maxDomainLength OR      name.org.length > NSName.maxOrgLength	THEN ERROR CallError[	  (IF style = simple THEN simpleKeyDoesNotExist ELSE strongKeyDoesNotExist),	   notApplicable];  END;ComputeNextVerifierForConversation: PROC [  conversation: PrivateConversationHandle,  recipientsHostNumber: System.HostNumber]    RETURNS [nextVerifier: Auth.Verifier] =  -- This will compute a unique verifier later than last. If necessary,  -- it will wait one second. If the timeStamp in the verifier is greater than  -- the current time (i.e. in the future), you're out of luck. It has the  -- side effect of modifying the lastVerifier and clearLastVerifier fields  -- of the conversation.  BEGIN    SELECT TRUE FROM      conversation.creds.flavor = simple => RETURN[conversation.lastVerifier];      conversation.incrementVerifierByTicks => -- strong, strange case --	BEGIN	  conversation.clearLastVerifier ¬	    AuthInternal.IncrementVerifierTicks[conversation.clearLastVerifier];	  AuthInternal.PackStrongVerifier[	    from: @conversation.clearLastVerifier,	    recipientsHostNumber: recipientsHostNumber,	    destVerifier: conversation.lastVerifier,	    key: conversation.conversationKey];	END;    ENDCASE => -- strong, normal case --      BEGIN	last: AuthProtocol.StrongVerifier ¬ conversation.clearLastVerifier;	timeOfLastVerifier, timeOfNextVerifier: LONG CARDINAL;	oneSecond: Process.Ticks ¬ Process.SecondsToTicks[1];	next: AuthProtocol.StrongVerifier ¬ [	  timeStamp: System.GetGreenwichMeanTime[],	  ticks: GetRandomTicksForVerifier[]];	timeOfLastVerifier ¬ System.SecondsSinceEpoch[last.timeStamp];	timeOfNextVerifier ¬ System.SecondsSinceEpoch[next.timeStamp];	IF ~(timeOfNextVerifier > timeOfLastVerifier) THEN	  BEGIN	    IF timeOfNextVerifier < timeOfLastVerifier THEN ERROR BadLineClock;	      -- Time appears to be going backwards!!!	-- If we get this far, timeOfNextVerifier = timeOfLastVerifier. Since	-- we can't make duplicate verifiers, we've got to increment the ticks	-- or, if we've run out of ticks in a LONG CARDINAL, then we've got	-- to wait until the next second. (This should be VERY rare.)	    IF last.ticks # LAST[LONG CARDINAL]	      THEN next.ticks ¬ last.ticks + 1	      ELSE		BEGIN		  Process.Pause[oneSecond];		  timesHaveHadToWaitForNextVerifier ¬		    timesHaveHadToWaitForNextVerifier + 1;		  next ¬ [		    timeStamp: System.GetGreenwichMeanTime[],		    ticks: GetRandomTicksForVerifier[]];		  IF System.SecondsSinceEpoch[next.timeStamp] <=		    timeOfLastVerifier		      THEN ERROR BadLineClock;			-- If, after pausing for a second, the clock			-- hasn't advanced, something must be wrong			-- with the clock...		END;	  END;	conversation.clearLastVerifier ¬ next;	AuthInternal.PackStrongVerifier[	  from: @conversation.clearLastVerifier,	  recipientsHostNumber: recipientsHostNumber,	  destVerifier: conversation.lastVerifier,	  key: conversation.conversationKey];      END;      RETURN[conversation.lastVerifier];  END;GetConversationFromCache: INTERNAL PROC [  id: PrivateIdentityHandle, recipient: NSName.Name]  RETURNS [conv: PrivateConversationHandle ¬ NIL] =  BEGIN    FindConversationFor: PROC [name: NSName.Name]      RETURNS [convFound: PrivateConversationHandle] =      BEGIN	previous: LONG POINTER TO PrivateConversationHandle;	IF AuthInternal.NilOrNullName[name] THEN RETURN[NIL];     -- Find the conversation (if any) preceding the one     --   we'd like to use.	previous ¬ @id.cachedConversations;	WHILE previous­ # NIL DO -- For entire list, do:	  IF NSStringExtras.EquivalentNames[previous­.recipient, name]	    THEN EXIT; -- Found one!	  previous ¬ @previous­.next;	ENDLOOP;	IF previous­ = NIL THEN RETURN[NIL]; -- Didn't find one.     -- Found one, splice it out:	convFound ¬ previous­;	previous­ ¬ convFound.next;     -- Put it on the front of the list of conversations in use:	convFound.next ¬ id.conversationsInUse;	id.conversationsInUse ¬ convFound;	RETURN[convFound];      END;    WeedOutOldConversations: PROC =      BEGIN	previous: LONG POINTER TO PrivateConversationHandle ¬	  @id.cachedConversations;	convToRemove: PrivateConversationHandle ¬ NIL;	-- Seek out and destroy all old conversations:	WHILE previous­ # NIL DO -- For entire list, do	  SELECT OldConversation[previous­] FROM	    FALSE =>	      BEGIN		previous ¬ @previous­.next;		LOOP; -- This is a young entry; pass over it.	      END;	    TRUE =>	      BEGIN		convToRemove ¬ previous­;	      -- Splice this conversation out of list:		previous­ ¬ previous­.next;	      -- Kill it:		convToRemove.owner ¬ NIL;		InternalTerminate[LOOPHOLE[LONG[@convToRemove]]];	      END;	  ENDCASE;	ENDLOOP;      END;    WeedOutOldConversations[];    RETURN[FindConversationFor[recipient]];  END;GetRandomTicksForVerifier: PROC RETURNS [ticks: LONG CARDINAL] =  BEGIN    ticks ¬ System.GetClockPulses[];    IF ticks > 10000 THEN ticks ¬ ticks - 10000;      -- This makes sure that ticks is within [0..MAX[LONG CARDINAL]-10000].      -- That way, we can make up to 10000 verifiers within a given second      -- by incrementing the ticks field.  END;InternalInitiate: PRIVATE ENTRY PROC [  identity: Auth.IdentityHandle, recipientsName: NSName.Name,  recipientsHostNumber: System.HostNumber ¬ Auth.nullHostNumber]    RETURNS [conversation: Auth.ConversationHandle] =  BEGIN    ENABLE UNWIND => NULL;    newConversation: PrivateConversationHandle;    newCreds: Auth.Credentials;    newConversationKey: Auth.Key ¬ Auth.nullKey;    newConversation ¬      GetConversationFromCache[PrivateIdent[identity], recipientsName];    IF newConversation # NIL THEN      BEGIN -- If there was a conversation in the cache, use it!	newConversation.recipientsHostNumber ¬ recipientsHostNumber;	RETURN[PublicConv[newConversation]];      END;  -- No credentials in the cache, so manufacture or fetch some:    SELECT PrivateIdent[identity].style FROM      simple =>	newCreds ¬	  AuthInternal.MakeSimpleCredentials[	    PrivateIdent[identity].myName, conversationHeap];      strong =>	[newCreds, newConversationKey] ¬	  Auth.FetchStrongCredentials[	    PrivateIdent[identity].myName, recipientsName,	    PublicKey[PrivateIdent[identity].myStrongKey], conversationHeap];    ENDCASE => ERROR;    newConversation ¬ conversationHeap.NEW[AuthInternal.ConversationObject];    newConversation.recipient ¬      AuthInternal.CloneNSName[recipientsName, conversationHeap];    newConversation.creds ¬ newCreds;    newConversation.lastVerifier ¬ Auth.nullVerifier; -- Filled in below.    newConversation.conversationKey ¬ PrivateKey[newConversationKey];    newConversation.incrementVerifierByTicks ¬ FALSE;    newConversation.clearLastVerifier ¬      [System.GetGreenwichMeanTime[], GetRandomTicksForVerifier[]];    newConversation.recipientsHostNumber ¬ recipientsHostNumber;    newConversation.creationTime ¬ System.GetGreenwichMeanTime[];    newConversation.owner ¬ NIL;    newConversation.next ¬ NIL;    newConversation.owningHeap ¬ conversationHeap;    SELECT TRUE FROM      newConversation.creds = Auth.nullCredentials =>	newConversation.lastVerifier ¬ Auth.nullVerifier;      PrivateIdent[identity].style = simple =>	newConversation.lastVerifier ¬	  AuthInternal.MakeVerifierFromHashedPassword[	    PrivateIdent[identity].myHashedPassword, conversationHeap];      PrivateIdent[identity].style = strong =>	newConversation.lastVerifier ¬	  DESCRIPTOR[	    Heap.MakeNode[conversationHeap, SIZE[AuthProtocol.StrongVerifier]],	    SIZE[AuthProtocol.StrongVerifier]];    ENDCASE => ERROR; -- Put on front of identity's list of conversations in use:    newConversation.owner ¬ PrivateIdent[identity];    newConversation.next ¬ PrivateIdent[identity].conversationsInUse;    PrivateIdent[identity].conversationsInUse ¬ newConversation;    RETURN[PublicConv[newConversation]];  END;InternalTerminate: PROC [  conversationPtr: LONG POINTER TO Auth.ConversationHandle,  okToCache: BOOLEAN ¬ FALSE] =  BEGIN    RemoveConvFromIdentity: ENTRY PROC [identity: Auth.IdentityHandle] =      -- Removes conversationPtr­ from identity.conversationsInUse.      BEGIN	ENABLE UNWIND => NULL;	-- Assume: identity = PrivateConv[conversationPtr­].owner	-- Assume: identity # NIL	previous: LONG POINTER TO PrivateConversationHandle ¬	  @PrivateIdent[identity].conversationsInUse;     -- Find previous conversation in chain:	DO	  IF previous­ = PrivateConv[conversationPtr­] THEN EXIT;	  IF previous­ = NIL THEN ERROR;	    -- A conversation has an owner that doesn't know about	    -- the conversation. This "can't" happen (if it does there	    -- is a bug in this code somewhere.	  previous ¬ @previous­.next;	ENDLOOP;     -- Splice out this conversation:	previous­ ¬ PrivateConv[conversationPtr­].next;	PrivateConv[conversationPtr­].next ¬ NIL;      END;    OfferConvToIdentityCache: ENTRY PROC [      identity: Auth.IdentityHandle, conversation: PrivateConversationHandle]	RETURNS [accepted: BOOLEAN ¬ FALSE] =      -- This operation may add conversation to identity.cachedConversations.      -- If it does, accepted will be set to TRUE.      BEGIN	ENABLE UNWIND => NULL;	IF ~okToCache	  OR conversation.incrementVerifierByTicks	  OR OldConversation[conversation]	  OR AuthInternal.NilOrNullName[conversation.recipient]	    THEN RETURN[accepted: FALSE];	conversation.next ¬ PrivateIdent[identity].cachedConversations;	PrivateIdent[identity].cachedConversations ¬ conversation;	RETURN[accepted: TRUE];      END;    addedToCache: BOOLEAN;    IF conversationPtr­ = NIL THEN RETURN; -- Nothing to do.    IF PrivateConv[conversationPtr­].owner # NIL THEN      BEGIN	RemoveConvFromIdentity[PublicIdent[PrivateConv[conversationPtr­].owner]];	addedToCache ¬	  OfferConvToIdentityCache[	    PublicIdent[PrivateConv[conversationPtr­].owner],	    PrivateConv[conversationPtr­]];	IF addedToCache	  THEN {conversationPtr­ ¬ NIL; RETURN};	    -- Do NOT free the conversation; do set it to NIL.      END;   -- Free the conversation:    AuthInternal.FreeNSName[      @PrivateConv[conversationPtr­].recipient,      PrivateConv[conversationPtr­].owningHeap];    AuthInternal.FreeCredentials[      @PrivateConv[conversationPtr­].creds,      PrivateConv[conversationPtr­].owningHeap];    AuthInternal.FreeVerifier[      @PrivateConv[conversationPtr­].lastVerifier,      PrivateConv[conversationPtr­].owningHeap];    PrivateConv[conversationPtr­].owningHeap.FREE[conversationPtr];      -- Smashes NIL into conversationPtr­.  END;IsWellKnownName: PROC [name: NSName.Name]  RETURNS [isWellKnown: BOOLEAN] =  BEGIN    RETURN[      AuthInternal.EquivalentNames[name, SharedKeys.asName] OR      AuthInternal.EquivalentNames[name, SharedKeys.chsName] OR      AuthInternal.EquivalentNames[name, SharedKeys.msName]      ];  END;MakeSimpleCHOrphanConversation: PROC [  for: NSName.Name, hashedPassword: Auth.HashedPassword]  RETURNS [chConv: CH.ConversationHandle] =  BEGIN    chConv ¬ MakeNullCHConversation[asStubHeap];    PrivateConv[chConv.conversation].creds ¬      AuthInternal.MakeSimpleCredentials[for, asStubHeap];    PrivateConv[chConv.conversation].lastVerifier ¬      AuthInternal.MakeVerifierFromHashedPassword[hashedPassword, asStubHeap];  END;OldConversation: PROC [conv: PrivateConversationHandle]  RETURNS [isOld: BOOLEAN] =  BEGIN    now: LONG CARDINAL ¬      System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    then: LONG CARDINAL ¬      System.SecondsSinceEpoch[conv.creationTime];    IF then > now      THEN isOld ¬ TRUE	-- Clock is running backward?? Consider the conversation "old".      ELSE isOld ¬ ((now - then) > conversationCacheTimeout);  END;ResolveNameIfAlias: ENTRY PROC [identity: Auth.IdentityHandle] =  -- Assume: This operation gets called only with a simple identity.  BEGIN    ENABLE {      AuthenticationError => ERROR CallError[badKey, initiator];      UNWIND => NULL;      };    chConversation: CH.ConversationHandle ¬ [NIL, NIL];    distingName: NSName.Name ¬ NIL;    rc: CH.ReturnCode;    IF PrivateIdent[identity].nameHasBeenResolved THEN RETURN;    CheckForValidName[PrivateIdent[identity].myName, PrivateIdent[identity].style];    IF IsWellKnownName[PrivateIdent[identity].myName] THEN      BEGIN	PrivateIdent[identity].nameHasBeenResolved ¬ TRUE;	RETURN;      END;    chConversation ¬ MakeSimpleCHOrphanConversation[      PrivateIdent[identity].myName, PrivateIdent[identity].myHashedPassword];    distingName ¬ AuthInternal.MakeEmptyNSName[asStubHeap];    BEGIN      ENABLE UNWIND => {	CH.FreeConversationHandle[@chConversation, NIL];	AuthInternal.FreeNSName[@distingName, asStubHeap];	};      rc ¬ CH.LookupDistinguishedName[	chConversation, PrivateIdent[identity].myName, distingName];      SELECT rc.code FROM	done =>	  BEGIN	  -- Assume: PrivateIdent[identity].myName is big enough;	  --   no heap will be needed by CopyNameFields.	    NSName.CopyNameFields[	      z: NIL, source: distingName,	      destination: PrivateIdent[identity].myName];	    PrivateIdent[identity].nameHasBeenResolved ¬ TRUE;	  END;	noSuchOrg, noSuchDomain, noSuchLocal,	illegalOrgName, illegalDomainName, illegalLocalName =>	  ERROR CallError[simpleKeyDoesNotExist, initiator];	rejectedTooBusy =>	  ERROR CallError[tooBusy, notApplicable];	allDown =>	  ERROR CallError[keysUnavailable, initiator];	credentialsInvalid =>	  ERROR CallError[badKey, initiator];      ENDCASE => ERROR CallError[simpleKeyDoesNotExist, initiator];      AuthInternal.FreeNSName[@distingName, asStubHeap];    END;    CH.FreeConversationHandle[@chConversation, NIL];  END;SelfAuthenticate: PROC [identity: Auth.IdentityHandle] =  -- This operation will also resolve the name in the identity handle.  -- Assume: This procedure is only called from an identity creation procedure!  BEGIN    creds: Auth.Credentials ¬ Auth.nullCredentials;    verifier: Auth.Verifier ¬ Auth.nullVerifier;    conv: Auth.ConversationHandle ¬ NIL;    SELECT PrivateIdent[identity].style FROM      simple =>	ResolveNameIfAlias[identity];      strong =>	CheckForValidName[PrivateIdent[identity].myName, strong];	-- Note: Since the strong credentials produced by the AS always contain	-- a distinguished name, we save a Clearinghouse operation by extracting	-- the disinguished name from the credentials that we are using to check	-- this identity.    ENDCASE => ERROR;    SELECT PrivateIdent[identity].style FROM      simple =>	BEGIN	  ENABLE UNWIND => InternalTerminate[@conv];	  conv ¬ InternalInitiate[identity, PrivateIdent[identity].myName];	  [creds, verifier] ¬Auth.CheckOutCredsAndNextVerifier[conv];	  IF ~Auth.CheckSimpleCredentials[creds, verifier].ok	    THEN ERROR CallError[badKey, notApplicable];	  InternalTerminate[@conv];	END;      strong =>	BEGIN	  ENABLE UNWIND => InternalTerminate[@conv];	  distingName: NSName.Name ¬ NIL;	  conv ¬ InternalInitiate[identity, PrivateIdent[identity].myName];	  [creds, verifier] ¬	    CheckOutCredsAndNextVerifier[conv, thisMachinesAddress.host];	-- To get the distinguished name for strong credentials, do an	-- Authenticate, which returns the distinguished name (which was	-- resolved by the server). Replace the identity.myName with this name.	  [distingName, , ] ¬ AuthInternal.InternalAuthenticate[	    PublicKey[PrivateIdent[identity].myStrongKey], creds, verifier,	    asStubHeap, thisMachinesAddress.host,	    FALSE, FALSE, TRUE, FALSE	    ! AuthenticationError => ERROR CallError[badKey, notApplicable]];	-- Assume: PrivateIdent[identity].myName is big enough;	--   no heap will be needed by CopyNameFields.	  NSName.CopyNameFields[	    z: NIL, source: distingName, destination: PrivateIdent[identity].myName];	  AuthInternal.FreeNSName[@distingName, asStubHeap];	  PrivateIdent[identity].nameHasBeenResolved ¬ TRUE;	  InternalTerminate[@conv];	END;    ENDCASE => ERROR;  END;-- Public/Private pointer conversions --  -- Note: This is a hack to avoid exporting public types.  -- (Because exported type clashes make it impossible for two  -- different implementations which export the same type to co-exist.)PrivateIdentityHandle: TYPE = LONG POINTER TO AuthInternal.IdentityObject;PrivateConversationHandle: TYPE = LONG POINTER TO AuthInternal.ConversationObject;PrivateConv: PROC [conversation: Auth.ConversationHandle]  RETURNS [PrivateConversationHandle] = INLINE    {RETURN[LOOPHOLE[conversation]]};PublicConv: PROC [privateConversation: PrivateConversationHandle]  RETURNS [Auth.ConversationHandle] = INLINE    {RETURN[LOOPHOLE[privateConversation]]};PrivateIdent: PROC [identity: Auth.IdentityHandle]  RETURNS [PrivateIdentityHandle] = INLINE    {RETURN[LOOPHOLE[identity]]};PublicIdent: PROC [privateIdentity: PrivateIdentityHandle]  RETURNS [Auth.IdentityHandle] = INLINE    {RETURN[LOOPHOLE[privateIdentity]]};PrivateKey: PROC [key: Auth.Key]  RETURNS [DESFace.Key] = INLINE    {RETURN[LOOPHOLE[key]]};PublicKey: PROC [privateKey: DESFace.Key]  RETURNS [Auth.Key] = INLINE    {RETURN[LOOPHOLE[privateKey]]};END.
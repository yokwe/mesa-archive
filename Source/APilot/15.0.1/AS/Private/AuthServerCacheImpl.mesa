-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- AuthServerCacheImpl.mesa-- JMaloney, 11-Jan-84 21:50:35.-- Last modified: JMaloney, 3-Jul-84 10:28:38.-- Last modified: AOF, 14-Dec-84 17:12:19.DIRECTORY  AuthInternal USING [asStubHeap],  AuthProtocol USING [    DescribeProbeResults, GetProgramNumbers, probeRequest, ProbeResults],  AuthServerCache USING [],  CHAddressCacheFriends USING [FindDomainAddr],  Courier USING [Free, nullParameters],  Environment USING [Block],  ExpeditedCourier USING [    CallToInternetRing, DeserializeFromBlock, ElapsedTime,    ExpandingRingAction, Header, Hop, RingBound],  NSAddr USING [SelectNearestAddress],  NSName USING [Name],  Process USING [Detach, Yield],  Router USING [AssignAddress],  System USING [NetworkAddress, nullNetworkAddress, SocketNumber];AuthServerCacheImpl: MONITOR  IMPORTS    AuthInternal, AuthProtocol, CHAddressCacheFriends, Courier,    ExpeditedCourier, NSAddr, Process, Router  EXPORTS AuthServerCache =BEGIN-- Monitored data --cacheSize: CARDINAL = 2;cache: ARRAY [0..cacheSize) OF System.NetworkAddress ¬  ALL[System.nullNetworkAddress];currentASAddress: System.NetworkAddress ¬ System.nullNetworkAddress;numberOfCacheRefillsSinceLastBoot: LONG CARDINAL ¬ 0;numberOfTimesASCacheUsed: LONG CARDINAL ¬ 0;searchInProgress: BOOLEAN ¬ FALSE;useLocalServer: BOOLEAN ¬ FALSE;-- Constants --expandingRingAction: ExpeditedCourier.ExpandingRingAction ¬  findMostServersInShortTime;expandingRingBounds: ExpeditedCourier.RingBound ¬  [low: 0, high: 5];-- Public procedures --ASAddress: PUBLIC ENTRY PROC [nameHint: NSName.Name]  RETURNS [currentAddress: System.NetworkAddress] =  BEGIN    ENABLE UNWIND => NULL;    addrFromCHCache: System.NetworkAddress ¬ System.nullNetworkAddress;    SELECT TRUE FROM      useLocalServer => RETURN[Router.AssignAddress[]]; -- Auth server is local.      nameHint = NIL =>	BEGIN -- Must use AS cache; no name hint provided.	  numberOfTimesASCacheUsed ¬	    numberOfTimesASCacheUsed + 1;	  RETURN[currentASAddress];       END;    ENDCASE;    addrFromCHCache ¬ CHAddressCacheFriends.FindDomainAddr[nameHint];    IF addrFromCHCache # System.nullNetworkAddress      THEN currentAddress ¬ addrFromCHCache      ELSE	BEGIN  -- Must use AS cache; CHS cache was of no use.	  -- Use our own address if the CH stub can't help us.	  currentAddress ¬ currentASAddress;	  numberOfTimesASCacheUsed ¬	     numberOfTimesASCacheUsed + 1;	END;  END;NextPlease: PUBLIC ENTRY PROC [badAddress: System.NetworkAddress]  RETURNS [numberOfAddressesInCache: CARDINAL ¬ 0] =  BEGIN    alreadySmashedAddr: BOOLEAN ¬ FALSE;    IF badAddress # System.nullNetworkAddress THEN      BEGIN	IF badAddress = currentASAddress	  THEN alreadySmashedAddr ¬ FALSE -- False means do it!	  ELSE alreadySmashedAddr ¬ TRUE;	-- If alreadySmashedAddr is false, then we got badAddress from our cache	-- and we want to remove it. Otherwise, we got it from the CH cache.      END;    FOR i: CARDINAL IN [0..cacheSize) DO      SELECT TRUE FROM	cache[i] = System.nullNetworkAddress => LOOP;	~alreadySmashedAddr =>	  BEGIN	    cache[i] ¬ System.nullNetworkAddress; -- Smash that no-good address!	    alreadySmashedAddr ¬ TRUE; -- But only the first one...	    LOOP;	  END;	numberOfAddressesInCache = 0 =>	  BEGIN	    currentASAddress ¬ cache[i];	    numberOfAddressesInCache ¬ numberOfAddressesInCache + 1;	    LOOP;	  END;      ENDCASE => numberOfAddressesInCache ¬ numberOfAddressesInCache + 1;    ENDLOOP;  END;Refill: PUBLIC PROC =  BEGIN    IF ~CanIStartASearch[] THEN RETURN;      -- Refill is a noop if search is already in progress...    numberOfCacheRefillsSinceLastBoot ¬ numberOfCacheRefillsSinceLastBoot + 1;    PushOldEntriesToEnd[];    Process.Detach[FORK Searcher[]];    Process.Yield[];  END;UseLocalServer: PUBLIC ENTRY PROC [useLocal: BOOLEAN] =  BEGIN    useLocalServer ¬ useLocal;  END;-- Private procedures --PushOldEntriesToEnd: ENTRY PROC =  BEGIN    -- Loop invariant: All cache entries in the range (nextEmptySlot..cacheSize)    --   contain real addresses.    -- We make one pass from the end to the beginning of the cache.    -- Every time we come across a real address, we try to move it    -- to cache[nextEmptySlot]. Of course, if there haven't been any "holes"    -- i will equal nextEmptySlot so we needn't do anything.    nextEmptySlot: CARDINAL ¬ cacheSize - 1;    FOR i: CARDINAL DECREASING IN [0..cacheSize) DO      SELECT TRUE FROM	cache[i] = System.nullNetworkAddress => LOOP;	  -- hit a hole: nothing to move --	i = nextEmptySlot => nextEmptySlot ¬ nextEmptySlot - 1;	  -- so far there have been no holes so we have nothing to do --      ENDCASE =>	  -- move the good address down to the end --	BEGIN	  cache[nextEmptySlot] ¬ cache[i];	  cache[i] ¬ System.nullNetworkAddress;	  nextEmptySlot ¬ nextEmptySlot - 1;	END;    ENDLOOP;  END;AddCacheEntry: ENTRY PROC [  indexForNewAddress: CARDINAL, newAddress: System.NetworkAddress]    RETURNS[wasANewEntry: BOOLEAN ¬ TRUE] =  BEGIN    FOR i: CARDINAL IN [0..indexForNewAddress) DO      IF cache[i] = newAddress THEN RETURN[wasANewEntry: FALSE];	-- suppress duplicate entries    ENDLOOP;    cache[indexForNewAddress] ¬ newAddress;    IF indexForNewAddress = 0 THEN currentASAddress ¬ newAddress;  END;Searcher: PROC =  -- The process that searches the net for Authentication Services.  BEGIN    ProbeReceiver:  PROC [      hopsToResponder: ExpeditedCourier.Hop,      elapsedTime: ExpeditedCourier.ElapsedTime,      header: ExpeditedCourier.Header,      serializedResponse: Environment.Block]	RETURNS [continue: BOOLEAN ¬ TRUE] =      BEGIN	reply: AuthProtocol.ProbeResults;	repliersAddress: System.NetworkAddress;	IF header.body.type # return	  OR ~ExpeditedCourier.DeserializeFromBlock[	    [@reply, AuthProtocol.DescribeProbeResults],	    AuthInternal.asStubHeap, serializedResponse]	    THEN RETURN;	IF reply.serverAddress # NIL THEN	  repliersAddress ¬ NSAddr.SelectNearestAddress[reply.serverAddress];	Courier.Free[	  [@reply, AuthProtocol.DescribeProbeResults], AuthInternal.asStubHeap];	IF cacheIndex >= cacheSize	  THEN continue ¬ FALSE	  ELSE	    BEGIN	      IF AddCacheEntry[cacheIndex, repliersAddress].wasANewEntry		THEN cacheIndex ¬ cacheIndex + 1;	    END;      END;    cacheIndex: CARDINAL ¬ 0;    program: LONG CARDINAL;    version: CARDINAL;    probeSocket: System.SocketNumber;    procedureNumber: CARDINAL ¬ AuthProtocol.probeRequest;    [program, version, , probeSocket] ¬      AuthProtocol.GetProgramNumbers[];    ExpeditedCourier.CallToInternetRing[      program, version, procedureNumber,      Courier.nullParameters, -- a probe request has no parameters --      expandingRingBounds, probeSocket, expandingRingAction,      ProbeReceiver, NIL, 10];    NowDoneSearching[];  END;CanIStartASearch: ENTRY PROC RETURNS [goFerIt: BOOLEAN] =  BEGIN    IF searchInProgress THEN RETURN[FALSE];    searchInProgress ¬ TRUE;    RETURN[TRUE];  END;NowDoneSearching: ENTRY PROC =  BEGIN    searchInProgress ¬ FALSE;  END;END.
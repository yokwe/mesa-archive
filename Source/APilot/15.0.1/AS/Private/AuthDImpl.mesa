-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- AuthDImpl.mesa-- JMaloney, 11-Jul-83 12:24:49.-- Last modified: JMaloney, 3-Jul-84 11:13:19.DIRECTORY  Auth USING [    AuthenticationError, ConversationHandle, ConversationProc,    Credentials, Flavor, HashedPassword, IdentityHandle,    Key, nullCredentials, nullHostNumber, Verifier],  AuthInternal USING [    asStubHeap, CloneCredentials, CloneNSName, CloneNSString,    ConversationObject, FreeCredentials, FreeVerifier, IdentityObject],  DESFace USING [    Block, CorrectParity, EncryptBlock, GetRandomKey, Key, nullKey],  ESCAlpha USING [aBLEL],  Inline USING [LowHalf],  Mopcodes USING [zESC],  NSName USING [Name],  NSString USING [    Character, Characters, ExpandString, FreeCharacters, LowerCase, String],  Process USING [InitializeMonitor],  System USING [HostNumber];AuthDImpl: MONITOR  LOCKS LOOPHOLE[identity, PrivateIdentityHandle]­ USING identity: Auth.IdentityHandle  IMPORTS    Auth, AuthInternal, DESFace, Inline, NSString, Process  EXPORTS Auth  SHARES Auth =BEGIN-- Utilities --CopyCredentials: PUBLIC PROC [  credentials: Auth.Credentials, z: UNCOUNTED ZONE]    RETURNS [newCopy: Auth.Credentials] =  BEGIN    IF credentials.value # NIL      THEN RETURN[AuthInternal.CloneCredentials[credentials, z]]      ELSE	BEGIN	  newCopy ¬ Auth.nullCredentials;	  newCopy.flavor ¬ credentials.flavor;	END;  END;CopyIdentity: PUBLIC PROC [  identity: Auth.IdentityHandle, z: UNCOUNTED ZONE]  RETURNS [newCopy: Auth.IdentityHandle] =  BEGIN    IF identity = NIL THEN RETURN[NIL] ELSE RETURN[InternalCopyIdentity[identity, z]];  END;EqualCredentials: PUBLIC PROC [creds1, creds2: Auth.Credentials]  RETURNS [equal: BOOLEAN] =  BEGIN    BlocksEqual: PROC [      block1: LONG POINTER, nWords: CARDINAL, block2: LONG POINTER]	RETURNS [equal: BOOLEAN] =      MACHINE CODE {Mopcodes.zESC, ESCAlpha.aBLEL};    IF creds1.flavor # creds2.flavor THEN RETURN[FALSE];    IF creds1.value = NIL THEN RETURN[IF creds2.value = NIL THEN TRUE ELSE FALSE];    IF LENGTH[creds1.value] # LENGTH[creds2.value] THEN RETURN[FALSE];    equal ¬ BlocksEqual[      BASE[creds1.value], LENGTH[creds1.value], BASE[creds2.value]];  END;GetFlavor: PUBLIC PROC [creds: Auth.Credentials] RETURNS [flavor: Auth.Flavor] =  BEGIN    RETURN[creds.flavor];      -- This was only here to hide the "passkey" type.      -- It could be removed next release if suitable changes      -- were made in the Auth interface (make Credentials.flavor      -- public).  END;EnumerateConversations: PUBLIC PROC [  identity: Auth.IdentityHandle, eachConv: Auth.ConversationProc] =  BEGIN    GetNextConversation: ENTRY PROC [      identity: Auth.IdentityHandle, startAtBeginning: BOOLEAN ¬ FALSE] =      -- Sets current, next      BEGIN	ENABLE UNWIND => NULL;	IF startAtBeginning	  THEN current ¬ PrivateIdent[identity].conversationsInUse	  ELSE current ¬ next;	IF current # NIL THEN next ¬ current.next;	  -- next is set BEFORE calling client in case he deletes	  -- the coversation we pass back to him.      END;    current, next: PrivateConversationHandle ¬ NIL;    GetNextConversation[identity: identity, startAtBeginning: TRUE];    UNTIL current = NIL DO      IF eachConv[PublicConv[current]].stop THEN EXIT;      GetNextConversation[identity];    ENDLOOP;  END;ExtractHashedPassword: PUBLIC PROC [simpleVerifier: Auth.Verifier]  RETURNS [hashedPassword: Auth.HashedPassword] =  BEGIN    IF LENGTH[simpleVerifier] # 1 THEN      ERROR Auth.AuthenticationError[verifierInvalid];    hashedPassword ¬ simpleVerifier[0];  END;HashSimplePassword: PUBLIC PROC [password: NSString.String]  RETURNS [hashedPassword: Auth.HashedPassword] =  BEGIN    primeHashBase: CARDINAL = 65357;    twoToTheSixteenth: LONG CARDINAL = 65536;    stringAs16BitCharacters: NSString.Characters;    IF password.length = 0 THEN RETURN[0]; -- Hash[""] = 0.    stringAs16BitCharacters ¬      NSString.ExpandString[AuthInternal.asStubHeap, password];    hashedPassword ¬ LOOPHOLE[NSString.LowerCase[stringAs16BitCharacters[0]]];    FOR i: CARDINAL IN [1..LENGTH[stringAs16BitCharacters]) DO      hashedPassword ¬ Inline.LowHalf[	(hashedPassword*twoToTheSixteenth +	 LOOPHOLE[NSString.LowerCase[stringAs16BitCharacters[i]], CARDINAL])	   MOD primeHashBase];    ENDLOOP;    NSString.FreeCharacters[AuthInternal.asStubHeap, stringAs16BitCharacters];  END;FreeCredentials: PUBLIC PROC [  credsPtr: LONG POINTER TO Auth.Credentials, z: UNCOUNTED ZONE] =  BEGIN    AuthInternal.FreeCredentials[credsPtr, z];  END;FreeVerifier: PUBLIC PROC [  verifierPtr: LONG POINTER TO Auth.Verifier, z: UNCOUNTED ZONE] =  BEGIN    AuthInternal.FreeVerifier[verifierPtr, z];  END;GetConversationDetails: PUBLIC PROC [conversation: Auth.ConversationHandle]    RETURNS [      recipient: NSName.Name, recipientsHostNumber: System.HostNumber,      creds: Auth.Credentials, conversationKey: Auth.Key,      owner: Auth.IdentityHandle] =  BEGIN    RETURN[      PrivateConv[conversation].recipient, Auth.nullHostNumber,      PrivateConv[conversation].creds,      PublicKey[PrivateConv[conversation].conversationKey],      PublicIdent[PrivateConv[conversation].owner]];  END;GetIdentityDetails: PUBLIC ENTRY PROC [identity: Auth.IdentityHandle]  RETURNS [    name: NSName.Name, password: NSString.String, style: Auth.Flavor] =  BEGIN    ENABLE UNWIND => NULL;    RETURN[      PrivateIdent[identity].myName,      PrivateIdent[identity].myPassword,      PrivateIdent[identity].style];  END;GetRandomKey: PUBLIC PROC RETURNS [key: Auth.Key] =  BEGIN    key ¬ PublicKey[DESFace.GetRandomKey[]];  END;InternalCopyIdentity: ENTRY PROC [  identity: Auth.IdentityHandle, z: UNCOUNTED ZONE]  RETURNS [newCopy: Auth.IdentityHandle] =  BEGIN    ENABLE UNWIND => NULL;    newIdentity: PrivateIdentityHandle ¬ NIL;    newIdentity ¬      z.NEW[AuthInternal.IdentityObject ¬	[style: PrivateIdent[identity].style,	 myName: AuthInternal.CloneNSName[PrivateIdent[identity].myName, z],	 myPassword: AuthInternal.CloneNSString[PrivateIdent[identity].myPassword, z],	 myStrongKey: PrivateIdent[identity].myStrongKey,	 myHashedPassword: PrivateIdent[identity].myHashedPassword,	 nameHasBeenResolved: PrivateIdent[identity].nameHasBeenResolved,	 conversationsInUse: NIL,	 cachedConversations: NIL,	 owningHeap: z]];    Process.InitializeMonitor[@newIdentity.LOCK];    RETURN[PublicIdent[newIdentity]];  END;PasswordStringToKey: PUBLIC PROC [password: NSString.String]  RETURNS [key: Auth.Key] =  BEGIN    DoIter: PROC =      BEGIN	DESFace.CorrectParity[@lastKey];	DESFace.EncryptBlock[	  key: lastKey, -- Note: Passed by value!	  from: LOOPHOLE[LONG[@passwordChunk]],	  to: LOOPHOLE[LONG[@lastKey]]];      END;   -- Assume: SIZE[NSString.Character] = SIZE[UNSPECIFIED].    passwordChunk: ARRAY [0..3] OF NSString.Character;    lastKey: DESFace.Key ¬ ALL[[b: 0, p: 0]]; -- Initial key is zero.    expandedString: NSString.Characters;    IF password.length = 0 OR password.bytes = NIL THEN      BEGIN	DESFace.CorrectParity[@lastKey];	RETURN[PublicKey[lastKey]];	-- Don't bother doing anything if client gives us a null string...      END;    expandedString ¬ NSString.ExpandString[AuthInternal.asStubHeap, password];    BEGIN      ENABLE	UNWIND => NSString.FreeCharacters[AuthInternal.asStubHeap, expandedString];      leftoverChars: CARDINAL;      FOR i: CARDINAL IN [0..LENGTH[expandedString]) DO	passwordChunk[i MOD 4] ¬ NSString.LowerCase[expandedString[i]];	IF (i MOD 4) = 3 THEN DoIter[]; -- Full password chunk, run 'er thru!      ENDLOOP;      leftoverChars ¬ LENGTH[expandedString] MOD 4;      IF leftoverChars # 0 THEN	BEGIN	  -- Assert: leftoverChars IN [1..3]	  FOR i: CARDINAL IN [leftoverChars..4) DO	    passwordChunk[i] ¬ [0, 0];	  ENDLOOP;	  DoIter[];	END;    END;    NSString.FreeCharacters[AuthInternal.asStubHeap, expandedString];    DESFace.CorrectParity[@lastKey];    RETURN[PublicKey[lastKey]];  END;-- Public/Private pointer conversions --  -- Note: This is a hack to avoid exporting public types.  -- (Because exported type clashes make it impossible for two  -- different implementations which export the same type to co-exist.)PrivateIdentityHandle: TYPE = LONG POINTER TO AuthInternal.IdentityObject;PrivateConversationHandle: TYPE = LONG POINTER TO AuthInternal.ConversationObject;PrivateConv: PROC [conversation: Auth.ConversationHandle]  RETURNS [PrivateConversationHandle] = INLINE    {RETURN[LOOPHOLE[conversation]]};PublicConv: PROC [privateConversation: PrivateConversationHandle]  RETURNS [Auth.ConversationHandle] = INLINE    {RETURN[LOOPHOLE[privateConversation]]};PrivateIdent: PROC [identity: Auth.IdentityHandle]  RETURNS [PrivateIdentityHandle] = INLINE    {RETURN[LOOPHOLE[identity]]};PublicIdent: PROC [privateIdentity: PrivateIdentityHandle]  RETURNS [Auth.IdentityHandle] = INLINE    {RETURN[LOOPHOLE[privateIdentity]]};PublicKey: PROC [privateKey: DESFace.Key]  RETURNS [Auth.Key] = INLINE    {RETURN[LOOPHOLE[privateKey]]};-- Assumption checking --compileCheckNSCharacterIsSizeOfUnspecified: BOOLEAN [TRUE..TRUE] =  (SIZE[NSString.Character] = SIZE[UNSPECIFIED]);END.
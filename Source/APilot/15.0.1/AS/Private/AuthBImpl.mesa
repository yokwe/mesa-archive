-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- AuthBImpl.mesa-- JMaloney, 11-Jul-83 12:24:49.-- Last modified: JMaloney, 30-May-84 18:32:10.DIRECTORY  Auth USING [    AuthenticationError, CallError, CheckSimpleCredentials,    ConversationHandle, Credentials, Flavor,    IdentityHandle, IdentityObject, Key, nullCredentials,    nullKey, nullVerifier, Verifier],  AuthInternal USING [    asStubHeap, CloneNSName, CloneVerifier, ConversationObject, FreeNSName,    FreeSimpleCredentials, FreeStrongCredentials, IdentityObject,    IncrementVerifierTicks, InternalAuthenticate, InternalExtractCredentialsDetails,    PackStrongVerifier, UnpackSimpleCredentials,    UnpackStrongCredentials, UnpackStrongVerifier],  AuthProtocol USING [    acceptableVerifierRange, SimpleCredentials, StrongCredentials, StrongVerifier],  Courier USING [Error],  CredsCache USING [    GarbageCollect, InsertOrUpdateStrongCreds, InsertStrongCreds,    LookupStrongCreds, NotFound, Overflow],  DESFace USING [Key, nullKey],  Heap USING [MakeNode],  NSName USING [Name, NameRecord],  Router USING [AssignAddress],  System USING [    GetGreenwichMeanTime, gmtEpoch, GreenwichMeanTime,    HostNumber, NetworkAddress, SecondsSinceEpoch];AuthBImpl: MONITOR  LOCKS LOOPHOLE[identity, PrivateIdentityHandle]­ USING identity: Auth.IdentityHandle  IMPORTS Auth, AuthInternal, Courier, CredsCache, Heap, Router, System  EXPORTS Auth, AuthInternal    -- All exports are to Auth unless otherwise noted.  SHARES Auth =BEGIN-- Globals and constants --acceptableVerifierRange: LONG CARDINAL ¬ AuthProtocol.acceptableVerifierRange;asHeap: UNCOUNTED ZONE = AuthInternal.asStubHeap;clocksWayOff: LONG CARDINAL = LONG[48] * LONG[60] * LONG[60]; -- two daysnullNameRecord: NSName.NameRecord ¬ [];thisMachinesAddress: System.NetworkAddress ¬ Router.AssignAddress[];-- Authentication --Authenticate: PUBLIC PROC [  recipient: Auth.IdentityHandle, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [initiator: NSName.Name] =  BEGIN    recipientsKey: Auth.Key ¬      IF recipient # NIL THEN GetKeyFromIdentity[recipient] ELSE Auth.nullKey;    [initiator, , ] ¬ AuthInternal.InternalAuthenticate[      recipientsKey, credentialsToCheck, verifierToCheck,      z, thisMachinesAddress.host, FALSE, FALSE, TRUE, TRUE      ! Auth.CallError => {ERROR Auth.AuthenticationError[credentialsInvalid]}];  END;AuthenticateWithExpiredCredentials: PUBLIC PROC [  recipient: Auth.IdentityHandle, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [initiator: NSName.Name] =  BEGIN    recipientsKey: Auth.Key ¬      IF recipient # NIL THEN GetKeyFromIdentity[recipient] ELSE Auth.nullKey;    [initiator, , ] ¬ AuthInternal.InternalAuthenticate[      recipientsKey, credentialsToCheck, verifierToCheck,      z, thisMachinesAddress.host, TRUE, FALSE, TRUE, TRUE      ! Auth.CallError => {ERROR Auth.AuthenticationError[credentialsInvalid]}];  END;AuthenticateAndReply: PUBLIC PROC [  recipient: Auth.IdentityHandle, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [initiator: NSName.Name, replyVerifer: Auth.Verifier] =  BEGIN    recipientsKey: Auth.Key ¬      IF recipient # NIL THEN GetKeyFromIdentity[recipient] ELSE Auth.nullKey;    [initiator, , replyVerifer] ¬ AuthInternal.InternalAuthenticate[      recipientsKey, credentialsToCheck, verifierToCheck,      z, thisMachinesAddress.host, FALSE, TRUE, TRUE, TRUE      ! Auth.CallError => {ERROR Auth.AuthenticationError[credentialsInvalid]}];  END;ExtractCredentialsDetails: PUBLIC PROC [  recipientsKey: Auth.Key, credentialsToCheck: Auth.Credentials,  z: UNCOUNTED ZONE]    RETURNS [      flavor: Auth.Flavor,      conversationKey: Auth.Key,      expirationTime: System.GreenwichMeanTime,      initiator: NSName.Name, badCredentials: BOOLEAN] =  BEGIN    [flavor, conversationKey, expirationTime,      initiator, badCredentials, , ] ¬	AuthInternal.InternalExtractCredentialsDetails[	  recipientsKey, credentialsToCheck, z, FALSE];  END;ReplyVerifierChecks: PUBLIC PROC [  conversation: Auth.ConversationHandle, verifierToCheck: Auth.Verifier]    RETURNS [verifierOK: BOOLEAN ¬ TRUE] =  BEGIN    IsProperReplyVerifier: PROC [      verifierToCheck: Auth.Verifier, convKey: DESFace.Key,      recipientsHostNumber: System.HostNumber]	RETURNS [isProper: BOOLEAN ¬ TRUE] =      BEGIN	strongVerifier: AuthProtocol.StrongVerifier;	strongVerifier ¬	  AuthInternal.UnpackStrongVerifier[	    verifier: verifierToCheck, key: convKey,	    recipientsHostNumber: recipientsHostNumber	    ! Courier.Error => {isProper ¬ FALSE; CONTINUE}];	IF isProper = FALSE THEN RETURN[FALSE];	isProper ¬	  (strongVerifier =	   AuthInternal.IncrementVerifierTicks[	     PrivateConv[conversation].clearLastVerifier]);      END;    SELECT PrivateConv[conversation].creds.flavor FROM      simple => RETURN[TRUE];      strong =>	RETURN[IsProperReplyVerifier[	  verifierToCheck, PrivateConv[conversation].conversationKey,	  PrivateConv[conversation].recipientsHostNumber]];    ENDCASE => ERROR;  END;-- Internal utilities exported to AuthInternal ----AuthInternal.--InternalAuthenticate: PUBLIC PROC [  recipientsKey: Auth.Key, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE,  recipientsHostNumber: System.HostNumber, expiredCredsOk: BOOLEAN,  computeReplyVerifier: BOOLEAN, returnInitiator: BOOLEAN, putInCache: BOOLEAN]    RETURNS [      initiator: NSName.Name ¬ NIL,      conversationKey: DESFace.Key ¬ DESFace.nullKey, -- interesting for strong only      replyVerifier: Auth.Verifier ¬ Auth.nullVerifier] =  BEGIN    decryptedCreds: AuthProtocol.StrongCredentials ¬      [DESFace.nullKey, System.gmtEpoch, NIL];    BEGIN      ENABLE UNWIND => {	AuthInternal.FreeNSName[@initiator, z];	AuthInternal.FreeStrongCredentials[@decryptedCreds, asHeap];	};      badCreds, wasInCache: BOOLEAN ¬ FALSE;      flavor: Auth.Flavor ¬ credentialsToCheck.flavor;      lastVerifier: AuthProtocol.StrongVerifier;      tempKey: Auth.Key ¬ Auth.nullKey;      IF credentialsToCheck = Auth.nullCredentials THEN	-- Null credentials are always accepted.	BEGIN	  IF returnInitiator AND z # NIL	    THEN initiator ¬ AuthInternal.CloneNSName[@nullNameRecord, z];	  IF computeReplyVerifier THEN	    replyVerifier ¬ AuthInternal.CloneVerifier[verifierToCheck, z];	  RETURN;	END;      [ , tempKey, decryptedCreds.expirationTime,	decryptedCreds.initiator, badCreds, wasInCache, lastVerifier] ¬	  InternalExtractCredentialsDetails[	    recipientsKey, credentialsToCheck, asHeap, putInCache];      IF badCreds THEN ERROR Auth.AuthenticationError[credentialsInvalid];      conversationKey ¬ decryptedCreds.conversationKey ¬ PrivateKey[tempKey];      IF z # NIL AND returnInitiator	THEN initiator ¬ AuthInternal.CloneNSName[decryptedCreds.initiator, z];	-- copy the initiator name into the client's heap      AuthInternal.FreeNSName[@decryptedCreds.initiator, asHeap];	-- Warning: decryptedCreds.initiator will be NIL from this point on!!      SELECT flavor FROM	simple =>	  BEGIN	    IF ~Auth.CheckSimpleCredentials[credentialsToCheck, verifierToCheck]	      THEN ERROR Auth.AuthenticationError[verifierInvalid];		-- Must be a bad verifier because we successfully		-- decoded the credentials earlier...	    IF computeReplyVerifier THEN	      replyVerifier ¬ AuthInternal.CloneVerifier[verifierToCheck, z];	  END;	strong =>	  BEGIN	    cacheOverflow: BOOLEAN ¬ FALSE;	    strongVerifier: AuthProtocol.StrongVerifier;	    IF ~expiredCredsOk AND CredsExpired[decryptedCreds.expirationTime]	      THEN ERROR Auth.AuthenticationError[credentialsExpired];	    [strongVerifier, replyVerifier] ¬ CheckStrongVerifier[	      verifierToCheck, conversationKey, recipientsHostNumber,	      wasInCache, lastVerifier, computeReplyVerifier, z];	  -- Put dat sucker in da cache!	    IF putInCache	      THEN CredsCache.InsertOrUpdateStrongCreds[		credentialsToCheck, PrivateKey[recipientsKey], strongVerifier		! CredsCache.Overflow => {cacheOverflow ¬ TRUE; CONTINUE};		  Courier.Error => CONTINUE -- Not expected! --];	    IF cacheOverflow THEN [] ¬ CredsCache.GarbageCollect[];	  END;      ENDCASE => ERROR Auth.AuthenticationError[credentialsInvalid];    END;  END;--AuthInternal.--InternalExtractCredentialsDetails: PUBLIC PROC [  recipientsKey: Auth.Key, credentialsToCheck: Auth.Credentials,  z: UNCOUNTED ZONE, putInCache: BOOLEAN]    RETURNS [      flavor: Auth.Flavor,      conversationKey: Auth.Key ¬ Auth.nullKey,      expirationTime: System.GreenwichMeanTime ¬ System.gmtEpoch,      initiator: NSName.Name ¬ NIL,      badCredentials: BOOLEAN ¬ FALSE,      credsCacheHit: BOOLEAN ¬ FALSE,      lastVerifier: AuthProtocol.StrongVerifier ¬ [System.gmtEpoch, 0]] =      -- Note: lastVerifier is meaningful only if credsCacheHit is TRUE.  BEGIN    flavor ¬ credentialsToCheck.flavor;    SELECT flavor FROM      simple =>	BEGIN	  simpleCreds: AuthProtocol.SimpleCredentials;	  simpleCreds ¬	    AuthInternal.UnpackSimpleCredentials[	      credentialsToCheck, asHeap	      ! Courier.Error => {GOTO badCreds}];	  IF z # NIL	    THEN initiator ¬ AuthInternal.CloneNSName[simpleCreds.initiator, z];	  conversationKey ¬ Auth.nullKey;	  expirationTime ¬ System.gmtEpoch;	  AuthInternal.FreeSimpleCredentials[@simpleCreds, asHeap];	END;      strong =>	BEGIN	-- The interface to the credentials cache is mildly obscure. Since	-- inserting credentials into the cache causes a decryption and	-- decryption is expensive, we want to avoid doing this decryption	-- twice. Thus, the order of operations to try is:	--   1. First lookup the credentials in the cache. If this works,	--	we are done. If it fails, we make a note to retry.	--   2. If tryAgain, then we add the credentials to the cache,	--	causing them to be decrypted, and then we look them up.	--	They should be there, of course, but if the cache isn't	--	implemented on this machine, or if they have been	--	GarbageCollected, they won't be. In these cases, make a	--	note to try once more.	--   3. The third time, we give up on the cache and just decrypt the	--	bloody credentials the hard way.	  strongCreds: AuthProtocol.StrongCredentials;	  tryAgain: BOOLEAN ¬ FALSE;	  credsCacheHit ¬ TRUE;	  [strongCreds, lastVerifier] ¬	    CredsCache.LookupStrongCreds[	      credentialsToCheck, asHeap		! CredsCache.NotFound =>		  {credsCacheHit ¬ FALSE; tryAgain ¬ TRUE; CONTINUE}	      ];	  IF tryAgain AND putInCache THEN	    BEGIN	      tryAgain ¬ FALSE;	      CredsCache.InsertStrongCreds[		credentialsToCheck, PrivateKey[recipientsKey]		! CredsCache.Overflow => CONTINUE;		    -- Just plow on, we'll GarbageCollect later...		  Courier.Error => GOTO badCreds		  ];	      [strongCreds, ] ¬		CredsCache.LookupStrongCreds[		  credentialsToCheck, asHeap		  ! CredsCache.NotFound => {tryAgain ¬ TRUE; CONTINUE}];	    END;	  IF tryAgain THEN	    strongCreds ¬ AuthInternal.UnpackStrongCredentials[	      credentialsToCheck, PrivateKey[recipientsKey], asHeap	      ! Courier.Error => GOTO badCreds];	  IF z # NIL	    THEN initiator ¬ AuthInternal.CloneNSName[strongCreds.initiator, z];	  conversationKey ¬ PublicKey[strongCreds.conversationKey];	  expirationTime ¬ strongCreds.expirationTime;	  AuthInternal.FreeStrongCredentials[@strongCreds, asHeap];	END;    ENDCASE => GOTO badCreds;  EXITS    badCreds => {badCredentials ¬ TRUE; RETURN};  END;--AuthInternal.--IncrementVerifierTicks: PUBLIC PROC [strongVerifier: AuthProtocol.StrongVerifier]  RETURNS [newStrongVerifier: AuthProtocol.StrongVerifier] =  BEGIN    newStrongVerifier.ticks ¬      IF strongVerifier.ticks = LAST[LONG CARDINAL]	THEN 0	ELSE strongVerifier.ticks + 1;    newStrongVerifier.timeStamp ¬      [IF newStrongVerifier.ticks = 0	THEN strongVerifier.timeStamp + 1	ELSE strongVerifier.timeStamp];  END;--AuthInternal.--Style: PUBLIC ENTRY PROC [identity: Auth.IdentityHandle]  RETURNS [styleOfIdentity: Auth.Flavor] =  -- For use in non-entry procedures when one needs to look at the style field.  BEGIN    ENABLE UNWIND => NULL;    RETURN[PrivateIdent[identity].style];  END;-- Private stuff --CheckStrongVerifier: PROC [  verifier: Auth.Verifier, conversationKey: DESFace.Key,  recipientsHostNumber: System.HostNumber,  lastVerifierWasInTheCache: BOOLEAN, lastVerifier: AuthProtocol.StrongVerifier,  computeReplyVerifier: BOOLEAN, z: UNCOUNTED ZONE]    RETURNS [      strongVerifier: AuthProtocol.StrongVerifier,      replyVerifier: Auth.Verifier ¬ Auth.nullVerifier] =  BEGIN    timeHereAndNow, timestampInVerifier, difference: LONG CARDINAL;    strongVerifier ¬      AuthInternal.UnpackStrongVerifier[	verifier: verifier, key: conversationKey,	recipientsHostNumber: recipientsHostNumber	! Courier.Error => ERROR Auth.AuthenticationError[verifierInvalid]];    timeHereAndNow ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    timestampInVerifier ¬ System.SecondsSinceEpoch[strongVerifier.timeStamp];    difference ¬ IF timeHereAndNow < timestampInVerifier      THEN timestampInVerifier - timeHereAndNow      ELSE timeHereAndNow - timestampInVerifier;    IF difference > acceptableVerifierRange THEN      SELECT TRUE FROM	difference > clocksWayOff OR	timeHereAndNow < timestampInVerifier =>	  ERROR Auth.AuthenticationError[verifierInvalid];	timeHereAndNow > timestampInVerifier =>	  ERROR Auth.AuthenticationError[verifierExpired];      ENDCASE => ERROR;    IF lastVerifierWasInTheCache AND      ~Earlier[lastVerifier, strongVerifier]	THEN ERROR Auth.AuthenticationError[verifierReused];    IF computeReplyVerifier AND z # NIL THEN      BEGIN	clearReplyVerifier: AuthProtocol.StrongVerifier;	clearReplyVerifier ¬ IncrementVerifierTicks[strongVerifier];	replyVerifier ¬ DESCRIPTOR[	  Heap.MakeNode[z, SIZE[AuthProtocol.StrongVerifier]],	  SIZE[AuthProtocol.StrongVerifier]];	AuthInternal.PackStrongVerifier[	  from: @clearReplyVerifier,	  recipientsHostNumber: recipientsHostNumber,	  destVerifier: replyVerifier, key: conversationKey];      END;  END;CredsExpired: PROC [credsExpirationTime: System.GreenwichMeanTime]  RETURNS [expired: BOOLEAN] =  -- secondsUntilExpiration will be zero if the the credentials have expired.  BEGIN    timeHereAndNow, timeOfCredsExpiration: LONG CARDINAL;    timeHereAndNow ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    timeOfCredsExpiration ¬ System.SecondsSinceEpoch[credsExpirationTime];    RETURN[timeOfCredsExpiration <= timeHereAndNow];  END;Earlier: PROC [verifierOne, verifierTwo: AuthProtocol.StrongVerifier]  RETURNS[oneCreatedBeforeTwo: BOOLEAN ¬ FALSE] =  -- Returns true iff verifierOne was created *before* verifierTwo.  BEGIN    timeOfVerifierOne: LONG CARDINAL ¬      System.SecondsSinceEpoch[verifierOne.timeStamp];    timeOfVerifierTwo: LONG CARDINAL ¬      System.SecondsSinceEpoch[verifierTwo.timeStamp];    SELECT TRUE FROM      -- Remember, earlier times are lower numbers!!      timeOfVerifierOne < timeOfVerifierTwo => RETURN[TRUE];      timeOfVerifierOne > timeOfVerifierTwo => RETURN[FALSE];      timeOfVerifierOne = timeOfVerifierTwo =>	RETURN[(verifierOne.ticks < verifierTwo.ticks)];    ENDCASE;  END;GetKeyFromIdentity: ENTRY PROC [identity: Auth.IdentityHandle]  RETURNS [keyFromIdentity: Auth.Key] =  BEGIN    ENABLE UNWIND => NULL;    RETURN[PublicKey[PrivateIdent[identity].myStrongKey]];  END;-- Public/Private pointer conversions --  -- Note: This is a hack to avoid exporting public types.  -- (Because exported type clashes make it impossible for two  -- different implementations which export the same type to co-exist.)PrivateIdentityHandle: TYPE = LONG POINTER TO AuthInternal.IdentityObject;PrivateConversationHandle: TYPE = LONG POINTER TO AuthInternal.ConversationObject;PrivateConv: PROC [conversation: Auth.ConversationHandle]  RETURNS [PrivateConversationHandle] = INLINE    {RETURN[LOOPHOLE[conversation]]};PrivateIdent: PROC [identity: Auth.IdentityHandle]  RETURNS [PrivateIdentityHandle] = INLINE    {RETURN[LOOPHOLE[identity]]};PrivateKey: PROC [key: Auth.Key]  RETURNS [DESFace.Key] = INLINE    {RETURN[LOOPHOLE[key]]};PublicKey: PROC [privateKey: DESFace.Key]  RETURNS [Auth.Key] = INLINE    {RETURN[LOOPHOLE[privateKey]]};END.
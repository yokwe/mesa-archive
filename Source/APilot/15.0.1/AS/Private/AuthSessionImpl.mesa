-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- AuthSessionImpl.mesa-- JMaloney, 13-Mar-84 15:26:15.-- Last modified: JMaloney, 19-Apr-84 13:00:57.DIRECTORY  Auth USING [Credentials, IdentityHandle, Key, nullKey, nullVerifier, Verifier],  AuthInternal USING [CloneVerifier, IdentityObject, InternalAuthenticate],  AuthSession USING [],  DESFace USING [Key],  NSName USING [Name],  Router USING [AssignAddress],  System USING [HostNumber];AuthSessionImpl: MONITOR  LOCKS LOOPHOLE[identity, PrivateIdentityHandle]­ USING identity: Auth.IdentityHandle  IMPORTS AuthInternal, Router  EXPORTS AuthSession  SHARES Auth =BEGINmyHostNumber: System.HostNumber ¬ Router.AssignAddress[].host;InitialAuthenticate: PUBLIC PROC [  recipient: Auth.IdentityHandle, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [initiator: NSName.Name, replyVerifier: Auth.Verifier] =  BEGIN    recipientsKey: Auth.Key ¬      IF recipient # NIL THEN GetKeyFromIdentity[recipient] ELSE Auth.nullKey;    [initiator, , replyVerifier] ¬ AuthInternal.InternalAuthenticate[      recipientsKey, credentialsToCheck, verifierToCheck, z,      myHostNumber, FALSE, TRUE, TRUE, TRUE];  END;NextReplyVerifier: PUBLIC PROC [  recipient: Auth.IdentityHandle, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [replyVerifier: Auth.Verifier ¬ Auth.nullVerifier] =  BEGIN    recipientsKey: Auth.Key ¬      IF recipient # NIL THEN GetKeyFromIdentity[recipient] ELSE Auth.nullKey;    IF credentialsToCheck.flavor = strong THEN      [ , , replyVerifier] ¬ AuthInternal.InternalAuthenticate[	recipientsKey, credentialsToCheck, verifierToCheck, z,	myHostNumber, FALSE, (z # NIL), FALSE, TRUE]    ELSE      {IF z # NIL THEN replyVerifier ¬ AuthInternal.CloneVerifier[verifierToCheck, z]};  END;AuthenticateWithExpiredCredentials: PUBLIC PROC [  recipient: Auth.IdentityHandle, credentialsToCheck: Auth.Credentials,  verifierToCheck: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [replyVerifier: Auth.Verifier ¬ Auth.nullVerifier] =  BEGIN    recipientsKey: Auth.Key ¬      IF recipient # NIL THEN GetKeyFromIdentity[recipient] ELSE Auth.nullKey;    IF credentialsToCheck.flavor = strong THEN      [ , , replyVerifier] ¬ AuthInternal.InternalAuthenticate[	recipientsKey, credentialsToCheck, verifierToCheck, z,	myHostNumber, TRUE, (z # NIL), FALSE, TRUE]    ELSE      {IF z # NIL THEN replyVerifier ¬ AuthInternal.CloneVerifier[verifierToCheck, z]};  END;-- Private stuff --GetKeyFromIdentity: ENTRY PROC [identity: Auth.IdentityHandle]  RETURNS [keyFromIdentity: Auth.Key] =  BEGIN    ENABLE UNWIND => NULL;    RETURN[PublicKey[PrivateIdent[identity].myStrongKey]];  END;-- Public/Private pointer conversions --  -- Note: This is a hack to avoid exporting public types.  -- (Because exported type clashes make it impossible for two  -- different implementations which export the same type to co-exist.)PrivateIdentityHandle: TYPE = LONG POINTER TO AuthInternal.IdentityObject;PrivateIdent: PROC [identity: Auth.IdentityHandle]  RETURNS [PrivateIdentityHandle] = INLINE    {RETURN[LOOPHOLE[identity]]};PublicKey: PROC [privateKey: DESFace.Key]  RETURNS [Auth.Key] = INLINE    {RETURN[LOOPHOLE[privateKey]]};END.
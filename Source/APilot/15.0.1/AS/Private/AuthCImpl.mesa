-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- AuthCImpl.mesa-- JMaloney, 11-Jul-83 12:24:49.-- Last modified: JMaloney, 3-Jul-84 12:00:10.DIRECTORY  Auth USING [    AuthenticationError, CallError, CallProblem,    CheckOutCredsAndNextVerifier, ConversationHandle,    Credentials, Flavor, HashedPassword, HashSimplePassword,    IdentityHandle, Initiate, Key, nullCredentials,    nullHashedPassword, nullKey, nullVerifier,    PasswordStringToKey, Terminate, Verifier, WhichArg],  AuthInternal USING [    asStubHeap, BadCredentialsPackage, CloneNSString,    ConversationObject, ExtractStuffFromCredentialsPackage, FreeNSString,    FreeSimpleCredentials, IdentityObject,    Style, UnpackSimpleCredentials],  AuthOps USING [    ChangeSimpleKey, ChangeStrongKey,    CreateSimpleKey, CreateStrongKey,    DeleteSimpleKey, DeleteStrongKey,    CheckSimpleCredentials, GetStrongCredentials],  AuthProtocol USING [    CredentialsPackage, DescribeCredentialsPackage, SimpleCredentials],  AuthServerCache USING [ASAddress, NextPlease, Refill],  Courier USING [Description, Error, Free],  DESFace USING [Block, CheckKeyParity, EncryptBlock, Key, nullKey],  NSName USING [Name],  NSString USING [String],  Process USING [MsecToTicks, Pause, Ticks],  SharedKeys USING [asName],  System USING [GetClockPulses, NetworkAddress, nullNetworkAddress];AuthCImpl: MONITOR  LOCKS LOOPHOLE[identity, PrivateIdentityHandle]­ USING identity: Auth.IdentityHandle  IMPORTS    Auth, AuthInternal, AuthProtocol, AuthOps, AuthServerCache, Courier,    DESFace, Process, SharedKeys, System  EXPORTS Auth  SHARES Auth =BEGIN-- Globals and constants --cacheNeverFilled: BOOLEAN ¬ TRUE;pauseForInitialCacheFill: Process.Ticks ¬ Process.MsecToTicks[15000];  -- fifteen secondstimesToRetry: CARDINAL ¬ 1;  -- The number of times to grab a new address out of the cache and re-try  -- an operation which must talk to an AS.-- Password/Key administration operations --ChangeMyPasswords: PUBLIC PROC [  identity: Auth.IdentityHandle, newPassword: NSString.String, z: UNCOUNTED ZONE,  changeStrong, changeSimple: BOOLEAN] =  BEGIN    ComputeOldKeyValues: ENTRY PROC [identity: Auth.IdentityHandle]      RETURNS [oldStrongValue: Auth.Key, oldSimpleValue: Auth.HashedPassword] =      -- Computes oldStrongValue and oldSimpleValue from password      -- in identity handle.      BEGIN	ENABLE UNWIND => NULL;	oldStrongValue ¬	  Auth.PasswordStringToKey[PrivateIdent[identity].myPassword];	oldSimpleValue ¬	  Auth.HashSimplePassword[PrivateIdent[identity].myPassword];      END;    ChangeIdentityInfo: ENTRY PROC [identity: Auth.IdentityHandle] =      -- Fix up the password info in the identity.      BEGIN	ENABLE UNWIND => NULL;	AuthInternal.FreeNSString[	  @PrivateIdent[identity].myPassword, PrivateIdent[identity].owningHeap];	PrivateIdent[identity].myPassword ¬	  AuthInternal.CloneNSString[newPassword, PrivateIdent[identity].owningHeap];	IF changeStrong	  THEN PrivateIdent[identity].myStrongKey ¬ PrivateKey[newStrongKey];	IF changeSimple	  THEN PrivateIdent[identity].myHashedPassword ¬ newHashedPassword;      END;    newStrongKey: Auth.Key ¬ Auth.PasswordStringToKey[newPassword];    newHashedPassword: Auth.HashedPassword ¬      Auth.HashSimplePassword[newPassword];    IF changeStrong THEN ChangeStrongKey[identity, newStrongKey];    IF changeSimple THEN      BEGIN	ENABLE UNWIND => {	  -- Undo what we have done so far...	  oldStrongKey: Auth.Key ¬ Auth.nullKey;	  oldSimpleKey: Auth.HashedPassword ¬ Auth.nullHashedPassword;	  [oldStrongKey, oldSimpleKey] ¬ ComputeOldKeyValues[identity];	  IF changeStrong THEN	    ChangeStrongKey[	      identity, oldStrongKey	      ! Auth.AuthenticationError, Auth.CallError => CONTINUE];	  ChangeSimpleKey[	    identity, oldSimpleKey	    ! Auth.AuthenticationError, Auth.CallError => CONTINUE];	  };	ChangeSimpleKey[identity, newHashedPassword];      END;    -- If we got this far it worked; we can fix up identityObject.    ChangeIdentityInfo[identity];  END;CreateStrongKey: PUBLIC PROC [  identity: Auth.IdentityHandle, name: NSName.Name, newStrongKey: Auth.Key] =  BEGIN    DoIt: PROC [      creds: Auth.Credentials, verifier: Auth.Verifier, conv: Auth.ConversationHandle,      asAddressPtr: LONG POINTER TO System.NetworkAddress] =	BEGIN	  encryptedInitialKey: DESFace.Block;	  DESFace.EncryptBlock[	    key: PrivateConv[conv].conversationKey,	    from: LOOPHOLE[LONG[@newStrongKey]], to: @encryptedInitialKey];	  AuthOps.CreateStrongKey[	    creds, verifier, name, encryptedInitialKey, asAddressPtr];	END;    SELECT AuthInternal.Style[identity] FROM      simple => ERROR Auth.AuthenticationError[inappropriateCredentials];      strong => ConverseWithASAndCallMe[identity, name, DoIt];    ENDCASE => ERROR;  END;ChangeStrongKey: PUBLIC PROC [  identity: Auth.IdentityHandle, newStrongKey: Auth.Key] =  BEGIN    ChangeIdentityInfo: ENTRY PROC [identity: Auth.IdentityHandle] =      BEGIN	ENABLE UNWIND => NULL;	AuthInternal.FreeNSString[	  @PrivateIdent[identity].myPassword, PrivateIdent[identity].owningHeap];	-- Leave password a nullString because it is no longer related to	-- the "truth" in identity.myStrongKey.	PrivateIdent[identity].myStrongKey ¬ PrivateKey[newStrongKey];      END;    DoIt: PROC [      creds: Auth.Credentials, verifier: Auth.Verifier, conv: Auth.ConversationHandle,      asAddressPtr: LONG POINTER TO System.NetworkAddress] =	BEGIN	  encryptedNewKey: DESFace.Block;	  DESFace.EncryptBlock[	    key: PrivateConv[conv].conversationKey,	    from: LOOPHOLE[LONG[@newStrongKey]], to: @encryptedNewKey];	AuthOps.ChangeStrongKey[creds, verifier, encryptedNewKey, asAddressPtr];	END;    SELECT AuthInternal.Style[identity] FROM      simple => ERROR Auth.AuthenticationError[inappropriateCredentials];      strong =>	ConverseWithASAndCallMe[identity, PrivateIdent[identity].myName, DoIt];    ENDCASE => ERROR;    -- If we got this far it worked; we can fix up identityObject.    ChangeIdentityInfo[identity];  END;DeleteStrongKey: PUBLIC PROC [identity: Auth.IdentityHandle, name: NSName.Name] =  BEGIN    DoIt: PROC [      creds: Auth.Credentials, verifier: Auth.Verifier, conv: Auth.ConversationHandle,      asAddressPtr: LONG POINTER TO System.NetworkAddress] =	BEGIN	  AuthOps.DeleteStrongKey[creds, verifier, name, asAddressPtr];	END;    SELECT AuthInternal.Style[identity] FROM      simple => ERROR Auth.AuthenticationError[inappropriateCredentials];      strong => ConverseWithASAndCallMe[identity, name, DoIt];    ENDCASE => ERROR;  END;CreateSimpleKey: PUBLIC PROC [  identity: Auth.IdentityHandle, name: NSName.Name,  newSimpleKey: Auth.HashedPassword] =  BEGIN    DoIt: PROC [      creds: Auth.Credentials, verifier: Auth.Verifier, conv: Auth.ConversationHandle,      asAddressPtr: LONG POINTER TO System.NetworkAddress] =	BEGIN	  AuthOps.CreateSimpleKey[	    creds, verifier, name, newSimpleKey, asAddressPtr];	END;    ConverseWithASAndCallMe[identity, name, DoIt];  END;ChangeSimpleKey: PUBLIC PROC [  identity: Auth.IdentityHandle, newSimpleKey: Auth.HashedPassword] =  BEGIN    ChangeIdentityInfo: ENTRY PROC [identity: Auth.IdentityHandle] =      BEGIN	ENABLE UNWIND => NULL;	AuthInternal.FreeNSString[	  @PrivateIdent[identity].myPassword, PrivateIdent[identity].owningHeap];	-- Leave password a nullString because it is no longer related to	-- the "truth" in identity.myHashedPassword.	PrivateIdent[identity].myHashedPassword ¬ newSimpleKey;      END;    DoIt: PROC [      creds: Auth.Credentials, verifier: Auth.Verifier, conv: Auth.ConversationHandle,      asAddressPtr: LONG POINTER TO System.NetworkAddress] =	BEGIN	  AuthOps.ChangeSimpleKey[creds, verifier, newSimpleKey, asAddressPtr];	END;    ConverseWithASAndCallMe[identity, PrivateIdent[identity].myName, DoIt];    -- If we got this far it worked; we can fix up identityObject.    ChangeIdentityInfo[identity];  END;DeleteSimpleKey: PUBLIC PROC [identity: Auth.IdentityHandle, name: NSName.Name] =  BEGIN    DoIt: PROC [      creds: Auth.Credentials, verifier: Auth.Verifier, conv: Auth.ConversationHandle,      asAddressPtr: LONG POINTER TO System.NetworkAddress] =	BEGIN	  AuthOps.DeleteSimpleKey[creds, verifier, name, asAddressPtr];	END;    ConverseWithASAndCallMe[identity, name, DoIt];  END;-- Credentials operations which call the server --CheckSimpleCredentials: PUBLIC PROC [  creds: Auth.Credentials, verifier: Auth.Verifier]    RETURNS [ok: BOOLEAN ¬ FALSE] =  BEGIN    DoIt: PROC [asAddressPtr: LONG POINTER TO System.NetworkAddress] =      BEGIN	ok ¬ AuthOps.CheckSimpleCredentials[creds, verifier, asAddressPtr];      END;    IF creds.flavor # simple      THEN ERROR Auth.AuthenticationError[credentialsInvalid];    BEGIN      simpleCreds: AuthProtocol.SimpleCredentials ¬	AuthInternal.UnpackSimpleCredentials[	  creds, AuthInternal.asStubHeap	  ! Courier.Error => ERROR Auth.AuthenticationError[credentialsInvalid]];      -- The following calls the AS and sets ok:      ContactASAndCallMe[	DoIt, simpleCreds.initiator	! UNWIND =>	  AuthInternal.FreeSimpleCredentials[@simpleCreds, AuthInternal.asStubHeap]];      AuthInternal.FreeSimpleCredentials[@simpleCreds, AuthInternal.asStubHeap];    END;  END;FetchStrongCredentials: PUBLIC PROC [  initiator, recipient: NSName.Name,  initiatorsStrongKey: Auth.Key, z: UNCOUNTED ZONE]    RETURNS [creds: Auth.Credentials, conversationKey: Auth.Key] =  BEGIN    DoIt: PROC [asAddressPtr: LONG POINTER TO System.NetworkAddress] =      BEGIN	credentialsPackage ¬	  AuthOps.GetStrongCredentials[initiator, recipient, nonce, asAddressPtr];      END;    convKey: DESFace.Key ¬ DESFace.nullKey;    credentialsPackage: AuthProtocol.CredentialsPackage;    nonce: LONG CARDINAL ¬ System.GetClockPulses[];    SELECT TRUE FROM      initiator = NIL => ERROR Auth.CallError[strongKeyDoesNotExist, initiator];      recipient = NIL => ERROR Auth.CallError[strongKeyDoesNotExist, recipient];    ENDCASE;    ContactASAndCallMe[DoIt, initiator]; -- fills in credentialsPackage    BEGIN      ENABLE UNWIND => Courier.Free[	[@credentialsPackage, AuthProtocol.DescribeCredentialsPackage],	AuthInternal.asStubHeap];      [creds, convKey] ¬	AuthInternal.ExtractStuffFromCredentialsPackage[	  credentialsPackage, PrivateKey[initiatorsStrongKey],	  recipient, nonce, z	  ! AuthInternal.BadCredentialsPackage =>	    ERROR Auth.CallError[badKey, notApplicable]];      IF ~DESFace.CheckKeyParity[@convKey]	THEN ERROR Auth.CallError[badKey, notApplicable];    END;    Courier.Free[      [@credentialsPackage, AuthProtocol.DescribeCredentialsPackage],      AuthInternal.asStubHeap];    RETURN[creds, PublicKey[convKey]];  END;-- Private stuff --ConverseWithASAndCallMe: PROC [  identity: Auth.IdentityHandle, nameHint: NSName.Name,  procToCall: PROC [    Auth.Credentials, Auth.Verifier, Auth.ConversationHandle,    LONG POINTER TO System.NetworkAddress]] =  BEGIN    retrys: CARDINAL ¬ 0;    asAddress: System.NetworkAddress ¬ System.nullNetworkAddress;    creds: Auth.Credentials ¬ Auth.nullCredentials;    verifier: Auth.Verifier ¬ Auth.nullVerifier;    conv: Auth.ConversationHandle;    conv ¬ Auth.Initiate[identity, SharedKeys.asName, , AuthInternal.asStubHeap];    asAddress ¬ AuthServerCache.ASAddress[nameHint];    BEGIN      ENABLE UNWIND => Auth.Terminate[@conv, AuthInternal.asStubHeap];      DO	[creds, verifier] ¬ Auth.CheckOutCredsAndNextVerifier[conv, asAddress.host];	procToCall[	  creds, verifier, conv, @asAddress	  ! Auth.CallError =>	    IF (reason = cannotReachAS OR reason = tooBusy) AND	      retrys < timesToRetry		THEN		  BEGIN		    addressesLeftInCache: CARDINAL ¬		      AuthServerCache.NextPlease[asAddress];		    AuthServerCache.Refill[];		    asAddress ¬ AuthServerCache.ASAddress[];		    retrys ¬ retrys + 1;		    LOOP;		  END;	   Auth.AuthenticationError =>	     -- The reason must be credentialsInvalid; this is highly unusual!	     {ERROR Auth.CallError[badKey, notApplicable]};	  ];	EXIT; -- Successful call      ENDLOOP;    END;    Auth.Terminate[@conv, AuthInternal.asStubHeap];  END;ContactASAndCallMe: PROC [  procToCall: PROC [LONG POINTER TO System.NetworkAddress],  nameHint: NSName.Name] =  BEGIN    retrys: CARDINAL ¬ 0;    asAddress: System.NetworkAddress ¬ AuthServerCache.ASAddress[nameHint];    IF cacheNeverFilled THEN      BEGIN	AuthServerCache.Refill[];	cacheNeverFilled ¬ FALSE;	IF asAddress = System.nullNetworkAddress THEN	  BEGIN	    Process.Pause[pauseForInitialCacheFill]; -- Wait only if we have to.	    asAddress ¬ AuthServerCache.ASAddress[];	  END;      END;    DO      procToCall[	@asAddress	! Auth.CallError =>	    IF (reason = cannotReachAS OR reason = tooBusy) AND	      retrys < timesToRetry		THEN		  BEGIN		    addressesLeftInCache: CARDINAL ¬		      AuthServerCache.NextPlease[asAddress];		    AuthServerCache.Refill[];		    asAddress ¬ AuthServerCache.ASAddress[];		    retrys ¬ retrys + 1;		    LOOP;		  END;	];      EXIT; -- Successful call    ENDLOOP;  END;-- Public/Private pointer conversions --  -- Note: This is a hack to avoid exporting public types.  -- (Because exported type clashes make it impossible for two  -- different implementations which export the same type to co-exist.)PrivateIdentityHandle: TYPE = LONG POINTER TO AuthInternal.IdentityObject;PrivateConversationHandle: TYPE = LONG POINTER TO AuthInternal.ConversationObject;PrivateConv: PROC [conversation: Auth.ConversationHandle]  RETURNS [PrivateConversationHandle] = INLINE    {RETURN[LOOPHOLE[conversation]]};PrivateIdent: PROC [identity: Auth.IdentityHandle]  RETURNS [PrivateIdentityHandle] = INLINE    {RETURN[LOOPHOLE[identity]]};PrivateKey: PROC [key: Auth.Key]  RETURNS [DESFace.Key] = INLINE    {RETURN[LOOPHOLE[key]]};PublicKey: PROC [privateKey: DESFace.Key]  RETURNS [Auth.Key] = INLINE    {RETURN[LOOPHOLE[privateKey]]};END.
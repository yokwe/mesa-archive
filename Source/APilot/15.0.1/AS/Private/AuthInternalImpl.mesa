-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- AuthInternalImpl.mesa-- JMaloney, 12-Jul-83 15:45:32.-- Last modified: JMaloney, 3-Jul-84 10:55:23.DIRECTORY  Auth USING [    Credentials, Flavor, HashedPassword, Key,    nullCredentials, nullVerifier, Verifier],  AuthInternal USING [UserEntry, UserPassword],  AuthProtocol USING [    courierNSNameOverheadInWords,    CredentialsPackage, CredentialsPackageInternals,    DescribeCredentialsPackageInternals, DescribeSimpleCredentials,    DescribeStrongCredentials, DescribeStrongVerifier, HostMask,    maxCredentialsPackageSizeInBlocks, maxCredentialsPackageSizeInWords,    maxCredentialsSizeInBlocks, maxCredentialsSizeInWords,    RoundBytesToWords, RoundWordsToDESBlocks,    SimpleCredentials, SimpleVerifier,    StrongCredentials, StrongVerifier],  ByteBlt USING [StartIndexGreaterThanStopIndexPlusOne],  Courier USING [    Free, Error, Description, DeserializeParameters, InvalidArguments,    Parameters, SerializeParameters],  DESFace USING [    Block, CBCCheckDecrypt, CBCCheckEncrypt,    DecryptBlock, EncryptBlock, Key, nullKey],  Heap USING [Create, Error, FreeNode, MakeNode],  Inline USING [DBITXOR, LongCOPY],  MemoryStream USING [Create, Destroy, IndexOutOfRange],  NSName USING [    DescribeNameRecord, maxDomainLength, maxLocalLength,    maxOrgLength, NameRecord, Name],  NSString USING [DescribeString, MakeString, nullString, String],  NSStringExtras USING [EquivalentNames],  Stream USING [EndOfStream, GetWord, Handle, PutWord],  System USING [GreenwichMeanTime, HostNumber, nullHostNumber];AuthInternalImpl: PROGRAM  IMPORTS    AuthProtocol, ByteBlt, Courier, DESFace, Heap, Inline,    MemoryStream, NSName, NSString, NSStringExtras, Stream  EXPORTS AuthInternal  SHARES Auth =BEGIN-- Globals and errors --asServerHeap: PUBLIC UNCOUNTED ZONE ¬ NIL;  -- Filled in by the server, if there is one.  -- (Assume: The server is ALWAYS started after the stub.)asStubHeap: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[  initial: 4, increment: 4, ownerChecking: doDebug];BadCredentialsPackage: PUBLIC ERROR = CODE;defaultExpirationTime: PUBLIC LONG CARDINAL ¬  LONG[24] * LONG[60] * LONG[60]; -- 24 hours, in secondsdoDebug: PUBLIC BOOLEAN ¬ FALSE;usePasskey: PUBLIC BOOLEAN ¬ FALSE;-- Miscellaneous utilities --ExtractStuffFromCredentialsPackage: PUBLIC PROC [  credsPackage: AuthProtocol.CredentialsPackage, recipientsKey: DESFace.Key,  recipientsName: NSName.Name, nonce: LONG CARDINAL, z: UNCOUNTED ZONE]    RETURNS [creds: Auth.Credentials, convKey: DESFace.Key] =  -- May raise BadCredentialsPackage.  BEGIN    credsPackageLength: CARDINAL ¬ LENGTH[credsPackage];    temp: ARRAY [0..AuthProtocol.maxCredentialsPackageSizeInBlocks)      OF DESFace.Block;    credsPackageGuts: AuthProtocol.CredentialsPackageInternals ¬ [];    IF credsPackageLength > AuthProtocol.maxCredentialsPackageSizeInWords      OR credsPackageLength MOD SIZE[DESFace.Block] # 0	THEN ERROR BadCredentialsPackage;    Inline.LongCOPY[      from: BASE[credsPackage], to: @temp,      nwords: credsPackageLength];    DESFace.CBCCheckDecrypt[      key: recipientsKey, nBlks: credsPackageLength/SIZE[DESFace.Block],      from: @temp, to: @temp, seed: [0,0,0,0]];    UnstuffParameters[      parameters:	[@credsPackageGuts, AuthProtocol.DescribeCredentialsPackageInternals],      from: DESCRIPTOR[@temp, credsPackageLength], z: z      ! Courier.Error => ERROR BadCredentialsPackage];    BEGIN      ENABLE UNWIND =>	Courier.Free[	  [@credsPackageGuts, AuthProtocol.DescribeCredentialsPackageInternals],	  z];      -- Assume: recipientsName # NIL      IF credsPackageGuts.nonce # nonce OR	~EquivalentNames[credsPackageGuts.recipient, recipientsName]	THEN ERROR BadCredentialsPackage;      creds ¬ credsPackageGuts.credentials;      credsPackageGuts.credentials ¬ Auth.nullCredentials;	-- This is done so that Courier will not free the credentials	-- that we are returning to our client. Obscure, but it saves	-- a heap allocation and copy.      convKey ¬ credsPackageGuts.conversationKey;    END;    Courier.Free[      [@credsPackageGuts, AuthProtocol.DescribeCredentialsPackageInternals],      z];  END;MakeVerifierFromHashedPassword: PUBLIC PROC [  hashedPassword: Auth.HashedPassword, z: UNCOUNTED ZONE]    RETURNS [verifier: Auth.Verifier] =  BEGIN    -- Assume: SIZE[AuthProtocol.SimpleVerifier] = 1    verifier ¬ DESCRIPTOR[      Heap.MakeNode[z, SIZE[AuthProtocol.SimpleVerifier]],      SIZE[AuthProtocol.SimpleVerifier]];    verifier[0] ¬ hashedPassword;  END;PackStrongVerifier: PUBLIC PROC [  from: LONG POINTER TO AuthProtocol.StrongVerifier,  recipientsHostNumber: System.HostNumber,  destVerifier: Auth.Verifier, key: DESFace.Key] =  -- Modifies destVerifier.  -- destVerifier must be large enough to hold a strong verifier.  BEGIN    hostMask: AuthProtocol.HostMask ¬ [host: recipientsHostNumber];    IF doDebug AND recipientsHostNumber = System.nullHostNumber      THEN from ¬ from;	-- This is a good place to set a breakpoint if you suspect that	-- there is a bug in the client program. Except when your	-- are broadcasting, using a null host number to produce a verifier	-- is not allowed. (Note: Some clients, like the MS, may in	-- fact transmit verifiers in their broadcasts.)    -- Assume: SIZE[AuthProtocol.StrongVerifier] = SIZE[DESFace.Block]    IF BASE[destVerifier] = NIL      OR LENGTH[destVerifier] # SIZE[DESFace.Block]	THEN ERROR; -- You passed me a bad destVerifier.    StuffParameters[      parameters: [from, AuthProtocol.DescribeStrongVerifier],      to: destVerifier];    BlockXOR[from: @hostMask, to: BASE[destVerifier]];    DESFace.EncryptBlock[      key: key, from: LOOPHOLE[BASE[destVerifier]],      to: LOOPHOLE[BASE[destVerifier]]];  END;StuffParameters: PUBLIC PROC [  parameters: Courier.Parameters,  to: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED] =  BEGIN    memStream: Stream.Handle;    memStream ¬ MemoryStream.Create[      [blockPointer: LOOPHOLE[BASE[to]],       startIndex: 0, stopIndexPlusOne: 2*LENGTH[to]]];    BEGIN      ENABLE UNWIND => MemoryStream.Destroy[memStream];      Courier.SerializeParameters[parameters, memStream];      DO -- Zero fill the rest of the buffer	Stream.PutWord[memStream, 0 ! Stream.EndOfStream => EXIT];      ENDLOOP;    END;    MemoryStream.Destroy[memStream];  END;UnstuffParameters: PUBLIC PROC [  parameters: Courier.Parameters,  from: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED,  z: UNCOUNTED ZONE] =  BEGIN    memStream: Stream.Handle;    memStream ¬ MemoryStream.Create[      [blockPointer: LOOPHOLE[BASE[from]],       startIndex: 0, stopIndexPlusOne: 2*LENGTH[from]]];    BEGIN      ENABLE UNWIND => MemoryStream.Destroy[memStream];      Courier.DeserializeParameters[	parameters, memStream, z	! ByteBlt.StartIndexGreaterThanStopIndexPlusOne,	  Courier.Error, Courier.InvalidArguments,	  Heap.Error, MemoryStream.IndexOutOfRange =>	    BEGIN	      Courier.Free[parameters, z]; -- Clean up.	      ERROR Courier.Error[parameterInconsistency];	    END;	];      DO -- Rest of buffer should be zeros	word: CARDINAL;	word ¬ Stream.GetWord[memStream ! Stream.EndOfStream => EXIT];	IF word # 0 THEN ERROR Courier.Error[parameterInconsistency];      ENDLOOP;    END;    MemoryStream.Destroy[memStream];  END;WordsForSerializedName: PUBLIC PROC [name: NSName.Name]  RETURNS [words: CARDINAL] =  BEGIN    -- Assume: name # NIL    words ¬      AuthProtocol.courierNSNameOverheadInWords	+ AuthProtocol.RoundBytesToWords[name.org.length]	+ AuthProtocol.RoundBytesToWords[name.domain.length]	+ AuthProtocol.RoundBytesToWords[name.local.length];  END;-- Manufacturing credentials --MakeStrongCredentials: PUBLIC PROC [  conversationKey: DESFace.Key,  expirationTime: System.GreenwichMeanTime,  initiator: NSName.Name,  recipientsKey: DESFace.Key,  z: UNCOUNTED ZONE]    RETURNS [strongCredentials: Auth.Credentials] =  BEGIN    strongCredsRecord: AuthProtocol.StrongCredentials;    blocksForStrongCreds: CARDINAL;    wordsForStrongCreds: CARDINAL;    strongCredsRecord ¬ [conversationKey, expirationTime, initiator];    blocksForStrongCreds ¬ AuthProtocol.RoundWordsToDESBlocks[      SIZE[AuthProtocol.StrongCredentials]      - SIZE[NSName.Name] + WordsForSerializedName[initiator]];    wordsForStrongCreds ¬ blocksForStrongCreds * SIZE[DESFace.Block];    strongCredentials ¬ [      flavor: strong,      value: DESCRIPTOR[	Heap.MakeNode[z, wordsForStrongCreds], wordsForStrongCreds]      ];    BEGIN      ENABLE UNWIND => Heap.FreeNode[z, BASE[strongCredentials.value]];      StuffParameters[	parameters: [@strongCredsRecord, AuthProtocol.DescribeStrongCredentials],	to: strongCredentials.value];      DESFace.CBCCheckEncrypt[	key: recipientsKey, nBlks: blocksForStrongCreds,	from: BASE[strongCredentials.value], to: BASE[strongCredentials.value],	seed: [0,0,0,0]];    END;  END;MakeSimpleCredentials: PUBLIC PROC [initiator: NSName.Name, z: UNCOUNTED ZONE]  RETURNS [simpleCredentials: Auth.Credentials] =  BEGIN    simpleCredsRecord: AuthProtocol.SimpleCredentials;    wordsForSimpleCreds: CARDINAL;    IF NilOrNullName[initiator] THEN RETURN[Auth.nullCredentials];    simpleCredsRecord ¬ [initiator];    wordsForSimpleCreds ¬      SIZE[AuthProtocol.SimpleCredentials]      - SIZE[NSName.Name] + WordsForSerializedName[initiator];    simpleCredentials ¬ [      flavor: simple,      value: DESCRIPTOR[	Heap.MakeNode[z, wordsForSimpleCreds], wordsForSimpleCreds]      ];    StuffParameters[      parameters: [@simpleCredsRecord, AuthProtocol.DescribeSimpleCredentials],      to: simpleCredentials.value      ! UNWIND => Heap.FreeNode[z, BASE[simpleCredentials.value]]];  END;-- Unpacking credentials --UnpackStrongCredentials: PUBLIC PROC [  strongCredentials: Auth.Credentials, recipientsKey: DESFace.Key,  z: UNCOUNTED ZONE]    RETURNS [unpacked: AuthProtocol.StrongCredentials ¬ []] =  BEGIN    credsLength: CARDINAL;    temp: ARRAY [0..AuthProtocol.maxCredentialsSizeInBlocks) OF DESFace.Block;    credsLength ¬ LENGTH[strongCredentials.value];    IF credsLength > AuthProtocol.maxCredentialsSizeInWords OR      credsLength MOD SIZE[DESFace.Block] # 0	THEN ERROR Courier.Error[parameterInconsistency];    Inline.LongCOPY[      from: BASE[strongCredentials.value], to: @temp,      nwords: credsLength];    DESFace.CBCCheckDecrypt[      key: recipientsKey, nBlks: credsLength/SIZE[DESFace.Block],      from: @temp, to: @temp, seed: [0,0,0,0]];    UnstuffParameters[      parameters: [@unpacked, AuthProtocol.DescribeStrongCredentials],      from: DESCRIPTOR[@temp, credsLength], z: z];  END;FreeStrongCredentials: PUBLIC PROC [  strongCredentialsPtr: LONG POINTER TO AuthProtocol.StrongCredentials,  z: UNCOUNTED ZONE] =  BEGIN    FreeNSName[@strongCredentialsPtr.initiator, z];      -- (Faster than Courier.Free)  END;UnpackSimpleCredentials: PUBLIC PROC [  simpleCredentials: Auth.Credentials, z: UNCOUNTED ZONE]    RETURNS [unpacked: AuthProtocol.SimpleCredentials ¬ []] =  BEGIN    nullNameRecord: NSName.NameRecord ¬ [];    IF LENGTH[simpleCredentials.value] = 0 OR BASE[simpleCredentials.value] = NIL      THEN {unpacked.initiator ¬ CloneNSName[@nullNameRecord, z]; RETURN};    UnstuffParameters[      parameters: [@unpacked, AuthProtocol.DescribeSimpleCredentials],      from: simpleCredentials.value, z: z];  END;FreeSimpleCredentials: PUBLIC PROC [  simpleCredentialsPtr: LONG POINTER TO AuthProtocol.SimpleCredentials,  z: UNCOUNTED ZONE] =  BEGIN    FreeNSName[@simpleCredentialsPtr.initiator, z];      -- (Faster than Courier.Free)  END;-- Unpacking verifiers --UnpackStrongVerifier: PUBLIC PROC [  verifier: Auth.Verifier, key: DESFace.Key,  recipientsHostNumber: System.HostNumber]    RETURNS [unpacked: AuthProtocol.StrongVerifier] =  BEGIN    hostMask: AuthProtocol.HostMask ¬ [host: recipientsHostNumber];    temp: DESFace.Block;    -- Assume: SIZE[AuthProtocol.StrongVerifier] = SIZE[DESFace.Block];    IF LENGTH[verifier] # SIZE[DESFace.Block] THEN      ERROR Courier.Error[parameterInconsistency];    DESFace.DecryptBlock[key: key, from: LOOPHOLE[BASE[verifier]], to: @temp];    BlockXOR[from: @hostMask, to: @temp];    UnstuffParameters[      parameters: [@unpacked, AuthProtocol.DescribeStrongVerifier],      from: DESCRIPTOR[@temp, SIZE[DESFace.Block]], z: NIL];	-- z is nil because there is no storage allocation.  END;UnpackSimpleVerifier: PUBLIC PROC [verifier: Auth.Verifier]  RETURNS [unpacked: AuthProtocol.SimpleVerifier] =  BEGIN    IF LENGTH[verifier] # 1 THEN ERROR Courier.Error[parameterInconsistency];    unpacked ¬ verifier[0];  END;-- Credentials and verifiers --CloneCredentials: PUBLIC PROC [creds: Auth.Credentials, z: UNCOUNTED ZONE]  RETURNS [newCopy: Auth.Credentials] =  BEGIN    newCopy ¬ [      flavor: creds.flavor,      value: DESCRIPTOR[	Heap.MakeNode[z, LENGTH[creds.value]], LENGTH[creds.value]]      ];    Inline.LongCOPY[      from: BASE[creds.value], to: BASE[newCopy.value],      nwords: LENGTH[creds.value]];  END;FreeCredentials: PUBLIC PROC [  credsPtr: LONG POINTER TO Auth.Credentials, z: UNCOUNTED ZONE] =  BEGIN    IF BASE[credsPtr­.value] # NIL THEN      BEGIN	Heap.FreeNode[z, BASE[credsPtr­.value]];	credsPtr­ ¬ Auth.nullCredentials;      END;  END;CloneVerifier: PUBLIC PROC [  verifier: Auth.Verifier, z: UNCOUNTED ZONE]    RETURNS [newCopy: Auth.Verifier] =  BEGIN    IF verifier = NIL THEN RETURN[NIL];    newCopy ¬ DESCRIPTOR[Heap.MakeNode[z, LENGTH[verifier]], LENGTH[verifier] ];    Inline.LongCOPY[      from: BASE[verifier], to: BASE[newCopy],      nwords: LENGTH[verifier]];  END;FreeVerifier: PUBLIC PROC [  verifierPtr: LONG POINTER TO Auth.Verifier, z: UNCOUNTED ZONE] =  BEGIN    IF BASE[verifierPtr­] # NIL THEN      BEGIN	Heap.FreeNode[z, BASE[verifierPtr­]];	verifierPtr­ ¬ Auth.nullVerifier;      END;  END;-- Names and strings ---- Room for improvement: Allocate the space for the three fields and the name-- record in one contiguous lump. One allocation is better than four!! Also,-- we could have a separate, uniform heap just for names to avoid fragmentation.MakeEmptyNSName: PUBLIC PROC [z: UNCOUNTED ZONE]  RETURNS [newName: NSName.Name]  =  BEGIN    newName ¬ z.NEW[NSName.NameRecord];    newName­ ¬ [      org: NSString.MakeString[z, NSName.maxOrgLength],      domain: NSString.MakeString[z, NSName.maxDomainLength],      local: NSString.MakeString[z, NSName.maxLocalLength]];  END;CloneNSName: PUBLIC PROC [name: NSName.Name, z: UNCOUNTED ZONE]  RETURNS [newCopy: NSName.Name] =  -- Maintains the maxlengths in the fields of the name.  BEGIN    IF name = NIL THEN RETURN[NIL];    newCopy ¬ z.NEW[NSName.NameRecord];    newCopy­ ¬ [      org: CloneNSString[name.org, z],      domain: CloneNSString[name.domain, z],      local: CloneNSString[name.local, z]];  END;FreeNSName: PUBLIC PROC [  namePtr: LONG POINTER TO NSName.Name, z: UNCOUNTED ZONE] =  BEGIN    IF namePtr­ = NIL THEN RETURN;    FreeNSString[@namePtr.org, z];    FreeNSString[@namePtr.domain, z];    FreeNSString[@namePtr.local, z];    z.FREE[namePtr]; -- Stuffs NIL in namePtr­.  END;MakeEmptyNSString: PUBLIC PROC [maxlength: CARDINAL, z: UNCOUNTED ZONE]  RETURNS [newString: NSString.String] =  BEGIN    newString ¬ NSString.MakeString[z, maxlength];  END;CloneNSString: PUBLIC PROC [string: NSString.String, z: UNCOUNTED ZONE]  RETURNS [newCopy: NSString.String] =  -- This differs from NSString.CopyString in that the copy has the same  -- maxlength as the original.  BEGIN    IF (string.maxlength = 0 OR string.bytes = NIL)      -- This test subsumes the case: string = NSString.nullString      THEN RETURN[NSString.nullString];    newCopy ¬ NSString.MakeString[z, string.maxlength];    IF string.length > 0 THEN      BEGIN	-- The following operation will not copy the final byte	-- of an odd-length string:	Inline.LongCOPY[	  from: string.bytes, to: newCopy.bytes, nwords: string.length/2];	-- So, in case string.length was odd (redundant if it was even):	newCopy.bytes[string.length - 1] ¬ string.bytes[string.length - 1];      END;    newCopy.length ¬ string.length;  END;FreeNSString: PUBLIC PROC [  stringPtr: LONG POINTER TO NSString.String, z: UNCOUNTED ZONE]  =  -- This differs from NSString.FreeString in that it crams NSString.nullString  -- into stringPtr­.  BEGIN    IF stringPtr.bytes # NIL THEN z.FREE[@stringPtr.bytes];    stringPtr­ ¬ NSString.nullString;  END;NilOrNullName: PUBLIC PROC [name: NSName.Name]  RETURNS [isNilOrNull: BOOLEAN] =  BEGIN    RETURN[      name = NIL OR      ((name.org.length = 0 OR name.org.bytes = NIL)	AND (name.domain.length = 0 OR name.domain.bytes = NIL)	AND (name.local.length = 0 OR name.local.bytes = NIL))];  END;EquivalentNames: PUBLIC PROC [name1, name2: NSName.Name]  RETURNS [equivalent: BOOLEAN] =  BEGIN    IF name1 = NIL THEN RETURN[(name2 = NIL)];    IF name2 = NIL THEN RETURN[(name1 = NIL)];      -- (Always FALSE, but clearer this way.)    RETURN[NSStringExtras.EquivalentNames[name1, name2]];  END;-- User entry/password stuff --DescribeUserEntry: PUBLIC Courier.Description =  BEGIN    user: LONG POINTER TO AuthInternal.UserEntry =      notes.noteSize[SIZE[AuthInternal.UserEntry]]; -- notes.noteCardinal[@user.lastNameIndex];    notes.noteParameters[@user.password, NSString.DescribeString]; -- notes.noteBoolean[@user.systemAdministrator];    notes.noteDisjointData[@user.fileserver, NSName.DescribeNameRecord];    notes.noteDisjointData[@user.mailserver, NSName.DescribeNameRecord];    notes.noteParameters[@user.description, NSString.DescribeString];    notes.noteParameters[@user.product, NSString.DescribeString];    notes.noteParameters[@user.training, NSString.DescribeString]; -- noteBoolean[@user.help];  END;DescribeUserPassword: PUBLIC Courier.Description =  BEGIN    userPassword: LONG POINTER TO AuthInternal.UserPassword =      notes.noteSize[SIZE[AuthInternal.UserPassword]];    notes.noteParameters[@userPassword.password, NSString.DescribeString];  END;-- Private procedures --FourWords: TYPE = MACHINE DEPENDENT RECORD [  doubleWord1, doubleWord2: LONG UNSPECIFIED];BlockXOR: PROC [from, to: LONG POINTER -- TO FourWords --] =  BEGIN    OPEN      source: LOOPHOLE[from, LONG POINTER TO FourWords],      dest: LOOPHOLE[to, LONG POINTER TO FourWords];    dest.doubleWord1 ¬ Inline.DBITXOR[source.doubleWord1, dest.doubleWord1];    dest.doubleWord2 ¬ Inline.DBITXOR[source.doubleWord2, dest.doubleWord2];  END;-- Loopholes --PrivateKey: PROC [key: Auth.Key]  RETURNS [DESFace.Key] = INLINE    {RETURN[LOOPHOLE[key]]};PublicKey: PROC [privateKey: DESFace.Key]  RETURNS [Auth.Key] = INLINE    {RETURN[LOOPHOLE[privateKey]]};-- Compile-time assumption checks --compileCheck1: BOOLEAN [TRUE..TRUE] = (SIZE[AuthProtocol.SimpleVerifier] = 1);compileCheck2: BOOLEAN [TRUE..TRUE] =  (SIZE[AuthProtocol.StrongVerifier] = SIZE[DESFace.Block]);compileCheck3: BOOLEAN [TRUE..TRUE] =  (SIZE[FourWords] = SIZE[DESFace.Block]);END.
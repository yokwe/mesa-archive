-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- AuthStubOpsImpl.mesa-- JMaloney, 23-Aug-83 11:27:46.-- Last modified: JMaloney, 21-May-84 16:02:53.DIRECTORY  Auth USING [    AuthenticationError, AuthenticationProblem, CallError, CallProblem,    Credentials, HashedPassword, Verifier, WhichArg],  AuthInternal USING [asServerHeap, asStubHeap],  AuthOps USING [    GetStrongCredentialsProc, CheckSimpleCredentialsProc,    CreateStrongKeyProc, ChangeStrongKeyProc, DeleteStrongKeyProc,    CreateSimpleKeyProc, ChangeSimpleKeyProc, DeleteSimpleKeyProc],  AuthProtocol USING [    CredentialsPackage, GetProgramNumbers,    authenticationError, AuthenticationErrorRecord, DescribeAuthenticationErrorRecord,    callError, CallErrorRecord, DescribeCallErrorRecord,    getStrongCredentials,    GetStrongCredentialsArgs, GetStrongCredentialsResults,    DescribeGetStrongCredentialsArgs, DescribeGetStrongCredentialsResults,    checkSimpleCredentials,    CheckSimpleCredentialsArgs, CheckSimpleCredentialsResults,    DescribeCheckSimpleCredentialsArgs, DescribeCheckSimpleCredentialsResults,    createStrongKey, CreateStrongKeyArgs, DescribeCreateStrongKeyArgs,    changeStrongKey, ChangeStrongKeyArgs, DescribeChangeStrongKeyArgs,    deleteStrongKey, DeleteStrongKeyArgs, DescribeDeleteStrongKeyArgs,    createSimpleKey, CreateSimpleKeyArgs, DescribeCreateSimpleKeyArgs,    changeSimpleKey, ChangeSimpleKeyArgs, DescribeChangeSimpleKeyArgs,    deleteSimpleKey, DeleteSimpleKeyArgs, DescribeDeleteSimpleKeyArgs],  AuthServerCache USING [UseLocalServer],  CHAddressCacheFriends USING [InvalidateAddr],  Courier USING [    Call, Create, Delete, Error, ErrorCode, Handle, nullParameters,    Parameters, RemoteErrorSignalled, VersionMismatch, VersionRange],  DESFace USING [Block],  Heap USING [FreeNode, MakeNode],  Inline USING [LongCOPY],  NetworkStream USING [], -- Courier requires NetworkStream.ClassOfService  NSName USING [Name],  System USING [NetworkAddress, nullNetworkAddress];AuthStubOpsImpl: PROGRAM  IMPORTS    Auth, AuthInternal, AuthProtocol, AuthServerCache,    CHAddressCacheFriends, Courier, Heap, Inline  EXPORTS AuthOps =BEGIN-- Globals --noResults: Courier.Parameters = Courier.nullParameters;procs: RECORD [  getStrongCredentials: AuthOps.GetStrongCredentialsProc,  checkSimpleCredentials: AuthOps.CheckSimpleCredentialsProc,  createStrongKey: AuthOps.CreateStrongKeyProc,  changeStrongKey: AuthOps.ChangeStrongKeyProc,  deleteStrongKey: AuthOps.DeleteStrongKeyProc,  createSimpleKey: AuthOps.CreateSimpleKeyProc,  changeSimpleKey: AuthOps.ChangeSimpleKeyProc,  deleteSimpleKey: AuthOps.DeleteSimpleKeyProc];threeMinutes: CARDINAL ¬ 3 * 60; -- in seconds  -- Note: This replaces AuthProtocol.remoteCallTimeout,  -- which was too short.-- Public procedures --GetStrongCredentials: PUBLIC PROC [  initiator, recipient: NSName.Name, nonce: LONG CARDINAL,  asAddressPtr: LONG POINTER TO System.NetworkAddress]    RETURNS [credentialsPackage: AuthProtocol.CredentialsPackage] =  BEGIN    credentialsPackage ¬      procs.getStrongCredentials[initiator, recipient, nonce, asAddressPtr]; -- If the server has registered itself with the stub, then the storage -- for credentialsPackage was allocated from server's heap. We must -- replace this with a copy allocated from the stub's heap.    IF procs.getStrongCredentials # RemoteGetStrongCredentials AND      BASE[credentialsPackage] # NIL THEN      BEGIN	tempCredentialsPackage: AuthProtocol.CredentialsPackage ¬ DESCRIPTOR [	  Heap.MakeNode[AuthInternal.asStubHeap, LENGTH[credentialsPackage]],	  LENGTH[credentialsPackage]	  ];	Inline.LongCOPY[	  from: BASE[credentialsPackage], to: BASE[tempCredentialsPackage],	  nwords: LENGTH[credentialsPackage]];	Heap.FreeNode[AuthInternal.asServerHeap, BASE[credentialsPackage]];	credentialsPackage ¬ tempCredentialsPackage;      END;  END;CheckSimpleCredentials: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  asAddressPtr: LONG POINTER TO System.NetworkAddress]    RETURNS [ok: BOOLEAN] =  BEGIN    ok ¬ procs.checkSimpleCredentials[credentials, verifier, asAddressPtr];  END;CreateStrongKey: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name, encryptedInitialKey: DESFace.Block,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    procs.createStrongKey[      credentials, verifier, name, encryptedInitialKey, asAddressPtr];  END;ChangeStrongKey: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  encryptedNewKey: DESFace.Block,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    procs.changeStrongKey[credentials, verifier, encryptedNewKey, asAddressPtr];  END;DeleteStrongKey: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    procs.deleteStrongKey[credentials, verifier, name, asAddressPtr];  END;CreateSimpleKey: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name, initialKey: Auth.HashedPassword,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    procs.createSimpleKey[credentials, verifier, name, initialKey, asAddressPtr];  END;ChangeSimpleKey: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  newKey: Auth.HashedPassword,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    procs.changeSimpleKey[credentials, verifier, newKey, asAddressPtr];  END;DeleteSimpleKey: PUBLIC PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    procs.deleteSimpleKey[credentials, verifier, name, asAddressPtr];  END;RegisterServerOps: PUBLIC PROC [  getStrongCredentialsProc: AuthOps.GetStrongCredentialsProc,  checkSimpleCredentialsProc: AuthOps.CheckSimpleCredentialsProc,  createStrongKeyProc: AuthOps.CreateStrongKeyProc,  changeStrongKeyProc: AuthOps.ChangeStrongKeyProc,  deleteStrongKeyProc: AuthOps.DeleteStrongKeyProc,  createSimpleKeyProc: AuthOps.CreateSimpleKeyProc,  changeSimpleKeyProc: AuthOps.ChangeSimpleKeyProc,  deleteSimpleKeyProc: AuthOps.DeleteSimpleKeyProc] =  BEGIN    procs ¬ [      getStrongCredentialsProc, checkSimpleCredentialsProc,      createStrongKeyProc, changeStrongKeyProc, deleteStrongKeyProc,      createSimpleKeyProc, changeSimpleKeyProc, deleteSimpleKeyProc];    AuthServerCache.UseLocalServer[TRUE];  END;UnregisterServerOps: PUBLIC PROC =  -- That is, register the remote procedures.  BEGIN    AuthServerCache.UseLocalServer[FALSE];    procs ¬ [      RemoteGetStrongCredentials, RemoteCheckSimpleCredentials,      RemoteCreateStrongKey, RemoteChangeStrongKey, RemoteDeleteStrongKey,      RemoteCreateSimpleKey, RemoteChangeSimpleKey, RemoteDeleteSimpleKey];  END;-- Remote procedure calls --RemoteGetStrongCredentials: PROC [  initiator, recipient: NSName.Name, nonce: LONG CARDINAL,  asAddressPtr: LONG POINTER TO System.NetworkAddress]    RETURNS [credentialsPackage: AuthProtocol.CredentialsPackage] =  BEGIN    argsRec: AuthProtocol.GetStrongCredentialsArgs ¬ [initiator, recipient, nonce];    resultsRec: AuthProtocol.GetStrongCredentialsResults;    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeGetStrongCredentialsArgs];    results: Courier.Parameters ¬      [@resultsRec, AuthProtocol.DescribeGetStrongCredentialsResults];    RemoteProcedureCall[      AuthProtocol.getStrongCredentials, args, results, asAddressPtr­];    RETURN[resultsRec.credentialsPackage];  END;RemoteCheckSimpleCredentials: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  asAddressPtr: LONG POINTER TO System.NetworkAddress]    RETURNS [ok: BOOLEAN] =  BEGIN    argsRec: AuthProtocol.CheckSimpleCredentialsArgs ¬ [credentials, verifier];    resultsRec: AuthProtocol.CheckSimpleCredentialsResults;    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeCheckSimpleCredentialsArgs];    results: Courier.Parameters ¬      [@resultsRec, AuthProtocol.DescribeCheckSimpleCredentialsResults];    RemoteProcedureCall[      AuthProtocol.checkSimpleCredentials, args, results, asAddressPtr­];    RETURN[resultsRec.ok];  END;RemoteCreateStrongKey: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name, encryptedInitialKey: DESFace.Block,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    argsRec: AuthProtocol.CreateStrongKeyArgs ¬      [credentials, verifier, name, encryptedInitialKey];    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeCreateStrongKeyArgs];    RemoteProcedureCall[      AuthProtocol.createStrongKey, args, noResults, asAddressPtr­];  END;RemoteChangeStrongKey: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  encryptedNewKey: DESFace.Block,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    argsRec: AuthProtocol.ChangeStrongKeyArgs ¬      [credentials, verifier, encryptedNewKey];    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeChangeStrongKeyArgs];    RemoteProcedureCall[      AuthProtocol.changeStrongKey, args, noResults, asAddressPtr­];  END;RemoteDeleteStrongKey: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    argsRec: AuthProtocol.DeleteStrongKeyArgs ¬      [credentials, verifier, name];    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeDeleteStrongKeyArgs];    RemoteProcedureCall[      AuthProtocol.deleteStrongKey, args, noResults, asAddressPtr­];  END;RemoteCreateSimpleKey: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name, initialKey: Auth.HashedPassword,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    argsRec: AuthProtocol.CreateSimpleKeyArgs ¬      [credentials, verifier, name, initialKey];    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeCreateSimpleKeyArgs];    RemoteProcedureCall[      AuthProtocol.createSimpleKey, args, noResults, asAddressPtr­];  END;RemoteChangeSimpleKey: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  newKey: Auth.HashedPassword,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    argsRec: AuthProtocol.ChangeSimpleKeyArgs ¬      [credentials, verifier, newKey];    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeChangeSimpleKeyArgs];    RemoteProcedureCall[      AuthProtocol.changeSimpleKey, args, noResults, asAddressPtr­];  END;RemoteDeleteSimpleKey: PROC [  credentials: Auth.Credentials, verifier: Auth.Verifier,  name: NSName.Name,  asAddressPtr: LONG POINTER TO System.NetworkAddress] =  BEGIN    argsRec: AuthProtocol.DeleteSimpleKeyArgs ¬      [credentials, verifier, name];    args: Courier.Parameters ¬      [@argsRec, AuthProtocol.DescribeDeleteSimpleKeyArgs];    RemoteProcedureCall[      AuthProtocol.deleteSimpleKey, args, noResults, asAddressPtr­];  END;-- Courier remote procedure call --Status: TYPE = {  ok, courierError, callError, authenticationError, unknownError};ReplyCode: TYPE = RECORD [  status: Status ¬ ok,  courierProblem: Courier.ErrorCode ¬ noError,    -- has meaning only if status=courierError  callProblem: Auth.CallProblem ¬ tooBusy,    -- has meaning only if status=callError  whichArg: Auth.WhichArg ¬ notApplicable,    -- has meaning only if status=callError  authenticationProblem: Auth.AuthenticationProblem ¬ credentialsInvalid    -- has meaning only if status=authenticationError   ];RemoteProcedureCall: PROC [  remoteProc: CARDINAL, args, results: Courier.Parameters,  addressOfAuthServer: System.NetworkAddress] =  -- Courier.Errors and remote errors are caught here.  BEGIN    program: LONG CARDINAL;    version: CARDINAL;    courierHandle: Courier.Handle ¬ NIL;    reply: ReplyCode ¬ [ok, ];    IF addressOfAuthServer = System.nullNetworkAddress      THEN ERROR Auth.CallError[cannotReachAS, notApplicable];      -- No Auth Server.    BEGIN      ENABLE UNWIND =>	IF courierHandle # NIL THEN Courier.Delete[courierHandle];      [program, version, , ] ¬ AuthProtocol.GetProgramNumbers[];      courierHandle ¬ Courier.Create[	addressOfAuthServer, program, version,	AuthInternal.asStubHeap, transactional];      [] ¬ Courier.Call[	cH: courierHandle, procedureNumber: remoteProc,	arguments: args, results: results, timeoutInSeconds: threeMinutes      -- Notes on timeout: Courier will always detect the situation where      -- the callee disappears because the underlying stream machinery      -- will timeout. The timeout specified here is different; it will      -- cause the call abort even if the stream is still open. Thus,      -- it protects you from hanging forever if the server is "live-locked"      -- (up but not making and useful progress).	! Courier.Error => {	    reply.status ¬ courierError;	    reply.courierProblem ¬ errorCode;	    CONTINUE;	    };	  Courier.VersionMismatch =>	    BEGIN	      serverVersionRange: Courier.VersionRange ¬ versionRange;	      reply.status ¬ courierError;	      reply.courierProblem ¬ protocolMismatch;	      CONTINUE;	    END;	  Courier.RemoteErrorSignalled =>	    BEGIN	      SELECT errorNumber FROM		AuthProtocol.callError =>		  BEGIN		    callErrorRecord: AuthProtocol.CallErrorRecord;		    reply.status ¬ callError;		    arguments[		      [@callErrorRecord,		       AuthProtocol.DescribeCallErrorRecord]];		    reply.callProblem ¬		      SELECT callErrorRecord.problem FROM			tooBusy => tooBusy,			accessRightsInsufficient => accessRightsInsufficient,			keysUnavailable => keysUnavailable,			strongKeyDoesNotExist => strongKeyDoesNotExist,			simpleKeyDoesNotExist => simpleKeyDoesNotExist,			strongKeyAlreadyRegistered => strongKeyAlreadyRegistered,			simpleKeyAlreadyRegistered => simpleKeyAlreadyRegistered,			domainForNewKeyUnavailable =>			  domainForNewKeyUnavailable,			domainForNewKeyUnknown => domainForNewKeyUnknown,			badKey => badKey,			badName => badNameForNewKey,			databaseFull => databaseFull,			other => other,		      ENDCASE => ERROR;		    reply.whichArg ¬ callErrorRecord.whichArg;		    -- Courier.Free[@callErrorRecord, ...] isn't necessary		    --   since a CallErrorRecord has no disjoint storage.		  END;		AuthProtocol.authenticationError =>		  BEGIN		    authenticationErrorRecord: AuthProtocol.AuthenticationErrorRecord;		    reply.status ¬ authenticationError;		    arguments[		      [@authenticationErrorRecord,		       AuthProtocol.DescribeAuthenticationErrorRecord]];		    reply.authenticationProblem ¬ authenticationErrorRecord.problem;		    -- Courier.Free[@authenticationErrorRecord, ...] isn't necessary		    --   since an AuthenticationErrorRecord has no disjoint storage.		  END;	      ENDCASE => reply.status ¬ unknownError;	      CONTINUE;	    END;	]; -- end of Courier.Call      SELECT reply.status FROM	ok => NULL; -- Call completed with no errors.	courierError =>	  SELECT reply.courierProblem FROM	    transmissionMediumHardwareProblem,	    transmissionMediumUnavailable,	    transmissionMediumNotReady,	    noAnswerOrBusy,	    noRouteToSystemElement,	    transportTimeout,	    remoteSystemElementNotResponding,	    noCourierAtRemoteSite =>	      BEGIN		-- These errors all indicate that we cannot communicate		-- AT ALL with the given address. In that case, we		-- ought to tell the CH cache about it.		CHAddressCacheFriends.InvalidateAddr[addressOfAuthServer];		ERROR Auth.CallError[cannotReachAS, notApplicable];	      END;	    tooManyConnections =>	      ERROR Auth.CallError[tooBusy, notApplicable];	  ENDCASE => ERROR Auth.CallError[cannotReachAS, notApplicable];	callError =>	  ERROR Auth.CallError[reply.callProblem, reply.whichArg];	authenticationError =>	  ERROR Auth.AuthenticationError[reply.authenticationProblem];      ENDCASE => ERROR Auth.CallError[other, notApplicable];    END;    Courier.Delete[courierHandle];  END;-- Initialization --  -- Initialize procs record with remote procedures:  UnregisterServerOps[];END.
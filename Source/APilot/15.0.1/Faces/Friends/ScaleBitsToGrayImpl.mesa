-- ScaleBitsToGrayImpl.mesa-- Last edited: JPM, 3-Dec-86 12:28:14-- Copyright (C) Xerox Corporation 1986, All rights reserved.DIRECTORY  Environment USING [BitAddress, bitsPerWord, Byte, Long],  ESCAlphaExtras USING [aSCALEBITSTOGRAY],  Frame USING [GetReturnFrame, ReadPC, WritePC],  Inline USING [DBITSHIFT, LowHalf],  PrincOps USING [ESCTrapTable],  ScaleBitsToGray USING [SBTGptr, ScaleFactor];ScaleBitsToGrayImpl: PROGRAM  IMPORTS Frame, Inline  EXPORTS ScaleBitsToGray =  BEGIN  -- TYPEs  ByteSeqPtr: TYPE = LONG POINTER TO RECORD [    PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte ];  -- constants  bitCounts: ARRAY [0..3] OF CARDINAL = [0, 1, 1, 2];  -- INLINE PROCs  BumpBitAddress: PROC [ba: Environment.BitAddress, incr: CARDINAL] RETURNS [Environment.BitAddress] = INLINE    BEGIN    offset: LONG CARDINAL = ba.bit + incr;    RETURN [[(ba.word + offset / Environment.bitsPerWord), , (Inline.LowHalf[offset] MOD Environment.bitsPerWord)]]    END;  -- PUBLIC PROCs  SoftwareScaleBitsToGray: PUBLIC PROCEDURE [ptr: ScaleBitsToGray.SBTGptr] =    BEGIN    scale: ScaleBitsToGray.ScaleFactor = ptr.scale;    lines: CARDINAL = (SELECT scale FROM      twoByTwo => 2,      fourByFour => 4,      eightByEight => 8,      sixteenBySixteen => 16,      ENDCASE => ERROR);    countsPerPixel: CARDINAL = lines / 2;    dstPtr: ByteSeqPtr = ptr.dst.word;    srcBase: Environment.BitAddress ¬ ptr.src;    srcPtr: LONG POINTER;    countArray: RECORD [      c: ARRAY [0..8) OF CARDINAL,      protection: ARRAY [0..7) OF CARDINAL] ¬ [NULL, ALL[0]];    LoadCountArray: PROC = INLINE      BEGIN      work: Environment.Long;      IF (work.low ¬ srcPtr­) = 0 THEN countArray.c ¬ ALL[0]	ELSE FOR i: CARDINAL IN [0..8) DO	  work.high ¬ 0;          work.lu ¬ Inline.DBITSHIFT[work.lu, 2];	  countArray.c[i] ¬ bitCounts[work.high]	ENDLOOP;      END;    FOR i: CARDINAL IN [0..lines) DO      srcIndex: CARDINAL ¬ srcBase.bit / 2;      dstIndex: CARDINAL ¬ ptr.dst.byte;      srcPtr ¬ srcBase.word;      LoadCountArray[];      THROUGH [0..ptr.pixelCount) DO        sum: CARDINAL ¬ 0;        IF srcIndex >= 8 THEN          BEGIN	  srcPtr ¬ srcPtr + 1;	  LoadCountArray[];	  srcIndex ¬ 0	  END;        THROUGH [0..countsPerPixel) DO          sum ¬ sum + countArray.c[srcIndex];	  srcIndex ¬ srcIndex + 1        ENDLOOP;        IF i # 0 THEN sum ¬ sum + dstPtr[dstIndex];	IF i = 15 AND sum > 127 THEN sum ¬ sum - 1;        dstPtr[dstIndex] ¬ sum;        dstIndex ¬ dstIndex + 1      ENDLOOP;      srcBase ¬ BumpBitAddress [srcBase, ptr.srcBpl]    ENDLOOP    END;  -- PRIVATE PROC (for trap table)    -- since this is called as trap instruction, we gotta    -- bump the pc.  Note that it is minimal stack, which    -- means we don't have to bother dumping state.  SCALEBITSTOGRAY: PROC [ptr: ScaleBitsToGray.SBTGptr] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    SoftwareScaleBitsToGray [ptr]    END;  -- main code  PrincOps.ESCTrapTable[ESCAlphaExtras.aSCALEBITSTOGRAY] ¬ LOOPHOLE[SCALEBITSTOGRAY]  END. -- of ScaleBitsToGrayImplLOG31-Oct-86 -- JPM -- Created.3-Dec-86 -- JPM -- Changed to process one source line at a time (like the microcode).
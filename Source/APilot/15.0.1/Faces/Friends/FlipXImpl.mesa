-- File: FlipXImpl.mesa-- Last Edit: --	      MYT    18-Nov-86 --		     19-Nov-86 add counter for debug --	      JPM     4-Dec-86 change defs name from FlipXOps to FlipX-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Inline USING [BITROTATE, LowHalf, DBITAND, DBITSHIFT],  Frame USING [GetReturnFrame, ReadPC, WritePC],  PrincOps USING [ESCTrapTable],  ESCAlphaExtras USING [aFLIPXBITS, aFLIPXGRAY],  FlipX;  FlipXImpl: PROGRAM  IMPORTS Inline, Frame  EXPORTS FlipX =    BEGIN    OPEN Inline;       -- FlipXBits PROC  FlipXBits: PUBLIC  PROC [left:LONG POINTER,width:INTEGER] =     BEGIN    -- since this is called as a trap instruction, we gotta bump the pc.      Frame.WritePC[        pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],        lf: Frame.GetReturnFrame[]];      SoftwareFlipXBits[left,width];    END; -- of FlipXBits      SoftwareFlipXBits : PUBLIC PROC [left: LONG POINTER,width:INTEGER] =     BEGIN      right: LONG POINTER ¬ left + LONG[width] - 1;      temp:  CARDINAL;            THROUGH [0..width/2) DO        temp ¬ ReverseBits[right]; 	right­ ¬ ReverseBits[left];	left­ ¬ temp;	right ¬ right - 1;	left ¬ left + 1;      ENDLOOP;            IF left = right THEN -- odd wpl, skip the middle word         right­ ¬ ReverseBits[left];	     END; -- of SoftwareFlipXBits    -- ReverseBits private procedure   ReverseBits: PROCEDURE [inptr:LONG POINTER] RETURNS [word:CARDINAL]=    BEGIN      count: INTEGER ¬ 0;      worklow: CARDINAL ¬ 0;      work: LONG CARDINAL ¬ LONG[inptr­];      work ¬ Inline.DBITSHIFT[work,16];        THROUGH[0..15) DO        work ¬ Inline.DBITSHIFT[work,-1];	worklow ¬ Inline.BITROTATE[Inline.LowHalf[work],2];	work ¬ Inline.DBITAND [work,0FFFF0000H];	work ¬ work + LONG[worklow];	ENDLOOP;      --process last bit        count ¬ count + 1;        work ¬ Inline.DBITSHIFT[work,-1];	RETURN[Inline.BITROTATE[Inline.LowHalf[work],1]];    END;    	 -- FlipXGray PROC  FlipXGray: PUBLIC PROC [left:LONG POINTER,width:INTEGER] =     BEGIN    -- since this is called as a trap instruction, we gotta bump the pc.      Frame.WritePC[        pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],        lf: Frame.GetReturnFrame[]];      SoftwareFlipXGray[left,width];    END; -- of FlipXGray      SoftwareFlipXGray : PUBLIC PROC [left: LONG POINTER,width:INTEGER] =     BEGIN      right: LONG POINTER ¬ left + LONG[width] - 1;      temp:  CARDINAL;            THROUGH [0..width/2) DO        temp ¬ Inline.BITROTATE[right­,8]; 	right­ ¬ Inline.BITROTATE[left­,8];	left­ ¬ temp;	right ¬ right - 1;	left ¬ left + 1;      ENDLOOP;            IF left = right THEN -- odd wpl, skip the middle word        right­ ¬ Inline.BITROTATE[left­,8];	     END; -- of SoftwareFlipXGray          -- Main Line code     PrincOps.ESCTrapTable[ESCAlphaExtras.aFLIPXBITS]  ¬ LOOPHOLE[FlipXBits];    PrincOps.ESCTrapTable[ESCAlphaExtras.aFLIPXGRAY]  ¬ LOOPHOLE[FlipXGray];    END.
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- DoveInputOutput.mesa  -- Created by DEG: 30-May-84 14:07:57-- Last edited by JPM: 30-Jul-85 14:33:40<<	Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.	The following program was created in 1984 but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.>>DIRECTORY  Environment USING [bitsPerWord, Byte, bytesPerWord, first64K, Long, LongPointerFromPage, PageCount, PageFromLongPointer, PageNumber, wordsPerPage],  Inline USING [LowHalf, HighHalf],  ESCAlpha USING [ << aINPUT, aOUTPUT >> alpha << , aLOCKMEM, aNOTIFYIOP >>, aROTATE, aVERSION],  Mopcodes USING [zEXCH, zESC, zLI8],  PageMap USING [GetState];DoveInputOutput: DEFINITIONS  IMPORTS Environment, Inline, PageMap SHARES PageMap =  BEGIN  OPEN ESCAlpha, Mopcodes;  << constants which should be in ESCAlpha >>  aBYTESWAP: ESCAlpha.alpha = 207B;  aLOCKMEM: ESCAlpha.alpha = 210B;  aNOTIFYIOP: ESCAlpha.alpha = 211B;  << copied TYPEs >>  Byte: TYPE = Environment.Byte;  PageCount: TYPE = Environment.PageCount;  PageNumber: TYPE = Environment.PageNumber;  << real memory page TYPEs (this implementation supports <= 2­16 real pages) >>  RealPageCount: TYPE = CARDINAL;  RealPageNumber: TYPE = CARDINAL;  << TYPEs corresponding to IOP STRUCs and RECORDs >>  AlternateOpieAddress: TYPE = MACHINE DEPENDENT RECORD [    low(0): ByteSwappedWord,    high(1): ByteSwappedWord];  Base: TYPE = LONG BASE POINTER;  ByteOffset: TYPE = [0..1];  ByteSwappedLinkPtr: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    nonNilPtr(0:0..0): BOOLEAN ¬ NULL,    pointer(0:1..14): Base RELATIVE POINTER[0..37777B] ¬ NULL,    pointerByte(0:15..15): ByteOffset ¬ 0];  ByteSwappedLong: TYPE = LONG UNSPECIFIED;  ByteSwappedPointer: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    pointer(0:0..14): Base RELATIVE POINTER[0..77777B] ¬ NULL,    pointerByte(0:15..15): ByteOffset ¬ 0];  ByteSwappedWord: TYPE = WORD;  ClientCondition: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    handlerID(0:0..7): HandlerID,    conditionRelMaskPtr(0:8..15): ConditionRelMaskPtr,    conditionPtr(1): ByteSwappedLinkPtr,    maskValue(2): WORD];  ConditionRelMaskPtr: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    maskWordOffset(0:0..6): [0..77B] ¬ NULL,    maskPtrByte(0:7..7): ByteOffset ¬ 0];  HandlerID: TYPE = PRIVATE MACHINE DEPENDENT {    private(0), first(1), mesaProcessor(16), last(127)};  InterruptContext: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    interruptStatus(0:0..7): Byte,    interruptHandlerID(0:8..15): HandlerID,    interruptTCBLinkPtr(1): ByteSwappedPointer,    interruptTimerValue(2): ByteSwappedWord,    watchdogLinkPtr(3): ByteSwappedPointer,    troubleIPCS(4): IPCS,    interruptMask(6:0..7): Byte,    interruptSlaveEOIcmd(6:8..15): Byte,    interruptController(7): ByteSwappedPointer];  InterruptContextBlock: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    interruptCode(0): PACKED ARRAY [0..icbCodeBytes) OF Byte,    interruptContext(icbCodeBytes/Environment.bytesPerWord): InterruptContext];  IOPBoolean: TYPE = MACHINE DEPENDENT {False(0), True(177777B)};  IOPShortBoolean: TYPE = MACHINE DEPENDENT {False(0), True(377B)};  IOPCondition: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    tcbLinkPtr(0): ByteSwappedLinkPtr ];  IORegionOffset: TYPE = CARDINAL;  IORTable: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    mesaHasLock(0): PACKED ARRAY [0..Environment.bitsPerWord) OF BOOLEAN,    iopRequestsLock(1): PACKED ARRAY [0..Environment.bitsPerWord) OF BOOLEAN,    segments(2): SEQUENCE COMPUTED HandlerID OF SegmentRec];  IPCS: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    ip(0): ByteSwappedWord,    cs(1): ByteSwappedWord];  MachineType: TYPE = MACHINE DEPENDENT {    altoI (1), altoII (2), altoIIXM (3), dolphin (4), dorado (5), dandelion (6),    dicentra (7), daybreak (8), daisy (9), (17B)};  MapRegister: TYPE = MACHINE DEPENDENT {    pcBase(0), ioRegion(8), mesaVM(9), communicationsReceive(10), communicationsSend(11), floppyDMA(12), optionsDMA(13), general(14), spare(15)};  MicrocodeVersion: TYPE = MACHINE DEPENDENT RECORD [    machineType(0:0..3): MachineType,    majorVersion(0:4..7): [0..17B],  -- incremented by incompatible changes    unused(0:8..13): [0..77B],    floatingPoint(0:14..14): BOOLEAN,    cedar(0:15..15): BOOLEAN,    releaseDate (1): CARDINAL];  -- days since January 1, 1901  NotifyMask: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    byteMask(0:0..7): Byte,    byteOffset(0:8..15): Byte];  OpieAddress: TYPE = MACHINE DEPENDENT RECORD [    A15toA0(0): ByteSwappedPointer,    A23toA16(1:0..7): Byte,    type(1:8..15): OpieAddressType];  OpieAddressType: PRIVATE TYPE = MACHINE DEPENDENT {    nil(0), extendedBus(20B), extendedBusPage(60B), iopLogical(120B), iopIORegionRelative(121B), pcLogical(220B), virtualWord(340B), virtualFirst64KRelative(341B), virtualPage(360B), (377B)};  QueueBlock: TYPE = MACHINE DEPENDENT RECORD [    queueHead(0): OpieAddress ¬ nilOpieAddress,    queueTail(2): OpieAddress ¬ nilOpieAddress,    queueNext(4): OpieAddress ¬ nilOpieAddress];  QueueEntry: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    queueType(0:0..7): Byte,    nextHandlerID(0:8..15): HandlerID,    nextTCBLinkPtr(1): ByteSwappedLinkPtr];  SegmentRec: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    ioRegionSegment(0): ByteSwappedWord,    stackSegment(1): ByteSwappedWord ];  SPSS: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    sp(0): ByteSwappedWord,    ss(1): ByteSwappedWord];  TaskContextBlock: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    taskQueue(0): QueueEntry,    taskCondition(2): ByteSwappedPointer,    taskICPtr(3): ByteSwappedPointer,    taskSP(4): ByteSwappedWord,    returnSPSS(5): SPSS,    prevState(7:0..3): TaskState,    presentState(7:4..7): TaskState,    taskHandlerID(7:8..15): HandlerID,    timerValue(8): ByteSwappedWord];  TaskState: PRIVATE TYPE = MACHINE DEPENDENT {unInitialized(0), jammed(2), waitForSystem(4), waitForTime(5), waitForCondition(6), waitForInterrupt(7), system(8), systemWaitingRestart(9), systemWaitingJam(10), interrupt(12), interruptWaitingRestart(13), interruptWaitingJam(14)};  << Other TYPEs >>  MemOperation: TYPE = MACHINE DEPENDENT {    add(0), and(1), or(2), xchg(3), overwriteIfNil(4)};  ReservedMemoryUse: TYPE = {notBusy, Raven, Display};  << Here we define a few useful constants. >>  icbCodeBytes: PRIVATE CARDINAL = 6;  mesaClientMaskPtr: PRIVATE ConditionRelMaskPtr = [maskWordOffset: SIZE[IOPCondition]];  nil: ByteSwappedLinkPtr = LOOPHOLE[0];  nilOpieAddress: OpieAddress = LOOPHOLE[LONG[0]];  segmentGranularity: LONG CARDINAL = 8;   -- words per segment unit  sizeInterruptContextBlock: CARDINAL = SIZE[InterruptContextBlock];  sizeTaskContextBlock: CARDINAL = SIZE[TaskContextBlock];  << PUBLIC variables (exported from ProcessorHeadDove) >>  IORegion: READONLY LONG POINTER TO IORTable;  mesaClientCondition: PRIVATE READONLY Base RELATIVE POINTER;  iorSegmentBase: PRIVATE CARDINAL;  firstReservedPage: READONLY RealPageNumber;      -- special display/raven memory  reservedPageCount: READONLY RealPageCount;     -- size of reserved memory  displayPageCount: READONLY RealPageCount;     -- size of display bitmap  firstMapPage: READONLY RealPageNumber;    -- real memory reserved for map  mapPagesCount: READONLY RealPageCount;      -- size of VM map  ioRegionPage: READONLY RealPageNumber;    -- real memory reserved for IORegion  ioRegionPageCount: READONLY RealPageCount;     -- size of IORegion reserved memory  firstRealPage: READONLY RealPageNumber;    -- lowest hardware-accessible page  lastRealPage:  READONLY RealPageNumber;    -- highest hardware-accessible page  numberRealPages: READONLY RealPageCount;    -- total of all real memory  numberVirtualPages: READONLY PageCount;    -- limit of supported VM (256 * mapPagesCount)  pcPresent: READONLY UNSPECIFIED;	-- PCE info from EEProm  << Head initialization of handler IORegion ptr (from IORegion table) >>  GetHandlerIORegionPtr: PROC [handlerID: HandlerID] RETURNS [LONG POINTER] = INLINE    {RETURN [IORegion + (segmentGranularity * (ByteSwap[IORegion[handlerID].ioRegionSegment] - iorSegmentBase))]};  << IOP Notification and memory locking procedures >>  GetIORegionOffset: PROC [pointer: LONG POINTER] RETURNS [offset: IORegionOffset] = INLINE    {offset ¬ IORegionOffset[pointer - IORegion]};  LockMem: PROC [operation: MemOperation, address: IORegionOffset, value: UNSPECIFIED, mask: WORD] RETURNS [result: UNSPECIFIED] = MACHINE CODE    {zESC, aLOCKMEM};  NotifyIOP: PROC [notifyMask: NotifyMask] = MACHINE CODE    {zESC, aNOTIFYIOP};  << Set up client condition (usually in IOCB constructed by a head) to access the Mesa up-notify task in IOP     Note: Mesa part of IORegion must contain condition and mask word >>  BuildMesaClientCondition: PROC [clientConditionPtr: LONG POINTER TO ClientCondition, mask: WORD] = INLINE    BEGIN    mesaClientConditionPtr: ByteSwappedLinkPtr = [nonNilPtr: TRUE, pointer: mesaClientCondition];    clientConditionPtr­ ¬ [handlerID: mesaProcessor, conditionRelMaskPtr: mesaClientMaskPtr, conditionPtr: ByteSwap[mesaClientConditionPtr], maskValue: mask]    END;  << Return real page number currently mapped to given virtual page.  Undefined if virtual page is not mapped.     This implementation limits processors to 2**16 pages of real memory. >>  GetRealPage: PROC [page: PageNumber] RETURNS [RealPageNumber] = INLINE    {RETURN[Inline.LowHalf[PageMap.GetState[page].real]]};  GetRealAddress: PROC [p: LONG POINTER] RETURNS [rp: LONG POINTER] = INLINE    BEGIN OPEN Environment;    RETURN [LongPointerFromPage[GetRealPage[PageFromLongPointer[p]]] +      (Inline.LowHalf[p] MOD wordsPerPage)];    -- this could take advantage of the fact that the add never carries    END;<< Get microcode version to check machine type or other options >>  GetMicrocodeVersion: PROC RETURNS [MicrocodeVersion] = MACHINE CODE    {zESC, aVERSION};<< Opie Addresses are PRIVATE TYPEs to Opie and should not be abused by Mesa code.  The Mesa world should limit its access to OpieAddresses through the PROCEDUREs provided by this interface.  In particular, no Mesa code above the level of the Heads should ever know about OpieAddresses.  And Heads should never access the fields within an OpieAddress directly.     The main purpose of providing OpieAddressToLongPointer and OpieAddressToPageNumber is actually two-fold.  The first is to allow the Heads to recover a handler modified Mesa OpieAddress to a Mesa address or page number.  The second is simply for reasons of symmetry. >>  LongPointerToOpieAddress: PROC [ptr: LONG POINTER] RETURNS [opieAddress: OpieAddress] = INLINE    BEGIN    opieAddress.A15toA0 ¬ ByteSwap[Inline.LowHalf[ptr]];    IF Inline.HighHalf[ptr] # Inline.HighHalf[Environment.first64K] THEN      BEGIN      opieAddress.A23toA16 ¬ Inline.HighHalf[ptr];      opieAddress.type ¬ virtualWord      END ELSE      BEGIN      opieAddress.A23toA16 ¬ 0;      opieAddress.type ¬ virtualFirst64KRelative      END;    END;  OpieAddressToLongPointer: PROC [opieAddress: OpieAddress] RETURNS [ptr: LONG POINTER] = INLINE    BEGIN    OPEN tempPtr: LOOPHOLE[ptr, Environment.Long];    SELECT opieAddress.type FROM      virtualWord => tempPtr.high ¬ opieAddress.A23toA16;      virtualFirst64KRelative => tempPtr.high ¬ Inline.HighHalf[Environment.first64K];      ENDCASE => RETURN[NIL];    tempPtr.low ¬ ByteSwap[opieAddress.A15toA0]    END;  OpieAddressToPageNumber: PROC [opieAddress: OpieAddress] RETURNS [page: PageNumber] = INLINE    {page ¬ (IF opieAddress.type = virtualPage      THEN LONG[ByteSwap[opieAddress.A15toA0]]      ELSE LAST[PageNumber])};  PageNumberToOpieAddress: PROC [page: PageNumber] RETURNS [opieAddress: OpieAddress] = INLINE    {opieAddress ¬ [A15toA0: ByteSwap[Inline.LowHalf[page]], A23toA16: 0, type: virtualPage]};<< Byte swapping is unfortunately necessary on the Dove processors because the PrincOps Mesa machine is a word machine and the Intel IOP which is used in the Dove processors is a byte/word machine and there is an inconsistency between I/O and non-I/O handling of bytes.   The PrincOps Mesa machine considers the LEFT byte in a word as the FIRST byte in the word and the RIGHT most byte as the second byte.  The Intel processors and I/O chips (eg. the Intel ethernet controller) treat the RIGHT most byte as the FIRST byte.  The solution to the IO byte swap problem: The mesa emulator to main-memory 16 bit data bus is "twisted" so that all transfers TO AND FROM main-memory swap bytes.   There are many situations in which the processors of each world treat the contents of a word as a single quantity (eg. word-sized-integers, addresses, portions of addresses).  In such use, BOTH the Mesa emulator AND the INTEL 186 consider the left most byte to be the numerically most-significant byte.   Unfortunately, the byte swapping hardware blindly reverses the bytes in such words as well as those destined for IO.  Thus, the integer 317 hex in either world becomes 1703 hex in the other world.     Fortunately, most word-quantities are of interest to one world or the other but not both.  Unfortunately, SOME word-quantities (particularly in IOCBs and FCBs) are of interest to BOTH worlds.   Therefore, byte-swapping procedures are provided through interface to allow the writers of the heads to correct the byte-swap inconsistency.  ByteSwap takes a value and swaps the bytes and returns that value.  LongByteSwap takes a thirty-two (32) bit quantity and treats it as two sixteen bit quantities and byte-swaps each quantity individually.  The LongByteSwap procedure causes 32-bit quantities in the Mesa world to look like the same 32-bit quantity in the IOP.  Note: the PrincOps Mesa machine stores a double word as two words with the least significant half stored first. >>  ByteSwap: PROC [value: UNSPECIFIED] RETURNS [UNSPECIFIED] = MACHINE CODE    {zESC, aBYTESWAP};  LongByteSwap: PROC [value: LONG UNSPECIFIED] RETURNS [LONG UNSPECIFIED] = MACHINE CODE    BEGIN    zESC, aBYTESWAP; zEXCH; zESC, aBYTESWAP; zEXCH;    END;  OldByteSwap: PROC [value: UNSPECIFIED] RETURNS [UNSPECIFIED] = MACHINE CODE    BEGIN    zLI8; zESC, aROTATE;    END;  OldLongByteSwap: PROC [value: LONG UNSPECIFIED] RETURNS [LONG UNSPECIFIED] = MACHINE CODE    BEGIN    zLI8; zESC, aROTATE; zEXCH; zLI8; zESC, aROTATE; zEXCH;    END; << Resolve contention for special memory >>  SetReservedMemoryUse: PROC [use: ReservedMemoryUse, pagesNeeded: PageCount ¬ 0];  END.LOG	DEG: 30-May-84 14:07:57	Created from DLionInputOutput.mesa of 30-Aug-83 11:21:49	DEG:  5-Jul-84 15:21:11	entered the STRUCture definitions from IOPDefs.asm of 14-Feb-84 11:13:22 and the I/O Region information from IORegion.asm of 17-Jun-84 14:45:02.	DEG:  1-Aug-84 22:13:59 add OpieAddress definition and BuildMesaClientCondition	JPM: 2-Aug-84 11:12:46 revise BuildMesaClientCondition, update for current IORegion.asm	DEG:  6-Aug-84 11:42:09 include the workmask area defined in IORegion.asm and revise to IORegion.asm of 25-Jul-84 15:04:30 PDT.	DEG: 14-Aug-84 12:13:45 include the pc Emulation FCBs (as comments until implemented in assembly code on IOP) and work area and move the Mesa/IOP communication area from outside of the Initial I/O Region to the beginning of the Initial I/O region following the Pad (padOffset, padLength).	DEG: 14-Aug-84 20:44:42 include definition for IOPCondition and IOPBoolean..	DEG: 17-Aug-84 14:43:49 correct definition of TaskContextBlock and TaskState.	DEG: 17-Aug-84 19:15:28 add definition of nilOpieAddress.	DEG: 27-Aug-84 14:24:17 Include definition of IOPBoolean and IOPShortBoolean and upgrade to reflect the state of IORegion.asm of 22-Aug-84, and IOPDefs.asm of 23-Aug-84.	DEG: 28-Aug-84 11:07:44 changed references to CONDITION to IOPCondition.	DEG: 31-Aug-84 17:55:30 Based upon OPIE 12.	DEG:  4-Sep-84 11:40:58 Fix for dealing with Opie Address conversion INLINEs.	DEG: 25-Sep-84 13:28:44 Based upon OPIE 13 plus add the TYPE definition for WordAsBytes and the INLINE PROCEDURE SwapBytes for the byte-swapping necessary.  Also, added TYPE definition for MicrocodeVersion and MachineType and added the PROCEDURE GetMicrocodeVersion so that the Heads can determine which processor and microcode on which they are running.	DEG: 25-Sep-84 22:15:56 Removed the SwapBytes and WordAsBytes stuff to replace them with the byte swapping solution as agreed upon by ETN and JPM.  Procedures added: ByteSwap, LongByteSwap	DEG: 28-Sep-84 11:45:59 Changed ByteSwap and LongByteSwap to OldByteSwap and OldLongByteSwap and defined new ByteSwap and new LongByteSwap procedures based upon the new alpha byte code aBYTESWAP.  Cleaned up ByteSwappedClientConditionPtr, ConditionPtr, mesaClientConditionPtr, mesaClientMaskPtr, and BuildMesaClientCondition per JPM's request.	DEG: 17-Oct-84  0:29:17 Upgrade to Opie 15..	DEG:  8-Nov-84 10:29:40 Make changes to Virtual and real memory description and support section and change the type Count to MaskCount.	DEG: 13-Nov-84 14:23:59 Add PROCEDURE for getting IORegion offsets.	DEG: 16-Nov-84 14:50:53 Add the variable numberRealPages and make a handful of others READONLY.	DEG: 30-Nov-84 15:08:33 Modify to be compatible with Opie 16.	DEG:  3-Dec-84 11:11:12 Add firstRealPage and lastRealPage.  Also define the type RealPageCount and removed some obsolete code.	DEG:  3-Dec-84 13:20:10 Add BootStrap stuff between WatchDog and Bindweed handler space..	DEG, KEK: 11-Mar-85 16:01:17 Modified for Opie 19.	JPM: 13-May-85 14:20:24 Modified for Opie redesign	JPM: 26-Jul-85 11:57:11 Bring up to date on Opie redesign (some types and constants changed)	JPM: 30-Jul-85 14:33:40 Add iorSegmentBase, fix bug in GetHandlerIORegionPtr	JPM: 13-Aug-85 10:57:11 Add pcPresent
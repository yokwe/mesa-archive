-- File: RESSupportImpl.mesa-- last edit: JPM 18-Nov-87 10:52:20-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Environment USING [Byte],  ESCAlphaExtras2 USING [aENCODE, aGETRUNS, aPREDICT, aRIPPLEXOR],  Frame USING [GetReturnFrame, ReadPC, WritePC],  Inline USING [BITAND, BITROTATE, BITSHIFT, BITXOR],  PrincOps USING [ESCTrapTable],  RESSupport USING [IMGStreamPtr, OffsetSize, ScanLinePtr, Status];RESSupportImpl: PROGRAM  IMPORTS Frame, Inline  EXPORTS RESSupport  SHARES RESSupport =  BEGIN  OPEN RESSupport, Inline;    --=======================  -- TYPES  --=======================  LocalStream: TYPE = RECORD [    handle:   LONG POINTER,    word:     WORD,    bitsUsed: INTEGER];  Nibble: TYPE = CARDINAL[0..15];    --=======================  -- Global Data and Private Procs  --=======================    stream, line: LocalStream;  offset: CARDINAL ¬ 0;    LoadLocalStream: PROCEDURE [ptr: IMGStreamPtr] =    BEGIN    stream.handle ¬ ptr.handle;    stream.word ¬ ptr.word;    stream.bitsUsed ¬ ptr.bitPos;    END;  StoreLocalStream: PROCEDURE [ptr: IMGStreamPtr] =    BEGIN    ptr.handle ¬ stream.handle;    ptr.word ¬ stream.word;    ptr.bitPos ¬ stream.bitsUsed;    END;  GetN: PROCEDURE RETURNS [val: Nibble] =    BEGIN     IF stream.bitsUsed >= 16 THEN  -- Fetch next word      {stream.word ¬ (stream.handle ¬ stream.handle + 1)­;       stream.bitsUsed ¬ 0};    val ¬ BITAND[(stream.word ¬ BITROTATE[stream.word, 4]), 0FH];    stream.bitsUsed ¬ stream.bitsUsed + 4;    END;  -- GetN    PutN: PROCEDURE [val: Nibble] =    BEGIN    stream.word ¬ BITROTATE[stream.word, 4] + val;    IF (stream.bitsUsed ¬ stream.bitsUsed + 4) >= 16 THEN  -- store this word      {stream.handle­ ¬ stream.word;       stream.handle ¬ stream.handle + 1;       stream.word ¬ 0;       stream.bitsUsed ¬ 0};    END;  -- PutN     Put2N: PROCEDURE [byte: WORD] = INLINE    BEGIN    PutN[BITSHIFT[byte, -4]];    PutN[BITAND[byte, 0FH]];    END;     Bump: PROCEDURE [nNibbles: CARDINAL] =    BEGIN    offset ¬ offset + nNibbles;    IF (line.bitsUsed ¬ line.bitsUsed + BITSHIFT[nNibbles, 2]) >= 16 THEN	{line.handle­ ¬ line.word;         line.handle ¬ line.handle + BITSHIFT[line.bitsUsed, -4];	 line.bitsUsed ¬ BITAND[line.bitsUsed, 0FH];         line.word ¬ 0};    END;    Store: PROCEDURE [nibble: Nibble] =    BEGIN    offset ¬ offset + 1;    line.word ¬ line.word + BITROTATE[nibble,      (SELECT (line.bitsUsed ¬ line.bitsUsed + 4) FROM        4 => 12, 8 => 8, 12 => 4, ENDCASE => 0)]    END;     --=======================  -- Decompression Support  --=======================  <<  SoftwareGetRuns decodes a single scan line of an image encoded with the  Xerox RES compression algorithm. See Xerox System Integration Standard  "Raster Encoding Standard" table 4.5 (June 1985 edition) for details.    At the first invocation of SoftwareGetRuns the position of source is expected to be  past the SOI byte. SoftwareGetRuns returns with the stream positioned at  the first nibble past the LCC for the next scan line, and returns the new LCC.    SoftwareGetRuns assumes that dest points to a scanLine that has been set to zero  prior to invocation.>>  SoftwareGetRuns: PUBLIC PROC [dest: ScanLinePtr, source: IMGStreamPtr, wpl: CARDINAL] 	               RETURNS [code: Environment.Byte, status: Status] =    BEGIN    temp: Nibble;    LoadLocalStream[source];    line ¬ [dest, 0, 0];    offset ¬ 0;    DO     -- get runs      SELECT (code ¬ GetN[]) FROM	>= 0CH => -- 12 bit codes	  {code ¬ BITROTATE[BITAND[code, 3], 4] + GetN[];	   IF (temp ¬ GetN[]) = 0	     THEN Bump[BITSHIFT[code, 6]]	     ELSE	       {IF code < 2 OR 		   (code < 26 AND (temp = 1 OR temp = 2 OR temp = 4 OR temp = 8))		  THEN GOTO illegal;		Bump[code];	        Store[temp]}};	>= 08H => -- 4 bit codes	  {Bump[0];	   Store[(SELECT BITAND[code, 3] FROM 0 => 8, 1 => 4, 2 => 2, ENDCASE => 1)]};		     	ENDCASE => -- 8 bit codes	  IF (code ¬ BITROTATE[code, 4] + GetN[]) < 68H	    THEN	      {IF code < 4 THEN GOTO normalExit;	       Bump[BITSHIFT[code, -2]];	       Store[(SELECT BITAND[code, 3] FROM 0 => 8, 1 => 4, 2 => 2, ENDCASE => 1)]}	    ELSE	      {IF (temp ¬ BITAND[BITSHIFT[code, -1], 0FH]) = 8 THEN		 IF BITAND[code, 1] = 0 THEN GOTO soiFound ELSE GOTO normalExit;	       Bump[BITAND[code, 1]];	       Store[(IF temp = 4 THEN 3 ELSE temp)]};    REPEAT      normalExit => status ¬ (IF offset > BITSHIFT[wpl, 2] THEN scanTooLong ELSE ok);      soiFound => status ¬ soiInData;      illegal => {code ¬ 0C0H + code; status ¬ illegalGin12bit};    ENDLOOP;    line.handle­ ¬ line.word;    StoreLocalStream[source];     END;    <<   SoftwareRippleXOR restores a line that has been xor'ed for a specific halftone cell size.>>  SoftwareRippleXOR: PUBLIC PROC [scanLine: ScanLinePtr, offset: OffsetSize, wpl: CARDINAL] =  BEGIN  carryover: WORD ¬ 0;  work: WORD;  THROUGH [0 .. wpl) DO    carryover ¬ work ¬ BITXOR[carryover, scanLine­];    DO      IF (carryover ¬ BITSHIFT[carryover, -offset]) = 0 THEN EXIT;      work ¬ BITXOR[work, carryover]    ENDLOOP;    scanLine­ ¬ work;    scanLine ¬ scanLine + 1;    carryover ¬ BITSHIFT[work, (16 - offset)]  ENDLOOP  END;    --==============    -- Compression    --==============    <<   SoftwarePredict computes the length of an encoded scan line.>>      SoftwarePredict: PUBLIC PROC [source: ScanLinePtr, wpl: CARDINAL]                        RETURNS [length: CARDINAL ¬ 0] =    BEGIN    nibble, run: CARDINAL ¬ 0;    sourceWord: WORD;    THROUGH [0..wpl) DO      IF (sourceWord ¬ source­) = 0        THEN run ¬ run + 4	ELSE THROUGH [0..4) DO          IF (nibble ¬ BITAND[(sourceWord ¬ BITROTATE[sourceWord, 4]), 0FH]) = 0	    THEN run ¬ run + 1            ELSE	      {IF run > 63 THEN 	         {run ¬ BITAND[run, 3FH];	          length ¬ length + 3};	       length ¬ length + (SELECT nibble FROM              		            1, 2, 4, 8 => SELECT run FROM                  	       		            0       => 1,                  		 	            < 26    => 2,              		     		            ENDCASE => 3,         		            ENDCASE    => IF run < 2 THEN 2 ELSE 3);	       run ¬ 0};	 ENDLOOP;      source ¬ source + 1    ENDLOOP;    END;    <<  SoftwareEncode compresses a single scan line of an image using the   Xerox RES compression algorithm. See Xerox System Integration Standard  "Raster Encoding Standard" table 4.5 (June 1985 edition) for details.>>      SoftwareEncode: PUBLIC PROC [source: ScanLinePtr, dest: IMGStreamPtr, wpl: CARDINAL] =    BEGIN    nibble, run: CARDINAL ¬ 0;    sourceWord: WORD;    LoadLocalStream[dest];    THROUGH [0..wpl) DO      IF (sourceWord ¬ source­) = 0        THEN run ¬ run + 4	ELSE THROUGH [0..4) DO          IF (nibble ¬ BITAND[(sourceWord ¬ BITROTATE[sourceWord, 4]), 0FH]) = 0	    THEN run ¬ run + 1            ELSE	      {IF run > 63 THEN 	         {Put2N[0C0H + BITSHIFT[run, -6]];	          PutN[0];	          run ¬ BITAND[run, 3FH]};	       SELECT nibble FROM                 1, 2, 4, 8 =>		   IF run < 26		     THEN		       {nibble ¬ SELECT nibble FROM 1 => 3, 2 => 2, 4 => 1, ENDCASE => 0; 		        IF run = 0			  THEN PutN[8 + nibble]                          ELSE Put2N[BITSHIFT[run, 2] + nibble]}              	     ELSE		       {Put2N[0C0H + run];			PutN[nibble]};	         ENDCASE =>	           IF run < 2		     THEN Put2N[60H + BITSHIFT[(IF nibble=3 THEN 4 ELSE nibble), 1] + run]              	     ELSE		       {Put2N[0C0H + run];		        PutN[nibble]};	       run ¬ 0};        ENDLOOP;      source ¬ source + 1    ENDLOOP;    StoreLocalStream[dest];    END;  -- PRIVATE PROCs (for trap table)    -- since these are called as trap instructions, we gotta    -- bump the pc.  Note that they all require minimal stack, which    -- means we don't have to bother dumping state.  GETRUNS: PROC [dest: ScanLinePtr, source: IMGStreamPtr, wpl: CARDINAL]        RETURNS [code: Environment.Byte, status: Status] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    [code, status] ¬ SoftwareGetRuns [dest, source, wpl]    END;  PREDICT: PROC [source: ScanLinePtr, wpl: CARDINAL]        RETURNS [length: CARDINAL] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    length ¬ SoftwarePredict [source, wpl]    END;  ENCODE: PROC [source: ScanLinePtr, dest: IMGStreamPtr, wpl: CARDINAL] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    SoftwareEncode [source, dest, wpl]    END;  RIPPLEXOR: PROC [scanLine: ScanLinePtr, offset: OffsetSize, wpl: CARDINAL] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    SoftwareRippleXOR [scanLine, offset, wpl]    END;  -- main code  PrincOps.ESCTrapTable[ESCAlphaExtras2.aGETRUNS] ¬ LOOPHOLE[GETRUNS];  PrincOps.ESCTrapTable[ESCAlphaExtras2.aPREDICT] ¬ LOOPHOLE[PREDICT];  PrincOps.ESCTrapTable[ESCAlphaExtras2.aENCODE] ¬ LOOPHOLE[ENCODE];  PrincOps.ESCTrapTable[ESCAlphaExtras2.aRIPPLEXOR] ¬ LOOPHOLE[RIPPLEXOR]  END. -- of RESSupportImplLOG18-Sep-87 -- JPM -- Created from Oahu3Impl.22-Sep-87 -- JPM -- Added SoftwareRippleXOR et al.18-Nov-87 -- JPM -- Take rotates out of LoadLocalStream and StoreLocalStream.
-- File: GrayBltImpl.mesa - last edit:-- JPM			 5-Sep-86 15:08:52-- Copyright (C) 1986 by Xerox Corporation. All rights reserved.DIRECTORY  BitBlt USING [BitAddress],  Environment USING [bitsPerWord, Byte, bytesPerWord],  ESCAlphaExtras USING [aGRAYBLT, aGRAYSUM, aGRAYTHRSHLD],  Frame USING [GetReturnFrame, ReadPC, WritePC],  GrayBlt USING [GBptr, Sumptr, Threshptr],  Inline USING [LowHalf],  PrincOps USING [ESCTrapTable];GrayBltImpl: PROGRAM  IMPORTS Frame, Inline  EXPORTS GrayBlt =  BEGIN  -- TYPEs  BitWord: TYPE = PACKED ARRAY [0 .. Environment.bitsPerWord) OF BOOLEAN;  ByteSeqAddress: TYPE = RECORD [    byte: ByteSeqPtr,    offset: NATURAL ];  ByteSeqPtr: TYPE = LONG POINTER TO RECORD [    PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte ];  -- INLINE PROCs  BumpBitAddress: PROC [ba: BitBlt.BitAddress, incr: CARDINAL] RETURNS [BitBlt.BitAddress] = INLINE    BEGIN    offset: LONG CARDINAL = ba.bit + incr;    RETURN [[(ba.word + offset / Environment.bitsPerWord), , (Inline.LowHalf[offset] MOD Environment.bitsPerWord)]]    END;  BumpByteAddress: PROC [bsa: ByteSeqAddress, incr: INTEGER] RETURNS [ByteSeqAddress] = INLINE    BEGIN    offset: LONG INTEGER = bsa.offset + incr;    RETURN [[(bsa.byte + offset / Environment.bytesPerWord), (Inline.LowHalf[offset] MOD Environment.bytesPerWord)]]    END;  -- PUBLIC PROCs  SoftwareGrayBlt: PUBLIC PROCEDURE [ptr: GrayBlt.GBptr] =    BEGIN    dst: ByteSeqAddress ¬ [ptr.dst.word, ptr.dst.byte];    src: ByteSeqAddress ¬ [ptr.src.word, ptr.src.byte];    GrayBltItem: PROC = INLINE      BEGIN      dstIndex, srcIndex: NATURAL;      incr: INTEGER;      IF ptr.flags.direction = forward THEN        BEGIN	dstIndex ¬ dst.offset;	srcIndex ¬ src.offset;	incr ¬ 1	END ELSE	BEGIN	dstIndex ¬ dst.offset + ptr.width - 1;	srcIndex ¬ src.offset + ptr.width - 1;	incr ¬ -1	END;      THROUGH [0 .. ptr.width) DO        dst.byte[dstIndex] ¬ GrayFunc [src.byte[srcIndex], dst.byte[dstIndex] ];	dstIndex ¬ dstIndex + incr;	srcIndex ¬ srcIndex + incr      ENDLOOP      END;    GrayFunc: PROC [srcByte, dstByte: Environment.Byte] RETURNS [Environment.Byte] = INLINE      BEGIN      srcByte ¬ SELECT ptr.flags.srcFunc FROM        null => srcByte,	invert => (Environment.Byte.LAST - srcByte),	trc => ptr.trc[srcByte],	ENDCASE => ERROR;      RETURN [SELECT ptr.flags.dstFunc FROM        set => srcByte,	add => MIN [(srcByte + dstByte), Environment.Byte.LAST],	subtract => MAX [INTEGER[dstByte - srcByte], Environment.Byte.FIRST],	average => (srcByte + dstByte) / 2,        ENDCASE => ERROR]      END;    THROUGH [0 .. ptr.height) DO      GrayBltItem [];      dst ¬ BumpByteAddress [dst, ptr.dstBpl];      src ¬ BumpByteAddress [src, ptr.srcBpl]    ENDLOOP    END;  SoftwareSum: PUBLIC PROCEDURE [ptr: GrayBlt.Sumptr] RETURNS [sum: LONG CARDINAL ¬ 0] =    BEGIN    src: ByteSeqAddress ¬ [ptr.src.word, ptr.src.byte];    SumItem: PROC = INLINE      BEGIN      srcIndex: NATURAL ¬ src.offset;      THROUGH [0 .. ptr.width) DO        sum ¬ sum + src.byte[srcIndex];	srcIndex ¬ srcIndex + 1      ENDLOOP      END;    THROUGH [0 .. ptr.height) DO      SumItem [];      src ¬ BumpByteAddress [src, ptr.srcBpl]    ENDLOOP    END;  SoftwareThreshold: PUBLIC PROCEDURE [ptr: GrayBlt.Threshptr] =    BEGIN    dst: BitBlt.BitAddress ¬ ptr.dst;    src: ByteSeqAddress ¬ [ptr.src.word, ptr.src.byte];    threshVal: NATURAL = ptr.srcCuttoffValue;    ThresholdItem: PROC = INLINE      BEGIN      dstPtr: LONG POINTER TO BitWord ¬ dst.word;      dstIndex: NATURAL ¬ dst.bit;      srcIndex: NATURAL ¬ src.offset;      hold: BitWord ¬ dstPtr­;      THROUGH [0 .. ptr.width) DO        IF dstIndex >= Environment.bitsPerWord THEN	  BEGIN	  dstPtr­ ¬ hold;	  hold ¬ (dstPtr ¬ dstPtr + 1)­;	  dstIndex ¬ 0	  END;	hold[dstIndex] ¬ (src.byte[srcIndex] > threshVal);	srcIndex ¬ srcIndex + 1;	dstIndex ¬ dstIndex + 1      ENDLOOP;      dstPtr­ ¬ hold      END;    THROUGH [0 .. ptr.height) DO      ThresholdItem [];      dst ¬ BumpBitAddress [dst, ptr.dstBpl];      src ¬ BumpByteAddress [src, ptr.srcBpl]    ENDLOOP    END;  -- PRIVATE PROCs (for trap table)    -- since these are called as trap instructions, we gotta    -- bump the pc.  Note that they are all minimal stack, which    -- means we don't have to bother dumping state.  GRAYBLT: PROC [ptr: GrayBlt.GBptr] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    SoftwareGrayBlt [ptr]    END;  GRAYSUM: PROC [ptr: GrayBlt.Sumptr] RETURNS [LONG CARDINAL] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    RETURN [SoftwareSum [ptr] ]    END;  GRAYTHRSHLD: PROC [ptr: GrayBlt.Threshptr] =    BEGIN    Frame.WritePC [      pc: [(Frame.ReadPC [Frame.GetReturnFrame [] ] + 2)],      lf: Frame.GetReturnFrame [] ];    SoftwareThreshold [ptr]    END;  -- main code  PrincOps.ESCTrapTable[ESCAlphaExtras.aGRAYBLT] ¬ LOOPHOLE[GRAYBLT];  PrincOps.ESCTrapTable[ESCAlphaExtras.aGRAYSUM] ¬ LOOPHOLE[GRAYSUM];  PrincOps.ESCTrapTable[ESCAlphaExtras.aGRAYTHRSHLD] ¬ LOOPHOLE[GRAYTHRSHLD]  END. -- of GrayBltImplLOG5-Sep-86 -- JPM -- Created.
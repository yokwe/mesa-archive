-- File: EthernetHeadDove.mesa - last edit:-- MxS                   8-Mar-89 14:16:29	  -- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.<<		The following program was created in 1984 but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.	>>DIRECTORY  DeviceCleanup USING [Await, Item],  DoveHandlerIDs USING [ethernet],  DoveInputOutput USING [BuildMesaClientCondition, ByteSwap, GetHandlerIORegionPtr, GetIORegionOffset, LockMem, LongPointerToOpieAddress, nilOpieAddress, NotifyIOP, OpieAddress, OpieAddressToLongPointer, QueueBlock],  Environment USING [first64K, wordsPerPage],  ESCAlphaExtras3 USING [aLOCKQUEUE],  EthernetHardFaceDove USING [CommandSelect, Status],  EthernetIOFaceDove USING [FunctionContextBlock, IOCB],  EthernetFace USING [GlobalStatePtr, Status],  EthernetSpecialFaceDove USING [],  HeadStartChain USING [Start],  HostNumbers USING [broadcastHostNumber, ProcessorID],  Inline USING [BITAND, LowHalf],  Mopcodes USING [zESC];EthernetHeadDove: PROGRAM  IMPORTS DeviceCleanup, DoveInputOutput, Inline,    RemainingStartChain: HeadStartChain  EXPORTS EthernetFace, EthernetSpecialFaceDove, HeadStartChain =  BEGIN  OPEN DoveIO: DoveInputOutput, EthernetHardFace: EthernetHardFaceDove,    EthernetIOFace: EthernetIOFaceDove;    ControlBlockRecord: PUBLIC TYPE = EthernetIOFace.IOCB;  DeviceHandle: PUBLIC TYPE = RECORD [CARDINAL];    IOCB: TYPE = LONG POINTER TO EthernetIOFace.IOCB;    controlBlockSize: PUBLIC CARDINAL _ SIZE[EthernetIOFace.IOCB];  globalStateSize: PUBLIC CARDINAL _ SIZE[EthernetIOFace.IOCB];  hearSelf: PUBLIC BOOLEAN _ FALSE;  nullDeviceHandle: PUBLIC DeviceHandle _ [123456B];    cleanupInitialized: BOOLEAN _ FALSE;  disableBroadcastReception: BOOLEAN ¬ FALSE;  fcb: LONG POINTER TO EthernetIOFace.FunctionContextBlock =    DoveIO.GetHandlerIORegionPtr[DoveHandlerIDs.ethernet];  gState: RECORD [inInterrupt, outInterrupt: WORD];  self: DeviceHandle = [0];    --TRYING OUT NEW UCODE FOR LARGER BUFFERS--	tbdCountGV: NATURAL ¬ 4;	rfdCountGV: NATURAL ¬ 12;	rbdCountGV: NATURAL ¬ 16;	rbLengthGV: NATURAL ¬ 760;    --TRYING OUT NEW UCODE FOR LARGER BUFFERS--  --***--  Incorrectype: ERROR = CODE;    AddCleanup: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    item: DeviceCleanup.Item;    -- There is no way to remove a cleanup procedure yet, so we have a flag    -- to avoid duplicates.    IF cleanupInitialized THEN RETURN;    cleanupInitialized _ TRUE;    DO      SELECT DeviceCleanup.Await[@item] FROM        kill => MakeSureOff[];	turnOff => MakeSureOff[];	turnOn => {          -- Note that this does NOT really put things back together.  It simply smashes things to a safe state.  The intention is that the driver will notice that nothing is happening and then call TurnOff+TurnOn to reset things.  That allows Pilot to reset the GMT clock on the way back from the debugger without getting tangled up with the normal Ethernet driver.	  MakeSureOff[];	  fcb.mesaInQueue _ [];	  fcb.mesaOutQueue _ [];	  gState.inInterrupt _ 0;	  gState.outInterrupt _ 0;	  -- I included the following statement because the Dandelion version does a similar thing.  However, I do not understand why it is necessary since EthernetFace.TurnOn is going to be called soon afterwards?  It may even be harmful since the i82586 is still programmed with the old parameters.	  fcb.mesaClientStateRequest _ on;	  };	ENDCASE;      ENDLOOP;    END;    GetNextDevice: PUBLIC PROCEDURE [device: DeviceHandle] RETURNS [DeviceHandle] =    BEGIN    -- IF ReadEEProm[ethernetPresent]=FALSE THEN RETURN[nullDeviceHandle];    RETURN[IF device=nullDeviceHandle THEN self ELSE nullDeviceHandle];    END;    GetPacketLength: PUBLIC PROCEDURE [cb: IOCB] RETURNS [CARDINAL] =    BEGIN    RETURN[WITH iocb: cb SELECT FROM input => (iocb.count+1)/2, ENDCASE => 0];    END; --round up the number of words, in case of odd-length packet    GetPacketsMissed: PUBLIC PROCEDURE [device: DeviceHandle] RETURNS [CARDINAL] =    BEGIN    RETURN[IF device#self THEN 0 ELSE DoveIO.ByteSwap[fcb.scb.rscErrs]];    END;    GetRetries: PUBLIC PROCEDURE [cb: IOCB] RETURNS [CARDINAL] =    BEGIN    RETURN[      LOOPHOLE[cb.i586Status, EthernetHardFace.Status.command.transmit].collisions      ];    END;    GetStatus: PUBLIC PROCEDURE [cb: IOCB] RETURNS [status: EthernetFace.Status] =    BEGIN    IF NOT cb.status.done THEN RETURN[<<IF cb.status.handled THEN>> pending <<ELSE queued>>];    IF NOT cb.status.isDequeued THEN {      DeQueue[        queuePtr: IF cb.type=input THEN @fcb.mesaInQueue ELSE @fcb.mesaOutQueue,        cb: cb];      ByteSwapIOCB[cb];      cb.status.isDequeued ¬ TRUE;      };    WITH iocb: cb SELECT FROM      input => {        OPEN inStatus: LOOPHOLE[	  iocb.i586Status, EthernetHardFace.Status.receiveFrame];	status _ SELECT TRUE FROM	  cb.status.okay =>	    IF Inline.BITAND[iocb.count, 1] # 0 THEN ok<<dippled>> ELSE ok,	  inStatus.ovrnErr => overrun,	  inStatus.crcErr =>	    IF inStatus.alnErr THEN crcAndBadAlignment ELSE crc,	  inStatus.alnErr => badAlignmentButOkCrc,	  cb.status.frameTooLong => packetTooLong,	  ENDCASE => otherError;	IF status = ok THEN {	  count: CARDINAL _ (iocb.length/2)-1;	  p: LONG POINTER = DoveIO.OpieAddressToLongPointer[iocb.address];	  DO	    (p + count)^ _ (p + count)^;	    IF count < Environment.wordsPerPage THEN {p^ _ p^; EXIT};	    count _ count - Environment.wordsPerPage;	    ENDLOOP;	  };	};      output => {        OPEN outStatus: LOOPHOLE[	  iocb.i586Status, EthernetHardFace.Status.command.transmit];	status _ SELECT TRUE FROM	  cb.status.okay => ok,	  cb.status.frameTooLong => packetTooLong,	  cb.status.interruptTimeout => pending,	  outStatus.underrun => underrun,	  outStatus.tooManyCollisions => tooManyCollisions,	  ENDCASE => otherError;	};      command => {        OPEN cmdStatus: LOOPHOLE[iocb.i586Status, EthernetHardFace.Status.command];	status _ IF cb.status.okay THEN ok	ELSE WITH cmdStatus SELECT iocb.action FROM	  ENDCASE => otherError;	};      reset, startRU => status ¬ IF cb.status.okay THEN ok ELSE otherError;      ENDCASE => ERROR;    END;    Initiate: PUBLIC PROCEDURE [device: DeviceHandle, cb: IOCB] =    BEGIN    IF device#self THEN RETURN;    cb.next ¬ DoveIO.nilOpieAddress;    cb.status ¬ [done: FALSE, handled: FALSE];    DoveIO.BuildMesaClientCondition[      clientConditionPtr: @cb.clientCondition, mask: gState.outInterrupt];    ByteSwapIOCB[cb];    EnQueue[queuePtr: @fcb.mesaOutQueue, cb: cb];    DoveIO.NotifyIOP[fcb.etherOutWorkMask];    END;    QueueInput: PUBLIC PROCEDURE [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: IOCB] =    BEGIN    IF device#self THEN RETURN;    cb^ _ [      next: DoveIO.nilOpieAddress,      clientCondition: NULL,      status: [done: FALSE, handled: FALSE],      op: input[        address: DoveIO.LongPointerToOpieAddress[buffer], length: length*2]      ];    DoveIO.BuildMesaClientCondition[      clientConditionPtr: @cb.clientCondition, mask: gState.inInterrupt];    ByteSwapIOCB[cb];    EnQueue[queuePtr: @fcb.mesaInQueue, cb: cb];    DoveIO.NotifyIOP[fcb.etherInWorkMask];    END;    QueueOutput: PUBLIC PROCEDURE [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: IOCB] =    BEGIN    count: CARDINAL _ length - 1;    p: LONG POINTER = buffer;    pages: CARDINAL ¬ 0;    IF device#self THEN RETURN;    DO      foo: UNSPECIFIED _ (p + count)^;      pages ¬ pages+1;      IF count < Environment.wordsPerPage THEN {foo _ p^; pages ¬ pages+1; EXIT};      count _ count - Environment.wordsPerPage;      ENDLOOP;<<  IF pages > fcb.nonMesaContext.tbdCount THEN {      };>>    cb^ _ [      next: DoveIO.nilOpieAddress,      clientCondition: NULL,      status: [done: FALSE, handled: FALSE],      op: output[        address: DoveIO.LongPointerToOpieAddress[buffer], length: length*2]      ];    DoveIO.BuildMesaClientCondition[      clientConditionPtr: @cb.clientCondition, mask: gState.outInterrupt];    ByteSwapIOCB[cb];    EnQueue[queuePtr: @fcb.mesaOutQueue, cb: cb];    DoveIO.NotifyIOP[fcb.etherOutWorkMask];    END;    RemoveCleanup: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    END;    Start: PUBLIC PROCEDURE =    BEGIN    RemainingStartChain.Start[];    END;    TurnOff: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    IF device#self THEN RETURN;    MakeSureOff[];    END;    TurnOn: PUBLIC PROCEDURE [device: DeviceHandle, host: HostNumbers.ProcessorID, inInterrupt, outInterrupt: WORD, globalState: EthernetFace.GlobalStatePtr] =    BEGIN    DoOutput: PROCEDURE RETURNS [ok: BOOLEAN] =      BEGIN      i: CARDINAL;      Initiate[device: device, cb: cb];      FOR i ¬ 0, i+1 UNTIL cb.status.done DO ENDLOOP;      DeQueue[queuePtr: @fcb.mesaOutQueue, cb: cb];      RETURN[cb.status.okay];      END;    cb: IOCB = @Environment.first64K[globalState];    IF device#self THEN RETURN;    MakeSureOff[];    fcb.mesaInQueue _ [];    fcb.mesaOutQueue _ [];    gState.outInterrupt ¬ 0;    fcb.mesaClientStateRequest _ on;    cb.op ¬ reset[];    --TRYING OUT NEW UCODE FOR LARGER BUFFERS--	fcb.nonMesaContext.tbdCount ¬ tbdCountGV;	fcb.nonMesaContext.rfdCount ¬ rfdCountGV;	fcb.nonMesaContext.rbdCount ¬ rbdCountGV;	fcb.nonMesaContext.rbLength ¬ DoveIO.ByteSwap[rbLengthGV];    --TRYING OUT NEW UCODE FOR LARGER BUFFERS--    IF ~DoOutput[] THEN RETURN;    cb.op ¬ command[      action: configure,      select: [configure[        byteCount: 9,	fifoLimit: 11,	saveBadFrames: TRUE,	addrTypeLoc: buffer,	broadcastDisable: disableBroadcastReception,	promiscuousMode: (host=HostNumbers.broadcastHostNumber)	]]      ];    IF ~DoOutput[] THEN RETURN;    IF host#HostNumbers.broadcastHostNumber THEN {      cb.op ¬ command[action: individualAddr, select: [individualAddr[id: host]]];      IF ~DoOutput[] THEN RETURN};    cb.op ¬ startRU[];    IF ~DoOutput[] THEN RETURN;    gState _ [inInterrupt: inInterrupt, outInterrupt: outInterrupt];    END;    ByteSwapIOCB: PROCEDURE [cb: IOCB] =    BEGIN    ByteSwapIndirect: PROCEDURE [p: LONG POINTER TO UNSPECIFIED] = {      p­ ¬ DoveIO.ByteSwap[p­]};    cb.i586Status ¬ DoveIO.ByteSwap[cb.i586Status];    WITH iocb: cb SELECT FROM      input, output => {        iocb.length ¬ DoveIO.ByteSwap[iocb.length];	iocb.count ¬ DoveIO.ByteSwap[iocb.count];	};      command =>        WITH sel: iocb.select SELECT iocb.action FROM	  nop, individualAddr, configure, dumpStatus, diagnose => NULL;	  multicastAddr => ByteSwapIndirect[@sel+0<<unused,byteCount>>];	--transmit => Error[notSupported];	  timeDomainRfl => ByteSwapIndirect[@sel.results];          ENDCASE => ERROR;      reset, startRU => NULL;      ENDCASE => ERROR;    END;    DeQueue: PROCEDURE [queuePtr: LONG POINTER TO DoveIO.QueueBlock, cb: IOCB] =    BEGIN    cbOA: DoveIO.OpieAddress = DoveIO.LongPointerToOpieAddress[cb];    IF queuePtr.queueHead=cbOA THEN {      queuePtr.queueHead _ cb.next;      IF queuePtr.queueTail=cbOA THEN queuePtr.queueTail ¬ DoveIO.nilOpieAddress;      }    ELSE {      FOR chase: IOCB ¬ DoveIO.OpieAddressToLongPointer[queuePtr.queueHead],      DoveIO.OpieAddressToLongPointer[chase.next] WHILE chase#NIL DO	IF chase.next=cbOA THEN {	  chase.next _ cb.next;	  IF queuePtr.queueTail=cbOA THEN	    queuePtr.queueTail _ DoveIO.LongPointerToOpieAddress[chase];	  EXIT};	ENDLOOP;      };    END;    EnQueue: PROCEDURE [queuePtr: LONG POINTER TO DoveIO.QueueBlock, cb: IOCB] =    BEGIN    cbOA: DoveIO.OpieAddress = DoveIO.LongPointerToOpieAddress[cb];     --***-- IF queuePtr = @fcb.mesaInQueue THEN {	    LockQueue [@fcb.iopEtherInQueSemaphore];	      IF queuePtr.queueHead=DoveIO.nilOpieAddress THEN queuePtr.queueHead ¬ cbOA    ELSE LOOPHOLE[      DoveIO.OpieAddressToLongPointer[queuePtr.queueTail],IOCB].next ¬ cbOA;    [] ¬ DoveIO.LockMem[      operation: overwriteIfNil,      address: DoveIO.GetIORegionOffset[@queuePtr.queueNext],      value: Inline.LowHalf[LOOPHOLE[cbOA]], --ToDo: UGLY--      mask: fcb.etherLockMask];    queuePtr.queueTail ¬ cbOA;    [] ¬ DoveIO.LockMem[operation: xchg, address: DoveIO.GetIORegionOffset[@fcb.mesaEtherInQueSemaphore], value: 0, mask: fcb.etherLockMask];}     --***-- ELSE  	{     LockQueue [@fcb.iopEtherOutQueSemaphore];    IF queuePtr.queueHead=DoveIO.nilOpieAddress THEN queuePtr.queueHead ¬ cbOA    ELSE LOOPHOLE[      DoveIO.OpieAddressToLongPointer[queuePtr.queueTail],IOCB].next ¬ cbOA;    [] ¬ DoveIO.LockMem[      operation: overwriteIfNil,      address: DoveIO.GetIORegionOffset[@queuePtr.queueNext],      value: Inline.LowHalf[LOOPHOLE[cbOA]], --ToDo: UGLY--      mask: fcb.etherLockMask];    queuePtr.queueTail ¬ cbOA;    [] ¬ DoveIO.LockMem[operation: and, address: DoveIO.GetIORegionOffset[@fcb.mesaEtherOutQueSemaphore], value: 0, mask: fcb.etherLockMask];}; 	       END;    MakeSureOff: PROCEDURE = INLINE    BEGIN    fcb.mesaClientStateRequest _ off;    DoveIO.NotifyIOP[fcb.etherInWorkMask];    DoveIO.NotifyIOP[fcb.etherOutWorkMask];    UNTIL --fcb.mesaInClientState=off AND-- fcb.mesaOutClientState=off DO ENDLOOP;    END;          --***--  LockQueue: PROCEDURE [pointer: LONG POINTER] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlphaExtras3.aLOCKQUEUE END;    END.LOG 6-Aug-84 17:10:26	BKI   	Creation 3-Apr-85 18:09:20	BKI   	GetPacketLength returns 0 on non-input iocbs.29-Jul-85 10:53:15	JPM	Opie redesign conversion.11-Aug-85 18:51:39	BKI	Remove unused local variables, cbOA....				Reset and reprogram chip in TurnOn.15-Aug-85  8:24:13	JPM	Comment out new TurnOn code till driver supports it.19-Aug-85 19:52:43	BKI	Include TurnOn code. Fix bugs (GetStatus; SELECT iocb.type; DeQueue iocb in TurnOn). 9-Sep-85 11:52:33	BKI	Fix GetRetries. Add copyright notice. 9-Sep-85 14:49:45	BKI	Disable reception of broadcasts.16-Oct-85 10:51:30	RRP	Re-Enable reception of broadcasts for 12.0k.27-May-86 14:29:40	RRP	changed GetPacketLength for odd length packets18-Feb-87 18:58:44	AOF	Tweaking things for large packets  8-Mar-89 14:16:36	MxS	added queue lock mechanism for Duke 
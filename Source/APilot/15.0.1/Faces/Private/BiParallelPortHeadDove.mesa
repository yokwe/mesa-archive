-- BiParallelPortHeadDove.mesa-- Head to service BiParallelPortOption(PPO) board AND Laser Printing Option(LPO) board-- Created by JMA on  5-Aug-86 14:32:52 from the original LPO version		-- Last edited: MxS  8-Jun-89 15:51:21 <<	Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.		The following program was created in 1985 but has not been published within the	 meaning of the copyright law, is furnished under license, and may not be used,	 copied and/or disclosed except in accordance with the terms of said license.>>DIRECTORY   DeviceCleanup USING [Await, Item, Reason],   DoveHandlerIDsExtrasExtras USING [ppo],   DoveInputOutput USING [BuildMesaClientCondition, Byte, ByteSwap, ByteSwappedWord,   	 ClientCondition, GetHandlerIORegionPtr, GetIORegionOffset, IOPShortBoolean,	 LockMem, LongPointerToOpieAddress, nilOpieAddress, NotifyIOP, OpieAddress,	 OpieAddressToLongPointer, QueueBlock ],   Environment USING [Base,  bytesPerPage, first64K],   Inline USING [BITAND, BITNOT, HighHalf, LowHalf],   BiParallelPortFace USING [CommandStatus, CompletedTransferStatus, DeviceStatus,   	OperationPtr, HardwareStatus, InitializationStatus, nullPortNumber, Parameters,	 Port, PortType, Transfer, TransferMode, TransferStatus],   BiParallelPortFaceExtras USING [StatusByte],   BiParallelPortIOFaceDove USING [BoardStatusRec, CommandRegrRec, ConfigRegrRec,   	CommandListRec, DeviceContextBlock, DMACntrlWrdBlockOut, DMACntrlWrdByteOut,	DMACntrlWrdByteIn, <<DMACntrlWrdBlockIn,>> DMACntrlWrdByteInNoIntrp,	FunctionContextBlock, HandlerStatusRec, IOContextBlock, LPOPROMError,	PortStatusRec, PPOPROMError, TransferStatus ],   ProcessorFaceExtras USING [MachineType, MachineTypeInfo],   ProcessorFaceExtras2 USING [DoveMachineType, DoveMachineTypeInfo],   Runtime USING [IsBound],   SpecialSpace USING [MakeGlobalFrameResident, MakeProcedureResident, SpecialError],   Zone USING [Alignment];    BiParallelPortHeadDove: PROGRAM   IMPORTS  DeviceCleanup, DoveInputOutput, Inline, ProcessorFaceExtras,  ProcessorFaceExtras2, Runtime, SpecialSpace   EXPORTS  BiParallelPortFace, BiParallelPortFaceExtras  =     BEGIN OPEN Dio: DoveInputOutput,		-- DIO stands for DoveInputOutput  	     Bpface: BiParallelPortFace,	-- BPFACE stands for BiParallelPortFace	     Bpio: BiParallelPortIOFaceDove;	-- BPIO stands for  BiParallelPortIOFaceDove     -- Constants  nilOpieAddress: Dio.OpieAddress = Dio.nilOpieAddress;  nilQueBlock: Dio.QueueBlock = [];  nilFCB: LONG POINTER = LOOPHOLE [8A000H];    -- TYPES  HeadDCB: TYPE = MACHINE DEPENDENT RECORD [	-- head local DCB info  	serviceRequested: BOOLEAN ¬ FALSE,	transferRequested: BOOLEAN ¬ FALSE,	-- NOT USED	deviceResetRequested: BOOLEAN ¬ FALSE,	portResetRequested: BOOLEAN ¬ FALSE,	updateRequested: BOOLEAN ¬ FALSE,	diagRequested: BOOLEAN ¬ FALSE,	deviceResetCompleted: BOOLEAN ¬ FALSE,	portResetCompleted: BOOLEAN ¬ FALSE,	statusUpdated: BOOLEAN ¬ FALSE,	diagCompleted: BOOLEAN ¬ FALSE,	unusedBit0: BOOLEAN ¬ FALSE,	unusedBit1: BOOLEAN ¬ FALSE,	unusedBits: [0..0FH] ¬ 0,		params: Bpface.Parameters ¬ [],	cnfgRegrVal: Bpio.ConfigRegrRec ¬ [],	pendingCommands: Bpio.CommandListRec ¬ [],	portStatus: Bpio.PortStatusRec,	numOfIOCBsEnqueued: CARDINAL ¬ 0	];	  HeadDCBPtr: TYPE = LONG POINTER TO HeadDCB;  FCB: TYPE = LONG POINTER TO Bpio.FunctionContextBlock;  DCB: TYPE = LONG POINTER TO Bpio.DeviceContextBlock;  IOCB: TYPE = LONG POINTER TO Bpio.IOContextBlock;      -- PUBLIC variables  operationSize: PUBLIC CARDINAL ¬ SIZE [Bpio.IOContextBlock];  -- WORD aligned, from the first 64K of virtual  operationAlignment: PUBLIC Zone.Alignment ¬ a1;  operationLocation: PUBLIC Environment.Base ¬ Environment.first64K;  -- Port 0 and Port 1  numberOfPorts: PUBLIC CARDINAL ¬ 2;  maxBlockSizeInBytes: PUBLIC CARDINAL ¬ Environment.bytesPerPage;    -- Global variables   p0DCB,  p1DCB: HeadDCB;  hDCBPtr: HeadDCBPtr ¬ NIL;	    ppoFCB: FCB ¬ NIL;  ppoDCB: LONG POINTER TO Bpio.DeviceContextBlock ¬ NIL;  iocb: IOCB ¬ NIL;    handlerLoaded: BOOLEAN ¬ FALSE;  optionIsPPO: BOOLEAN ¬ TRUE;  promError: WORD;  resetDevice: BOOLEAN ¬ FALSE;  eepromInfo: WORD;  localBoardStatus: Bpio.BoardStatusRec;  handlerStat: Bpio.HandlerStatusRec;  headInitialized: BOOLEAN ¬ FALSE;    -- for debug  qDbug: Dio.QueueBlock ¬ [];    -- saved on InitializeCleanup  savedPPOfcb: FCB;  savedClientCondition: Dio.ClientCondition;  savedDCB0: Bpio.DeviceContextBlock;  savedDCB1: Bpio.DeviceContextBlock;  p0Remain, p1Remain: CARDINAL ¬ 0;  << For Dahlia >>  savedPort0dcbSpareByte0: DoveInputOutput.Byte;  savedPort0dcbSpareByte1: DoveInputOutput.Byte;  savedPPoSpareWord: DoveInputOutput.ByteSwappedWord;  hardWareType: ProcessorFaceExtras.MachineType;  dovehardWareType: ProcessorFaceExtras2.DoveMachineType;    Initialize: PUBLIC PROC [notify: WORD]    RETURNS [initStatus: Bpface.InitializationStatus] =    BEGIN    ppoClientConditionPtr: LONG POINTER TO Dio.ClientCondition ¬ NIL;         -- before ANYTHING else, check if handler is loaded and started    IF NOT handlerLoaded THEN    	RETURN [optionSoftwareNotStarted];        -- ALSO, check if the board is installed, IF WE CAN    IF NOT ppoFCB.ppoHandlerStatus.boardInstalled THEN    	RETURN [optionHardwareNotDetected];	    -- handler error detected at handler init time?    IF handlerStat.handlerError THEN RETURN [other];    	    -- Set up Client Condition    ppoClientConditionPtr ¬ @ppoFCB.ppoClientCondition;    Dio.BuildMesaClientCondition [ppoClientConditionPtr, notify];    headInitialized ¬ TRUE;        LocalInit [];    RETURN [success];        END;  -- Initialize         << This command may be issued at ANY time >>  InitiatePortReset: PUBLIC PROC [port: Bpface.Port]    RETURNS [commandStatus: Bpface.CommandStatus] =    BEGIN        IF NOT SetDCBPtrs [port] THEN RETURN [invalidParameter];    LocalReset [hDCBPtr, ppoDCB];   		-- calling an INLINE Proc    IF (hDCBPtr.numOfIOCBsEnqueued > 0) THEN {    	AbortQueue [@ppoDCB.transferQue];	-- calling an INLINE Proc	hDCBPtr.numOfIOCBsEnqueued ¬ 0 };    ppoDCB.transferQue ¬ nilQueBlock;        -- down notify.    Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];        hDCBPtr.serviceRequested ¬ TRUE;    hDCBPtr.deviceResetRequested ¬ resetDevice;    resetDevice ¬ FALSE;	-- clear this flag, LocalReset Proc has seen it     RETURN [inProgress]    END;  -- InitiatePortReset  << This command may be issued at ANY time >>  InitiateDeviceReset: PUBLIC PROC [port: Bpface.Port]    RETURNS [commandStatus: Bpface.CommandStatus] =    BEGIN        -- Device reset is HW supported only on PPO HW    IF NOT optionIsPPO THEN RETURN [invalidParameter];        resetDevice ¬ TRUE;    RETURN [ InitiatePortReset [port]]    END;  -- InitiateDeviceReset  GetNextAvailablePort: PUBLIC PROC [portType: Bpface.PortType]    RETURNS [nextPort: Bpface.Port] =    BEGIN        IF optionIsPPO THEN	{	-- three types possible       SELECT portType FROM    	   outputOnly => nextPort ¬ (SELECT FALSE FROM				    	 p0DCB.params.portInUse => 0,				    	 p1DCB.params.portInUse => 1,				     	 ENDCASE => Bpface.nullPortNumber);				     	   inputOnly,			     	   bidirectional => IF p1DCB.params.portInUse			   	THEN nextPort ¬ Bpface.nullPortNumber				ELSE nextPort ¬ 1;			    	   ENDCASE => nextPort ¬ Bpface.nullPortNumber 	   }	-- inputOnly and unknown type	       ELSE { 	 -- LP Option installed, only one type possible    	IF portType # outputOnly THEN nextPort ¬ Bpface.nullPortNumber	ELSE nextPort ¬ 0 };	    RETURN [nextPort]    END;  -- GetNextPortNumber			  GetHardwareStatusBits: PUBLIC PROC [port: Bpface.Port]    RETURNS [commandStatus: Bpface.CommandStatus,    	     hardwareStatus: Bpface.HardwareStatus] =    BEGIN        -- check if this port is valid    -- return command status    commandStatus ¬ ready;        IF NOT SetDCBPtrs [port] THEN RETURN [invalidParameter, hardwareStatus];		    -- update local copy from the IORegion	    localBoardStatus ¬ ppoFCB.ppoBoardStatus;    hDCBPtr.portStatus ¬ ppoDCB.portStatus;		    hardwareStatus.port ¬ port;    hardwareStatus.boardMode ¬ hDCBPtr.params.portType;        -- return raw status in INTEL format    hardwareStatus.boardStatus ¬ Dio.ByteSwap [LOOPHOLE [localBoardStatus, WORD]];    hardwareStatus.portStatus ¬ Dio.ByteSwap [LOOPHOLE [hDCBPtr.portStatus, WORD]];         RETURN [commandStatus, hardwareStatus]    END;  -- GetHardwareStatusBits        GetStatus: PUBLIC PROC [port: Bpface.Port]    RETURNS [commandStatus: Bpface.CommandStatus,     		deviceStatus: Bpface.DeviceStatus ] =    BEGIN    newPortStatus: Bpio.PortStatusRec;    commandList: Bpio.CommandListRec;        IF NOT SetDCBPtrs [port] THEN RETURN [invalidParameter, deviceStatus];    deviceStatus.port ¬ port;    deviceStatus.portType ¬ hDCBPtr.params.portType;        commandList ¬ ppoDCB.commandList;    hDCBPtr.pendingCommands ¬ commandList;        newPortStatus ¬ ppoDCB.portStatus;    hDCBPtr.portStatus ¬ newPortStatus;        deviceStatus.fault ¬ newPortStatus.prntrFault;	-- scnr, has same bit position    deviceStatus.busy ¬ newPortStatus.prntrBusy;	-- scnr, has same bit position        SELECT deviceStatus.portType FROM	unknown,	outputOnly => { deviceStatus.select ¬ newPortStatus.select;  			deviceStatus.printerEmpty ¬ newPortStatus.printerEmpty;			-- not supported by HW & 4045			deviceStatus.deviceConnection ¬ unknown };				inputOnly  => {};		bidirectional => BEGIN 			  deviceStatus.endOfInputStream ¬ NOT newPortStatus.notScanLineSyncBuf;			  deviceStatus.attention ¬ NOT newPortStatus.attention;			  IF newPortStatus.scnrNotConnected			    THEN deviceStatus.deviceConnection ¬ disconnected			    ELSE {				  IF newPortStatus.scnrOn				     THEN deviceStatus.deviceConnection ¬ connectedAndOn				     ELSE deviceStatus.deviceConnection ¬ connectedButOff }			 END;	ENDCASE;        -- check for LPO/PPO PROM Error condition		      deviceStatus.portError ¬       (Inline.BITAND [Dio.ByteSwap [ppoFCB.ppoBoardStatus], promError] = promError);           << check if the option board CANNOT communicate with the device, probably because    a wrong handshaking protocol setting was used: useAck/useBusy, pulseWidth setting, etc. >>    deviceStatus.portException ¬ NOT newPortStatus.portReady;    IF hDCBPtr.updateRequested THEN       hDCBPtr.statusUpdated ¬ NOT (hDCBPtr.updateRequested ¬ commandList.updateStatusCmd);	    IF hDCBPtr.portResetRequested THEN         hDCBPtr.portResetCompleted ¬ NOT (hDCBPtr.portResetRequested ¬ commandList.resetCmd);           IF hDCBPtr.deviceResetRequested THEN  hDCBPtr.deviceResetCompleted ¬    			NOT (hDCBPtr.deviceResetRequested ¬ commandList.resetCmd);					     IF hDCBPtr.diagRequested THEN hDCBPtr.diagCompleted ¬    			NOT (hDCBPtr.diagRequested ¬ commandList.diagnosticCmd);        hDCBPtr.serviceRequested ¬ (hDCBPtr.updateRequested OR hDCBPtr.portResetRequested OR    				(hDCBPtr.numOfIOCBsEnqueued > 0) OR hDCBPtr.diagRequested );         deviceStatus.testResultIsUpToDate ¬ hDCBPtr.diagCompleted;			    deviceStatus.statusIsUpToDate ¬ hDCBPtr.statusUpdated;    deviceStatus.portWasReset ¬ hDCBPtr.portResetCompleted;    deviceStatus.deviceWasReset ¬ hDCBPtr.deviceResetCompleted;	    RETURN [ready, deviceStatus];    END;  -- GetStatus  InitiateTransfer: PUBLIC PROC [transfer: Bpface.Transfer]    RETURNS [commandStatus: Bpface.CommandStatus ] =    BEGIN    lockCmdList: WORD = 0010H;    unlockCmdList: WORD = Inline.BITNOT [lockCmdList];    commandList: Bpio.CommandListRec ¬ [];        << ** FOR DEBUG ONLY ** >>    <<Buffer: TYPE = PACKED ARRAY [0..512) OF Environment.Byte;    BufferPtr: TYPE = LONG POINTER TO Buffer;    outBuff,    inBuff: BufferPtr ¬ NIL;        -- FOR DEBUG, examine outBuff to check for data to be transferred    outBuff ¬ LOOPHOLE [transfer.operation.dataBufferPtr, BufferPtr]; >>    SELECT TRUE FROM      -- set DCB pointers      NOT SetDCBPtrs [transfer.port]				=> RETURN [invalidParameter];            -- check if this port or portType is set up for this type of transfer      --    should NOT be able to use Port1 if LPO board, etc.      (NOT optionIsPPO) AND (transfer.transferMode = get)	=> RETURN [invalidParameter];      -- check status first, can't transfer if Reset or Diagnostic commands pending      (ppoDCB.commandList.resetCmd OR ppoDCB.commandList.diagnosticCmd)      								=> RETURN [busy];      -- load iocb data structure      ENDCASE							=> SetForTransfer [transfer];                             -- don't even bother processing a 0 byte request    IF transfer.operation.bufferByteLength = 0 THEN {      iocb.currentOpStatus ¬ success;      RETURN [inProgress] };          -- lock command list, no locking    ppoDCB.commandList.locked ¬ TRUE;        -- inform handler it's a transfer process    commandList.transferCmd ¬ TRUE;    commandList.commandPending ¬ True;	--   this flag is cleared by the handler        -- enqueue the new IOCB    iocb.currentOpStatus ¬ pending;	-- set iocb operational status    EnqueueIOCB [@ppoDCB.transferQue, iocb];        [hDCBPtr.pendingCommands] ¬ Dio.LockMem[ -- lock out handler when command is being loaded       operation: or,       address: Dio.GetIORegionOffset[@ppoDCB.commandList],       value: commandList,       mask:  ppoFCB.ppoLockMask];           -- allow handler change access, set locked ¬ FALSE    ppoDCB.commandList.locked ¬ FALSE;        -- pass an i186 ptr to the DCB requesting service       ppoFCB.ppoDCBPtr ¬ ppoDCB.dcbLocation;        hDCBPtr.serviceRequested ¬ TRUE;        -- Perform a Down notify        Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];        -- Returns a status of command in progress    RETURN [inProgress]    END;  -- InitiateTransfer  PollTransferStatus: PUBLIC PROC [port: Bpface.Port, operation: Bpface.OperationPtr]    RETURNS [transferStatus: Bpface.TransferStatus, bytesTransferred: CARDINAL ] =    BEGIN    commandList: Bpio.CommandListRec ¬ [];        iocb ¬ LOOPHOLE [operation, IOCB];    SELECT TRUE FROM       iocb = NIL 		=> RETURN [incomplete, 0];       NOT SetDCBPtrs [port] 	=> RETURN [aborted, 0];              ppoDCB.transferQue.queueNext = Dio.LongPointerToOpieAddress [iocb]       		=> BEGIN		   IF ppoDCB.commandList.transferCmd		      -- handler is working on it		      THEN RETURN [inProgress, Dio.ByteSwap [iocb.bytesTransferred]]					      -- BAD NEWS! Handler is stalled; re-load the commandList		      -- workaround for AR 12298		      ELSE { IF iocb.currentOpStatus = pending THEN		      	       { commandList: Bpio.CommandListRec ¬ [];			       			         -- like in the InitiateTransfer Proc			         ppoDCB.commandList.locked ¬ TRUE;			         commandList.transferCmd ¬ TRUE;				 commandList.commandPending ¬ True;   				 [hDCBPtr.pendingCommands] ¬ Dio.LockMem [operation: or,       					address: Dio.GetIORegionOffset[@ppoDCB.commandList],       					value: commandList,       					mask:  ppoFCB.ppoLockMask];   				 ppoDCB.commandList.locked ¬ FALSE;   				 ppoFCB.ppoDCBPtr ¬ ppoDCB.dcbLocation;    				 hDCBPtr.serviceRequested ¬ TRUE;   				 -- Perform a Down notify   				 Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];				 RETURN [pending, 0];				} -- IF...			     };  -- ELSE...		     END;  			       ENDCASE			=> {};			        transferStatus ¬ (SELECT iocb.currentOpStatus FROM     				success 	=> success,				endOfScanLine	=> endOfInputStream,				inProgress	=> inProgress,				pending		=> pending,				aborted		=> aborted,				incomplete 	=> incomplete,				ENDCASE 	=> incomplete);   	        bytesTransferred ¬ Dio.ByteSwap [iocb.bytesTransferred];        IF (transferStatus IN Bpface.CompletedTransferStatus) THEN       DequeueIOCB [@ppoDCB.transferQue, iocb];                 RETURN [transferStatus, bytesTransferred]    END; -- PollTransferStatus    InitiateTest: PUBLIC PROC [port: Bpface.Port, diagnosticTestPattern: WORD]    RETURNS [commandStatus: Bpface.CommandStatus] =    BEGIN    commandList: Bpio.CommandListRec ¬ [];    configRegrImage: Bpio.ConfigRegrRec ¬ [];    commandRegrImage: Bpio.CommandRegrRec ¬ [];    -- load ppoFCB.ppoConfigRegrVal with following values:    --	1)period ¬ 8    --	2)useAck ¬  FALSE    --	3)maintMode ¬ TRUE    --	4)dmaRequest ¬ FALSE    --  5)scan ¬ FALSE    --	6)scanner port ¬ FALSE    -- ** Use Default All Values **    -- load ppoFCB.ppoCmdRegrVal with the following values:    --	1)reset ¬ FALSE    --	2)clearIntr ¬ FALSE    --	3)enforce20uSecRule ¬ TRUE    --	4)ppo Go ¬ TRUE        IF NOT SetDCBPtrs [port] THEN RETURN [invalidParameter];        -- check to make sure no cmds are pending before doing anything else    IF ppoDCB.commandList.commandPending = True THEN RETURN [busy];        configRegrImage ¬ hDCBPtr.cnfgRegrVal;        configRegrImage.maintMode ¬ TRUE;    configRegrImage.ppoDMAEnable ¬ FALSE;    ppoDCB.cnfgRegrVal ¬ configRegrImage;    ppoDCB.cmdRegrVal ¬ commandRegrImage;    ppoFCB.ppoDiagTestPattern ¬ Dio.ByteSwap [diagnosticTestPattern];        -- inform handler its a diagnostics process    ppoDCB.commandList.diagnosticCmd ¬ TRUE;    ppoDCB.commandList.commandPending ¬ True;	-- lock out another diag  or a transfer command    						--  this flag is cleared by the handler    [hDCBPtr.pendingCommands] ¬ Dio.LockMem[    -- lock out handler when command is being loaded       operation: or,       address: Dio.GetIORegionOffset[@ppoDCB.commandList],       value: commandList,       mask:  ppoFCB.ppoLockMask];           -- pass an i186 ptr to the DCB requesting service       ppoFCB.ppoDCBPtr ¬ ppoDCB.dcbLocation;    hDCBPtr.diagRequested ¬ TRUE;    hDCBPtr.diagCompleted ¬  FALSE;    hDCBPtr.serviceRequested ¬ TRUE;    Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];    RETURN [inProgress]    END; -- InitiateTest       GetTestResult: PUBLIC PROC    RETURNS [returnPattern: WORD] =    BEGIN    -- get result from IORegion    returnPattern ¬ Dio.ByteSwap [ppoFCB.ppoDiagReturnPattern];    RETURN [returnPattern];    END;          SetParameters: PUBLIC PROC [parameters: Bpface.Parameters] =    BEGIN    IF NOT SetDCBPtrs [parameters.port] THEN RETURN;        hDCBPtr.params ¬ parameters;    -- return if just indicating "OFF" condition    IF NOT hDCBPtr.params.portInUse THEN RETURN;        hDCBPtr.cnfgRegrVal ¬ [useAck: (parameters.transferProtocol = useAck),    				usePort1: (parameters.port = 1),				doScan: (parameters.portType = bidirectional) ];				    hDCBPtr.cnfgRegrVal.clockCounter ¬ ( SELECT parameters.pulseWidth FROM    			pw250ns		=> 0EH,			pw500ns		=> 0CH,			pw625nSec	=> 0BH,			pw750ns		=> 0AH,    			pw1uSec 	=> 08H,    			pw1250ns 	=> 06H,			pw1500ns	=> 04H,			pw1750ns	=> 02H,			pw2uSec		=> 00H,			ENDCASE		=> 08H );			    END;  -- SetParameters          TestIfBiParallelPortExists: PUBLIC PROC [port: Bpface.Port]    RETURNS [commandStatus: Bpface.CommandStatus] =    BEGIN     RETURN [unimplemented]      END; -- TestIfBiParallelPortExists      BiParallelPortExists:  PUBLIC PROC [port: Bpface.Port]     RETURNS [BOOLEAN] =      BEGIN     RETURN [TRUE]     END; -- BiParallelPortExists             << This command may be issued at ANY time >>  UpdateStatus:  PUBLIC PROC [port: Bpface.Port]    RETURNS [commandStatus: Bpface.CommandStatus] =    BEGIN    commandList: Bpio.CommandListRec ¬ [];        IF NOT SetDCBPtrs [port] THEN RETURN [invalidParameter];        IF ppoDCB.commandList.resetCmd THEN RETURN [busy];	    ppoDCB.cnfgRegrVal ¬ hDCBPtr.cnfgRegrVal;	-- load default value    commandList.updateStatusCmd ¬ TRUE;    [hDCBPtr.pendingCommands] ¬ Dio.LockMem[		       operation: or,       address: Dio.GetIORegionOffset[@ppoDCB.commandList],       value: commandList,       mask:  ppoFCB.ppoLockMask];           -- pass an i186 ptr to the DCB requesting service       ppoFCB.ppoDCBPtr ¬ ppoDCB.dcbLocation;        -- down notify.    Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];    hDCBPtr.updateRequested ¬ TRUE;    hDCBPtr.statusUpdated ¬ FALSE;    RETURN [inProgress]    END; -- UpdateStatus  << PRIVATE PROCEDURES >>  -- FOR DEBUG ONLY CopyQBlock: PROC [] =   BEGIN   qDbug ¬ ppoDCB.transferQue;   p0Remain ¬ p0DCB.numOfIOCBsEnqueued;   p1Remain ¬ p1DCB.numOfIOCBsEnqueued;      END;  -- CopyQBlock          << 	Queue Head and Tail ptrs are READ-ONLY to the handler >>  DequeueIOCB: PROC [quePtr: LONG POINTER TO Dio.QueueBlock, exIOCB: IOCB] =    BEGIN    oneLess: BOOLEAN ¬ FALSE;    headPtr: IOCB ¬ LOOPHOLE [Dio.OpieAddressToLongPointer [quePtr.queueHead]];    xIOCB: Dio.OpieAddress ¬  LOOPHOLE [Dio.LongPointerToOpieAddress [exIOCB]];    leadPtr, trailPtr: IOCB ¬ NIL;         IF  headPtr = NIL THEN RETURN [];      IF headPtr = exIOCB THEN  {	    quePtr.queueHead ¬ exIOCB.nextIOCB;	-- point to the new head	    IF quePtr.queueTail = xIOCB THEN    -- if tail then iocbNext is NIL	       quePtr.queueTail ¬ nilOpieAddress;	       oneLess ¬ TRUE }	    	         ELSE BEGIN  -- search for the IOCB to be removed      	  leadPtr ¬ trailPtr ¬ headPtr;	  UNTIL leadPtr = NIL	    DO	    IF leadPtr = exIOCB THEN {	         trailPtr.nextIOCB ¬ leadPtr.nextIOCB;		 IF xIOCB = quePtr.queueTail THEN		     quePtr.queueTail ¬ Dio.LongPointerToOpieAddress[trailPtr];		 oneLess ¬ TRUE;		 EXIT }		 	     ELSE {  -- advance pointers	        trailPtr ¬ leadPtr;	        leadPtr ¬ Dio.OpieAddressToLongPointer[leadPtr.nextIOCB] };	     ENDLOOP; 	   END;          IF oneLess THEN        hDCBPtr.numOfIOCBsEnqueued ¬ hDCBPtr.numOfIOCBsEnqueued - 1;	-- break remaining ties to the transfer queue            -- exIOCB.nextIOCB ¬ nilOpieAddress;     END; -- DequeueIOCB	        << 	Queue Head and Tail ptrs are READ-ONLY to the handler  >>  EnqueueIOCB: PROC [quePtr: LONG POINTER TO Dio.QueueBlock, newIOCB: IOCB] =    BEGIN    lastIOCB: IOCB ¬ NIL;    opieNewIOCB: Dio.OpieAddress ¬    		 Dio.LongPointerToOpieAddress [newIOCB];        -- set nextIOCB ptr of the last IOCB to nil    newIOCB.nextIOCB ¬ nilOpieAddress;        -- check if this is will be the first IOCB on the queue    IF quePtr.queueHead = nilOpieAddress    	THEN 	quePtr.queueHead ¬ opieNewIOCB			ELSE {  -- start by converting the tail ptr to a MESA ptr		-- ...and add ONLY from the tail end		lastIOCB ¬ Dio.OpieAddressToLongPointer [quePtr.queueTail];	       		lastIOCB.nextIOCB ¬ opieNewIOCB };		    [] ¬ Dio.LockMem[       		operation: xchg,       		address: Dio.GetIORegionOffset[@quePtr.queueNext]+1,       		value: Inline.HighHalf[LOOPHOLE[opieNewIOCB]],       		mask:  0];    [] ¬ Dio.LockMem [       		operation: overwriteIfNil,       		address: Dio.GetIORegionOffset[@quePtr.queueNext],       		value: Inline.LowHalf[LOOPHOLE[opieNewIOCB]],        		mask: ppoFCB.ppoLockMask];	         -- point to the new last IOCB         quePtr.queueTail ¬ opieNewIOCB;        -- keep track of the number of IOCBs in the queue    hDCBPtr.numOfIOCBsEnqueued ¬ hDCBPtr.numOfIOCBsEnqueued + 1;        END; -- EnqueueIOCB		      LocalInit: PROC  =     BEGIN    cmdList: Bpio.CommandListRec ¬ [];        -- set defaults    ppoFCB.port0DCB.commandList ¬ ppoFCB.port1DCB.commandList ¬ cmdList;    ppoFCB.port0DCB.transferQue ¬ ppoFCB.port1DCB.transferQue ¬ nilQueBlock;    p0DCB.portStatus ¬ ppoFCB.port0DCB.portStatus;     p1DCB.portStatus ¬ ppoFCB.port1DCB.portStatus;        END;  -- LocalInit      LocalReset: PROC [mDCB: HeadDCBPtr, iDCB: DCB] = INLINE    BEGIN    commandRegrImage: Bpio.CommandRegrRec ¬ [];    commandList: Bpio.CommandListRec ¬ [];        commandList.resetCmd ¬ TRUE;    commandList.commandPending ¬ True;        -- program config regr to be used by the handler    iDCB.cnfgRegrVal ¬ mDCB.cnfgRegrVal;        -- reset the option board... and maybe the device attached too    commandRegrImage.ppoNotReset ¬ FALSE;    commandRegrImage.deviceReset ¬ resetDevice;		-- this is active high    commandRegrImage.ppoNotClearIntrp ¬ commandRegrImage.ppoGo ¬ FALSE;    iDCB.cmdRegrVal ¬ commandRegrImage;            [mDCB.pendingCommands] ¬ Dio.LockMem[       operation: or,       address: Dio.GetIORegionOffset[@iDCB.commandList],       value: commandList,       mask:  ppoFCB.ppoLockMask];         --  pass an i186 ptr to the DCB requesting service    ppoFCB.ppoDCBPtr ¬ iDCB.dcbLocation;        mDCB.portResetRequested ¬ TRUE;    mDCB.portResetCompleted ¬ FALSE;           END;	-- LocalReset Inline Proc          << Local INLINE Proc to set iocb status to ABORT.     This is tricky, since this proc will be writing in a pieces of memory that the     handler has write-access to.  Worst case shouldn't be too serious--I think. >>  AbortQueue: PROC [ptr: LONG POINTER TO Dio.QueueBlock] = INLINE     BEGIN     tempPtr: IOCB ¬ Dio.OpieAddressToLongPointer [ptr.queueHead];     --temp1: IOCB ¬ Dio.OpieAddressToLongPointer [ptr.queueHead];     --temp2: IOCB ¬ NIL;          -- set all non-SUCCESS iocb status in the queue to ABORTED     WHILE tempPtr # NIL     DO       -- could use a Read-Modify-Write capability or locking mechanism here       IF (tempPtr.currentOpStatus # success) AND (tempPtr.currentOpStatus # endOfScanLine) AND       	  (tempPtr.currentOpStatus # aborted)       THEN {	  -- added the line below for debug	  LOOPHOLE [tempPtr.specialTransfer, Bpio.TransferStatus] ¬ tempPtr.currentOpStatus;       	  tempPtr.currentOpStatus ¬ aborted };	         tempPtr ¬ Dio.OpieAddressToLongPointer [tempPtr.nextIOCB];     ENDLOOP;     <<     -- dissolve the queue     WHILE temp1 # NIL DO       temp2 ¬ Dio.OpieAddressToLongPointer [temp1.nextIOCB];       temp1.nextIOCB ¬ nilOpieAddress;       temp1 ¬ temp2;     ENDLOOP;     >>          END;  -- AbortQueue               -- proc set up the IOCB and be made ready for enqueueing   SetForTransfer: PROC [transfer: Bpface.Transfer] =    BEGIN    DMA1CntrlWrd: Dio.ByteSwappedWord;    transferCount: Dio.ByteSwappedWord;         -- set IOCB ptr    iocb ¬ LOOPHOLE [transfer.operation, IOCB];        IF transfer.transferMode = get THEN      BEGIN  -- GET Process      DMA1CntrlWrdValForByteInputNoIntrp: WORD = Bpio.DMACntrlWrdByteInNoIntrp;      DMA1CntrlWrdValForByteInput: WORD = Bpio.DMACntrlWrdByteIn;            IF transfer.controlOrData = control THEN {    	 DMA1CntrlWrd ¬ DMA1CntrlWrdValForByteInputNoIntrp;	 transferCount ¬ 1 }	-- control/status bytes are transferred 1 byte at a time	       ELSE {  -- special step required to transfer Data: 1) N-1 DMA transfer 2) 1 byte transfer    	  DMA1CntrlWrd ¬ DMA1CntrlWrdValForByteInput;	  transferCount ¬ transfer.operation.bufferByteLength - 1 };        -- total number of bytes to be transferred        iocb.transferDataSize ¬ Dio.ByteSwap [transfer.operation.bufferByteLength];      END  -- GET Process        ELSE -- PUT Process      BEGIN             DMA1CntrlWrdValForWordOutput: WORD = Bpio.DMACntrlWrdBlockOut;      DMA1CntrlWrdValForByteOutput: WORD = Bpio.DMACntrlWrdByteOut;             -- check for odd byte transfer       IF (transfer.operation.bufferByteLength MOD 2) # 0 THEN {	-- odd byte transfer        -- if odd byte detected then used BYTE DMA transfer, no big perf hit        DMA1CntrlWrd ¬ DMA1CntrlWrdValForByteOutput;        transferCount ¬ transfer.operation.bufferByteLength }             ELSE { 							-- even byte transfer    	  -- if even byte transfer then used WORD DMA transfer, big win here.    	  DMA1CntrlWrd ¬ DMA1CntrlWrdValForWordOutput;	  transferCount ¬ transfer.operation.bufferByteLength / 2 };             iocb.transferDataSize ¬ Dio.ByteSwap [transferCount];     END;  -- PUT Process          -- load control word, transfer count, and DMA1 source pointer into IOCB      iocb.dma1CntrlWrdVal ¬ Dio.ByteSwap [DMA1CntrlWrd];    iocb.dma1TransferCount ¬ Dio.ByteSwap [transferCount];    iocb.dma1MemSrcOrDst ¬ Dio.LongPointerToOpieAddress [transfer.operation.dataBufferPtr];		     -- init some IOCB locations	    iocb.bytesTransferred ¬ 0;    iocb.iocbSpareByte0 ¬ 077H;    iocb.iocbSpareByte1 ¬ 077H;    iocb.specialTransfer ¬ False;         -- set option regr values in the IOCB    SetCnfgAndCmdRegrs [transfer];        END;  -- SetForTransfer      -- set configuration and command regrs values for transfer   SetCnfgAndCmdRegrs: PROC [transfer:Bpface.Transfer] =    BEGIN    configRegrImage: Bpio.ConfigRegrRec ¬ hDCBPtr.cnfgRegrVal;    commandRegrImage: Bpio.CommandRegrRec ¬ [];            -- ** defaulted values are: **    --	maintMode ¬ FALSE    --  enableIntrp ¬ TRUE    --	dmaRequest ¬ TRUE    --  all others are client selectable        configRegrImage.dataIsControl ¬ (transfer.controlOrData = control);    configRegrImage.directionIsIn ¬ (transfer.transferMode = get);    configRegrImage.byteMode ¬ (transfer.transferMode = get);			          -- ** defaulted values are: **    --  deviceNotReset ¬ TRUE    --	ppoGo ¬ TRUE    --	enforce20uSecRule ¬ FALSE	 used by LPO, but always set to FALSE     --	ppoNotClearIntrp ¬ TRUE    --	ppoNotReset ¬ TRUE        -- no need to byte swap since IOFace has the bits Intel format already    iocb.iocbCnfgRegrVal ¬ ppoDCB.cnfgRegrVal ¬ configRegrImage;    iocb.iocbCmdRegrVal ¬ ppoDCB.cmdRegrVal  ¬ commandRegrImage;    END;  -- SetCnfgAndCmdRegrs    << Sets global variable ptrs ppoDCB and hDCBPtr >>  SetDCBPtrs: PROC [port: Bpface.Port] RETURNS [BOOLEAN] = INLINE    BEGIN    IF (NOT optionIsPPO) AND (port = 1) THEN RETURN [FALSE];    IF port = 1    THEN {	ppoDCB ¬ @ppoFCB.port1DCB;	hDCBPtr ¬ @p1DCB  }    ELSE {				-- and for port = nullPortNumber too	ppoDCB ¬ @ppoFCB.port0DCB;	hDCBPtr ¬ @p0DCB };    RETURN [TRUE]    END;  -- SetDCBPtrs INLINE PROC          SavePort0Image: PROCEDURE = INLINE    BEGIN    savedDCB0 ¬ ppoFCB.port0DCB; -- status BEFORE reset and swap    p0Remain ¬ p0DCB.numOfIOCBsEnqueued;		          -- must clean up by performing reset and abort all non-SUCCESS iocbs    LocalReset [@p0DCB, @ppoFCB.port0DCB];    -- Perform a Down notify    Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];    THROUGH [0..LAST[CARDINAL]] DO ENDLOOP;	-- give it a little time		        IF (p0DCB.numOfIOCBsEnqueued > 0) THEN {       AbortQueue [@ppoFCB.port0DCB.transferQue];       p0DCB.numOfIOCBsEnqueued ¬ 0;       ppoFCB.port0DCB.transferQue ¬ nilQueBlock };       p0DCB.serviceRequested ¬ FALSE;    END;  -- SavePort0Image       SavePort1Image: PROCEDURE = INLINE    BEGIN    savedDCB1 ¬ ppoFCB.port1DCB; -- status BEFORE reset and swap    p1Remain ¬ p1DCB.numOfIOCBsEnqueued;		          -- must clean up by performing reset and abort all non-SUCCESS iocbs    LocalReset [@p1DCB, @ppoFCB.port1DCB];    -- Perform a Down notify    Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask];    THROUGH [0..LAST[CARDINAL]] DO ENDLOOP;	-- give it a little time		        IF (p1DCB.numOfIOCBsEnqueued > 0) THEN {      AbortQueue [@ppoFCB.port1DCB.transferQue];      p1DCB.numOfIOCBsEnqueued ¬ 0;      ppoFCB.port1DCB.transferQue ¬ nilQueBlock };      p1DCB.serviceRequested ¬ FALSE    END;  -- SavePort1Image          InlineInit: PROCEDURE = INLINE    BEGIN    -- init important variables    handlerLoaded ¬ FALSE;    handlerStat.handlerInitialized ¬ FALSE;    handlerStat.boardInstalled ¬ FALSE;    handlerStat.usingBiParallelPortOption ¬ FALSE;    ppoFCB ¬ Dio.GetHandlerIORegionPtr[DoveHandlerIDsExtrasExtras.ppo];    -- avoid WRITE PROTECT FAULT, check if GetHandlerIORegionPtr PROC returned a valid pointer    -- If the pointer is valid, then check if Opie recognized BiParallel Printing Option    IF (ppoFCB # NIL) OR (ppoFCB # nilFCB) THEN {  	handlerStat ¬ ppoFCB.ppoHandlerStatus;	-- remember the initial handler stat	handlerLoaded ¬ ppoFCB.ppoHandlerStatus.handlerInitialized;	-- remember which option we're interfacing with        optionIsPPO ¬ ppoFCB.ppoHandlerStatus.usingBiParallelPortOption;	promError ¬ (IF optionIsPPO THEN Bpio.PPOPROMError    		        ELSE Bpio.LPOPROMError);	eepromInfo ¬ ppoFCB.ppoEEPROMInfo };	    END; -- InlineInit     InitializeCleanup: PUBLIC PROCEDURE =    BEGIN    item: DeviceCleanup.Item;    reason: DeviceCleanup.Reason;        DO      reason ¬ DeviceCleanup.Await[@item];      IF handlerLoaded AND headInitialized THEN      {  SELECT reason FROM 	   turnOff, kill =>	        BEGIN	    	IF ppoFCB.ppoHandlerStatus.handlerBusy THEN	          -- give the handler a little time to finish what it's doing	   	  THROUGH [0..LAST[CARDINAL]] WHILE ppoFCB.ppoHandlerStatus.handlerBusy DO	          ENDLOOP;		 		 <<  Update, Reset, and Diagnostic commands should have had time to finish since		 all three commands do not wait at the handler level, except for Transfer command .. >>		-- Transfer may still going but can't wait any longer, commence controller quiesce		-- board status reflects status BEFORE the reset		localBoardStatus ¬ ppoFCB.ppoBoardStatus;		resetDevice ¬ FALSE;		-- cleanup port 0		IF p0DCB.params.portInUse THEN SavePort0Image[];		-- cleanup port 1    		IF p1DCB.params.portInUse THEN SavePort1Image[];		    		--save Opie stuff		savedClientCondition ¬ ppoFCB.ppoClientCondition;		savedPPOfcb ¬ ppoFCB;				--save XP11 stuff		savedPort0dcbSpareByte0 ¬ ppoFCB.port0DCB.dcbSpareByte0;		savedPort0dcbSpareByte1 ¬ ppoFCB.port0DCB.dcbSpareByte1;		savedPPoSpareWord ¬ ppoFCB.ppoSpareWord;		   		--The Head's global variables are saved by Pilot	        END;  -- turnOff, kill			    turnOn =>	        BEGIN		-- Init again just in case something changed while we were off		InlineInit[];		IF handlerLoaded THEN		  { ppoFCB.ppoClientCondition ¬ savedClientCondition;		    -- update all port and board status		    ppoFCB.port0DCB.commandList.updateStatusCmd ¬ TRUE;		    IF optionIsPPO THEN  { 		-- update port 1 too		       ppoFCB.port1DCB.cnfgRegrVal.usePort1 ¬ TRUE;		       ppoFCB.port1DCB.commandList.updateStatusCmd ¬ TRUE };    		    ppoFCB.ppoDCBPtr ¬ ppoFCB.port0DCB.dcbLocation;		    		    ppoFCB.port0DCB.dcbSpareByte0 ¬ savedPort0dcbSpareByte0;		    ppoFCB.port0DCB.dcbSpareByte1 ¬ savedPort0dcbSpareByte1;		    ppoFCB.ppoSpareWord ¬ savedPPoSpareWord;		    		    Dio.NotifyIOP [ppoFCB.ppoWorkFromClientMask]		   };		-- Head should be ready for the next set of commands		END;			    disconnect => NULL;		-- TurnOff was already called	    ENDCASE;       }; -- handlerLoad AND headInitialized           ENDLOOP;    END;	-- InitializeCleanup      <<This null procedure MUST follow InitializeCleanup.    This null proc is supposed to bring in the remaining portions of    made-resident InitializeCleanup procedure in case it crosses    swap-unit boundary, code fragmentation. >>      WorkaroundForAR9282: PROCEDURE =    BEGIN    nonEmptyProcedure: BOOLEAN;    nonEmptyProcedure ¬ TRUE;    END;	-- WorkaroundForAR9282	  << For Dahlia >>    GetPrinterStatus: PUBLIC PROCEDURE [port: Bpface.Port]   	RETURNS [statusByte: BiParallelPortFaceExtras.StatusByte, valid: BOOLEAN] =	  	BEGIN	   nilByte: BiParallelPortFaceExtras.StatusByte ¬ 0;		   IF NOT SetDCBPtrs [port] THEN RETURN [  , FALSE];	       IF ppoDCB.dcbSpareByte1 = LOOPHOLE[55H] THEN 	       		BEGIN 	      		statusByte ¬ ppoDCB.dcbSpareByte0;	      		ppoDCB.dcbSpareByte0 ¬ nilByte;			ppoDCB.dcbSpareByte1 ¬ nilByte;	       		RETURN [statusByte, TRUE];			END;	RETURN [nilByte, TRUE];	END;  <<GetPageAtOutputTray: PUBLIC PROCEDURE [port: Bpface.Port]   	RETURNS [pageAtOutputTray: Bpface.PageAtOutputTray, valid: BOOLEAN] =  	BEGIN	   countWord: Environment.Word;		   IF NOT SetDCBPtrs [port] THEN RETURN [  , FALSE];	       countWord ¬ ppoFCB.ppoSpareWord;	       pageAtOutputTray ¬ DoveInputOutput.ByteSwap[countWord];	RETURN [pageAtOutputTray, TRUE] ;	END;>>	  GetHardWareType: PUBLIC PROCEDURE []  	RETURNS [hardWareIsDahlia:BOOLEAN ¬ FALSE] =	BEGIN		IF Runtime.IsBound[LOOPHOLE[ProcessorFaceExtras2.DoveMachineTypeInfo]] THEN {	     --Pilot15.0	     dovehardWareType ¬ ProcessorFaceExtras2.DoveMachineTypeInfo [];	     hardWareIsDahlia ¬ SELECT dovehardWareType FROM	       daybreak, daisy => FALSE,	       dahlia, duke, diana, dune => TRUE,	       ENDCASE => FALSE}	       	   ELSE {	     --Pilot14.0	     hardWareType ¬ ProcessorFaceExtras.MachineTypeInfo [];	     hardWareIsDahlia ¬ SELECT hardWareType FROM	       daybreak, daisy => FALSE,	       dahlia => TRUE,	       ENDCASE => FALSE};		IF hardWareIsDahlia THEN	   ppoFCB.port0DCB.dcbSpareByte1 ¬ 0;		 RETURN [hardWareIsDahlia];	END;	  << Mainline code >>    InlineInit[];    SpecialSpace.MakeGlobalFrameResident[frame: LOOPHOLE[BiParallelPortHeadDove] !    SpecialSpace.SpecialError => CONTINUE];  SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[InitializeCleanup] !    SpecialSpace.SpecialError => CONTINUE];  SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[WorkaroundForAR9282] !    SpecialSpace.SpecialError => CONTINUE];    InitializeCleanup [];      END...BiParallelPortHeadDove.mesa        LOG  21-Mar-88 14:32:31	JMA:don't cleanup if head or handler not initialized   3-Mar-88 11:05:26	JMA:saved states and restored them during IntializeCleanup   4-Dec-87 15:29:45	JMA:Fixed portError and added use of portException statuses  24-Nov-87 15:11:10	JMA:Added workaround for AR 12298 in PollTransferStatus Proc  24-Aug-87 15:33:09	JMA:made InitializeCleanup and WorkaroundForAR9282 contiguous  30-Jun-87 14:21:14	JMA:used commandList locking  22-May-87 12:49:05	JMA:fixed Dequeue Proc  27-Apr-87 13:20:22	JMA:added nilFCB constant  18-Nov-88 15:08:24	MS:Added GetPrinterStatus,<< GetPageAtOutputTray,>> GetHardWareType   8-Jun-89 15:48:09	MxS: Import Runtime.IsBound to support Pilot14.0 and Pilot15.0 
-- TTYPortHeadDove.mesa-- Created by PE/JM: 23-Jan-85 15:01:05-- Last edited:-- DMS		17-Sep-85 17:33:32		:Using one byte buffer-- JPM		29-Jul-85  9:56:06		:Opie redesign conversion-- DMS		14-Mar-85 15:57:52		:Changed from Remote Heads version<<	Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1984 but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.	>><<  This module TTYPortHeadDove represents the implementation of the TTYPortFace definition module.  This head is implemented differently from the Dlion head (TTYPortHeadDLion.mesa) due to the architecture difference of the IOP for the two workstations. >>DIRECTORY  DeviceCleanup USING [Await, Item, Reason],  DoveHandlerIDs USING [tty],  DoveInputOutput USING [BuildMesaClientCondition, ByteSwap, ByteSwappedWord,     ClientCondition, GetHandlerIORegionPtr, NotifyIOP],  HeadStartChain USING [Start],  Process USING [MsecToTicks, Pause],  TTYPortIOFaceDove,  TTYPortFace USING [DeviceStatus, Parameter, TransferStatus];     TTYPortHeadDove: PROGRAM  IMPORTS DeviceCleanup, DoveInputOutput, Process, RemainingHeads : HeadStartChain   EXPORTS HeadStartChain, TTYPortFace =  {  -- TTY Type definitions    TTYState: TYPE = {ON, OFF};      ttyFcb: LONG POINTER TO TTYPortIOFaceDove.FunctionContextBlock _    DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.tty];       -- Errors  unimplementedParameter: ERROR = CODE;  unimplementedStopBit: ERROR = CODE;  unimplementedBaudRate: ERROR = CODE;   -- Parameters saved during world swapping:  savedWR1: TTYPortIOFaceDove.WR1ByteType;  savedWR3: TTYPortIOFaceDove.WR3ByteType;  savedWR4: TTYPortIOFaceDove.WR4ByteType;  savedWR5: TTYPortIOFaceDove.WR5ByteType;  savedClientCondition: DoveInputOutput.ClientCondition;  savedBaudRate: DoveInputOutput.ByteSwappedWord;  rxOK: BOOLEAN;  txOK: BOOLEAN;  setOK: BOOLEAN;  ttyState: TTYState _ OFF;    -- Constants  nullStatusWord: TTYPortIOFaceDove.TTYStatusWord = [FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];       resetStatusWord: TTYPortIOFaceDove.TTYStatusWord = [FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];  backOnStatusWord: TTYPortIOFaceDove.TTYStatusWord = [FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE,     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];           << PUBLIC PROCEDURES>>  GetCommand: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [data: CHARACTER, stat: TTYPortFace.TransferStatus] =    {    statusImage: TTYPortIOFaceDove.TTYStatusWord _        DoveInputOutput.ByteSwap[ttyFcb.ttyStatusWord];      IF lineNumber # 0 THEN RETURN [NULL, notReady];      IF statusImage.ttyRxBufFull THEN          {         data _ ttyFcb.rxBuffer;	 statusImage.ttyRxBufFull _ FALSE;	 stat _ (SELECT TRUE FROM          ttyFcb.rr1.parityError => parityError,          ttyFcb.rr1.asyncFramingError => asynchFramingError,          ttyFcb.rr1.rxOverrun => dataLost,          ttyFcb.rr0.breakDetected => breakDetected,	  statusImage.ttyDataLost => dataLost,         ENDCASE => success);	 -- Clear dataLost flag after reporting it	 IF statusImage.ttyDataLost THEN	   statusImage.ttyDataLost _ FALSE;	 ttyFcb.ttyStatusWord _ DoveInputOutput.ByteSwap[statusImage];         }      ELSE          stat _ (SELECT TRUE FROM          ttyFcb.rr1.parityError => parityError,          ttyFcb.rr1.asyncFramingError => asynchFramingError,          ttyFcb.rr1.rxOverrun => dataLost,          ttyFcb.rr0.breakDetected => breakDetected,         ENDCASE => notReady);     };  GetLineCount: PUBLIC PROCEDURE RETURNS [lineCount: CARDINAL] =    {    RETURN [1] -- dedicated RS232 channel B      };  GetStatus: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [stat: TTYPortFace.DeviceStatus] =    {    statusImage: TTYPortIOFaceDove.TTYStatusWord _      DoveInputOutput.ByteSwap[ttyFcb.ttyStatusWord];    IF lineNumber # 0 THEN RETURN [ [FALSE, FALSE, FALSE, FALSE] ];    stat.dataTerminalReady _ NOT ttyFcb.iopSystemInputPort.nDataTerminalReady;    stat.readyToGet _ statusImage.ttyRxBufFull;    IF statusImage.ttyInterruptFail THEN      {      stat.readyToPut _ FALSE;      statusImage.ttyInterruptFail _ FALSE;      ttyFcb.ttyStatusWord _ DoveInputOutput.ByteSwap[statusImage];      }    ELSE      stat.readyToPut _  statusImage.ttyTxBufEmpty;    stat.requestToSend _ ttyFcb.rr0.requestToSend;    };  << turn off receive & transmit and reset buffer pointers >>  Off: PUBLIC PROCEDURE [lineNumber: CARDINAL] =    {    workListImage: TTYPortIOFaceDove.WorkListType _      DoveInputOutput.ByteSwap[ttyFcb.ttyWorkList];    IF lineNumber # 0 THEN RETURN;    ttyState _ OFF;    ttyFcb.wr1.txIntDMAenable _    ttyFcb.wr3.rxEnable _     ttyFcb.wr5.txEnable _ FALSE;    workListImage.writeReg1 _     workListImage.writeReg3 _     workListImage.writeReg5 _ TRUE;    workListImage.workToBeDone _ TRUE;    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];    ttyFcb.ttyStatusWord _ nullStatusWord;    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];    };  << get client condition mask and enable receive & transmit >>  On: PUBLIC PROCEDURE [lineNumber: CARDINAL, mask: UNSPECIFIED] =    {    workListImage: TTYPortIOFaceDove.WorkListType _ DoveInputOutput.ByteSwap[ttyFcb.ttyWorkList];    ttyClientConditionPtr: LONG POINTER TO DoveInputOutput.ClientCondition       _ @ttyFcb.ttyClientCondition;    statusImage: TTYPortIOFaceDove.TTYStatusWord _  DoveInputOutput.ByteSwap[ttyFcb.ttyStatusWord];        IF lineNumber # 0 THEN RETURN;    ttyState _ ON;    DoveInputOutput.BuildMesaClientCondition[ttyClientConditionPtr, mask];    -- reset buffer indices    ttyFcb.wr1.interruptCondition _ intOnAllRxParityNotAffectVector;    ttyFcb.wr1.txIntDMAenable _    ttyFcb.wr3.rxEnable _     ttyFcb.wr5.txEnable _ TRUE;    workListImage.writeReg1 _    workListImage.writeReg3 _    workListImage.writeReg5 _     workListImage.workToBeDone _ TRUE;    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];    statusImage.ttyChnlBOn _ TRUE;    statusImage.ttyTxBufEmpty _ TRUE;    statusImage.ttyRxBufFull _ FALSE;    statusImage.ttyInterruptFail _ FALSE;    statusImage.ttyDataLost _ FALSE;    ttyFcb.ttyStatusWord _ DoveInputOutput.ByteSwap[statusImage];    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];    };      << fill transmit buffer and update buffer pointers >>      PutCommand: PUBLIC PROCEDURE [lineNumber: CARDINAL, data: CHARACTER]    RETURNS [stat: TTYPortFace.TransferStatus] =    {    statusImage: TTYPortIOFaceDove.TTYStatusWord _       DoveInputOutput.ByteSwap[ttyFcb.ttyStatusWord];    IF lineNumber # 0 THEN RETURN [notReady];    IF statusImage.ttyTxBufEmpty THEN      {      ttyFcb.txBuffer _ data;      statusImage.ttyTxBufEmpty _ FALSE;       ttyFcb.ttyStatusWord _ DoveInputOutput.ByteSwap[statusImage];      DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];      IF ttyFcb.rr0.breakDetected THEN stat _ breakDetected      ELSE stat _ success;      }   ELSE      IF ttyFcb.rr0.breakDetected THEN stat _ breakDetected     ELSE stat _ notReady;   };  SendBreak: PUBLIC PROCEDURE [lineNumber: CARDINAL] =    {    workListImage: TTYPortIOFaceDove.WorkListType _ DoveInputOutput.ByteSwap[ttyFcb.ttyWorkList];    ttyFcb.wr5.sendBreak _ workListImage.writeReg5 _ workListImage.workToBeDone _ TRUE;    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];    Process.Pause [Process.MsecToTicks [250] ]; -- must be at least 190    ttyFcb.wr5.sendBreak _ FALSE;    workListImage.writeReg5 _ workListImage.workToBeDone _ TRUE;    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];    };      << program registers & set flag (locked) in ttyFcb.workList >>  SetParameter: PUBLIC PROCEDURE [lineNumber: CARDINAL, parameter: TTYPortFace.Parameter] =    {    workListImage: TTYPortIOFaceDove.WorkListType _ DoveInputOutput.ByteSwap[ttyFcb.ttyWorkList];    baudRateImage: DoveInputOutput.ByteSwappedWord _ 0;    IF lineNumber # 0 THEN RETURN;    WITH parameter SELECT FROM       -- rx & tx set to the same char length       characterLength	=> { ttyFcb.wr3.rxCharLength _ ttyFcb.wr5.txCharLength _ (SELECT characterLength FROM		 		   lengthIs5bits => ch5bits,				   lengthIs6bits => ch6bits,       				   lengthIs7bits => ch7bits,				   lengthIs8bits => ch8bits,				   ENDCASE => ERROR unimplementedParameter);				 workListImage.writeReg3 _ workListImage.writeReg5 _ TRUE;			   };			          clearToSend	=> {       				ttyFcb.wr5.clearToSend _ clearToSend;				workListImage.writeReg5 _ TRUE; -- RTS on i8274			   };              dataSetReady	=> {       				ttyFcb.wr5.dataSetReady _ dataSetReady;				workListImage.writeReg5 _ TRUE; -- DTR on i8274			   };              lineSpeed	=> { baudRateImage _ (SELECT lineSpeed FROM       				   bps50 	=> 5000, -- values for the i8254				   bps75 	=> 3334, --  programmable interval timer				   bps110 	=> 2272,				   bps150 	=> 1667,				   bps300 	=> 833,				   bps600 	=> 417,				   bps1200 	=> 208,				   bps1800 	=> 138,				   bps2000 	=> 126,				   bps2400 	=> 104,				   bps3600 	=> 69,				   bps4800 	=> 52,				   bps7200 	=> 35,				   bps9600 	=> 26,				   bps19200 	=> 13,				   ENDCASE	=> ERROR unimplementedBaudRate);			      ttyFcb.ttyBaudRate _  DoveInputOutput.ByteSwap[baudRateImage];       			      workListImage.writeBaudRate _ TRUE;			   };			          parity		=> { ttyFcb.wr4.parity _ (SELECT parity FROM       				   none => none,				   odd 	=> parityOdd,				   even => parityEven,				   ENDCASE => ERROR unimplementedParameter);				 workListImage.writeReg4 _ TRUE;			   };			          stopBits		=> { ttyFcb.wr4.stopBits _ (SELECT stopBits FROM       				   none 		=> ERROR unimplementedStopBit,       				   one	 		=> oneStopBit,				   oneAndHalf	 	=> oneAndHalfStopBit,				   two	 		=> twoStopBit,				   ENDCASE		=> ERROR unimplementedParameter);				 workListImage.writeReg4 _ TRUE;			   };       ENDCASE 		=> RETURN;    -- set up work list      workListImage.workToBeDone _ TRUE;    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];    };  << PRIVATE PROCs >>  InitializeCleanup: PROCEDURE =    {    item: DeviceCleanup.Item;    reason: DeviceCleanup.Reason;    i: CARDINAL _ 0;    statusImage: TTYPortIOFaceDove.TTYStatusWord _ DoveInputOutput.ByteSwap[ttyFcb.ttyStatusWord];    workListImage: TTYPortIOFaceDove.WorkListType _ DoveInputOutput.ByteSwap[ttyFcb.ttyWorkList];    DO      reason _ DeviceCleanup.Await[@item];      IF ttyState = ON THEN        SELECT reason FROM 	  turnOff, kill =>	    {	    -- Save parameters	    savedWR1 _ ttyFcb.wr1;	    savedWR3 _ ttyFcb.wr3;	    savedWR4 _ ttyFcb.wr4;	    savedWR5 _ ttyFcb.wr5;	    savedClientCondition _ ttyFcb.ttyClientCondition;	    savedBaudRate _ ttyFcb.ttyBaudRate;	    -- Turn off the chip	    ttyFcb.wr1.txIntDMAenable _    	    ttyFcb.wr3.rxEnable _             ttyFcb.wr5.txEnable _ FALSE;            workListImage.writeReg1 _             workListImage.writeReg3 _             workListImage.writeReg5 _ TRUE;            workListImage.workToBeDone _ TRUE;	    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];	    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];  	    -- Wait for Tx/Rx and Parameter setting completion	    rxOK _ FALSE;	    txOK _ FALSE;	    setOK _ FALSE;	    FOR i IN [0..LAST[CARDINAL]] DO	      IF (NOT statusImage.ttyRxBufFull) THEN	        { rxOK _ TRUE; EXIT; };	      ENDLOOP;	    FOR i IN [0..LAST[CARDINAL]] DO 	      IF (statusImage.ttyTxBufEmpty) THEN	        { txOK _ TRUE; EXIT; };	      ENDLOOP;	    FOR i IN [0..LAST[CARDINAL]] DO 	      IF NOT workListImage.workToBeDone THEN	        { setOK _ TRUE; EXIT; };	      ENDLOOP;	    -- Set FCB parameters to show channel is OFF	    ttyFcb.ttyStatusWord _ DoveInputOutput.ByteSwap[resetStatusWord];	    };	  turnOn =>	    {	    -- Reset Write Registers, fcb parameters and turn Channel back on	    ttyFcb.wr1 _ savedWR1;	    ttyFcb.wr3 _ savedWR3;	    ttyFcb.wr4 _ savedWR4;	    ttyFcb.wr5 _ savedWR5;	    ttyFcb.ttyClientCondition _ savedClientCondition;	    ttyFcb.ttyBaudRate _ savedBaudRate;	    -- Put channel on	    ttyFcb.ttyStatusWord _ DoveInputOutput.ByteSwap[backOnStatusWord];	    ttyFcb.wr1.interruptCondition _ intOnAllRxParityNotAffectVector;	    ttyFcb.wr1.txIntDMAenable _    	    ttyFcb.wr3.rxEnable _             ttyFcb.wr5.txEnable _ TRUE;            workListImage.writeReg1 _             workListImage.writeReg3 _ 	    workListImage.writeReg4 _            workListImage.writeReg5 _	    workListImage.writeBaudRate _ TRUE;            workListImage.workToBeDone _ TRUE;	    ttyFcb.ttyWorkList _ DoveInputOutput.ByteSwap[workListImage];	    DoveInputOutput.NotifyIOP [ttyFcb.ttyWorkMask];	    };	  disconnect => NULL;  -- turnOff was already called	  ENDCASE;	ENDLOOP;        };      -- Start Chain  Start: PUBLIC PROC = { RemainingHeads.Start[] };  << Mainline code >>  InitializeCleanup [];  }...    	
-- DiskHeadLabeledDukeB.mesa-- Last edited by MN:  2-Nov-88 22:07:24DIRECTORY  DiskHeadLabeledDukeInternal USING [    altQInvalid, altQWaiting, fcb, maxNumberOfBuffers, nk, numberOfInstalledDrives, numberOfTrackBuffers, oldestEntry, PromptHandler, rdcImplementsTrackReadCommand, readHit, readHitInvalidSect, readMis, replaceAlgorithm, savedAltQInvalid, savedAltQWaiting, savedStartHandlerForMesa, savedHandlerState, savedClientInfo, savedCurrentDrivePtr, savedControllerRegisters, savedDriveInfoAndDMAStatus, savedDCB, sectorsPerTrackBuffer, trackBufferInitialized, trackBufferTable, writeHit, writeMis],  DiskIOFaceDuke USING [DCB, DCBPtr, DriveNumber, IOCBlongPtr, nil, selectMasks],  DeviceCleanup USING [Await, Item, Reason],  DoveInputOutput USING [    BuildMesaClientCondition,    ByteSwap, ByteSwappedPointer, IOPShortBoolean, LongPointerToOpieAddress, nilOpieAddress],  CompatibilityDiskFace USING [OperationPtr, OldGetDeviceAttributes, Reset],  Environment USING [bitsPerWord, wordsPerPage],  PilotDiskFace USING [ControllerHandle, DeviceHandle, GlobalStatePtr];DiskHeadLabeledDukeB: PROGRAM  IMPORTS    CompatibilityDiskFace, DeviceCleanup, DiskHeadLabeledDukeInternal, DoveInputOutput  EXPORTS    CompatibilityDiskFace, DiskHeadLabeledDukeInternal =  BEGIN  OPEN    CDF: CompatibilityDiskFace,    DHI: DiskHeadLabeledDukeInternal,    IOF: DiskIOFaceDuke,    PDF: PilotDiskFace;  InitializeCleanup: PUBLIC PROCEDURE [PDF.ControllerHandle] =    BEGIN OPEN DeviceCleanup;    item: Item;    DO      reason: Reason = Await[@item];      SELECT reason FROM        turnOff, disconnect, kill => {          DHI.fcb.mesaCleanupRequest ¬ True;          DHI.PromptHandler[];          UNTIL DHI.fcb­.handlerStoppedForMesaCleanup = True DO ENDLOOP;          DHI.savedAltQInvalid ¬ DHI.altQInvalid;	  DHI.savedAltQWaiting ¬ DHI.altQWaiting;          DHI.savedStartHandlerForMesa ¬ DHI.fcb.startHandlerForMesa;          DHI.savedHandlerState ¬ DHI.fcb.handlerState;          DHI.savedClientInfo ¬ DHI.fcb.clientInfo;          DHI.savedCurrentDrivePtr ¬ DHI.fcb.currentDrivePtr;          DHI.savedControllerRegisters ¬ DHI.fcb.controllerRegisters;          DHI.savedDriveInfoAndDMAStatus ¬ DHI.fcb.driveInfoAndDMAStatus;          DHI.savedDCB ¬ DHI.fcb.dcb};        turnOn => {	  DHI.fcb.mesaCleanupRequest ¬ True;          DHI.PromptHandler[];          UNTIL DHI.fcb­.handlerStoppedForMesaCleanup = True DO ENDLOOP;          DHI.altQInvalid ¬ DHI.savedAltQInvalid;	  DHI.altQWaiting ¬ DHI.savedAltQWaiting;          DHI.fcb.startHandlerForMesa ¬ DHI.savedStartHandlerForMesa;          DHI.fcb.handlerState ¬ DHI.savedHandlerState;          DHI.fcb.clientInfo ¬ DHI.savedClientInfo;          DHI.fcb.currentDrivePtr ¬ DHI.savedCurrentDrivePtr;          DHI.fcb.controllerRegisters ¬ DHI.savedControllerRegisters;          DHI.fcb.driveInfoAndDMAStatus ¬ DHI.savedDriveInfoAndDMAStatus;          DHI.fcb.dcb ¬ DHI.savedDCB;	  DHI.fcb.mesaCleanupRequest ¬ False;          DHI.PromptHandler[] --Is this prompt necessary?--};        ENDCASE      ENDLOOP    END;  InitializeController: PUBLIC PROCEDURE [    controller: PDF.ControllerHandle,    globalState: PDF.GlobalStatePtr, mask: WORD,    nakedCondition: LONG POINTER TO CONDITION ¬ NIL] =    BEGIN    DHI.nk ¬ nakedCondition;    DHI.altQInvalid ¬ [IOF.nil, IOF.nil];    DHI.altQWaiting ¬ [IOF.nil, IOF.nil];    FOR driveNumber: IOF.DriveNumber IN IOF.DriveNumber DO      dcb: IOF.DCBPtr = @DHI.fcb­.dcb[driveNumber];      dcb­ ¬ [        mesaHead: IOF.nil, handlerMesaNext: IOF.nil,        mesaTail: IOF.nil, blockMesaQueue: False,	iopHead: TRASH, handlerIOPNext: TRASH,        iopTail: TRASH, blockIOPQueue: TRASH,	currentDriveMask: mask,        diskCommand: TRASH, mesaClientCondition: TRASH, iopClientCondition: TRASH,        currentIOCB: DoveInputOutput.nilOpieAddress, recalibrate: TRUE,        useEcc: FALSE,        driveExists: driveNumber < DHI.numberOfInstalledDrives,        selectMask: IOF.selectMasks[driveNumber], diskState: notThere,        dcbOffset: driveNumber * SIZE[IOF.DCB],        deviceInformation: [        driveType: TRASH, sectorsPerTrack: TRASH, headsPerCylinder: TRASH,        cylindersPerDrive: TRASH, reduceWriteCurrentCylinder: TRASH,        precompensationCylinder: TRASH]];      DoveInputOutput.BuildMesaClientCondition[        clientConditionPtr: @dcb.mesaClientCondition, mask: mask];      ENDLOOP;    CDF.Reset[controller];    DHI.fcb­.mesaCleanupRequest ¬ False;    END;  InitializeTrackBuffer: PUBLIC PROCEDURE [    device: PDF.DeviceHandle,    buffer: LONG POINTER,    numberOfBuffers: CARDINAL] =    BEGIN    IF (LOOPHOLE[buffer, LONG CARDINAL] MOD Environment.wordsPerPage) # 0 THEN      ERROR; -- buffer should be page aligned    DHI.numberOfTrackBuffers ¬ numberOfBuffers;    [sectorsPerTrack: DHI.sectorsPerTrackBuffer] ¬      CDF.OldGetDeviceAttributes[device];    FOR i: CARDINAL IN [0..DHI.numberOfTrackBuffers) DO      DHI.trackBufferTable [i].order ¬ i;      DHI.trackBufferTable [i].sectorValid ¬ ALL [FALSE];      DHI.trackBufferTable [i].trackData ¬ buffer;      -- make each page dirty, advance buffer      THROUGH [0..DHI.sectorsPerTrackBuffer) DO	buffer­ ¬ 0;	buffer ¬ buffer + Environment.wordsPerPage;	ENDLOOP;      ENDLOOP;    -- Turn on the buffer    DHI.trackBufferInitialized ¬ TRUE;    END;  PagesForTrackBuffering: PUBLIC PROCEDURE [device: PDF.DeviceHandle]    RETURNS [pagesPerBuffer: CARDINAL, maxNumberOfBuffers: CARDINAL] =    BEGIN    sectorsPerTrackBuffer: CARDINAL;    [sectorsPerTrack: sectorsPerTrackBuffer] ¬ CDF.OldGetDeviceAttributes[device];    IF (sectorsPerTrackBuffer > Environment.bitsPerWord)	OR (NOT DHI.rdcImplementsTrackReadCommand)	OR (DHI.nk = NIL)      THEN RETURN[pagesPerBuffer: 0, maxNumberOfBuffers: 0];    RETURN[pagesPerBuffer: sectorsPerTrackBuffer, maxNumberOfBuffers: DHI.maxNumberOfBuffers];    END;  << ReadTrackBuffer: set iocb for track read. It may change       iocb.bufferHit, iocb.mapEntry, iocb.dataPtr, iocb.pageCount,       iocb.stopHandlerOnCompletion, dob.negativeSectorCount,       dob.sectorValid, dob.operation >>  ReadTrackBuffer: PUBLIC PROCEDURE [op: CDF.OperationPtr] =    BEGIN    foundOne, hit: BOOLEAN ¬ FALSE;    mapIndex, oldOrder: CARDINAL;    iocb: IOF.IOCBlongPtr = LOOPHOLE[op, IOF.IOCBlongPtr];    -- Is there the track in the buffer ?    FOR mapIndex IN [0..DHI.numberOfTrackBuffers) DO      IF (op.clientHeader.cylinder = DHI.trackBufferTable[mapIndex].cylinder) AND	 (op.clientHeader.head = DHI.trackBufferTable[mapIndex].head) THEN	{ foundOne ¬ TRUE; EXIT};      ENDLOOP;    IF foundOne THEN      BEGIN      -- We have the track.  Does the track have valid data ?      start: CARDINAL = op.clientHeader.sector;      firstSect: CARDINAL = DHI.trackBufferTable[mapIndex].firstSect;      sectIndex: CARDINAL ¬ IF start < firstSect	THEN start - firstSect + DHI.sectorsPerTrackBuffer	ELSE start - firstSect;      THROUGH [start..MIN[DHI.sectorsPerTrackBuffer, start + iocb.runLength]) DO	hit ¬ DHI.trackBufferTable[mapIndex].sectorValid[Environment.bitsPerWord-1 - sectIndex];	IF NOT hit THEN EXIT;	sectIndex ¬ sectIndex + 1;	IF sectIndex = DHI.sectorsPerTrackBuffer THEN sectIndex ¬ 0;	ENDLOOP;      END;    IF hit THEN      BEGIN      iocb.bufferHit ¬ TRUE;      DHI.readHit ¬ DHI.readHit + 1;      END    ELSE      BEGIN      IF NOT foundOne THEN	-- We don't have the track.  Select purged entry.	IF DHI.replaceAlgorithm = lru THEN	  BEGIN	  -- order=0 is the oldest.	  FOR i:CARDINAL IN [0..DHI.numberOfTrackBuffers) DO	    IF DHI.trackBufferTable[i].order = 0 THEN	      {mapIndex ¬ i; EXIT}	    ENDLOOP;	  DHI.readMis ¬ DHI.readMis + 1;	  END	ELSE <<fifo>>	  BEGIN	  mapIndex ¬ DHI.oldestEntry;	  DHI.oldestEntry ¬ DHI.oldestEntry + 1;	  IF DHI.oldestEntry = DHI.numberOfTrackBuffers THEN DHI.oldestEntry ¬ 0;	  END      ELSE	BEGIN	-- We have the track, but data is invalid (may be written)	DHI.readHitInvalidSect ¬ DHI.readHitInvalidSect + 1;	END;      -- set iocb and dob for track buffer      iocb.bufferHit ¬ FALSE;      iocb.dob.sectorValid ¬ LOOPHOLE[0] <<All false>>;      iocb.dob.operation ¬ readTrack;      iocb.pageCount ¬ DoveInputOutput.ByteSwap[DHI.sectorsPerTrackBuffer];      iocb.dob.negativeSectorCount ¬ DoveInputOutput.ByteSwap[0 - DHI.sectorsPerTrackBuffer];      iocb.dataPtr ¬	DoveInputOutput.LongPointerToOpieAddress[DHI.trackBufferTable[mapIndex].trackData];      -- set mapEntry      DHI.trackBufferTable[mapIndex].sectorValid ¬ LOOPHOLE[0]<<All False>>;      DHI.trackBufferTable[mapIndex].cylinder ¬ op.clientHeader.cylinder;      DHI.trackBufferTable[mapIndex].head ¬ op.clientHeader.head;      END;-- not hit    iocb.mapEntry ¬ mapIndex;    -- set stopHandlerOnCompletion if operation is for more than one track    --      IF op.clientHeader.sector + op.pageCount > DHI.sectorsPerTrackBuffer THEN      iocb­.stopHandlerOnCompletion ¬ True;    IF DHI.replaceAlgorithm = lru THEN      BEGIN      -- maintain order, order = 0 is the oldest      oldOrder ¬ DHI.trackBufferTable[mapIndex].order;      FOR i:CARDINAL IN [0..DHI.numberOfTrackBuffers) DO	IF DHI.trackBufferTable[i].order > oldOrder THEN	  DHI.trackBufferTable[i].order ¬ DHI.trackBufferTable[i].order - 1;	ENDLOOP;      DHI.trackBufferTable[mapIndex].order ¬ DHI.numberOfTrackBuffers - 1;      END;    END; -- ReadTrackBuffer  << InvalidateTrackBuffer: invalidate track buffer map flag.  No effect to iocb >>  InvalidateTrackBuffer: PUBLIC PROCEDURE [op: CDF.OperationPtr, dcb: IOF.DCBPtr] =    BEGIN    foundOne: BOOLEAN;    mapIndex: CARDINAL;    cyl, head, sect, remainingPage: CARDINAL;    cyl ¬ op.clientHeader.cylinder;    head ¬ op.clientHeader.head;    sect ¬ op.clientHeader.sector;    remainingPage ¬ op.pageCount;    WHILE remainingPage > 0 DO      foundOne ¬ FALSE;      FOR mapIndex IN [0..DHI.numberOfTrackBuffers) DO	IF (cyl = DHI.trackBufferTable[mapIndex].cylinder) AND	   (head = DHI.trackBufferTable[mapIndex].head) THEN	  { foundOne ¬ TRUE; EXIT};	ENDLOOP;      IF foundOne THEN	BEGIN	-- invalidate the entry	firstSect: CARDINAL = DHI.trackBufferTable[mapIndex].firstSect;	sectIndex: CARDINAL ¬ IF sect < firstSect	  THEN sect - firstSect + DHI.sectorsPerTrackBuffer	  ELSE sect - firstSect;	WHILE (remainingPage # 0) AND (sect # DHI.sectorsPerTrackBuffer) DO	  DHI.trackBufferTable[mapIndex].sectorValid[Environment.bitsPerWord-1 - sectIndex] ¬ FALSE;	  sect ¬ sect + 1;	  remainingPage ¬ remainingPage - 1;	  sectIndex ¬ sectIndex + 1;	  IF sectIndex = DHI.sectorsPerTrackBuffer THEN sectIndex ¬ 0;	  ENDLOOP;	DHI.writeHit ¬ DHI.writeHit + 1;	END      ELSE	BEGIN	-- proceed to next track	remainingPage ¬ IF (DHI.sectorsPerTrackBuffer - sect) >= remainingPage	  THEN 0	  ELSE remainingPage - (DHI.sectorsPerTrackBuffer - sect);	DHI.writeMis ¬ DHI.writeMis + 1;	END;      sect ¬ 0; head ¬ head + 1;      IF head = dcb.deviceInformation.headsPerCylinder THEN { head ¬ 0; cyl ¬ cyl + 1};      ENDLOOP; -- WHILE remainingPage > 0    END; -- InvalidateTrackBuffer  OldStartB: PUBLIC PROCEDURE = {};  END.....LOGMN: 12-Oct-88 17:54:16  Created.MN:  2-Nov-88 22:07:43	Fixed bug(can't disk boot from ether-booted Othello). Added OldStartB.
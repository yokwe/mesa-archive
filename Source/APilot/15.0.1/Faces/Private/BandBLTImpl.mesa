-- BandBLTImpl.mesa-- Copyright (C) 1985 by Xerox Corporation.  All rights reserved.-- Last edited by CRF: 5-Sep-86  8:51:38-- THINGS TO DO:-- 1. Add Character TYPE to BandBLT.-- 2. How does the microcode provide mutual exclusion, or is that not a problem?DIRECTORY  BandBLT,  BitBlt --USING [DstFunc, SrcFunc]--,  Environment USING [bitsPerWord, wordsPerPage],  ESCAlpha USING [aBANDBLT],  Heap USING [systemMDSZone],  Frame USING [GetReturnFrame, ReadPC, WritePC],  Inline USING [LowHalf],  PrincOps USING [ESCTrapTable],  Space USING [LongPointerFromPage];BandBLTImpl: MONITOR  -- monitor protects the global variables  IMPORTS BitBlt, Frame, Inline, Space, Heap  EXPORTS BandBLT=  BEGIN  -- Data Structures:  FontPointerTable: TYPE = ARRAY BandBLT.Font OF LONG POINTER TO FontVectorTable;  FontVectorTable: TYPE = ARRAY Character OF Displacement;  Character: TYPE = CARDINAL [0..256);  Displacement: TYPE = CARDINAL;    -- double-word displacement into font bitmap memory (must be multiplied by 2     -- to get a single-word displacement).  OneFontEntry: TYPE = RECORD [  -- one entry in the font bitmap memory    scanLines: CARDINAL,    -- count of scan lines in this bitmap.    bitsPerLine: CARDINAL,  -- count of bits along scan line of this bitmap.    bitMap: CharBitMap];    -- the bitmap.  CharBitMap: TYPE = ARRAY [0..0) OF UNSPECIFIED;  --the bitmap for the character.  FontEntry: TYPE = LONG POINTER TO OneFontEntry;    bitsPerScanLine: CARDINAL = Environment.wordsPerPage*Environment.bitsPerWord;    -- a scan line is not allowed to cross a memory page boundary currently,    -- which limits the size of a scan line to one memory page worth of bits, i.e.    -- 4096 bits (13.65" @ 300 bits per inch).    -- Forrest would like to allow two-page (8192 bit) scan lines.  wordsPerScanLine: CARDINAL = bitsPerScanLine/Environment.bitsPerWord;  scanLinesPerBand: CARDINAL = (Inline.LowHalf[BandBLT.bandBufferSize]*    Environment.wordsPerPage)/wordsPerScanLine;    bBTableSpacePtr: POINTER TO BitBlt.BBTableSpace ¬     Heap.systemMDSZone.NEW[BitBlt.BBTableSpace];  ptBBTable: BitBlt.BBptr ¬ BitBlt.AlignedBBTable[bBTableSpacePtr];  List: TYPE = {band, leftover};  currentList: List;  Inkwell: TYPE = [0..377B];  inkwellBand, inkwellLeftover: Inkwell;  Level: TYPE = [0..377B];  levelBand, levelLeftover: Level;  black: CARDINAL = LAST[Inkwell];  srcFuncBand, srcFuncLeftover: BitBlt.SrcFunc;  dstFuncBand, dstFuncLeftover: BitBlt.DstFunc;  bandDone, leftoverDone: BOOLEAN;  bandList: BandBLT.BandListItemLongPointer;  -- input band list  readLO: BandBLT.BandListItemLongPointer;  -- input leftover list  writeLO: BandBLT.BandListItemLongPointer;  -- output leftover list  bandBuf: LONG POINTER;  -- output band buffer  fontPointerTable: LONG POINTER TO FontPointerTable;  -- font pointer array  inkwells: LONG POINTER;  -- inkwell memory  fontRasters: FontEntry;  -- font raster (bitmap) memory  command: BandBLT.Command;  -- current item command  lastSetLevel: BandBLT.BandListItemLongPointer;  lastSetInk: BandBLT.BandListItemLongPointer;  -- COMMENTS  -- This is all based on the assumption that levels are monotonically increasing, and each level is only used once on the whole page.  -- It's possible that inkwell (sort of a color) shouldn't be a separate entry type, but an attribute of rectangles, circles, etc. It seems like at this time, we almost have to precede every rectangle by an inkwell setting. The only exception is when a bunch of rectangles at the same level all start in the same band. This savings doesn't seem worth it. In the meantime, all my test rectangles will generate their own preceeding inkwells.  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- Public Procedure  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  SoftwareBandBLT: PUBLIC ENTRY PROCEDURE [bandBLTTable: BandBLT.BandBLTTablePtr]    RETURNS [nextEntry: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    bandDone ¬ leftoverDone ¬ FALSE;    levelBand ¬ levelLeftover ¬ FIRST[Level];      -- implicitly, each list starts with a set level command to FIRST[Level].    inkwellBand ¬ inkwellLeftover ¬ FIRST[Inkwell];    srcFuncBand ¬ srcFuncLeftover ¬ null;    dstFuncBand ¬ dstFuncLeftover ¬ null;      -- implicitly, each list starts with a set level command to FIRST[Inkwell]      -- with null source and destination flags.    currentList ¬ leftover;  -- start reading in leftover list    lastSetLevel.setLevel ¬ NIL;    lastSetInk.setInk ¬ NIL;    bandBuf ¬ bandBLTTable.bandbuf;    bandList.ptr ¬ bandBLTTable.bandlist;    readLO.ptr ¬ Space.LongPointerFromPage[bandBLTTable.readLO];    writeLO.ptr ¬ Space.LongPointerFromPage[bandBLTTable.writeLO];    fontPointerTable ¬ Space.LongPointerFromPage[bandBLTTable.fontPtrTbl];    inkwells ¬ Space.LongPointerFromPage[bandBLTTable.inkwells];    fontRasters ¬ Space.LongPointerFromPage[bandBLTTable.fontRasters];    UNTIL bandDone AND leftoverDone DO      --this is the main loop for the page      --get the next band list entry      IF currentList = leftover THEN ProcessOneLeftoverItem[]      ELSE ProcessOneBandItem[];      ENDLOOP;    RETURN[bandList.ptr];      -- points to endOfBand item if end of band (or NIL if end of page)    END;  -- of SoftwareBandBLT  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- Private Procedures  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  BANDBLT: PROCEDURE [bandBLTTable: BandBLT.BandBLTTablePtr]    RETURNS [nextEntry: LONG POINTER] =    BEGIN    -- This procedure is called via a microcode trap if the microcode does not    -- implement BandBLT.  Since this is called as a trap instruction, we have to    -- bump the pc.  Note that BandBLT is minimal stack, which means we don't    -- have to bother dumping state.    Frame.WritePC[      pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],      lf: Frame.GetReturnFrame[]];    RETURN SoftwareBandBLT[bandBLTTable];    END;  -- of BANDBLT  BumpInputPointer: PROCEDURE [size: CARDINAL] =    BEGIN    IF currentList = band THEN bandList.ptr ¬ bandList.ptr + size    ELSE readLO.ptr ¬ readLO.ptr + size;    END;  -- of BumpInputPointer  CreateCharacterLeftover: PROCEDURE =    BEGIN    ForceOutInkAndLevel[];    SELECT TRUE FROM      currentList = band =>        BEGIN  --new character	writeLO.leftOverChar­ ¬ [leftOverChar [type: BandBLT.charCmd,	    font: bandList.char.font, cc: bandList.char.cc, mustBeZero: 0,	    yloc: bandList.char.yloc, alsoMustBeZero: 0,	    scansToSkip: scanLinesPerBand - bandList.char.xloc]];        END;      currentList = leftover =>        BEGIN  --leftover character        writeLO.leftOverChar­ ¬ readLO.leftOverChar­;        writeLO.leftOverChar.scansToSkip ¬	    writeLO.leftOverChar.scansToSkip + scanLinesPerBand;        END;      ENDCASE;    --bump output pointer    writeLO.ptr ¬ writeLO.ptr + SIZE[leftOverChar BandBLT.BlItem];    END;  --of CreateCharacterLeftover  ForceOutInkAndLevel: PROCEDURE =    -- This procedure allows outputting setInk or setLevel commands to the    -- leftover list only when they are needed, i.e. only when an object to which    -- they apply produces a leftover.    BEGIN    IF lastSetLevel.setLevel # NIL THEN {      writeLO.setLevel­ ¬ lastSetLevel.setLevel­;      writeLO.ptr ¬ writeLO.ptr + SIZE[setLevel BandBLT.BlItem];      lastSetLevel.setLevel ¬ NIL};    IF lastSetInk.setInk # NIL THEN {      writeLO.setInk­ ¬ lastSetInk.setInk­;      writeLO.ptr ¬ writeLO.ptr + SIZE[setInk BandBLT.BlItem];      lastSetInk.setInk ¬ NIL};    END;  -- of ForceOutInkAndLevel  ProcessBandCharacter: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    fontEntry: FontEntry;    ixTheoreticalLastScanInBandPlus1: CARDINAL;    srcWordsPerLine: CARDINAL;    --calculate the bitmap pointer from the font and character code.    fontEntry ¬ fontRasters + LONG[fontPointerTable[i.char.font][i.char.cc]]*2;    srcWordsPerLine ¬ (fontEntry.bitsPerLine + 15)/Environment.bitsPerWord;    ixTheoreticalLastScanInBandPlus1 ¬ fontEntry.scanLines + i.char.xloc;    ptBBTable­ ¬ [      dst: [        word: (bandBuf + (i.char.xloc*wordsPerScanLine) +	    (i.char.yloc/Environment.bitsPerWord)),        reserved: 0,        bit: (i.char.yloc MOD Environment.bitsPerWord)],      dstBpl: bitsPerScanLine,      src: [        word: @fontEntry.bitMap,  --the whole source character        reserved: 0,        bit: 0],      srcDesc: [srcBpl[srcBpl: srcWordsPerLine*Environment.bitsPerWord]],	  --bits along the scan line of dest      width: fontEntry.bitsPerLine,  --bits along the scan line of dest      height: (MIN[ixTheoreticalLastScanInBandPlus1, scanLinesPerBand] -	  i.char.xloc),  --number of scan lines affected      flags: [        -- determines the BitBlt function        direction: forward,        disjoint: FALSE,        disjointItems: FALSE,        gray: FALSE,        srcFunc: null,        dstFunc: or,        reserved: 0        ],      reserved: 0      ];    ProcessCharacter[fontEntry, ixTheoreticalLastScanInBandPlus1];    BumpInputPointer[SIZE[char BandBLT.BlItem]];    END;  -- of ProcessBandCharacter  ProcessCharacter: PROCEDURE    [fontEntry: FontEntry, ixTheoreticalLastScanInBandPlus1: CARDINAL] =    BEGIN    BitBlt.BITBLT[ptBBTable];  --move the actual bitmap    --let's see if we should build a leftover    IF ixTheoreticalLastScanInBandPlus1 > scanLinesPerBand THEN      RecordLeftOver[IF currentList = band THEN bandList ELSE readLO];    END;  -- of ProcessCharacter  ProcessEndOfBand: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    IF currentList = leftover THEN      BEGIN      levelLeftover ¬ LAST[Level];      currentList ¬ band;      leftoverDone ¬ TRUE;      -- don't bother bumping the input leftover list pointer, we're done with it      END    ELSE      BEGIN      levelBand ¬ LAST[Level];      currentList ¬ leftover;      bandDone ¬ TRUE;      -- DON'T bump the input pointer, the client will      END;    IF bandDone AND leftoverDone THEN RecordLeftOver[i];      -- move it to the leftover list for next time.  Only one endOfBand command,      -- the last one, is moved to the new leftover list.    END;  -- of ProcessEndOfBand  ProcessInkwell: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    IF currentList = band THEN      BEGIN      inkwellBand ¬ i.setInk.inknum*16;      dstFuncBand ¬ i.setInk.dstFunc;      srcFuncBand ¬ i.setInk.srcFunc;      END    ELSE      BEGIN      inkwellLeftover ¬ i.setInk.inknum*16;      dstFuncLeftover ¬ i.setInk.dstFunc;      srcFuncLeftover ¬ i.setInk.srcFunc;      END;    RecordLeftOver[i];    BumpInputPointer[SIZE[setInk BandBLT.BlItem]];    END;  -- of ProcessInkwell  ProcessLeftoverCharacter: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    fontEntry: FontEntry;    ixTheoreticalLastScanInBandPlus1: CARDINAL;    srcWordsPerLine: CARDINAL;    --calculate the bitmap pointer from the font and character code.    fontEntry ¬ fontRasters +        LONG[fontPointerTable[i.leftOverChar.font][i.leftOverChar.cc]]*2;    srcWordsPerLine ¬ (fontEntry.bitsPerLine + 15)/Environment.bitsPerWord;    ixTheoreticalLastScanInBandPlus1 ¬        fontEntry.scanLines - i.leftOverChar.scansToSkip;    ptBBTable­ ¬ [      dst: [        word: (bandBuf + (i.leftOverChar.yloc/Environment.bitsPerWord)),        reserved: 0,        bit: (i.leftOverChar.yloc MOD Environment.bitsPerWord)],      dstBpl: bitsPerScanLine,      src: [        word: (@fontEntry.bitMap + (i.leftOverChar.scansToSkip*srcWordsPerLine)),        reserved: 0,        bit: 0],      srcDesc: [srcBpl[srcBpl: srcWordsPerLine*Environment.bitsPerWord]],	--bits along the scan line of dest      width: fontEntry.bitsPerLine,  --bits along the scan line of dest      height: MIN[ixTheoreticalLastScanInBandPlus1, scanLinesPerBand],	--number of scan lines affected      flags: [        -- determines the BitBlt function        direction: forward,        disjoint: FALSE,        disjointItems: FALSE,        gray: FALSE,        srcFunc: null,        dstFunc: or,        reserved: 0        ],      reserved: 0      ];    ProcessCharacter[fontEntry, ixTheoreticalLastScanInBandPlus1];    BumpInputPointer[SIZE[leftOverChar BandBLT.BlItem]];    END;  -- of ProcessLeftoverCharacter  ProcessLevel: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    oldList: List ¬ currentList;    IF currentList = band THEN levelBand ¬ i.setLevel.levelnum    ELSE levelLeftover ¬ i.setLevel.levelnum;  --set the new level    -- change the current list if required    SELECT TRUE FROM      levelLeftover < levelBand => currentList ¬ leftover;      levelLeftover > levelBand => currentList ¬ band;      levelLeftover = levelBand => NULL;      ENDCASE;    IF currentList = oldList THEN {      -- We're not changing lists, so this set level command applies to the next      -- leftover we generate from the current list.      -- Thus we move the set level command to the leftover list and advance the      -- input pointer past it.      RecordLeftOver[i];      BumpInputPointer[SIZE[setLevel BandBLT.BlItem]]};    -- Note that we don't advance the input pointer if we change lists, since we    -- will want to write the set level command out to the leftover list when we    -- switch back to this list.    END;  -- of ProcessLevel  ProcessNormalEntity: PROCEDURE [thisItem: BandBLT.BandListItemLongPointer] =    BEGIN    SELECT command FROM      BandBLT.endOfBandCmd => ProcessEndOfBand[thisItem];      BandBLT.endOfPageCmd =>        BEGIN        bandDone ¬ leftoverDone ¬ TRUE;  -- cause us to return        bandList.ptr ¬ NIL;  -- mark end of page for client        END;      BandBLT.nopCmd => BumpInputPointer[SIZE[nop BandBLT.BlItem]];      BandBLT.rectangleCmd => ProcessRectangle[thisItem];      BandBLT.ruletteCmd => ProcessRulette[thisItem];      BandBLT.setInkCmd => ProcessInkwell[thisItem];      BandBLT.setLevelCmd => ProcessLevel[thisItem];      BandBLT.trapezoidCmd => ProcessTrapezoid[thisItem];      ENDCASE => ERROR;    END;  -- of ProcessNormalEntity  ProcessOneBandItem: PROCEDURE =    BEGIN    -- presume it's (arbitrarily) a rectangle, since it has a complete entry type    command ¬ bandList.rectangle.type;    IF command < BandBLT.endOfBandCmd THEN {      command ¬ BandBLT.charCmd; -- in case of a big font number      ProcessBandCharacter[bandList]}    ELSE ProcessNormalEntity[bandList];    END;  -- of ProcessOneBandItem  ProcessOneLeftoverItem: PROCEDURE =    BEGIN    -- presume it's (arbitrarily) a rectangle, since it has a complete entry type    command ¬ readLO.rectangle.type;    IF command < BandBLT.endOfBandCmd THEN {      command ¬ BandBLT.charCmd; -- in case of a big font number      ProcessLeftoverCharacter[readLO]}    ELSE ProcessNormalEntity[readLO];    END;  -- of ProcessOneLeftoverItem  ProcessRectangle: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    ixTheoreticalLastScanInBandPlus1: CARDINAL;    inkwell: CARDINAL;    dstFunc: BitBlt.DstFunc;    srcFunc: BitBlt.SrcFunc;    IF currentList = band THEN {      inkwell ¬ inkwellBand;      dstFunc ¬ dstFuncBand;      srcFunc ¬ srcFuncBand;      }    ELSE {      inkwell ¬ inkwellLeftover;      dstFunc ¬ dstFuncLeftover;      srcFunc ¬ srcFuncLeftover;      };    ixTheoreticalLastScanInBandPlus1 ¬ i.rectangle.nScans + i.rectangle.xloc;    ptBBTable­ ¬ [      dst: [          word: (bandBuf + (i.rectangle.xloc*wordsPerScanLine) +              (i.rectangle.yloc/Environment.bitsPerWord)),	      --position in destination          reserved: 0,          bit: (i.rectangle.yloc MOD Environment.bitsPerWord)],      dstBpl: bitsPerScanLine,      src: [        word: (inkwells + inkwell + i.rectangle.xloc),        reserved: 0,        bit: (i.rectangle.yloc MOD Environment.bitsPerWord)],      srcDesc: [gray[gray: [        reserved: 0,        yOffset: i.rectangle.xloc,        widthMinusOne: 0,  -- restricted to 0 for initial microcode implementations	  -- by PrincOps        heightMinusOne: 15]]],      width: i.rectangle.bitsPerScan,  --bits along the scan line of dest      height: (MIN[ixTheoreticalLastScanInBandPlus1, scanLinesPerBand] -          i.rectangle.xloc),  --number of scan lines affected      flags: [        -- determines the BitBlt function        direction: forward,        disjoint: FALSE,        disjointItems: FALSE,        gray: TRUE,        srcFunc: srcFunc,        dstFunc: dstFunc,        reserved: 0        ],      reserved: 0      ];    BitBlt.BITBLT[ptBBTable];  -- move the actual bitmap    --let's see if a leftover is needed    IF ixTheoreticalLastScanInBandPlus1 > scanLinesPerBand THEN RecordLeftOver[i];      --we need a leftover    BumpInputPointer[SIZE[rectangle BandBLT.BlItem]];    END;  -- of ProcessRectangle  ProcessRulette: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    ink: LONG POINTER;    ink ¬ inkwells + inkwellBand;  -- must be band, rulettes have no leftovers    ptBBTable­ ¬ [      dst: [        word: (bandBuf + (i.rulette.xloc*wordsPerScanLine) +	    (i.rulette.yloc/Environment.bitsPerWord)),        reserved: 0,        bit: (i.rulette.yloc MOD Environment.bitsPerWord)],      dstBpl: bitsPerScanLine,      src: [        word: (ink + i.rulette.xloc),        reserved: 0,        bit: (i.rulette.yloc MOD Environment.bitsPerWord)],      srcDesc: [gray[gray: [        reserved: 0,        yOffset: i.rulette.xloc,        widthMinusOne: 0, -- restricted to 0 for initial microcode implementations	  -- by PrincOps        heightMinusOne: 15]]],      width: i.rulette.length,      height: 1,      flags: [        -- determines the BitBlt function        direction: forward,        disjoint: FALSE,        disjointItems: FALSE,        gray: TRUE,        srcFunc: srcFuncBand,  -- must be band, rulettes never produce leftovers        dstFunc: dstFuncBand,  -- must be band, rulettes never produce leftovers        reserved: 0        ],      reserved: 0      ];    BitBlt.BITBLT[ptBBTable]; --move the actual bitmap    BumpInputPointer[SIZE[rulette BandBLT.BlItem]];    END; -- of ProcessRulette  ProcessTrapezoid: PROCEDURE [i: BandBLT.BandListItemLongPointer] =    BEGIN    dstFunc: BitBlt.DstFunc;    inkwell: CARDINAL;    ixTheoreticalLastScanInBandPlus1: CARDINAL;    scans: CARDINAL;    srcFunc: BitBlt.SrcFunc;    yMax: BandBLT.Interpolator ¬ i.trapezoid.yMax;    yMin: BandBLT.Interpolator ¬ i.trapezoid.yMin;    IF currentList = band THEN {      inkwell ¬ inkwellBand;      dstFunc ¬ dstFuncBand;      srcFunc ¬ srcFuncBand;      }    ELSE {      inkwell ¬ inkwellLeftover;      dstFunc ¬ dstFuncLeftover;      srcFunc ¬ srcFuncLeftover;      };    ixTheoreticalLastScanInBandPlus1 ¬ i.trapezoid.nScans + i.trapezoid.xloc;    scans ¬ MIN[ixTheoreticalLastScanInBandPlus1, scanLinesPerBand] -      i.trapezoid.xloc;  --number of scan lines affected in current band    FOR s: CARDINAL IN [0..scans) DO      currentXloc: CARDINAL ¬ i.trapezoid.xloc + s;      bitOffset: [0..Environment.bitsPerWord) ¬         yMin.val.int MOD Environment.bitsPerWord;      ptBBTable­ ¬ [	dst: [	  word: (bandBuf + (currentXloc*wordsPerScanLine) +	    (yMin.val.int/Environment.bitsPerWord)),	  reserved: 0,	  bit: bitOffset],	dstBpl: bitsPerScanLine,	src: [	  word: (inkwells + inkwell + currentXloc),	  reserved: 0,	  bit: bitOffset],	srcDesc: [gray[gray: [	  reserved: 0,	  yOffset: currentXloc,	  widthMinusOne: 0,  -- restricted to 0 for initial microcode	    -- implementations by PrincOps	  heightMinusOne: 15]]],	width: yMax.val.int - yMin.val.int,  --bits along the scan line of dest	height: 1,	flags: [	  -- determines the BitBlt function	  direction: forward,	  disjoint: FALSE,	  disjointItems: FALSE,	  gray: TRUE,	  srcFunc: srcFunc,	  dstFunc: dstFunc,	  reserved: 0],	reserved: 0];      BitBlt.BITBLT[ptBBTable];  -- move one scan line of the trapezoid      yMin.val.li ¬ yMin.val.li + yMin.dVal.li;      yMax.val.li ¬ yMax.val.li + yMax.dVal.li;      ENDLOOP;    IF ixTheoreticalLastScanInBandPlus1 > scanLinesPerBand      THEN RecordLeftOver[i: i, scansDone: scans, yMin: @yMin, yMax: @yMax];    BumpInputPointer[SIZE[trapezoid BandBLT.BlItem]];    END; -- of ProcessTrapezoid  RecordLeftOver: PROCEDURE [i: BandBLT.BandListItemLongPointer,    scansDone: CARDINAL ¬ 0,    yMin, yMax: LONG POINTER TO BandBLT.Interpolator ¬ NIL] =    -- This procedure delays writing setInk and setLevel commands to the leftover    -- list until a following item produces a leftover.  If no following item    -- produces a leftover, the setInk and setLevel commands serve no function in    -- the leftover list.    BEGIN    SELECT command FROM      BandBLT.charCmd => CreateCharacterLeftover[];      BandBLT.endOfBandCmd => writeLO.endOfBand­ ¬ i.endOfBand­;        -- don't bother bumping the output pointer, we're done      BandBLT.rectangleCmd => {        ForceOutInkAndLevel[];	writeLO.rectangle­ ¬ i.rectangle­;        writeLO.rectangle.xloc ¬ 0;  -- modify it to be a leftover        writeLO.rectangle.nScans ¬ writeLO.rectangle.nScans - ptBBTable.height;        writeLO.ptr ¬ writeLO.ptr + SIZE[rectangle BandBLT.BlItem]};      BandBLT.setInkCmd => lastSetInk.setInk ¬ i.setInk;      BandBLT.setLevelCmd => lastSetLevel.setLevel ¬ i.setLevel;      BandBLT.trapezoidCmd => {        ForceOutInkAndLevel[];	writeLO.trapezoid­ ¬ i.trapezoid­;	writeLO.trapezoid.xloc ¬ 0;	writeLO.trapezoid.nScans ¬ writeLO.trapezoid.nScans - scansDone;	writeLO.trapezoid.yMin ¬ yMin­;	writeLO.trapezoid.yMax ¬ yMax­;	writeLO.ptr ¬ writeLO.ptr + SIZE[trapezoid BandBLT.BlItem]};      ENDCASE => ERROR;  -- endOfPage, nops, and rulettes don't generate leftovers    END;  -- of RecordLeftOver	  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- Mainline Code  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  PrincOps.ESCTrapTable[ESCAlpha.aBANDBLT] ¬ LOOPHOLE[BANDBLT];  -- This installs the Mesa implementation in the trap table in case the  -- microcode does not implement BandBLT and instead tries to trap to Mesa.    END.  -- of BandBLTImplLOG12May82 - CRF - Created file starting from [Sun]<CharlieLevy>BandBltPack.mesa.28Feb83 - CRF - Fix gray brick alignment in ProcessRectangle and ProcessRulette.22Jul83 - BChang12Jan84 - Castillo - Changed name from BandBLTImpl; added command ¬ BandBLT.charCmd in ProcessOneBandItem & ProcessOneLeftoverItem.10Jul85 - castillo - copyright notice.15Jul86 - CRF - Added trapezoids; fixed warning by using Inline.LowHalf in scanLinesPerBand calculation.29Jul86 - CRF - Added default initialization of inkwell and source and destination functions to match the PrincOps and microcode implementation.30Jul86 - CRF - Corrected handling of nop band list items (must bump pointer).07Aug86 - CRF - Use "null" and "or" as source and destination functions, respectively, for characters, rather than the inkwell functions.05Sep86 - CRF - Changed name from MesaBandBLTImpl back to BandBLTImpl, now that SoftwareBandBLT is defined in BandBLT.mesa.  Added BANDBLT procedure and initialization code to install it in the Escape opcode trap table.  (Follows model of TextBltImpl.mesa.)08May87 - KEK - add bBTableSpacePtr in an attempt to outsmart MDS-relieved-labelless compiler that doesn't understand "@" is short.
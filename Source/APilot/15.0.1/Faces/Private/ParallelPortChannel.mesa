-- ParallelPortChannel.mesa-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.-- Revised by BKI:		           11-Apr-86 18:04:13-- Owner: CLDIRECTORY  Environment, Heap, Inline, ParallelPort, ParallelPortFace, ParallelPortFaceExtras, Process, SpecialRuntime;ParallelPortChannel: MONITOR  IMPORTS Heap, SpecialRuntime, ParallelPortFace, ParallelPortFaceExtras, Inline, Process  EXPORTS ParallelPort    =  BEGIN OPEN ParallelPort;    -- Pack Data Structure:  ChannelRec: TYPE = RECORD [    direction: Direction,    format: Format,    lptCond: LONG POINTER TO CONDITION _ NIL,    mask: WORD,    channelStatus: ChannelStatus,    commandStatus: ParallelPortFace.CommandStatus,    deviceStatus: DeviceStatus,    lock: BOOLEAN _ FALSE,    abortAllTransfers: BOOLEAN _ FALSE,    block: Environment.Block,    bvFirstByte, bvLastByte: BOOLEAN,    firstByte, lastByte: Environment.Byte,    transferRecord: ParallelPortFace.TransferRec,    condReBroadcast: CONDITION,    processCatcher: PROCESS _ NIL,    cvTestCount: CARDINAL _ 25];  Channel: TYPE = LONG POINTER TO ChannelRec;    InvalidChannelHandle, OverlapNotPermitted, NotImplemented: ERROR = CODE;     channelCur: Channel _ NIL;  bvGoHome: BOOLEAN;  --has to be outside of channel  bvMultiple: BOOLEAN = TRUE;  --If true, will deal with multiple page block by breaking them up. If false, blocks are restricted to one memory page. Starting testing with this false, and giving it small blocks.  bvReallySend: BOOLEAN _ TRUE;  bvEnforce: BOOLEAN _ TRUE;  --enforce the 20uSec rule  createFailedReason: ChannelStatus _ ok;  --temporary for CL      -- Signals and Errors:  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----   -- Public Operations  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----   Create: PUBLIC PROC [direction: Direction, format: Format]       RETURNS [channel: ChannelHandle, channelStatus: ChannelStatus] =     BEGIN     IF channelCur # NIL THEN RETURN [NIL, channelAlreadyCreated];     bvGoHome _ FALSE;     channelCur _ channel _ Heap.systemZone.NEW[ChannelRec];     [channelCur.lptCond, channelCur.mask] _ SpecialRuntime.AllocateNakedCondition[];     Process.SetTimeout[channelCur.lptCond, Process.MsecToTicks[1000]];     channelCur.direction _ direction;      channelCur.format _ format;     channelCur.processCatcher _ FORK CatcherProcess[];     channelCur.commandStatus _ ParallelPortFace.Initialize[channelCur.mask];     SELECT channelCur.commandStatus FROM       rejected => {channelStatus _ notRegistered; GOTO createFailed};       ready => NULL;       ENDCASE => ERROR;     IF NOT ParallelPortFaceExtras.ParallelPortExists[] THEN       {channelStatus _ noParallelHardware; GOTO createFailed};     channelCur.commandStatus _ ParallelPortFace.InitiateReset[];     IF channelCur.commandStatus # inProgress THEN ERROR;     WaitTillPortWasReset[];     ParallelPortFace.UpdateStatus[];     WaitTillStatusBack[];     channelCur.deviceStatus _ ParallelPortFace.GetStatus[];       IF NOT channelCur.deviceStatus.fault AND channelCur.deviceStatus.select AND     channelCur.deviceStatus.busy THEN       --don't invalidate handle; Diagnostics might want to call Test--       {channelCur.channelStatus _ channelStatus _ noDeviceAttached; RETURN};     channelCur.channelStatus _ channelStatus _ ok;     --CAUTION, the following three constants are device dependent!!!!!     IF format = centronicsWithBusy THEN       {channelCur.transferRecord.useAck _ FALSE;       channelCur.transferRecord.enforce20uSecRule _ bvEnforce;       channelCur.transferRecord.clockCounter _ LAST[ParallelPortFace.Period];}     ELSE       {channelCur.transferRecord.useAck _ TRUE;       channelCur.transferRecord.enforce20uSecRule _ FALSE;       channelCur.transferRecord.clockCounter _ LAST[ParallelPortFace.Period];};     EXITS       createFailed => {         -- note that this code is very similar to Delete --         bvGoHome _ TRUE;	 BroadcastGoHome[];	 JOIN channelCur.processCatcher; channelCur.processCatcher _ NIL;	 SpecialRuntime.DeallocateNakedCondition[channelCur.lptCond];         Heap.systemZone.FREE[@channelCur];  --side effect: channelCur _ NIL	 channel _ NIL;	 createFailedReason _ channelStatus;  --temporary for CL         };     END;  --of Create OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  Delete: PUBLIC PROC [channel: ChannelHandle] =     BEGIN    IF channel # channelCur OR channel = NIL THEN ERROR InvalidChannelHandle;    channelCur.abortAllTransfers _ TRUE;    --Reset will quiesce parallel port and abort an inProgress transfer--    channelCur.commandStatus _ ParallelPortFace.InitiateReset[];    IF channelCur.commandStatus # inProgress THEN ERROR;    WaitTillPortWasReset[];    --Send waiting processes home--    bvGoHome _ TRUE;    BroadcastGoHome[];    --Wait until client goes home--    WHILE channelCur.lock DO Process.Pause[Process.MsecToTicks[50]] ENDLOOP;    --Wait until catcherProcess dies--    JOIN channelCur.processCatcher; channelCur.processCatcher _ NIL;    --At this point, nobody else except me should be accessing channelCur--    SpecialRuntime.DeallocateNakedCondition[channelCur.lptCond];    Heap.systemZone.FREE[@channelCur];  --side effect: channelCur _ NIL    END;  -- of Delete OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  PutBlock: PUBLIC PROC [channel: ChannelHandle, block: Environment.Block]       RETURNS [transferStatus: TransferStatus] =     BEGIN    IF channel # channelCur OR channel = NIL THEN ERROR InvalidChannelHandle;    IF channelCur.lock THEN ERROR OverlapNotPermitted;    channelCur.lock _ TRUE;    channelCur.block _ block;    ModifyBlock[];  --to handle odd bytes at front and back    IF channelCur.bvFirstByte THEN      BEGIN      channelCur.transferRecord.transferMode _ putByte;      channelCur.transferRecord.byteData _ channelCur.firstByte;      DoSynchronousTransfer[];      END;    IF channelCur.block.startIndex # channelCur.block.stopIndexPlusOne THEN      BEGIN      channelCur.transferRecord.transferMode _ putBlock;      channelCur.transferRecord.bufferPtr _ @channelCur.block;      IF bvMultiple THEN DoMultipleTransfers[] ELSE DoSynchronousTransfer[];      END;    IF channelCur.bvLastByte THEN      BEGIN      channelCur.transferRecord.transferMode _ putByte;      channelCur.transferRecord.byteData _ channelCur.lastByte;      DoSynchronousTransfer[];      END;    channelCur.lock _ FALSE;    transferStatus _ success;    END;  -- of PutBlock OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  GetBlock: PUBLIC PROC [channel: ChannelHandle, block: Environment.Block]       RETURNS [transferStatus: TransferStatus] =     BEGIN    ERROR NotImplemented;    END;  -- of GetBlock OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  GetStatus: PUBLIC PROC [channel: ChannelHandle] RETURNS [deviceStatus: DeviceStatus] =    BEGIN    IF channel # channelCur OR channel = NIL THEN ERROR InvalidChannelHandle;    ParallelPortFace.UpdateStatus[];    WaitTillStatusBack[];    deviceStatus _ channelCur.deviceStatus _ ParallelPortFace.GetStatus[];    END;  -- of GetStatus OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  StatusWait: PUBLIC PROC [channel: ChannelHandle, deviceStatus: DeviceStatus] RETURNS [newDeviceStatus: DeviceStatus] =     BEGIN    IF channel # channelCur OR channel = NIL THEN ERROR InvalidChannelHandle;    <<ParallelPortFace.UpdateStatus[];  --just once>>    DO       IF bvGoHome THEN RETURN;       <<WaitTillStatusBack[];  --either because of the above call,  or a change in status>>       --we get here on completion of every transfer. Is the GetStatus expensive?       channelCur.deviceStatus _ newDeviceStatus _ ParallelPortFace.GetStatus[];       IF newDeviceStatus # deviceStatus THEN RETURN;       Process.Pause[Process.MsecToTicks[250]];       ENDLOOP;    END;  -- of StatusWait OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  Test: PUBLIC PROC [channel: ChannelHandle] RETURNS [hardwareReliabilty: HardwareReliability] =     BEGIN    returnPattern: WORD;    commandStatusCur: ParallelPortFace.CommandStatus;    ctErrors: LONG CARDINAL _ 0;    IF channel # channelCur OR channel = NIL THEN ERROR InvalidChannelHandle;    IF channelCur.lock THEN ERROR OverlapNotPermitted;    channelCur.lock _ TRUE;    THROUGH [0..channelCur.cvTestCount) DO      dataPattern: MACHINE DEPENDENT RECORD [        high(0:0..7): Environment.Byte,	low(0:8..15): Environment.Byte];      FOR i: Environment.Byte IN [0..LAST[Environment.Byte]] DO        dataPattern _ [high: i, low: Inline.BITNOT[i]];	IF channelCur.abortAllTransfers THEN GOTO aborted;        commandStatusCur _ ParallelPortFace.InitiateTest[LOOPHOLE[dataPattern]];        IF commandStatusCur # inProgress THEN ERROR;        WaitTillTestDone[];        returnPattern _ ParallelPortFace.GetTestResult[];        IF returnPattern # LOOPHOLE[dataPattern,WORD] THEN	  ctErrors _ ctErrors + 1;        ENDLOOP;      REPEAT aborted => NULL;      ENDLOOP;    hardwareReliabilty _ SELECT ctErrors FROM      0 => perfect,      Inline.LongMult[256,channelCur.cvTestCount] => broken,      ENDCASE => flaky;    channelCur.lock _ FALSE;    END;  -- of Test OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----   -- Private Procedures  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ModifyBlock: PROC =    BEGIN    -- here, check to see if the block start or ends with an odd byte, and modify the block, so that we can use word boundaries only in most moves    channelCur.bvFirstByte _ channelCur.bvLastByte _ FALSE;    IF channelCur.block.startIndex MOD 2 # 0 THEN      BEGIN      channelCur.bvFirstByte _ TRUE;      channelCur.firstByte _ channelCur.block.blockPointer[channelCur.block.startIndex];      channelCur.block.startIndex _ channelCur.block.startIndex + 1;      END;    IF channelCur.block.stopIndexPlusOne MOD 2 # 0 THEN      BEGIN      channelCur.bvLastByte _ TRUE;      channelCur.lastByte _ channelCur.block.blockPointer[channelCur.block.stopIndexPlusOne - 1];      channelCur.block.stopIndexPlusOne _ channelCur.block.stopIndexPlusOne - 1;      END;    END;  --of ModifyBlock OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  DoMultipleTransfers: PROC =    BEGIN    blockSmall: Environment.Block;    ptrStartLarge, ptrEndLarge, ptrCurLarge: LONG POINTER;    ptrStartSmall, ptrEndSmall: LONG POINTER;    -- the "large" block is in channelCur    -- we've got to fill in channelCur.transferRecord.bufferPtr _ @blockSmall many times    -- we know odd bytes have already been removed    ptrStartLarge _ ptrCurLarge _ channelCur.block.blockPointer + (channelCur.block.startIndex / 2);    ptrEndLarge _ channelCur.block.blockPointer + (channelCur.block.stopIndexPlusOne / 2);    DO  --fill in blockSmall       blockSmall.blockPointer _ LOOPHOLE[LOOPHOLE[ptrCurLarge, LONG CARDINAL] - (LOOPHOLE[ptrCurLarge, LONG CARDINAL] MOD 256)];  --point to bottom of page       ptrEndSmall _ LOOPHOLE[MIN[LOOPHOLE[ptrEndLarge, LONG CARDINAL], LOOPHOLE[(blockSmall.blockPointer + 256), LONG CARDINAL]]];       ptrStartSmall _ LOOPHOLE[MAX[LOOPHOLE[ptrCurLarge, LONG CARDINAL], LOOPHOLE[(blockSmall.blockPointer), LONG CARDINAL]]];       blockSmall.stopIndexPlusOne _ Inline.LowHalf[(ptrEndSmall - blockSmall.blockPointer) * 2];       blockSmall.startIndex _ Inline.LowHalf[(ptrStartSmall - blockSmall.blockPointer) * 2];       channelCur.transferRecord.bufferPtr _ @blockSmall;       DoSynchronousTransfer[];       ptrCurLarge _ blockSmall.blockPointer + 256;       IF LOOPHOLE[ptrCurLarge, LONG CARDINAL] >= LOOPHOLE[ptrEndLarge, LONG CARDINAL] THEN EXIT;       ENDLOOP;    END;  --of DoMultipleTransfers OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  DoSynchronousTransfer: PROC =    BEGIN    commandStatusCur: ParallelPortFace.CommandStatus;    IF channelCur.abortAllTransfers OR NOT bvReallySend THEN RETURN;    commandStatusCur _ ParallelPortFace.InitiateTransfer[channelCur.transferRecord];    IF commandStatusCur # inProgress THEN ERROR;    <<IF commandStatusCur # inProgress THEN     	WHILE commandStatusCur # inProgress	DO commandStatusCur _ ParallelPortFace.InitiateTransfer[channelCur.transferRecord]	ENDLOOP;  --Jon's extra test>>    WaitTillTransferDone[];    END;  --of DoSynchronousTransfer  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  WaitTillTransferDone: ENTRY PROC =    BEGIN    transferStatusCur: ParallelPortFace.TransferStatus;    DO       transferStatusCur _ ParallelPortFace.GetTransferStatus[];       IF transferStatusCur = success OR transferStatusCur = aborted THEN RETURN[];       WAIT channelCur.condReBroadcast;  --inProgress or incomplete       IF bvGoHome THEN RETURN;       ENDLOOP;    END;  -- of WaitTillTransferDone OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  WaitTillStatusBack: ENTRY PROC =    BEGIN    DO       WAIT channelCur.condReBroadcast;       channelCur.deviceStatus _ ParallelPortFace.GetStatus[];       IF channelCur.deviceStatus.statusIsUpToDate OR bvGoHome THEN RETURN;  --with status in channelCur.deviceStatus       ENDLOOP;    END;  -- of WaitTillStatusBack OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  WaitTillPortWasReset: ENTRY PROC =    BEGIN    DO       WAIT channelCur.condReBroadcast;       channelCur.deviceStatus _ ParallelPortFace.GetStatus[];       IF channelCur.deviceStatus.portWasReset OR bvGoHome THEN RETURN;         ENDLOOP;    END;  -- of WaitTillPortWasReset OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  WaitTillTestDone: ENTRY PROC =    BEGIN    DO       WAIT channelCur.condReBroadcast;       channelCur.deviceStatus _ ParallelPortFace.GetStatus[];       IF channelCur.deviceStatus.testResultIsUpToDate OR bvGoHome THEN RETURN;         ENDLOOP;    END;  -- of WaitTillTestDone OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  CatcherProcess: ENTRY PROC =    BEGIN  --re-braodcasts the naked notify to all WAITers    Process.SetPriority[5];    UNTIL bvGoHome DO       WAIT channelCur.lptCond^;       BROADCAST channelCur.condReBroadcast;       ENDLOOP;    END;  -- of CatcherProcess OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  BroadcastGoHome: ENTRY PROC =    BEGIN    BROADCAST channelCur.condReBroadcast;    END;  -- of BroadcastGoHome OK  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----      -- Mainline Code  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----   END.  -- of ParallelPortChannel     LOGCL  11-Oct-85  created module 13-Nov-85 various changes to def, added SetTimouts 2-Dec-85 CL and JMA merged into mostly hacked version 22-Dec-85 CL put all synchronous transfers on Bolean for testing23-Dec-85 CL put in MakeHeadResident[] Proc in attempt to eliminate crashes in BandBLT27-Dec-85 CL timing of Initiate Transfer......hmmm, December 28 must have removed timing of Initiate Transfer....that's OK. CL, 3-Mar-863-Mar-86 CL put enforcing of the 20uSec rule on a boolean. NIL'd channel upon bad Create.12-Mar-86 CL rasised priority of CatcherProcess to 521-Mar-86 BKI Create implements notRegistered return value. Create returns valid handle even if noDeviceAttached (for Diagnostics). Create cleans up some if not successful. Test uses more data patterns, and runs for about ten seconds.31-Mar-86 CL made WaitTillStatusBack RETURN if bvGoHome (AR 9285) 4-Apr-86 BKI Move MakeHeadResident function to Head (part of AR 9138).  Finish Create clean-up (AR 9210).  In Delete PROC, deallocate naked CV later.  Create returns noParallelHardware (AR 9047). 8-Apr-86 BKI In Create, fix test for noDeviceAttached (AR 9295). 8-Apr-86 CL modified StatusWait 9-Apr-86 CL modified StatusWait to save status in channel record11-Apr-86 BKI Delete quiesces parallel port (AR 9303).11-Apr-86 BKI Delete sends everybody home. Check for NIL ChannelHandle arguments (AR 9319).
-- File: UserTerminalHeadDove.mesa - last edit:-- KXW                  7-Nov-86 17:43:31-- This head contains both the Dove Display Head and the Dove Keyboard/Mouse head.-- Copyright (C) 1986 by Xerox Corporation. All rights reserved.-- Created by AnK on 22-Aug-84 15:08:44--  Uses Opie version 22--  This is Mesa 12.0---- Last edited by--   KXW:	  7-Nov-86 17:45:06	:Fix bug in GetDisplayAlignmentData and modify GetAlignmentsFromBytes.--   MXT:	 19-Aug-86 14:40:00	:Corrected Bitmap vs Cursor mix rule for Daisy.--   MXT:	 17-Jun-86 18:06:55	:Added return value to NotifyDisplayAlignment--   MXT:	  2-Jun-86 16:10:20	:Changed video-cursor mixrule for Daisy.--   MXT:	  5-May-86 16:37:56	:Added GetMicrocodeVersion in NotifyDisplayAlignment--   MXT:	 29-Apr-86  9:18:40	:Added GetDisplayAlignmentData and NotifyDisplayAlignment for Display re-alignment (Daisy).--   JPM:	  9-Sep-85 13:10:39	:Fix bug in cleanup proc.--   JPM:	 29-Jul-85  9:44:44	:Opie redesign conversion.--   JGS:	 25-Feb-85 16:39:51	:add some of DEG's fixes.--   AnK:	 18-Feb-85 15:01:27	:Fixed bug in world swaps.  Also, added keyMoFCB stuff.--   AnK:	 25-Jan-85 10:23:31	:Implemented procedures GetBorderPattern--					:   and GetCursonPattern.--   AnK:	 9-Jan-85 15:38:09	:Implemented special bit in the upNotifyBits for Daisy.--					:Took out cursor location conversion (from pixels to--					: word and offset for the x-coordinate, and from pixels--					: to 4-bit and 6-bit units for the y-coordinate.  This--					: is now done in the display handler.--					:Took out limits check on the cursor position.  This--					: is now done in the display handler.--					:Changed name of map variable to cursorPattern.--					:Fixed initialization of the display background.--   AnK:	 5-Dec-84 10:27:00	:Put Init. of global variables back, Fixed data mixes--					: in SetBackground and let x and y cursor position go--					: 15 bits into border.--   AnK:	 2-Nov-84 18:18:43	:Updated for Opie 16--   AxR: 	28-Nov-84  9:51:06	:Temporarily init. global vars in Initialize due to--					: start trap--   AxR:	 7-Nov-84 13:37:58	:Continued setting-up for Real Environment--   AnK:	 2-Nov-84 18:18:43	:Took out cludges that were added for remote heads--   AxR:	 2-Nov-84 11:01:29--   AnK:	17-Oct-84 10:07:01	:Added check for cursor location, and recompiled for--					: other changes--   AnK:	13-Oct-84 12:58:23	:Deleted RemoteDoveInputOutput--   AnK:	 5-Oct-84 15:34:16	:Added RemoteDoveInputOutput--   AnK:	12-Sep-84  9:06:10	:Included byte swapping procedures--   AnK:	12-Sep-84  9:06:10<<	Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.		The following program was created in 1984 but has not been published within the meaning of the	copyright law, is furnished under license, and may not be used, copied and/or disclosed except	in accordance with the terms of said license.	>>DIRECTORY  BeepFace,  BeepIOFaceDove,  BitBlt,  DeviceCleanup USING [Await, Item, Reason],  DisplayFace,  DisplayFaceExtras,  DisplayIOFaceDove,  DisplaySpecialFaceDaisy,  DoveHandlerIDs USING [beep, display, keyboardAndMouse],  DoveInputOutput USING [BuildMesaClientCondition, ByteSwap, ByteSwappedWord,    ClientCondition, firstReservedPage, GetHandlerIORegionPtr, GetIORegionOffset, GetMicrocodeVersion,    LockMem, NotifyIOP, SetReservedMemoryUse, TaskContextBlock],  Environment USING [    BitAddress, Base, bitsPerWord, Byte, LongPointerFromPage, PageCount,    PageFromLongPointer, PageNumber, wordsPerPage],  HeadStartChain,  Inline USING [BITAND, BITOR, LongCOPY, LongDiv, LowByte, LowHalf],  KeyboardFace,  KeyMoIOFaceDove,  MouseFace,  PageMap USING [flagsVacant, flagsClean, RealPageNumber, SetMapFlags],  ProcessorFace USING [reservedNakedNotifyMask];  UserTerminalHeadDove: PROGRAM  IMPORTS BitBlt, DeviceCleanup, DoveInputOutput, Environment, Inline,    RemainingHeads: HeadStartChain, PageMap, ProcessorFace  EXPORTS BeepFace, DisplayFace, DisplayFaceExtras, DisplaySpecialFaceDaisy, HeadStartChain, KeyboardFace, MouseFace  SHARES PageMap =  BEGIN OPEN Environment, BeepIOFaceDove, DisplayFace, DisplayIOFaceDove, KeyMoIOFaceDove;  -- **************************************************************************************   << Global variables used to keep old border pattern when display is turned off.    When display is disconnected set the border pattern to a constant 0, 0 so that one can read the cursor. >>    savedOddPairs, savedEvenPairs: [0..377B] ¬ 0;    -- DisplayFace CONSTANTS      -- Masks for setting bits in chngdInfo field of FCB      cursorPosChangedMask: DoveInputOutput.ByteSwappedWord  ¬ DoveInputOutput.ByteSwap[32768];    								-- 1000 0000 0000 0000, Set b15								    cursorMapChangedMask: DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[16384];    								-- 0100 0000 0000 0000, Set b14								    borderPatChangedMask: DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[8192];    								-- 0010 0000 0000 0000, Set b13								    backGrndChangedMask:  DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[4096];    								-- 0001 0000 0000 0000, Set b12								    displInfoChangedMask: DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[2048];    								-- 0000 1000 0000 0000, Set b11								    pictureBorderPatChangedMask: DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[10240];    								-- 0010 1000 0000 0000, Set b13 and b11    alignmentChangedMask: DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[1024];								    								-- 0000 0100 0000 0000, Set b10    allInfoChangedMask: DoveInputOutput.ByteSwappedWord ¬ DoveInputOutput.ByteSwap[63488];    								-- 1111 1100 0000 0000, Set b15, b14, b13, b12, b11, b10-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   -- DisplayFace VARIABLES     -- Get fixed location for displayFCB  displayFCB: LONG POINTER TO displayFunctionContextBlock ¬         DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.display];  -- Set up pointer to client condition.  vertCondPtr: LONG POINTER TO DoveInputOutput.ClientCondition ¬ @displayFCB.vertRetraceEvent;  cursor: DisplayFace.Point;   cursorPosition: PUBLIC LONG POINTER TO READONLY Point ¬ @cursor;    displayHeight: CARDINAL [0..32767] ¬ DoveInputOutput.ByteSwap[displayFCB.crtConfig.numberDisplayLines];        globalStateSize: PUBLIC CARDINAL ¬ 0;    --  This constant is used by the face, so it is maintained in this head.    --  But it is not needed for Dove.    hasBorder: PUBLIC BOOLEAN ¬ TRUE;  hasBuffer: PUBLIC BOOLEAN ¬ TRUE;  height: PUBLIC CARDINAL [0..32767] ¬ displayHeight;  interlaced: PUBLIC BOOLEAN ¬ IF (Inline.BITAND[displayFCB.crtConfig.configInfo, interlacedMask] > 0)  				THEN TRUE ELSE FALSE;    pixelsPerInch: PUBLIC CARDINAL ¬ displayFCB.crtConfig.pixels;  refreshRate: PUBLIC CARDINAL ¬ displayFCB.crtConfig.refresh;    scrollXQuantum: PUBLIC CARDINAL ¬ 1; -- **** Used by face **** --  scrollYQuantum: PUBLIC CARDINAL ¬ 2;  scrollingInhibitsCursor: PUBLIC BOOLEAN ¬ TRUE;    width: PUBLIC CARDINAL [0..32767] ¬ DoveInputOutput.ByteSwap[displayFCB.crtConfig.numberBitsPerLine];  patchBufferSize: CARDINAL ¬ 16;  pagesForCursorBuffer: Environment.PageCount ¬    (patchBufferSize*(width/bitsPerWord) + wordsPerPage - 1)/wordsPerPage;  -- DeleteScrollWindow uses CursorBuffer.  pagesForBitmap: PUBLIC Environment.PageCount ¬    ((height*(width/bitsPerWord) + wordsPerPage - 1)/wordsPerPage) + pagesForCursorBuffer;  wordsPerLine: CARDINAL ¬ width/bitsPerWord;    xCursorOffset: WORD;  -- Offsets for x and y coordinates of cursor position  yCursorOffset: WORD;  bitmapAddress: LONG POINTER ¬ NIL;    borderSwapped: BOOLEAN ¬ FALSE;      -- scroll VARIABLES  bbTableSpace: BitBlt.BBTableSpace;  bb: BitBlt.BBptr;  -- This is how the BitBlt Table is set up:  -- BBTable, BitBltTable: TYPE = MACHINE DEPENDENT RECORD [  --   dst: BitAddress,  --   dst.word: LONG POINTER,  set by Scroll or DeleteScrollWindow to dest    --     dst.reserved: [0..LAST[WORD]/bitsPerWord), Initialize sets to 0  --     dst.bit: [0..bitsPerWord),  set by CreateScrollWindow to firstPatchBit  --   dstBpl: INTEGER,  set by Initialize to width (of display)  --   src: BitAddress,  --     src.word: LONG POINTER,  set by Scroll or DeleteScrollWindow to source  --     src.reserved: [0..LAST[WORD]/bitsPerWord),  set by Initialize to 0  --     src.bit: [0..bitsPerWord),  set by Scroll to line.bit or DeleteScrollWindow to firstPatchBit  --   srcDesc.srcBpl: INTEGER,  set by Scroll to increment*bitsPerWord,  --        set by DeleteScrollWindow to width (of display)  --   width: CARDINAL,  set by CreateScrollWindow to w (Width of scroll window)  --   height: CARDINAL,  set by Scroll or DeleteScrollWindow to count  --   flags: BitBltFlags,  set up by Initialize  --   reserved: UNSPECIFIED  Initialize sets to 0];  -- DisplayFace PUBLIC PROCEDURES  Connect: PUBLIC PROC [bitMap: PageNumber] =    BEGIN    real: PageMap.RealPageNumber ¬ DoveInputOutput.firstReservedPage;    DoveInputOutput.SetReservedMemoryUse[Display];    FOR virtual: PageNumber IN [bitMap..bitMap + pagesForBitmap) DO      PageMap.SetMapFlags[        virtual: virtual, real: real, flags: PageMap.flagsClean];      real ¬ real + 1;      ENDLOOP;    bitmapAddress ¬ Environment.LongPointerFromPage[bitMap];    bitmapAddress­ ¬ 0;    Inline.LongCOPY[      from: bitmapAddress, nwords: CARDINAL[pagesForBitmap]*wordsPerPage - 1,      to: bitmapAddress + 1];    TurnOn[];    END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  CreateScrollWindow: PUBLIC PROCEDURE[locn:Point, w:CARDINAL, h:CARDINAL] =    BEGIN    -- Normally this procedure would define an area in the bitmap that can be scrolled up or down.    -- But, temporarily, it is a dummy procedure to allow this code to compile and bind.    tempCreateScroll:CARDINAL ¬ 0;        tempCreateScroll ¬ tempCreateScroll + 1;        END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   DeleteScrollWindow: PUBLIC PROCEDURE =     BEGIN    --Normally this procedure would delete the scroll window.    -- But, temporarily, it is a dummy procedure to allow this code to compile and bind.    tempDeleteScroll:CARDINAL ¬ 0;        tempDeleteScroll ¬ tempDeleteScroll + 1;        END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  Disconnect: PUBLIC PROC =    BEGIN    p: LONG CARDINAL = Environment.PageFromLongPointer[bitmapAddress];    TurnOff[];    IF bitmapAddress # NIL THEN      FOR virtual: PageNumber IN [p..p + pagesForBitmap) DO        PageMap.SetMapFlags[          virtual: virtual, real: NULL, flags: PageMap.flagsVacant]        ENDLOOP;    bitmapAddress ¬ NIL;    DoveInputOutput.SetReservedMemoryUse[notBusy];    END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  GetBitBltTable: PUBLIC PROC RETURNS [BitBlt.BBTable] =    BEGIN    RETURN[      [        dst: [word: bitmapAddress, bit: 0], dstBpl: width,        src: [word: bitmapAddress, bit: 0], srcDesc: [srcBpl[width]],        width: width, height: height, flags: []]]    END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  GetBorderPattern: PUBLIC PROC RETURNS [oddPairs, evenPairs: [0..377B]] =    BEGIN    [oddPairs, evenPairs] ¬ displayFCB.border;    RETURN[oddPairs, evenPairs];    END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  GetCursorPattern: PUBLIC PROC RETURNS [cursorPtr: DisplayFace.CursorPtr] =    BEGIN    cursorPtr ¬ @displayFCB.cursorPattern;    RETURN[cursorPtr];    END;  Initialize: PUBLIC PROC [    globalState: DisplayFace.GlobalStatePtr, wakeVF: WORD] =    BEGIN       displayFCB.cursorXCoord ¬ 0;     displayFCB.cursorYCoord ¬ 0;          displayFCB.border ¬ [252B, 125B];		-- Speckled pattern      displayFCB.cursorPattern ¬ ALL[0];		-- Solid white cursor          displayFCB.displCntl.dataCursor ¬ 1; -- same mixRule for both Daisy and Daybreak       --  Non-inverted video, non-inverted cursor, ORed     displayFCB.displCntl.picture ¬ Picture;     displayFCB.displCntl.unusedB2 ¬ 1;          displayFCB.mixRule ¬ 8;          -- Pass notify mask on to handler.     -- Since Daisy uses the display's vertical retrace interrupt to trigger process timeouts,     --     an addition bit needs set in the upNotifyBits.     --    (The additional bit is provided in reservedNakedNotifyMask).     -- Note that Daybreak does not use this bit.     DoveInputOutput.BuildMesaClientCondition[vertCondPtr, Inline.BITOR[wakeVF, ProcessorFace.reservedNakedNotifyMask]];          LOOPHOLE[cursorPosition, LONG POINTER TO DisplayFace.Point]­ ¬ [0, 0];          -- Do necessary byte swapping for the x and y coordinates of cursor locn offsets     xCursorOffset ¬ DoveInputOutput.ByteSwap[displayFCB.crtConfig.xCoordOffset];     yCursorOffset ¬ DoveInputOutput.ByteSwap[displayFCB.crtConfig.yCoordOffset];          -- Set up bit map stuff    bb ¬ BitBlt.AlignedBBTable[@bbTableSpace];    bb.src.reserved ¬ 0;    bb.dst.reserved ¬ 0;    bb.dstBpl ¬ INTEGER[width];    bb.flags ¬ [      direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,      srcFunc: null, dstFunc: null, reserved: 0];    END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  InitializeCleanup: PUBLIC PROC =	-- Display/Raven?/Sound Generator cleanup Proc --    BEGIN OPEN DeviceCleanup;    fcbState: displayFunctionContextBlock;    oldPosition: Position;        --sgcsbStateCommand: pSGCommand;    item: Item;        DO      reason: Reason = Await[@item];      SELECT reason FROM              turnOff, kill => {          fcbState ¬ displayFCB­; -- Save state of display	  	  displayFCB.border ¬ [0, 0];	  displayFCB.displCntl.picture ¬ Border;  --  (Daybreak)          -- displayFCB.***.*** ¬ FALSE;             (Daisy)      *****  TBD *****                --  Set flag to indicate change in border and put border across display.          --  The pictureBorderPatChangedMask is already byte swapped         --  Use Mesa machine code to get lock while setting changed flags; result returned is unused.         [] ¬ DoveInputOutput.LockMem              [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], pictureBorderPatChangedMask, displayFCB.displayLock];	             	 oldPosition ¬ position­;	-- Save old position of mouse	 InlineBeepOff[];		-- Turn off speaker 	 };	            turnOn => {	  LOOPHOLE[position, LONG POINTER TO MouseFace.Point]­ ¬ oldPosition;	-- Restore old mouse position	  InlineBeepOff[];		-- Turn off speaker	            -- Restore state of display          displayFCB­.vertRetraceEvent ¬ fcbState.vertRetraceEvent;	  displayFCB­.cursorXCoord ¬ fcbState.cursorXCoord;	  displayFCB­.cursorYCoord ¬ fcbState.cursorYCoord;<<	  displayFCB­.border ¬ fcbState.border;  -- done by InlineTurnOn >>	  displayFCB­.cursorPattern ¬ fcbState.cursorPattern;	  displayFCB­.displCntl ¬ fcbState.displCntl;	  displayFCB­.mixRule ¬ fcbState.mixRule;	  InlineTurnOn[]};			-- And restore display screen	          disconnect =>          IF bitmapAddress # NIL THEN            BEGIN            p: LONG CARDINAL = Environment.PageFromLongPointer[bitmapAddress];            FOR virtual: PageNumber IN [p..p + pagesForBitmap) DO              PageMap.SetMapFlags[                virtual: virtual, real: NULL, flags: PageMap.flagsVacant]              ENDLOOP;            END;        ENDCASE;      ENDLOOP;    END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =       Scroll: PUBLIC PROCEDURE[    line:Environment.BitAddress, lineCount: CARDINAL, increment: INTEGER] =    BEGIN    --Normally this procedure would scroll the display as needed.    -- But, temporarily, it is a dummy procedure to allow this code to compile and bind.    tempScroll:CARDINAL ¬ 0;        tempScroll ¬ tempScroll + 1;        END;    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   SetBackground: PUBLIC PROC [b: DisplayFace.Background] =    BEGIN              IF (b = black) THEN        {	--  Invert video, invert cursor, OR,	E hex	displayFCB.displCntl.dataCursor ¬ 14;	--displayFCB.mixRule ¬ 14; 			-- default invert (Daisy)	}     ELSE -- b = white --	{        --  Non-invert video, Non-invert cursor, OR	displayFCB.displCntl.dataCursor ¬ 1;	--displayFCB.mixRule ¬ 1;	};	       --  Set flag to indicate change in backgrnd to handler.       --  The backGrndChangedMask is already byte swapped       --  Use Mesa machine code to get lock while setting changed flag; result returned is unused.       [] ¬ DoveInputOutput.LockMem            [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], backGrndChangedMask, displayFCB.displayLock];              END;  -- SetBackground       -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  SetBorderPattern: PUBLIC PROC [oddPairs, evenPairs: [0..377B]] = {    InlineSetBorderPattern[savedOddPairs ¬ oddPairs, savedEvenPairs ¬ evenPairs]};      InlineSetBorderPattern: PROC [oddPairs, evenPairs: [0..377B]] = INLINE    BEGIN    displayFCB.border ¬ [oddPairs, evenPairs];      [] ¬ DoveInputOutput.LockMem[        or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo],        borderPatChangedMask, displayFCB.displayLock];    END;  -- InlineSetBorderPattern    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  SetCursorPattern: PUBLIC PROC [p: DisplayFace.CursorPtr] =    BEGIN        displayFCB.cursorPattern ¬ p­;          -- Set bit for a chng in cursor pattern    --  The cursorMapChangedMask is already byte swapped    --  Use Mesa machine code to get lock while setting changed flag; result returned is unused.    [] ¬ DoveInputOutput.LockMem         [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], cursorMapChangedMask, displayFCB.displayLock];           END;  -- SetCursorPattern    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  SetCursorPosition: PUBLIC PROC [cursor: DisplayFace.Point] =    BEGIN    displayFCB.cursorXCoord ¬ DoveInputOutput.ByteSwap[cursor.x];    displayFCB.cursorYCoord ¬ DoveInputOutput.ByteSwap[cursor.y];        -- Set bit for a chng in cursor position    --  The cursorPosChangedMask is already byte swapped    --  Use Mesa machine code to get lock while setting changed flag; result returned is unused.    [] ¬ DoveInputOutput.LockMem         [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], cursorPosChangedMask, displayFCB.displayLock];          LOOPHOLE[cursorPosition, LONG POINTER TO DisplayFace.Point]­ ¬ cursor;    -- Update cursor position for clients above the face.          END; -- SetCursorPosition    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  TurnOn: PUBLIC PROC = {InlineTurnOn[]};        InlineTurnOn: PROC = INLINE    BEGIN    InlineSetBorderPattern[oddPairs: savedOddPairs, evenPairs: savedEvenPairs];    -- Set bit for a chng in command    --  The allInfoChangedMask is already byte swapped    --  Use Mesa machine code to get lock while setting changed flags; result returned is unused.    [] ¬ DoveInputOutput.LockMem         [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], allInfoChangedMask, displayFCB.displayLock];    END;  -- TurnOn      -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  TurnOff: PUBLIC PROC = BEGIN InlineTurnOff[]; END;  InlineTurnOff: PROC = INLINE    BEGIN    [oddpairs: savedOddPairs, evenPairs: savedEvenPairs] ¬ displayFCB.border;    InlineSetBorderPattern[oddPairs: 0, evenPairs: 0];    displayFCB.displCntl.picture ¬ Border;  --  (Daybreak)    -- displayFCB.***.*** ¬ FALSE;             (Daisy)      *****  TBD *****    -- Set bit for a chng in command    --  The displInfoChangedMask is already byte swapped    --  Use Mesa machine code to get lock while setting changed flag; result returned is unused.    [] ¬ DoveInputOutput.LockMem         [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], displInfoChangedMask, displayFCB.displayLock];           END;  -- InlineTurnOff    -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  --  DisplaySpecialFaceDove    --CantMoveScreen: PUBLIC SIGNAL = CODE;  GetDisplayAlignmentData: PUBLIC PROCEDURE[x, y: DisplaySpecialFaceDaisy.Alignments] RETURNS[newX, newY: Environment.Byte] =    BEGIN            newX ¬ IF x.dir = rightDown THEN x.low              ELSE	       Inline.BITOR[128, -- direction bit	  Inline.LowByte[((CARDINAL[x.nibbleOffset] - 1)/4 + 1) * 4 -- wordOffset	      + 3 - ((CARDINAL[x.nibbleOffset] - 1) MOD 4)]];	          newY ¬ y.low;           END;      GetAlignmentsFromBytes: PUBLIC PROCEDURE[x, y: Environment.Byte] RETURNS [xa, ya: DisplaySpecialFaceDaisy.Alignments] =    BEGIN    ya.high ¬ 0;    ya.low ¬ y;            xa.dir ¬ IF x>127 THEN leftUp ELSE rightDown;    xa.nibbleOffset ¬ IF x<=127 THEN       Inline.BITAND[x, 127]    ELSE      Inline.BITAND[x, 124] - Inline.BITAND[x, 3];    END;        NotifyDisplayAlignment: PUBLIC PROCEDURE RETURNS[notified: BOOLEAN] =     BEGIN    notifyMask: DoveInputOutput.ByteSwappedWord ¬ alignmentChangedMask;        -- when the machine is not a daisy workstation, simply returns.        IF DoveInputOutput.GetMicrocodeVersion[].machineType # daisy THEN RETURN[FALSE];    «IF newY MOD 2 = 1 THEN {      borderSwapped ¬ TRUE;      SetBorderPattern[oddPairs: savedEvenPairs, evenPairs: savedOddPairs];      notifyMask ¬ notifyMask OR pictureBorderPatChangedMask};    displayFCB.alignmentX ¬ newX;    displayFCB.alignmentY ¬ newY;»        [] ¬ DoveInputOutput.LockMem         [or, DoveInputOutput.GetIORegionOffset[@displayFCB.chngdInfo], alignmentChangedMask, displayFCB.displayLock];        RETURN[TRUE]    END; -- SetDisplayAlignment-- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   -- KeyboardFace   keyMoFCB: LONG POINTER TO KeyboardMouseFunctionContextBlock ¬         DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.keyboardAndMouse];          keyboard: PUBLIC LONG POINTER TO READONLY PACKED ARRAY OF KeyboardFace.DownUp ¬ LOOPHOLE[@keyMoFCB.kBbase];   -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = -- MouseFace   position: PUBLIC LONG POINTER TO READONLY Position ¬   LOOPHOLE[@keyMoFCB.mouseXY];   Position: TYPE = MouseFace.Point;     buttons: PUBLIC LONG POINTER TO READONLY Buttons ¬ LOOPHOLE[keyboard];   Buttons: TYPE = MouseFace.Buttons;    SetPosition: PUBLIC PROC [p: MouseFace.Point] =    BEGIN     UNTIL position­ = p      DO      LOOPHOLE[position, LONG POINTER TO MouseFace.Point]­ ¬ p;      ENDLOOP;    END;   -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =-- BeepFace-- BeepFace Variable  megaHertz: LONG CARDINAL ¬ 2764800;	--This is temp until value is known to be correct  					--then it will be moved into BeepOn: PUBLIC PROC		  				--Inline.LongDiv[megaHertz, ....  -- Get fixed location for beepFCB  beepFCB: LONG POINTER TO BeepFunctionContextBlock ¬         DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.beep];  BeepOn: PUBLIC PROC [frequency: CARDINAL] = {    OPEN Inline;  -- The MAX in the next statement prevents the LowHalf from overflowing.    -- The period (in usec*1.8432) will be in the range [~29..63535].    --Whats the new DOVE numerator. Because dove has a 3 megahertz clock and    --Dlion has a 2 megahertz clock it should be 1843200 * 1.5 = 2764800    --The period (in usec*2.764800) will be in the range [~43..64297].        beepFCB.frequency ¬ DoveInputOutput.ByteSwap[Inline.LowHalf[Inline.LongDiv[megaHertz, MAX[frequency, 43]]]];    DoveInputOutput.NotifyIOP[beepFCB.beepMask]    --Must poke the IOP to let it know that frequency has changed    };      BeepOff: PUBLIC PROC = {InlineBeepOff[]};    InlineBeepOff: PROC = INLINE {    beepFCB.frequency ¬ 0;   DoveInputOutput.NotifyIOP[beepFCB.beepMask]   --Must poke the IOP to let it know that frequency has changed   };  -- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  Start: PUBLIC --HeadStartChain.-- PROC = {RemainingHeads.Start[]};  END.LOG    (For previous log entries, please see Mesa 8.0 archive version.)October 16, 1981  1:09 PM   JXF        fix up patch count to patchCount-1.8-Nov-81 17:21:16   JXF        Don't update IOCB if display is off.2-Dec-81 10:57:29   JXF         Change Scroll to acdept BitAddress.27-Jan-82 14:56:59   AWL         In Connect do TurnOn only when the bitmap is really there.26-Feb-82 10:54:09   LXD         In SetPosition-- patch to reduce window between when mouse position is set and picked up.1-Jul-82 10:42:23   AEF         Add cursorMask to CSB and add cursorMaskTable, create InlineTurnOff.28-Jul-82 13:56:48   AEF        New IOPage layout, use DLionInputOutput.GetRealAddress.25-Oct-82 12:15:29   wDK        Make compatible with Klamath PageMap. 8-Apr-83 17:49:10   AEF        For Klamath - don't use Utilities, fix truncation errors  
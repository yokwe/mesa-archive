-- Copyright (C) 1988 by Fuji Xerox Co., Ltd, Tokyo, Japan.-- All rights reserved. -- File: DiskHeadDuke.mesa last edited  8-Oct-88 23:05:35 by MN.DIRECTORY  Boot				USING [BootFileDescriptorPageHandle,				       BootFileDescriptorPageSeal,				       BootFileDescriptorPageVersion,				       eofDescriptorLink,				       nullDiskBootChainLink,				       eofDiskBootChainLink],  Device			USING [Type],  Environment			USING [wordsPerPage],  HeadStartChain,  CompatibilityDiskFace,  CompatibilityDiskFaceExtra,  Inline			USING [LongMult, DIVMOD],  PilotDiskFace,  PilotDiskFaceStatistics,  Zone				USING [Alignment];DiskHeadDuke: PROGRAM   IMPORTS CompatibilityDiskFace, CompatibilityDiskFaceExtra,	  RemainingHeads: HeadStartChain, Inline   EXPORTS HeadStartChain, PilotDiskFace, PilotDiskFaceStatistics = BEGIN  OPEN PDF:PilotDiskFace, CDF:CompatibilityDiskFace;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~   DiskFaceAdapter Content                                        ~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<<Prior to label-less Pilot the content of labels was in Pilot's domain.  Withthe advent of label-less Pilot, labels have become part of the machine dependentdomain because older hardware, PROMs and difficult-to-change microcode have somelabel knowledge built-in which must be accomodated; while newer rigid disksubsystems won't have labels at all.This PROGRAM module exists to provide compatibility between older labeled rigiddisk subsystems and the new label-less Pilot.  The principle method is that ofmaintaining a conformance between the new PilotDiskFace.Operation TYPE and theold Operation TYPE, now defined as CompatibilityDiskFace.Operation, such thatfor most characteristics they are LOOPHOLES of each other. GetDeviceAttributes,Initiate and Poll in the Heads for labeled disk subsystems must be converted toOldGetDeviceAttributes, OldInitiate and OldPoll and exported toCompatibilityDiskFace.  This program module, DiskFaceAdapter, implementsGetDeviceAttributes, Initiate and Poll and exports them to PilotDiskFace.  Nowwhen these proceedures are called, DiskFaceAdapter LOOPHOLES the Operation andprovides dummy labels that accomodate the expectations of the older Heads,hardware, PROMs and microcode (eg. a smoothly incrementing label.filepage acrossruns of pages).  It does this by using the absolute sector count as the value forlabel.filepage.Additionally, DiskFaceAdapter incorporates a significant set of functions new tothe Head level of IO software.  These are the functions: makeBootable,makeUnbootable and getBootLocation.  For prelabel-less Pilot, booting was basedon bootChainLinks contained as part of the label (label.dontCare).  These linksconsisted of the diskAddress of the next piece of the boot file. Thus,IN-THE-PAST, for all boot files except initialMicrocode the last label in eachpageRun of the boot file pointed to the beggining of the next pageRun or, for thelast run, was Boot.eofDiskBootChainLink. initialMicrocode boot files did this andalso linked each sector in the each run. For FULLY label-less disk subsystems,ALL booting will use the new data structure Boot.BootFileDescriptorPage.HOWEVER, for the older labeled disk subsystems, although BootFileTypes pilot,debugger and debuggee use BootFileDescriptorPage(s) because they are booted bya new Germ that knows about such things, BootFileTypes initialMicrocode,softMicrocode, hardMicrocode<<diag>> and germ  continues to use the oldbootChainLinks-in-the-label approach because PROMed and difficult-to-changebootMicrocode expect them.>>  --   -- ERROR CODEs  --   descriptorError: ERROR = CODE;  cantGetHere:     ERROR = CODE;  --   -- Variables  --   ad:   CDF.AdapterDataPtr ¬ NIL;  cop:  CDF.OperationPtr  ¬ NIL;  maCD: Boot.BootFileDescriptorPageHandle ¬ NIL;  headsPerDrive:   CARDINAL ¬ 0;  sectorsPerHead:  CARDINAL ¬ 0;  -- Private PROCEDUREs in alphabetical order.  --   DAToFilePageNumber: PRIVATE PROCEDURE [da: PDF.DiskAddress]    RETURNS [CDF.FilePageNumber] = INLINE    {RETURN[da.sector + Inline.LongMult[	      sectorsPerHead, da.head + da.cylinder*headsPerDrive]]};  IncrementDiskAddress: PRIVATE PROCEDURE [daIn: PDF.DiskAddress,    count: CARDINAL] RETURNS [daOut: PDF.DiskAddress] = INLINE    BEGIN     quot: CARDINAL;    [quot, daOut.sector]		¬ Inline.DIVMOD[daIn.sector + count, sectorsPerHead];    [quot, daOut.head]		¬ Inline.DIVMOD[daIn.head + quot, headsPerDrive];    daOut.cylinder ¬ daIn.cylinder + quot;    END;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~   PUBLIC Types and Data                                          ~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --PilotDiskFaceStatistics--  pilotDiskErrors: ARRAY CDF.Status OF LONG CARDINAL ¬ ALL[0];  pilotDiskOtherErrors: ARRAY PilotDiskFaceStatistics.OtherErrors OF    LONG CARDINAL ¬ ALL[0];   pilotDiskOperationsInitiated: PUBLIC LONG CARDINAL ¬ 0;  pilotDiskPagesRead: PUBLIC LONG CARDINAL ¬ 0;  pilotDiskPagesWritten: PUBLIC LONG CARDINAL ¬ 0;   nullControllerHandle: PUBLIC PDF.ControllerHandle;  nullDeviceHandle: PUBLIC PDF.DeviceHandle;  operationSize: PUBLIC CARDINAL;  operationAlignment: PUBLIC Zone.Alignment;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~   PUBLIC PROCs EXPORTED TO SCSIDiskFace                          ~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Start: PUBLIC PROC =    BEGIN    CDF.OldStart[];    nullControllerHandle ¬ LOOPHOLE[CDF.nullControllerHandle];    nullDeviceHandle ¬ LOOPHOLE[CDF.nullDeviceHandle];    operationSize ¬ CDF.operationSize;    operationAlignment ¬ CDF.operationAlignment;    CDF.pilotDiskErrors ¬ @pilotDiskErrors;    CompatibilityDiskFaceExtra.pilotDiskOtherErrors ¬ @pilotDiskOtherErrors;    CDF.pilotDiskOperationsInitiated ¬ @pilotDiskOperationsInitiated;    CDF.pilotDiskPagesRead ¬ @pilotDiskPagesRead;    CDF.pilotDiskPagesWritten ¬ @pilotDiskPagesWritten;     pilotDiskOperationsInitiated ¬ 0;    pilotDiskPagesRead ¬ 0;    pilotDiskPagesWritten ¬ 0;    RemainingHeads.Start[];    END; --of Start--~~~~~~~~~~~~~~~~~~~~~-- Controller PROCs  ----~~~~~~~~~~~~~~~~~~~~~  -- There could be up to 7 controllers...  GetNextController: PUBLIC PROC    [controller: PDF.ControllerHandle]    RETURNS [PDF.ControllerHandle] =    {RETURN[CDF.GetNextController[controller]]};  GetControllerAttributes: PUBLIC PROC [PDF.ControllerHandle]    RETURNS [CARDINAL] =    {RETURN[CDF.globalStateSize]};  InitializeController: PUBLIC PROC [    controller: PDF.ControllerHandle,    globalState: PDF.GlobalStatePtr,    mask: WORD,    nakedCondition: LONG POINTER TO CONDITION ¬ NIL] =    {CDF.InitializeController[controller, globalState, mask, nakedCondition]};--~~~~~~~~~~~~~~~~-- Drive PROCs  ----~~~~~~~~~~~~~~~~  GetNextDevice: PUBLIC PROC [device: PDF.DeviceHandle]    RETURNS [PDF.DeviceHandle] =    {RETURN[CDF.GetNextDevice[device]]};  DetermineDiskShape: PUBLIC PROCEDURE [    device: PDF.DeviceHandle, operation: PDF.OperationPtr,    mode: PDF.DeterminationMode, buffer: LONG POINTER]    RETURNS [known: BOOLEAN] =    {RETURN[CDF.DetermineDiskShape[device, operation, mode, buffer]]};      GetDeviceAttributes: PUBLIC PROC [device: PDF.DeviceHandle]    RETURNS [cylinders, movingHeads, fixedHeads,    sectorsPerTrack: CARDINAL] =    BEGIN    [cylinders, movingHeads, fixedHeads, sectorsPerTrack]				¬ CDF.OldGetDeviceAttributes[device];    headsPerDrive ¬ movingHeads+fixedHeads;    sectorsPerHead ¬ sectorsPerTrack;    END;  -- END of GetDeviceAttributes  GetDeviceType: PUBLIC PROC [device: PDF.DeviceHandle]    RETURNS [Device.Type] =    {RETURN[CDF.GetDeviceType[device]]};  GetDriveInfo: PUBLIC PROCEDURE [h: PDF.DeviceHandle]     RETURNS [      firstPageOfInitialMicrocode: PDF.DiskAddress,      lastPageOfInitialMicrocode: PDF.DiskAddress,      firstPilotPage: PDF.DiskAddress,      formattingSpec: PDF.FormattingSpec,      formattingAlignment: PDF.FormattingUnit] =      {[firstPageOfInitialMicrocode, lastPageOfInitialMicrocode,      firstPilotPage, formattingSpec, formattingAlignment] ¬      CDF.GetDriveInfo[h]};  GetFormattingUnit: PUBLIC PROC [device: PDF.DeviceHandle]    RETURNS [PDF.FormattingUnit] =    {RETURN [CDF.GetFormattingUnit[device]]};   --~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Special Handling PROCs  ----~~~~~~~~~~~~~~~~~~~~~~~~~~~  Reset: PUBLIC PROC [c: PDF.ControllerHandle] =    {CDF.Reset[c]};  Recalibrate: PUBLIC PROC [d: PDF.DeviceHandle] =    {CDF.Recalibrate[d]};  InitializeCleanup: PUBLIC PROC [c: PDF.ControllerHandle] =    {CDF.InitializeCleanup[c]};  SuggestedTries: PUBLIC PROC [device: PDF.DeviceHandle]    RETURNS [PDF.Tries] =    {RETURN[CDF.SuggestedTries[device]]};  PagesForTrackBuffering: PUBLIC PROCEDURE [device: PDF.DeviceHandle]    RETURNS [pagesPerBuffer: CARDINAL, maxNumberOfBuffers: CARDINAL] =    {[pagesPerBuffer, maxNumberOfBuffers] ¬        CDF.PagesForTrackBuffering[device]};  InitializeTrackBuffer: PUBLIC PROCEDURE [    device: PDF.DeviceHandle,    buffer: LONG POINTER,    numberOfBuffers: CARDINAL] =    {CDF.InitializeTrackBuffer[device, buffer, numberOfBuffers]};--~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Input/Output PROCs      ----~~~~~~~~~~~~~~~~~~~~~~~~~~~  Initiate: PUBLIC PROC [op: PDF.OperationPtr] =    BEGIN    cop ¬ LOOPHOLE[op, CDF.OperationPtr];    ad  ¬ CDF.AddressOfAdapterData[cop];    ad­ ¬ []; <<includes mode ¬ normal, nextRunIndex ¬ 1 & nextSector ¬ 1>>    IF op.reserved1 # NIL    THEN <<a label has been spcified>> ad.mode ¬ passThrough    ELSE {      ad.command ¬ op.command;      cop.labelPtr ¬ @ad.label;      CDF.SetLabelFilePage[cop.labelPtr,			DAToFilePageNumber[cop.clientHeader]];      cop.command ¬ SELECT ad.command FROM        noOp =>   [noOp,noOp,noOp],        read =>   [verify,verify,read],        write =>  [verify,write,write],        verify => [verify,verify,verify],        format => [write,write,write],        readHeader => [read,noOp,noOp],        readHeaderAndData => [read,read,read],        makeUnbootable, getBootLocation => [verify,verify,read],        makeBootable => [verify,write,write],        ENDCASE => [noOp,noOp,noOp];      IF ad.command IN [makeBootable .. getBootLocation]      THEN {	cop.pageCount ¬ 1; cop.tries ¬ 15; cop.incrementDataPtr ¬ TRUE;        ad.maBuffer ¬ cop.dataPtr;        IF ad.command # getBootLocation	THEN cop.dataPtr ¬ cop.dataPtr + Environment.wordsPerPage;        maCD ¬ ad.maCurrentDescr ¬ ad.maFirstDescr ¬ LOOPHOLE[cop.dataPtr];        ad.daFirstDescr ¬ cop.clientHeader;        SELECT ad.command FROM	  getBootLocation => ad.mode ¬ getBootLocation;	  makeUnbootable  => ad.mode ¬ readDescr;	  makeBootable  => {	    ad.bootFileType ¬ maCD.header.bootFileType;	    IF ad.bootFileType # initialMicrocode	    THEN ad.mode ¬ writeDescr	    ELSE {              <<For pre label-less systems initialMicrocode, makeBootable		does not even write the descr. It begins the linking process		immediatedly.>> 	      IF   maCD.header.seal # Boot.BootFileDescriptorPageSeal	        OR maCD.header.version # Boot.BootFileDescriptorPageVersion	      THEN ERROR descriptorError;	      ad.currentRun ¬ maCD.pageRuns[0];              ad.daCurrentLinkLabel ¬ ad.currentRun.da;	      <<cop.clientHeader already pointing at 1st sector of 1st run>>              <<nextSector = 1 & ad.nextRunIndex = 1 because of ad­ ¬ []		above>>	      cop.dataPtr ¬ ad.maBuffer; cop.incrementDataPtr ¬ FALSE;	      cop.command ¬ [verify,read,read];	      ad.mode ¬ readLabel}};          ENDCASE => ERROR cantGetHere}};    CDF.OldInitiate[cop];    END;  -- END of Inititate  Poll: PUBLIC PROC [controller: PDF.ControllerHandle]         RETURNS [status:       PDF.Status,	         op:           PDF.OperationPtr,		 retriedCount: CARDINAL] =    BEGIN    cStatus: CDF.Status;    [cStatus, cop, retriedCount] ¬ CDF.OldPoll[controller];    op ¬ LOOPHOLE[cop];    status ¬ LOOPHOLE[cStatus];    IF status = inProgress THEN RETURN; -- Head not done    ad ¬ CDF.AddressOfAdapterData[cop];    IF ad.mode = passThrough THEN RETURN;    IF (ad.mode = normal) OR (status # goodCompletion)    <<Note: Since CDF.OldPoll does retries, status # goodCompletion implies      a hard error and the processing of makeBootable, makeUnbootable and      getBootLocation commands can't be done in the presence of hard errors;      so this filters out those cases.>>    THEN {      IF (status = reserved6) OR (status = reserved9) THEN						status ¬ otherError;      op.command ¬ ad.command; op.reserved1 ¬ NIL; RETURN};    <<Must be processing a makeBootable, makeUnbootable or getBootLocation      command with goodCompletion; because all others would have RETURNed       before this point.  Note: Just before the final RETURN, makeBootable      and makeUnbootable ALSO provide the getBootLocation function      (ie. op.diskHeader ¬ the boot diskAddress appropriate to      bootFileType).>>    maCD ¬ ad.maCurrentDescr;    IF ad.mode IN [writeDescr..getBootLocation]    THEN {       IF   maCD.header.seal # Boot.BootFileDescriptorPageSeal        OR maCD.header.version # Boot.BootFileDescriptorPageVersion      THEN ERROR descriptorError;      ad.bootFileType ¬ maCD.header.bootFileType};      SELECT ad.mode FROM      getBootLocation => NULL; <<Drop to common boot location posting.>>      writeDescr, readDescr => {         IF maCD.header.nextPage # Boot.eofDescriptorLink	THEN { <<More descriptor pages to read or write>>          cop.clientHeader ¬ maCD.header.nextPage;          CDF.SetLabelFilePage[cop.labelPtr,	    DAToFilePageNumber[cop.clientHeader]];          ad.maCurrentDescr ¬ LOOPHOLE[cop.dataPtr];	    <<address of next descripter because incrementDataPtr = true>>          cop.pageCount ¬ 1; cop.tries ¬ 15;	  CDF.OldInitiate[cop]; status ¬ inProgress; RETURN}	ELSE {<<No more descriptor pages; so see if need to process links.>>          SELECT ad.bootFileType FROM            pilot, debugger, debuggee => NULL;	    <<Doesn't need links so drop to common boot location posting.>>            softMicrocode, hardMicrocode<<diag>>, germ => {	      maCD ¬ ad.maCurrentDescr ¬ ad.maFirstDescr;              ad.currentRun ¬ maCD.pageRuns[0];              <<ad.nextRunIndex = 1 via ad­ ¬ [] in Initiate>>	      cop.clientHeader ¬ ad.daCurrentLinkLabel		¬ IncrementDiskAddress			[ad.currentRun.da, ad.currentRun.count -1];              cop.dataPtr ¬ ad.maBuffer; cop.incrementDataPtr ¬ FALSE;	      cop.command ¬ [verify,read,read];	      ad.mode ¬ readLabel;              cop.pageCount ¬ 1; cop.tries ¬ 15;	      CDF.OldInitiate[cop]; status ¬ inProgress; RETURN};            ENDCASE=>ERROR cantGetHere			<<no writeDescr for initialMicrocode>>}};      readLabel => {	<<Just read a label to be linked; so set the link and rewrite it.>>	ad.label.dontCare ¬ LOOPHOLE[	  IF ad.command = makeUnbootable	  THEN Boot.nullDiskBootChainLink	  ELSE IF ad.bootFileType = initialMicrocode	          AND ad.nextSector < ad.currentRun.count	    THEN cop.clientHeader <<already points to next sector in run>>	    ELSE IF ad.nextRunIndex < maCD.header.pageRunsCount	      THEN maCD.pageRuns[ad.nextRunIndex].da	      ELSE Boot.eofDiskBootChainLink				<<If multiPageDescr, will rewrite>>];	cop.clientHeader ¬ ad.daCurrentLinkLabel;	cop.command ¬ [verify,write,write];	ad.mode ¬ writeLabel;        cop.pageCount ¬ 1; cop.tries ¬ 15;	CDF.OldInitiate[cop]; status ¬ inProgress; RETURN};      writeLabel => {      <<Just wrote a label containing a link.  Set up for next, if any	more.>>	IF ad.bootFileType=initialMicrocode AND				ad.nextSector<ad.currentRun.count	THEN ad.nextSector ¬ ad.nextSector + 1	     <<clientHeader already points to next sector in run>>	ELSE IF ad.nextRunIndex < maCD.header.pageRunsCount	  THEN { <<more runs this descriptor>>            ad.nextSector ¬ 1; <<might be initialMicrocode>>            ad.currentRun ¬ maCD.pageRuns[ad.nextRunIndex];            ad.nextRunIndex ¬ ad.nextRunIndex + 1;	    cop.clientHeader ¬ IF ad.bootFileType = initialMicrocode	      THEN ad.currentRun.da	      ELSE IncrementDiskAddress				[ad.currentRun.da, ad.currentRun.count - 1]}	  ELSE IF maCD.header.nextPage # Boot.eofDescriptorLink	    THEN <<more descriptors>> {	      maCD ¬ ad.maCurrentDescr ¬ maCD + Environment.wordsPerPage;              <<The last sector of the last run got an		eofDiskBootChainLink. Now we know there are more		descriptors, so REWRITE it (ie. don't need to change		ad.currentRun) to point to the first sector of the		FIRST (ie. ad.nextRunIndex = 0) run of the new descriptor.>>              ad.nextRunIndex ¬ 0;	      cop.clientHeader ¬ ad.daCurrentLinkLabel}	    ELSE GOTO wasLastLink;	ad.daCurrentLinkLabel ¬ cop.clientHeader;	cop.command ¬ [verify,read,read];	ad.mode ¬ readLabel;        cop.pageCount ¬ 1; cop.tries ¬ 15;	CDF.OldInitiate[cop]; status ¬ inProgress; RETURN;	EXITS wasLastLink => NULL};      ENDCASE => ERROR cantGetHere;    <<If it gets through to this point without RETURNing, then all that's      left is posting the boot location in op.diskHeader and a little      cleanup.>>    op.diskHeader ¬ SELECT ad.bootFileType FROM      initialMicrocode, softMicrocode, hardMicrocode, germ =>	ad.maFirstDescr.pageRuns[0].da,      ENDCASE => ad.daFirstDescr;    op.command ¬ ad.command;    op.reserved1 ¬ NIL;    END;  -- END of PollEND...  -- END of DiskHeadDukeLOG10-Aug-88 13:51:54 KT  Created form DiskHeadDLight 8-Oct-88 23:05:29 MN  Added PagesForTrackBuffering, InitializeTrackBuffer		       Added nakedCondition to InitializeController
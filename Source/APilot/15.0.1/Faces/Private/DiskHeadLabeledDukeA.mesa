-- Copyright (C) 1988 by Fuji Xerox Co., Ltd, Tokyo, Japan.-- All rights reserved. -- File: DiskHeadLabeledDukeA.mesa last edited  2-Nov-88 22:06:52 by MN.DIRECTORY  Checksum			USING [ComputeChecksum],  CompatibilityDiskFace 	USING [AdapterData, AdapterDataPtr, Command,				       FixUpLabel, Label, MatchLabels,				       NextLabel, Op, Operation,				       OperationPtr, Status],  CompatibilityDiskFaceExtra,  Device			USING [Type],  DiskIOFaceDuke,  DoveHandlerIDs		USING [disk],  DiskHeadLabeledDukeInternal	USING [AltQ, GetClockPulses, ReadTrackBuffer,				       InvalidateTrackBuffer, ReplaceAlgorithm,				       maxNumberOfBuffers, NotifyControllerProcess,				       PromptHandler, OldStartB,				       TrackBufferTableEntry, XferType],  DoveInputOutput		USING [ByteSwap,				       ByteSwappedPointer, ByteSwappedWord,				       GetHandlerIORegionPtr, IOPBoolean,				       IOPShortBoolean, LongByteSwap,				       LongPointerToOpieAddress,				       nilOpieAddress],  Environment			USING [Base, bitsPerWord, first64K, Long,				       PageNumber, PageFromLongPointer, wordsPerPage],  Inline			USING [BITNOT, BITXOR, DIVMOD, HighHalf,				       LongCOPY, LongDivMod, LongMult, LowHalf],  PageMap			USING [GetState, RealPageNumber, SetMapState, State],  PilotDiskFace,  PilotDiskFaceStatistics,  ProcessOperations		USING [DisableInterrupts, EnableInterrupts],  SelfDescribingDisks		USING [currentVersion, DiskShape,				       DiskShapeDescriptorAddress,				       DiskShapeDescriptorPageFormat,				       nullDiskShape, Seal],  SpecialDiskFaceDove,  SpecialPilotDiskFace,  System			USING [GetClockPulses, Pulses],  Zone				USING [Alignment];DiskHeadLabeledDukeA: PROGRAM  IMPORTS Checksum, CompatibilityDiskFace,	  DiskHeadLabeledDukeInternal, DoveInputOutput, Environment, Inline,	  PageMap, ProcessOperations, System  EXPORTS CompatibilityDiskFace, CompatibilityDiskFaceExtra,	  SpecialDiskFaceDove, SpecialPilotDiskFace, DiskHeadLabeledDukeInternal  SHARES  PageMap =BEGIN OPEN      CDF: CompatibilityDiskFace,      DHI: DiskHeadLabeledDukeInternal,      PDF: PilotDiskFace,      IOF: DiskIOFaceDuke;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Constants  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AltQ: TYPE = DHI.AltQ;  altQInvalid: PUBLIC AltQ ¬ [IOF.nil, IOF.nil];  altQWaiting: PUBLIC AltQ ¬ [IOF.nil, IOF.nil];  delayLoopCount: CARDINAL ¬ LAST[CARDINAL];  numberOfInstalledDrives: PUBLIC IOF.DriveNumber ¬ 1;  fcb: PUBLIC IOF.FCBPtr ¬    DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.disk];  formatArray: ARRAY [0..0] OF PDF.Command;  globalStateSize: PUBLIC CARDINAL ¬ 0;  nullControllerHandle: PUBLIC PDF.ControllerHandle ¬ LOOPHOLE[0FFFFH];  nullDeviceHandle: PUBLIC PDF.DeviceHandle ¬ LOOPHOLE[0FFFFH];  myControllerHandle: PDF.ControllerHandle = LOOPHOLE[1];  operationSize: PUBLIC CARDINAL ¬ SIZE[IOF.IOCB] + SIZE[CDF.AdapterData];  operationAlignment: PUBLIC Zone.Alignment ¬ a1;  timeOfLastPrompt: PUBLIC IOF.ClockPulses ¬ [0];  eccErrorCnt: LONG CARDINAL ¬ 0;  eccFixCnt: LONG CARDINAL ¬ 0;  pilotAccess: SpecialDiskFaceDove.PilotAccess ¬ on;  diskShape: ARRAY IOF.DriveNumber OF    SelfDescribingDisks.DiskShape ¬ ALL[SelfDescribingDisks.nullDiskShape];  DiskHandlerWedged: ERROR = CODE;  MustFormatInTrackMultiples: ERROR = CODE;  << For debugging purposes >>  <<  pilotDiskErrors: PUBLIC ARRAY CDF.Status OF CARDINAL ¬ ALL[0];  pilotDiskOtherErrors: PUBLIC ARRAY PilotDiskFaceStatistics.OtherErrors OF    CARDINAL ¬ ALL[0];  pilotDiskOperationsInitiated: PUBLIC LONG CARDINAL;  pilotDiskPagesRead: PUBLIC LONG CARDINAL;  pilotDiskPagesWritten: PUBLIC LONG CARDINAL;  >>   -- PilotDiskFaceStatistics  pilotDiskErrors:		PUBLIC LONG POINTER TO ARRAY					CDF.Status OF LONG CARDINAL;  pilotDiskOtherErrors:		PUBLIC LONG POINTER TO ARRAY		PilotDiskFaceStatistics.OtherErrors OF LONG CARDINAL;  pilotDiskOperationsInitiated:	PUBLIC LONG POINTER TO LONG CARDINAL;  pilotDiskPagesRead: 		PUBLIC LONG POINTER TO LONG CARDINAL;  pilotDiskPagesWritten: 	PUBLIC LONG POINTER TO LONG CARDINAL;  << When going to the debugger head related portions and only head related     portions of the FunctionContextBlock must be copied during world swaps     and restored on the way back.>>  savedAltQInvalid, savedAltQWaiting: PUBLIC AltQ;  savedStartHandlerForMesa: PUBLIC DoveInputOutput.IOPBoolean;  savedHandlerState: PUBLIC IOF.HandlerState;  savedClientInfo: PUBLIC IOF.ClientInfo;  savedCurrentDrivePtr: PUBLIC DoveInputOutput.ByteSwappedPointer;  savedControllerRegisters: PUBLIC IOF.DiskControllerRegisters;  savedDriveInfoAndDMAStatus: PUBLIC IOF.DMAStateInfo;  savedDCB: PUBLIC ARRAY IOF.DriveNumber OF				IOF.DeviceContextBlock;  useLEDs: BOOLEAN ¬ TRUE;  --  -- Variables for TrackBuffer  --  accessCount: PUBLIC LONG CARDINAL ¬ 0;  maxWait: PUBLIC LONG CARDINAL ¬ 0;  minWait: PUBLIC LONG CARDINAL ¬ LAST [LONG CARDINAL];  nk: PUBLIC LONG POINTER TO CONDITION;  numberOfTrackBuffers: PUBLIC [1..DHI.maxNumberOfBuffers] ¬ 4;  oldestEntry: PUBLIC [0..DHI.maxNumberOfBuffers) ¬ 0;<<for ReplaceAlgorithm = fifo>>  rdcImplementsTrackReadCommand: PUBLIC BOOLEAN ¬ FALSE;  readHit, readHitInvalidSect, readMis: PUBLIC LONG CARDINAL ¬ 0;  replaceAlgorithm: PUBLIC DHI.ReplaceAlgorithm  ¬ lru;<<lru, fifo>>  sectorsPerTrackBuffer: PUBLIC CARDINAL;  totalWait: PUBLIC LONG CARDINAL ¬ 0;  trackBufferInitialized: PUBLIC BOOLEAN ¬ FALSE;  trackBufferTable: PUBLIC ARRAY[0..DHI.maxNumberOfBuffers) OF	DHI.TrackBufferTableEntry;  waitStart, waitEnd: System.Pulses;  writeHit, writeMis: PUBLIC LONG CARDINAL ¬ 0;  xferType: PUBLIC DHI.XferType ¬ copy;<<map, copy>>  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- PROCEDUREs in alphabetical order.  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AddressOfAdapterData: PUBLIC PROC [cop: CDF.OperationPtr]    RETURNS [CDF.AdapterDataPtr] = {    RETURN[LOOPHOLE[cop + SIZE[IOF.IOCB]]]};  CopyLabelWithByteSwap: PRIVATE PROCEDURE [    sourceLabel: LONG POINTER, destinationLabel: LONG POINTER] = INLINE    BEGIN    FOR index: NATURAL IN [0..SIZE[CDF.Label]) DO      (destinationLabel + index)­ ¬ DoveInputOutput.ByteSwap[        (sourceLabel + index)­];      ENDLOOP;    END;  -- DeviceHandle: PUBLIC TYPE = IOF.DriveNumber;  DeviceHandleToDriveNumber: PROC [d: PDF.DeviceHandle]    RETURNS [IOF.DriveNumber] = INLINE {RETURN[LOOPHOLE[d]]};  DetermineDiskShape: PUBLIC PROCEDURE [    device: PDF.DeviceHandle, operation: PDF.OperationPtr,    mode: PDF.DeterminationMode, buffer: LONG POINTER]    RETURNS [BOOLEAN] =    BEGIN    dn: IOF.DriveNumber = DeviceHandleToDriveNumber[device];    dcb: IOF.DCBPtr = @fcb.dcb[dn];    ds: LONG POINTER TO SelfDescribingDisks.DiskShape = @diskShape[dn];    savedOperation: CDF.Operation;    labeledOperation: CDF.OperationPtr ¬ LOOPHOLE[operation];    iocb: IOF.IOCBlongPtr = LOOPHOLE[operation];    IF dcb.diskState # ready THEN      BEGIN      InquireAboutDrive[dcb, dn];      SELECT dcb.diskState FROM        notThere, notReady => RETURN[FALSE];        ready => NULL;        ENDCASE => ERROR;      END;    IF ds.cylinderCount = PDF.unknownAttribute THEN      BEGIN      label: CDF.Label;      status: CDF.Status;      dsp: LONG POINTER TO SelfDescribingDisks.DiskShapeDescriptorPageFormat = buffer;      IF buffer = NIL THEN RETURN[FALSE];      savedOperation ¬ labeledOperation­;  --Don't confuse germ by changing operation.      labeledOperation­ ¬ [        clientHeader: SelfDescribingDisks.DiskShapeDescriptorAddress,	labelPtr: LONG[@label],	dataPtr: buffer,	incrementDataPtr: FALSE,	command: [verify, read, read],	tries: (IF mode = quickReadOnly THEN 1 ELSE 10),	pageCount: 1,	device: device];      iocb.useBuffer ¬ FALSE;      OldInitiate[labeledOperation];      DO        returnedOp: CDF.OperationPtr;	[status, returnedOp, ] ¬ OldPoll[myControllerHandle];	IF returnedOp = labeledOperation AND status # inProgress THEN EXIT;        ENDLOOP;      --operation.labelPtr ¬ NIL;      labeledOperation­ ¬ savedOperation;  --Don't confuse germ by changing operation.      IF status # goodCompletion OR        dsp.seal # SelfDescribingDisks.Seal OR	dsp.version # SelfDescribingDisks.currentVersion OR	dsp.checkSum # Inline.BITNOT[dsp.invertedCheckSum] OR	Checksum.ComputeChecksum[p: buffer, nWords: 254] # dsp.checkSum THEN        BEGIN	ds.pagesPerTrack ¬ dcb.deviceInformation.sectorsPerTrack;	ds.headsPerCylinder ¬ dcb.deviceInformation.headsPerCylinder;	ds.cylinderCount ¬ DoveInputOutput.ByteSwap[dcb.deviceInformation.cylindersPerDrive];	ds.reducedWriteCylinder ¬ DoveInputOutput.ByteSwap[dcb.deviceInformation.reduceWriteCurrentCylinder];	ds.preCompensationCylinder ¬ DoveInputOutput.ByteSwap[dcb.deviceInformation.precompensationCylinder];	END ELSE	BEGIN	ds­ ¬ dsp.diskShape;	dcb.deviceInformation.sectorsPerTrack ¬ ds.pagesPerTrack;	dcb.deviceInformation.headsPerCylinder ¬ ds.headsPerCylinder;	dcb.deviceInformation.cylindersPerDrive ¬ DoveInputOutput.ByteSwap[ds.cylinderCount];	dcb.deviceInformation.reduceWriteCurrentCylinder ¬ DoveInputOutput.ByteSwap[ds.reducedWriteCylinder];	dcb.deviceInformation.precompensationCylinder ¬ DoveInputOutput.ByteSwap[ds.preCompensationCylinder];	rdcImplementsTrackReadCommand ¬ iocb.dob.currentVersion >= 1;	END;      END;    RETURN[TRUE];    END;  DriveNumberToDeviceHandle: PROC [d: IOF.DriveNumber]    RETURNS [PDF.DeviceHandle] = INLINE {RETURN[LOOPHOLE[d]]};  EnqueueOperation: PRIVATE PROCEDURE [    dcb: IOF.DCBPtr, ptr: IOF.IOCBPtr,    invalidOperation: BOOLEAN ¬ FALSE, iocb: IOF.IOCBlongPtr] =    <<Note: The caller is responsible for byte-swapping ptr.>>    BEGIN    oldTail: IOF.IOCBlongPtr;    IF invalidOperation      THEN        IF altQInvalid.head = IOF.nil	  THEN  altQInvalid.tail ¬ altQInvalid.head ¬ ptr	  ELSE {oldTail ¬ Lengthen[DoveInputOutput.ByteSwap[altQInvalid.tail]];	        altQInvalid.tail ¬ oldTail.mesaNext ¬ ptr}      ELSE        IF dcb.mesaHead = IOF.nil THEN	  BEGIN	  waitStart ¬ System.GetClockPulses[];	  IF iocb.useBuffer AND (iocb.type = normal) THEN	    DHI.ReadTrackBuffer[LOOPHOLE[iocb]];	  IF trackBufferInitialized AND (iocb.command.data = write) THEN	    DHI.InvalidateTrackBuffer[op: LOOPHOLE[iocb], dcb: dcb];	  IF iocb.bufferHit THEN	    BEGIN	    dcb.mesaHead ¬ ptr;	    dcb.handlerMesaNext ¬ IOF.nil;	    iocb.inProgress ¬ False;	    iocb.complete ¬ True;	    DHI.NotifyControllerProcess[];	    END	  ELSE	    dcb.mesaHead ¬ dcb.handlerMesaNext ¬ ptr;	  END	ELSE 	  IF altQWaiting.head = IOF.nil	    THEN  altQWaiting.tail ¬ altQWaiting.head ¬ ptr		  <<Note iocb.mesaNext is nil at entry to EnqueueOperation>>	    ELSE {oldTail¬Lengthen[DoveInputOutput.ByteSwap[altQWaiting.tail]];		  altQWaiting.tail ¬ oldTail.mesaNext ¬ ptr};    END;  FindLastDrive: PRIVATE PROCEDURE RETURNS [last: CARDINAL] = INLINE    BEGIN    last ¬ 0;    FOR driveNumber: IOF.DriveNumber IN IOF.DriveNumber DO      dcb: IOF.DCBPtr = @fcb.dcb[driveNumber];      IF dcb­.diskState = notThere THEN InquireAboutDrive[dcb, driveNumber];      IF dcb­.diskState = notThere THEN LOOP;      last ¬ driveNumber;      ENDLOOP;    END;    GetControllerAttributes: PUBLIC PROCEDURE [PDF.ControllerHandle]    RETURNS [CARDINAL] = {RETURN[globalStateSize]};  -- assumes DetermineDiskShape called first  OldGetDeviceAttributes: PUBLIC PROCEDURE [device: PDF.DeviceHandle]    RETURNS [cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL] =    BEGIN    dcb: IOF.DCBPtr = @fcb.dcb[DeviceHandleToDriveNumber[device]];    RETURN[      cylinders: DoveInputOutput.ByteSwap[      dcb­.deviceInformation.cylindersPerDrive], fixedHeads: 0,        sectorsPerTrack: dcb­.deviceInformation.sectorsPerTrack,        movingHeads:        (IF dcb­.diskState = ready THEN dcb­.deviceInformation.headsPerCylinder         ELSE PDF.unknownAttribute)];    END;  GetDeviceType: PUBLIC PROCEDURE [device: PDF.DeviceHandle]    RETURNS [Device.Type] = {RETURN[diskShape[DeviceHandleToDriveNumber[device]].type]};  GetDiskShape: PUBLIC PROCEDURE [device: PDF.DeviceHandle]    RETURNS [shape: SelfDescribingDisks.DiskShape] =    {RETURN[diskShape[DeviceHandleToDriveNumber[device]]]};  GetDriveInfo: PUBLIC PROCEDURE [h: PDF.DeviceHandle]    RETURNS [      firstPageOfInitialMicrocode: PDF.DiskAddress,      lastPageOfInitialMicrocode: PDF.DiskAddress,      firstPilotPage: PDF.DiskAddress,      formattingSpec: PDF.FormattingSpec,      formattingAlignment: PDF.FormattingUnit] =    BEGIN    cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL;    [cylinders, movingHeads, fixedHeads, sectorsPerTrack] ¬ OldGetDeviceAttributes[      device: h];    firstPageOfInitialMicrocode ¬ IOF.firstPageOfInitialMicrocode;    IF movingHeads > 2      THEN lastPageOfInitialMicrocode ¬ [	cylinder: 0,	head: fixedHeads + movingHeads - 2,	sector: sectorsPerTrack - 1 + IOF.initialSector]      ELSE lastPageOfInitialMicrocode ¬ [	cylinder: 0,	head: 0,	sector: sectorsPerTrack - 1 + IOF.initialSector];    -- In Labelless pilot the last page of InitialMicrocode is deferent from    -- labeled pilot. If head =< 2 then the last page of InitialMicrocode is    -- [0, 0, lastSector] and if head > 2 it becomes    -- [0, HeadsParCyrinder - 2, lastSector].    firstPilotPage ¬ IOF.firstPilotPage;    formatArray[0] ¬ IOF.formattingCommand;    formattingSpec ¬ DESCRIPTOR[formatArray];    formattingAlignment ¬ GetFormattingUnit[h];    END;  GetFormattingUnit: PUBLIC PROCEDURE [PDF.DeviceHandle]    RETURNS [PDF.FormattingUnit] = {RETURN[singleTrack]};  -- There is only one controller...  GetNextController: PUBLIC PROCEDURE [controller: PDF.ControllerHandle]    RETURNS [PDF.ControllerHandle] = {    RETURN[      IF controller = nullControllerHandle THEN myControllerHandle      ELSE nullControllerHandle]};  GetNextDevice: PUBLIC PROCEDURE [device: PDF.DeviceHandle]    RETURNS [PDF.DeviceHandle] = {    thisDrive: CARDINAL =      (IF device = nullDeviceHandle THEN 0       ELSE DeviceHandleToDriveNumber[device] + 1);    IF thisDrive ~IN IOF.DriveNumber THEN RETURN[nullDeviceHandle];    IF thisDrive > FindLastDrive[] THEN RETURN[nullDeviceHandle];    RETURN[DriveNumberToDeviceHandle[thisDrive]]};  OldInitiate: PUBLIC PROCEDURE [op: CDF.OperationPtr] =    BEGIN    dcb: IOF.DCBPtr = @fcb.dcb[0];    invalidOperation: BOOLEAN ¬ FALSE;    iocb: IOF.IOCBlongPtr ¬ LOOPHOLE[op];    short: IOF.IOCBPtr = Shorten[iocb];    ad: CDF.AdapterDataPtr = AddressOfAdapterData[op];        MapFix[op];  -- touches and dirties pages.    iocb.try ¬ 1;    iocb.labelFixupType ¬ none;    iocb.pageLocalization ¬ 0;    iocb.preRestored ¬ FALSE;    op.deviceStatus ¬ LOOPHOLE[IOF.deviceStatusInitial];    invalidOperation ¬ InitIOCB[iocb, dcb];    iocb.nextIOCB ¬ DoveInputOutput.nilOpieAddress;    iocb.mesaNext ¬ IOF.nil;    iocb.useBuffer ¬ ad.command = read    		 AND op.enableTrackBuffer		 AND trackBufferInitialized		 AND ad.mode = normal		 AND op.incrementDataPtr;    EnqueueOperation[dcb: dcb, ptr: DoveInputOutput.ByteSwap[short],                     invalidOperation: invalidOperation, iocb: iocb];    pilotDiskOperationsInitiated ¬ pilotDiskOperationsInitiated + 1;    DHI.PromptHandler[];    END;  InitIOCB: PRIVATE PROCEDURE [    iocb: IOF.IOCBlongPtr, dcb: IOF.DCBPtr]    RETURNS [invalidOperation: BOOLEAN ¬ FALSE] =    BEGIN OPEN dI: dcb­.deviceInformation, dob: iocb­.dob, label: iocb.op.labelPtr, op: iocb­.op;    <<Temp. for compatability>>    iocb.filler ¬ ALL[0];        <<The following are initial states. They may change later>>    IF iocb.pageLocalization = 0        THEN iocb.runLength ¬ IF op.pageCount > 128 THEN 128 ELSE op.pageCount      ELSE iocb.runLength ¬ IF  iocb.pageLocalization > 15 THEN 16 ELSE 1;    iocb.command ¬ iocb.op.command;    iocb.stopHandlerOnCompletion ¬ False;    iocb.type ¬ normal;       <<A key notion to understanding InitIOCB is that iocb.type is set ONLY         by InitIOCB, exclusively for Poll who ONLY reads it.>>    IF  iocb.labelFixupType = readLabel THEN       BEGIN      iocb.command ¬ [header: verify, label: read, data: noOp];      iocb.runLength ¬ 1;      iocb.type ¬ labelFixup;      iocb.stopHandlerOnCompletion ¬ True;      END;    IF  dcb.recalibrate AND (~ iocb.preRestored) THEN       BEGIN      iocb.command ¬ [header: verify, label: read, data: noOp];      iocb.runLength ¬ 1;      iocb.type ¬ restore;      iocb.stopHandlerOnCompletion ¬ True;      END;    << On multi-page runs if page zero of the file is included we must break the operation into two operations.  The first involving only the first page of file and the second the rest of the run.  Upon successfully completing the operation on page zero the call to CDF.NextLabel modifies the label.  This is a crucial side effect. >>    IF  (iocb.command.header # write) AND (iocb.command.label # read)         AND (label.filePageLo = 0) AND (label.filePageHi = 0)       THEN iocb.runLength ¬ 1;    IF iocb.runLength # op.pageCount THEN iocb­.stopHandlerOnCompletion ¬ True;    iocb.pageCount ¬ DoveInputOutput.ByteSwap[iocb.runLength];    << For the time being we need to set some defaults until the hardware changes >>    iocb­.complementDOB ¬ TRUE;    iocb­.etch ¬ etch1;    iocb­.useLEDs ¬ useLEDs;    << end of throw-away code. >>        CopyLabelWithByteSwap[      sourceLabel: op.labelPtr, destinationLabel: @iocb.dob.label];  << effectively is: iocb.dob.label ¬ op.labelPtr­; >>    iocb­.unused1 ¬ 0;    iocb­.unused2 ¬ 0;    iocb­.diagnosticCommand ¬ iocb­.halt ¬ FALSE;    iocb­.dataPtr ¬ DoveInputOutput.LongPointerToOpieAddress[op.dataPtr];    iocb­.incrementDataPtr ¬       IF iocb.labelFixupType=readLabel THEN FALSE ELSE op.incrementDataPtr;    iocb­.dmaTimedOut ¬ False;    iocb­.error ¬ iocb­.diskOperationBlockError ¬ False;    iocb­.controllerErrorType ¬ noError;    iocb­.dmaErrorType ¬ noError;    iocb­.complete ¬ iocb­.inProgress ¬ False;    iocb­.onlyDOBFromController ¬ False;    iocb.bufferHit ¬ FALSE;        dob.zero1 <<¬ dob.zero2>> ¬ dob.zero3 ¬ dob.zero4 ¬ dob.zero5 ¬ dob.zero6 ¬ 0;    dob.currentVersion ¬ 0;    <<dob.reserved1 ¬ >>dob.reserved2 ¬ 0;    dob.driveAndControllerStatus ¬ IOF.defaultDriveAndControllerStatus;    dob.negativeSectorCount ¬ DoveInputOutput.ByteSwap[0 - iocb.runLength];    dob.writeEndCount ¬ IOF.defaultWriteEndCount;    dob.startingSectorOnTrack ¬ 0;  << Pilot numbers sectors from [0..n) >>    dob.eccSyndrome ¬ [a: 0, b: 0];    dob.eccFlag ¬ IF dcb.useEcc THEN ECC ELSE CRC;    dob.currentCylinder ¬ IOF.initialCurrentCylinder;    dob.header ¬ LOOPHOLE[DoveInputOutput.LongByteSwap[      LOOPHOLE[IF iocb.type = restore  -- doing a preRestore                 THEN PDF.DiskAddress[cylinder: 5, head: 0, sector: 0]		 ELSE iocb­.op.clientHeader, 	       LONG UNSPECIFIED]]];    dob.headerError ¬ dob.labelError ¬ dob.dataError ¬ dob.lastError ¬ [      error: noError];    dob.reducedWriteCylinder ¬ dI.reduceWriteCurrentCylinder;    dob.preCompensationCylinder ¬ dI.precompensationCylinder;    dob.sectorsPerTrack ¬ dI.sectorsPerTrack;    dob.headsPerCylinder ¬ dI.headsPerCylinder;    dob.cylindersPerDrive ¬ dI.cylindersPerDrive;    BEGIN <<Determine dob.operation. Watch for invalidOperations.>>      <<Note: Must filter out invalidOperations before testing for recalibrate.>>      command: CDF.Command ¬ iocb.command;      SELECT command.header FROM        noOp => {invalidOperation ¬ TRUE};        read => {invalidOperation ¬ TRUE};        write => {IF (command.label = write) AND (command.data = write)	            THEN dob.operation ¬ formatTracks                     ELSE invalidOperation ¬ TRUE};        verify => {          SELECT command.label FROM            noOp => {invalidOperation ¬ TRUE};            read => {              SELECT command.data FROM                noOp => {dob.operation ¬ readLabel};                read => {dob.operation ¬ readLabelAndData};                write => {invalidOperation ¬ TRUE};                verify => {invalidOperation ¬ TRUE};                ENDCASE => invalidOperation ¬ TRUE};            write => {              IF command.data = write THEN dob.operation ¬ writeLabelAndData              ELSE invalidOperation ¬ TRUE};            verify => {              SELECT command.data FROM                noOp => {dob.operation ¬ readData;		         IF iocb.dataPtr = DoveInputOutput.nilOpieAddress			   THEN invalidOperation ¬ TRUE			   ELSE iocb.incrementDataPtr ¬ FALSE};                read => {dob.operation ¬ readData};                write => {dob.operation ¬ writeData};                verify => {dob.operation ¬ verifyData};                ENDCASE => invalidOperation ¬ TRUE};            ENDCASE => invalidOperation ¬ TRUE};        ENDCASE => invalidOperation ¬ TRUE;      IF invalidOperation THEN {        ds: IOF.DeviceStatus ¬ IOF.deviceStatusInitial;        ds.complete ¬ TRUE;        ds.errorDetected ¬ TRUE;        ds.illegalOperation ¬ TRUE;        op.deviceStatus ¬ LOOPHOLE[ds];        iocb.error ¬ iocb.complete ¬ True;        iocb.dob.lastError.error ¬ illegalOperation;        RETURN};    END;    IF dcb.recalibrate AND iocb.preRestored THEN      BEGIN      dcb.recalibrate ¬ FALSE;        dob.operation ¬ restore;      iocb.type ¬ restore;      iocb.stopHandlerOnCompletion ¬ True;      iocb.command ¬ [noOp, noOp, noOp]; <<For Debugging, since no restore com>>      END;    SELECT dob.operation FROM      readData, readLabelAndData => {        iocb­.dataCommandTransfer ¬ TRUE;        iocb­.dataCommandDirection ¬ toMesa;        iocb­.dataTransferDirection ¬ read};      writeData, writeLabelAndData, verifyData => {        iocb­.dataCommandTransfer ¬ TRUE;        iocb­.dataCommandDirection ¬ fromMesa;        iocb­.dataTransferDirection ¬ write};      formatTracks => {        tracks: CARDINAL;        excessPages: CARDINAL;        [quotient: tracks, remainder: excessPages] ¬ Inline.DIVMOD[          num: iocb.runLength, den: dcb­.deviceInformation.sectorsPerTrack];        IF excessPages # 0 THEN ERROR MustFormatInTrackMultiples;        dob.negativeFormatTrackCount ¬ DoveInputOutput.ByteSwap[0 - tracks];        iocb­.dataCommandTransfer ¬ FALSE;        iocb­.dataTransferDirection ¬ noDataOperation};      ENDCASE => {        iocb­.dataCommandTransfer ¬ FALSE;        iocb­.dataTransferDirection ¬ noDataOperation};    END;  InquireAboutDrive: PRIVATE PROCEDURE [dcb: IOF.DCBPtr, dn: CARDINAL] =    BEGIN    dcb.diskState ¬ IF (dn < numberOfInstalledDrives) THEN ready ELSE notThere;    END;  Lengthen: PRIVATE PROCEDURE [short: IOF.IOCBPtr]    RETURNS [IOF.IOCBlongPtr] = INLINE {    RETURN[@Environment.first64K[short]]};  MapFix: PRIVATE PROCEDURE [op: CDF.OperationPtr] =    BEGIN    -- touch or dirty each page    pageAddr: LONG POINTER ¬ op.dataPtr;    pageCount: CARDINAL = IF op.incrementDataPtr THEN op.pageCount ELSE 1;    wdsPerPage: CARDINAL = Environment.wordsPerPage;    SELECT op.command.data FROM      read =>        THROUGH [0..pageCount) DO          pageAddr­ ¬ 0; pageAddr ¬ pageAddr + wdsPerPage ENDLOOP;      write, verify =>        THROUGH [0..pageCount) DO          d: CARDINAL = pageAddr­; pageAddr ¬ pageAddr + wdsPerPage ENDLOOP;      noOp =>  <<Kludge re converting vvn to vvr>>        IF op.command.header = verify AND op.command.label = verify THEN	  pageAddr­ ¬ 0;      ENDCASE;    END;  OldPoll: PUBLIC PROCEDURE [controller: PDF.ControllerHandle]    RETURNS [      status: CDF.Status, op: CDF.OperationPtr,      retriedCount: CARDINAL] =    BEGIN     dcbPtr: IOF.DCBPtr;    ds: IOF.DeviceStatus;    iocb: IOF.IOCBlongPtr;    pagesCompleted: CARDINAL;    startHandler: BOOLEAN;    dob: IOF.DiskOperationBlock; <<Not in alpha order for better code>>        ConvertDiskAddressToPageNumber: PRIVATE PROCEDURE [      diskAddress: PDF.DiskAddress, dcbPtr: IOF.DCBPtr]      RETURNS [pageNumber: Environment.PageNumber] = INLINE      BEGIN OPEN dI: dcbPtr­.deviceInformation;      pageNumber ¬        diskAddress.sector + Inline.LongMult[          dI.sectorsPerTrack,          diskAddress.head + dI.headsPerCylinder * diskAddress.cylinder];      END;    IncrementClientHeader: PRIVATE PROCEDURE [iocb: IOF.IOCBlongPtr, dcb: IOF.DCBPtr] = INLINE      BEGIN OPEN cH: iocb.op.clientHeader, dI: dcb.deviceInformation;        IF (cH.sector ¬ cH.sector + 1) = dI.sectorsPerTrack THEN {           cH.sector ¬ 0;          IF (cH.head ¬ cH.head + 1) = dI.headsPerCylinder THEN {	  cH.cylinder ¬ cH.cylinder + 1; cH.head ¬ 0}};      END;      KickHandler: PROCEDURE [controller: PDF.ControllerHandle] = INLINE      BEGIN      currentTime: IOF.ClockPulses ¬ DHI.GetClockPulses[];      deltaTime: IOF.TimeUnit;      timeoutInterval: IOF.TimeUnit = 100;  << Give the IOP a chance to run. >>      deltaTime ¬ currentTime.pulses - timeOfLastPrompt.pulses;  << Don't worry about clock wrap-around.  It will only kick the handler extra soon once in a blue-moon. >>      IF deltaTime > timeoutInterval THEN DHI.PromptHandler[];      END;    NeedsRecalibrate: PRIVATE PROCEDURE [      ds: IOF.DeviceStatus, iocb: IOF.IOCBlongPtr]      RETURNS [needsRecalibrate: BOOLEAN] =      BEGIN      RETURN[ds.writeFault OR  ds.illegalCylinder OR              iocb.dob.lastError.error = currentCylinderUnknown OR              iocb.dob.headerError.error = currentCylinderUnknown OR              (((iocb.try MOD 4) = 3) AND ds.sectorNotFound) OR	     ((iocb.try MOD 16) = 15)];      END;    DiskStatistics: PROCEDURE =      BEGIN      pilotDiskErrors[status] ¬ pilotDiskErrors[status] + 1;      IF status = otherError THEN        BEGIN        OPEN deviceStatus: LOOPHOLE[op­.deviceStatus, IOF.DeviceStatus],          errorField: iocb.dob.lastError;        IF deviceStatus.labelAddressMarkError THEN          pilotDiskOtherErrors[labelAddressMarkError] ¬            pilotDiskOtherErrors[labelAddressMarkError] + 1;        IF deviceStatus.labelIDError THEN          pilotDiskOtherErrors[labelIDError] ¬            pilotDiskOtherErrors[labelIDError] + 1;        IF deviceStatus.dataAddressMarkError THEN          pilotDiskOtherErrors[dataAddressMarkError] ¬            pilotDiskOtherErrors[dataAddressMarkError] + 1;        IF deviceStatus.dataIDError THEN          pilotDiskOtherErrors[dataIDError] ¬            pilotDiskOtherErrors[dataIDError] + 1;        SELECT errorField.error FROM          currentCylinderUnknown =>            pilotDiskOtherErrors[currentCylinderUnknown] ¬              pilotDiskOtherErrors[currentCylinderUnknown] + 1;          cylinderTooBig =>            pilotDiskOtherErrors[cylinderTooBig] ¬              pilotDiskOtherErrors[cylinderTooBig] + 1;          fifoEmptyAtGetCommandBlock =>            pilotDiskOtherErrors[fifoEmptyAtGetCommandBlock] ¬              pilotDiskOtherErrors[fifoEmptyAtGetCommandBlock] + 1;          fifoNotEmpty =>            pilotDiskOtherErrors[fifoNotEmpty] ¬              pilotDiskOtherErrors[fifoNotEmpty] + 1;          fifoFull =>            pilotDiskOtherErrors[fifoFull] ¬ pilotDiskOtherErrors[fifoFull] + 1;          fifoEmpty =>            pilotDiskOtherErrors[fifoEmpty] ¬ pilotDiskOtherErrors[fifoEmpty] + 1;          fifoNotEmptyAtLoadCommandBlock =>            pilotDiskOtherErrors[fifoNotEmptyAtLoadCommandBlock] ¬              pilotDiskOtherErrors[fifoNotEmptyAtLoadCommandBlock] + 1;          illegalOperation =>            pilotDiskOtherErrors[illegalOperation] ¬              pilotDiskOtherErrors[illegalOperation] + 1;          illegalDiagnosticOperation =>            pilotDiskOtherErrors[illegalDiagnosticOperation] ¬              pilotDiskOtherErrors[illegalDiagnosticOperation] + 1;          protocolViolation =>            pilotDiskOtherErrors[protocolViolation] ¬              pilotDiskOtherErrors[protocolViolation] + 1;          ENDCASE;        END;      END;    << Start Poll code. First locate an IOCB; preferably a completed IOCB. >>    retriedCount ¬ 0;    dcbPtr ¬ @fcb.dcb[0];    SELECT TRUE FROM      altQInvalid.head # IOF.nil =>         BEGIN        iocb ¬ Lengthen[DoveInputOutput.ByteSwap[altQInvalid.head]];        IF altQInvalid.head = altQInvalid.tail	  THEN  altQInvalid.tail ¬ altQInvalid.head ¬ IOF.nil	  ELSE {oldHead: IOF.IOCBlongPtr ¬	          Lengthen[DoveInputOutput.ByteSwap[altQInvalid.head]];	        altQInvalid.head ¬ oldHead.mesaNext};        op ¬ @iocb.op; status ¬ otherError; DiskStatistics[];        RETURN	END;       dcbPtr.mesaHead # IOF.nil =>         iocb ¬ Lengthen[DoveInputOutput.ByteSwap[dcbPtr.mesaHead]];      altQWaiting.head # IOF.nil =>         BEGIN        dcbPtr.mesaHead ¬ dcbPtr.handlerMesaNext ¬ altQWaiting.head;         DHI.PromptHandler[];	iocb ¬ Lengthen[DoveInputOutput.ByteSwap[dcbPtr.mesaHead]];        IF altQWaiting.head = altQWaiting.tail	  THEN altQWaiting.tail ¬ altQWaiting.head ¬ IOF.nil	  ELSE altQWaiting.head ¬ iocb.mesaNext;	END;      ENDCASE => {op ¬ NIL; status ¬ clientError; RETURN};    op ¬ @iocb.op;    IF iocb.complete = False THEN {      IF iocb.inProgress = False THEN KickHandler[controller];      status ¬ inProgress; <<As far as the Driver is concerned>>      DiskStatistics[];      RETURN};    <<Wow!! The handler has completed this iocb. Now for some fun!>>    dob ¬ iocb.dob;    startHandler ¬ iocb.stopHandlerOnCompletion = True OR iocb.error = True;    pagesCompleted ¬ 0;    IF iocb.useBuffer AND NOT iocb.bufferHit THEN      -- buffer miss.  rdc did track read.      BEGIN      OPEN tB: trackBufferTable[iocb.mapEntry];      tB.firstSect ¬ dob.header.sector;      -- set upto 16 booleans.      tB.sectorValid ¬ DoveInputOutput.ByteSwap[iocb.dob.sectorValid];      IF NOT (iocb.diskOperationBlockError = True	   OR iocb.controllerErrorType = interruptTimeout	   OR iocb.controllerErrorType = controllerNotInIdleLoop) THEN	BEGIN	-- check if error is on the sector that requested	start:CARDINAL = op.clientHeader.sector;	end:CARDINAL = MIN[start + iocb.runLength - 1, sectorsPerTrackBuffer - 1];	noErrorInRequestedSect:BOOLEAN ¬ TRUE;	sectIndex:CARDINAL ¬ IF start < tB.firstSect	  THEN start - tB.firstSect + sectorsPerTrackBuffer	  ELSE start - tB.firstSect;	THROUGH [start..end] WHILE noErrorInRequestedSect DO	  noErrorInRequestedSect ¬ tB.sectorValid[Environment.bitsPerWord-1 - sectIndex];	  sectIndex ¬ sectIndex + 1;	  IF sectIndex = sectorsPerTrackBuffer THEN sectIndex ¬ 0;	  ENDLOOP;	IF noErrorInRequestedSect THEN --error sector is not needed this time	  iocb.error ¬ False	ELSE	  iocb.error ¬ True;	END;      END; -- IF iocb.useBuffer AND...    IF iocb.useBuffer AND (iocb.error = False) THEN      -- we have data in the buffer      BEGIN      OPEN tB: trackBufferTable[iocb.mapEntry];      start:CARDINAL = op.clientHeader.sector;      end:CARDINAL = MIN[start + iocb.runLength - 1, sectorsPerTrackBuffer - 1];      dataState, bufferState: PageMap.State;      dataReal, bufferReal: PageMap.RealPageNumber;      dataPage, bufferPageBase, bufferPage: Environment.PageNumber;      sectIndex: CARDINAL;      sectIndex ¬ IF start < tB.firstSect	THEN start - tB.firstSect + sectorsPerTrackBuffer	ELSE start - tB.firstSect;      dataPage ¬ Environment.PageFromLongPointer[op.dataPtr];      bufferPageBase ¬ Environment.PageFromLongPointer[@tB.trackData[0]];      FOR i: CARDINAL IN [start..end] DO	IF xferType = copy THEN	  Inline.LongCOPY[from: @tB.trackData[sectIndex],			  nwords: Environment.wordsPerPage,			  to: op.dataPtr]	ELSE <<map>>	  BEGIN	  bufferPage ¬ bufferPageBase + sectIndex;	  ProcessOperations.DisableInterrupts;	  [state: dataState, real: dataReal] ¬ PageMap.GetState[dataPage];	  [state: bufferState, real: bufferReal] ¬ PageMap.GetState[bufferPage];	  PageMap.SetMapState[virtual: dataPage, real: bufferReal, state: dataState];	  PageMap.SetMapState[virtual: bufferPage, real: dataReal, state: bufferState];	  ProcessOperations.EnableInterrupts;	  tB.sectorValid[Environment.bitsPerWord-1 - sectIndex] ¬ FALSE;	  END;	dataPage ¬ dataPage + 1;	sectIndex ¬ sectIndex + 1;	IF sectIndex = sectorsPerTrackBuffer THEN sectIndex ¬ 0;	pagesCompleted ¬ pagesCompleted + 1;	IF iocb­.incrementDataPtr THEN op.dataPtr ¬	      op.dataPtr + Environment.wordsPerPage;	IncrementClientHeader[iocb: iocb, dcb: dcbPtr];	CDF.NextLabel[op.labelPtr];	ENDLOOP;      END; -- IF iocb.useBuffer AND...    IF iocb.error = True THEN      BEGIN      IF iocb.useBuffer <<retry with good old code, tread as if the error was ComErr>>	   OR iocb.diskOperationBlockError = True	   OR iocb.controllerErrorType = interruptTimeout	   OR iocb.controllerErrorType = controllerNotInIdleLoop	THEN     	  BEGIN	  ds ¬ IOF.deviceStatusComErr;	  iocb.useBuffer ¬ FALSE;<<retry with no track buffering>>	  END	ELSE          BEGIN	  ds ¬ [	    inProgress: FALSE,	    complete: TRUE,            errorDetected: TRUE,            communicationError: FALSE,            dmaTimeout: iocb­.dmaTimedOut = True,            fifoError: 	         dob.headerError.error IN	          [fifoEmptyAtGetCommandBlock..fifoNotEmptyAtLoadCommandBlock]	      OR dob.labelError.error IN                  [fifoEmptyAtGetCommandBlock..fifoNotEmptyAtLoadCommandBlock]	      OR dob.dataError.error IN                  [fifoEmptyAtGetCommandBlock..fifoNotEmptyAtLoadCommandBlock]	      OR dob.lastError.error IN                  [fifoEmptyAtGetCommandBlock..fifoNotEmptyAtLoadCommandBlock],            illegalOperation: FALSE <<illegalOperation handled earlier>>,            ready: ~dob.driveAndControllerStatus.notReady,            protocolViolation:	         dob.lastError.error = protocolViolation              OR dob.labelError.error = protocolViolation              OR dob.headerError.error = protocolViolation              OR dob.dataError.error = protocolViolation	      OR dob.lastError.error = currentCylinderUnknown              OR dob.headerError.error = currentCylinderUnknown,            writeFault: 	         dob.lastError.error = writeFault              <<OR (    iocb­.op.command.data = write	          AND ~dob.driveAndControllerStatus.notWriteFault)>>,            illegalCylinder:                 dob.lastError.error = cylinderTooBig              OR dob.headerError.error = cylinderTooBig,            track00: ~dob.driveAndControllerStatus.notTrack0, 	    unused0: 0,            sectorNotFound: 	         dob.lastError.error = sectorNotFound              OR dob.headerError.error = sectorNotFound,            headerCRCError: dob.headerError.error = headerCRCorECCError,            labelAddressMarkError:	      dob.labelError.error = labelAddressMarkNotFound,            labelIDError: dob.labelError.error = labelIDError,            labelVerifyError: dob.labelError.error = labelVerifyError,            labelCRCError: 	         dob.labelError.error = labelCRCorECCError              OR dob.labelError.error = labelCRCAndVerifyError,            dataAddressMarkError: 	          dob.dataError.error = dataAddressMarkNotFound              AND iocb­.op.command.data # noOp,            dataIDError:	          dob.dataError.error = dataIDError              AND iocb­.op.command.data # noOp,            dataVerifyError: 	          dob.dataError.error = dataVerifyError              AND iocb­.op.command.data # noOp,            dataCRCorECCError:	          (dob.dataError.error = dataCRCorECCError                   OR dob.dataError.error = dataCRCOrECCAndVerifyError)              AND iocb­.op.command.data # noOp,	    unused1: 0];          status ¬ SELECT TRUE FROM            ~ds.ready => notReady,            ds.writeFault => writeFault,            ds.sectorNotFound => headerNotFound,            ds.headerCRCError => headerCRCError,            ds.labelAddressMarkError, ds.labelIDError => otherError,            ds.labelCRCError => labelCRCError,            ds.labelVerifyError => labelVerifyError,            ds.dataAddressMarkError, ds.dataIDError => otherError,            ds.dataCRCorECCError => dataCRCError,            ds.dataVerifyError => dataVerifyError,            ENDCASE => otherError;	  END;      <<A key notion to understanding Poll is that iocb.type is set ONLY        by InitIOCB, exclusively for Poll who ONLY reads it.>>      SELECT iocb.type FROM        normal =>           IF ds.communicationError	   THEN	    BEGIN	    <<An error has been detected but we don't know much about it	      because communication with the controller is disrupted.  In	      particular, if the activity was a multisector transfer, we	      can't SAFELY determine the number of good sectors.  WARNING! 	      Do not change pageLocalization retry effort without a THROUGH	      understanding of controller-fifo-dma failure modes.>>	    ds ¬ IOF.deviceStatusComErr;	    <<dcbPtr.recalibrate ¬ TRUE;>> <<rdc was reset so must recalibrate>>	    pagesCompleted ¬ 0;  <<So no need to update op fields!>>	    IF iocb.try >= op.tries 	      THEN 	        status ¬ otherError	      ELSE	        BEGIN	        IF iocb.try > 3 AND iocb.runLength > 1		     AND iocb.pageLocalization = 0 	          THEN iocb.pageLocalization ¬ iocb.runLength;		       <<Initiate pageLocalization because a communications error		         has occured on a multi-sector transfer and some retries		         have failed.>> 	        status   ¬ inProgress;	        iocb.try ¬ iocb.try + 1;	        END;	    END	   ELSE	    BEGIN            dmaPagesCompleted: CARDINAL;            dobHdr: PDF.DiskAddress;            dobPagesCompleted: CARDINAL;            dmaPagesCompleted ¬ 	       iocb.runLength - DoveInputOutput.ByteSwap[iocb­.pageCount];            dobHdr ¬ LOOPHOLE[DoveInputOutput.LongByteSwap[	        LOOPHOLE[dob.header, LONG UNSPECIFIED]]];            dobPagesCompleted ¬ CARDINAL[	        ConvertDiskAddressToPageNumber[dobHdr, dcbPtr] -		ConvertDiskAddressToPageNumber[op.clientHeader,  dcbPtr]];	    <<Must investigate why use of dob.negativeSectorCount doesn't work>>	    pagesCompleted ¬ IF op.command.data = read	                       THEN MIN[dobPagesCompleted, dmaPagesCompleted]	                       ELSE dobPagesCompleted;	    IF op.command.header = write <<ie. www + format>>	      THEN pagesCompleted ¬ pagesCompleted -	           (pagesCompleted MOD dcbPtr.deviceInformation.sectorsPerTrack);	    IF pagesCompleted > 0 THEN 	      BEGIN	      <<Some progress, so not stuck>> 	      iocb.try ¬ 1;	      iocb.labelFixupType ¬ none; 	      IF iocb.pageLocalization > 0 THEN	        iocb.pageLocalization ¬ iocb.pageLocalization - pagesCompleted;               <<update op fields>>	      op.pageCount ¬ op.pageCount - pagesCompleted;              IF iocb­.incrementDataPtr THEN op.dataPtr ¬	           op.dataPtr + pagesCompleted * Environment.wordsPerPage;	      IF pagesCompleted = dobPagesCompleted	        THEN {op.clientHeader ¬ dobHdr;	              CopyLabelWithByteSwap[@dob.label, op.labelPtr]}		ELSE THROUGH [0..pagesCompleted) DO	               IncrementClientHeader[iocb: iocb, dcb: dcbPtr];                       IF op.command.label # read		         THEN CDF.NextLabel[op.labelPtr];	               ENDLOOP;	      END;            SELECT TRUE FROM              status=labelVerifyError AND	        iocb.labelFixupType = verifyErrorExpected => NULL; 		<<We certainly don't want to retry this expected error.>>	      status = labelVerifyError AND iocb.labelFixupType = none =>                BEGIN	        iocb.labelFixupType ¬ readLabel;	        iocb.labelFixupTry  ¬ 1;	        status ¬ inProgress;	        END;	      dcbPtr.useEcc AND status=dataCRCError AND iocb.try>1 AND	                      op.command.data=read AND TryEccFix[iocb] =>	        BEGIN	        pilotDiskPagesRead ¬ pilotDiskPagesRead + pagesCompleted;                iocb.error ¬ False;		iocb.runLength ¬ 1; <<The fixed page>>	        END;	      ENDCASE => 	        BEGIN	        IF iocb.try < op.tries THEN 		  {status ¬ inProgress; iocb.try ¬  iocb.try + 1};	        IF NeedsRecalibrate[ds, iocb] THEN dcbPtr.recalibrate ¬ TRUE;	        END;	    END;        restore =>          BEGIN	  pagesCompleted ¬ 0;	  dcbPtr.recalibrate ¬ TRUE;	  IF ~ iocb.preRestored	    THEN {status ¬ inProgress; iocb.preRestored ¬ TRUE}	    ELSE IF iocb.try < op.tries 	      THEN {status ¬ inProgress; iocb.try ¬ iocb.try + 1}	      ELSE status ¬ recalibrateError;           END;        labelFixup =>          BEGIN	  pagesCompleted ¬ 0;	  status ¬ inProgress;	  IF iocb.labelFixupTry < 5 	    THEN iocb.labelFixupTry ¬ iocb.labelFixupTry + 1	    ELSE {iocb.try ¬ iocb.try + 1;	          iocb.labelFixupType ¬ verifyErrorExpected};	  END;        ENDCASE;      END;    <<Note If TryEccFix above is executed and the Ecc fix works, then       TryEccFix returns TRUE and iocb.error changes from True to False.      This is the only case that gets treated first as an error and then      as not an error.>>    IF iocb.error = False THEN        BEGIN      SELECT iocb.type FROM        normal => 	  BEGIN	  ds ¬ [            inProgress: FALSE, complete: TRUE, errorDetected: FALSE,            communicationError: FALSE, dmaTimeout: FALSE, fifoError: FALSE,            illegalOperation: FALSE, ready: FALSE, protocolViolation: FALSE,            writeFault: FALSE, illegalCylinder: FALSE,	    track00: (~dob.driveAndControllerStatus.notTrack0) AND NOT iocb.bufferHit,	    unused0: 0, sectorNotFound: FALSE, headerCRCError: FALSE,	    labelAddressMarkError: FALSE, labelIDError: FALSE,	    labelVerifyError: FALSE, labelCRCError: FALSE,	    dataAddressMarkError: FALSE, dataIDError: FALSE,	    dataVerifyError: FALSE, dataCRCorECCError: FALSE, unused1: 0];	  IF NOT iocb.useBuffer THEN	    -- when useBuffer following variables have been already maintained	    BEGIN	    pagesCompleted ¬ iocb.runLength;	    <<update op fields>>	    IF iocb­.incrementDataPtr THEN op.dataPtr ¬		 op.dataPtr + pagesCompleted * Environment.wordsPerPage;	    op.clientHeader ¬ LOOPHOLE[DoveInputOutput.LongByteSwap[		  LOOPHOLE[dob.header, LONG UNSPECIFIED]]];	    IncrementClientHeader[iocb: iocb, dcb: dcbPtr];	    CopyLabelWithByteSwap[@dob.label, op.labelPtr];	    IF op.command.label # read	      THEN CDF.NextLabel[op.labelPtr];	    END;	  iocb.labelFixupType ¬ none; <<May need to clear the fixed state>> 	  IF iocb.pageLocalization > 0 THEN iocb.pageLocalization ¬	     iocb.pageLocalization - pagesCompleted; 	  <<update op field>>	  op.pageCount ¬ op.pageCount - pagesCompleted;	  IF op.pageCount = 0 	    THEN status ¬ goodCompletion 	    ELSE {status ¬ inProgress; iocb.try ¬ 1};	  END;        restore => {pagesCompleted ¬ 0; status ¬ inProgress; iocb.preRestored ¬ TRUE};        labelFixup =>          BEGIN  	  <<iocb.type = labelFixup implies iocb.labelFixupType = readLabel>>	  labelFromDisk: CDF.Label; 	  CopyLabelWithByteSwap[@iocb.dob.label, @labelFromDisk];          IF CDF.MatchLabels[op.labelPtr, @labelFromDisk] 	    THEN {CDF.FixUpLabel[op.labelPtr, @labelFromDisk];	          iocb.labelFixupType ¬ fixed}            ELSE iocb.labelFixupType ¬ verifyErrorExpected;	  pagesCompleted ¬ 0; status ¬ inProgress;          END;        ENDCASE;      END;    IF iocb­.dataCommandTransfer THEN       IF iocb­.dataCommandDirection = fromMesa	THEN pilotDiskPagesWritten ¬ pilotDiskPagesWritten + pagesCompleted	ELSE pilotDiskPagesRead ¬ pilotDiskPagesRead + pagesCompleted;    DiskStatistics[];    IF status = inProgress THEN      BEGIN      op.deviceStatus ¬ LOOPHOLE[IOF.deviceStatusInProgress];      IF InitIOCB[iocb, dcbPtr] THEN ERROR; <<No invalidOperations here!>>      IF iocb.useBuffer AND (iocb.type = normal) THEN        DHI.ReadTrackBuffer[op];      IF iocb.bufferHit THEN        BEGIN	dcbPtr.handlerMesaNext ¬ IOF.nil;	iocb.inProgress ¬ False;	iocb.complete ¬ True;	DHI.NotifyControllerProcess[];	END      ELSE        -- handlerMesaNext may be dequeued by previous hit operation so...	dcbPtr.handlerMesaNext ¬ dcbPtr.mesaHead;      -- no need to call InvalidateTrackBuffer      END     ELSE       BEGIN      <<Aw. We are DONE with this iocb. The fun's over.>>      oldHead: DiskIOFaceDuke.IOCBlongPtr =	Lengthen[DoveInputOutput.ByteSwap[altQWaiting.head]];      op.deviceStatus ¬ LOOPHOLE[ds];      -- statistics      BEGIN      diff: LONG CARDINAL;      waitEnd ¬ System.GetClockPulses[];      diff ¬ (Value[waitEnd] - Value[waitStart]);      accessCount ¬ accessCount + 1;      totalWait ¬ totalWait + diff;      IF diff > maxWait THEN maxWait ¬ diff;      IF diff < minWait THEN minWait ¬ diff;      END;      IF altQWaiting.head # DiskIOFaceDuke.nil THEN	BEGIN	waitStart ¬ System.GetClockPulses[];	IF oldHead.useBuffer AND (oldHead.type = normal) THEN	  DHI.ReadTrackBuffer[LOOPHOLE[oldHead]];	IF trackBufferInitialized AND (oldHead.command.data = write) THEN	  DHI.InvalidateTrackBuffer[op: LOOPHOLE[oldHead], dcb: dcbPtr];	IF oldHead.bufferHit THEN	  BEGIN	  dcbPtr.mesaHead ¬ altQWaiting.head;	  dcbPtr.handlerMesaNext ¬ IOF.nil;	  oldHead.inProgress ¬ False;	  oldHead.complete ¬ True;	  DHI.NotifyControllerProcess[];	  END	ELSE	  dcbPtr.mesaHead ¬ dcbPtr.handlerMesaNext ¬ altQWaiting.head;	END      ELSE        dcbPtr.mesaHead ¬ dcbPtr.handlerMesaNext ¬ altQWaiting.head;       IF altQWaiting.head = altQWaiting.tail	THEN altQWaiting.tail ¬ altQWaiting.head ¬ IOF.nil	ELSE altQWaiting.head ¬ oldHead.mesaNext;      END;    retriedCount ¬ iocb.try - 1;    IF startHandler THEN fcb.startHandlerForMesa ¬ True;    DHI.PromptHandler[];    END;  << of Poll >>  Recalibrate: PUBLIC PROCEDURE [device: PDF.DeviceHandle] = {    fcb.dcb[DeviceHandleToDriveNumber[device]].recalibrate ¬ TRUE};  Reset: PUBLIC PROCEDURE [controller: PDF.ControllerHandle] =    BEGIN    terminalCount: CARDINAL = 0;    counts: CARDINAL ¬ 0;    timeoutCount: LONG CARDINAL ¬ 0;    << Pre-Dove this procedure was a NOP.  However, we have the ability in the Dove-class software to Reset the controller and the supporting handler.  That is what we will do on Dove.  Any outstanding operations will be terminated and have their status marked as "operationReset". >>    <<fcb­.handlerState ¬ resettingHandler;    ResetNotify[disk];    UNTIL fcb­.handlerState = normal DO     timeoutCount ¬ timeoutCount + 1;     IF timeoutCount = 0 THEN {       counts ¬ counts + 1;       IF counts = terminalCount THEN EXIT};    ENDLOOP;    IF fcb­.handlerState # normal THEN ERROR; >>    fcb­.startHandlerForMesa ¬ True;  << until we have Reset worked out this allows the handler to do useful work >>    END;  SetDiskShape: PUBLIC PROCEDURE [    device: PDF.DeviceHandle, shape: SelfDescribingDisks.DiskShape] =    BEGIN    dn: IOF.DriveNumber = DeviceHandleToDriveNumber[device];    dcb: IOF.DCBPtr = @fcb.dcb[dn];    ds: LONG POINTER TO SelfDescribingDisks.DiskShape = @diskShape[dn];    ds­ ¬ shape;    dcb.deviceInformation.sectorsPerTrack ¬ ds.pagesPerTrack;    dcb.deviceInformation.headsPerCylinder ¬ ds.headsPerCylinder;    dcb.deviceInformation.cylindersPerDrive ¬ DoveInputOutput.ByteSwap[ds.cylinderCount];    dcb.deviceInformation.reduceWriteCurrentCylinder ¬ DoveInputOutput.ByteSwap[ds.reducedWriteCylinder];    dcb.deviceInformation.precompensationCylinder ¬ DoveInputOutput.ByteSwap[ds.preCompensationCylinder];    END;  SetRecoveryOptions: PUBLIC PROCEDURE [    drive: PDF.DeviceHandle, eccUse: BOOLEAN] =    BEGIN    dcb: IOF.DCBPtr ¬ @fcb.dcb[DeviceHandleToDriveNumber[drive]];    dcb.useEcc ¬ FALSE;    END;  Shorten: PRIVATE PROCEDURE [long: IOF.IOCBlongPtr]    RETURNS [IOF.IOCBPtr] = INLINE {    RETURN[LOOPHOLE[Inline.LowHalf[long]]]};  OldStart: PUBLIC PROC = {DiskHeadLabeledDukeInternal.OldStartB[]};  SuggestedTries: PUBLIC PROC [device: PDF.DeviceHandle]    RETURNS [PDF.Tries] = {RETURN[24]}; --mumble  TryEccFix: PRIVATE PROCEDURE [iocb: IOF.IOCBlongPtr]    RETURNS [fixed: BOOLEAN] =    BEGIN    -- constants    bitsPerPage: CARDINAL = Environment.wordsPerPage * Environment.bitsPerWord;    dispRegSize: CARDINAL = 11;    eccSize: CARDINAL = 32;    maxDisp: CARDINAL = bitsPerPage - patErrSize;  -- Relative to dataBuffer    patErrSize: CARDINAL = 11;    -- local variables    disp: INTEGER;    dispReg: MACHINE DEPENDENT RECORD [      SELECT OVERLAID * FROM      whole => [all: [0..3777B]],      src => [src0: [0..1], src1to8: [0..377B], src9: [0..1], src10: [0..1]],      dest => [dest0to7: [0..377B], dest8: [0..1], dest9: [0..1], dest10: [0..1]],      ENDCASE];    dataBitsPtr: LONG POINTER TO PACKED ARRAY [0..bitsPerPage) OF [0..1];    fbBitDisp, fbBitPat: [0..1];    i, s0, s1: CARDINAL;    patErr: MACHINE DEPENDENT RECORD [      SELECT OVERLAID * FROM      whole => [all: [0..3777B], pada: [0..37B]],      bitArray => [bits: PACKED ARRAY [0..patErrSize) OF [0..1], padb: [0..37B]],      load => [hi5: [0..37B], lo6: [0..77B], padl: [0..37B]],      src => [src11: [0..1], src12to21: [0..1777B], pads: [0..37B]],      dest => [dest11to20: [0..1777B], dest21: [0..1], padd: [0..37B]],      ENDCASE];    patZero: MACHINE DEPENDENT RECORD [      SELECT OVERLAID * FROM      whole => [all: [0..1777B]],      src => [src22: [0..1], src23to31: [0..777B]],      dest => [dest22to30: [0..777B], dest31: [0..1]],      ENDCASE];    syndrom: MACHINE DEPENDENT RECORD [  -- to decompose eccSyndrom      dispReg: [0..3777B],  -- from eccSyndrom.a      patErrHi5: [0..37B],  -- from eccSyndrom.a      patErrLo6: [0..77B],  -- from eccSyndrom.b      patZero: [0..1777B]];  -- from eccSyndrom.b    -- Count eccErrors    eccErrorCnt ¬ eccErrorCnt + 1;    -- Make "divided" copy of eccSyndrom    syndrom ¬ LOOPHOLE[iocb.dob.eccSyndrome];    dispReg.all ¬ syndrom.dispReg;    patErr.hi5 ¬ syndrom.patErrHi5;    patErr.lo6 ¬ syndrom.patErrLo6;    patZero.all ¬ syndrom.patZero;    -- Isolate burst pattern    FOR s0 IN [0..21) DO      IF patZero.all = 0 THEN EXIT;      fbBitPat ¬ Inline.BITXOR[patErr.src11, 0];      patErr.dest11to20 ¬ patErr.src12to21;      patErr.dest21 ¬ patZero.src22;      patZero.dest22to30 ¬ patZero.src23to31;      patZero.dest31 ¬ fbBitPat;      REPEAT FINISHED => RETURN[FALSE];  -- not fixable      ENDLOOP;    IF patErr.all = 0 THEN RETURN[FALSE];  -- not fixable    -- Determine S1     FOR s1 IN [0..2047) DO      IF patErr.all = dispReg.all THEN EXIT;      fbBitDisp ¬ Inline.BITXOR[dispReg.src0, 0];      dispReg.dest0to7 ¬ dispReg.src1to8;      dispReg.dest8 ¬ Inline.BITXOR[dispReg.src9, fbBitDisp];      dispReg.dest9 ¬ dispReg.src10;      dispReg.dest10 ¬ fbBitDisp;      REPEAT FINISHED => RETURN[FALSE];  -- not fixable;      ENDLOOP;    -- Determine disp     disp ¬ Inline.LongDivMod[      Inline.LongMult[s0, 19 * 2047] + Inline.LongMult[s1, 195 * 21],      42987].remainder;    -- Make relative to disk data size(incl ecc) from 42987 bit psuedo record    disp ¬ disp + bitsPerPage + eccSize - 42987;    -- Handle Edge effects     IF ~(disp IN [0..maxDisp]) THEN      BEGIN      IF disp < 0 THEN        BEGIN  -- Left justify pattern        THROUGH [0..patErrSize) WHILE patErr.src11 = 0 DO          disp ¬ disp + 1;          patErr.dest11to20 ¬ patErr.src12to21;          patErr.dest21 ¬ 0;          ENDLOOP;        IF disp < 0 THEN RETURN[FALSE];  -- not fixable        END      ELSE        BEGIN  -- Right justify pattern        THROUGH [0..patErrSize) WHILE patErr.dest21 = 0 DO          disp ¬ disp - 1;          patErr.src12to21 ¬ patErr.dest11to20;          patErr.src11 ¬ 0;          ENDLOOP;        IF disp > maxDisp THEN RETURN[FALSE];  -- not fixable        END;      END;    -- Do fix     eccFixCnt ¬ eccFixCnt + 1;    dataBitsPtr ¬ LOOPHOLE[iocb.op.dataPtr];    IF iocb.op.incrementDataPtr THEN      LOOPHOLE[dataBitsPtr, Environment.Long].low ¬        Inline.LowHalf[dataBitsPtr] - Environment.wordsPerPage;    FOR i IN [0..patErrSize) DO      dataBitsPtr[disp + i] ¬ Inline.BITXOR[dataBitsPtr[disp + i], patErr.bits[i]];      ENDLOOP;    RETURN[TRUE];    END;  -- TryEccFix[]  Value: PROCEDURE [pulses: System.Pulses] RETURNS [LONG CARDINAL] = INLINE {    RETURN[LOOPHOLE[pulses]]};  END...LOGKT:  10-Aug-88 13:52:17	Created from DiskHeadDoveMN:  17-Aug-88 18:08:40 Renamed DiskHeadLabeledDuke to DiskHeadLabeledDukeA.MN:   8-Oct-88 22:53:55 Added TrackBuffering.MN:  29-Oct-88 14:31:26 Fixed bug(added AND op.incrementDataPtr to iocb.useBuffer).MN:   2-Nov-88 22:02:02 Fixed bug(can't disk boot from ether-booted Othello).			Made OldStart to call OldStartB.
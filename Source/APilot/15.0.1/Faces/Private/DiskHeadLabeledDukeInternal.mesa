-- Copyright (C) 1988  by Fuji Xerox Corporation. All rights reserved. -- DiskHeadLabeledDukeInternal.mesa -- Last edited by MN:  2-Nov-88 22:03:19DIRECTORY  CompatibilityDiskFace USING [OperationPtr],  DiskIOFaceDuke USING [ClientInfo, ClockPulses, DCBPtr, DeviceContextBlock,    DiskControllerRegisters, DMAStateInfo, DriveNumber, HandlerState,    IOCBPtr, FCBPtr],  DoveInputOutput USING [ByteSwappedPointer, IOPBoolean, NotifyIOP],  Environment USING [bitsPerWord, wordsPerPage],  ESCAlpha USING [aRRIT],  Mopcodes USING [zESC],  ProcessOperations USING [Notify],  PSB USING [PsbIndex, PsbNull];DiskHeadLabeledDukeInternal: DEFINITIONS  IMPORTS DoveInputOutput, ProcessOperations =  BEGIN  AltQ: TYPE = RECORD[head: DiskIOFaceDuke.IOCBPtr, tail: DiskIOFaceDuke.IOCBPtr];  ReplaceAlgorithm: TYPE = {lru, fifo};  XferType: TYPE = {copy, map};  sectorsPerTrackBuffer: CARDINAL;  maxNumberOfBuffers: CARDINAL = 16;  altQInvalid, altQWaiting: AltQ;  fcb: DiskIOFaceDuke.FCBPtr;  nk: LONG POINTER TO CONDITION;  numberOfInstalledDrives: DiskIOFaceDuke.DriveNumber;  numberOfTrackBuffers: [1..maxNumberOfBuffers];  oldestEntry: [0..maxNumberOfBuffers);  replaceAlgorithm: ReplaceAlgorithm;  rdcImplementsTrackReadCommand: BOOLEAN;  timeOfLastPrompt: DiskIOFaceDuke.ClockPulses;  trackBufferInitialized: BOOLEAN;  trackBufferTable: ARRAY[0..maxNumberOfBuffers) OF TrackBufferTableEntry;  xferType: XferType;  savedAltQInvalid, savedAltQWaiting: AltQ;  savedStartHandlerForMesa: DoveInputOutput.IOPBoolean;  savedHandlerState: DiskIOFaceDuke.HandlerState;  savedClientInfo: DiskIOFaceDuke.ClientInfo;  savedCurrentDrivePtr: DoveInputOutput.ByteSwappedPointer;  savedControllerRegisters: DiskIOFaceDuke.DiskControllerRegisters;  savedDriveInfoAndDMAStatus: DiskIOFaceDuke.DMAStateInfo;  savedDCB: ARRAY DiskIOFaceDuke.DriveNumber OF				DiskIOFaceDuke.DeviceContextBlock;  readHit, readHitInvalidSect, readMis: LONG CARDINAL;  writeHit, writeMis: LONG CARDINAL;  totalWait: LONG CARDINAL;  accessCount: LONG CARDINAL;  maxWait, minWait: LONG CARDINAL;  TrackBufferTableEntry: TYPE = MACHINE DEPENDENT RECORD[    order(0): [0..maxNumberOfBuffers),    firstSect(1): [0..Environment.bitsPerWord),    sectorValid(2): PACKED ARRAY[0..Environment.bitsPerWord) OF BOOLEAN,    cylinder(3): CARDINAL,    head(4): CARDINAL,    trackData(5): LONG POINTER TO ATrackData];  ATrackData: TYPE = ARRAY [0..0) OF APage;  APage: TYPE = ARRAY [0..Environment.wordsPerPage) OF CARDINAL;  NotifyControllerProcess: PROCEDURE [] = INLINE    BEGIN    <<This is kind of architecturally wrong, but should work.>>    ConditionPtr: TYPE = LONG POINTER TO Condition;    Condition: TYPE = MACHINE DEPENDENT RECORD[      reserved(0:0..2): [0..7],      tail(0:3..12): PSB.PsbIndex,      available(0:13..13): [0..1],      abortable(0:14..14): BOOLEAN,      wakeup(0:15..15): BOOLEAN];    IF LOOPHOLE[nk, ConditionPtr].tail = PSB.PsbNull THEN      LOOPHOLE[nk, ConditionPtr].wakeup ¬ TRUE    ELSE      ProcessOperations.Notify[nk];    END;  ReadTrackBuffer: PROCEDURE [op: CompatibilityDiskFace.OperationPtr];  InvalidateTrackBuffer: PROCEDURE [op: CompatibilityDiskFace.OperationPtr,				 dcb: DiskIOFaceDuke.DCBPtr];  PromptHandler: PRIVATE PROCEDURE [] = INLINE    BEGIN    << Here we will do a down NOTIFY to prompt the Disk Handler to do some work. >>    DoveInputOutput.NotifyIOP[notifyMask: fcb­.workMask];    timeOfLastPrompt ¬ GetClockPulses[];    END;  OldStartB: PROCEDURE [];  GetClockPulses: PRIVATE PROCEDURE RETURNS [p: DiskIOFaceDuke.ClockPulses] =    MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aRRIT; END;  END.LOGMN:   8-Oct-88 22:55:36	Created.MN:   2-Nov-88 21:56:41 Fixed bug(can't disk boot from ether-booted Othello). Added OldStartB.
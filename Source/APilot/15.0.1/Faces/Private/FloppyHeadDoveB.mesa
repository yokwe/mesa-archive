-- File: FloppyHeadDoveB.mesa - last edit:-- MS	20-Jan-89 15:29:38	move InitializeCleanup here from FloppyHeadDoveA-- JAC	 9-Nov-87 16:39:35 	move DiagnosticDiskChangeClear here from FloppyHeadDoveA-- JAC	 6-Nov-87 15:37:40 	move DiskChangeClear here from FloppyHeadDoveA and only clear currentStream, tapeStatistics, passesOnThisStream if a tape.-- JAC	13-Oct-87 14:28:09 	rearrange module-- JAC	22-Sep-87 18:44:37 	continue splitting-- JAC	28-Aug-87 10:02:24	created-- Copyright (C) 1987 1989 by Xerox Corporation and Fuji Xerox. All rights reserved.<< WARNING... WARNING... WARNING...  If the diagnostic face is ever used for floppy tape diagnostics at least 2 things must be considered.  First, the head must be checked for uses of PilotContext vs. DiagnosticContext.  Second, the recalibrate and seek commands must be fixed for the tape.  The handler deselects the device as soon as it believes that the command is over (that is, after it has sent all the command bytes and read all the result bytes).  In the case of seeks, the termination of sending bytes to the controller is not really the end of the command.  The tape may not yet be in the correct place and the drive would be deselected before the tape has found the correct address.  Since recalibrates move the head at max 77 tracks and tapes have 245 tracks the recalibrate command must be issued at maximum of 4 times.  This is further complicated by the fact that the track 0 signal is not valid from the Wangtec drive.  As a result, the recalibrate must always be issued 4 times to ensure track 0 has been reached.>>DIRECTORY  Device USING [nullType],  DeviceCleanup USING [Await, Item, Reason],  DeviceTypesExtras4 USING [fad5000],  DoveInputOutput USING [NotifyIOP, OpieAddressToLongPointer, QueueBlock],  FloppyCommissure,  FloppyDiagnosticFaceDove,  FloppyDiskFace,  FloppyIOFaceDove,  SpecialFloppyTapeFace;FloppyHeadDoveB: PROGRAM  IMPORTS DeviceCleanup, DoveInputOutput, FloppyCommissure  EXPORTS FloppyCommissure, FloppyDiagnosticFaceDove, FloppyDiskFace, SpecialFloppyTapeFace =    BEGIN OPEN FloppyCommissure, FloppyDiskFace, FloppyIOFaceDove, SpecialFloppyTapeFace;    DiagnosticScratchSpaceForHead: LONG POINTER TO UNSPECIFIED;    SaveDiagnosticQueue: DoveInputOutput.QueueBlock;  SavePilotQueue: DoveInputOutput.QueueBlock;  Save80186Queue: DoveInputOutput.QueueBlock;--*****FloppyDiskFace pieces*****  DiskChangeClear: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[device];    IF ValidDiskDriveNumber[DiskDriveNumber] THEN      BEGIN OPEN dcb:FloppyFCB.FloppyDCB[DiskDriveNumber];      -- IF DoorOpen THEN RETURN ;      -- PilotDiskChanged ¬ FALSE ;      dcb.PilotDiskChanged ¬ dcb.DoorOpen;      IF dcb.DeviceAttributes.type = DeviceTypesExtras4.fad5000 THEN {	currentStream ¬ 0;	tapeStatistics ¬ nullStats;	passesOnThisStream ¬ 0};      END;    END;  << DiskChangeClear >>  GetLogStatus: PUBLIC PROCEDURE [operation: OperationPtr]    RETURNS [logStatus: LogStatus] =    BEGIN RETURN[DESCRIPTOR[operation, SIZE[IOCB]]]; END;  << GetLogStatus >>         Reset: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN InternalReset[]; END;  << Reset >>     InitializeCleanup: PUBLIC PROCEDURE =  -- works by black magic    BEGIN  -- should we save the whole FCB ???    OPEN fcb:FloppyFCB;        item: DeviceCleanup.Item;        DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM        turnOff, kill =>          BEGIN          fcb.FloppyStopHandler ¬ TRUE;          DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];          FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL fcb.FloppyHandlerIsStopped            OR delay > 1000000 DO ENDLOOP;          SaveDiagnosticQueue ¬ fcb.FloppyDiagnosticQueue;          SavePilotQueue ¬ fcb.FloppyPilotQueue;          Save80186Queue ¬ fcb.Floppy80186Queue;          END;        turnOn =>          BEGIN          fcb.FloppyDiagnosticQueue ¬ SaveDiagnosticQueue;          fcb.FloppyPilotQueue ¬ SavePilotQueue;          fcb.Floppy80186Queue ¬ Save80186Queue;          fcb.FloppyStopHandler ¬ FALSE;          DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];          END;        ENDCASE;      ENDLOOP;    END;     --*****FloppyDiagnosticFaceDove pieces*****    DiagnosticAquireLock: PUBLIC PROCEDURE =    BEGIN    FloppyFCB­.FloppyDiagnosticsOn ¬ TRUE;    -- PilotDiskChanged ¬ TRUE ;    END;      DiagnosticDiskChangeClear: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[device];    IF ValidDiskDriveNumber[DiskDriveNumber] THEN      BEGIN OPEN dcb:FloppyFCB.FloppyDCB[DiskDriveNumber];      -- IF DoorOpen THEN RETURN ;      -- FloppyFCB.FloppyDCB[DiskDriveNumber].DiagnosticDiskChanged ¬ FALSE ;      dcb.DiagnosticDiskChanged ¬ dcb.DoorOpen;      IF dcb.DeviceAttributes.type = DeviceTypesExtras4.fad5000 THEN {	currentStream ¬ 0;	tapeStatistics ¬ nullStats;	passesOnThisStream ¬ 0};      END;    END;  << DiagnosticDiskChangeClear >>  DiagnosticGetDeviceAttributes: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [attributes: Attributes] =    BEGIN attributes ¬ InternalGetDeviceAttributes[device, Diagnostics]; END;  << DiagnosticGetDeviceAttributes >>  DiagnosticGetNextDevice: PUBLIC PROCEDURE [previous: DeviceHandle]    RETURNS [next: DeviceHandle] =    BEGIN     next ¬ InternalGetNextDevice[previous];     END;  << DiagnosticGetNextDevice >>  DiagnosticInitialize: PUBLIC PROCEDURE [    notify: WORD, initialAllocation: LONG POINTER] =    BEGIN    DiagnosticClientMask ¬ notify;    DiagnosticScratchSpaceForHead ¬ initialAllocation;    END;  << DiagnosticInitialize >>  DiagnosticInitiate: PUBLIC PROCEDURE [    iocb: IOCBPtr, UseMesaOp: BOOLEAN, ActualfdcCode: fdcCommandType]    RETURNS [status: Status] =    BEGIN    status ¬ InternalInitiate[iocb, Diagnostics, UseMesaOp, ActualfdcCode];    END;  << DiagnosticInitiate >>  DiagnosticPoll: PUBLIC PROCEDURE [iocb: IOCBPtr]    RETURNS [status: Status, retriedCount: CARDINAL] =    BEGIN [status, retriedCount] ¬ InternalPoll[iocb, Diagnostics]; END;  << DiagnosticPoll >>  DiagnosticReleaseLock: PUBLIC PROCEDURE =    BEGIN    FloppyFCB­.FloppyDiagnosticsOn ¬ FALSE;    END;  DiagnosticReset: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN InternalReset[]; END;  << DiagnosticReset >>  DiagnosticSetContext: PUBLIC PROCEDURE [    device: DeviceHandle, context: Context]    RETURNS [NewContextWasSet: BOOLEAN] =    BEGIN    NewContextWasSet ¬ InternalSetContext[device, context, Diagnostics];    END;  << DiagnosticSetContext >> --*****SpecialFloppyTapeFace pieces*****    GetTapeParameters: PUBLIC PROCEDURE [device: DeviceHandle] RETURNS [parameters: Parameters] =    BEGIN    RETURN[[numberOfStreams:maxStreams , maxTracksPerStream: maxTracksPerStream]];    END;      LogicalAddressToPhysicalAddress: PUBLIC PROC [logicalAddress: DiskAddress]   RETURNS [physicalAddress: PhysicalAddress] =    BEGIN    RETURN[[      cylinder:		logicalAddress.cylinder MOD maxTracksPerStream,      stream:		logicalAddress.cylinder / maxTracksPerStream + 1,      sector:		logicalAddress.sector]];    END;     Retention: PUBLIC PROCEDURE [operation: OperationPtr]  RETURNS [status: Status] =  --retentioning is started by submitting an IOCB with a null command and selecting the next stream.  the handler will finish and cause the driver to poll.  the head will then resubmit the IOCB with a stream select back to the current stream to finish the retention.  this is a problem with multiple IOCBs.  currently, another IOCB cannot be submitted until the retention IOCB has been submitted the second time.    BEGIN    iocb: IOCBPtr ¬ LOOPHOLE[operation];    tapeStatistics.retentionsDone ¬ tapeStatistics.retentionsDone + 1;    passesOnThisStream ¬ 0;    tapeStatistics.retentionNeeded ¬ FALSE;        --if currentStream = 0 then the retention command must have happened before any read or write so let's assume that currentStream = 1 and go for it.  if the tape was inserted after the boot this will be true anyway.  however, if the tape was inserted before the boot it could be on any stream and we can't tell which it was so just go with 1.    IF currentStream = 0 THEN currentStream ¬ 1;    retentionInProgress ¬ TRUE;    iocb.operation.address ¬ DiskAddress[1, 0, 1];    status ¬ GetStatusOfNewOperation[iocb, Pilot, FALSE, ReadID];    IF status = inProgress THEN      BEGIN BuildIOCB[iocb, NewOp, Pilot, TRUE]; EnqueueIOCB[iocb]; END    ELSE BEGIN iocb­.OperationState ¬ OperationInvalid; END;    END;     --*****Floppy Commissure pieces*****    GetStatusOfFailedOperation: PUBLIC PROCEDURE [iocb: IOCBPtr]    RETURNS [status: Status ¬ recordNotFound << miscError >> ] =  -- only called if OperationState = OperationFailed    BEGIN    ST0: fdcStatusRegister0Type;    ST1: fdcStatusRegister1Type;    ST2: fdcStatusRegister2Type;    --  ST3 : fdcStatusRegister3Type ;    <<    IF iocb.FDCHung THEN RETURN [ controllerHungError ] ;>>    IF iocb.TimeoutOccurred THEN RETURN[notReady];    IF iocb.CurrentFDCCommand > 0 THEN      BEGIN OPEN com:iocb.fdcCommands[iocb.CurrentFDCCommand];      IF com.NumberOfResultBytes # com.NumberOfResultBytesRead THEN RETURN;  -- hardware error      SELECT com.fdcCode FROM        NullCommand => BEGIN END;        Recalibrate => BEGIN END;        Seek => BEGIN END;        SenseDriveStatus =>          BEGIN          --	    ST3 ¬ LOOPHOLE[com.ResultBytes[1]] ;		not really a fault in this fdc op          --	    IF ST3.Fault THEN RETURN [ recordNotFound ] ;          END;        SenseInterruptStatus =>          BEGIN          ST0 ¬ LOOPHOLE[com.ResultBytes[1]];          IF ST0.NotReadyError THEN RETURN[notReady];          IF ST0.EquipmentCheckError THEN RETURN[notReady << hardwareError >> ];          IF ST0.InterruptType = ReadyLineChangedDuringCommandExecution THEN            RETURN[notReady];          END;        Specify => BEGIN END;        FormatTrack, ReadData, ReadDeletedData, ReadID, ReadTrack, ScanEqual,          ScanHighOrEqual, ScanLowOrEqual, WriteData, WriteDeletedData =>          BEGIN          ST0 ¬ LOOPHOLE[com.ResultBytes[1]];          ST1 ¬ LOOPHOLE[com.ResultBytes[2]];          ST2 ¬ LOOPHOLE[com.ResultBytes[3]];          IF ST0.NotReadyError THEN RETURN[notReady];          IF ST0.InterruptType = ReadyLineChangedDuringCommandExecution THEN            RETURN[notReady];          IF ST1.EndOfTrackError THEN RETURN[recordNotFound];          IF ST2.DataErrorInDataField THEN RETURN[dataError];          IF ST1.DataError THEN RETURN[headerError];          IF com.fdcCode = ReadID THEN            BEGIN IF ST1.SectorNotFoundError THEN RETURN[headerError]; END          ELSE            BEGIN IF ST1.SectorNotFoundError THEN RETURN[recordNotFound]; END;          IF ST1.WriteProtectError THEN RETURN[writeFault];          IF ST2.ControlMark THEN RETURN[deletedData];          IF ST2.WrongCylinder THEN RETURN[cylinderError];          IF ST2.BadCylinder THEN RETURN[cylinderError];          IF ST0.EquipmentCheckError THEN RETURN[notReady];          IF ST1.OverRunError THEN RETURN[dataLost << dmaError >> ];          IF ST1.MissingAddressMarkError THEN RETURN[recordNotFound];          IF ST2.ScanNotSatisfied THEN RETURN[recordNotFound];          IF ST2.MissingAddressMarkInDataField THEN RETURN[dataLost];          IF ST0.InterruptType # NormalTermination THEN RETURN[recordNotFound];          END;        ENDCASE => RETURN[invalidOperation];  -- illegal fdc code      END;    RETURN;  -- we either don't know or can't report exactly what is wrong    END;  << GetStatusOfFailedOperation >>--*****internal pieces*****        InternalReset: PROCEDURE =    BEGIN OPEN fcb:FloppyFCB­;--    SaveDiagnosticQueue: DoveInputOutput.QueueBlock;--    SavePilotQueue: DoveInputOutput.QueueBlock;<<    Save80186Queue: DoveInputOutput.QueueBlock;>>    fcb.FloppyStopHandler ¬ TRUE;  --  tell the Handler to quit cleanly at a convient place    DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];    FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL fcb.FloppyHandlerIsStopped      OR delay > 1000000 DO ENDLOOP;    MarkListAborted[      DoveInputOutput.OpieAddressToLongPointer[fcb.FloppyPilotQueue.queueNext]];  -- abort all remaining Operations--    SaveDiagnosticQueue ¬ fcb.FloppyDiagnosticQueue;<<    Save80186Queue ¬ fcb.Floppy80186Queue;    DoveInputOutput.NotifyIOP[ResetFloppyHandlerMask];  --  reset handler with sledge hammer    FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL delay > 1000000 DO ENDLOOP;    FOR delay: LONG CARDINAL ¬ 0, delay + 1 WHILE fcb.FloppyHandlerIsStopped      AND (delay < 1000000) DO ENDLOOP;  --  twiddle your thumbs until it until handler starts again    fcb.FloppyStopHandler ¬ TRUE;  --  tell the Handler to quit cleanly at a convient place    FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL delay > 1000000 DO ENDLOOP;    FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL fcb.FloppyHandlerIsStopped      OR delay > 1000000 DO ENDLOOP;--    fcb.FloppyDiagnosticQueue ¬ SaveDiagnosticQueue;    fcb.Floppy80186Queue ¬ Save80186Queue;>>    fcb.FloppyResetFDC ¬ TRUE;    fcb.FloppyStopHandler ¬ FALSE;  --  let handler start again    END;  << InternalReset >>  MarkListAborted: PROCEDURE [iocb: IOCBPtr] = INLINE  -- ASSUMES Floppy Handler is STOPPED    BEGIN    WHILE iocb # NIL DO      iocb­.OperationState ¬ OperationAborted;      iocb ¬ DoveInputOutput.OpieAddressToLongPointer[iocb­.NextIOCB];      ENDLOOP;    END;  << MarkListAborted >>  ValidDiskDriveNumber: PROCEDURE [DiskDriveNumber: INTEGER]    RETURNS [BOOLEAN] = INLINE    BEGIN RETURN[GetDeviceType[DiskDriveNumber] # Device.nullType] END;      END...
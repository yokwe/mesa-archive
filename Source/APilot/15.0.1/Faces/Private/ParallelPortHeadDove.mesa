-- ParallelPortHeadDove.mesa-- Created by JMA on 23-Sep-85 14:45:54		-- Last edited:--	BKI	11-Apr-86 12:30:15	:Fix handlerLoaded assignment (AR 9314).--	BKI	 4-Apr-86 15:45:22	:Make cleanup stuff resident (AR 9138).--					:InitializeCleanup checks handlerLoaded.--					:Export ParallelPortFaceExtras.--	JMA	27-Mar-86  9:48:41	:InitializeCleanup now saves port & board status in global var--	JMA	20-Mar-86 18:18:52	:added validation of psoFCB in InitializeCleanup & Initialize --	JMA	18-Jan-86 14:40:15	:write protect and 0938 hang up fixes, hopefully--	JMA	27-Feb-86 15:18:22	:implemented Laser Printing Option detection<<	Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.		The following program was created in 1984 but has not been published within the	 meaning of the copyright law, is furnished under license, and may not be used,	 copied and/or disclosed except in accordance with the terms of said license.>>DIRECTORY   DeviceCleanup USING [Await, Item, Reason],   DoveHandlerIDs USING [pso],   DoveInputOutput USING [BuildMesaClientCondition, Byte, ByteSwap,   	 ClientCondition, GetHandlerIORegionPtr, GetIORegionOffset,	 LockMem, LongPointerToOpieAddress, NotifyIOP, OpieAddress ],   --HeadStartChain USING [Start],   ParallelPortFace USING [CommandStatus, DeviceType, DeviceStatusRec,   	 TransferMode, TransferStatus, TransferRec],   ParallelPortFaceExtras USING [],   ParallelPortIOFaceDove USING [DMACntrlWrdByteOut, DMACntrlWrdBlockOut,    	 FunctionContextBlock, PROMError, PSOBoardStatusRec, PSOPortStatusRec,	 PSOCommandRec, PSOCommandRegrRec, PSOCommandStatusType,	 PSOConfigRegrRec, PSOTransferConfigRec],   SpecialSpace USING [MakeGlobalFrameResident, MakeProcedureResident, SpecialError];    ParallelPortHeadDove: PROGRAM   IMPORTS  DeviceCleanup, DoveInputOutput, SpecialSpace <<, RemainingHeads: HeadStartChain>>   EXPORTS  ParallelPortFace, ParallelPortFaceExtras =     BEGIN     -- Constants    -- Global variables   psoFCB: LONG POINTER TO ParallelPortIOFaceDove.FunctionContextBlock _ NIL;    handlerLoaded: BOOLEAN _ FALSE;  commandInProgress: BOOLEAN _ FALSE;  requestForStatusUpdate: BOOLEAN _ FALSE;  requestForReset: BOOLEAN _ FALSE;  requestForDiagnostics: BOOLEAN _ FALSE;  deviceStatusWasUpdated: BOOLEAN _ FALSE;  deviceWasReset: BOOLEAN _ FALSE;  diagnosticsComplete: BOOLEAN _ FALSE;  deviceWasInitialized: BOOLEAN _ FALSE;    transferAborted: BOOLEAN _ FALSE;		-- also applys to diagnostic process  deviceType:ParallelPortFace.DeviceType;  localBlockPtr: LONG POINTER _ NIL;  localPortStatus: ParallelPortIOFaceDove.PSOPortStatusRec;  localBoardStatus: ParallelPortIOFaceDove.PSOBoardStatusRec;  pendingCommand: ParallelPortIOFaceDove.PSOCommandRec _ [];    Initialize: PUBLIC PROC [notify: WORD]    RETURNS [commandStatus: ParallelPortFace.CommandStatus] =    BEGIN    psoClientConditionPtr: LONG POINTER TO DoveInputOutput.ClientCondition _ NIL;         -- before ANYTHING else, check if handler is loaded and started    IF NOT handlerLoaded THEN RETURN [rejected];        -- Set up Client Condition    psoClientConditionPtr _ @psoFCB.psoClientCondition;    DoveInputOutput.BuildMesaClientCondition [psoClientConditionPtr, notify];    deviceType _ none;    deviceWasInitialized _ TRUE;    localPortStatus _ psoFCB.psoPortStatus;        RETURN [ready];        END;    ParallelPortExists: PUBLIC PROC    RETURNS [BOOLEAN] =    BEGIN    <<Using long loopback delay, determine if LP Option is connected.>>    RETURN[TRUE];    END;         << This command may be issued at ANY time >>  InitiateReset: PUBLIC PROC    RETURNS [commandStatus: ParallelPortFace.CommandStatus] =    BEGIN    LocalReset [];			-- calling an INLINE Proc    RETURN[inProgress]    END;        GetStatus: PUBLIC PROC    RETURNS [deviceStatus: ParallelPortFace.DeviceStatusRec ] =    BEGIN    promError: DoveInputOutput.Byte = ParallelPortIOFaceDove.PROMError;    commandImage: ParallelPortIOFaceDove.PSOCommandRec _ psoFCB.psoCommand;    newPortStatus: ParallelPortIOFaceDove.PSOPortStatusRec _ psoFCB.psoPortStatus;    boardStatus: ParallelPortIOFaceDove.PSOBoardStatusRec _ psoFCB.psoBoardStatus;           IF requestForStatusUpdate THEN     	deviceStatusWasUpdated _ NOT (requestForStatusUpdate _ commandImage.updateStatusCmd);    IF requestForReset THEN    	deviceWasReset _ NOT (requestForReset _ commandImage.resetCmd);    IF requestForDiagnostics THEN    	diagnosticsComplete _ NOT (requestForDiagnostics _ commandImage.diagnosticCmd);        localPortStatus _ newPortStatus;    deviceStatus.fault _ newPortStatus.fault;    deviceStatus.select _ newPortStatus.select;    deviceStatus.busy _ newPortStatus.busy;    deviceStatus.lptPSOPortStatusRec _ LONG [@localPortStatus];        deviceStatus.statusIsUpToDate _ deviceStatusWasUpdated;    deviceStatus.portWasReset _ deviceWasReset;    deviceStatus.portType _ deviceType;    deviceStatus.testResultIsUpToDate _ diagnosticsComplete;     IF boardStatus.stateID = promError THEN deviceStatus.portError _ TRUE;        -- deviceStatus.portException not yet implemented,     --   an unknown interrupt source: not a fault or PROM error interrupt    RETURN [deviceStatus];    END;  InitiateTransfer: PUBLIC PROC [transfer: ParallelPortFace.TransferRec]    RETURNS [commandStatus: ParallelPortFace.CommandStatus ] =    BEGIN    commandImage: ParallelPortIOFaceDove.PSOCommandRec _     	psoFCB.psoCommand;    -- check status first    IF commandImage.commandPending = True THEN RETURN [rejected];        -- start with a fresh record    commandImage _ [];        SELECT transfer.transferMode FROM    	putBlock	=> BEGIN    		   	   [] _ SetForOutputTransfer[transfer];		   	   [] _ SetForBlockOutput[transfer];    		   	   END;		    	putByte		=> BEGIN    		   	   [] _ SetForOutputTransfer[transfer];		   	   [] _ SetForByteOutput[transfer];    		   	   END;		       	ENDCASE		=> RETURN [rejected];	-- also, getBlock and getByte are not implemented		           -- inform handler it's a transfer process    commandImage.transferCmd _ TRUE;    commandImage.commandPending _ True;		-- do not allow another transfer or diagnostics    						--   this flag is cleared by the handler    [pendingCommand] _ DoveInputOutput.LockMem[	-- lock out handler when command is being loaded       operation: or,       address: DoveInputOutput.GetIORegionOffset[@psoFCB.psoCommand],       value: commandImage,       mask:  psoFCB.psoLockMask];    -- reset this deviceStatus flag    deviceStatusWasUpdated _ deviceWasReset _ requestForDiagnostics _ FALSE;    transferAborted _ FALSE;        -- Perform a Down notify    DoveInputOutput.NotifyIOP [psoFCB.psoWorkMask];        -- Returns a status of command in progress    RETURN [inProgress]    END;  GetTransferStatus: PUBLIC PROC    RETURNS [transferStatus: ParallelPortFace.TransferStatus] =    BEGIN    commandImage: ParallelPortIOFaceDove.PSOCommandRec _    		psoFCB.psoCommand;    commandStatus: ParallelPortIOFaceDove.PSOCommandStatusType _    			DoveInputOutput.ByteSwap [psoFCB.psoCommandStatus];        --Get transfer Status from command status of IORegion        SELECT commandStatus FROM        notReady	=> transferStatus _ aborted;    	ready		=> BEGIN			   IF transferAborted 			   THEN transferStatus _ aborted			   ELSE {			    	  IF commandImage.commandPending = True				  THEN transferStatus _ inProgress				  ELSE transferStatus _ success }			   END;	inProgress	=> transferStatus _ inProgress;	incomplete	=> transferStatus _ incomplete;        exceptional	=> transferStatus _ incomplete;	-- PROM error     ENDCASE		=> transferStatus _ incomplete;	    IF commandImage.commandPending = True THEN transferStatus _ inProgress;           RETURN [transferStatus]    END;    InitiateTest: PUBLIC PROC [diagnosticTestPattern: WORD]    RETURNS [commandStatus: ParallelPortFace.CommandStatus] =    BEGIN    commandImage: ParallelPortIOFaceDove.PSOCommandRec _    		psoFCB.psoCommand;    configRegrImage: ParallelPortIOFaceDove.PSOConfigRegrRec =    		[maintMode:TRUE, psoDMAEnable:FALSE];    commandRegrImage: ParallelPortIOFaceDove.PSOCommandRegrRec = [];    -- check status first    IF commandImage.commandPending = True THEN RETURN [rejected];        -- start off with a fresh record    commandImage _ [];        -- load psoFCB.psoConfigRegrVal with following values:    --	1)period _ 0    --	2)useAck _  FALSE    --	3)maintMode _ TRUE    --	4)dmaRequest _ FALSE    --  5)scan _ FALSE    --	6)scanner port _ FALSE    -- ** Use Default All Values **    -- load psoFCB.psoCmdRegrVal with the following values:    --	1)reset _ FALSE    --	2)clearIntr _ FALSE    --	3)enforce20uSecRule _ TRUE    --	4)pso Go _ TRUE            psoFCB.psoConfigRegrVal _ configRegrImage;    psoFCB.psoCmdRegrVal _ commandRegrImage;    psoFCB.psoDiagTestPattern _ DoveInputOutput.ByteSwap [diagnosticTestPattern];        -- inform handler its a diagnostics process    commandImage.diagnosticCmd _ TRUE;    commandImage.commandPending _ True;		-- lock out another diag  or a transfer command    						--  this flag is cleared by the handler    [pendingCommand] _ DoveInputOutput.LockMem[	-- lock out handler when command is being loaded       operation: or,       address: DoveInputOutput.GetIORegionOffset[@psoFCB.psoCommand],       value: commandImage,       mask:  psoFCB.psoLockMask];    requestForDiagnostics _ TRUE;    deviceStatusWasUpdated _ deviceWasReset _ diagnosticsComplete _ FALSE;    transferAborted _ FALSE;    DoveInputOutput.NotifyIOP [psoFCB.psoWorkMask];    RETURN[inProgress]    END;       GetTestResult: PUBLIC PROC    RETURNS [returnPattern: WORD] =    BEGIN    -- get result from IORegion    returnPattern _ DoveInputOutput.ByteSwap [psoFCB.psoDiagReturnPattern];    RETURN [returnPattern];    END;   << This command may be issued at ANY time >>  UpdateStatus:  PUBLIC PROC =    BEGIN    commandImage: ParallelPortIOFaceDove.PSOCommandRec _ [];        commandImage.updateStatusCmd _ TRUE;    [pendingCommand] _ DoveInputOutput.LockMem[		       operation: or,       address: DoveInputOutput.GetIORegionOffset[@psoFCB.psoCommand],       value: commandImage,       mask:  psoFCB.psoLockMask];        deviceStatusWasUpdated _ NOT (requestForStatusUpdate _ TRUE);    -- down notify.    DoveInputOutput.NotifyIOP [psoFCB.psoWorkMask];    RETURN[]    END;  << PRIVATE PROCEDURES >>    LocalInit: PROC    RETURNS [] =     BEGIN    END;      LocalReset: PROC = INLINE    BEGIN    commandImage: ParallelPortIOFaceDove.PSOCommandRec _ [];        commandImage.resetCmd _ TRUE;    commandImage.commandPending _ True;    [pendingCommand] _ DoveInputOutput.LockMem[       operation: or,       address: DoveInputOutput.GetIORegionOffset[@psoFCB.psoCommand],       value: commandImage,       mask:  psoFCB.psoLockMask];         requestForReset _ TRUE;     deviceStatusWasUpdated _ diagnosticsComplete _ deviceWasReset _ FALSE;     deviceType _ none;         -- check if we're aborting any transfer/diagnostic process     -- NOTE: handler resets transfer and diagnostic command bits    commandImage _ psoFCB.psoCommand;    IF (commandImage.transferCmd) OR (commandImage.diagnosticCmd) THEN       transferAborted _ TRUE;       -- down notify.    DoveInputOutput.NotifyIOP [psoFCB.psoWorkMask];  END;	-- LocalReset Inline Proc    SetForBlockOutput: PROC [transfer: ParallelPortFace.TransferRec] =    BEGIN    DMA1CntrlWrdValForWordOutput: WORD = ParallelPortIOFaceDove.DMACntrlWrdBlockOut;    transferConfigImage: ParallelPortIOFaceDove.PSOTransferConfigRec;        -- inform handler it's block output mode    transferConfigImage.transferMode _ outputBlock;    psoFCB.psoTransferConfig _ transferConfigImage;          -- program DMA1 for transfer     -- Convert Transfer Count and Source Pointer for handler    -- load dma control word with proper setting        psoFCB.dma1CntrlWrdVal _ DoveInputOutput.ByteSwap [DMA1CntrlWrdValForWordOutput];    -- transfer count in WORDS    -- Note: data may start in any WORD location within the Environment.Block    psoFCB.psoDMATransferCount _ DoveInputOutput.ByteSwap     		[(transfer.bufferPtr.stopIndexPlusOne - transfer.bufferPtr.startIndex) / 2];    -- creating a start pointer to a word location within the data block    localBlockPtr _ transfer.bufferPtr.blockPointer + (transfer.bufferPtr.startIndex / 2);    psoFCB.psoDMASourcePtr _ DoveInputOutput.LongPointerToOpieAddress [localBlockPtr];          RETURN []    END;      SetForByteOutput: PROC [transfer: ParallelPortFace.TransferRec] =    BEGIN    DMA1CntrlWrdValForByteOutput: WORD = ParallelPortIOFaceDove.DMACntrlWrdByteOut;    transferConfigImage: ParallelPortIOFaceDove.PSOTransferConfigRec;        -- inform handler it's byte output mode    transferConfigImage.transferMode _ outputByte;    psoFCB.psoTransferConfig _ transferConfigImage;    psoFCB.psoByteIO _ DoveInputOutput.ByteSwap [transfer.byteData];     -- program DMA1 for transfer    -- Convert Transfer Count and Source Pointer for handler    -- load dma control word with proper setting        psoFCB.dma1CntrlWrdVal _ DoveInputOutput.ByteSwap [DMA1CntrlWrdValForByteOutput];    psoFCB.psoDMATransferCount _ DoveInputOutput.ByteSwap [1];	-- one byte transfer    psoFCB.psoDMASourcePtr _ DoveInputOutput.LongPointerToOpieAddress [@psoFCB.psoByteIO];        RETURN []    END;          SetForOutputTransfer: PROC [transfer:ParallelPortFace.TransferRec] =    BEGIN    configRegrImage: ParallelPortIOFaceDove.PSOConfigRegrRec =     		[clockCounter:transfer.clockCounter, useAck:transfer.useAck];    commandRegrImage: ParallelPortIOFaceDove.PSOCommandRegrRec =    		[enforce20uSecRule:transfer.enforce20uSecRule];        -- indicate data direction    deviceType _ output;        -- ** Use Default Values **    -- load psoFCB.psoConfigRegrVal with following values:    --	1)period _ client selectable    --	2)useAck _  client selectable    --	3)maintMode _ FALSE    --	4)dmaRequest _ TRUE    --  5)scan _ FALSE    --	6)scanner port _ FALSE          -- ** Use Default Values **    -- load psoFCB.psoCmdRegrVal with the following values:    --	1)reset _ FALSE    --	2)clearIntr _ FALSE    --	3)enforce20uSecRule _ client selectable    --	4)pso Go _ TRUE        -- byte swap for the handler to understand    psoFCB.psoConfigRegrVal _ configRegrImage;    psoFCB.psoCmdRegrVal _ commandRegrImage;    END;     << Note that this clean up procedure DOES NOT save or restore any OPIE structures >>   InitializeCleanup: PUBLIC PROCEDURE =    BEGIN    item: DeviceCleanup.Item;    reason: DeviceCleanup.Reason;        -- check if Laser Printing Option is activated at all    IF NOT handlerLoaded THEN RETURN;        DO      reason _ DeviceCleanup.Await[@item];            SELECT reason FROM 	   turnOff, kill =>	        BEGIN	    	IF psoFCB.psoCommand.commandPending = True THEN	         -- give the handler a little time to finish what it's doing	   	 THROUGH [0..LAST[CARDINAL]] WHILE (psoFCB.psoCommand.commandPending = True) DO	         ENDLOOP;		 		 <<  Update, Reset, and Diagnostic commands should have had time to finish since		 all three commands do not wait at the handler level, except for Transfer command .. >>		 		 commandInProgress _ (psoFCB.psoCommand.commandPending = True);		 -- Transfer may still going but can't wait any longer, commence device quiesce		 IF commandInProgress THEN {		   LocalReset [];	-- all statuses are updated AFTER reset 		   THROUGH [0..LAST[CARDINAL]] DO ENDLOOP };	-- give it a little time		   		-- The Head's global variables are saved by Pilot		--    Save current port and board status for debug	        << board status reflects status AFTER the reset, it should show start state;		      port status however should not have been affected by the reset.  		      localPortStatus contains status at swap time >>		localBoardStatus _ psoFCB.psoBoardStatus;  		localPortStatus _ psoFCB.psoPortStatus;	        END;			    turnOn => {}; -- Head should be ready for the next set of commands		      	    disconnect => NULL;		-- TurnOff was already called	 ENDCASE;      -- ELSE nothing to do if LPO handler non-existent      ENDLOOP;    END;	-- InitializeCleanup    WorkaroundForAR9282: PROCEDURE =    BEGIN    nonEmptyProcedure: BOOLEAN;    nonEmptyProcedure _ TRUE;    END;	-- WorkaroundForAR9282	  << Mainline code >>    psoFCB ¬ DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.pso];    -- avoid WRITE PROTECT FAULT, check if GetHandlerIORegionPtr PROC returned a  --	valid pointer  -- If the pointer is valid, then check if Opie recognized Laser Printing Option  handlerLoaded ¬ (psoFCB # NIL) AND (    LOOPHOLE[DoveInputOutput.ByteSwap [psoFCB.psoCommandStatus],    ParallelPortIOFaceDove.PSOCommandStatusType] # notReady);    SpecialSpace.MakeGlobalFrameResident[frame: LOOPHOLE[ParallelPortHeadDove] !    SpecialSpace.SpecialError => CONTINUE];  SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[InitializeCleanup] !    SpecialSpace.SpecialError => CONTINUE];  SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[WorkaroundForAR9282] !    SpecialSpace.SpecialError => CONTINUE];    InitializeCleanup [];      END.  -- ParallelPortHeadDove.mesa
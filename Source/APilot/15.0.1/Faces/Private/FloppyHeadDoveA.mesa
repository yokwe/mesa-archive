-- File: FloppyHeadDoveA.mesa - last edit:-- MS	20-Jan-89 15:29:16-- Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989 by Xerox Corporation and Fuji Xerox. All rights reserved.<<	File = FloppyHeadDove.mesa	Stored as [BamBam:OSBU North:Xerox]<WFaces>Dove>FloppyHeadDove.mesa	This Head/Handler was deliberately designed to handle multiple disk drives	but NOT to do any parallel disk operations even though the fdc can do some	THIS VERSION OF THE HEAD TRANSLATES THE MESA writeDeletedSector	OPERATIONS to nop AND THE FDC OPERATIONS ReadDeletedData AND        WriteDeletedData TO NullCommand. We need to do this until we find out	what status the controller really returns when operations on deleted	sectors are performed. (kam  3-Oct-85  9:19:47)>>DIRECTORY  Device USING [nullType, Type],  <<DeviceCleanup USING [Await, Item, Reason],>>  DeviceTypesExtras USING [anyFloppy, sa455],  DeviceTypesExtras3 USING [sa475],  DeviceTypesExtras4 USING [fad5000],  Environment USING [Byte, bytesPerPage, bytesPerWord, wordsPerPage],  FloppyDiagnosticFaceDove,  FloppyCommissure,  FloppyDiskFace,  FloppyIOFaceDove,  DoveHandlerIDs USING [floppy],  DoveInputOutput USING [    BuildMesaClientCondition, ByteSwap, ClientCondition, GetHandlerIORegionPtr,    GetIORegionOffset, LockMem, LongPointerToOpieAddress, nilOpieAddress,    NotifyIOP, NotifyMask, OpieAddress, OpieAddressToLongPointer, QueueBlock],  HeadStartChain USING [Start],  Inline USING [BITAND, BITOR, DIVMOD, HighHalf, LongCOPY, LongDivMod, LongMult, LowHalf],  SpecialFloppyTapeFace,  Zone USING [Alignment];FloppyHeadDoveA: PROGRAM  IMPORTS <<DeviceCleanup,>> DoveInputOutput, FloppyCommissure, RemainingHeads: HeadStartChain, Inline  EXPORTS FloppyCommissure, FloppyDiagnosticFaceDove, FloppyDiskFace, HeadStartChain, SpecialFloppyTapeFace =  BEGIN OPEN FloppyCommissure, FloppyDiskFace, FloppyIOFaceDove, SpecialFloppyTapeFace;  FloppyFCB: PUBLIC LONG POINTER TO FunctionContextBlock ¬    DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.floppy];  initialAllocationLength: PUBLIC CARDINAL ¬ SizeOfScratchSpaceForHead;  nullDeviceHandle: PUBLIC DeviceHandle ¬ LOOPHOLE[-1];  operationAlignment: PUBLIC Zone.Alignment ¬ a1;  operationBlockLength: PUBLIC CARDINAL ¬ SIZE[IOCB];  ActualMaxTracksPerFormatOperation: CARDINAL = 1;  ActualNumberOfRetries: Tries ¬ 7;  ActualNumberOfRetriesWhenDMAHit: Tries ¬ 50;--  ResetFloppyHandlerMask: DoveInputOutput.NotifyMask ¬ LOOPHOLE[0];  DiagnosticClientMask: PUBLIC WORD ¬ 0;  PilotClientMask: WORD ¬ 0;  PilotScratchSpaceForHead: LONG POINTER TO UNSPECIFIED;  SizeOfScratchSpaceForHead: CARDINAL = 0;   << SaveDiagnosticQueue: DoveInputOutput.QueueBlock;  SavePilotQueue: DoveInputOutput.QueueBlock;  Save80186Queue: DoveInputOutput.QueueBlock;>>  --private variables for tape support:  tapeStatistics: PUBLIC Statistics ¬ nullStats;	--statistics on the current tape  passesOnThisStream: PUBLIC CARDINAL ¬ 0;	--number of retries for this stream.  used to determine when retentioning is needed  currentStream: PUBLIC CARDINAL ¬ 0;  retentionInProgress: PUBLIC BOOLEAN ¬ FALSE;  retentionQueue: IOCBPtr ¬ NIL;  --queue which will hold iocbs submitted while a retention is in progress    -- ****************************************************************************  --		PUBLIC PROCEDURES EXPORTed to PILOT via FloppyDiskFace & HeadStartChain  -- ****************************************************************************  GetContext: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [context: Context] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[device];    IF ValidDiskDriveNumber[DiskDriveNumber] THEN      BEGIN context ¬ FloppyFCB­.FloppyDCB[DiskDriveNumber].PilotContext; END    ELSE BEGIN context ¬ NullContext; END;    END;  << GetContext >>  GetDeviceAttributes: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [attributes: Attributes] =    BEGIN attributes ¬ InternalGetDeviceAttributes[device, Pilot]; END;  << GetDeviceAttributes >>  GetNextDevice: PUBLIC PROCEDURE [previous: DeviceHandle]    RETURNS [next: DeviceHandle] =    BEGIN next ¬ InternalGetNextDevice[previous]; END;  << GetNextDevice >>              GetStatistics: PUBLIC PROCEDURE RETURNS [stats: Statistics] =     BEGIN RETURN[tapeStatistics] END;            Initialize: PUBLIC PROCEDURE [    notify: WORD, initialAllocation: LONG POINTER] =    BEGIN OPEN fcb:FloppyFCB­;    PilotClientMask ¬ notify;    PilotScratchSpaceForHead ¬ initialAllocation;    fcb.FloppyStopHandler ¬ TRUE;    DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];    FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL fcb.FloppyHandlerIsStopped      OR delay > 1000000 DO ENDLOOP;    InitializeFCB[];    FOR drive: CARDINAL IN [0..MaxNumberOfDiskDrives) DO      InitializeDCB[drive] ENDLOOP;    fcb.FloppyResetFDC ¬ TRUE;    fcb.FloppyStopHandler ¬ FALSE;    DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];    END;  << Initialize >>  <<InitializeCleanup: PUBLIC PROCEDURE =  -- works by black magic    BEGIN  -- should we save the whole FCB ???    OPEN fcb:FloppyFCB;    item: DeviceCleanup.Item;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM        turnOff, kill =>          BEGIN          fcb.FloppyStopHandler ¬ TRUE;          DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];          FOR delay: LONG CARDINAL ¬ 0, delay + 1 UNTIL fcb.FloppyHandlerIsStopped            OR delay > 1000000 DO ENDLOOP;          SaveDiagnosticQueue ¬ fcb.FloppyDiagnosticQueue;          SavePilotQueue ¬ fcb.FloppyPilotQueue;          Save80186Queue ¬ fcb.Floppy80186Queue;          END;        turnOn =>          BEGIN          fcb.FloppyDiagnosticQueue ¬ SaveDiagnosticQueue;          fcb.FloppyPilotQueue ¬ SavePilotQueue;          fcb.Floppy80186Queue ¬ Save80186Queue;          fcb.FloppyStopHandler ¬ FALSE;          DoveInputOutput.NotifyIOP[fcb.FloppyWorkMask];          END;        ENDCASE;      ENDLOOP;    END; >> << InitializeCleanup >>  Initiate: PUBLIC PROCEDURE [operation: OperationPtr]    RETURNS [status: Status] =    BEGIN    iocb: IOCBPtr ¬ LOOPHOLE[operation];    status ¬ InternalInitiate[iocb, Pilot, TRUE, NullCommand];    END;  << Initiate >>              MaxTracksPerFormatOperation: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [maxTracks: CARDINAL] =    BEGIN maxTracks ¬ InternalMaxTracksPerFormatOperation[device]; END;  << MaxTracksPerFormatOperation >>  Poll: PUBLIC PROCEDURE [operation: OperationPtr]    RETURNS [status: Status, retriedCount: CARDINAL] =    BEGIN    iocb: IOCBPtr ¬ LOOPHOLE[operation];    [status, retriedCount] ¬ InternalPoll[iocb, Pilot];    END;  << Poll >>          SetContext: PUBLIC PROCEDURE [device: DeviceHandle, context: Context]    RETURNS [NewContextWasSet: BOOLEAN] =    BEGIN NewContextWasSet ¬ InternalSetContext[device, context, Pilot]; END;  << SetContext >>  Start: PUBLIC PROCEDURE =  -- exported to HeadStartChain - works by black magic    BEGIN RemainingHeads.Start[]; END;  << Start >>  SuggestedTries: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [tries: Tries] = BEGIN tries ¬ InternalSuggestedTries[device]; END;  << SuggestedTries >>  -- ****************************************************************************  --		PUBLIC PROCEDURES for FloppyDiagnosticFaceDove  -- ****************************************************************************  DiagnosticGetContext: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [context: Context] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[device];    IF ValidDiskDriveNumber[DiskDriveNumber] THEN      BEGIN      context ¬ FloppyFCB­.FloppyDCB[DiskDriveNumber].DiagnosticContext;      END    ELSE BEGIN context ¬ NullContext; END;    END;  << DiagnosticGetContext >>      DiagnosticMaxTracksPerFormatOperation: PUBLIC PROCEDURE [    device: DeviceHandle] RETURNS [maxTracks: CARDINAL] =    BEGIN maxTracks ¬ InternalMaxTracksPerFormatOperation[device]; END;  << DiagnosticMaxTracksPerFormatOperation >>  DiagnosticSuggestedTries: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [tries: Tries] =     BEGIN tries ¬ InternalSuggestedTries[device];     END;   << DiagnosticSuggestedTries >>  -- ****************************************************************************  --		PRIVATE PROCEDURES for HEAD  -- ****************************************************************************  InternalGetDeviceAttributes: PUBLIC PROCEDURE [    device: DeviceHandle, client: MesaClientType]    RETURNS [attributes: Attributes] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[device];    IF ValidDiskDriveNumber[DiskDriveNumber] THEN      BEGIN      UpdateAttributesInDeviceContextBlock[DiskDriveNumber, client];      attributes ¬ FloppyFCB­.FloppyDCB[DiskDriveNumber].DeviceAttributes;      END    ELSE BEGIN attributes ¬ NullAttributes; END;    END;  << InternalGetDeviceAttributes >>  InternalGetNextDevice: PUBLIC PROCEDURE [previous: DeviceHandle]    RETURNS [next: DeviceHandle ¬ nullDeviceHandle] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[previous];    DiskDriveNumber ¬      IF previous = nullDeviceHandle THEN 0 ELSE DiskDriveNumber + 1;    WHILE DiskDriveNumber IN [0..MaxNumberOfDiskDrives) DO      IF ValidDiskDriveNumber[DiskDriveNumber] THEN        RETURN[LOOPHOLE[DiskDriveNumber]];      DiskDriveNumber ¬ DiskDriveNumber + 1;      ENDLOOP;    END;  << InternalGetNextDevice >>  InternalInitiate: PUBLIC PROCEDURE [    iocb: IOCBPtr, client: MesaClientType, UseMesaOp: BOOLEAN,    ActualfdcCode: fdcCommandType] RETURNS [status: Status] =    BEGIN        IF tapeStatistics.retentionNeeded AND       FloppyFCB.FloppyDCB[LOOPHOLE[iocb.operation.device]].DeviceAttributes.type = DeviceTypesExtras4.fad5000 THEN {      iocb.OperationState ¬ OperationInvalid;       iocb.savedStatus ¬ otherError;      RETURN[iocb.savedStatus]};      -- Translate the operation as described in the comment    IF UseMesaOp THEN {      IF iocb.operation.function = writeDeletedSector      THEN iocb.operation.function ¬ nop}    ELSE {      IF ActualfdcCode = WriteDeletedData OR ActualfdcCode = ReadDeletedData      THEN ActualfdcCode ¬ NullCommand};        iocb.savedStatus ¬ status ¬ GetStatusOfNewOperation[iocb, client, UseMesaOp, ActualfdcCode];    IF status = inProgress THEN      IF retentionInProgress THEN {      --hold all iocbs from the handler.  in particular we want to hold tape      --iocbs since we do not want to submit a tape operation in the middle of      --a retention.  remember that retentions require 2 iocbs to finish so that      --an operation could sneak in.  in order to maintain simplicity, to let      --retentions finish as quickly as possible and to make sure that the       --floppy and tape are not moving at the same time, hold any floppy      --operations as well        next: IOCBPtr;        iocb.NextIOCB ¬ DoveInputOutput.nilOpieAddress;        IF retentionQueue = NIL THEN           retentionQueue ¬ iocb        ELSE  {  --this is not the first IOCB that will be held	  FOR next ¬ retentionQueue, LOOPHOLE[next.NextIOCB] UNTIL LOOPHOLE[next.NextIOCB, LONG POINTER] = NIL 	    DO ENDLOOP;	  next.NextIOCB ¬ LOOPHOLE[iocb]}}           ELSE {BuildIOCB[iocb, NewOp, client, FALSE]; EnqueueIOCB[iocb]}    ELSE BEGIN iocb­.OperationState ¬ OperationInvalid; END;    END;  << InternalInitiate >>  InternalMaxTracksPerFormatOperation:  PROCEDURE [device: DeviceHandle]    RETURNS [CARDINAL] = INLINE    BEGIN       RETURN[	IF ValidDiskDriveNumber[LOOPHOLE[device]] THEN  	  IF FloppyFCB.FloppyDCB[LOOPHOLE[device]].DeviceAttributes.type = DeviceTypesExtras4.fad5000 THEN	    maxTracksPerStream	  ELSE ActualMaxTracksPerFormatOperation  --leave the number for the floppy alone	ELSE 0];    END;  << InternalMaxTracksPerFormatOperation >>  InternalPoll: PUBLIC PROCEDURE [iocb: IOCBPtr, client: MesaClientType]    RETURNS [status: Status, retriedCount: CARDINAL] =    BEGIN        CurrentOperationState: OperationStateType ¬ iocb.OperationState;  -- do only one read on iocb while queued    SELECT CurrentOperationState FROM      OperationDoesNotExist, OperationBuilt =>        BEGIN status ¬ invalidOperation; retriedCount ¬ 0; END;      OperationInvalid => status ¬ iocb.savedStatus;      OperationWaiting, OperationInProgress =>        BEGIN status ¬ inProgress; retriedCount ¬ iocb.CurrentTryCount - 1; END;      OperationAborted =>        BEGIN        DequeueIOCB[iocb];        status ¬ aborted;        retriedCount ¬ iocb.CurrentTryCount - 1;        END;      OperationCompleted =>        BEGIN        DequeueIOCB[iocb];        UpdateOperation[iocb];	status ¬ goodCompletion;	retriedCount ¬ iocb.CurrentTryCount - 1;	IF retentionInProgress THEN {	  --retentioning is accomplished w/ a ReadID command and selecting next	  --stream.  currentStream is NOT updated.       	  --now resubmit to restore stream	  IF currentStream # iocb.stream THEN {	    status ¬ inProgress;	    ResubmitRetention[iocb, client]}	  ELSE {retentionInProgress ¬ FALSE; SubmitHeldIOCBs[client]}}	ELSE 	  SELECT iocb.GeneralizedFDCOperation FROM	    ReadData, ReadDeletedData, ReadTrack, WriteData, WriteDeletedData =>	      BEGIN	      IF iocb.operation.count > 0 THEN		BEGIN		IF (status ¬ GetStatusOfContinuedOperation[iocb]) = inProgress THEN {		  BuildIOCB[iocb, ContinueOp, client, FALSE];		  EnqueueIOCB[iocb]};		END;	      END;	    --a nop has been turned into a SenseDriveStatus if this is a tape.  since the tape file system wants a nop to return write protected do it here.  if an error has occurred during the SenseDriveStatus we will go to OperationFailed where we don't care about write protect and will just send back the error	    SenseDriveStatus => 	      IF (iocb.operation.function = nop) AND	        FloppyIsWriteProtected[LOOPHOLE[iocb.operation.device]] THEN	          status ¬ writeFault;	    ENDCASE;        END;      OperationFailed =>        BEGIN        DequeueIOCB[iocb];--      DummyCallForBreakPointing[iocb];	IF retentionInProgress THEN { 	  	  --this must be a retention.  see comments above.  ignore errors since	  --we cannot tell the difference between real errors and errors	  --caused by retentioning an unformatted tape.	  IF currentStream # iocb.stream THEN {	    status ¬ inProgress;	    ResubmitRetention[iocb, client]}	  ELSE {	    retentionInProgress ¬ FALSE;	    status ¬ goodCompletion;	    SubmitHeldIOCBs[client]}}	ELSE {	  UpdateOperation[iocb];	  retriedCount ¬ iocb.CurrentTryCount - 1;	  IF iocb.CurrentTryCount >= 3 AND iocb.TimeoutOccurred THEN	    BEGIN status ¬ notReady; RETURN; END;	  IF iocb.CurrentTryCount < iocb.operation.tries THEN	    BEGIN	    status ¬ inProgress;	    UpdateStatistics[iocb];	    IF iocb.tapeSelection = tapeOnStreamSelection THEN { 	    --then this iocb caused a stream selection and we don't want things to get messed up so we'll redo it in case it didn't happen before. by forcing currentStream to be 0, another stream select command will be generated otherwise we would see the stream as correct and not generate the stream select command. 	      currentStream ¬ 0};	    BuildIOCB[iocb, RetryOp, client, FALSE];	    EnqueueIOCB[iocb];	    END	  ELSE BEGIN status ¬ GetStatusOfFailedOperation[iocb]; END};        END;      ENDCASE => BEGIN status ¬ invalidOperation; retriedCount ¬ 0; END;    END;  << InternalPoll >>  InternalSetContext: PUBLIC PROCEDURE [    device: DeviceHandle, context: Context, client: MesaClientType]    RETURNS [NewContextWasSet: BOOLEAN ¬ FALSE] =    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[device];    DasFormat: FormatInfoRecord;    IF ValidDiskDriveNumber[DiskDriveNumber] AND context.format = IBM THEN      BEGIN OPEN dcb:FloppyFCB­.FloppyDCB[DiskDriveNumber];      DasFormat ¬ GetFormatInfo[context, dcb.DeviceAttributes.type].theFormat;      IF DasFormat.ValidFormat THEN        BEGIN        IF client = Diagnostics THEN dcb.DiagnosticContext ¬ context        ELSE dcb.PilotContext ¬ context;        UpdateAttributesInDeviceContextBlock[DiskDriveNumber, client];        NewContextWasSet ¬ TRUE;        END;      END;    END;  << InternalSetContext >>  InternalSuggestedTries:  PROCEDURE [device: DeviceHandle]    RETURNS [Tries] = INLINE    BEGIN     RETURN[IF ValidDiskDriveNumber[LOOPHOLE[device]] THEN ActualNumberOfRetries ELSE 1];    END;  << InternalSuggestedTries >>  -- ****************************************************************************  --		Support PROCEDURES for HEAD  -- ****************************************************************************  BuildIOCB: PUBLIC PROCEDURE [    iocb: IOCBPtr, iocbType: IOCBType, client: MesaClientType, retention: BOOLEAN] =    BEGIN    InitializeIOCB[iocb, iocbType, client];    IF iocb.GeneralizedFDCOperation IN fdcCommandType THEN      IF ImpliedSeek[iocb.GeneralizedFDCOperation] THEN {        SetupFDCPrimitiveOperation[iocb, Seek];        SetupFDCPrimitiveOperation[iocb, SenseInterruptStatus]};	         SetupStreamInfo[iocb, retention];    SELECT iocb.GeneralizedFDCOperation FROM      NullCommand =>        BEGIN--	iocb.ResetAndFlushFlag ¬ TRUE;	-- iocb.FlushFlag ¬ TRUE ;--	iocb.SpecifyFlag ¬ TRUE;--	iocb.RecalFlag ¬ TRUE;        END;      ReadID, SenseDriveStatus, SenseInterruptStatus, Specify =>        BEGIN 	SetupFDCPrimitiveOperation[iocb, iocb.GeneralizedFDCOperation];	END;      FormatTrack, ReadData, ReadDeletedData, ReadTrack, ScanEqual,        ScanHighOrEqual, ScanLowOrEqual, WriteData, WriteDeletedData =>        BEGIN        IF iocb.operation.count # 0 THEN           SetupFDCPrimitiveOperation[iocb, iocb.GeneralizedFDCOperation];        END;      Recalibrate =>        BEGIN        SetupFDCPrimitiveOperation[iocb, Recalibrate];        SetupFDCPrimitiveOperation[iocb, SenseInterruptStatus];        END;      Seek => BEGIN END;      ENDCASE => BEGIN END;          Touch[iocb];    END;  << BuildIOCB >>  ByteSwapIOCB: PROCEDURE [iocb: IOCBPtr] =    BEGIN OPEN iocb­;        ByteSwapDMAandCounter: PROCEDURE [track: LONG POINTER TO TrackDMAandCounterControl] =      BEGIN      track.TotalBytesToTransfer ¬	DoveInputOutput.ByteSwap[track.TotalBytesToTransfer];      track.TotalBytesActuallyTransfered ¬ DoveInputOutput.ByteSwap[	track.TotalBytesActuallyTransfered];      track.CounterControlRegister ¬ 	DoveInputOutput.ByteSwap[track.CounterControlRegister];      track.FirstDMAtransferCount ¬	DoveInputOutput.ByteSwap[track.FirstDMAtransferCount];      track.FirstDMAcontrolWord ¬ 	DoveInputOutput.ByteSwap[track.FirstDMAcontrolWord];      track.NumberOfMiddleDMAtransfers ¬ DoveInputOutput.ByteSwap[	track.NumberOfMiddleDMAtransfers];      track.MiddleDMAtransferCount ¬	DoveInputOutput.ByteSwap[track.MiddleDMAtransferCount];      track.MiddleDMAcontrolWord ¬	DoveInputOutput.ByteSwap[track.MiddleDMAcontrolWord];      track.LastDMAtransferCount ¬	DoveInputOutput.ByteSwap[track.LastDMAtransferCount];      track.LastDMAcontrolWord ¬ 	DoveInputOutput.ByteSwap[track.LastDMAcontrolWord];      END;    ByteSwapDMAandCounter[@firstTrack];    FinalDMACount ¬ DoveInputOutput.ByteSwap[FinalDMACount];    NumberOfFDCCommands ¬ DoveInputOutput.ByteSwap[NumberOfFDCCommands];    CurrentFDCCommand ¬ DoveInputOutput.ByteSwap[CurrentFDCCommand];    numberOfMiddleTrackTransfers ¬       DoveInputOutput.ByteSwap[numberOfMiddleTrackTransfers];    ByteSwapDMAandCounter[@middleTrack];    ByteSwapDMAandCounter[@lastTrack];    END;  << ByteSwapIOCB >>  DequeueIOCB: PROCEDURE [iocb: IOCBPtr] =    BEGIN    Chase: IOCBPtr;    OpieAddressOfIOCB: DoveInputOutput.OpieAddress ¬      DoveInputOutput.LongPointerToOpieAddress[iocb];    queue: LONG POINTER TO DoveInputOutput.QueueBlock ¬ @FloppyFCB­.FloppyPilotQueue;    IF iocb­.OperationIsQueued = TRUE THEN      BEGIN OPEN queue­;      IF queueHead = OpieAddressOfIOCB THEN        BEGIN        queueHead ¬ iocb­.NextIOCB;        IF queueTail = OpieAddressOfIOCB THEN          queueTail ¬ DoveInputOutput.nilOpieAddress;        END      ELSE        BEGIN        FOR Chase ¬ DoveInputOutput.OpieAddressToLongPointer[queueHead],          DoveInputOutput.OpieAddressToLongPointer[Chase­.NextIOCB] WHILE Chase          # NIL DO          --  BEGINLOOP          IF Chase­.NextIOCB = OpieAddressOfIOCB THEN            BEGIN            Chase­.NextIOCB ¬ iocb­.NextIOCB;            IF queueTail = OpieAddressOfIOCB THEN              queueTail ¬ DoveInputOutput.LongPointerToOpieAddress[Chase];            EXIT;            END;          ENDLOOP;        END;      ByteSwapIOCB[iocb];      iocb­.OperationIsQueued ¬ FALSE;      END;    END;  << DequeueIOCB >>--  DummyCallForBreakPointing: PROCEDURE [iocb: IOCBPtr] = BEGIN END;  EnqueueIOCB: PUBLIC PROCEDURE [iocb: IOCBPtr] =    BEGIN    OpieAddressOfIOCB: DoveInputOutput.OpieAddress ¬      DoveInputOutput.LongPointerToOpieAddress[iocb];    queue: LONG POINTER TO DoveInputOutput.QueueBlock ¬ @FloppyFCB­.FloppyPilotQueue;    CurrentOperationState: OperationStateType ¬ iocb­.OperationState;    IF iocb­.OperationIsQueued = FALSE AND iocb­.OperationState = OperationBuilt      THEN      BEGIN OPEN queue­, FloppyFCB­;      oldValue: CARDINAL;      iocb­.OperationIsQueued ¬ TRUE;      iocb­.OperationState ¬ OperationWaiting;      ByteSwapIOCB[iocb];      WHILE (oldValue ¬         DoveInputOutput.LockMem[	  xchg,	   DoveInputOutput.GetIORegionOffset[@FloppyQueueSemaphore], 	   1, 	   FloppyLockMask]) = 1 DO	ENDLOOP;      IF queueHead = DoveInputOutput.nilOpieAddress THEN        queueHead ¬ OpieAddressOfIOCB      ELSE        LOOPHOLE[DoveInputOutput.OpieAddressToLongPointer[queueTail],          IOCBPtr]­.NextIOCB ¬ OpieAddressOfIOCB;      [] ¬ DoveInputOutput.LockMem[        xchg, DoveInputOutput.GetIORegionOffset[@queue­.queueNext] + 1,        Inline.HighHalf[LOOPHOLE[OpieAddressOfIOCB]], FloppyLockMask];  --  IF queueNext = NIL THEN queueNext ¬ iocb      [] ¬ DoveInputOutput.LockMem[        overwriteIfNil, DoveInputOutput.GetIORegionOffset[@queue­.queueNext],        Inline.LowHalf[LOOPHOLE[OpieAddressOfIOCB]], FloppyLockMask];  --  IF queueNext = NIL THEN queueNext ¬ iocb      FloppyQueueSemaphore ¬ 0;      DoveInputOutput.NotifyIOP[FloppyWorkMask];      queueTail ¬ OpieAddressOfIOCB;      END;    END;  << EnqueueIOCB >>  -- modify to take client as a parameter also  FloppyIsWriteProtected: PROCEDURE [DiskDriveNumber: INTEGER]    RETURNS [BOOLEAN] =    BEGIN OPEN dcb:FloppyFCB­.FloppyDCB[DiskDriveNumber];    RETURN[dcb.PilotContext.protect OR dcb.DriveStatusHead0.WriteProtected];    END;  << FloppyIsWriteProtected >>  GetDeviceType: PUBLIC PROCEDURE [DiskDriveNumber: INTEGER]    RETURNS [device: Device.Type] =    BEGIN    EncodedDevice: EncodedDiskDriveType;    EncodedDevice ¬      SELECT DiskDriveNumber FROM        0 => FloppyFCB.FloppyEncodedDeviceTypes.Drive0Type,        1 => FloppyFCB.FloppyEncodedDeviceTypes.Drive1Type,        2 => FloppyFCB.FloppyEncodedDeviceTypes.Drive2Type,        3 => FloppyFCB.FloppyEncodedDeviceTypes.Drive3Type,        ENDCASE => NoDiskDrive;    device ¬      SELECT EncodedDevice FROM        NoDiskDrive => Device.nullType,        anyFloppyDiskDrive => DeviceTypesExtras.anyFloppy,        sa455DiskDrive => DeviceTypesExtras.sa455,        sa475DiskDrive => DeviceTypesExtras3.sa475,	fad5000250KBTapeDrive => DeviceTypesExtras4.fad5000,	fad5000500KBTapeDrive => DeviceTypesExtras4.fad5000,        ENDCASE => Device.nullType;    END;  GetFormatInfo: PROCEDURE [context: Context, device: Device.Type]    RETURNS [      theEncodedSectorLength: EncodedSectorLengthType,      theFormat: FormatInfoRecord] =  BEGIN    theEncodedSectorLength ¬ SELECT context.sectorLength FROM      64 => x128,      128 => x256,      256 => x512,      512 => x1024,      1024 => x2048,      2048 => x4096,      ENDCASE => xIllegal;    theFormat ¬ SELECT device FROM        DeviceTypesExtras.sa455 => sa455FormatInfoTable[theEncodedSectorLength][context.density],        DeviceTypesExtras3.sa475 => sa475FormatInfoTable[theEncodedSectorLength][context.density],	DeviceTypesExtras4.fad5000 => fad5000FormatInfoTable[theEncodedSectorLength][context.density],    ENDCASE => NullFormatInfoRecord ;  END;  << GetFormatInfo >>  GetPort80ControlWord: PROCEDURE [ DiskDriveNumber: INTEGER, device: Device.Type]    RETURNS [cw: Port80ControlWordRecord] =  BEGIN    SELECT device FROM      DeviceTypesExtras.sa455 => cw ¬ sa455Port80ControlWord;      DeviceTypesExtras3.sa475 => cw ¬ sa475Port80ControlWord;      DeviceTypesExtras4.fad5000 =>         BEGIN        cw ¬ fad5000Port80ControlWord;	IF Tape500KBDevice[DiskDriveNumber] THEN cw.Select250KbDataRate ¬ FALSE;	RETURN;  --do not select the drive if this is a tape	END;    ENDCASE => RETURN[LOOPHOLE[0]];        SELECT DiskDriveNumber FROM      0 => cw.DriveSelect0 ¬ TRUE;      1 => cw.DriveSelect1 ¬ TRUE;      2 => cw.DriveSelect2 ¬ TRUE;      3 => cw.DriveSelect3 ¬ TRUE;    ENDCASE => RETURN[LOOPHOLE[0]];  END;  GetSpecifyParameters: PROCEDURE [device: Device.Type]    RETURNS [SRTplusHUT: Environment.Byte, HLTplusNDMA: Environment.Byte] = INLINE  BEGIN    SELECT device FROM      DeviceTypesExtras.sa455 => RETURN[sa455StepRateTimePlusHeadUnloadTime, sa455HeadLoadTimePlusNotInDMAmode];      DeviceTypesExtras3.sa475 => RETURN[sa475StepRateTimePlusHeadUnloadTime, sa475HeadLoadTimePlusNotInDMAmode];      DeviceTypesExtras4.fad5000 => RETURN[fad5000StepRateTimePlusHeadUnloadTime, fad5000HeadLoadTimePlusNotInDMAmode];    ENDCASE => RETURN[0, 0];  END;    GetStatusOfContinuedOperation: PROCEDURE [iocb: IOCBPtr] RETURNS [status: Status ¬ inProgress] = INLINE    BEGIN    DiskDriveNumber: INTEGER ¬ LOOPHOLE[iocb.operation.device];    IF NOT ValidCylinder[DiskDriveNumber, iocb.operation.address.cylinder] THEN RETURN[cylinderError];    IF NOT ValidHead[DiskDriveNumber, iocb.operation.address.head] THEN       RETURN[recordNotFound];    IF NOT ValidSector[DiskDriveNumber, iocb.operation.address.sector] THEN        RETURN[recordNotFound];    END;  GetStatusOfNewOperation: PUBLIC PROCEDURE [    iocb: IOCBPtr, client: MesaClientType, UseMesaOp: BOOLEAN,    ActualfdcCode: fdcCommandType] RETURNS [status: Status ¬ inProgress] =    BEGIN OPEN op:iocb­.operation;    DiskDriveNumber: INTEGER;    tapeThisIOCB: BOOLEAN;    IF iocb = NIL THEN RETURN[invalidOperation];    IF UseMesaOp THEN      BEGIN      IF NOT (op.function IN Function) THEN RETURN[invalidOperation];      iocb.GeneralizedFDCOperation ¬ LookupFDCOpForMesaOp[op.function];      END    ELSE BEGIN iocb.GeneralizedFDCOperation ¬ ActualfdcCode; END;    DiskDriveNumber ¬ LOOPHOLE[op.device];    IF NOT ValidDiskDriveNumber[DiskDriveNumber] THEN RETURN[invalidOperation];        BEGIN OPEN dcb:FloppyFCB­.FloppyDCB[DiskDriveNumber];    tapeThisIOCB ¬ dcb.DeviceAttributes.type = DeviceTypesExtras4.fad5000;    IF (iocb.GeneralizedFDCOperation = NullCommand) AND tapeThisIOCB THEN {    --***this is the pits.  BuildIOCB will do a recalibrate when it sees a null    --command.  the tape cannot be turned off as soon as the recalibrate command    --is issued.  note that this is a problem because Wangtek sends back the track 0    --signal before track 0 has been reached.  since we must insure that the drive    --is not turned off before the operation is completed, we change the nop    --into a SenseDriveStatus.  changing the GeneralizedFDCOperation into a     --SenseDriveStatus means that BuildIOCB will not see the channel's nop    --and a recalibrate will not be issued.  SenseDriveStatus was chosen    --because the handler does not do a periodic SenseDriveStatus in the case of    --a tape.  this tries to recoup any lose we might have occurred (only write    --protect.      iocb.GeneralizedFDCOperation ¬ SenseDriveStatus};    UpdateAttributesInDeviceContextBlock[DiskDriveNumber, client];    IF NOT dcb.DeviceAttributes.ready THEN RETURN[notReady];    IF dcb.DeviceAttributes.diskChange THEN RETURN[diskChange];    IF ((iocb.GeneralizedFDCOperation = WriteData)	OR (iocb.GeneralizedFDCOperation = WriteDeletedData)	OR (iocb.GeneralizedFDCOperation = FormatTrack))       AND FloppyIsWriteProtected[DiskDriveNumber] THEN RETURN[writeFault];    SELECT iocb.GeneralizedFDCOperation FROM      NullCommand, Recalibrate, ScanEqual, ScanHighOrEqual, ScanLowOrEqual,        SenseDriveStatus, SenseInterruptStatus, Specify => BEGIN END;      FormatTrack, ReadData, ReadDeletedData, ReadTrack,        WriteData, WriteDeletedData =>        BEGIN        IF NOT ValidDataPointer[DiskDriveNumber, op.dataPtr] THEN RETURN[memoryError];        IF NOT ValidCylinder[DiskDriveNumber, op.address.cylinder] THEN RETURN[cylinderError];        IF NOT ValidHead[DiskDriveNumber, op.address.head] THEN RETURN[recordNotFound];        IF (iocb.GeneralizedFDCOperation # FormatTrack)	   AND (iocb.GeneralizedFDCOperation # ReadTrack)	   AND (NOT ValidSector[DiskDriveNumber, op.address.sector]) THEN RETURN[recordNotFound];	IF (iocb.GeneralizedFDCOperation = FormatTrack) AND tapeThisIOCB AND	  (op.address.cylinder MOD maxTracksPerStream # 0) THEN	    RETURN[invalidOperation];	IF iocb.GeneralizedFDCOperation = ReadTrack THEN op.address.sector ¬ 1;        END;      ReadID, Seek =>        BEGIN        IF NOT ValidCylinder[DiskDriveNumber, op.address.cylinder] THEN RETURN[cylinderError];        IF NOT ValidHead[DiskDriveNumber, op.address.head] THEN RETURN[recordNotFound];        END;      ENDCASE => RETURN[invalidOperation];  -- illegal fdc oeration    END;    RETURN[inProgress];  -- we can't find anything wrong so . . .    END;  << GetStatusOfNewOperation >>  InitializeDCB: PROCEDURE [DiskDriveNumber: INTEGER] =    BEGIN OPEN FloppyFCB­.FloppyDCB[DiskDriveNumber];    DeviceAttributes.type ¬ GetDeviceType[DiskDriveNumber];    dcbExtraByte1 ¬ 0;    DriveBusy ¬ FALSE;    DiagnosticDiskChanged ¬ FALSE;    PilotDiskChanged ¬ FALSE;    DiagnosticContext ¬ DefaultContext;    PilotContext ¬ DefaultContext;    DoorOpen ¬ FALSE;    SpecifyAndRecalFlags ¬ 0 ;    Port80ControlWord ¬ DoveInputOutput.ByteSwap[GetPort80ControlWord[DiskDriveNumber, DeviceAttributes.type]];    [StepRateTimePlusHeadUnloadTime, HeadLoadTimePlusNotInDMAmode] ¬ GetSpecifyParameters[DeviceAttributes.type];    UpdateAttributesInDeviceContextBlock[DiskDriveNumber, Pilot];    END;  InitializeFCB: PROCEDURE = INLINE    BEGIN OPEN FloppyFCB­;<<    FloppyDiagnosticQueue.queueHead ¬ DoveInputOutput.nilOpieAddress;    FloppyDiagnosticQueue.queueTail ¬ DoveInputOutput.nilOpieAddress;    FloppyDiagnosticQueue.queueNext ¬ DoveInputOutput.nilOpieAddress;>>    FloppyPilotQueue.queueHead ¬ DoveInputOutput.nilOpieAddress;    FloppyPilotQueue.queueTail ¬ DoveInputOutput.nilOpieAddress;    FloppyPilotQueue.queueNext ¬ DoveInputOutput.nilOpieAddress;    END;  InitializeIOCB: PROCEDURE [    iocb: IOCBPtr, iocbType: IOCBType, client: MesaClientType] =    BEGIN OPEN iocb­;    DiskDriveNumber: INTEGER ¬ LOOPHOLE[operation.device];    SELECT iocbType FROM      NewOp =>        BEGIN OPEN FloppyFCB­.FloppyDCB[DiskDriveNumber];        theContext ¬          IF client = Diagnostics THEN DiagnosticContext ELSE PilotContext;        AlternateSectors ¬ FALSE;        MultiTrackMode ¬ DeviceAttributes.twoSided;        SkipDeletedSector ¬ FALSE;        UnusedForNow ¬ 0;        CurrentTryCount ¬ 1;        ResetAndFlushFlag ¬ FALSE;        -- FlushFlag ¬ FALSE ;        SpecifyFlag ¬ FALSE;        RecalFlag ¬ FALSE;        END;      ContinueOp =>        BEGIN        CurrentTryCount ¬ 1;        ResetAndFlushFlag ¬ FALSE;        -- FlushFlag ¬ FALSE ;        SpecifyFlag ¬ FALSE;        RecalFlag ¬ FALSE;        END;      RetryOp =>        BEGIN        CurrentTryCount ¬ CurrentTryCount + 1;        ResetAndFlushFlag ¬ FDCHung OR TimeoutOccurred OR CurrentTryCount >= 5 ;        -- FlushFlag ¬ ResetAndFlushFlag ;        SpecifyFlag ¬ ResetAndFlushFlag;        RecalFlag ¬ ResetAndFlushFlag OR CurrentTryCount >= 4 ;        END;      ENDCASE;    OperationIsQueued ¬ FALSE;    OperationState ¬ OperationBuilt;    NextIOCB ¬ DoveInputOutput.nilOpieAddress;    DataAddress ¬ DoveInputOutput.LongPointerToOpieAddress[operation.dataPtr];    DoveInputOutput.BuildMesaClientCondition[      @ActualClientCondition,      IF client = Diagnostics THEN DiagnosticClientMask ELSE PilotClientMask];    FinalStateOfFDC ¬ LOOPHOLE[0];    PCEResetFDCFlag ¬ FALSE;    PCEStartMotorFlags ¬ 0;    DaDriveNumber ¬ DiskDriveNumber;    FDCHung ¬ FALSE;    firstTrack ¬ InitTrackDMAandCounterControl;    FinalDMACount ¬ 0;    IncrementDataPointer ¬ operation.incrementDataPointer;    TimeoutOccurred ¬ FALSE;    NumberOfFDCCommands ¬ 0;    CurrentFDCCommand ¬ 0;    FOR command: CARDINAL IN [1..MaxfdcCommandsInIOCB] DO      fdcCommands[command] ¬ NullfdcCommandRecord; ENDLOOP;    tapeSelection ¬ none;    stream ¬ 0;    numberOfMiddleTrackTransfers ¬ 0;    middleTrack ¬ InitTrackDMAandCounterControl;    lastTrack ¬ InitTrackDMAandCounterControl;    END;  << InitializeIOCB >>          ResubmitRetention: PROCEDURE [iocb: IOCBPtr, client: MesaClientType]  =  --called when we have determined that we are in the middle of a retention.  --see comments in InternalPoll under ReadID about retentioning.  --resubmit IOCB to go back to the stream we were on before the retentioning   --was started.    BEGIN    currentStream ¬ currentStream - 1;  --fool SetupStreamInfo proc    BuildIOCB[iocb, ContinueOp, client, TRUE];    currentStream ¬ currentStream + 1;    EnqueueIOCB[iocb];    END;  SetupDMAinfo: PROCEDURE [iocb: IOCBPtr] =    BEGIN OPEN iocb­, iocb­.fdcCommands[iocb­.NumberOfFDCCommands];    DiskDriveNumber: INTEGER ¬ LOOPHOLE[operation.device];    LeftOverBytes: INTEGER;    WordOffsetFromPageBoundry: INTEGER;    FormattingBuffer: LONG POINTER TO ARRAY [1..100] OF SectorHeaderRecord ¬      operation.dataPtr;    TempEncodedSectorLength: EncodedSectorLengthType;    DasFormat: FormatInfoRecord;    TempSectorHeaderRecord: SectorHeaderRecord;    theSector: Environment.Byte;    FirstTrackSectorsToTransfer: CARDINAL;    FirstTrackMaxPossibleSectorsToTransfer: CARDINAL;    tapeThisIOCB: BOOLEAN ¬ FloppyFCB.FloppyDCB[DiskDriveNumber].DeviceAttributes.type = DeviceTypesExtras4.fad5000;    lastTrackSectorsToTransfer: CARDINAL;        SetupTrackInfo: PROCEDURE [track: LONG POINTER TO TrackDMAandCounterControl, sectorsToTransfer: CARDINAL] =      BEGIN      track.TotalBytesToTransfer ¬ 	Environment.bytesPerWord * sectorsToTransfer * theContext.sectorLength;      track.CounterControlRegister ¬ StartCounter;          -- Setup DMA          SELECT DataTransferCode FROM	Read =>	  BEGIN	  track.FirstDMAcontrolWord ¬ StartDMARead;	  track.MiddleDMAcontrolWord ¬ StartDMARead;	  track.LastDMAcontrolWord ¬ StartDMARead;	  END;	Write =>	  BEGIN	  track.FirstDMAcontrolWord ¬ StartDMAWrite;	  track.MiddleDMAcontrolWord ¬ StartDMAWrite;	  track.LastDMAcontrolWord ¬ StartDMAWrite;	  END;	ENDCASE;          IF theContext.sectorLength = 512 --1024/2-- THEN {      IF WordOffsetFromPageBoundry = 0 THEN  -- we are on a Mesa page boundry         BEGIN	track.FirstDMAtransferCount ¬ MIN[	  Environment.bytesPerPage*2, track.TotalBytesToTransfer];	END      ELSE	BEGIN	track.FirstDMAtransferCount ¬ MIN[	  Environment.bytesPerPage*2 - 2 * WordOffsetFromPageBoundry,	  track.TotalBytesToTransfer];	END;	      track.FirstDMAcontrolWord.dmaInterruptWhenDone ¬ 	track.FirstDMAtransferCount < track.TotalBytesToTransfer;	      [track.NumberOfMiddleDMAtransfers, LeftOverBytes] ¬ Inline.DIVMOD[	track.TotalBytesToTransfer - track.FirstDMAtransferCount,	Environment.bytesPerPage*2];      IF LeftOverBytes = 0 THEN	track.NumberOfMiddleDMAtransfers ¬ 	  track.NumberOfMiddleDMAtransfers - 2;      IF track.NumberOfMiddleDMAtransfers > 0 THEN	BEGIN	track.MiddleDMAtransferCount ¬ Environment.bytesPerPage*2;	track.MiddleDMAcontrolWord.dmaInterruptWhenDone ¬ TRUE;	END      ELSE BEGIN track.NumberOfMiddleDMAtransfers ¬ 0; END;       track.LastDMAtransferCount ¬	track.TotalBytesToTransfer -	  (track.NumberOfMiddleDMAtransfers * track.MiddleDMAtransferCount	    + track.FirstDMAtransferCount);}      ELSE {      IF WordOffsetFromPageBoundry = 0 THEN  -- we are on a Mesa page boundry	BEGIN	track.FirstDMAtransferCount ¬ MIN[	  Environment.bytesPerPage, track.TotalBytesToTransfer];	END      ELSE	BEGIN	track.FirstDMAtransferCount ¬ MIN[	  Environment.bytesPerPage - 2 * WordOffsetFromPageBoundry,	  track.TotalBytesToTransfer];	END;          track.FirstDMAcontrolWord.dmaInterruptWhenDone ¬ 	track.FirstDMAtransferCount < track.TotalBytesToTransfer;          [track.NumberOfMiddleDMAtransfers, LeftOverBytes] ¬ Inline.DIVMOD[	track.TotalBytesToTransfer - track.FirstDMAtransferCount,	Environment.bytesPerPage];      IF LeftOverBytes = 0 THEN	track.NumberOfMiddleDMAtransfers ¬ 	  track.NumberOfMiddleDMAtransfers - 1;      IF track.NumberOfMiddleDMAtransfers > 0 THEN	BEGIN	track.MiddleDMAtransferCount ¬ Environment.bytesPerPage;	track.MiddleDMAcontrolWord.dmaInterruptWhenDone ¬ TRUE;	END      ELSE BEGIN track.NumberOfMiddleDMAtransfers ¬ 0; END;          track.LastDMAtransferCount ¬	track.TotalBytesToTransfer -	  (track.NumberOfMiddleDMAtransfers * track.MiddleDMAtransferCount	    + track.FirstDMAtransferCount);      };            END;    [TempEncodedSectorLength, DasFormat] ¬ GetFormatInfo[      theContext, GetDeviceType[DiskDriveNumber]];    IF fdcCode = FormatTrack THEN      BEGIN      firstTrack.CounterControlRegister ¬ StartCounter;      TempSectorHeaderRecord.Cylinder ¬         IF tapeThisIOCB THEN operation.address.cylinder MOD maxTracksPerStream        ELSE operation.address.cylinder;      TempSectorHeaderRecord.Head ¬ operation.address.head;      TempSectorHeaderRecord.EncodedBytesPerSector ¬        LOOPHOLE[TempEncodedSectorLength];      IF AlternateSectors THEN        BEGIN        -- NOT SUPPORTED        END      ELSE        BEGIN        FOR theSector IN [1..DasFormat.SectorsPerTrack] DO          TempSectorHeaderRecord.Sector ¬ theSector;          FormattingBuffer­[theSector] ¬ TempSectorHeaderRecord;          ENDLOOP;        END;      firstTrack.TotalBytesToTransfer ¬        2 * DasFormat.SectorsPerTrack * SIZE[SectorHeaderRecord];      firstTrack.FirstDMAtransferCount ¬ firstTrack.TotalBytesToTransfer;      firstTrack.FirstDMAcontrolWord ¬ StartDMAWrite;      IF tapeThisIOCB THEN {        numberOfMiddleTrackTransfers ¬ maxTracksPerStream - 1;	middleTrack.TotalBytesToTransfer ¬ firstTrack.TotalBytesToTransfer;	middleTrack.CounterControlRegister ¬ StartCounter;	middleTrack.FirstDMAtransferCount ¬ middleTrack.TotalBytesToTransfer;	middleTrack.FirstDMAcontrolWord ¬ StartDMAWrite};      END    ELSE      BEGIN      FirstTrackMaxPossibleSectorsToTransfer ¬        IF MultiTrackMode AND DataTransferCode = Read        AND operation.address.head = 0 THEN 2 * DasFormat.SectorsPerTrack        ELSE DasFormat.SectorsPerTrack;      FirstTrackSectorsToTransfer ¬ MIN[        operation.count,        FirstTrackMaxPossibleSectorsToTransfer + 1 - operation.address.sector];	      [, WordOffsetFromPageBoundry] ¬ Inline.LongDivMod[    LOOPHOLE[operation.dataPtr, LONG CARDINAL], Environment.wordsPerPage];	      SetupTrackInfo[@firstTrack, FirstTrackSectorsToTransfer];	          IF tapeThisIOCB AND ~(fdcCode = ReadTrack) THEN         BEGIN	sectorsLeftOnThisStream: CARDINAL ¬ MIN[	  operation.count - FirstTrackSectorsToTransfer,	  maxTracksPerStream * DasFormat.SectorsPerTrack -	    ((operation.address.cylinder MOD maxTracksPerStream + 1) *	      DasFormat.SectorsPerTrack)	  ];	                IF sectorsLeftOnThisStream # 0 THEN 	  BEGIN	  [numberOfMiddleTrackTransfers, lastTrackSectorsToTransfer] ¬ 	    Inline.DIVMOD[	      sectorsLeftOnThisStream, DasFormat.SectorsPerTrack];	      	  IF numberOfMiddleTrackTransfers # 0 THEN 	    	    SetupTrackInfo[@middleTrack, DasFormat.SectorsPerTrack]; 	  IF lastTrackSectorsToTransfer # 0 THEN	    SetupTrackInfo[@lastTrack, lastTrackSectorsToTransfer];	   END;	END;          END;    END;  << SetupDMAinfo >>  SetupFDCPrimitiveOperation: PROCEDURE [    iocb: IOCBPtr, ActualfdcCode: fdcCommandType] =    BEGIN OPEN iocb­;    DiskDriveNumber: INTEGER ¬ LOOPHOLE[operation.device];    TempEncodedSectorLength: EncodedSectorLengthType;    DasFormat: FormatInfoRecord;    tapeThisIOCB: BOOLEAN ¬ FloppyFCB.FloppyDCB[DiskDriveNumber].DeviceAttributes.type = DeviceTypesExtras4.fad5000;    NumberOfFDCCommands ¬ NumberOfFDCCommands + 1;    BEGIN OPEN fdcCommands[NumberOfFDCCommands];    [TempEncodedSectorLength, DasFormat] ¬ GetFormatInfo[      theContext, GetDeviceType[DiskDriveNumber]];    fdcCode ¬ ActualfdcCode;    DataTransferCode ¬ DataTransferOperation[ActualfdcCode];    NumberOfCommandBytes ¬ NumberOfFDCCommandBytes[ActualfdcCode];    NumberOfResultBytes ¬ NumberOfFDCResultBytes[ActualfdcCode];    MustWaitForInterrupt ¬ WaitForInterrupt[ActualfdcCode];    CommandBytes[1] ¬ FDCCommandCode[ActualfdcCode];    IF MultiTrackMode THEN CommandBytes[1] ¬ Inline.BITOR[CommandBytes[1], 80H];    IF theContext.density = double THEN      CommandBytes[1] ¬ Inline.BITOR[CommandBytes[1], 40H];    IF SkipDeletedSector THEN CommandBytes[1] ¬ Inline.BITOR[CommandBytes[1], 20H];    CommandBytes[1] ¬ Inline.BITAND[CommandBytes[1], FDCCommandByteOneMask[fdcCode]];    CommandBytes[2] ¬ DiskDriveNumber;    IF operation.address.head = 1 THEN      CommandBytes[2] ¬ Inline.BITOR[CommandBytes[2], 04H];    CommandBytes[2] ¬ Inline.BITAND[CommandBytes[2], FDCCommandByteTwoMask[fdcCode]];    IF tapeThisIOCB THEN       CommandBytes[3] ¬ operation.address.cylinder MOD maxTracksPerStream    ELSE CommandBytes[3] ¬ operation.address.cylinder;        CommandBytes[4] ¬ operation.address.head;    CommandBytes[5] ¬ operation.address.sector;    CommandBytes[6] ¬ LOOPHOLE[TempEncodedSectorLength];    CommandBytes[7] ¬ DasFormat.SectorsPerTrack;    CommandBytes[8] ¬ DasFormat.ReadWriteGapLength;    CommandBytes[9] ¬ IF CommandBytes[6] = 0 THEN 128 ELSE 255;    --    fix up fdcCodes that dont fit the general case    SELECT ActualfdcCode FROM      NullCommand => BEGIN END;      FormatTrack =>        BEGIN        CommandBytes[3] ¬ LOOPHOLE[TempEncodedSectorLength];        CommandBytes[4] ¬ DasFormat.SectorsPerTrack;        CommandBytes[5] ¬ DasFormat.FormatGapLength;        CommandBytes[6] ¬ 	  IF tapeThisIOCB THEN fillerByteForTapeFormatting 	  ELSE FloppyFCB.FloppyFillerByteForFormatting;        END;      ReadData => BEGIN END;      ReadDeletedData => BEGIN END;      ReadID => BEGIN END;      ReadTrack => BEGIN END;      Recalibrate => BEGIN END;      ScanEqual =>        BEGIN CommandBytes[9] ¬ IF AlternateSectors THEN 2 ELSE 1; END;      ScanHighOrEqual =>        BEGIN CommandBytes[9] ¬ IF AlternateSectors THEN 2 ELSE 1; END;      ScanLowOrEqual =>        BEGIN CommandBytes[9] ¬ IF AlternateSectors THEN 2 ELSE 1; END;      Seek => BEGIN END;      SenseDriveStatus => BEGIN END;      SenseInterruptStatus => BEGIN END;      Specify =>        BEGIN OPEN FloppyFCB­.FloppyDCB[DiskDriveNumber];        CommandBytes[2] ¬ StepRateTimePlusHeadUnloadTime;        CommandBytes[3] ¬ HeadLoadTimePlusNotInDMAmode;        END;      WriteData => BEGIN END;      WriteDeletedData => BEGIN END;      ENDCASE => NULL;    IF DataTransferCode = Read OR DataTransferCode = Write THEN      SetupDMAinfo[iocb];    END;    END;  << SetupFDCPrimitiveOperation >>      SetupStreamInfo: PROCEDURE [iocb: IOCBPtr, retention: BOOLEAN] = INLINE    BEGIN    newStream: CARDINAL;    IF FloppyFCB.FloppyDCB[LOOPHOLE[iocb.operation.device]].DeviceAttributes.type # DeviceTypesExtras4.fad5000 THEN RETURN;    IF retention THEN {      iocb.tapeSelection ¬ tapeOnStreamSelection;      IF currentStream < maxStreams THEN iocb.stream ¬ currentStream + 1      ELSE IF currentStream = maxStreams THEN iocb.stream ¬ currentStream - 1}    ELSE {      newStream ¬ iocb.operation.address.cylinder / maxTracksPerStream + 1;      SELECT iocb.GeneralizedFDCOperation FROM	FormatTrack => 	  BEGIN	  iocb.stream ¬ currentStream ¬ newStream;	  tapeStatistics ¬ nullStats;	  iocb.tapeSelection ¬ formatSelection;	  END;	Specify, SenseInterruptStatus => BEGIN END;	NullCommand, SenseDriveStatus => iocb.tapeSelection ¬ tapeOn;	ReadData, ReadDeletedData, ReadID, ReadTrack, ScanHighOrEqual, 	ScanLowOrEqual, Seek, WriteData, WriteDeletedData =>	  IF currentStream # newStream THEN  {	    iocb.tapeSelection ¬ tapeOnStreamSelection;	    currentStream ¬ iocb.stream ¬ newStream;	    passesOnThisStream ¬ 0}	  ELSE iocb.tapeSelection ¬ tapeOn;	ENDCASE};    END;       SubmitHeldIOCBs: PROCEDURE [client: MesaClientType] =    --submit those IOCBs to the handler which were held because a retention was   --in progress     BEGIN     IF retentionQueue = NIL THEN RETURN;     FOR next: IOCBPtr ¬ retentionQueue, LOOPHOLE[next.NextIOCB] UNTIL next = NIL DO       BuildIOCB[next, NewOp, client, FALSE];       EnqueueIOCB[next];       ENDLOOP;     END;      Tape500KBDevice: PROCEDURE [DiskDriveNumber: INTEGER]    RETURNS [ThisIsA500KBTape: BOOLEAN] = INLINE    --determine if the drive attached is a 500KB tape    BEGIN    EncodedDevice: EncodedDiskDriveType;    EncodedDevice ¬      SELECT DiskDriveNumber FROM        0 => FloppyFCB.FloppyEncodedDeviceTypes.Drive0Type,        1 => FloppyFCB.FloppyEncodedDeviceTypes.Drive1Type,        2 => FloppyFCB.FloppyEncodedDeviceTypes.Drive2Type,        3 => FloppyFCB.FloppyEncodedDeviceTypes.Drive3Type,        ENDCASE => NoDiskDrive;    ThisIsA500KBTape ¬      SELECT EncodedDevice FROM	fad5000250KBTapeDrive => FALSE,	fad5000500KBTapeDrive => TRUE,        ENDCASE => FALSE;    END;      Touch: PROCEDURE [iocb: IOCBPtr] =  --This procedure touches every page of the data buffer in order to get the map flags set correctly because the IOP does not do this.  This is especially important in the case of writes into memory from the floppy/tape.  If the pages are not marked as dirty, the data may be lost if pilot decides to reclaim memory before the client looks at the buffer.  Watch out for LONG CARDINALs and the germ.    BEGIN        TouchTheRun: PROCEDURE [addr: LONG POINTER, count: CARDINAL, dirty: BOOLEAN] = INLINE      BEGIN      IF dirty THEN {        next: LONG POINTER = addr + 1;        IF count # 0 THEN {           addr­ ¬ 0; 	   Inline.LongCOPY[from:addr, to: next, nwords: count-1] };	   }      ELSE         THROUGH [0..count) DO dummy: CARDINAL ¬ addr­;            addr ¬ addr + 1;	ENDLOOP;      END;  --of TouchTheRun          DasFormat: FormatInfoRecord;    runLength: CARDINAL;    addr: LONG POINTER ¬ iocb.operation.dataPtr;    rl: CARDINAL;    thisTimeRunLength: CARDINAL;    touchCount: CARDINAL;    touchRunLength: CARDINAL;          IF addr = NIL OR       DataTransferOperation[iocb.GeneralizedFDCOperation] = None THEN RETURN;    [ ,DasFormat] ¬       GetFormatInfo[iocb.theContext, GetDeviceType[iocb.DaDriveNumber]];    runLength ¬       IF FloppyFCB.FloppyDCB[LOOPHOLE[iocb.DaDriveNumber]].DeviceAttributes.type = DeviceTypesExtras4.fad5000 THEN  MIN[iocb.operation.count,         ((maxTracksPerStream * DasFormat.SectorsPerTrack) - 	(((iocb.operation.address.cylinder MOD maxTracksPerStream) * DasFormat.SectorsPerTrack) +	(iocb.operation.address.sector - 1)))]      ELSE MIN [iocb.operation.count,         DasFormat.SectorsPerTrack - (iocb.operation.address.sector - 1)];    rl ¬ IF iocb.operation.incrementDataPointer THEN runLength ELSE 1;    touchRunLength ¬ MIN[rl, LAST[CARDINAL]/iocb.theContext.sectorLength];    UNTIL rl = 0 DO      thisTimeRunLength ¬ MIN[rl, touchRunLength];            touchCount ¬ thisTimeRunLength * iocb.theContext.sectorLength;      TouchTheRun[        addr: addr, 	count: touchCount, 	dirty: DataTransferOperation[iocb.GeneralizedFDCOperation] = Read];      rl ¬ rl - thisTimeRunLength;      addr ¬ addr + touchCount;      ENDLOOP;    END;  UpdateAttributesInDeviceContextBlock: PROCEDURE [    DiskDriveNumber: INTEGER, client: MesaClientType] =    BEGIN    OPEN dcb:FloppyFCB­.FloppyDCB[DiskDriveNumber],         das:FloppyFCB­.FloppyDCB[DiskDriveNumber].DeviceAttributes;    DasFormat: FormatInfoRecord;    das.type ¬ GetDeviceType[DiskDriveNumber];    DasFormat ¬ GetFormatInfo[      IF client = Diagnostics THEN dcb.DiagnosticContext ELSE dcb.PilotContext,      das.type].theFormat;    das.numberOfCylinders ¬ SELECT das.type FROM	Device.nullType => 0,	DeviceTypesExtras.sa455 => 40,	DeviceTypesExtras3.sa475 => 77,	DeviceTypesExtras4.fad5000 => maxStreams * maxTracksPerStream,      ENDCASE => 0;    das.numberOfHeads ¬ IF dcb.DriveStatusHead0.TwoSided THEN 2 ELSE 1;    das.maxSectorsPerTrack ¬ DasFormat.SectorsPerTrack;    das.formatLength ¬ DasFormat.SectorsPerTrack * SIZE[SectorHeaderRecord];    das.ready ¬ dcb.DriveStatusHead0.Ready;    das.diskChange ¬      IF client = Diagnostics THEN dcb.DiagnosticDiskChanged ELSE dcb.PilotDiskChanged;    das.twoSided ¬ dcb.DriveStatusHead0.TwoSided;    das.busy ¬ dcb.DriveBusy;    END;  << UpdateAttributesInDeviceContextBlock >>  -- Joe Pasqua's version of UpdateOperation  UpdateOperation: PROCEDURE [iocb: IOCBPtr] =    BEGIN OPEN iocb;    SectorsTransfered: CARDINAL;    knowSectorsTransfered: BOOLEAN ¬ FALSE;    handlingError: BOOLEAN;    tapeThisIOCB: BOOLEAN ¬ FloppyFCB.FloppyDCB[LOOPHOLE[iocb.operation.device]].DeviceAttributes.type = DeviceTypesExtras4.fad5000;    DiskAddressToSector: PROCEDURE [      diskAddress: DiskAddress, tracksPerCylinder: CARDINAL,      sectorsPerTrack: CARDINAL] RETURNS [sector: CARDINAL] = INLINE {      RETURN[        diskAddress.sector +          sectorsPerTrack *            (diskAddress.head + tracksPerCylinder * diskAddress.cylinder)]};    IF NumberOfFDCCommands <= 0 THEN {operation.count ¬ 0; RETURN};	-- get out on nop's, they are always complete    IF CurrentFDCCommand <= 0 THEN RETURN ;    IF FDCHung THEN RETURN;    IF TimeoutOccurred THEN RETURN;    SELECT fdcCommands[CurrentFDCCommand].fdcCode FROM      ReadData, ReadDeletedData, ReadID, ReadTrack, ScanEqual, ScanHighOrEqual,        ScanLowOrEqual, WriteData, WriteDeletedData => NULL;      -- We'll do more checking later for this case...      ENDCASE =>  --FormatTrack, Recalibrate, Specify, Sense*Status, Seek, Null        IF FinalDMACount + firstTrack.TotalBytesActuallyTransfered # 0 THEN RETURN;    -- too hard to analyse for now    IF CurrentFDCCommand = NumberOfFDCCommands THEN      BEGIN OPEN fdcCommands[CurrentFDCCommand];      IF NumberOfResultBytes # NumberOfResultBytesRead THEN RETURN;      SELECT fdcCode FROM        FormatTrack =>          IF OperationState = OperationCompleted THEN BEGIN	    operation.address.sector ¬ 1;	    IF tapeThisIOCB THEN	      operation.address.cylinder ¬ 	        operation.address.cylinder + maxTracksPerStream	    ELSE operation.address.cylinder ¬ operation.address.cylinder + 1;	    IF MultiTrackMode THEN {	      operation.address.head ¬ 1 - operation.address.head;	      operation.address.cylinder ¬ operation.address.cylinder - operation.address.head};          END;        ReadData, ReadDeletedData, ReadID, ReadTrack, ScanEqual,          ScanHighOrEqual, ScanLowOrEqual, WriteData, WriteDeletedData =>          BEGIN          st0: FloppyIOFaceDove.fdcStatusRegister0Type ¬ LOOPHOLE[ResultBytes[            1]];          st1: FloppyIOFaceDove.fdcStatusRegister1Type ¬ LOOPHOLE[ResultBytes[            2]];          st2: FloppyIOFaceDove.fdcStatusRegister2Type ¬ LOOPHOLE[ResultBytes[            3]];          daPtr: LONG POINTER TO FloppyDiskFace.Attributes ¬            @(FloppyFCB­.FloppyDCB[               LOOPHOLE[iocb.operation.device]].DeviceAttributes);          tracksPerCylinder: CARDINAL ¬ daPtr.numberOfHeads;          sectorsPerTrack: CARDINAL ¬ daPtr.maxSectorsPerTrack;          -- We are now in one of three states (going in we assume #3):          -- 1. An error occurred which we can deal with (handlingError = TRUE)          -- 2. An error occurred which we can't deal with (RETURN)          -- 3. No error occurred (handlingError = FALSE)          handlingError ¬ FALSE;  -- Assume normal completion          IF            (firstTrack.TotalBytesActuallyTransfered + FinalDMACount) MOD              (CARDINAL[theContext.sectorLength] * Environment.bytesPerWord) = 0            AND st1.OverRunError AND st0.InterruptType = AbnormalTermination            AND              ~(st0.SeekEnd OR st0.EquipmentCheckError OR st0.NotReadyError                 OR st1.EndOfTrackError OR st1.DataError                 OR st1.SectorNotFoundError OR st1.WriteProtectError                 OR st1.MissingAddressMarkError OR st2.DataErrorInDataField                 OR st2.WrongCylinder OR st2.ScanEqualHit                 OR st2.ScanNotSatisfied OR st2.BadCylinder                 OR st2.MissingAddressMarkInDataField) THEN handlingError ¬ TRUE          ELSE IF FinalDMACount + firstTrack.TotalBytesActuallyTransfered # 0 THEN	    RETURN;          SectorsTransfered ¬	    IF tapeThisIOCB THEN DiskAddressToSector[                DiskAddress[ResultBytes[4], ResultBytes[5], ResultBytes[6]],                tracksPerCylinder, sectorsPerTrack] - 	      DiskAddressToSector[                DiskAddress[operation.address.cylinder MOD maxTracksPerStream,  0,	          operation.address.sector],	        tracksPerCylinder, sectorsPerTrack]	    ELSE DiskAddressToSector[              DiskAddress[ResultBytes[4], ResultBytes[5], ResultBytes[6]],              tracksPerCylinder, sectorsPerTrack] - DiskAddressToSector[              operation.address, tracksPerCylinder, sectorsPerTrack];          knowSectorsTransfered ¬ TRUE;	  operation.address.cylinder ¬ ResultBytes[4];	  IF tapeThisIOCB THEN operation.address.cylinder ¬  	    operation.address.cylinder + (currentStream - 1) * maxTracksPerStream;          operation.address.head ¬ ResultBytes[5];          operation.address.sector ¬ ResultBytes[6];          IF handlingError AND (NOT tapeThisIOCB) THEN --don't let the tape do that many repositions	    BEGIN	    -- Try real hard when it is a DMA hit	    operation.tries ¬ MAX[	      ActualNumberOfRetriesWhenDMAHit, operation.tries];	    IF SectorsTransfered # 0 THEN CurrentTryCount ¬ 1;            -- We made some progress, so reset the retry count	    END;          END;        ENDCASE;      IF fdcCode = ReadID AND operation.dataPtr # NIL THEN        BEGIN        recordID: RecordIDPtr ¬ LOOPHOLE[operation.dataPtr];        recordID­.address.cylinder ¬ ResultBytes[4];	IF tapeThisIOCB THEN recordID­.address.cylinder ¬ 	  recordID­.address.cylinder + ((currentStream - 1) * maxTracksPerStream);        recordID­.address.head ¬ ResultBytes[5];        recordID­.address.sector ¬ ResultBytes[6];        recordID­.sectorLength ¬	  SELECT LOOPHOLE[ResultBytes[7], EncodedSectorLengthType] FROM	    x128 => 64,	    x256 => 128,	    x512 => 256,	    x1024 => 512,	    x2048 => 1024,	    x4096 => 2048,	    ENDCASE => UnknownSectorLength;        --	recordID­.MachineDependentBytes[1] ¬ ResultBytes[1] ;        --	recordID­.MachineDependentBytes[2] ¬ ResultBytes[2] ;        --	recordID­.MachineDependentBytes[3] ¬ ResultBytes[3] ;        END;	      IF fdcCode = SenseDriveStatus AND tapeThisIOCB THEN  {      --work around a problem where TwoSided is somehow getting set to true        tempStatusRegister: fdcStatusRegister3Type ¬ LOOPHOLE[ResultBytes[1]];        FloppyFCB.FloppyDCB[LOOPHOLE[operation.device]].DriveStatusHead0.WriteProtected ¬ 	  tempStatusRegister.WriteProtected};      SELECT fdcCode FROM        FormatTrack =>          BEGIN          IF OperationState = OperationCompleted AND operation.count > 0 THEN	    IF tapeThisIOCB THEN  --***SHOULD THIS CHECK FOR > 245?	      operation.count ¬ operation.count - maxTracksPerStream            ELSE operation.count ¬ operation.count - 1;          END;        ReadTrack =>          BEGIN          IF OperationState = OperationCompleted AND operation.count > 0 THEN            BEGIN            operation.count ¬ operation.count - 1;            IF operation.incrementDataPointer THEN               operation.dataPtr ¬ 	        operation.dataPtr + firstTrack.TotalBytesToTransfer / 2;            END;          END;        ReadData, ReadDeletedData, ScanEqual, ScanHighOrEqual, ScanLowOrEqual,          WriteData, WriteDeletedData =>          BEGIN          IF firstTrack.TotalBytesActuallyTransfered = 0 THEN            -- since INTEL clears the counter when it reaches MaxCount,            -- we have 0 means either total success or total failure.            IF OperationState = OperationCompleted THEN	    --***IS THIS WHAT I REALLY WANT              firstTrack.TotalBytesActuallyTransfered ¬ 	        IF lastTrack.TotalBytesToTransfer # 0 THEN		  lastTrack.TotalBytesToTransfer		ELSE 		  IF middleTrack.TotalBytesToTransfer # 0 THEN		    middleTrack.TotalBytesToTransfer		  ELSE firstTrack.TotalBytesToTransfer;          IF ~knowSectorsTransfered THEN            SectorsTransfered ¬              firstTrack.TotalBytesActuallyTransfered / (2*theContext.sectorLength);          IF operation.incrementDataPointer THEN            operation.dataPtr ¬ operation.dataPtr + 	      Inline.LongMult[SectorsTransfered, theContext.sectorLength];          operation.count ¬ operation.count - SectorsTransfered;          END;        ENDCASE;      END;    END;  << UpdateOperation >>          UpdateStatistics: PROCEDURE [iocb: IOCBPtr] = INLINE  --update statistics for SpecialFloppyTapeFace.  Note that totalRetriesDone  --may not equal recordNotFoundErrors + retriesDone if somehow the death   --occurred before the handler got to the first command    BEGIN    ST1: fdcStatusRegister1Type;    IF FloppyFCB.FloppyDCB[LOOPHOLE[iocb.operation.device]].DeviceAttributes.type # DeviceTypesExtras4.fad5000 THEN RETURN;        tapeStatistics.totalRetriesDone ¬ tapeStatistics.totalRetriesDone + 1;    IF (passesOnThisStream ¬ passesOnThisStream + 1) > maxRetriesForRetention THEN      tapeStatistics.retentionNeeded ¬ TRUE;    IF iocb.CurrentFDCCommand > 0 THEN      BEGIN OPEN iocb.fdcCommands[iocb.CurrentFDCCommand];      SELECT fdcCode FROM	FormatTrack, ReadData, ReadDeletedData, ReadID, ReadTrack, ScanEqual,	  ScanHighOrEqual, ScanLowOrEqual, WriteData, WriteDeletedData =>	  BEGIN	  ST1 ¬ LOOPHOLE[ResultBytes[2]];	  	  IF ST1.EndOfTrackError OR ST1.MissingAddressMarkError OR	    (fdcCode # ReadID AND ST1.SectorNotFoundError) THEN	      tapeStatistics.recordNotFoundErrors ¬ 		tapeStatistics.recordNotFoundErrors + 1	  ELSE tapeStatistics.retriesDone ¬ tapeStatistics.retriesDone + 1;	  END;	  	ENDCASE => tapeStatistics.retriesDone ¬ tapeStatistics.retriesDone + 1;      END;    END;  ValidCylinder: PROCEDURE [    DiskDriveNumber: INTEGER, cylinder: CARDINAL] RETURNS [BOOLEAN] = INLINE    BEGIN    RETURN[      cylinder < FloppyFCB­.FloppyDCB[        DiskDriveNumber].DeviceAttributes.numberOfCylinders]    END;  << ValidCylinder >>  ValidDataPointer: PROCEDURE [    DiskDriveNumber: INTEGER, DataPointer: LONG POINTER] RETURNS [BOOLEAN] =    BEGIN    WordOffsetFromSectorBoundry: INTEGER;    IF DataPointer = NIL THEN RETURN[FALSE];    [, WordOffsetFromSectorBoundry] ¬ Inline.LongDivMod[      LOOPHOLE[DataPointer, LONG CARDINAL],      FloppyFCB.FloppyDCB[DiskDriveNumber].PilotContext.sectorLength];    IF WordOffsetFromSectorBoundry # 0 THEN RETURN[FALSE];    RETURN[TRUE];    END;  << ValidDataPointer >>  ValidDiskDriveNumber: PROCEDURE [DiskDriveNumber: INTEGER]    RETURNS [BOOLEAN] = INLINE    BEGIN RETURN[GetDeviceType[DiskDriveNumber] # Device.nullType] END;   ValidHead: PROCEDURE [    DiskDriveNumber: INTEGER, head: Environment.Byte] RETURNS [BOOLEAN] = INLINE    BEGIN    RETURN[      head < FloppyFCB­.FloppyDCB[        DiskDriveNumber].DeviceAttributes.numberOfHeads]    END;  << ValidHead >>  ValidSector: PROCEDURE [    DiskDriveNumber: INTEGER, sector: Environment.Byte] RETURNS [BOOLEAN] = INLINE    BEGIN    RETURN[      sector IN        [1..FloppyFCB­.FloppyDCB[           DiskDriveNumber].DeviceAttributes.maxSectorsPerTrack]]    END;  << ValidSector >>  END.	-- of FloppyHeadDove.mesaLOG: 3-Oct-85 08:34:25 kam		Translate xxDeletedSector operations to nops 3-Oct-85 10:34:29 kam/jp	Try at least 50 times if there is a DMA hit25-Jun-87 17:30:53 JAC		add floppy tape support29-Jun-87 15:04:10 JAC		change retentioning implementation				turn NullCommand into ReadID if tape during GetStatusOfNewOperation 6-Jul-87 19:44:40 JAC		fix tapeSelection during formats15-Jul-87  9:34:34 JAC		redo retention using retentionInProgress28-Jul-87 15:48:04 JAC		hold IOCBs while retention in progress 6-Aug-87  9:28:53 JAC		change NullCommand into SenseDriveStatus if tape during GetStatusOfNewOperation 7-Aug-87 10:36:06 JAC		set currentStream in SetupStreamInfo if format 7-Aug-87 16:15:18 JAC		only set WriteProtected bit in DriveStatusHead0 during UpdateOperation if tape and operation is SenseDriveStatus27-Aug-87 18:47:25 JAC		created from FloppyHeadDove22-Sep-87 18:45:09 JAC		continue splitting25-Sep-87  9:53:15 JAC		add touch procedure26-Sep-87 13:56:33 JAC		fix semaphore stuff; add tapeThisIOCB in SetupFDCPrimitiveOperation and use correct format filler byte for tape29-Sep-87 13:43:49 JAC		remove semaphore stuff13-Oct-87 14:25:16 JAC		add semaphore stuff27-Oct-87 14:44:48 JAC	        tape nops should return write protect; use SaveDiagnosticQueue; redo stream selection if an error occurred; make Tape500KBDevice an inline 2-Nov-87 17:09:16 JAC	        add GetStatusOfContinuedOperation 4-Nov-87 17:44:34 JAC	        use GetStatusOfContinuedOperation correctly;use FloppyIsWriteProtected in case of nops returning write protect  6-Nov-87 14:36:31 JAC	        fix InternalMaxTracksPerFormatOperation for the tape; use passesOnThisStream in UpdateStatistics; set tapeStatistics.retentionNeeded in UpdateStatistics if necessary; move DiskChangeClear to FloppyHeadDoveB;don't bump tries during tape overruns;make DiagnosticDiskChangeClear equal DiskChangeClear 9-Nov-87 15:43:32 JAC	        set operationState to operationInvalid when a retention is needed and an initiate is stopped so that a poll won't submit the operation; move DiagnosticDiskChangeClear to FloppyHeadDoveB16-Nov-87 11:10:34 JAC	        add usage of iocb.savedStatus11-Oct-88 14:57:00 TXM	        don't reset, flush, specify and recalibrate on NullCommand in BuildIOCB for performance.20-Jan-89 15:29:08 MS		change SetupDMAinfo and remove InitializeCleanup
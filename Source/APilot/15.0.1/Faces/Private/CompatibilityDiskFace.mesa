-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- CompatibilityDiskFace.mesa ( 8-Oct-88 23:20:07 By: MN)<<This DEFINITIONS module exists to provide compatibility between er  labeled rigid disk subsystems and the new label-less Pilot. >>DIRECTORY  Boot USING [BootFileDescriptorPageHandle, BootFileType,    maxPageRunsPerPage, PageRun],  Device USING [Type],  Environment USING [bitsPerWord, Long],  Inline USING [LongNumber],  PilotDiskFace,  Zone USING [Alignment];CompatibilityDiskFace: DEFINITIONS =  BEGIN OPEN PDF: PilotDiskFace;-- Initialization Stuff  OldGetDeviceAttributes: PROCEDURE [PDF.DeviceHandle]    RETURNS [cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL];  -- Before DetermineDiskShape on this device returns TRUE, some or all attributes may return value=unknown.  unknownAttribute: CARDINAL = LAST[CARDINAL];    OldStart: PROCEDURE [];-- Label Stuff  Label: TYPE = MACHINE DEPENDENT RECORD [    fileID(labelOffset[fileID].word):      FileID,    filePageLo(labelOffset[filePageLo].word):      CARDINAL,    filePageHi(labelOffset[filePageHi].word:labelOffset[filePageHi].bit..6):      [0..128),    pageZeroAttributes(        labelOffset[pageZeroAttributes].word:          labelOffset[pageZeroAttributes].bit..15):      [0..512),    attributesInAllPages(labelOffset[attributesInAllPages].word): WORD,    dontCare(labelOffset[dontCare].word): ARRAY [0..2) OF WORD];  FileID: TYPE [5];  -- File name.  FilePageNumber: TYPE = LONG CARDINAL;    -- Actually this should be a 23 bit range as delimited by:    firstFilePageNumber: FilePageNumber = 0;    lastFilePageNumber: FilePageNumber = 8388607;  -- Label semantics:  --   PDF only attaches semantics to the file page number (a 23 bit  --      number formed by concatenating the fields filePageLo and filePageHi).  --      All other fields have no semantics to PDF.  --      It is intended that the field fileID is the primary name of a file and  --      the fields pageZeroAttributes and attributesInAllPages define attributes  --      of a file.  This might be interesting to a client program that only  --      has its hands on the primary name of a file and needs to derive its  --      attributes.  --   When verifying labels, the following fields must match and must be  --     the same in every page of a run of pages:  --         fileID and attributesInAllPages  --     The field pageZeroAttributes must match in page zero of a file and  --     must be zero in every other page of a file.  When verifying labels,  --     the client must supply the correct value of this field if the initial  --     page number of the run is zero.  Otherwise, the label provided by the  --     client must have this field as zero.  --     The field dontCare does not participate in label verification.  --     The file page number (filePageLo & filePageHi) increments in each page  --     of a given run; that is, a run of consecutive pages has  --     increasing values of the file page number.  --   When writing labels, the fields fileID, attributesInAllPages  --     and dontCare are the same in every page of the run.  The file page  --     page number is incremented in each successive page of a run.  The field  --     pageZeroAttributes is only written with the client supplied value for  --     page zero of a file; it is forced to zero in all other pages of a run.    -- Constants defining the offsets of the various label fields.  These are  -- provided so that clients of this interface can correctly position their  -- fields in their records.    LabelOffsets: TYPE = {    fileID, filePageLo, filePageHi, pageZeroAttributes, attributesInAllPages,    dontCare};  LabelPosition: TYPE = RECORD [word: CARDINAL, bit: [0..Environment.bitsPerWord]];  labelOffset: ARRAY LabelOffsets OF LabelPosition = [    fileID: [0, 0],    filePageLo: [5, 0],    filePageHi: [6, 0],    pageZeroAttributes: [6, 7],    attributesInAllPages: [7, 0],    dontCare: [8, 0]];    -- Operations defined on labels  GetLabelFilePage: PROCEDURE [label: LONG POINTER TO Label]    RETURNS [FilePageNumber] = INLINE    {RETURN[      LOOPHOLE[        Environment.Long[	  num[lowbits: label.filePageLo, highbits: label.filePageHi]]]]};      SetLabelFilePage: PROCEDURE [    label: LONG POINTER TO Label, fpn: FilePageNumber] = INLINE    BEGIN    label.filePageLo ¬ LOOPHOLE[fpn, Inline.LongNumber].lowbits;    label.filePageHi ¬ LOOPHOLE[fpn, Inline.LongNumber].highbits;    END;      MatchLabels: PROCEDURE [p1, p2: LONG POINTER TO Label]    RETURNS [match: BOOLEAN] = INLINE    BEGIN    -- Test whether significant fields of p1­ and p2­ are equal.    -- All fields except dontCare are significant.    -- NOTE: We use two-word compares since the compiler expands them into inline    -- machine code rather than a kernel function call.  The order of the compares    -- is optimized for the Pilot file system!    MatchableLabel: TYPE = MACHINE DEPENDENT RECORD [      a, b, c, d, dontCare: RECORD [UNSPECIFIED, UNSPECIFIED]];    BEGIN    OPEN m1: LOOPHOLE[p1­, MatchableLabel], m2: LOOPHOLE[p2­, MatchableLabel];    RETURN[m1.a = m2.a AND m1.c = m2.c AND m1.d = m2.d AND m1.b = m2.b]    END    END;        NextLabel: PROCEDURE [p: LONG POINTER TO Label] = INLINE    BEGIN    -- Modify p to match next page label in run.    IF (p.filePageLo ¬ p.filePageLo + 1) = 0 THEN p.filePageHi ¬ p.filePageHi + 1;    p.pageZeroAttributes ¬ 0;    END;   FixUpLabel: PROCEDURE [     verifyLabel: LONG POINTER TO Label, labelFromDisk: LONG POINTER TO Label] = INLINE    BEGIN    -- Used when a label verify error occurs and MatchLabels[...] = TRUE to    -- update the label being used for verification.    verifyLabel.dontCare ¬ labelFromDisk.dontCare;    END;  labelSize: CARDINAL [10..10] = SIZE[Label];    zeroLabel: ARRAY [0..10) OF WORD = [0,0,0,0,0,0,0,0,0,0];  -- Performing operations  OldInitiate: PROC [OperationPtr];  -- Note a new disk request, and arrange for eventual execution.  Note that  -- client does not have control over what controller services the operaton.  OldPoll: PROC [PDF.ControllerHandle]    RETURNS [status: Status, op: OperationPtr, retriedCount: CARDINAL];  -- Poll a particular controller.  Polling an idle controller will result in  -- [clientError, NIL] being returned with no other side effects.  Operations  -- will not necessarily come back in order submitted, and an error in a   -- particular operation does not abort the rest.  Status: TYPE = {    inProgress, goodCompletion, notReady, recalibrateError, seekTimeout,    headerCRCError, labelCRCError, dataCRCError, headerNotFound, labelVerifyError,    dataVerifyError, overrunError, writeFault, memoryError, memoryFault,    clientError, operationReset, otherError};  -- Operation structure  -- Operations must live in the first 64K and must be operationAlignment  -- aligned.  Clients should allocate storage of operationSize for Operations,  -- and use the first SIZE[Operation] words for the actual operation.  -- The remaining storage is used by the Head in device dependent fashion.  OperationPtr: TYPE = LONG POINTER TO Operation;  Operation: TYPE = MACHINE DEPENDENT RECORD [    clientHeader(0): PDF.DiskAddress,  -- address of first sector of request    labelPtr(2): LONG POINTER TO Label,  -- first label of request.  MUST NOT BE NIL    dataPtr(4): LONG POINTER,  -- first (page aligned) data address of operation    incrementDataPtr(6:0..0): BOOLEAN,  -- if TRUE, add wordsPerPage to dataPtr after each    -- successful data read/write/verify    enableTrackBuffer(6:1..1): BOOLEAN ¬ FALSE,    command(6:2..7): Command,  -- the actual disk operation    tries(6:8..15): Tries,      -- Indication of how hard the Face should retry the operation in the presence      -- of errors.  Increasing values of tries indicates that non-decreasing      -- effort should be expended in retrying the failing operation.  Retries      -- include device specific recovery (ECC, recalibrates, ...)    pageCount(7): CARDINAL,  -- sectors remaining for this operation.      deviceStatus(10B): RECORD [a, b: UNSPECIFIED] ¬ NULL,    diskHeader(12B): PDF.DiskAddress ¬ NULL,  -- if command.header=Op[read], place the header here.    device(14B): PDF.DeviceHandle];    SuggestedTries: PROCEDURE [device: PDF.DeviceHandle] RETURNS [tries: Tries];    -- suggested number of tries for standard recovery algorithm for that device  Tries: TYPE = (0..400B];  Command: TYPE = MACHINE DEPENDENT RECORD [header, label, data: Op];  Op: TYPE = MACHINE DEPENDENT{noOp, read, write, verify};  -- Adaptation Stuff   <<Adaptation is the process of adapting new PDF operations    to  (CompatibilityDiskFace) operations.>>    AddressOfAdapterData: PROCEDURE [cop: OperationPtr] RETURNS [AdapterDataPtr];  AdapterDataPtr: TYPE = LONG POINTER TO AdapterData;  AdapterData: TYPE = MACHINE DEPENDENT RECORD [    mode(0:0..3): {normal, passThrough, writeDescr, readDescr,      getBootLocation, readLabel, writeLabel} ¬ normal,    bootFileType(0:4..7): Boot.BootFileType ¬ pilot,    nextSector(0:8..15): [0..16] ¬ 1, <<for initialMicrocode only>>    command(1:0..7): PDF.Command ¬ noOp,    nextRunIndex(1:8..15): [0..Boot.maxPageRunsPerPage] ¬ 1,    maBuffer(2): LONG POINTER ¬ NIL,    daFirstDescr(4): PDF.DiskAddress ¬ NULL,    maFirstDescr(6): Boot.BootFileDescriptorPageHandle ¬ NIL,    maCurrentDescr(8): Boot.BootFileDescriptorPageHandle ¬ NIL,    daCurrentLinkLabel(10): PDF.DiskAddress ¬ NULL,    currentRun(12): Boot.PageRun ¬ [NULL, 0],    label(15): Label ¬ LOOPHOLE[zeroLabel]];-- common DLight disk heads stuff not already in CDF  -- Variables  pilotDiskErrors: LONG POINTER TO ARRAY Status OF LONG CARDINAL;  pilotDiskOperationsInitiated: LONG POINTER TO LONG CARDINAL;  pilotDiskPagesRead: LONG POINTER TO LONG CARDINAL;  pilotDiskPagesWritten: LONG POINTER TO LONG CARDINAL;    -- Controllers  GetNextController: PROC [PilotDiskFace.ControllerHandle] RETURNS [PilotDiskFace.ControllerHandle];    -- Devices  GetNextDevice: PROCEDURE [PilotDiskFace.DeviceHandle] RETURNS [PilotDiskFace.DeviceHandle];  -- Device-related Initialization  DetermineDiskShape: PROCEDURE [    device: PilotDiskFace.DeviceHandle, operation: PilotDiskFace.OperationPtr, mode: PilotDiskFace.DeterminationMode,    buffer: LONG POINTER ¬ NIL] RETURNS [nowKnown: BOOLEAN];  -- Disk structure  GetDeviceType: PROCEDURE [PilotDiskFace.DeviceHandle] RETURNS [Device.Type];  GetDriveInfo: PROCEDURE [PilotDiskFace.DeviceHandle]    RETURNS [      firstPageOfInitialMicrocode: PilotDiskFace.DiskAddress,      lastPageOfInitialMicrocode: PilotDiskFace.DiskAddress,      firstPilotPage: PilotDiskFace.DiskAddress,      formattingSpec: PilotDiskFace.FormattingSpec,      formattingAlignment: PilotDiskFace.FormattingUnit];  GetFormattingUnit: PROCEDURE [PilotDiskFace.DeviceHandle] RETURNS [PilotDiskFace.FormattingUnit];  -- Performing operations    operationSize: READONLY CARDINAL;  operationAlignment: READONLY Zone.Alignment;    nullControllerHandle: READONLY PilotDiskFace.ControllerHandle;  nullDeviceHandle:	READONLY PilotDiskFace.DeviceHandle;      -- Errors and error recovery  Recalibrate: PROCEDURE [PilotDiskFace.DeviceHandle];   Reset: PROCEDURE [PilotDiskFace.ControllerHandle];    -- Initialization    globalStateSize:	READONLY CARDINAL;  GetControllerAttributes: PROCEDURE [PilotDiskFace.ControllerHandle]    RETURNS [globalStateSize: CARDINAL];  InitializeController: PROCEDURE [    controller: PilotDiskFace.ControllerHandle,    globalState: PilotDiskFace.GlobalStatePtr, mask: WORD,    nakedCondition: LONG POINTER TO CONDITION ¬ NIL];  -- nakedCondition is ignored if the controller does not support track buffering.  -- Also, if nakedCondition = NIL, then track buffering will not be performed.  InitializeCleanup: PROCEDURE [controller: PilotDiskFace.ControllerHandle];    PagesForTrackBuffering: PROCEDURE [device: PilotDiskFace.DeviceHandle]    RETURNS [pagesPerBuffer: CARDINAL, maxNumberOfBuffers: CARDINAL];  -- Informs client of the interface what support exists for track buffering.  -- maxNumberOfBuffers = 0 is returned if track buffering is not supported.  -- Also returns maxNumberOfBuffers = 0 if the controller was not initialized  -- with all needed information (nakedCondition = NIL).  InitializeTrackBuffer: PROCEDURE [    device: PilotDiskFace.DeviceHandle,    buffer: LONG POINTER, -- first(page aligned, resident) data address of track buffer    numberOfBuffers: CARDINAL];  -- Provides storage and notification mechanism for use on track buffering  --   for the specified device.  -- Should only be called after InitializeController,  --   and should only be called if PagesForTrackBuffering has returned  --   a maxNumberOfBuffers value other than 0.  END.....16-Jun-86  7:39:38  ETN   Created from 12.0 PDF 19-Jul-86 18:11:18  ETN   AdapterData changed in support of a major rework of the makeBootable like   functions of DiskFaceAdapter using the new Pilot provided working buffer. 22-Aug-86  9:17:31  RDM   Renamed this file to correct spelling of "Compatibility". Was "Compatability". 8-Sep-87 12:44:33  SPL   Added common DLight disk heads stuff   8-Sep-87 16:13:42  SPL   add PilotDiskFaceStatistics PTRs   14-Sep-87 15:34:45  SPL   pilotDiskErrors: PDF.Status ¬ Status 8-Oct-88 23:20:01  MN   Changed Operation.unused to enableTrackBuffer   Added PagesForTrackBuffering, InitializeTrackBuffer   Added nakedCondition to InitializeController
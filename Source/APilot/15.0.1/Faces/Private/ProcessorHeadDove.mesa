-- File: ProcessorHeadDove.mesa - last edit:-- TXM                 12-Oct-89 19:27:06-- ProcessorHeadDove.mesa 12-Oct-89 19:27:06 by TXM-- Copyright (C) 1987, 1988, 1989 by Xerox Corporation. All rights reserved.DIRECTORY  BitBlt USING [AlignedBBTable, BITBLT, BBptr, BBTableSpace],  DeviceCleanup USING [Perform],  DoveInputOutput USING [    Base, ByteSwap, GetHandlerIORegionPtr, IORTable,    LongByteSwap, NotifyIOP, RealPageCount, RealPageNumber],  ESCAlpha USING [aBITBLT, aBYTBLTR, aBYTBLT, aDMUL, aSDIV, aSDDIV, aUDDIV],  Environment USING [    bitsPerByte, bitsPerWord, bytesPerPage, bytesPerWord, Byte,    LongNumber, LongPointerFromPage, PageCount, PageNumber, wordsPerPage],  Frame USING [GetReturnFrame, ReadPC, WritePC],  Inline USING [    BITAND, BITSHIFT, BITXOR, DBITSHIFT, DIVMOD, LongCOPY, LongCOPYReverse,    LongDiv, LongDivMod, LongMult, LowHalf],  KeyboardFace USING [KeyboardType],  Mopcodes USING [zDIS, zDIS2],  PageMap USING [GetState],  PilotMP USING [cPowerOff, cWrongGerm],  PrincOps USING [ControlLink, ESCTrapTable, LocalFrameHandle, StateVector],  ProcessOperations USING [DisableInterrupts],  ProcessorFace USING [gmtEpoch, GreenwichMeanTime, ProcessorID, SpecialSetMP],  ProcessorFaceExtras USING [CSBanks, MachineType],  ProcessorFaceExtras2 USING [DoveMachineType],  ProcessorIOFaceDove USING [Command, FCBPtr],  SDDefs USING [SD, sOpcodeTrap];ProcessorHeadDove: PROGRAM  IMPORTS BitBlt, DeviceCleanup, DoveInputOutput, Environment, Frame, Inline, PageMap, ProcessOperations, ProcessorFace  EXPORTS DoveInputOutput, KeyboardFace, ProcessorFace, ProcessorFaceExtras, ProcessorFaceExtras2  SHARES PageMap, ProcessorFace =  BEGIN  -- Constants  cvTimeoutMask: WORD = 100000B; -- Dove microcode assumes level 0  ioRegionAfterEnd: CARDINAL = 256;  ioRegionByteOffset: CARDINAL = 16384; -- to avoid 16KB IOP local RAM  ioRegionPageOffset: CARDINAL = ioRegionByteOffset / Environment.bytesPerPage;  validDisplayBits: WORD = 207B;  -- Public items:  -- exported to DoveInputOutput  IORegion: PUBLIC LONG POINTER TO DoveInputOutput.IORTable;  mesaClientCondition: PUBLIC DoveInputOutput.Base RELATIVE POINTER;  iorSegmentBase: PUBLIC CARDINAL;  firstReservedPage: PUBLIC DoveInputOutput.RealPageNumber;  reservedPageCount: PUBLIC DoveInputOutput.RealPageCount;  displayPageCount: PUBLIC DoveInputOutput.RealPageCount;  firstMapPage: PUBLIC DoveInputOutput.RealPageNumber;  mapPagesCount: PUBLIC DoveInputOutput.RealPageCount;  ioRegionPage: PUBLIC DoveInputOutput.RealPageNumber;  ioRegionPageCount: PUBLIC DoveInputOutput.RealPageCount;  firstRealPage: PUBLIC DoveInputOutput.RealPageNumber;  lastRealPage: PUBLIC DoveInputOutput.RealPageNumber;  numberRealPages: PUBLIC DoveInputOutput.RealPageCount;  numberVirtualPages: PUBLIC Environment.PageCount;  pcPresent: PUBLIC UNSPECIFIED;  -- exported to KeyboardFace  keyboardType: PUBLIC KeyboardFace.KeyboardType;  -- exported to ProcessorFace  microsecondsPerHundredPulses: PUBLIC CARDINAL;  millisecondsPerTick: PUBLIC CARDINAL;  mp: PUBLIC CARDINAL;  processorID: PUBLIC ProcessorFace.ProcessorID;  reservedNakedNotifyMask: PUBLIC WORD;  -- Private items:  ioRegionStart: CARDINAL;  fcb: ProcessorIOFaceDove.FCBPtr;  bitBltImplementedByMicrocode: BOOLEAN;  timeToAutoPowerOn: ProcessorFace.GreenwichMeanTime;    InstructionNotImplemented: PRIVATE ERROR = CODE;  -- INLINE PROCs  DoCommand: PROC [command: ProcessorIOFaceDove.Command] = INLINE    BEGIN    fcb.command ¬ command;    DoveInputOutput.NotifyIOP [LOOPHOLE [0] ];    UNTIL fcb.command = noCommand DO ENDLOOP    END;  FindStartOfIORegion: PROC = INLINE    BEGIN    << Here is the algorithm for finding the starting virtual page of the IORegion and the number of pages in it.       The IORegion occupies virtual pages [ioRegionAfterEnd-ioRegionPageCount..ioRegionAfterEnd).       The real offset of these pages is [ioRegionPageOffset..ioRegionPageOffset+ioRegionPageCount), taken MOD 256.       So if "x" is the real page behind virtual page ioRegionAfterEnd-1, ioRegionPageCount = (x MOD 256)+1-ioRegionPageOffset,       and ioRegionStart = ioRegionAfterEnd-ioRegionPageCount. >>    realForIORegionEnd: DoveInputOutput.RealPageNumber ¬ Inline.LowHalf [PageMap.GetState [(ioRegionAfterEnd - 1)].real];    ioRegionPageCount ¬ (realForIORegionEnd MOD 256) + 1 - ioRegionPageOffset;    ioRegionStart ¬ ioRegionAfterEnd - ioRegionPageCount;    IORegion ¬ Environment.LongPointerFromPage [ioRegionStart];    ioRegionPage ¬ realForIORegionEnd + 1 - ioRegionPageCount;    iorSegmentBase ¬ ioRegionByteOffset / 16 -- segmentGranularity in bytes    END;      --===================  -- Intialization:  --===================  Start: PUBLIC --ProcessorFace.-- PROC =    BEGIN    -- find machine type, initialize exports    workWord: CARDINAL;    FindStartOfIORegion [];    fcb ¬ DoveInputOutput.GetHandlerIORegionPtr [mesaProcessor];    mesaClientCondition ¬ Inline.LowHalf [LOOPHOLE [@fcb.mesaClientCondition, LONG UNSPECIFIED] - LOOPHOLE [fcb, LONG UNSPECIFIED] ];    DoCommand [readHostID];    processorID ¬ fcb.data.hostID;    DoCommand [readKeyboardType];    workWord ¬ DoveInputOutput.ByteSwap [fcb.data.byteSwappedKeyboardType];    keyboardType ¬ (SELECT workWord FROM      2 => eLevel5,      3 => jLevel5,      ENDCASE => level5);    DoCommand [readPCType];    pcPresent ¬ DoveInputOutput.ByteSwap [fcb.data.byteSwappedPCType];    DoCommand [readVMMapDesc];    firstMapPage ¬ DoveInputOutput.ByteSwap [fcb.data.firstMapPage];    mapPagesCount ¬ DoveInputOutput.ByteSwap [fcb.data.countMapPages];    numberVirtualPages ¬ LONG [mapPagesCount] * Environment.wordsPerPage;    DoCommand [readDisplayDesc];    workWord ¬ DoveInputOutput.ByteSwap [fcb.data.displayType];    displayPageCount ¬ (SELECT Inline.BITAND [workWord, validDisplayBits] FROM      1 => 129+8, -- 15" B/W      5 => 243+8, -- 19" B/W      3 => 293, -- 13" color      7 => 400, -- 15" color (a guesstimate)      ENDCASE => 0); -- none or non-bitmap    firstReservedPage ¬ DoveInputOutput.ByteSwap [fcb.data.firstDisplayBankPage];    reservedPageCount ¬ DoveInputOutput.ByteSwap [fcb.data.countDisplayBankPages];    DoCommand [readRealMemDesc];    firstRealPage ¬ DoveInputOutput.ByteSwap [fcb.data.firstRealPageInVMM];    lastRealPage ¬ DoveInputOutput.ByteSwap [fcb.data.lastRealPageInVMM];    numberRealPages ¬ DoveInputOutput.ByteSwap [fcb.data.countRealPagesInVMM] + mapPagesCount + reservedPageCount;    SELECT DoveMachineTypeInfo[] FROM      daybreak, dahlia, diana =>        BEGIN	microsecondsPerHundredPulses ¬ 1600;	millisecondsPerTick ¬ 50	END;      daisy =>        BEGIN	microsecondsPerHundredPulses ¬ 2048; 	millisecondsPerTick ¬ 52;	END;      duke =>        BEGIN	microsecondsPerHundredPulses ¬ 1280; 	millisecondsPerTick ¬ 40;	END;      dune =>        BEGIN	microsecondsPerHundredPulses ¬ 1280; 	millisecondsPerTick ¬ 50;	END;      ENDCASE => -- this isn't a Dove machine!        BEGIN	SetMP [PilotMP.cWrongGerm];	DO ENDLOOP -- hang	END;    reservedNakedNotifyMask ¬ cvTimeoutMask;    SDDefs.SD[SDDefs.sOpcodeTrap] ¬ LOOPHOLE[UnimplementedTrapHandler];    PrincOps.ESCTrapTable­ ¬      ALL[LOOPHOLE[UnimplementedTrapHandler, PrincOps.ControlLink]];    PrincOps.ESCTrapTable[ESCAlpha.aSDIV] ¬ LOOPHOLE[SDIV];    PrincOps.ESCTrapTable[ESCAlpha.aSDDIV] ¬ LOOPHOLE[SDDIV];    PrincOps.ESCTrapTable[ESCAlpha.aUDDIV] ¬ LOOPHOLE[UDDIV];    PrincOps.ESCTrapTable[ESCAlpha.aDMUL] ¬ LOOPHOLE[DMUL];    -- Note: BITBLT is not simulated.    PrincOps.ESCTrapTable[ESCAlpha.aBYTBLT] ¬ LOOPHOLE[BYTBLT];    PrincOps.ESCTrapTable[ESCAlpha.aBYTBLTR] ¬ LOOPHOLE[BYTBLTR];    -- Execute a simple BitBlt to find out if the microcode implements it:    BEGIN    trueValue: BOOLEAN ¬ TRUE;    bbTableSpace: BitBlt.BBTableSpace;    bbTable: BitBlt.BBptr = BitBlt.AlignedBBTable[@bbTableSpace];    prevTrapHandler: PrincOps.ControlLink ¬ PrincOps.ESCTrapTable[ESCAlpha.aBITBLT];    -- Set to BLT a TRUE into bitBltImplementedByMicrocode.    bbTable­ ¬ [      dst: [word: @bitBltImplementedByMicrocode, bit: 0],      dstBpl: Environment.bitsPerWord,      src: [word: @trueValue, bit: 0],      srcDesc: [srcBpl[Environment.bitsPerWord]],      width: Environment.bitsPerWord, height: 1,      flags: [        direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,        srcFunc: null, dstFunc: null]];    PrincOps.ESCTrapTable[ESCAlpha.aBITBLT] ¬ LOOPHOLE[BITBLTNotImplementedByMicrocode];    bitBltImplementedByMicrocode ¬ FALSE;    BitBlt.BITBLT[  -- If implemented by microcode, sets      bbTable];  -- bitBltImplementedByMicrocode ¬ TRUE; otherwise stays FALSE.    PrincOps.ESCTrapTable[ESCAlpha.aBITBLT] ¬ prevTrapHandler;    END;        END;  --Start--  -- Initialization utilities:    BITBLTNotImplementedByMicrocode: PROC [BitBlt.BBptr] =    BEGIN    -- MUST not be a nested procedure!    -- If this procedure is invoked, that means that the microcode does not    -- implement BitBlt (e.g. RavenMesa microcode).    lf: PrincOps.LocalFrameHandle ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf]+2], lf: lf]; -- step past BITBLT instn.    END;  --==============================  -- ProcessorFace Implementation:  --==============================  BootButton: PUBLIC PROC =    BEGIN    ProcessOperations.DisableInterrupts [];    DoCommand [bootButton]    END;  CountCSBanks: PUBLIC PROCEDURE RETURNS [banks: ProcessorFaceExtras.CSBanks] =       BEGIN       DoCommand [readNumbCSBanks];       banks ¬ DoveInputOutput.ByteSwap [fcb.data.byteSwappedCSBanks];       END;         GetGreenwichMeanTime: PUBLIC PROC RETURNS [gmt: ProcessorFace.GreenwichMeanTime] =    {IF NOT fcb.timeOfDayIsValid THEN gmt ¬ ProcessorFace.gmtEpoch ELSE      BEGIN      DoCommand [readGMT];      gmt ¬ DoveInputOutput.LongByteSwap [fcb.data.byteSwappedGMT]      END};  GetNextAvailableVM: PUBLIC PROC [page: Environment.PageNumber]    RETURNS [firstPage: Environment.PageNumber, count: Environment.PageCount] =    BEGIN    SELECT page FROM      > ioRegionAfterEnd => RETURN [0, 0];      > 0 => RETURN [ioRegionAfterEnd, numberVirtualPages - ioRegionAfterEnd];      ENDCASE => RETURN [0, ioRegionStart];  -- = 0    END;  MachineTypeInfo: PUBLIC PROC RETURNS[type: ProcessorFaceExtras.MachineType] =    BEGIN    DoCommand[readMachineType];    type ¬ SELECT DoveInputOutput.ByteSwap[fcb.data.byteSwappedMachineType] FROM      IN [0..1] => daisy,      2 => dahlia,       3 => daybreak,      ENDCASE => LAST[ProcessorFaceExtras.MachineType];    END;  DoveMachineTypeInfo: PUBLIC PROC RETURNS[type: ProcessorFaceExtras2.DoveMachineType] =    BEGIN    DoCommand[readMachineType];    type ¬ SELECT DoveInputOutput.ByteSwap[fcb.data.byteSwappedMachineType] FROM      IN [0..1] => daisy,      2 => dahlia,       3 => daybreak,      4 => duke,      5 => diana,      6 => dune,      ENDCASE => LAST[ProcessorFaceExtras2.DoveMachineType];    END;  PowerOff: PUBLIC PROCEDURE =    BEGIN    -- NOTE: This code depends on the greenwich mean time clock running    -- with interrupts disabled and devices turned off.    ProcessOperations.DisableInterrupts [];    DeviceCleanup.Perform [turnOff];    SetMP [PilotMP.cPowerOff];    DO      IF GetGreenwichMeanTime [] - ProcessorFace.gmtEpoch        >= timeToAutoPowerOn - ProcessorFace.gmtEpoch THEN BootButton []      ENDLOOP;    END;  ResetAutomaticPowerOn: PUBLIC PROC = {    timeToAutoPowerOn ¬ ProcessorFace.gmtEpoch - 1};  SetAutomaticPowerOn: PUBLIC PROC [    gmt: ProcessorFace.GreenwichMeanTime, externalEvent: BOOLEAN] = {    timeToAutoPowerOn ¬ gmt};  -- externalEvent ignored on Dove  SetGreenwichMeanTime: PUBLIC PROC [gmt: ProcessorFace.GreenwichMeanTime] =    BEGIN    fcb.data.byteSwappedGMT ¬ DoveInputOutput.LongByteSwap [gmt];    DoCommand [writeGMT];    fcb.timeOfDayIsValid ¬ TRUE    END;  SetMP: PUBLIC PROC [mpnew: CARDINAL] = {ProcessorFace.SpecialSetMP[mp ¬ mpnew]};  --===========================================  -- Software implemention of instructions not implemented by microcode  --===========================================  -- The routines below assume that the return link is a frame, and has been started.  UnimplementedTrapHandler: PROC = {    v: RECORD [a: ARRAY [0..3) OF WORD, state: PrincOps.StateVector];    v.state ¬ STATE; ERROR InstructionNotImplemented};  Number: TYPE = Environment.LongNumber;  SDIV: PROC [q, r: INTEGER] RETURNS [INTEGER <<, INTEGER>>] =    BEGIN    -- remainder returned above the stack.    Pop: PROC [INTEGER, INTEGER] RETURNS [INTEGER] = MACHINE CODE {Mopcodes.zDIS};    lf: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    negnum, negden: BOOLEAN;    state ¬ STATE;    IF negden ¬ (r < 0) THEN r ¬ -r;    IF negnum ¬ (q < 0) THEN q ¬ -q;    [quotient: q, remainder: r] ¬ Inline.DIVMOD[num: q, den: r];    IF Inline.BITXOR[negnum, negden] # 0 THEN q ¬ -q;    IF negnum THEN r ¬ -r;    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    RETURN Pop[q, r];    END;  -- SDIV--  DMUL:PROC [a, b: Number] RETURNS [product: Number] =    BEGIN    lf: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    state ¬ STATE;    product.lc ¬ Inline.LongMult[a.lowbits, b.lowbits];    product.highbits ¬      product.highbits + a.lowbits*b.highbits + a.highbits*b.lowbits;    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    END;  --DMUL--  SDDIV: PROC [num, den: Number] RETURNS [quotient <<, remainder>>: Number] =    BEGIN    -- remainder returned above the stack    Pop2: PROC [Number, Number] RETURNS [Number] = MACHINE CODE {Mopcodes.zDIS2};    remainder: Number;    lf: PrincOps.LocalFrameHandle;    negNum, negDen: BOOLEAN ¬ FALSE;    state: PrincOps.StateVector;    state ¬ STATE;    IF INTEGER[num.highbits] < 0 THEN {negNum ¬ TRUE; num.li ¬ -num.li};    IF INTEGER[den.highbits] < 0 THEN {negDen ¬ TRUE; den.li ¬ -den.li};    [quotient: quotient, remainder: remainder] ¬ DUDivMod[num, den];    IF Inline.BITXOR[negNum,  negDen] # 0 THEN quotient.li ¬ -quotient.li;    IF negNum THEN remainder.li ¬ -remainder.li;    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    RETURN Pop2[quotient, remainder];    END;  --SDDIV--  UDDIV: PROC [num, den: Number]    RETURNS [quotient <<, remainder>>: Number] =    BEGIN    Pop2: PROC [Number, Number] RETURNS [Number] = MACHINE CODE {Mopcodes.zDIS2};    remainder: Number;    lf: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    state ¬ STATE;    [quotient: quotient, remainder: remainder] ¬ DUDivMod[num, den];    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    RETURN Pop2[quotient, remainder];    END;  --UDDIV--  DUDivMod: PROC [num, den: Number] RETURNS [quotient, remainder: Number] =    BEGIN    OPEN Inline;    qq: CARDINAL;    count: [0..31);    lTemp: Number;    IF den.highbits = 0 THEN      BEGIN      [quotient.highbits, qq] ¬ LongDivMod[        num: LOOPHOLE[Number[num[lowbits: num.highbits, highbits: 0]]],        den: den.lowbits];      [quotient.lowbits, remainder.lowbits] ¬ LongDivMod[        num: LOOPHOLE[Number[num[lowbits: num.lowbits, highbits: qq]]],        den: den.lowbits];      remainder.highbits ¬ 0;      END    ELSE      BEGIN      count ¬ 0;      quotient.highbits ¬ 0;      lTemp ¬ den;      WHILE lTemp.highbits # 0 DO -- normalize        lTemp.lc ¬ DBITSHIFT[lTemp.lc, -1];        count ¬ count + 1;        ENDLOOP;      IF num.highbits >= lTemp.lowbits THEN {        -- subtract off 2­16*divisor and fix up count        div: Number ¬ Number[num[lowbits: 0, highbits: lTemp.lowbits]];        qq ¬ LongDiv[num.lc - div.lc, lTemp.lowbits]/2 + 100000B;        count ¬ count - 1}      ELSE qq ¬ LongDiv[num.lc, lTemp.lowbits]; -- trial quotient      qq ¬ BITSHIFT[qq, -count];      lTemp.lc ¬ LongMult[den.lowbits, qq]; -- multiply by trial quotient      lTemp.highbits ¬ lTemp.highbits + den.highbits*qq;      UNTIL lTemp.lc <= num.lc DO        -- decrease quotient until product is small enough        lTemp.lc ¬ lTemp.lc - den.lc;        qq ¬ qq - 1;        ENDLOOP;      quotient.lowbits ¬ qq;      remainder.lc ¬ num.lc - lTemp.lc;      END;    END;  --DUDivMod--  BYTBLT: PROC [    destBase: LONG ORDERED POINTER, destIndex, count: CARDINAL,    sourceBase: LONG ORDERED POINTER, sourceIndex: CARDINAL] =    BEGIN    OPEN Environment;    lf: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];    bba: BitBlt.BBTableSpace;    bbt: BitBlt.BBptr = BitBlt.AlignedBBTable[@bba];    MaxBytesPerScanLine: CARDINAL = 40B;    bytesPerScanLine: CARDINAL ¬ MaxBytesPerScanLine;    bitsPerScanLine: CARDINAL;    lines, tail: CARDINAL;    destBase ¬ destBase + destIndex/2;    destIndex ¬ destIndex MOD 2;    sourceBase ¬ sourceBase + sourceIndex/2;    sourceIndex ¬ sourceIndex MOD 2;      IF destIndex = sourceIndex THEN      BEGIN      -- Can use Inline.LongCOPY      s: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[sourceBase];      d: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[destBase];      words: CARDINAL;      moved: CARDINAL ¬ 0;      IF destIndex # 0 THEN        BEGIN        -- Thus destIndex = sourceIndex = 1	d[1] ¬ s[1];	d ¬ d+1;	s ¬ s+1;	moved ¬ 1;	END;      words ¬ (count-moved)/2;      Inline.LongCOPY[to: d, from: s, nwords: words];      IF (moved + 2*words) # count THEN  --        d[2*words] ¬ s[2*words];  -- Move the one remaining byte      Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];      RETURN;      END;         << Can't use Inline.LongCOPY, because source and destination    are "not aligned", i.e., one starts at a word boundary,    the other in the middle of a word. >>    IF bitBltImplementedByMicrocode THEN      BEGIN  -- microcode does BitBlt      SELECT destBase FROM        > sourceBase =>          BEGIN          wDiff: LONG CARDINAL = destBase - sourceBase;          IF wDiff <= LAST[CARDINAL]/2 THEN            bytesPerScanLine ¬              CARDINAL[wDiff]* bytesPerWord + destIndex - sourceIndex;	  END;        < sourceBase => NULL;        ENDCASE => IF sourceIndex < destIndex THEN bytesPerScanLine ¬ 1;      bytesPerScanLine ¬ MIN[bytesPerScanLine, MaxBytesPerScanLine];      bitsPerScanLine ¬ bytesPerScanLine*bitsPerByte;      [quotient: lines, remainder: tail] ¬        Inline.DIVMOD[num: count, den: bytesPerScanLine];      bbt­ ¬ [        dst: [word: destBase, bit: destIndex*bitsPerByte],        dstBpl: bitsPerScanLine,        src: [word: sourceBase, bit: sourceIndex*bitsPerByte],        srcDesc: [srcBpl[bitsPerScanLine]], width: bitsPerScanLine, height: lines,        flags: [          direction: forward, disjoint: FALSE, disjointItems: FALSE, gray: FALSE,          srcFunc: null, dstFunc: null]];      IF lines # 0 THEN BitBlt.BITBLT[bbt];      IF tail # 0 THEN        BEGIN        count ¬ lines*bytesPerScanLine;        bbt.dst.word ¬ bbt.dst.word + count/2;        bbt.src.word ¬ bbt.src.word + count/2;        IF count MOD 2 = 1 THEN	  BEGIN          IF destIndex = 0 THEN bbt.dst.bit ¬ bitsPerByte          ELSE bbt.dst ¬ [word: bbt.dst.word + 1, bit: 0];          IF sourceIndex = 0 THEN bbt.src.bit ¬ bitsPerByte          ELSE bbt.src ¬ [word: bbt.src.word + 1, bit: 0];	  END;        bbt.width ¬ bitsPerByte*tail;        bbt.height ¬ 1;        BitBlt.BITBLT[bbt];	END;      END  -- microcode does BitBlt    ELSE      BEGIN  -- microcode does NOT do BitBlt      dest: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[destBase];      source: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[sourceBase];      FOR i: CARDINAL IN [0..count) DO        dest[destIndex + i] ¬ source[sourceIndex + i];        ENDLOOP;      END;    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    END;  --BYTBLT--  BYTBLTR: PROC [    destBase: LONG ORDERED POINTER, destIndex, count: CARDINAL,    sourceBase: LONG ORDERED POINTER, sourceIndex: CARDINAL] =    BEGIN    OPEN Environment;    lf: PrincOps.LocalFrameHandle ¬ Frame.GetReturnFrame[];    bba: BitBlt.BBTableSpace;    bbt: BitBlt.BBptr = BitBlt.AlignedBBTable[@bba];    MaxBytesPerScanLine: CARDINAL = 40B;    bytesPerScanLine: CARDINAL ¬ MaxBytesPerScanLine;    bitsPerScanLine: CARDINAL;    lines, tail: CARDINAL;    destBase ¬ destBase + destIndex/2;    destIndex ¬ destIndex MOD 2;    sourceBase ¬ sourceBase + sourceIndex/2;    sourceIndex ¬ sourceIndex MOD 2;      IF destIndex = sourceIndex THEN      BEGIN      -- Can use Inline.LongCOPYReverse      s: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[sourceBase];      d: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[destBase];      words: CARDINAL;      odd: CARDINAL ¬ count MOD 2;      IF sourceIndex # odd THEN        BEGIN	d[count-odd] ¬ s[count-odd];	count ¬ count - 1;	END;      words ¬ count/2;      IF sourceIndex # 0 THEN BEGIN        Inline.LongCOPYReverse[to: d+1, from: s+1, nwords: words];        d[1] ¬ s[1];  -- Move the one remaining byte        END      ELSE Inline.LongCOPYReverse[to: d, from: s, nwords: words];      Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];      RETURN;      END;          IF bitBltImplementedByMicrocode THEN      BEGIN  -- microcode does BITBLT      SELECT sourceBase FROM        > destBase =>	  BEGIN          wDiff: LONG CARDINAL = sourceBase - destBase;          IF wDiff <= LAST[CARDINAL]/2 THEN            bytesPerScanLine ¬              CARDINAL[wDiff]*bytesPerWord + sourceIndex - destIndex;	  END;        < destBase => NULL;        ENDCASE => IF destIndex < sourceIndex THEN bytesPerScanLine ¬ 1;      bytesPerScanLine ¬ MIN[bytesPerScanLine, MaxBytesPerScanLine];      bitsPerScanLine ¬ bytesPerScanLine*bitsPerByte;      [quotient: lines, remainder: tail] ¬        Inline.DIVMOD[num: count, den: bytesPerScanLine];      bbt­ ¬ [        dst: [          word: destBase + (count + destIndex - bytesPerScanLine)/2,          bit: ((count + destIndex - bytesPerScanLine) MOD 2)*bitsPerByte],        dstBpl: -INTEGER[bitsPerScanLine],        src: [          word: sourceBase + (count + sourceIndex - bytesPerScanLine)/2,          bit: ((count + sourceIndex - bytesPerScanLine) MOD 2)*bitsPerByte],        srcDesc: [srcBpl[-INTEGER[bitsPerScanLine]]],        width: bitsPerScanLine, height: lines,        flags: [          direction: backward, disjoint: FALSE, disjointItems: FALSE, gray: FALSE,          srcFunc: null, dstFunc: null]];      IF lines # 0 THEN BitBlt.BITBLT[bbt];      IF tail # 0 THEN	BEGIN        bbt.dst ¬ [word: destBase, bit: destIndex*bitsPerByte];        bbt.src ¬ [word: sourceBase, bit: sourceIndex*bitsPerByte];        bbt.width ¬ bitsPerByte*tail;        bbt.height ¬ 1;        BitBlt.BITBLT[bbt];	END;      END  -- microcode does BITBLT    ELSE      BEGIN  -- microcode does NOT do BITBLT      -- BitBlt is unimplemented.      dest: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[destBase];      source: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[sourceBase];      FOR i: CARDINAL DECREASING IN [0..count) DO        dest[destIndex + i] ¬ source[sourceIndex + i];        ENDLOOP;      END;    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    END;  --BYTBLTR--  END.LOG17-Oct-84 -- JPM -- Created from ProcessorHeadDLion.15-Nov-84 -- JPM -- Added exported variables and initialization code for them.3-Dec-84 -- JPM -- Changed real page count variables to DoveInputOutput.RealPageCount.7-Dec-84 -- JPM -- Expanded IORegion to 64 pages total.13-Feb-85 -- JPM -- Fix bug in Start (had extraneous BITSHIFT of display eeprom word)18-Feb-85 -- JPM -- Add keyboardType and code (in Start) to initialize it10-Apr-85 -- JPM -- Change ioRegionExtraPages to ioRegionPages and fix at 64 (for now)16-Apr-85 -- JPM -- For Daisy with multiple A-chips, set firstRealPage to 09-May-85 -- JPM -- Convert to 11.1; fix bug in Start (didn't compute lastRealPage properly for 1MB or less); add FindStartOfIORegion9-Jul-85 -- JPM -- Opie redesign conversion31-Jul-85 -- JPM -- Add code to export iorSegmentBase13-Aug-85 -- JPM -- Add code to export pcPresent9-Sep-85 -- JPM -- Change display and keyboard tests in Start (new EEPROM format)30-Jul-86 12:17:44	JAC 	update microsecondsPerHundredPulses and millisecondsPerTick for Daisy13-Jan-87 15:11:33 -- JWF -- Added CountCSBanks 4-Nov-87 16:58:21 -- MXT -- Added MachineTypeInfo14-Sep-88 13:17:31 -- TXM -- Added DoveMachineTypeInfo19-Sep-88 14:10:20 -- TXM -- Updated microsecondsPerHundredPulses for Duke15-Dec-88 16:26:54 -- AXA -- Added diana and dune in DoveMachineTypeInfo12-Oct-89 19:27:06 -- TXM -- Changed millisecondsPerTick to 40 for Duke
--File = BiParallelPortChannelDriver.mesa--   Controller dependent BUT device independent channel driver.--   created 16-Aug-86 13:10:23 by JMA--   last edited  8-Jun-89 16:10:44 MxS---- Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY   ByteBlt USING [ByteBlt],   Environment USING [Block, Byte, nullBlock, wordsPerPage],   Heap USING [Create, MakeNode],   BiParallelPortChannel USING [BlockPtr, Parameters],   BiParallelPortChannelExtras,   BiParallelPortFace USING [CommandStatus, ControlOrData, CompletedTransferStatus,   	DeviceConnection, DeviceStatus, GetHardwareStatusBits, GetNextAvailablePort,	GetTestResult, GetStatus, HardwareStatus, Initialize, InitializationStatus, 	InitiateDeviceReset, InitiatePortReset, InitiateTest, InitiateTransfer,  	maxBlockSizeInBytes, nullPortNumber, Operation, operationSize, operationAlignment,	OperationPtr, Parameters, PollTransferStatus, PulseWidth, Port, PortType, Transfer,	TransferProtocol, TransferStatus, TransferMode, SetParameters, UpdateStatus],   BiParallelPortFaceExtras USING [GetPrinterStatus, GetHardWareType, StatusByte],   Process USING [Detach, GetPriority, InitializeCondition, MsecToTicks, Priority, SecondsToTicks, SetPriority],   ResidentHeap USING [first64K, MakeNode],   SpecialRuntime USING [AllocateNakedCondition],   SpecialHeap USING [MakeResident],   Zone USING [Base, nil, Status];	   BiParallelPortChannelDriver: MONITOR  IMPORTS ByteBlt, Heap, ResidentHeap, SpecialHeap, SpecialRuntime,  		 BiParallelPortFace, BiParallelPortFaceExtras, Process		   EXPORTS BiParallelPortChannel, BiParallelPortChannelExtras =    BEGIN    OPEN BiParallelPortFace;    maxBufferListSize: CARDINAL = 6;  -- 6 X 512 = 3K bytes  maxBlockSizeInBytes: PUBLIC CARDINAL ¬ BiParallelPortFace.maxBlockSizeInBytes;  nilHandle: PUBLIC PortHandle ¬ NIL;     -- TYPES  -- Pack Data Structure:  PortHandle: PUBLIC TYPE = LONG POINTER TO PortRec;  PortRec: TYPE = RECORD [    locked: BOOLEAN ¬ FALSE,    param: Parameters ¬ [],    commandStatus: CommandStatus,    transferPending: CARDINAL ¬ 0,    deviceStatus: DeviceStatus ¬ [],    transfer: Transfer    ];  CompletionHandle: PUBLIC TYPE = LONG POINTER TO CompletionRec;  CompletionRec: TYPE = RECORD [    id: CARDINAL ¬ 0,    isActive: BOOLEAN ¬ FALSE,    transfer: Transfer,    transferStatus: TransferStatus,    opRelPtr: Zone.Base RELATIVE POINTER TO BiParallelPortFace.Operation ¬ Zone.nil,    dataBlock: LONG POINTER ¬ NIL,    clientBlockPtr: BiParallelPortChannel.BlockPtr ¬ NIL,    nextCompRec: CompletionHandle ¬ NIL    ];      -- GLOBAL VARIABLES    ChannelDriverError: PUBLIC ERROR = CODE;  InvalidPortNumberOrPortType: PUBLIC ERROR = CODE;  NilChannelHandle: PUBLIC ERROR = CODE;  ParallelPortInUse: PUBLIC ERROR = CODE;  TransferExceedsMaxSize: PUBLIC ERROR = CODE;    heapBuffer: UNCOUNTED ZONE;  heapBlock: UNCOUNTED ZONE;    channelInitialized: BOOLEAN ¬ FALSE;		-- parallel port channel initialized  nakedWakeUpPtr: LONG POINTER TO CONDITION ¬ NIL;  nakedWakeUpMask: WORD;  condReBroadcast: CONDITION;  compRecReleased: CONDITION;  statusWait: CONDITION;    compHead,  compTail: CompletionHandle ¬ NIL;      -- There are only TWO ports available  port0Handle,  port1Handle: PortHandle ¬ NIL;  hwStat: HardwareStatus;  initialStatus: InitializationStatus;  waitingForCompHandle: CARDINAL ¬ 0;  waitingForCondReBroad: CARDINAL ¬ 0;    << For Dahlia >>  statusByte: BiParallelPortFaceExtras.StatusByte ¬ 0;  nilStatusByte: BiParallelPortFaceExtras.StatusByte ¬ 0;  hardWareIsDahlia:BOOLEAN ¬ FALSE;  prevPriority: Process.Priority;      << PUBLIC PROCEDURES >>    Create: PUBLIC ENTRY PROC [port: Port, portType: PortType]     RETURNS [portHandle: PortHandle, initStatus: InitializationStatus] =     BEGIN     ENABLE UNWIND => NULL;     handle: PortHandle ¬ nilHandle;          initStatus ¬ other;     IF NOT channelInitialized THEN {     	[initialStatus] ¬ BiParallelPortFace.Initialize [nakedWakeUpMask];	channelInitialized ¬ (initialStatus = success) };	     IF channelInitialized THEN        BEGIN     	SELECT port FROM        	0 => { 		       IF port0Handle.param.portInUse		          THEN RETURN WITH ERROR ParallelPortInUse			  ELSE handle ¬ port0Handle };					1 =>  { 		        IF port1Handle.param.portInUse		          THEN RETURN WITH ERROR ParallelPortInUse			  ELSE handle ¬ port1Handle };		ENDCASE =>  RETURN WITH ERROR InvalidPortNumberOrPortType;	END;          IF handle # nilHandle THEN {        UNTIL NOT handle.locked DO	   -- wait for portHandle to be unlocked by MajorCleanup proc	   waitingForCondReBroad ¬ waitingForCondReBroad + 1;	   WAIT condReBroadcast	ENDLOOP;	     	handle.param.port ¬ handle.transfer.port ¬ port;	handle.param.portType ¬ portType;	handle.param.portInUse ¬ TRUE;	<<handle.param.pulseWidth ¬ pw250ns;>>     	BiParallelPortFace.SetParameters [handle.param] };	     initStatus ¬ initialStatus;         IF port = 0 THEN     hardWareIsDahlia ¬ BiParallelPortFaceExtras.GetHardWareType[];          RETURN [handle, initStatus]     END;  -- Create            Delete: PUBLIC PROC [lp: LONG POINTER TO PortHandle] =    BEGIN    ENABLE UNWIND => NULL;    tempPtr: PortHandle ¬ nilHandle;        IF lp # NIL THEN {       lp.locked ¬ TRUE;  -- locked port handle while clean up in progress       tempPtr ¬ lp­;       lp­ ¬ nilHandle;       Process.Detach [FORK MajorCleanUp [tempPtr]] }    END; -- Delete              DeviceReset: PUBLIC ENTRY PROC [portHandle: PortHandle]    RETURNS [commandStatus: CommandStatus] =    BEGIN    ENABLE UNWIND => NULL;    IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;    RETURN [portHandle .commandStatus ¬    		BiParallelPortFace.InitiateDeviceReset [portHandle .param.port]];    END;  -- DeviceReset              Get: PUBLIC ENTRY PROC [portHandle: PortHandle, controlOrData: ControlOrData,       		    	  transferBlock: BiParallelPortChannel.BlockPtr ]      RETURNS [commandStatus: CommandStatus, completionHandle: CompletionHandle] =    BEGIN    ENABLE UNWIND => NULL;        [portHandle.commandStatus, completionHandle] ¬ DoTransfer [portHandle, controlOrData,     								transferBlock, get];    RETURN [portHandle.commandStatus, completionHandle];    END;  -- Get         GetNextAvailablePort: PUBLIC ENTRY PROC [portType: PortType]    RETURNS [nextPort: Port] =    BEGIN    ENABLE UNWIND => NULL;    RETURN [BiParallelPortFace.GetNextAvailablePort [portType]]    END;  -- GetNextPortNumber						      GetRawStatus: PUBLIC ENTRY PROC [portHandle: PortHandle]    RETURNS [commandStatus: CommandStatus, statusWord1, statusWord2: WORD] =    BEGIN    ENABLE UNWIND => NULL;        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;        [portHandle.commandStatus, hwStat] ¬       BiParallelPortFace.GetHardwareStatusBits [portHandle.param.port];    RETURN [portHandle.commandStatus, LOOPHOLE [hwStat.boardStatus], LOOPHOLE [hwStat.portStatus]]    END;  -- GetRawStatus  GetStatus: PUBLIC ENTRY PROC [portHandle: PortHandle]    RETURNS [commandStatus: CommandStatus, stat: DeviceStatus ] =    BEGIN    ENABLE UNWIND => NULL;        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;    [portHandle.commandStatus, portHandle.deviceStatus] ¬    	BiParallelPortFace.GetStatus [portHandle.param.port];    RETURN [portHandle.commandStatus, portHandle.deviceStatus];    END; -- GetStatus              GetTestResult: PUBLIC ENTRY PROC [portHandle: PortHandle]    RETURNS [returnPattern: WORD] =    BEGIN    ENABLE UNWIND => NULL;    portHandle: PortHandle ¬ LOOPHOLE [portHandle];        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;    RETURN [returnPattern ¬ BiParallelPortFace.GetTestResult [] ];    END;  -- GetTestResult             InitiateTest: PUBLIC ENTRY PROC [portHandle: PortHandle, diagnosticTestPattern: WORD]    RETURNS [commandStatus: CommandStatus] =    BEGIN    ENABLE UNWIND => NULL;        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;    RETURN [portHandle.commandStatus ¬    		 BiParallelPortFace.InitiateTest [portHandle.param.port, diagnosticTestPattern]];    END;  -- InitiateTest              PortReset: PUBLIC ENTRY PROC [portHandle: PortHandle]    RETURNS [commandStatus: CommandStatus] =    BEGIN    ENABLE UNWIND => NULL;        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;    RETURN [portHandle.commandStatus ¬ BiParallelPortFace.InitiatePortReset [portHandle.param.port]];    END;  -- Port Reset              Put: PUBLIC ENTRY PROC [portHandle: PortHandle, controlOrData: ControlOrData,   		    	  transferBlock: BiParallelPortChannel.BlockPtr ]    RETURNS [commandStatus: CommandStatus, completionHandle: CompletionHandle] =    BEGIN    ENABLE UNWIND => NULL;        [portHandle.commandStatus, completionHandle] ¬ DoTransfer [portHandle, controlOrData,     								transferBlock, put];    RETURN [portHandle.commandStatus, completionHandle];    END;  -- Put            SetParameters: PUBLIC ENTRY PROC [portHandle: PortHandle,  			           parameters: BiParallelPortChannel.Parameters ] =    BEGIN    ENABLE UNWIND => NULL;        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;    portHandle.param.transferProtocol ¬ parameters.transferProtocol;    portHandle.param.pulseWidth ¬ parameters.pulseWidth;    BiParallelPortFace.SetParameters [portHandle.param];    END; -- SetParameter          StatusChangeWait: PUBLIC ENTRY PROC [portHandle: PortHandle,  				 stat: DeviceStatus]    RETURNS [newStat: DeviceStatus] =    BEGIN    ENABLE UNWIND => NULL;    oldStat: DeviceStatus;    doUpdate: BOOLEAN ¬ TRUE;        IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;        DO      -- UpdateStatus proc is performed on the average of 1 per second      IF doUpdate THEN portHandle.commandStatus ¬       			BiParallelPortFace.UpdateStatus [portHandle.param.port];      -- wait for notification      <<WAIT statusWait;>>        waitingForCondReBroad ¬ waitingForCondReBroad + 1;	WAIT condReBroadcast;            -- return on DELETEd Channel      IF NOT portHandle.param.portInUse THEN RETURN [portHandle.deviceStatus];      [portHandle.commandStatus, portHandle.deviceStatus] ¬    			BiParallelPortFace.GetStatus [portHandle.param.port];      IF portHandle.deviceStatus.statusIsUpToDate THEN         -- UpdateStatus command completed, return if old statusIsUpToDate = FALSE	IF NOT stat.statusIsUpToDate THEN {	   newStat ¬ portHandle.deviceStatus;	   EXIT };            -- got here 'cuz of timeout or caused by other condition      oldStat ¬ stat;	-- eliminate statusIsUpToDate from comparison      oldStat.statusIsUpToDate ¬ portHandle.deviceStatus.statusIsUpToDate;      -- now, compare all status bits      IF oldStat # portHandle.deviceStatus THEN {        -- difference(s) in status	newStat ¬ portHandle.deviceStatus;        newStat.statusIsUpToDate ¬ TRUE;      	EXIT };	      doUpdate ¬ NOT doUpdate;    ENDLOOP;        -- statusIsUpToDate = TRUE from this return statement    RETURN [newStat]    END;  -- StatusChangeWait			          TransferWait: PUBLIC ENTRY PROC [portHandle: PortHandle,  			           completionHandle: CompletionHandle]    RETURNS [status: TransferStatus, byteCount: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;        IF (portHandle = nilHandle) OR (completionHandle = NIL) OR        (NOT completionHandle.isActive) THEN RETURN WITH ERROR NilChannelHandle;        DO		    	[status, byteCount] ¬ BiParallelPortFace.PollTransferStatus [portHandle.param.port,    				completionHandle.transfer.operation];	IF status IN BiParallelPortFace.CompletedTransferStatus THEN EXIT;	waitingForCondReBroad ¬ waitingForCondReBroad + 1;	WAIT condReBroadcast;    ENDLOOP;    completionHandle.transferStatus ¬ status;        IF (completionHandle.transfer.transferMode = get) AND (byteCount > 0) THEN       BEGIN       OPEN completionHandle;       block: Environment.Block ¬ Environment.nullBlock;       bBltCount: CARDINAL ¬ 0;          -- should we check to make sure given data buffer has not been deallocated?          -- WARNING: we assume client buffer is still available to us for write          -- copy data from client buffer to data buffer using ByteBlt          block ¬ [LOOPHOLE [dataBlock], 0, byteCount];          bBltCount ¬ ByteBlt.ByteBlt [to: clientBlockPtr­, from: block]       END;           -- reclaim CompletionRec    StoreCompRec [completionHandle];    completionHandle ¬ NIL;    -- notify sigalling available space    NOTIFY compRecReleased;    <<    IF waitingForCompHandle > 0 THEN {       BROADCAST compRecReleased;       waitingForCompHandle ¬ 0 };    >>           portHandle.transferPending ¬ portHandle.transferPending - 1;         RETURN [status, byteCount]    END;  -- TransferWait              << PRIVATE PROCEDURES>>     BuildBufferList: PROC =    BEGIN    lptr: LONG POINTER ¬ NIL;						    tempPtr: CompletionHandle ¬ NIL;    zoneStatus: Zone.Status;    inx: INTEGER;    offset: LONG INTEGER ¬ 0;    maxBlockSizeInWords: CARDINAL ¬ maxBlockSizeInBytes/2;        heapBuffer ¬ Heap.Create [initial: maxBufferListSize+1];    heapBlock ¬ Heap.Create [initial: maxBufferListSize+2, increment: maxBufferListSize,    				     threshold: (maxBufferListSize+1) * maxBlockSizeInWords,				     largeNodeThreshold: (maxBufferListSize+2) * maxBlockSizeInWords];    SpecialHeap.MakeResident [heapBlock];        lptr ¬ Heap.MakeNode [z: heapBlock, n: (maxBufferListSize+1) * maxBlockSizeInWords];    offset ¬ LOOPHOLE [lptr, LONG INTEGER] MOD Environment.wordsPerPage;    IF offset # 0 THEN					       lptr ¬ lptr + (Environment.wordsPerPage - offset);  -- align on a page boundary            -- allocate storage: CompletionRec, Data space & IOCB space    FOR inx IN [0..maxBufferListSize) DO          -- alloc CompletionRec      tempPtr ¬ heapBuffer.NEW [CompletionRec];            -- alloc IOCB      [tempPtr.opRelPtr, zoneStatus] ¬ ResidentHeap.MakeNode [BiParallelPortFace.operationSize,       		      			 BiParallelPortFace.operationAlignment, first64K];      <<IF zoneStatus # okay THEN RETURN ; >>      tempPtr.transfer.operation ¬ @ResidentHeap.first64K [tempPtr.opRelPtr];            -- alloc data buffer      tempPtr.dataBlock ¬ lptr + LONG [inx] * LONG [maxBlockSizeInWords];      IF LOOPHOLE [tempPtr.dataBlock, LONG INTEGER] MOD Environment.wordsPerPage # 0 THEN    	RETURN WITH ERROR ChannelDriverError;	-- for debug	      tempPtr.id ¬ inx;				-- for debug      StoreCompRec [tempPtr];			-- add to the list          ENDLOOP    END;  -- BuildBufferList                  MajorCleanUp: ENTRY PROC [portHandle: PortHandle] =    BEGIN        -- Reset will quiesce parallel port and abort any processes in progress    portHandle.commandStatus ¬ BiParallelPortFace.InitiatePortReset [portHandle.param.port];    IF portHandle.commandStatus = inProgress THEN         DO	-- wait for reset confirmation      IF portHandle.deviceStatus.portWasReset THEN EXIT;      waitingForCondReBroad ¬ waitingForCondReBroad + 1;      WAIT condReBroadcast;      [portHandle.commandStatus, portHandle.deviceStatus] ¬    	  BiParallelPortFace.GetStatus [portHandle.param.port];    ENDLOOP;        -- set port to OFF in the Head    portHandle.param.portInUse ¬ FALSE;    BiParallelPortFace.SetParameters [portHandle.param];    portHandle.locked ¬ FALSE;    BROADCAST condReBroadcast;    NOTIFY statusWait;		-- bring StatusChangeWait proc home too    END;  -- MajorCleanUp        << WAITs for nakedWakeUp Notify AND updates global status >>  NotifyCatcher: ENTRY PROC =    BEGIN    <<Process.SetPriority [5];>>		-- raise priority        DO					-- runs FOREVER!      WAIT nakedWakeUpPtr­;		-- sit and wait for nakedWakeUp cond          -- wake every WAITing process waiting for this cond      IF waitingForCondReBroad > 0 THEN {    	BROADCAST condReBroadcast;	waitingForCondReBroad ¬ 0 };	-- NOTIFY even though statusWait may not be WAITing      NOTIFY statusWait;    ENDLOOP    END;  -- NotifyCatcher      << Retrieves a CompRec from the list >>  RetrieveCompRec: PROC RETURNS [CompletionHandle] =     BEGIN    new: CompletionHandle;    IF compHead = NIL THEN RETURN [NIL];    new ¬ compHead;    compHead ¬ compHead.nextCompRec;    new.nextCompRec ¬ NIL;    new.isActive ¬ TRUE;    RETURN [new]    END;  -- RetrieveCompRec         << Stores spent CompRec to the list >>  StoreCompRec: PROC [old: CompletionHandle] =     BEGIN    old.nextCompRec ¬ NIL;    old.isActive ¬ FALSE;    IF compHead = NIL THEN compHead ¬ old    ELSE compTail.nextCompRec ¬ old;    compTail ¬ old;    END; -- StoreCompRec          << private proc to perform the actual transfer >>   DoTransfer: INTERNAL PROC [portHandle: PortHandle, controlOrData: ControlOrData,   		   	     transferBlock: BiParallelPortChannel.BlockPtr,			     transferMode: BiParallelPortFace.TransferMode]    RETURNS [commandStatus: CommandStatus, completionHandle: CompletionHandle] =    BEGIN    ENABLE UNWIND => NULL;    dataLength: CARDINAL ¬ 0;    tempBlock: Environment.Block;    IF portHandle = nilHandle THEN RETURN WITH ERROR NilChannelHandle;        dataLength ¬ transferBlock.stopIndexPlusOne - transferBlock.startIndex;   << IF dataLength > maxBlockSizeInBytes    	THEN RETURN WITH ERROR TransferExceedsMaxSize;>>        -- get a ready-made CompletionRec with an IOCB and a one page-aligned data buffer    completionHandle ¬ NIL;        -- wait till we get an available compHandle    DO    completionHandle ¬ RetrieveCompRec [];    IF completionHandle = NIL THEN WAIT compRecReleased    	<<  -- too inefficient?   	 IF completionHandle = NIL THEN {      	 waitingForCompHandle ¬ waitingForCompHandle + 1;       	WAIT compRecReleased }    	>>    ELSE EXIT;    ENDLOOP;       IF (NOT hardWareIsDahlia) OR portHandle.param.port = 1 THEN {       IF dataLength > maxBlockSizeInBytes    	THEN RETURN WITH ERROR TransferExceedsMaxSize;	       IF transferMode = put THEN       BEGIN       IF dataLength > 0 THEN {          block: Environment.Block ¬ Environment.nullBlock;                 -- copy data from client buffer to data buffer using ByteBlt          block ¬ [LOOPHOLE [completionHandle.dataBlock], 0, dataLength];          block.stopIndexPlusOne ¬ ByteBlt.ByteBlt [to: block, from: transferBlock­] }       END };           -- save client supplied block    completionHandle.clientBlockPtr ¬ transferBlock;        -- set up for a transfer    IF (NOT hardWareIsDahlia) OR portHandle.param.port = 1 THEN { completionHandle.transfer.operation­ ¬ [completionHandle.dataBlock, dataLength];}    ELSE { tempBlock.blockPointer  ¬ transferBlock.blockPointer + LOOPHOLE[transferBlock.startIndex];    completionHandle.transfer.operation­ ¬ [tempBlock.blockPointer, dataLength];};    completionHandle.transfer.port ¬ portHandle.param.port;    completionHandle.transfer.transferMode ¬ transferMode;    completionHandle.transfer.controlOrData ¬ controlOrData;        portHandle.transfer ¬ completionHandle.transfer;  -- remember last transfer for debug            -- finally, queue for a transfer    portHandle.commandStatus ¬ BiParallelPortFace.InitiateTransfer [completionHandle.transfer];        -- reclaim ALL spaces allocated if transfer rejected    IF portHandle.commandStatus # inProgress THEN    	BEGIN	StoreCompRec [completionHandle];	completionHandle ¬ NIL;	NOTIFY compRecReleased;	<<	IF waitingForCompHandle > 0 THEN {       	   BROADCAST compRecReleased;           waitingForCompHandle ¬ 0 };	>>	END    ELSE portHandle.transferPending ¬ portHandle.transferPending + 1;	-- keep count of xfer pending        RETURN [portHandle.commandStatus, completionHandle];    END;  -- DoTransfer    			 		     << For Dahlia >>     GetPrinterStatus: PUBLIC ENTRY PROCEDURE [portHandle: PortHandle]   	RETURNS [statusByte: BiParallelPortFaceExtras.StatusByte] =		BEGIN	--commandStatus: BiParallelPortFace.CommandStatus;	valid: BOOLEAN;	statusByte ¬ 0;		   -- read SubStatus Register	  	   DO	 	    [statusByte, valid] ¬ BiParallelPortFaceExtras.GetPrinterStatus [portHandle.param.port];		    IF valid # TRUE THEN RETURN WITH ERROR InvalidPortNumberOrPortType;		    IF statusByte # nilStatusByte THEN EXIT;		    waitingForCondReBroad ¬ waitingForCondReBroad + 1;	 	    WAIT condReBroadcast;		   ENDLOOP;		   	RETURN [statusByte];	END;	   <<  GetPageAtOutputTray: PUBLIC ENTRY PROCEDURE [portHandle: PortHandle]   	RETURNS [pageAtOutputTray: PageAtOutputTray] =   		BEGIN	valid: BOOLEAN;	pageAtOutputTray ¬ LOOPHOLE[0];   	  	   				[] ¬ BiParallelPortFace.UpdateStatus [portHandle.param.port];				   DO		   waitingForCondReBroad ¬ waitingForCondReBroad + 1;		   WAIT condReBroadcast;		   [portHandle.commandStatus, portHandle.deviceStatus] ¬ BiParallelPortFace.GetStatus [portHandle.param.port];		   IF portHandle.deviceStatus.statusIsUpToDate # TRUE THEN LOOP;	  	    [pageAtOutputTray, valid] ¬ BiParallelPortFace.GetPageAtOutputTray [portHandle.param.port];		    IF valid # TRUE THEN RETURN WITH ERROR InvalidPortNumberOrPortType;		    EXIT;		   ENDLOOP;		   	RETURN [pageAtOutputTray];	END;>>  << Mainline Code >>    BuildBufferList [];			-- build CompletionRec List    -- There are only TWO ports available  port0Handle ¬ heapBuffer.NEW [PortRec];  port1Handle ¬ heapBuffer.NEW [PortRec];    [nakedWakeUpPtr, nakedWakeUpMask] ¬ SpecialRuntime.AllocateNakedCondition [];  Process.InitializeCondition [nakedWakeUpPtr, Process.SecondsToTicks [60] ];  	-- 60 S	   -- activate watcher process  prevPriority ¬ Process.GetPriority [];  Process.SetPriority [5];  Process.Detach [ FORK NotifyCatcher []];  Process.SetPriority [prevPriority];  channelInitialized ¬ FALSE;    Process.InitializeCondition [@compRecReleased, Process.MsecToTicks [50] ];     -- 50 mS  << Process.InitializeCondition [@condReBroadcast, Process.SecondsToTicks [70] ];  -- 70 S >>  Process.InitializeCondition [@condReBroadcast, Process.SecondsToTicks [20] ];  -- 20 S  Process.InitializeCondition [@statusWait, Process.MsecToTicks [500] ]; 	 -- 0.5 S          END... BiParallelPortChannelDriver        LOG    16-Aug-86 13:10:23	JMA	Created  27-Feb-87 18:26:46	JMA	Changed Parallel to BiParallel  22-May-87 12:59:43	JMA	added conditional BROADCASTs  29-Jun-87 10:23:23	JMA	fixed StatusChangeWait & made maxBufferListSize = 6  13-Jan-88 17:53:00    JMA	fixed StatusChangeWait again  19-Jan-88 12:47:36    JMA	once more, fixed StatusChangeWait again so that it uses UpdateStatus  	proc on a timed basis.  Also replaced BROADCAST for compRecReleased CONDITION with NOTIFY	in the hope of making the Driver more efficient.  	  18-Nov-88 14:54:04    MS	Added GetPrinterStatus,<<GetPageAtOutputTray>>   8-Jun-89 16:11:13	MxS	recompiled to divide the Interface
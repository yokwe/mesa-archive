-- File: Buffer.Mesa - last edit:-- AOF                 20-Aug-86 11:54:27-- SMA                 16-May-86  8:57:53-- MI                  23-Apr-86 16:08:05-- Copyright (C) 1984, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  Environment USING [Block, Byte],  EthernetFace USING [Status],  System USING [Pulses];Buffer: DEFINITIONS =  BEGIN  -- Opaque Data TYPEs gets value through EXPORTED TYPEs  Device: TYPE [2];  --opaque is Driver.Device  Cluster: TYPE [2];  --opaque is BufferMgr.Cluster  Context: TYPE = LONG POINTER;  --to level-1 protocol dependent data  -- Basic Data TYPEs  Byte: TYPE = Environment.Byte;  -- QUEUES  Queue: TYPE = LONG POINTER TO QueueObject;  QueueObject: TYPE = RECORD [    length: CARDINAL, first, last: Buffer, seal: Seal];  Enqueue: PROC[Queue, Buffer];  Dequeue: PROC[Queue] RETURNS [Buffer];  ExtractFromQueue: PUBLIC PROC[Queue, Buffer] RETURNS [Buffer];  QueueLength: PROC[q: Queue] RETURNS [CARDINAL] =    INLINE {RETURN[q.length]};  QueueEmpty: PROC[q: Queue] RETURNS [BOOLEAN] =    INLINE {RETURN[q.length = 0]};  QueueInitialize: PROC[Queue];  QueueCleanup: PROC[Queue];    Seal: TYPE = MACHINE DEPENDENT{unsealed(0), queueSeal(123001B),    bufferSeal(123002B), normalPool(123003B), systemPool(123004B),    listenPool(123005B), listenerSeal(123006B), (LAST[CARDINAL])};  --BUFFER POOLS  AccessHandle: TYPE = LONG POINTER TO --READONLY-- AccessObject;  AccessObject: TYPE = RECORD[    receiveInUse, sendInUse: CARDINAL,  --current values    receive, send: CARDINAL,  --as requested by client    clientFreeBuffer: CONDITION,  --whenever buffer is returned to free pool    next: AccessHandle,  --linked together for debugging (doDebug)    frame: UNSPECIFIED,  --return frame of allocator of object (doDebug)    seal: Seal];  --smashed when object deleted or by accident  PoolType: TYPE = Seal; << [normalPool..listenPool] >>  MakePool: PROC[send, receive: CARDINAL, type: PoolType ¬ normalPool]    RETURNS[AccessHandle];  DestroyPool: PROC[aH: AccessHandle];  GetBuffer: PROC[    type: Type ¬ vagrant, aH: AccessHandle, function: Function,    wait: BOOLEAN ¬ TRUE, size: CARDINAL] RETURNS [b: Buffer];  ReturnBuffer: PROC[Buffer];  CreditReceiveBuffer: PROC[aH: AccessHandle, b: Buffer] RETURNS[BOOLEAN];  BuffersLeft: PROC[aH: AccessHandle] RETURNS [CARDINAL];  SendBuffersLeft: PROC[AccessHandle] RETURNS [CARDINAL];  ReceiveBuffersLeft: PROC[AccessHandle] RETURNS [CARDINAL];  -- BUFFERS  Function: TYPE = {send, receive, driver, free};  Type: TYPE = MACHINE DEPENDENT{    vagrant(0), ns(1), pup(2), arpa(3), osi(4), upt1(5), upt2(6), orphan(7)};  Pointer: TYPE = LONG POINTER TO Buffer;  Buffer: TYPE = LONG POINTER TO BufferObject;  BufferObject: TYPE = MACHINE DEPENDENT RECORD [    highLayer(0): Environment.Block,  --used by network and above layers    linkLayer(4): Environment.Block,  --used by data link layer    requeueProcedure(8): PROC[Buffer],  --for freeing, etc    requeueData(10): LONG UNSPECIFIED,  --available to higher layer clients    fo(12): FixedOverhead,  --information generically used all layers    bufferBody(35): SELECT OVERLAID * FROM      rawBytes => [rawBytes(35): PACKED SEQUENCE COMPUTED CARDINAL OF Byte],      rawWords => [rawWords(35): SEQUENCE COMPUTED CARDINAL OF WORD],      ENDCASE];  <<  --PRIVATE-- in the following record indicates that the field is written only  by the buffer management routines.  >>  FixedOverhead: TYPE = MACHINE DEPENDENT RECORD [    next(0:0..31): --PRIVATE-- Buffer,  --links queued buffers together    queue(2:0..31): --PRIVATE-- Queue,  --of current queue (or NIL if ~in Queue)    cluster(4:0..31): --PRIVATE-- Cluster,  --from which the buffer was extracted    slot(6:0..15): --PRIVATE-- CARDINAL,  --index of cluster slot    currentOwner(7:0..31): --PRIVATE-- AccessHandle,  --that currently is using    seal(9:0..15): --PRIVATE-- Seal,  --for debugging smashed data structures    network(10:0..31): Device,  --set by DLL on input and network layer on output    context(12:0..31): Context,  --level-1 protocol dependent data structure    status(14:0..15): TransferStatus,  --software status set by many, seen by few    time(15:0..31): System.Pulses,  --buffer was received/transmitted    allNets(17:0..0): BOOLEAN,  --broadcast to all connected nets    bypassZeroNet(17:1..1): BOOLEAN,  --?????    type(17:2..4): --PRIVATE-- Type,  --valid only if not free    function(17:5..6): --PRIVATE-- Function,  --valid only if not free    tries(17:7..15): Byte,  --transport transmissions attempts    debug(18:0..15): UNSPECIFIED,  --return frame link of last queue operation    driver(19): DriverInformation];  --driver information      DeviceType: TYPE = MACHINE DEPENDENT{    ethernet(0), ethernetOne, phonenet, clusternet, x25, spare1, spare2,    other(15)};      dataLinkReserve: READONLY CARDINAL;  --data link encapsulation reserved (bytes)  maxUserDataSize: READONLY CARDINAL;  --max data field available client (bytes)     DriverInformation: TYPE = MACHINE DEPENDENT RECORD [    length(0:0..15): CARDINAL,  --in bytes, including encapsulation    iocb(1:0..31): LONG POINTER,  --pointer to control block (drivers only)    faceStatus(3:0..15): SELECT device(3:0..3): DeviceType FROM      ethernet => [ethernet(3:4..15): EthernetFace.Status],      other => [other(3:4..15): WORD[0..7777B]],      ENDCASE];  TransferStatus: TYPE = {    pending,  --packet has not been sent/received    goodCompletion,  --all is okay    aborted,  --by client or by system    rejected,  --by client or by system    noRouteToNetwork,  --local router couldn't find route    hardwareProblem,  --on this machine    invalidDestAddr,  --no such address or improperly specified    protocolViolation,  --software protocol check    noAnswerOrBusy, -- auto-dial, curcuits only    noTranslationForDestination, -- no phone number for this destination    circuitInUse, -- being used to talk to another destination    circuitNotReady, -- dial the phone or connect modems (non-auto-dial case)    noDialingHardware, dialerHardwareProblem};   --BUFFER MANAGEMENT UTILITIES  DataBytesPerRawBuffer: PROC [Buffer] RETURNS [CARDINAL];  END.  LOG14-May-84 11:18:05  AOF  Post Klamath.23-Apr-86 16:08:22  MI   Cut protocol dependency and changed structure of BufferObject to support variable size of encapsulation.12-May-86 16:58:30  SMA  Moved in Seal and DeviceType from DriverTypes.	19-Aug-86 10:05:38  AOF  Clean up comments, etc (DataBytesPerRawBuffer).20-Aug-86 11:54:07  AOF  dataLinkReserve & maxUserDataSize	
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- MailCourier.mesa-- Last edited by AlHall:	11-Oct-83 13:14:00-- Last revised by Wobber:	 6-Apr-84 16:30:34-- last edited by Hankins:	12-Jul-83 10:35:12-- last edited by Gobbel:	 8-Jun-83 11:44:01DIRECTORY  Auth USING [AuthenticationProblem, Credentials, Verifier],  Courier USING [Description, Handle, VersionRange],  Inbasket USING [CacheStatus, CacheVerifier, Index, IndexRange, State],  MailAttributes USING [    Attribute, AttributeList, Attributes, Envelope, InbasketEnvelopeRecord,    MessageStatus, Selections],  MailStubSpecial USING [ForwardResult],  MailTransport USING [    Envelope, EnvelopeRecord, nullEnvelopeRecord,    AccessProblem, ConnectionProblem, ContentsType, DeliveryAckType,    MessageID, NameList, Postmark, ServiceProblem, SessionProblem,    TransferProblem, UndefinedProblem, Undeliverables],  NSAddr USING [Address],  NSAssignedTypes USING [name, sizeInBytes, type],  NSDataStream USING [Source, Sink, Ticket],  NSName USING [Name],  ServicesAssignedTypes USING [firstMailAttributeType, firstMSType],  Stream USING [Handle],  System USING [SocketNumber];  MailCourier: DEFINITIONS =  BEGIN  Attributes: TYPE = MailAttributes.Attributes;  AttributeList: TYPE = MailAttributes.AttributeList;  ContentsType: TYPE = MailTransport.ContentsType;  Name: TYPE = NSName.Name;  NameList: TYPE = MailTransport.NameList;  Selections: TYPE = MailAttributes.Selections;  Words: TYPE = LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED;    AuthPair: TYPE = MACHINE DEPENDENT RECORD [c: Auth.Credentials, v: Auth.Verifier];  CredsAndMbx: TYPE = MACHINE DEPENDENT RECORD [creds: AuthPair, name: Name];  EncodedAttribute: TYPE = RECORD [type: EncodedType, words: Words];  EncodedList: TYPE = LONG DESCRIPTOR FOR ARRAY OF EncodedAttribute;  EncodedType: TYPE = LONG CARDINAL;  EncodedSelections: TYPE = MACHINE DEPENDENT RECORD [    transportEnvelope(0): BOOLEAN,    inbasketEnvelope(1): BOOLEAN,    mailAttributes(2): LONG DESCRIPTOR FOR ARRAY OF EncodedType];  ListElement: TYPE = LONG POINTER TO ListElementRecord;  ListElementProc: TYPE = PROC [e: ListElement] RETURNS [continue: BOOLEAN];  ListElementRecord: TYPE = MACHINE DEPENDENT RECORD [    message: Inbasket.Index,    transportEnvelope: EncodedList,    inbasketEnvelope: EncodedList,    mailAttributes: EncodedList    ];  ServerDispatchProc: TYPE = PROC [params: ParamPtr];    SessionToken: TYPE [2];  ProtocolSession: TYPE = MACHINE DEPENDENT RECORD [    token: SessionToken, verifier: Auth.Verifier];  -- willingness of servers to accept mail    Willingness: TYPE = CARDINAL;  mostWilling: Willingness = 1;  leastWilling: Willingness = 10;          -- types describing remote programs  protocolBase: CARDINAL = 16;    tBase: CARDINAL = protocolBase*ProtocolType.transport.ORD;  iBase: CARDINAL = protocolBase*ProtocolType.inbasket.ORD;  sBase: CARDINAL = protocolBase*ProtocolType.interServer.ORD;    ProtocolType: TYPE = MACHINE DEPENDENT {transport(0), inbasket(1), interServer(2)};  ProcedureType: TYPE = MACHINE DEPENDENT {    -- transport procs    serverPoll(tBase+0), post(tBase+1), beginDelivery(tBase+2),    acknowledge(tBase+3), deliverContent(tBase+4), deliverEnvelope(tBase+5),    endDelivery(tBase+6), deliverySlotPoll(tBase+7),    -- inbasket procs    changeStatus(iBase+0), delete(iBase+1), list(iBase+2), locate(iBase+3),    logoff(iBase+4), logon(iBase+5), mailCheck(iBase+6), inbasketPoll(iBase+7),    retrieve(iBase+8),    -- server to server procs    queryUp(sBase+0), cacheFlush(sBase+1), forwardMsg(sBase+2)};  ProcedureTypeRep: TYPE = MACHINE DEPENDENT RECORD [    fill(0: 0..9): [0..1024), prot(0: 10..11): ProtocolType, num(0:12..15): [0..16)];    ErrorType: TYPE = {    access, authentication, connection, contentsType, index,    invalidRecipients, service, session, transfer, undefined};  BulkDataObject: TYPE = LONG POINTER TO BulkDataRecord;  BulkDataState: TYPE = MACHINE DEPENDENT {ticket, sink, source, stream};  BulkDataRecord: TYPE = MACHINE DEPENDENT RECORD [    object(0): SELECT state(0): BulkDataState FROM  -- not noted in Description!!      ticket => [ticket(1): NSDataStream.Ticket],  -- must be the largest one!!!      sink => [sink(1): NSDataStream.Sink],      source => [source(1): NSDataStream.Source],      stream => [stream(1): Stream.Handle],      ENDCASE];           ParamPtr: TYPE = LONG POINTER TO ParamRecord;  ParamRecord: TYPE = MACHINE DEPENDENT RECORD [    type(0): ProcedureType,    version(1): CARDINAL,    results(2): ResultRecord,    var(11): SELECT COMPUTED ProcedureType FROM      -- transport procs      acknowledge => [        session(11): ProtocolSession, reply(16): MailTransport.DeliveryAckType],      beginDelivery => [mbx(11): CredsAndMbx],      deliverContent => [session(11): ProtocolSession, contents(16): BulkDataRecord],      deliverEnvelope => [session(11): ProtocolSession],      deliverySlotPoll => [mbx(11): CredsAndMbx],      endDelivery => [session(11): ProtocolSession],      post => [        authPair(11): AuthPair, recipients(18): NameList,        returnToName(21): Name, -- only noted in old version	postIfInvalidNames(23): BOOLEAN, allowDLRecipients(24): BOOLEAN,        contentsType(25): ContentsType, envOptions(27): EncodedList,	contents(30): BulkDataRecord],      serverPoll => [authPair(11): AuthPair],      -- inbasket procs      changeStatus => [        session(11): ProtocolSession, range(16): Inbasket.IndexRange,        status(18): MailAttributes.MessageStatus],      delete => [session(11): ProtocolSession, range(16): Inbasket.IndexRange],      inbasketPoll => [mbx(11): CredsAndMbx],      list => [        session(11): ProtocolSession, range(16): Inbasket.IndexRange,        selections(18): EncodedSelections, listing(23): BulkDataRecord,	listProc(35): ListElementProc -- NOT NOTED IN DESCRIPTION RTN!! --],      locate => [        session(11): ProtocolSession, status(16): MailAttributes.MessageStatus],      logoff => [session(11): ProtocolSession],      logon => [        mbx(11): CredsAndMbx, cacheCheck(20): Inbasket.CacheVerifier,        allowSharing(24): BOOLEAN],      mailCheck => [session(11): ProtocolSession],      retrieve => [        session(11): ProtocolSession, message(16): Inbasket.Index,        expectedContentsType(17): ContentsType, contents(19): BulkDataRecord],            -- server to server procs      cacheFlush => [name(11): Name],      queryUp => [destService(11): Name],      forwardMsg => [        authPair(11): AuthPair, sendingService(18): Name, destService(20): Name,        size(22): LONG CARDINAL, createPostmark(24): MailTransport.Postmark,        msgID(28): MailTransport.MessageID, inbasketEnv(33): EncodedList,	contents(36): BulkDataRecord],      ENDCASE];      ResultPtr: TYPE = LONG POINTER TO ResultRecord;  ResultRecord: TYPE = MACHINE DEPENDENT RECORD [    var(0): SELECT OVERLAID ProcedureType FROM      -- transport procs      acknowledge => [],      beginDelivery => [deliverySession(0): ProtocolSession],      deliverContent => [],      deliverEnvelope => [empty(0): BOOLEAN, envelope(1): EncodedList],      deliverySlotPoll => [mailExists(0): BOOLEAN, isPrimary(1): BOOLEAN],      endDelivery => [],      post => [        invalidNames(0): MailTransport.Undeliverables,	msgID(3): MailTransport.MessageID ],      serverPoll => [        willingness(0): Willingness, address(1): NSAddr.Address,	returnVerifier(4): Auth.Verifier, serverName(7): Name],            -- inbasket procs      changeStatus => [],      delete => [],      inbasketPoll => [pollState(0): Inbasket.State],      list => [],      locate => [index(0): Inbasket.Index],      logoff => [cacheVerifier(0): Inbasket.CacheVerifier],      logon => [session(0): ProtocolSession, cacheStatus(5): Inbasket.CacheStatus],      mailCheck => [checkState(0): Inbasket.State, checkAgainWithin(4): CARDINAL],      retrieve => [transportEnv(0): EncodedList, inbasketEnv(3): EncodedList],      -- server to server procs      forwardMsg => [forwardResult(0): MailStubSpecial.ForwardResult],      queryUp => [upAndAccepting(0): BOOLEAN],      cacheFlush => [],      ENDCASE];      ErrorArgumentRecord: TYPE = MACHINE DEPENDENT RECORD [    var(0): SELECT COMPUTED ErrorType FROM      access => [problem(0): MailTransport.AccessProblem],      authentication => [problem(0): Auth.AuthenticationProblem],      connection => [problem(0): MailTransport.ConnectionProblem],      contentsType => [correctType(0): MailTransport.ContentsType],      index => [badIndex(0): Inbasket.Index],      invalidRecipients => [nameList(0): MailTransport.Undeliverables],      service => [problem(0): MailTransport.ServiceProblem],      session => [problem(0): MailTransport.SessionProblem],      transfer => [problem(0): MailTransport.TransferProblem],      undefined => [problem(0): MailTransport.UndefinedProblem],      ENDCASE];  -- PROCS    -- mapping of proc/error types into numbers/descriptions    DescribeArguments: Courier.Description;  DescribeResults: Courier.Description;  GetProgram: PROC [type: ProcedureType] RETURNS [prog: LONG CARDINAL];    GetError: PROC [error: ErrorType, proc: ProcedureType]    RETURNS [number: CARDINAL, desc: Courier.Description];  GetSocket: PROC RETURNS [System.SocketNumber];  GetExportInfo: PROC [type: ProtocolType] RETURNS [stubVersion: CARDINAL,    prog: LONG CARDINAL, versionRange: Courier.VersionRange];    LookupErrorType: PROC [errorNumber: CARDINAL, proc: ProcedureType]    RETURNS [type: ErrorType, desc: Courier.Description];      -- Raises Courier.Error[unknownErrorInRemoteProcedure] !!!      LookupProcedure: PROC [procNumber: CARDINAL, cH: Courier.Handle]    RETURNS [type: ProcedureType];      -- Raises Courier.NoSuchProcedureNumber !!!  NumberFromProc: PROCEDURE [type: ProcedureType]    RETURNS[CARDINAL] = INLINE {      RETURN[LOOPHOLE[type, ProcedureTypeRep].num] };      ProtocolFromProc: PROCEDURE [type: ProcedureType]    RETURNS[ProtocolType] = INLINE {      RETURN[LOOPHOLE[type, ProcedureTypeRep].prot] };      RegisterServer: PROCEDURE [proc: ServerDispatchProc];    -- utilities    EncodeSelections: PROC [sels: Selections] RETURNS [EncodedSelections];  FreeEncodedSelections: PROC [encodedSels: EncodedSelections] = INLINE {    stubZone.FREE[@encodedSels.mailAttributes.BASE] };    -- procedures for serialization/deserialization of ListStream    DeserializeListStream: PROC [s: Stream.Handle, proc: ListElementProc]    RETURNS [stoppedByClient: BOOLEAN];   SerializeListStream: PROC [s: Stream.Handle, doList: PROC[ListElementProc]];  -- utility/heap procedures    stubZone: UNCOUNTED ZONE;    FreeEncodedList: PROC [list: EncodedList];  FreeNameList: PROC [name: NameList];  FreeResults: PROC [loc: ParamPtr];      -- useful description procs    DescribeEncodedList: Courier.Description;  DescribePostmark: Courier.Description;  DescribeUndeliverables: Courier.Description;    -- stuff about envelopes and attributes of messages    InternalEnvelope: TYPE = LONG POINTER TO InternalEnvelopeRecord;  InternalEnvelopeRecord: TYPE = RECORD [    transport: MailTransport.EnvelopeRecord,    --optional fields internal to MS    returnToName: NSName.Name,    previousRecipients: MailTransport.NameList];      VariantEnvelope: TYPE = RECORD [    var: SELECT type: * FROM      transport => [env: MailTransport.Envelope],      filed => [env: MailAttributes.Envelope],      inbasket => [env: LONG POINTER TO MailAttributes.InbasketEnvelopeRecord],      internal => [env: InternalEnvelope],      ENDCASE ];         nullInternalEnvelopeRecord: InternalEnvelopeRecord = [    transport: MailTransport.nullEnvelopeRecord,    returnToName: NIL, previousRecipients: NIL];      --  ENVELOPE ATTRIBUTE TYPES  EnvelopeType: TYPE = EncodedType;        -- transport envelope  postmark: EnvelopeType = 0;  messageID: EnvelopeType = 1;   contentsType: EnvelopeType = 2;  contentsSize: EnvelopeType = 3;  originator: EnvelopeType = 4;  oldTransportProblem: EnvelopeType = 5;  transportProblem: EnvelopeType = 6;  returnToName: EnvelopeType = 7;  previousRecipients: EnvelopeType = 8;    -- inbasket envelope  messageStatus: EnvelopeType = 1000;    --  MESSAGE ATTRIBUTE TYPES  (NBS-compatible message attributes)    MessageType: TYPE = EncodedType;  firstMsgAttribute: MessageType = ServicesAssignedTypes.firstMailAttributeType;   from: MessageType = firstMsgAttribute;  replyTo: MessageType = firstMsgAttribute + 2;  to: MessageType = firstMsgAttribute + 4;  cc: MessageType = firstMsgAttribute + 5;  comments: MessageType = firstMsgAttribute + 15;  inReplyTo: MessageType = firstMsgAttribute + 18;  lastMsgAttribute: MessageType = inReplyTo;    -- MESSAGE ATTRIBUTE TYPES which are Filing attributes    bodySize: EncodedType = NSAssignedTypes.sizeInBytes;  bodyType: EncodedType = NSAssignedTypes.type;  subject: EncodedType = NSAssignedTypes.name;    -- the following are for the encapsulation of envelopes on FIling files  filedEnvelope: EncodedType = ServicesAssignedTypes.firstMSType + 1;  -- transportEnvelope: EncodedType = ServicesAssignedTypes.firstMSType + 1;  -- inbasketEnvelope: EncodedType = ServicesAssignedTypes.firstMSType + 2;    -- encoding/decoding envelopes  -- both of the following can raise Courier errors!!  DecodeVariantEnvelope: PROC [list: EncodedList, env: VariantEnvelope];  EncodeVariantEnvelope: PROC [env: VariantEnvelope] RETURNS [list: EncodedList];  FreeVariantEnvelope: PROC [env: VariantEnvelope];  SizeOfVariantEnvelope: PROC [env: VariantEnvelope] RETURNS [words: CARDINAL];  -- operations on attributes  -- all the following can raise MailAttribute errors!!    DecodeAttributeList: PROC [from: EncodedList, attributes: Attributes];  EncodeAttributeList: PROC [from: AttributeList, defaultName: Name]    RETURNS [EncodedList];  END.  
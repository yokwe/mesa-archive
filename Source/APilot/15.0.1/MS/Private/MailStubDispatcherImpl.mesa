-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- MailStubDispatcherImpl.mesa  -  All remote calls to mail stub come here.-- Wobber	6-Apr-84 15:55:25-- Gobbel	24-May-83 12:18:04-- Hankins	11-Jul-83 13:07:56-- Gillies	22-Jan-86 19:48:26 Check out new verifier for Courier RetryDIRECTORY  Auth USING [    AuthenticationError, AuthenticationProblem, CallError, CallProblem,    CheckOutNextVerifier, CheckOutCredsAndNextVerifier,    ConversationHandle, IdentityHandle, Initiate, Refresh, WhichArg, Terminate],  Courier USING [    Arguments, Call, Create, Delete, Description, Error, ErrorCode, Free,    Handle, Parameters, RemoteErrorSignalled, VersionMismatch],  CH USING [    Buffer, BufferTooSmall, ConversationHandle, DeserializeFromRhs,    FreeConversationHandle, FreeRhs, LookupValueProperty, MakeConversationHandle,    MakeRhs, ReturnCode],  CHCommonLookups USING [LookupAddress],  CHPIDs USING [mailboxes],  ExpeditedCourier USING [    Call, CallToInternetRing, DeserializeFromBlock, Hop,    NewRadiusNotifyProc, ResponseProc],  Inbasket USING [ContentsTypeMismatch, Index, InvalidIndex],  MailCourier USING [    AuthPair, BulkDataObject, DescribeArguments,    DescribeResults, ErrorArgumentRecord, ErrorType, GetExportInfo,    GetProgram, GetSocket, LookupErrorType, NumberFromProc,    ParamPtr, ParamRecord, ProcedureType, ProtocolSession, ResultRecord,    ServerDispatchProc, SessionToken, stubZone],  MailStubInternal,  MailStubSpecial,  MailTransport USING [    AuthenticationProblem, ContentsType, Error, ErrorRecord, FreeUndeliverables,    InvalidRecipients, Location, LocationRecord, MailboxType, Undeliverables],  NetworkStream USING [AssignNetworkAddress],  NSAddr USING [SelectNearestAddress],  NSDataStream USING [    Abort, Aborted, AnnounceStream, CancelTicket, Handle, OperateOnSink,    OperateOnSource, Register, Ticket],  NSName USING [CopyName, FreeName, Name, NameRecord],  SharedKeys USING [msName],  Stream USING [Delete],  System USING [HostNumber, NetworkAddress, nullNetworkAddress];  MailStubDispatcherImpl: MONITOR   IMPORTS    Auth, CH, CHCommonLookups, Courier, ExpeditedCourier, Inbasket, MailCourier,    MailStubSpecial, MailTransport, NetworkStream, NSAddr, NSDataStream,    NSName, SharedKeys, Stream  EXPORTS MailCourier, MailStubInternal, MailStubSpecial, MailTransport  SHARES MailTransport =  BEGIN    -- TYPES    GenericError: TYPE = RECORD [    var: SELECT type: * FROM      transport => [error: MailTransport.ErrorRecord],      invalidRecipients => [nameList: MailTransport.Undeliverables],      invalidIndex => [badIndex: Inbasket.Index],      contentsType => [correctType: MailTransport.ContentsType],      courier => [code: Courier.ErrorCode],      authentication => [problem: Auth.AuthenticationProblem],      none => [],      ENDCASE];    -- VARIABLES    forceRemoteCalls: BOOLEAN ¬ FALSE;  localDispatcher: MailCourier.ServerDispatchProc ¬ NIL;  localAddr: System.NetworkAddress;  tVer: CARDINAL ¬ MailCourier.GetExportInfo[transport].stubVersion;  z: UNCOUNTED ZONE = MailCourier.stubZone;    -- Expedited Courier success statistics  ExpCalls: ARRAY BOOLEAN OF LONG CARDINAL ¬ ALL[0];  ExpResponds: ARRAY BOOLEAN OF LONG CARDINAL ¬ ALL[0];  bothCourierFails: LONG CARDINAL ¬ 0;    Bug: ERROR = CODE;        -- PROCS (to MailStubInternal)    CallWithSession: PUBLIC PROCEDURE [    s: MailStubInternal.Session, params: MailCourier.ParamPtr] =    BEGIN    session: LONG POINTER TO MailCourier.ProtocolSession ¬ LOOPHOLE[@params.var];    NewVerifier: PROC = {session­ ¬ [s.token, Auth.CheckOutNextVerifier[s.conv]]};    AcquireSession[s];    Call[NewVerifier, s.cH, params ! UNWIND => ReleaseSession[s]];    ReleaseSession[s];    END;  -- CallWithSession	  CallWithoutSession: PUBLIC PROCEDURE [    params: MailCourier.ParamPtr, callType: MailStubInternal.CallType,    identity: Auth.IdentityHandle] RETURNS [newS: MailStubInternal.Session] =    BEGIN    cH: Courier.Handle;    prog: LONG CARDINAL;    conv: Auth.ConversationHandle;    dest: System.NetworkAddress;    token: MailCourier.SessionToken;    authPairPtr: LONG POINTER TO MailCourier.AuthPair ¬ LOOPHOLE[@params.var];    NewVerifier: PROC =      {IF conv#NIL THEN        [authPairPtr.c, authPairPtr.v] ¬ Auth.CheckOutCredsAndNextVerifier[conv]};    [conv, dest] ¬ MakeConversation[identity, callType];    prog ¬ MailCourier.GetProgram[params.type];    cH ¬ Courier.Create[dest, prog, params.version, z, transactional];    Call [NewVerifier, cH, params !      MailTransport.Error =>         IF error=[authentication[credsExpiredPleaseRetry]] THEN Auth.Refresh[conv];      UNWIND => {Courier.Delete[cH]; Auth.Terminate[@conv, z]}];    SELECT params.type FROM      logon, beginDelivery => token ¬ params.results.session.token;      ENDCASE => {Courier.Delete[cH]; Auth.Terminate[@conv, z]; RETURN[NIL]};    -- ?? check return verifier here??    newS ¬ z.NEW[MailStubInternal.SessionRecord ¬ [cH, conv, token]];    END;  -- CallWithoutSession  DeleteSession: PUBLIC PROCEDURE [s: MailStubInternal.Session] =    BEGIN    Courier.Delete[s.cH];    Auth.Terminate[@s.conv, z];    z.FREE[@s];    END;  LocalPostingSlot: PUBLIC PROCEDURE RETURNS [System.NetworkAddress] =    BEGIN    IF localDispatcher#NIL THEN RETURN [localAddr];    RETURN [MailStubSpecial.nullAddress];    END;         -- PROCS (to MailTransport)     FreeLocation: PUBLIC PROC [loc: MailTransport.Location] =    BEGIN    NSName.FreeName[z, loc.serverName];    z.FREE[@loc];    END;      GetLocation: PUBLIC PROC [identity: Auth.IdentityHandle, mailbox: NSName.Name,    type: MailTransport.MailboxType] RETURNS [loc: MailTransport.Location] =    BEGIN    initialBufferSize: CARDINAL ¬ 25;    buffer: CH.Buffer ¬ CH.MakeRhs[initialBufferSize, z];    server: NSName.Name ¬ NIL;    addr: System.NetworkAddress;    convH: CH.ConversationHandle ¬ [NIL];        BEGIN ENABLE      BEGIN      UNWIND => {        CH.FreeRhs[buffer, z];        IF server#NIL THEN NSName.FreeName[z, server];	IF convH.conversation#NIL THEN CH.FreeConversationHandle[@convH, z] };      CH.BufferTooSmall => {        CH.FreeRhs[offender, z];        buffer ¬ CH.MakeRhs[lengthNeeded, z];	RESUME[buffer] };      END;    rc: CH.ReturnCode;    ok: BOOLEAN;    authError: Auth.CallProblem;    [convH, ok, authError] ¬ CH.MakeConversationHandle[identity, z];    IF ~ok THEN MapAuthError[authError, initiator];    rc ¬ CH.LookupValueProperty[convH, mailbox, CHPIDs.mailboxes, buffer, NIL];    SELECT rc.code FROM      IN [illegalOrgName..noSuchLocal] =>        ERROR MailTransport.Error [[location[noSuchName]]];      propertyIDNotFound =>        ERROR MailTransport.Error [[location[noMailboxForName]]];      done =>         BEGIN        tempMbox: MailStubSpecial.MailboxPropertyRecord;        IF ~CH.DeserializeFromRhs[	  [@tempMbox, MailStubSpecial.MailboxPropertyDescription], z, buffer] OR	     LENGTH[tempMbox.servers] <= type.ORD THEN	       ERROR MailTransport.Error [[location[noLocationFound]]];        server ¬ NSName.CopyName[z, @tempMbox.servers[type.ORD]];        Courier.Free[[@tempMbox, MailStubSpecial.MailboxPropertyDescription], z];        END;      ENDCASE;    IF rc.code=done THEN      [rc, addr] ¬ CHCommonLookups.LookupAddress[convH, server];    SELECT rc.code FROM      done => NULL;      rejectedTooBusy, allDown =>        ERROR MailTransport.Error [[location[noCHAvailable]]];      ENDCASE =>        ERROR MailTransport.Error [[location[noLocationFound]]];        END;  -- of ENABLE UNWIND          CH.FreeRhs[buffer, z];    CH.FreeConversationHandle[@convH, z];    loc ¬ z.NEW [MailTransport.LocationRecord ¬ [type, server, addr]];    END;  -- export to MailStubSpecial    AllowLocalCalls: PUBLIC PROCEDURE = {forceRemoteCalls ¬ FALSE};  DisallowLocalCalls: PUBLIC PROCEDURE = {forceRemoteCalls ¬ TRUE};   -- mailbox CH property description  ServerPollBroadcast: PUBLIC PROCEDURE [    identity: Auth.IdentityHandle, callback: MailStubSpecial.ServerPollCallback] =    BEGIN    procNumber: CARDINAL;    prog: LONG CARDINAL;    conv: Auth.ConversationHandle;    gotAResponse: BOOLEAN ¬ FALSE;    hopsToBroadcast: ExpeditedCourier.Hop = 6;    stopAtNextRing: BOOLEAN ¬ FALSE;    p: serverPoll MailCourier.ParamRecord ¬ [      serverPoll, tVer, NULL, serverPoll [NULL]];    NextRing: ExpeditedCourier.NewRadiusNotifyProc = {      RETURN[~(newRingRadius > 0 AND stopAtNextRing)] };    ResponseProc: ExpeditedCourier.ResponseProc =      BEGIN      continue ¬ TRUE;      WITH header.body SELECT FROM	return =>	  BEGIN	  IF ExpeditedCourier.DeserializeFromBlock[	    [@p, MailCourier.DescribeResults], z, serializedResponse] THEN	      BEGIN	      plsStop: BOOLEAN ¬ ~callback[	        NSAddr.SelectNearestAddress[p.results.address],	        p.results.willingness, p.results.serverName];	      stopAtNextRing ¬ plsStop OR stopAtNextRing;	      -- ?? check return verifier	      Courier.Free[[@p, MailCourier.DescribeResults], z];	      END;	  END;	ENDCASE;   -- else some system problem      END;		-- proc. BroadcastResponseProc	    prog ¬ MailCourier.GetProgram[serverPoll];    procNumber ¬ MailCourier.NumberFromProc[serverPoll];    conv ¬ MakeConversation[identity, [broadcast[]]].c;    [p.authPair.c, p.authPair.v] ¬ Auth.CheckOutCredsAndNextVerifier[conv];    ExpeditedCourier.CallToInternetRing[      prog, p.version, procNumber, [@p, MailCourier.DescribeArguments],      [0, hopsToBroadcast], MailCourier.GetSocket[], findMostServersInShortTime,      ResponseProc, NextRing];    Auth.Terminate[@conv, z];    END;            -- export to MailCourier    RegisterServer: PUBLIC PROCEDURE [proc: MailCourier.ServerDispatchProc] =    BEGIN    localDispatcher ¬ proc;    END;        	  --  Private procs  BulkDataCall: PROC [    cH: Courier.Handle, bulkObject: MailCourier.BulkDataObject,     localCall: BOOLEAN, callProc: PROC RETURNS [BOOLEAN]] =    BEGIN    HandleProc: PROC [h: NSDataStream.Handle] =       BEGIN      IF localCall THEN        BEGIN	bulkObject­ ¬ [stream [h]];	IF ~callProc[] THEN NSDataStream.Abort[h];	Stream.Delete[h ! NSDataStream.Aborted => CONTINUE];        END      ELSE        BEGIN	bulkObject­ ¬ [ticket [NSDataStream.Register[h, cH.remote, cH, TRUE]]];        IF ~callProc[] THEN	  WITH b: bulkObject SELECT FROM	    ticket => NSDataStream.CancelTicket[b.ticket, cH];	    ENDCASE;	END;      END;     -- callProc catches all ERRORs ... local and remote    WITH s: bulkObject SELECT FROM      sink => NSDataStream.OperateOnSink[s.sink, LOOPHOLE[HandleProc]];      source => NSDataStream.OperateOnSource[s.source, LOOPHOLE[HandleProc]]      ENDCASE => ERROR Bug;    END;      Call: PROCEDURE [newVerifier: PROC, cH: Courier.Handle, p: MailCourier.ParamPtr] =    BEGIN    procNumber: CARDINAL;    local, expedited: BOOLEAN ¬ FALSE;	-- how to make calls    courier: BOOLEAN ¬ TRUE;		-- assume it will be a normal courier call    bulkObject: MailCourier.BulkDataObject ¬ NIL;    errRec: GenericError ¬ [none[]];        CallInternal: PROC RETURNS [worked: BOOLEAN ¬ FALSE] =      -- catch all local AND remote errors here!!!      BEGIN ENABLE {	MailTransport.Error => {errRec ¬ [transport[error]]; GOTO problem};	MailTransport.InvalidRecipients => {	  errRec ¬ [invalidRecipients[nameList]]; GOTO problem};	Inbasket.InvalidIndex =>{errRec ¬ [invalidIndex[badIndex]]; GOTO problem};	Inbasket.ContentsTypeMismatch => {	  errRec ¬ [contentsType[correctType]]; GOTO problem};	Auth.AuthenticationError => {	  errRec ¬ [authentication[reason]]; GOTO problem};	Courier.Error => {	  errRec ¬ [courier[errorCode]];	  IF expedited THEN bothCourierFails ¬ bothCourierFails + 1; GOTO problem};	Courier.RemoteErrorSignalled =>	  BEGIN	  errArgs: MailCourier.ErrorArgumentRecord;	  errDesc: Courier.Description;	  errorType: MailCourier.ErrorType;	  [errorType, errDesc] ¬ MailCourier.LookupErrorType[errorNumber, p.type];	  arguments[[@errArgs, errDesc]];	  errRec ¬ WITH e: errArgs SELECT errorType FROM	    access => [transport[[access[e.problem]]]],	    authentication => [authentication[e.problem]],	    connection => [transport[[connection[e.problem]]]],	    contentsType => [contentsType[e.correctType]],	    index => [invalidIndex[e.badIndex]],	    invalidRecipients => [invalidRecipients[e.nameList]],	    session => [transport[[handle[e.problem]]]],	    service => [transport[[service[e.problem]]]],	    transfer => [transport[[transfer[e.problem]]]],	    undefined => [transport[[undefined[e.problem]]]],	    ENDCASE => ERROR Bug;	  GOTO problem;	  END };      procNumber ¬ MailCourier.NumberFromProc[p.type];      newVerifier[];	-- deposit Auth verifier into arguments list      IF local THEN {worked ¬ TRUE; localDispatcher[p]}; -- always works      IF ~worked AND expedited THEN BEGIN	worked ¬ ExpediteCall[cH, procNumber, [p, MailCourier.DescribeArguments],	  [p, MailCourier.DescribeResults] ! Courier.RemoteErrorSignalled =>	  BEGIN	  -- Authenticated calls aren't idempotent.  The authentication verifier	  -- should change for each retransmission.  If not, then verifierReused may	  -- be raised after the 2nd..nth retransmission.  Fixing ExpeditedCourier is	  -- very hard, so here we give up on expediting if we get verifierReused.	  errArgs: MailCourier.ErrorArgumentRecord;	  errDesc: Courier.Description;	  errorType: MailCourier.ErrorType;	  [errorType, errDesc] ¬ MailCourier.LookupErrorType[errorNumber, p.type];	  arguments[[@errArgs, errDesc]];	  WITH e: errArgs SELECT errorType FROM	    authentication => IF e.problem = verifierReused THEN CONTINUE;	    ENDCASE;	  REJECT;	  END;];	-- count the number of exp+courier, and exp only calls.	ExpCalls[courier] ¬ ExpCalls[courier] + 1;	-- count the number of expedited calls that worked.	ExpResponds[worked] ¬ ExpResponds[worked] + 1;	IF ~ worked THEN newVerifier[];	-- maybe we got through; use 2nd verifier	END;      IF ~worked AND courier THEN BEGIN	[] ¬ Courier.Call[	  cH: cH, procedureNumber: procNumber,	  arguments: [p, MailCourier.DescribeArguments],	  results: [p, MailCourier.DescribeResults],	  streamCheckoutProc: (	  IF bulkObject#NIL THEN NSDataStream.AnnounceStream ELSE NIL) !	  Courier.VersionMismatch => ERROR Courier.Error[noSuchProgramExport];	  Courier.Error =>	    IF errorCode=transportTimeout AND bulkObject=NIL THEN RETRY];	worked ¬ TRUE;	-- if no signals are raised, it worked.      END;      -- This next line is a reasonable result for Expedited-only calls that fail.      IF ~worked THEN errRec ¬ [courier[remoteSystemElementNotResponding]];      RETURN[worked];      EXITS  -- enabled        problem => RETURN[FALSE];      END;  -- CallInternal              -- "List" called locally does not go through BulkDataCall.    IF localDispatcher#NIL AND cH.remote.host=localAddr.host AND      ~forceRemoteCalls THEN local ¬ TRUE;    WITH a: p SELECT p.type FROM      list => IF ~local THEN bulkObject ¬ @a.listing;      deliverContent => bulkObject ¬ @a.contents;      retrieve => bulkObject ¬ @a.contents;      post => bulkObject ¬ @a.contents;      forwardMsg => bulkObject ¬ @a.contents;      deliverySlotPoll, inbasketPoll, mailCheck => expedited ¬ TRUE;      queryUp, cacheFlush => {expedited ¬ TRUE; courier ¬ FALSE};      ENDCASE;    IF bulkObject=NIL THEN [] ¬ CallInternal []    ELSE BulkDataCall[cH, bulkObject, local, CallInternal];          -- careful to clean up all errors which require storage    WITH e: errRec SELECT FROM      transport => ERROR MailTransport.Error[e.error];      invalidIndex => ERROR Inbasket.InvalidIndex[e.badIndex];      contentsType => ERROR Inbasket.ContentsTypeMismatch[e.correctType];      courier => ERROR Courier.Error[e.code];      invalidRecipients =>        ERROR MailTransport.InvalidRecipients[e.nameList !	  UNWIND => MailTransport.FreeUndeliverables[e.nameList]];      authentication =>        ERROR MailTransport.Error [[authentication[	  SELECT e.problem FROM	    credentialsInvalid => badNameInIdentity,	    verifierInvalid => badPwdInIdentity,	    credentialsExpired => credsExpiredPleaseRetry,	    inappropriateCredentials => authFlavorTooWeak,	    ENDCASE => other]]];      ENDCASE;    END;  -- Call	    ExpediteCall: PROC [    cH: Courier.Handle, procedureNumber: CARDINAL,    arguments, results: Courier.Parameters] RETURNS [done: BOOLEAN ¬ FALSE] =    BEGIN    dest: System.NetworkAddress ¬ cH.remote;    ExpeditedReponseProc: ExpeditedCourier.ResponseProc =      BEGIN      ProvideErrorArgs: Courier.Arguments =	BEGIN	done ¬ ExpeditedCourier.DeserializeFromBlock[	  argumentsRecord, z, serializedResponse];	IF ~done THEN Courier.Error[parameterInconsistency];        END;      WITH header.body SELECT FROM        return => done ¬ ExpeditedCourier.DeserializeFromBlock[	  results, z, serializedResponse];	  -- else a problem with expedited courier.	abort => ERROR Courier.RemoteErrorSignalled[abort, ProvideErrorArgs]; 	ENDCASE;      RETURN [FALSE];		-- this value is ignored.      END;	-- proc. ExpeditedReponseProc	    dest.socket ¬ MailCourier.GetSocket[];    ExpeditedCourier.Call[      cH.programNumber, cH.versionNumber, procedureNumber,      arguments, dest, ExpeditedReponseProc];    END;     MakeConversation: PROCEDURE [    ident: Auth.IdentityHandle, callType: MailStubInternal.CallType]    RETURNS [c: Auth.ConversationHandle ¬ NIL, a: System.NetworkAddress] =    BEGIN    loc, allocLoc: MailTransport.Location ¬ NIL;    authName: NSName.Name ¬ SharedKeys.msName;    WITH cT: callType SELECT FROM      directed => loc ¬ allocLoc ¬ GetLocation[ident, cT.mbx, primary];      located => loc ¬ cT.loc;      addressed => a ¬ cT.sPtr­;      broadcast => a ¬ System.nullNetworkAddress;      ENDCASE;    IF loc#NIL THEN { authName ¬ loc.serverName; a ¬ loc.addr };    IF ident#NIL THEN      c ¬ Auth.Initiate[ident, authName, a.host, z !        UNWIND => IF allocLoc#NIL THEN FreeLocation[allocLoc];        Auth.CallError => MapAuthError[reason, whichArg]];    IF allocLoc#NIL THEN FreeLocation[allocLoc];    END;  MapAuthError: PROC [code: Auth.CallProblem, whichArg: Auth.WhichArg] =    BEGIN    ERROR MailTransport.Error [[authentication[      SELECT code FROM        strongKeyDoesNotExist, simpleKeyDoesNotExist =>	  IF whichArg=recipient THEN cantGetKeyAtAS ELSE badNameInIdentity,         badKey => badPwdInIdentity,         tooBusy => tooBusy,         cannotReachAS => cannotReachAS,         keysUnavailable => cantGetKeyAtAS,	 ENDCASE => other]]];    END;      -- ENTRY PROCS    AcquireSession: ENTRY PROC [s: MailStubInternal.Session] =    BEGIN    UNTIL ~s.streamInUse DO WAIT s.streamAvailable; ENDLOOP;    s.streamInUse ¬ TRUE;    END;      ReleaseSession: ENTRY PROC [s: MailStubInternal.Session] =    BEGIN    s.streamInUse ¬ FALSE;    NOTIFY s.streamAvailable;    END;      localAddr ¬ NetworkStream.AssignNetworkAddress[];  END.  		  		  LOG.26-Mar-85 11:15:34 DWG New stats, Inbasket.mailCheck->expedited, QueryUp + SendCacheFlush ->expedited only22-Jan-86 19:48:09 DWG Checks out new verifier for expedited retry.
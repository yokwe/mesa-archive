-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- MailAttributesImpl.mesa-- Last revised by Gobbel: 10-May-84 11:37:13-- Last revised by Wobber: 29-Feb-84 16:35:51-- last edited by Hankins 27-Jun-83 12:21:30DIRECTORY  Courier USING [    Description, DeserializeParameters, Error, Free,    nullParameters, Parameters, SerializeParameters],  Heap USING [Create],  MailAttributes,  MailCourier,  MailTransport USING [    ClearEnvelope, Envelope, MessageID, NameList, Postmark, Problem, ProblemRecord],  NSFile USING [Attribute, Attributes, AttributeList, ExtendedSelections, Selections],  NSName USING [    ClearName, DescribeNameRecord, DecodeParameters, EncodeParameters,    FreeName, Name, NameRecord, SizeOfSerializedData],  NSString USING [    CopyString, DescribeString, EquivalentStrings, FreeString, nullString, String],  Stream USING [Handle];MailAttributesImpl: PROGRAM  IMPORTS Courier, Heap, MailCourier, MailTransport, NSName, NSString  EXPORTS MailAttributes, MailCourier =  BEGIN    -- TYPES:  Attribute: TYPE = MailAttributes.Attribute;  Attributes: TYPE = MailAttributes.Attributes;  AttributeList: TYPE = MailAttributes.AttributeList;  AttributeType: TYPE = MailAttributes.AttributeType;  EncodedAttribute: TYPE = MailCourier.EncodedAttribute;  EncodedList: TYPE = MailCourier.EncodedList;  EncodedSelections: TYPE = MailCourier.EncodedSelections;  EncodedType: TYPE = MailCourier.EncodedType;  Envelope: TYPE = MailAttributes.Envelope;  FileAttributeList: TYPE = NSFile.AttributeList;  FileSelections: TYPE = NSFile.Selections;  ListElementProc: TYPE = MailCourier.ListElementProc;  MailProperties: TYPE = MailAttributes.MailProperties;  Name: TYPE = NSName.Name;  NameRecord: TYPE = NSName.NameRecord;  NameList: TYPE = MailTransport.NameList;  Selections: TYPE = MailAttributes.Selections;  VariantEnvelope: TYPE = MailCourier.VariantEnvelope;  Words: TYPE = MailAttributes.Words;  WordSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];      stubZonePages: CARDINAL ¬ 200;  stubHeapSwapUnit: CARDINAL = 4;  stubZone: PUBLIC UNCOUNTED ZONE;    Bug: ERROR = CODE;  BadEnvelope: PUBLIC SIGNAL = CODE;  IllegalAttribute: PUBLIC SIGNAL [attr: Attribute] = CODE;  MalformedAttribute: PUBLIC SIGNAL [type: AttributeType, words: Words] = CODE;    AllocWords: PROC [pt: LONG POINTER TO Words,    len: CARDINAL, recSize: CARDINAL ¬ 1] = INLINE    { pt­ ¬ DESCRIPTOR[stubZone.NEW[WordSeq[len*recSize]], len] };  ParametersFromWords: PROC [words: Words, parameters: Courier.Parameters] =    INLINE { NSName.DecodeParameters[stubZone, words, parameters] };      WordsFromParameters: PROC [parameters: Courier.Parameters] RETURNS [Words] =    INLINE { RETURN[NSName.EncodeParameters[stubZone, parameters]] };        -- EXPORTS to MailAttributes:    ClearAttributes: PUBLIC PROCEDURE [attributes: Attributes] =    BEGIN    FreeNameList[attributes.answerTo];    FreeNameList[attributes.copies];    FreeNameList[attributes.from];    FreeNameList[attributes.to];    NSString.FreeString[stubZone, attributes.inReplyTo];    NSString.FreeString[stubZone, attributes.note];    NSString.FreeString[stubZone, attributes.subject];    END;    ClearEnvelope: PUBLIC PROCEDURE [envelope: Envelope] =    BEGIN    MailTransport.ClearEnvelope[@envelope.transport];    END;    ClearProperties: PUBLIC PROCEDURE [props: MailProperties] =    BEGIN    ClearEnvelope[@props.env];    ClearAttributes[@props.attrs];    END;    DecodeProperties: PUBLIC PROC [fAttrs: NSFile.Attributes, props: MailProperties] =    BEGIN    BEGIN ENABLE Courier.Error => {      SIGNAL BadEnvelope; props.env ¬ MailAttributes.nullEnvelopeRecord; CONTINUE};    eList: EncodedList ¬ NIL;    FOR i: CARDINAL IN [0..LENGTH[fAttrs.extended]) DO      IF fAttrs.extended[i].value=NIL THEN LOOP;  -- ** ADDED      SELECT fAttrs.extended[i].type FROM        MailCourier.filedEnvelope =>          ParametersFromWords[            fAttrs.extended[i].value, [@eList, MailCourier.DescribeEncodedList]];        ENDCASE;      ENDLOOP;    DecodeVariantEnvelope[eList, [filed[@props.env]] !      UNWIND => FreeEncodedList[eList]];    FreeEncodedList[eList];    END;  -- of ENABLE Courier.Error    props.attrs ¬ MailAttributes.nullAttributesRecord;    props.attrs.bodySize ¬ fAttrs.sizeInBytes;    props.attrs.bodyType ¬ fAttrs.type;    props.attrs.subject ¬ NSString.CopyString[stubZone, fAttrs.name];    FOR i: CARDINAL IN [0..LENGTH[fAttrs.extended]) DO      ENABLE UNWIND => ClearProperties[props];      IF fAttrs.extended[i].value=NIL THEN LOOP;  -- ** ADDED      DecodeAttribute[[fAttrs.extended[i].type, fAttrs.extended[i].value], @props.attrs];      ENDLOOP;    END;      EncodeProperties: PUBLIC PROC [    attrList: AttributeList, env: Envelope, defaultName: Name]    RETURNS [FileAttributeList] =    BEGIN    fAttrList: FileAttributeList;    listLength: CARDINAL ¬ 0;    NextElement: PROC [a: NSFile.Attribute] =      BEGIN      fAttrList[listLength] ¬ a;      listLength ¬ listLength + 1;      END;    AllocWords[@fAttrList, LENGTH[attrList]+1, SIZE[NSFile.Attribute]];    IF env#NIL THEN      BEGIN ENABLE Courier.Error => {SIGNAL BadEnvelope; CONTINUE};      words: Words;      eList: EncodedList ¬ EncodeVariantEnvelope[[filed[env]]];      words ¬ WordsFromParameters[        [@eList, MailCourier.DescribeEncodedList] !        UNWIND => FreeEncodedList[eList]];      FreeEncodedList[eList];      NextElement[[extended[MailCourier.filedEnvelope, words]]];      END;    FOR i: CARDINAL IN [0..LENGTH[attrList]) DO       ENABLE UNWIND => FreeFileAttributes[DESCRIPTOR[BASE[fAttrList], listLength]];      WITH attr: attrList[i] SELECT FROM        mailBodySize => NULL;  -- don't encode size here!!!         mailBodyType => NextElement[[type[attr.value]]]; 	mailSubject =>	  NextElement[[name[NSString.CopyString[stubZone, attr.value]]]];        ENDCASE =>          BEGIN	  attribute: EncodedAttribute ¬ EncodeAttribute[attrList[i], defaultName];	  NextElement[[extended[attribute.type, attribute.words]]];	  END;      ENDLOOP;    RETURN [DESCRIPTOR[BASE[fAttrList], listLength]];    END;  EncodeNil: PUBLIC PROC [sels: Selections] RETURNS [FileAttributeList] =    BEGIN    fAttrList: FileAttributeList;    listLength: CARDINAL ¬ 0;    NextElement: PROC [type: EncodedType] =      BEGIN      fAttrList[listLength] ¬ [extended[type, NIL]];      listLength ¬ listLength + 1;      END;    -- Transport and inbasket envelope make up for slots    --  by mailBodyType and mailSubject.    AllocWords[@fAttrList, LENGTH[sels.attributes], SIZE[NSFile.Attribute]];          IF sels.envelope THEN NextElement[MailCourier.filedEnvelope];    FOR i: AttributeType IN AttributeType DO      IF sels.attributes[i] THEN        -- we won't try to NIL out the file type or name here!!	SELECT i FROM	  mailBodySize, mailBodyType, mailSubject => NULL;	  ENDCASE => NextElement[EncodeAttributeType[i]];      ENDLOOP;    RETURN [DESCRIPTOR[BASE[fAttrList], listLength]];    END;      FreeFileAttributes: PUBLIC PROC [list: FileAttributeList] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[list]) DO      WITH attr: list[i] SELECT FROM        extended => stubZone.FREE[@attr.value.BASE];	name => NSString.FreeString[stubZone, attr.value];	ENDCASE;      ENDLOOP;    stubZone.FREE[@list.BASE];    END;  FreeFileSelections: PUBLIC PROC [sels: FileSelections] =    BEGIN    stubZone.FREE[@sels.extended.BASE];    END;  MapSelections: PUBLIC PROC [selections: Selections, mergeWith: FileSelections]    RETURNS [fSelections: FileSelections] =    BEGIN    listLength: CARDINAL ¬ 0;    extendedList: NSFile.ExtendedSelections;    maxExt: CARDINAL ¬ LENGTH[selections.attributes]+LENGTH[mergeWith.extended];    NextElement: PROC [type: EncodedType] =      BEGIN      extendedList[listLength] ¬ type;      listLength ¬ listLength + 1;      END;    fSelections.interpreted ¬ mergeWith.interpreted;    AllocWords[@extendedList, (LENGTH[selections.attributes] +      LENGTH[mergeWith.extended]), SIZE[EncodedType]];    IF selections.envelope THEN NextElement[MailCourier.filedEnvelope];    FOR i: CARDINAL IN [0 .. LENGTH[mergeWith.extended]) DO      NextElement[mergeWith.extended[i]]; ENDLOOP;    FOR i: AttributeType IN AttributeType DO      IF selections.attributes[i] THEN        SELECT i FROM          mailBodySize => fSelections.interpreted[sizeInBytes] ¬ TRUE;          mailBodyType => fSelections.interpreted[type] ¬ TRUE;	  mailSubject => fSelections.interpreted[name] ¬ TRUE;          ENDCASE => NextElement[EncodeAttributeType[i]];      ENDLOOP;    fSelections.extended ¬ DESCRIPTOR[BASE[extendedList], listLength];    IF listLength#0 THEN fSelections.interpreted[extended] ¬ TRUE;    END;      UnqualifyAttributeNames: PUBLIC PROC[attributes: Attributes, defaultName: Name] =    -- eliminates duplicate domain/org names in attribute rec.    BEGIN    UnqualifyNameList: PROC [nL: NameList] =      BEGIN      IF nL # NIL THEN        FOR i: CARDINAL IN [0..LENGTH[nL]) DO          IF NSString.EquivalentStrings[nL[i].domain, defaultName.domain] THEN {            NSString.FreeString[stubZone, nL[i].domain];	    nL[i].domain ¬ NSString.nullString };          IF NSString.EquivalentStrings[nL[i].org, defaultName.org] THEN {            NSString.FreeString[stubZone, nL[i].org];	    nL[i].org ¬ NSString.nullString };        ENDLOOP;      END;    UnqualifyNameList[attributes.answerTo];    UnqualifyNameList[attributes.copies];    UnqualifyNameList[attributes.from];    UnqualifyNameList[attributes.to];    END;      -- EXPORTS to MailCourier  -- operations on envelopes      DecodeVariantEnvelope: PUBLIC PROC [list: EncodedList, env: VariantEnvelope] =    BEGIN    -- ?? nil out partially decoded attribute, or rely on courier to clean up    -- we can put back the following unwind clause when Courier is better    -- BEGIN ENABLE UNWIND =>      --       -- WITH e: env SELECT FROM      --  transport => MailTransport.ClearEnvelope[e.env];      --  filed => ClearEnvelope[e.env];      --  ENDCASE;    WITH e: env SELECT FROM      transport => e.env­ ¬ MailAttributes.nullEnvelopeRecord.transport;      filed => e.env­ ¬ MailAttributes.nullEnvelopeRecord;      inbasket => e.env­ ¬ MailAttributes.nullEnvelopeRecord.inbasket;      internal => e.env­ ¬ MailCourier.nullInternalEnvelopeRecord;      ENDCASE;    FOR i: CARDINAL IN [0..LENGTH[list]) DO      params: Courier.Parameters;      params ¬ LookupEnvelopeAttribute[env, list[i].type];      IF params=Courier.nullParameters THEN LOOP;        ParametersFromWords[list[i].words, params];      ENDLOOP;    END;  EncodeVariantEnvelope: PUBLIC PROC [env: VariantEnvelope] RETURNS [EncodedList] =    BEGIN OPEN MailCourier;    nullEncodedType: EncodedType = LAST[EncodedType];    list: EncodedList;    listLength: CARDINAL ¬ 0;    maxEnvelopeAttributes: CARDINAL = 10;  -- *** this may need to grow    type: EncodedType ¬ nullEncodedType;    AllocWords[@list, maxEnvelopeAttributes, SIZE[EncodedAttribute]];    DO      ENABLE UNWIND => FreeEncodedList[DESCRIPTOR[BASE[list], listLength]];      params: Courier.Parameters;      type ¬ SELECT type FROM        nullEncodedType => SELECT env.type FROM	  inbasket => messageStatus,	  ENDCASE => postmark,        IN [postmark..returnToName] => type + 1,        previousRecipients => messageStatus,        ENDCASE => nullEncodedType;      IF type = nullEncodedType THEN EXIT;      params ¬ LookupEnvelopeAttribute[env, type, TRUE];      IF params=Courier.nullParameters THEN LOOP;      list[listLength] ¬ [type, WordsFromParameters[params]];      listLength ¬ listLength + 1;      ENDLOOP;    RETURN[DESCRIPTOR[BASE[list], listLength]];    END;      FreeVariantEnvelope: PUBLIC PROC [env: VariantEnvelope] =    BEGIN    tEnv: MailTransport.Envelope;    WITH e: env SELECT FROM      transport => tEnv ¬ e.env;      filed => tEnv ¬ @e.env.transport;      inbasket => RETURN;      internal => {        tEnv ¬ @e.env.transport;        IF e.env.returnToName#NIL THEN	  NSName.FreeName[stubZone, e.env.returnToName];	FreeNameList[e.env.previousRecipients] };      ENDCASE;    MailTransport.ClearEnvelope[tEnv];    END;      SizeOfVariantEnvelope: PUBLIC PROC [env: VariantEnvelope]    RETURNS [wordCount: CARDINAL ¬ 0] =    BEGIN OPEN MailCourier;    nullEncodedType: EncodedType = LAST[EncodedType];    type: EncodedType ¬ nullEncodedType;    DO      params: Courier.Parameters;      thisAttributeCount: CARDINAL;      -- !!! IMPLIES KNOWLEDGE OF COURIER FORMATTING      perAttributeOv: CARDINAL = 3;  -- 2 words of type, 1 of count      type ¬ SELECT type FROM        nullEncodedType => SELECT env.type FROM	  inbasket => messageStatus,	  ENDCASE => postmark,        IN [postmark..returnToName] => type + 1,        previousRecipients => messageStatus,        ENDCASE => nullEncodedType;      IF type = nullEncodedType THEN EXIT;      params ¬ LookupEnvelopeAttribute[env, type, TRUE];      IF params=Courier.nullParameters THEN LOOP;      thisAttributeCount ¬ NSName.SizeOfSerializedData[params];      wordCount ¬ wordCount + thisAttributeCount + perAttributeOv;      ENDLOOP;    wordCount ¬ wordCount + 1;   -- for length of toplevel array descriptor    END;      FreeEncodedList: PUBLIC PROC [list: EncodedList] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[list]) DO      stubZone.FREE[@list[i].words.BASE]; ENDLOOP;    stubZone.FREE[@list.BASE];    END;      FreeNameList: PUBLIC PROC [list: NameList] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[list]) DO      NSName.ClearName[stubZone, @list[i]]; ENDLOOP;    stubZone.FREE[@list.BASE];    END;  -- operations on attributes    DecodeAttributeList: PUBLIC PROC [from: EncodedList, attributes: Attributes] =    BEGIN ENABLE UNWIND => ClearAttributes[attributes];    attributes­ ¬ MailAttributes.nullAttributesRecord;    FOR i: CARDINAL IN [0..LENGTH[from]) DO      DecodeAttribute[from[i], attributes]; ENDLOOP;    END;  EncodeAttributeList: PUBLIC PROC [from: AttributeList, defaultName: Name]    RETURNS [list: EncodedList] =    BEGIN    AllocWords[@list, LENGTH[from], SIZE[EncodedAttribute]];    FOR i: CARDINAL IN [0..LENGTH[from]) DO      list[i] ¬ EncodeAttribute[from[i], defaultName !        UNWIND => FreeEncodedList[DESCRIPTOR[BASE[list], i]]];      ENDLOOP;    END;  -- procs for support of List operation    ListHeader: TYPE = MACHINE DEPENDENT RECORD [    type: CARDINAL,  -- nextSegment or lastSegment    lists: CARDINAL];  -- number of lists in this (sub) sequence    singleMessageListHeader: ListHeader = [type: 0, lists: 1];  endOfListHeader: ListHeader = [type: 1, lists: 0];    EncodeSelections: PUBLIC PROC [sels: Selections]    RETURNS [encodedSels: EncodedSelections] =    BEGIN    list: LONG DESCRIPTOR FOR ARRAY OF EncodedType;    listLength: CARDINAL ¬ 0;    AllocWords[@list, LENGTH[sels.attributes], SIZE[EncodedType]];    FOR i: AttributeType IN AttributeType DO      IF sels.attributes[i] THEN {        list[listLength] ¬ EncodeAttributeType[i]; listLength ¬ listLength + 1};      ENDLOOP;    encodedSels ¬ [sels.envelope, sels.envelope, DESCRIPTOR[BASE[list], listLength]];    END;     DeserializeListStream: PUBLIC PROC [s: Stream.Handle, proc: ListElementProc]    RETURNS [stoppedByClient: BOOLEAN] =    BEGIN    header: ListHeader;    clientAbort: BOOLEAN ¬ FALSE;    DO       Courier.DeserializeParameters[[@header, DescribeListHeader], s, stubZone];      FOR i: CARDINAL IN [0..header.lists) DO        eRec: MailCourier.ListElementRecord ¬ [0, NIL, NIL, NIL];	Cleanup: PROC = {Courier.Free[[@eRec, DescribeListElement], stubZone]};	IF clientAbort THEN RETURN[TRUE];   -- not at end of enumeration !!	Courier.DeserializeParameters[[@eRec, DescribeListElement], s, stubZone];        clientAbort ¬ ~proc[@eRec ! UNWIND => Cleanup[]];	Cleanup[];	ENDLOOP;      IF header.type#0 THEN RETURN[FALSE];      ENDLOOP;    END;         SerializeListStream: PUBLIC PROC [    s: Stream.Handle, doList: PROC[ListElementProc]] =    BEGIN    -- not end of stream, 1 message in sequence    header: ListHeader ¬ singleMessageListHeader;    SerializeListElement: ListElementProc =      BEGIN      -- we won't worry about catching serialization errors here ...      -- we just deserialized them getting here ... fix this if we don't      -- do this deserialization/serialization at some later time.      Courier.SerializeParameters[[@header, DescribeListHeader], s];      Courier.SerializeParameters[[e, DescribeListElement], s];      continue ¬ TRUE;      END;    doList[SerializeListElement];    header ¬ endOfListHeader;  -- end of stream    Courier.SerializeParameters[[@header, DescribeListHeader], s];    END;                 -- PRIVATE PROCEDURES    DecodeAttribute: PROCEDURE [    from: EncodedAttribute, attrs: MailAttributes.Attributes] =    BEGIN    -- caller should NIL out attributes beforehand!!    params: Courier.Parameters ¬ SELECT from.type FROM      MailCourier.replyTo => [@attrs.answerTo, DescribeNameList],      MailCourier.cc => [@attrs.copies, DescribeNameList],      MailCourier.from => [@attrs.from, DescribeNameList],      MailCourier.to => [@attrs.to, DescribeNameList],      MailCourier.inReplyTo => [@attrs.inReplyTo, DescribeString],      MailCourier.comments => [@attrs.note, DescribeString],      MailCourier.bodySize => [@attrs.bodySize, DescribeLongCardinal],      MailCourier.bodyType => [@attrs.bodyType, DescribeLongCardinal],      MailCourier.subject => [@attrs.subject, DescribeString],      ENDCASE => Courier.nullParameters;    IF params=Courier.nullParameters THEN RETURN;    ParametersFromWords[from.words, params !      Courier.Error => {        type: AttributeType ¬ DecodeAttributeType[from.type];	SIGNAL MalformedAttribute[type, from.words];	NilAttribute[type, attrs]; CONTINUE }];    END;	  DecodeAttributeType: PROC [from: EncodedType] RETURNS [type: AttributeType] =    BEGIN    type ¬  SELECT from FROM      MailCourier.replyTo => mailAnswerTo,      MailCourier.cc => mailCopies,      MailCourier.from => mailFrom,      MailCourier.to => mailTo,      MailCourier.inReplyTo => mailInReplyTo,      MailCourier.comments => mailNote,      MailCourier.bodySize => mailBodySize,      MailCourier.bodyType => mailBodyType,      MailCourier.subject => mailSubject,      ENDCASE => ERROR Bug;    END;        EncodeAttribute: PROCEDURE [from: MailAttributes.Attribute, defName: Name]    RETURNS [encoded: EncodedAttribute ¬ [0, NIL]] =    BEGIN    params: Courier.Parameters;    DescribeQNameList: Courier.Description --[notes: Notes]--  =      BEGIN OPEN notes;      p: LONG POINTER TO NameList = noteSize[size: SIZE[NameList]];      noteArrayDescriptor[p, SIZE[NameRecord], LAST[CARDINAL]];      IF BASE[p­] # NIL THEN        FOR i: CARDINAL IN [0..LENGTH[p­]) DO	  saveName: NameRecord ¬ p[i];	  IF p[i].domain = NSString.nullString THEN p[i].domain ¬ defName.domain;	  IF p[i].org = NSString.nullString THEN p[i].org ¬ defName.org;	  noteParameters[@p[i], NSName.DescribeNameRecord];	  p[i] ¬ saveName;	  ENDLOOP;      END;        params ¬ WITH a: from SELECT FROM      mailFrom, mailAnswerTo, mailTo, mailCopies => [@a.value,        IF defName=NIL THEN DescribeNameList ELSE DescribeQNameList],      mailNote, mailInReplyTo, mailSubject => [@a.value, DescribeString],      mailBodySize, mailBodyType => [@a.value, DescribeLongCardinal],      ENDCASE => Courier.nullParameters;    encoded.type ¬ EncodeAttributeType[from.type];    encoded.words ¬ WordsFromParameters[params !      Courier.Error => {SIGNAL IllegalAttribute[from]; CONTINUE}];    END;    EncodeAttributeType: PROCEDURE [from: AttributeType] RETURNS [to: EncodedType] =    BEGIN    to ¬ SELECT from FROM      mailAnswerTo => MailCourier.replyTo,      mailCopies => MailCourier.cc,      mailFrom => MailCourier.from,      mailTo => MailCourier.to,      mailInReplyTo => MailCourier.inReplyTo,      mailNote => MailCourier.comments,      mailBodySize => MailCourier.bodySize,      mailBodyType => MailCourier.bodyType,      --mailSubject,--      ENDCASE => MailCourier.subject;    END;    LookupEnvelopeAttribute: PROC [env: VariantEnvelope, type: EncodedType,    encoding: BOOLEAN ¬ FALSE] RETURNS [params: Courier.Parameters] =    BEGIN OPEN MailCourier;    params ¬ WITH e: env SELECT FROM      transport => SELECT type FROM        postmark => [@e.env.postmark, MailCourier.DescribePostmark],        messageID => [@e.env.messageID, DescribeMessageID],        contentsType => [@e.env.contentsType, DescribeLongCardinal],        contentsSize => [@e.env.contentsSize, DescribeLongCardinal],        originator => (IF encoding AND e.env.originator=NIL THEN	  Courier.nullParameters ELSE [@e.env.originator, DescribeName]),	transportProblem => (IF encoding AND e.env.problem=NIL THEN	  Courier.nullParameters ELSE [@e.env.problem, DescribeProblem]),	ENDCASE => Courier.nullParameters,      inbasket => SELECT type FROM	messageStatus => [@e.env.status, DescribeCardinal],        ENDCASE => Courier.nullParameters,      internal => SELECT type FROM        returnToName => (IF encoding AND e.env.returnToName=NIL THEN	  Courier.nullParameters ELSE [@e.env.returnToName, DescribeName]),        previousRecipients => (IF encoding AND e.env.previousRecipients=NIL THEN	  Courier.nullParameters ELSE [@e.env.previousRecipients, DescribeNameList]),        ENDCASE => 	  LookupEnvelopeAttribute[[transport[@e.env.transport]], type, encoding],      filed => SELECT type FROM	messageStatus =>	  LookupEnvelopeAttribute[[inbasket[@e.env.inbasket]], type, encoding],	ENDCASE =>	  LookupEnvelopeAttribute[[transport[@e.env.transport]], type, encoding],      ENDCASE => Courier.nullParameters;    END;    NilAttribute: PROC [type: AttributeType, attrs: Attributes] =    BEGIN    SELECT type FROM      mailFrom => attrs.from ¬ MailAttributes.nullAttributesRecord.from;      mailAnswerTo => attrs.answerTo ¬ MailAttributes.nullAttributesRecord.answerTo;      mailTo => attrs.to ¬ MailAttributes.nullAttributesRecord.to;      mailCopies => attrs.copies ¬ MailAttributes.nullAttributesRecord.copies;      mailNote => attrs.note ¬ MailAttributes.nullAttributesRecord.note;      mailInReplyTo => attrs.inReplyTo ¬ MailAttributes.nullAttributesRecord.inReplyTo;      mailBodySize => attrs.bodyType ¬ MailAttributes.nullAttributesRecord.bodySize;      mailBodyType => attrs.bodyType ¬ MailAttributes.nullAttributesRecord.bodyType;      mailSubject => attrs.subject ¬ MailAttributes.nullAttributesRecord.subject;      ENDCASE;    END;              StartTrap: PROC =    BEGIN    stubZone ¬ Heap.Create[initial: stubHeapSwapUnit,      maxSize: stubZonePages, increment: stubHeapSwapUnit];    END;                           -- description procs          DescribeCardinal: Courier.Description --[notes: Notes]--  =    BEGIN    [] ¬ notes.noteSize[SIZE[CARDINAL]];    END;      DescribeListElement: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    p: MailCourier.ListElement = noteSize[size: SIZE[MailCourier.ListElementRecord]];    noteParameters[@p.transportEnvelope, MailCourier.DescribeEncodedList];    noteParameters[@p.inbasketEnvelope, MailCourier.DescribeEncodedList];    noteParameters[@p.mailAttributes, MailCourier.DescribeEncodedList];    END;      DescribeListHeader: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    [] ¬ noteSize[size: SIZE[ListHeader]];    END;      DescribeLongCardinal: Courier.Description --[notes: Notes]--  =    BEGIN    notes.noteLongCardinal[notes.noteSize[SIZE[LONG CARDINAL]]];    END;      DescribeMessageID: Courier.Description =    BEGIN OPEN notes;    [] ¬ noteSize[SIZE[MailTransport.MessageID]];    END;      DescribeName: Courier.Description =    BEGIN OPEN notes;    noteDisjointData[noteSize[size: SIZE[Name]], NSName.DescribeNameRecord];    END;    DescribeNameList: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    p: LONG POINTER TO NameList = noteSize[size: SIZE[NameList]];    noteArrayDescriptor[p, SIZE[NameRecord], LAST[CARDINAL]];    IF BASE[p­] # NIL THEN      FOR i: CARDINAL IN [0..LENGTH[p­])        DO noteParameters[@p[i], NSName.DescribeNameRecord]; ENDLOOP;    END;      DescribeProblem: Courier.Description =    BEGIN OPEN notes;    p: LONG POINTER TO MailTransport.Problem =      noteSize[SIZE[MailTransport.Problem]];    noteDisjointData[p, DescribeProblemRecord];    END;     DescribeProblemRecord: Courier.Description =    BEGIN OPEN notes, MailTransport;    p: LONG POINTER TO MailTransport.ProblemRecord =      noteSize[SIZE[MailTransport.ProblemRecord]];    noteParameters[@p.undeliverables, MailCourier.DescribeUndeliverables];    noteParameters[@p.returnedEnvelope, MailCourier.DescribeEncodedList];    END;      DescribeString: Courier.Description = NSString.DescribeString;          -- mainline code    StartTrap[];        END.    
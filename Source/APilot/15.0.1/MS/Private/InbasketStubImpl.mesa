-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- InbasketStubImpl.mesa  -  Inbasket stub implementation-- last edited by Wobber,   6-Apr-84 13:54:31DIRECTORY  Auth USING [IdentityHandle],  Courier USING [Error],  Inbasket,  MailAttributes USING [    AttributesRecord, ClearEnvelope, ClearProperties, Envelope,    MailPropertiesRecord, MalformedAttribute, MessageStatus, Selections, String],  MailCourier USING [    DecodeAttributeList, DecodeVariantEnvelope,    DeserializeListStream, EncodeSelections, EncodedSelections,    FreeEncodedSelections, FreeResults, ListElementProc, GetExportInfo,    ParamRecord, ProcedureType],  MailStubInternal USING [    CallType, CallWithSession, CallWithoutSession, DeleteSession, Session],  MailTransport USING [ContentsType, Error, Location, NameList],  NSDataStream USING [Abort, Aborted, Sink, SourceStream],  NSName USING [Name],  Stream USING [Delete];  InbasketStubImpl: PROGRAM   IMPORTS    Courier, MailAttributes, MailCourier, MailStubInternal,    MailTransport, NSDataStream, Stream  EXPORTS Inbasket =  BEGIN OPEN MSI: MailStubInternal;  -- TYPES    ContentsType: TYPE = MailTransport.ContentsType;  Index: TYPE = Inbasket.Index;  IndexRange: TYPE = Inbasket.IndexRange;  Location: TYPE = MailTransport.Location;  Name: TYPE = NSName.Name;  NameList: TYPE = MailTransport.NameList;  PR: TYPE = MailCourier.ParamRecord;  State: TYPE = Inbasket.State;  String: TYPE = MailAttributes.String;    Session: PUBLIC TYPE = MailStubInternal.Session;      -- ERRORs  ContentsTypeMismatch: PUBLIC ERROR [correctType: ContentsType] = CODE;  InvalidIndex: PUBLIC ERROR [badIndex: Index] = CODE;  iVer: CARDINAL ¬ MailCourier.GetExportInfo[inbasket].stubVersion;  -- EXPORTs to Inbasket interface  -- sessionless procs    Logon: PUBLIC PROC [    identity: Auth.IdentityHandle, inbasket: Name,    cacheCheck: Inbasket.CacheVerifier, allowSharing: BOOLEAN, loc: Location]    RETURNS [session: Session, cacheStatus: Inbasket.CacheStatus] =    BEGIN    callType: MSI.CallType;    p: logon PR ¬ [      logon, iVer, NULL, logon [[NULL, inbasket], cacheCheck, allowSharing]];    callType ¬ IF loc=NIL THEN [directed[inbasket]] ELSE [located[loc]];    session ¬ MSI.CallWithoutSession [@p, callType, identity];    cacheStatus ¬ p.results.cacheStatus;    MailCourier.FreeResults[@p];    END;  MailPoll: PUBLIC PROC [identity: Auth.IdentityHandle,    inbasket: Name, loc: Location] RETURNS [state: State] =    BEGIN    callType: MSI.CallType;    p: inbasketPoll PR ¬ [inbasketPoll, iVer, NULL, inbasketPoll[[NULL, inbasket]]];    callType ¬ IF loc=NIL THEN [directed[inbasket]] ELSE [located[loc]];    [] ¬ MSI.CallWithoutSession [@p, callType, identity];    state ¬ p.results.pollState;    END;    	      -- session procs    ChangeStatus: PUBLIC PROC [    session: Session, range: IndexRange, status: MailAttributes.MessageStatus] =    BEGIN    p: changeStatus PR ¬ [      changeStatus, iVer, NULL, changeStatus[NULL, range, status]];    MSI.CallWithSession [session, @p];    END;    Delete: PUBLIC PROC [session: Session, range: IndexRange] =    BEGIN    p: delete PR ¬ [delete, iVer, NULL, delete[NULL, range]];    MSI.CallWithSession [session, @p];    END;    List: PUBLIC PROC [session: Session, range: IndexRange,    sels: MailAttributes.Selections, proc: Inbasket.ListProc] =    BEGIN    aborted: BOOLEAN ¬ FALSE;    calledBack: BOOLEAN ¬ FALSE;    p: list PR ¬ [list, iVer, NULL,      list[NULL, range, NULL, [sink[[proc[DoList]]]], DoCallback]];    DoCallback: MailCourier.ListElementProc =      BEGIN      pRec: MailAttributes.MailPropertiesRecord;      calledBack ¬ TRUE;      -- no storage allocated for inbasket envelope      MailCourier.DecodeVariantEnvelope[        e.inbasketEnvelope, [inbasket[@pRec.env.inbasket]]];      MailCourier.DecodeVariantEnvelope[        e.transportEnvelope, [transport[@pRec.env.transport]]];      MailCourier.DecodeAttributeList[e.mailAttributes, @pRec.attrs !        MailAttributes.MalformedAttribute => RESUME;	UNWIND => MailAttributes.ClearEnvelope[@pRec.env]];      continue ¬ proc[e.message, @pRec !         UNWIND => MailAttributes.ClearProperties[@pRec]];      MailAttributes.ClearProperties[@pRec];      END;    DoList: PROC [sourceDS: NSDataStream.SourceStream] =      BEGIN      stoppedByClient: BOOLEAN ¬ FALSE;      stoppedByClient ¬ MailCourier.DeserializeListStream[sourceDS, DoCallback !        NSDataStream.Aborted => { aborted ¬ TRUE; CONTINUE };        UNWIND => Stream.Delete[sourceDS ! NSDataStream.Aborted => CONTINUE]];           IF stoppedByClient THEN NSDataStream.Abort[sourceDS];      Stream.Delete[sourceDS ! NSDataStream.Aborted => CONTINUE];      END;  -- of DoList	    p.selections ¬ MailCourier.EncodeSelections[sels];    MSI.CallWithSession [session, @p !      UNWIND => MailCourier.FreeEncodedSelections[p.selections]];    MailCourier.FreeEncodedSelections[p.selections];    -- part of workaround for Filing AR 12077    -- all aborts from server should be ERRORs    IF ~calledBack AND aborted THEN ERROR Courier.Error[returnTimedOut];    END;  -- of List      Locate: PUBLIC PROC [session: Session, status: MailAttributes.MessageStatus]    RETURNS [index: Index] =    BEGIN    p: locate PR ¬ [locate, iVer, NULL, locate[NULL, status]];    MSI.CallWithSession [session, @p];    index ¬ p.results.index;    END;      Logoff: PUBLIC PROC [session: Session]    RETURNS [cacheVerifier: Inbasket.CacheVerifier] =    BEGIN    p: logoff PR ¬ [logoff, iVer, NULL, logoff[NULL]];    MSI.CallWithSession [session, @p !      Courier.Error => CONTINUE;      MailTransport.Error => IF error#[handle[wrongState]] THEN CONTINUE];    cacheVerifier ¬ p.results.cacheVerifier;    MSI.DeleteSession[session];    END;    MailCheck: PUBLIC PROC [session: Session]    RETURNS [state: State, checkAgainWithin: CARDINAL] =    BEGIN    p: mailCheck PR ¬ [mailCheck, iVer, NULL, mailCheck[NULL]];    MSI.CallWithSession [session, @p];    state ¬ p.results.checkState;    checkAgainWithin ¬ p.results.checkAgainWithin;    END;    Retrieve: PUBLIC PROC [    session: Session, message: Index, expectedContentsType: ContentsType,    contents: NSDataStream.Sink, envelope: MailAttributes.Envelope] =    BEGIN    p: retrieve PR ¬ [ retrieve, iVer, NULL,      retrieve[NULL, message, expectedContentsType, [sink[contents]]]];    MSI.CallWithSession [session, @p];    BEGIN ENABLE UNWIND => MailCourier.FreeResults[@p];    -- no storage allocated for inbasket envelope    MailCourier.DecodeVariantEnvelope[      p.results.transportEnv, [transport[@envelope.transport]]];    MailCourier.DecodeVariantEnvelope[      p.results.inbasketEnv, [inbasket[@envelope.inbasket]]];    END;  -- of ENABLE UNWIND    MailCourier.FreeResults[@p];    END;      END.--Modification Log: 3-Feb-83 10:26:57  By: EPW  Add workaround for Filing AR 12077 to RemoteList.11-Mar-83 10:02:11  By: EPW  Extensive stub rework for Raisin. 
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- MailTransportStubImpl.mesa  -  Mail transport stub implementation-- last edited by Wobber:  29-May-84 13:48:05-- last edited by Hankins: 20-Jun-84 12:04:02DIRECTORY  Auth USING [IdentityHandle],  Courier USING [Error],  MailAttributes USING [InbasketEnvelopeRecord],  MailCourier USING [    DecodeVariantEnvelope, EncodedList, EncodeVariantEnvelope, FreeEncodedList,    FreeResults, GetExportInfo, ParamRecord, stubZone, Willingness],  MailStubInternal USING [    CallType, CallWithSession, CallWithoutSession, DeleteSession,    LocalPostingSlot, Session],  MailStubSpecial USING [    ForwardData, ForwardResult, nullAddress,    ServerPollBroadcast, ServerPollCallback],  MailTransport,  MailTransportExtras,  NetworkStream USING [AssignNetworkAddress],  NSDataStream USING [Abort, Aborted, Sink, Source],  NSName USING [ClearName, FreeName, Name],  Router USING [GetDelayToNet],  Stream USING [Delete],  System USING [NetworkAddress, NetworkNumber];  MailTransportStubImpl: MONITOR   IMPORTS Courier, MailCourier, MailStubInternal, MailStubSpecial,     MailTransport, NetworkStream, NSDataStream, NSName, Router, Stream  EXPORTS MailStubSpecial, MailTransport, MailTransportExtras =  BEGIN OPEN MSI: MailStubInternal;    -- TYPES    ContentsType: TYPE = MailTransport.ContentsType;  Envelope: TYPE = MailTransport.Envelope;  Location: TYPE = MailTransport.Location;  Name: TYPE = NSName.Name;  NameList: TYPE = MailTransport.NameList;  PR: TYPE = MailCourier.ParamRecord;  Undeliverables: TYPE = MailTransport.Undeliverables;    nullAddress: System.NetworkAddress = MailStubSpecial.nullAddress;  flushCacheCount: CARDINAL = 8;  zone: UNCOUNTED ZONE = MailCourier.stubZone;  localNet: System.NetworkNumber ¬ NetworkStream.AssignNetworkAddress[].net;  previousAvailableMS: System.NetworkAddress ¬ nullAddress;  previousWillFactor: CARDINAL ¬ LAST[CARDINAL];  postingCacheCount: CARDINAL ¬ 0;  lookForNewPostingSlot: BOOLEAN ¬ FALSE;      sVer: CARDINAL ¬ MailCourier.GetExportInfo[interServer].stubVersion;  tVer: CARDINAL ¬ MailCourier.GetExportInfo[transport].stubVersion;    DeliveryHandle: PUBLIC TYPE = MSI.Session;  ReturnedEnvelope: PUBLIC TYPE = MailCourier.EncodedList;      -- ERRORs   Error: PUBLIC ERROR [error: MailTransport.ErrorRecord] = CODE;  InvalidRecipients: PUBLIC ERROR [nameList: Undeliverables] = CODE;      -- EXPORTs to MailTransport interface    ClearEnvelope: PUBLIC PROC [env: Envelope] =     BEGIN    IF env.postmark.server#NIL THEN      NSName.FreeName[zone, env.postmark.server];    IF env.originator#NIL THEN      NSName.FreeName[zone, env.originator];    IF env.problem#NIL THEN      BEGIN      FreeUndeliverables[env.problem.undeliverables];      FreeReturnedEnvelope[env.problem.returnedEnvelope];      zone.FREE[@env.problem];      END;    END;  DecodeReturnedEnvelope: PUBLIC PROC [    encoding: ReturnedEnvelope, envelope: Envelope] RETURNS [ok: BOOLEAN ¬ FALSE] =    BEGIN ENABLE Courier.Error => CONTINUE;    MailCourier.DecodeVariantEnvelope[encoding, [transport[envelope]]];    ok ¬ TRUE;    END;    EncodeReturnedEnvelope: PUBLIC PROC [envelope: Envelope]    RETURNS [encoding: ReturnedEnvelope] =    { encoding ¬ MailCourier.EncodeVariantEnvelope[[transport[envelope]]] };    FreeReturnedEnvelope: PUBLIC PROC [rEnv: ReturnedEnvelope] =    { MailCourier.FreeEncodedList[rEnv] };      FreeUndeliverables: PUBLIC PROC [undeliverables: Undeliverables] =    BEGIN    IF undeliverables = NIL THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[undeliverables]) DO      NSName.ClearName[zone, @undeliverables[i].name]; ENDLOOP;    zone.FREE[@undeliverables.BASE];    END;  -- posting slot access    AbortBulkStream: PROC [src: NSDataStream.Source] =    BEGIN    WITH s: src SELECT FROM      -- this is a special case ... we must abort the outgoing data stream      stream =>        BEGIN	NSDataStream.Abort[s.stream];	Stream.Delete[s.stream ! NSDataStream.Aborted => CONTINUE];	END;      ENDCASE;    END;  lowThreshold: CARDINAL = 9;  highThreshold: CARDINAL = 6;		-- this is 500 pages on local net  ResponseValue: PROC [hops, willingness: CARDINAL]    RETURNS [CARDINAL] = INLINE { RETURN[hops+willingness] };  Post: PUBLIC PROC [identity: Auth.IdentityHandle, recipients: NameList,    postIfInvalidRecipients, allowDLRecipients: BOOLEAN,    contentsType: ContentsType, contents: NSDataStream.Source]    RETURNS [invalidNames: Undeliverables] =    BEGIN    [undeliverables: invalidNames] ¬ PostDirected[      identity, recipients, postIfInvalidRecipients,      allowDLRecipients, contentsType, contents, NIL];    END;  PostDirected: PUBLIC PROC [identity: Auth.IdentityHandle, recipients: NameList,    postIfInvalidRecipients, allowDLRecipients: BOOLEAN,    contentsType: ContentsType, contents: NSDataStream.Source,    where: LONG POINTER TO System.NetworkAddress]    RETURNS [undeliverables: Undeliverables ¬ NIL,    msgID: MailTransport.MessageID ¬ MailTransport.nullMessageID] =    BEGIN    p: post PR ¬ [ post, tVer, NULL,      post [NULL, recipients, NIL, postIfInvalidRecipients,        allowDLRecipients, contentsType, NIL, [source[contents]]]];    server: System.NetworkAddress;    BEGIN ENABLE       UNWIND => IF p.contents.state=source THEN AbortBulkStream[contents];    IF where#NIL THEN server ¬ where­    ELSE      BEGIN		-- non-directed call ...      bestResponse: CARDINAL;      lookForBetter: BOOLEAN;      [server, bestResponse, lookForBetter] ¬ GetPreferredAddr[];        -- try to poll an existing addr (local machine if on a server)      IF server # nullAddress AND NOT lookForBetter THEN        BEGIN ENABLE Error, Courier.Error => { server ¬ nullAddress; CONTINUE };        pt: serverPoll PR ¬ [serverPoll, tVer, NULL, serverPoll [NULL]];        thisResponse: CARDINAL ¬ 0;	[] ¬ MSI.CallWithoutSession [@pt, [addressed[@server]], identity];        thisResponse ¬ ResponseValue[	  Router.GetDelayToNet[server.net], pt.results.willingness];	IF thisResponse > lowThreshold THEN	  server ¬ nullAddress ELSE bestResponse ¬ thisResponse;	   -- if the server is not extremely willing or perhaps a distance away.	   -- will want to broadcast for new posting slot        MailCourier.FreeResults[@pt];        END;          IF server=nullAddress OR lookForBetter THEN        BEGIN        bestResponseNet: CARDINAL ¬ 0;  -- deltaHops not used if lookForBetter 	InspectPollResponse: MailStubSpecial.ServerPollCallback =          BEGIN          -- ** would like a better metric to determine which is best.	  -- hops is not really good 'cause not true delay.	  deltaHops: CARDINAL ¬ 0;	  hopsThisResponse: CARDINAL ¬ Router.GetDelayToNet[addr.net];	  responseValue: CARDINAL ¬ ResponseValue[hopsThisResponse, willingness];	     -- search for something better than we already have.	  IF responseValue < bestResponse THEN {	    server ¬ addr; bestResponse ¬ responseValue;	    lookForBetter ¬ FALSE; bestResponseNet ¬ hopsThisResponse };	  -- determine if we should halt the broadcast          deltaHops ¬ IF hopsThisResponse > bestResponseNet THEN	    hopsThisResponse-bestResponseNet ELSE 0;	  RETURN[lookForBetter OR (bestResponse > highThreshold+deltaHops)];	  END;	-- proc. InspectPollResponse                MailStubSpecial.ServerPollBroadcast[identity, InspectPollResponse];        END;      SetPreferredAddr[server, bestResponse];      END;    IF server=nullAddress THEN ERROR Error[[location[noMailDropUp]]];    [] ¬ MSI.CallWithoutSession[@p, [addressed[@server]], identity !      MailTransport.Error =>        IF error.errorType=service THEN ResetPreferredAddr[]];    undeliverables ¬ p.results.invalidNames;    msgID ¬ p.results.msgID;    END;   -- of enable UNWIND    END;  -- Access to 'delivery slots'.  -- DeliveryHandle ops    Acknowledge: PUBLIC PROC [    handle: DeliveryHandle, reply: MailTransport.DeliveryAckType] =    BEGIN    p: acknowledge PR ¬ [acknowledge, tVer, NULL, acknowledge [NULL, reply]];    MailStubInternal.CallWithSession [handle, @p];    END;  BeginDelivery: PUBLIC PROC [identity: Auth.IdentityHandle,    deliverySlot: Name, loc: Location] RETURNS [handle: DeliveryHandle] =    BEGIN    callType: MSI.CallType;    p: beginDelivery PR ¬ [beginDelivery, tVer, NULL,      beginDelivery [[NULL, deliverySlot]]];    callType ¬ IF loc=NIL THEN [directed[deliverySlot]] ELSE [located[loc]];    handle ¬ MSI.CallWithoutSession[@p, callType, identity];    MailCourier.FreeResults[@p];    END;    DeliverContent: PUBLIC PROC [    handle: DeliveryHandle, contents: NSDataStream.Sink] =    BEGIN    p: deliverContent PR ¬ [deliverContent, tVer, NULL,      deliverContent [NULL, [sink[contents]]]];    MSI.CallWithSession [handle, @p];    END;    DeliverEnvelope: PUBLIC PROC [handle: DeliveryHandle, envelope: Envelope]    RETURNS [empty: BOOLEAN] =    BEGIN    p: deliverEnvelope PR ¬ [deliverEnvelope, tVer, NULL, deliverEnvelope [NULL]];    MSI.CallWithSession [handle, @p];    MailCourier.DecodeVariantEnvelope[p.results.envelope, [transport[envelope]] !      UNWIND => MailCourier.FreeResults[@p]];    empty ¬ p.results.empty;    MailCourier.FreeResults[@p];    END;    EndDelivery: PUBLIC PROC [handle: DeliveryHandle] =    BEGIN    p: endDelivery PR ¬ [endDelivery, tVer, NULL, endDelivery [NULL]];    MSI.CallWithSession [handle, @p !      Courier.Error => CONTINUE;      Error => IF error#[handle[wrongState]] THEN CONTINUE];    MSI.DeleteSession[handle];    END;    Poll: PUBLIC PROC [identity: Auth.IdentityHandle, deliverySlot: Name, loc: Location]    RETURNS [mailExists, isPrimary: BOOLEAN] =    BEGIN    callType: MSI.CallType;    p: deliverySlotPoll PR ¬ [deliverySlotPoll, tVer, NULL,      deliverySlotPoll [[NULL, deliverySlot]]];    callType ¬ IF loc=NIL THEN [directed[deliverySlot]] ELSE [located[loc]];    [] ¬ MSI.CallWithoutSession [@p, callType, identity];    mailExists ¬ p.results.mailExists;    isPrimary ¬ p.results.isPrimary;    END;    -- exports to MailStubSpecial:    --inter-server protocol back door  ForwardMsg: PUBLIC PROC [    identity: Auth.IdentityHandle, data: MailStubSpecial.ForwardData]    RETURNS [rc: MailStubSpecial.ForwardResult] =    BEGIN ENABLE Error => {      rc ¬ WITH e: error SELECT FROM        authentication => credsRefresh,        service =>	  SELECT e.problem FROM            serviceFull => serverTooBusy,	    serviceUnavailable => serverNotAccepting,            mediumFull => mediumTooFull,	    ENDCASE => other,	transfer => abortedByClient,	undefined => formatError,	ENDCASE => other;      CONTINUE };    iEnv: MailAttributes.InbasketEnvelopeRecord ¬ [data.status];    p: forwardMsg PR ¬ [forwardMsg, sVer, NULL,      forwardMsg [ NULL, data.myName, data.destName,        data.size, data.created, data.id,	MailCourier.EncodeVariantEnvelope[[inbasket[@iEnv]]],        [source[data.source]]]];    p.results.forwardResult ¬ done;   -- because old protocol doesn't return result    [] ¬ MSI.CallWithoutSession[      @p, [addressed[@data.where]], identity !      UNWIND => {        IF p.contents.state=source THEN AbortBulkStream[data.source];        MailCourier.FreeEncodedList[p.inbasketEnv] }];    MailCourier.FreeEncodedList[p.inbasketEnv];    rc ¬ p.results.forwardResult;    END;  QueryUp: PUBLIC PROC [whatServer: NSName.Name,    where: System.NetworkAddress] RETURNS [up: BOOLEAN] =    BEGIN    p: queryUp PR ¬ [queryUp, sVer, NULL, queryUp [whatServer]];    [] ¬ MSI.CallWithoutSession [@p, [addressed[@where]]];    up ¬ p.results.upAndAccepting;    END;  SendCacheFlush: PUBLIC PROC [where: System.NetworkAddress, who: Name] =    BEGIN    p: cacheFlush PR ¬ [cacheFlush, sVer, NULL, cacheFlush [who]];    [] ¬ MSI.CallWithoutSession [@p, [addressed[@where]]];    END; -- ENTRY PROCS    GetPostingSlot: PUBLIC PROC RETURNS [System.NetworkAddress] =    { RETURN[GetPreferredAddr[].addr] };      SetPostingSlot: PUBLIC PROC [addr: System.NetworkAddress] =    { SetPreferredAddr[addr] };  GetPreferredAddr: ENTRY PROC RETURNS [    addr: System.NetworkAddress, val: CARDINAL ¬ LAST[CARDINAL],    findBetterAddr: BOOLEAN ¬ lookForNewPostingSlot] =    BEGIN    -- if a non-local net ... flush cache after n posts.    -- val value is always LAST[] if ~findBetterAddr    val ¬ LAST[CARDINAL];    IF previousAvailableMS#nullAddress AND      (previousAvailableMS.net=localNet OR        (postingCacheCount ¬ postingCacheCount+1) # flushCacheCount) THEN	  { addr ¬ previousAvailableMS;	    IF findBetterAddr THEN val ¬ previousWillFactor }    ELSE addr ¬ MSI.LocalPostingSlot[];    END;      ResetPreferredAddr: ENTRY PROC = {lookForNewPostingSlot ¬ TRUE};  SetPreferredAddr: ENTRY PROC [    addr: System.NetworkAddress, val: CARDINAL ¬ LAST[CARDINAL]] =    BEGIN    IF addr#previousAvailableMS THEN postingCacheCount ¬ 0;    previousAvailableMS ¬ addr;    previousWillFactor ¬ val;    lookForNewPostingSlot ¬ FALSE;    END;  END.  
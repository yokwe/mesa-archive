-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- MailCourierDescriptions.mesa-- Description Routines for Mailing Courier Programs-- Last revised by Wobber:  29-May-84 10:13:53-- last edited by Hankins:  27-Jun-84 16:33:15	fix deliverContent arg descrDIRECTORY  Auth USING [DescribeCredentials, DescribeVerifier, Verifier],  Courier USING [    Description, Error, Free, Handle, NoSuchProcedureNumber, VersionRange],  MailCourier,  MailStubSpecial USING [MailboxPropertyRecord, TestMode],  MailTransport USING [MessageID, Postmark, Undeliverables, UndeliveredName],  NSAddr USING [DescribeAddress],  NSDataStream USING [DescribeTicket],  NSName USING [DescribeNameRecord, Name, NameRecord],  System USING [SocketNumber];MailCourierDescriptions: MONITOR  IMPORTS Auth, Courier, MailCourier, NSAddr, NSDataStream, NSName  EXPORTS MailCourier, MailStubSpecial =  BEGIN        PR: TYPE = MailCourier.ParamRecord;  RR: TYPE = MailCourier.ResultRecord;  CredsAndMbx: TYPE = MailCourier.CredsAndMbx;  EncodedAttribute: TYPE = MailCourier.EncodedAttribute;  EncodedList: TYPE = MailCourier.EncodedList;  ErrorArgumentRecord: TYPE = MailCourier.ErrorArgumentRecord;  ErrorType: TYPE = MailCourier.ErrorType;  ProcType: TYPE = MailCourier.ProcedureType;  ProtocolSession: TYPE = MailCourier.ProtocolSession;  ProtocolType: TYPE = MailCourier.ProtocolType;  TestMode: TYPE = MailStubSpecial.TestMode;    AuthType: TYPE = {none, creds, credsAndMbx, session};  ErrorDesc: TYPE = LONG DESCRIPTOR FOR ARRAY OF ErrorType;  ProcInfo: TYPE = MACHINE DEPENDENT RECORD [    authType: AuthType, argSize: [0..64), resSize: [0..64)];      mailTransportProgram: CARDINAL = 17;  inbasketProgram: CARDINAL = 18;  interServerProgram: CARDINAL = 126;  testProgramOffset: CARDINAL = 1000;    transportVersions: Courier.VersionRange = [1,4];  inbasketVersions: Courier.VersionRange = [1,1];  interserverVersions: Courier.VersionRange = [1,2];  intermediateTransportVersion: CARDINAL = 3;  defaultMailCourierSocket: System.SocketNumber = LOOPHOLE[26];  testMailCourierSocket: System.SocketNumber = LOOPHOLE[27];    testMode: MailStubSpecial.TestMode ¬ off;  mailCourierSocket: System.SocketNumber ¬ defaultMailCourierSocket;    Bug: ERROR = CODE;    inbasketErrors: ARRAY [0..9) OF ErrorType ¬ [    access, authentication, connection, contentsType,    index, session, service, transfer, undefined];      interServerErrors: ARRAY [0..4) OF ErrorType ¬ [    authentication, service, transfer, undefined];      transportErrors: ARRAY [0..8) OF ErrorType ¬ [    access, authentication, connection, invalidRecipients,    service, transfer, undefined, session];      nullInfo: ProcInfo = [none, 0,0];  procArray: ARRAY ProcType OF ProcInfo ¬ [    [none, SIZE[PR.serverPoll], SIZE[RR.serverPoll]],    [creds, SIZE[PR.post], SIZE[RR.post]],    [credsAndMbx, SIZE[PR.beginDelivery], SIZE[RR.beginDelivery]],    [session, SIZE[PR.acknowledge], SIZE[RR.acknowledge]],    [session, SIZE[PR.deliverContent], SIZE[RR.deliverContent]],    [session, SIZE[PR.deliverEnvelope], SIZE[RR.deliverEnvelope]],    [session, SIZE[PR.endDelivery], SIZE[RR.endDelivery]],    [credsAndMbx, SIZE[PR.deliverySlotPoll], SIZE[RR.deliverySlotPoll]],    nullInfo, nullInfo, nullInfo, nullInfo, nullInfo, nullInfo, nullInfo, nullInfo,    [session, SIZE[PR.changeStatus], SIZE[RR.changeStatus]],    [session, SIZE[PR.delete], SIZE[RR.delete]],    [session, SIZE[PR.list], SIZE[RR.list]],    [session, SIZE[PR.locate], SIZE[RR.locate]],    [session, SIZE[PR.logoff], SIZE[RR.logoff]],    [credsAndMbx, SIZE[PR.logon], SIZE[RR.logon]],    [session, SIZE[PR.mailCheck], SIZE[RR.mailCheck]],    [credsAndMbx, SIZE[PR.inbasketPoll], SIZE[RR.inbasketPoll]],    [session, SIZE[PR.retrieve], SIZE[RR.retrieve]],    nullInfo, nullInfo, nullInfo, nullInfo, nullInfo, nullInfo, nullInfo,    [none, SIZE[PR.queryUp], SIZE[RR.queryUp]],    [none, SIZE[PR.cacheFlush], SIZE[RR.cacheFlush]],    [creds, SIZE[PR.forwardMsg], SIZE[RR.forwardMsg]]];      FreeResults: PUBLIC PROC [loc: MailCourier.ParamPtr] =    BEGIN    Courier.Free[[loc, DescribeResults], MailCourier.stubZone];    END;      GetError: PUBLIC PROC [error: ErrorType, proc: ProcType]    RETURNS [number: CARDINAL, desc: Courier.Description] =    BEGIN    protocol: ProtocolType ¬ MailCourier.ProtocolFromProc[proc];    errors: ErrorDesc ¬ SELECT protocol FROM      inbasket => DESCRIPTOR[inbasketErrors],      transport => DESCRIPTOR[transportErrors],      ENDCASE => DESCRIPTOR[interServerErrors];    FOR i: CARDINAL IN [0..LENGTH[errors]) DO      IF errors[i]=error THEN        RETURN[i, SELECT error FROM          contentsType => DescribeTypeMismatch,          invalidRecipients => DescribeUndeliverables,          ENDCASE => DescribeOneWord];      ENDLOOP;    ERROR Bug;    END;      GetExportInfo: PUBLIC PROC [type: ProtocolType] RETURNS [stubVersion: CARDINAL,    prog: LONG CARDINAL, versionRange: Courier.VersionRange] =    BEGIN    prog ¬ GetProgram[VAL[MailCourier.protocolBase*type.ORD]];    SELECT type FROM      interServer => {        versionRange ¬ interserverVersions;	stubVersion ¬ interserverVersions.high };      inbasket => {        versionRange ¬ inbasketVersions;	stubVersion ¬ inbasketVersions.high };      transport => {        versionRange ¬ transportVersions;	stubVersion ¬ transportVersions.high };      ENDCASE => ERROR;    END;      GetProgram: PUBLIC PROC [type: ProcType] RETURNS [prog: LONG CARDINAL] =    BEGIN    prog ¬ SELECT MailCourier.ProtocolFromProc[type] FROM      interServer => interServerProgram,      inbasket => inbasketProgram,      transport => mailTransportProgram,      ENDCASE => ERROR;    prog ¬ prog + (testMode.ORD*testProgramOffset);    END;  GetSocket: PUBLIC PROC RETURNS [System.SocketNumber] =   { RETURN[mailCourierSocket] };    LookupErrorType: PUBLIC PROC [errorNumber: CARDINAL, proc: ProcType]    RETURNS [type: ErrorType, desc: Courier.Description] =    BEGIN    errors: ErrorDesc ¬ SELECT MailCourier.ProtocolFromProc[proc] FROM      inbasket => DESCRIPTOR[inbasketErrors],      transport => DESCRIPTOR[transportErrors],      ENDCASE => DESCRIPTOR[interServerErrors];    IF errorNumber<LENGTH[errors] THEN      BEGIN      type ¬ errors[errorNumber];      desc ¬ SELECT type FROM        contentsType => DescribeTypeMismatch,        invalidRecipients => DescribeUndeliverables,        ENDCASE => DescribeOneWord;      END    ELSE Courier.Error[unknownErrorInRemoteProcedure];    END;  LookupProcedure: PUBLIC PROC [procNumber: CARDINAL, cH: Courier.Handle]    RETURNS [type: ProcType] =      BEGIN    prog: LONG CARDINAL ¬ cH.programNumber - (testMode.ORD*testProgramOffset);    SELECT prog FROM      mailTransportProgram => {         type ¬ VAL[procNumber+MailCourier.tBase];	IF type IN [serverPoll..deliverySlotPoll] THEN RETURN };      inbasketProgram => {        type ¬ VAL[procNumber+MailCourier.iBase];	IF type IN [changeStatus..retrieve] THEN RETURN };      interServerProgram => {        type ¬ VAL[procNumber+MailCourier.sBase];	IF type IN [queryUp..forwardMsg] THEN RETURN };      ENDCASE;    ERROR Courier.NoSuchProcedureNumber;    END;      SetTestMode: PUBLIC ENTRY PROC [type: TestMode] =     BEGIN    IF testMode#off THEN mailCourierSocket ¬ testMailCourierSocket;    testMode ¬ type;    END;  TestModeActive: PUBLIC ENTRY PROC RETURNS[TestMode] = {RETURN[testMode]};      -- DESCRIPTION ROUTINES    -- export to MailStubSpecial    MailboxPropertyDescription: PUBLIC Courier.Description =    BEGIN OPEN notes;    maxMailboxes: CARDINAL = 5;    p: LONG POINTER TO MailStubSpecial.MailboxPropertyRecord =      noteSize[SIZE[MailStubSpecial.MailboxPropertyRecord]];    noteLongCardinal[@LOOPHOLE[p.timestamp, LONG CARDINAL]];    noteArrayDescriptor[@p.servers, SIZE[NSName.NameRecord], maxMailboxes];    IF BASE[p.servers] # NIL THEN      FOR i: CARDINAL IN [0..LENGTH[p.servers]) DO        noteParameters[@p.servers[i], NSName.DescribeNameRecord];        ENDLOOP;     END;  DescribeEncodedList: PUBLIC Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    p: LONG POINTER TO EncodedList = noteSize[SIZE[EncodedList]];    noteArrayDescriptor[p, SIZE[EncodedAttribute], LAST[CARDINAL]];    IF BASE[p­] # NIL THEN      FOR i: CARDINAL IN [0..LENGTH[p­]) DO        noteLongCardinal[site: @p[i].type];        noteArrayDescriptor[@p[i].words, SIZE[UNSPECIFIED], LAST[CARDINAL]];	ENDLOOP;    END;      DescribeOneWord: PUBLIC Courier.Description =    BEGIN OPEN notes;    p: LONG POINTER TO CARDINAL = notes.noteSize [SIZE [CARDINAL]];    END;      DescribePostmark: PUBLIC Courier.Description =    BEGIN OPEN notes;    p: LONG POINTER TO MailTransport.Postmark =      noteSize[SIZE[MailTransport.Postmark]];    noteDisjointData[@p.server, NSName.DescribeNameRecord];    noteLongCardinal[@LOOPHOLE[p.time, LONG CARDINAL]];    END;      DescribeTicket: Courier.Description --[notes: Notes]--  =    BEGIN    p: LONG POINTER TO ticket MailCourier.BulkDataRecord =       notes.noteSize [SIZE [ticket MailCourier.BulkDataRecord]];    notes.noteDeadSpace [@p.object, SIZE[MailCourier.BulkDataState]];    notes.noteParameters [@p.ticket, NSDataStream.DescribeTicket];    END;      DescribeTypeMismatch: Courier.Description --[notes: Notes]--  =    BEGIN    p: LONG POINTER TO contentsType ErrorArgumentRecord =       notes.noteSize [SIZE [contentsType ErrorArgumentRecord]];    notes.noteLongCardinal [@p.correctType];    END;      DescribeUndeliverables: PUBLIC Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    p: LONG POINTER TO MailTransport.Undeliverables =      notes.noteSize [SIZE [MailTransport.Undeliverables]];    notes.noteArrayDescriptor[p, SIZE[MailTransport.UndeliveredName], LAST[CARDINAL]];    IF BASE [p­] # NIL THEN      FOR i: CARDINAL IN [0..LENGTH [p­]) DO        notes.noteParameters[@p[i].name, NSName.DescribeNameRecord];      ENDLOOP;    END;      DescribeArguments: PUBLIC Courier.Description =    BEGIN    deadSpace: CARDINAL ¬ 0;    params: MailCourier.ParamPtr = notes.noteSize [SIZE[PR]];    info: ProcInfo ¬ procArray[params.type];    notes.noteDeadSpace[params, SIZE[CARDINAL] + SIZE[ProcType] + SIZE[RR]];    SELECT info.authType FROM      session =>        BEGIN        p: LONG POINTER TO ProtocolSession ¬ LOOPHOLE[@params.var];	notes.noteParameters [@p.verifier, Auth.DescribeVerifier];        END;      creds, credsAndMbx =>        BEGIN        p: LONG POINTER TO CredsAndMbx ¬ LOOPHOLE[@params.var];	notes.noteParameters [@p.creds.c, Auth.DescribeCredentials];	notes.noteParameters [@p.creds.v, Auth.DescribeVerifier];	IF info.authType=credsAndMbx THEN	  notes.noteDisjointData [@p.name, NSName.DescribeNameRecord];        END;      ENDCASE;    -- descriptions for procedures with other NOTEable things    WITH p: params SELECT params.type FROM      post =>        BEGIN        notes.noteArrayDescriptor [          @p.recipients, SIZE [NSName.NameRecord], LAST[CARDINAL]];        IF p.recipients # NIL THEN          FOR i: CARDINAL IN [0..LENGTH [p.recipients]) DO            notes.noteParameters [@p.recipients[i], NSName.DescribeNameRecord];            ENDLOOP;        IF params.version < intermediateTransportVersion THEN	  BEGIN	  notes.noteDisjointData[@p.returnToName, NSName.DescribeNameRecord];	  -- note postIfInvalidNames (BOOLEAN) 	  notes.noteDeadSpace[@p.allowDLRecipients, SIZE[BOOLEAN]];          notes.noteLongCardinal [@p.contentsType];          notes.noteDeadSpace [@p.envOptions, SIZE[MailCourier.EncodedList]]	  END	ELSE	  BEGIN	  notes.noteDeadSpace[@p.returnToName, SIZE[NSName.Name]];	  -- note postIfInvalidNames (BOOLEAN)          -- note allowDLRecipients (BOOLEAN)          notes.noteLongCardinal [@p.contentsType];          notes.noteParameters [@p.envOptions, DescribeEncodedList];          END;        notes.noteParameters [@p.contents, DescribeTicket];        END;      serverPoll =>        BEGIN        notes.noteParameters [@p.authPair.c, Auth.DescribeCredentials];        IF params.version < intermediateTransportVersion THEN	  deadSpace ¬ SIZE[Auth.Verifier]	ELSE	  notes.noteParameters [@p.authPair.v, Auth.DescribeVerifier];	END;      deliverContent => notes.noteParameters [@p.contents, DescribeTicket];                  list =>        BEGIN        -- note range        -- note selections.transportEnvelope (BOOLEAN)        -- note selections.inbasketEnvelope (BOOLEAN)        notes.noteArrayDescriptor [@p.selections.mailAttributes,           SIZE [MailCourier.EncodedType --LongCardinal--], LAST[CARDINAL]];        IF BASE [p.selections.mailAttributes] # NIL THEN          FOR i: CARDINAL IN [0..LENGTH [p.selections.mailAttributes]) DO          notes.noteLongCardinal [@p.selections.mailAttributes[i]];          ENDLOOP;        notes.noteParameters [@p.listing, DescribeTicket];	deadSpace ¬ SIZE[MailCourier.ListElementProc];	END;      retrieve =>        BEGIN        -- note message (Inbasket.Index)        notes.noteLongCardinal [@p.expectedContentsType];        notes.noteParameters [@p.contents, DescribeTicket];        END;	      -- server to server procs      queryUp =>        BEGIN	IF params.version#interserverVersions.high THEN	  deadSpace ¬ SIZE[NSName.Name]	ELSE	  notes.noteDisjointData[@p.destService, NSName.DescribeNameRecord]	END;      cacheFlush =>        notes.noteDisjointData[@p.name, NSName.DescribeNameRecord];      forwardMsg =>        BEGIN        notes.noteDisjointData[@p.sendingService, NSName.DescribeNameRecord];        IF params.version#interserverVersions.high THEN	  BEGIN	  notes.noteDeadSpace[@p.destService, SIZE[NSName.Name]];	  notes.noteDeadSpace[@p.size, SIZE[LONG CARDINAL]];          END	ELSE	  BEGIN	  notes.noteDisjointData[@p.destService, NSName.DescribeNameRecord];          notes.noteLongCardinal[@p.size];	  END;	notes.noteDisjointData[	  @p.createPostmark.server, NSName.DescribeNameRecord];        notes.noteLongCardinal[@LOOPHOLE[p.createPostmark.time, LONG CARDINAL]];        notes.noteParameters [@p.inbasketEnv, DescribeEncodedList];        notes.noteParameters [@p.contents, DescribeTicket];	END;      ENDCASE;    info.argSize ¬ info.argSize - deadSpace;    IF info.argSize#SIZE[PR] THEN      notes.noteDeadSpace[params+info.argSize, SIZE[PR]-info.argSize];    END;  DescribeResults: PUBLIC Courier.Description =    BEGIN    deadSpace: CARDINAL ¬ 0;    ovSize: CARDINAL = SIZE[CARDINAL]+SIZE[ProcType];    resultsSize: CARDINAL = ovSize+SIZE[RR];    params: MailCourier.ParamPtr = notes.noteSize [resultsSize];    info: ProcInfo ¬ procArray[params.type];    -- descriptions for procedures with other NOTEable things    notes.noteDeadSpace[params, SIZE[CARDINAL] + SIZE[ProcType]];    SELECT params.type FROM      logon, beginDelivery =>        BEGIN	notes.noteParameters [	  @params.results.session.verifier, Auth.DescribeVerifier];	END;      post =>        BEGIN        notes.noteParameters [@params.results.invalidNames, DescribeUndeliverables];	IF params.version < transportVersions.high THEN	  deadSpace ¬ SIZE[MailTransport.MessageID];        END;      deliverEnvelope =>        BEGIN        notes.noteParameters [@params.results.envelope, DescribeEncodedList];	END;      serverPoll =>        BEGIN        notes.noteParameters [@params.results.address, NSAddr.DescribeAddress];        IF params.version < intermediateTransportVersion THEN	  deadSpace ¬ (SIZE[Auth.Verifier]+SIZE[NSName.Name])	ELSE          BEGIN	  notes.noteParameters [	    @params.results.returnVerifier, Auth.DescribeVerifier];	  notes.noteDisjointData [	    @params.results.serverName, NSName.DescribeNameRecord];	  END;	END;      retrieve =>        BEGIN        notes.noteParameters [@params.results.transportEnv, DescribeEncodedList];        notes.noteParameters [@params.results.inbasketEnv, DescribeEncodedList];	END;      forwardMsg =>        IF params.version < interserverVersions.high THEN	  deadSpace ¬ SIZE[CARDINAL];      ENDCASE;    info.resSize ¬ ovSize + info.resSize - deadSpace;    IF info.resSize#resultsSize THEN      notes.noteDeadSpace[params+info.resSize, resultsSize-info.resSize];    END;  END.         
-- File: MailStreamImpl.mesa - last edit:-- AOF                 19-Jan-87  9:32:55-- Wobber              20-Jun-84 12:02:59-- Hankins             23-Mar-83 10:11:49-- Copyright (C) 1983, 1984 , 1987, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Auth USING [GetIdentityDetails, IdentityHandle],  Courier USING [DeserializeParameters, Error, SerializeParameters],  Environment USING [Block, Byte],  Inbasket USING [Index, Retrieve, Session],  Inline USING [HighHalf, LongNumber, LowHalf],  MailAttributes USING [    AttributeList, Attributes, ClearEnvelope, EnvelopeRecord, IllegalAttribute,    MalformedAttribute, SerialStream, SerialStreamDirection],  MailCourier USING [    stubZone, DecodeAttributeList, DescribeEncodedList, EncodeAttributeList,    EncodedList, FreeEncodedList],  MailStream USING [StreamProc],  MailTransport USING [ctSerializedFile, Error, NameList, Post, Undeliverables],  NSDataStream USING [Abort, Aborted, SinkStream, SourceStream],  NSName USING [Name],  Stream USING [CompletionCode, defaultObject, Delete, DeleteProcedure,    EndOfStream, GetBlock, GetByte, GetWord, GetProcedure, Handle,    InvalidOperation, Object, PutBlock, PutByte, PutProcedure, PutWord,    SendNow, SendNowProcedure, SetInputOptions];MailStreamImpl: PROGRAM  IMPORTS    Auth, Courier, Inbasket, Inline, MailAttributes, MailCourier,    MailTransport, NSDataStream, Stream  EXPORTS MailStream, MailAttributes =  BEGIN  Attributes: TYPE = MailAttributes.Attributes;  AttributeList: TYPE = MailAttributes.AttributeList;  SerialStream: TYPE = MailAttributes.SerialStream;  SerialStreamDirection: TYPE = MailAttributes.SerialStreamDirection;      -- types  Handle: TYPE = LONG POINTER TO SerialStreamObject;  ReceiveHandle: TYPE = LONG POINTER TO receive SerialStreamObject;  SendHandle: TYPE = LONG POINTER TO send SerialStreamObject;  StreamProc: TYPE = MailStream.StreamProc;    SerialStreamObject: TYPE = RECORD [    userStreamObject: Stream.Object ¬ Stream.defaultObject,    attributesDone: BOOLEAN ¬ FALSE,    realStream: Stream.Handle,    variant: SELECT direction: SerialStreamDirection FROM      send => [        leftoverPresent: BOOLEAN ¬ FALSE,        leftoverByte: Environment.Byte ¬ NULL],      receive => [	lastSegment: BOOLEAN ¬ FALSE,        status: Stream.CompletionCode ¬ normal,        bytesLeftInSegment: CARDINAL ¬ 0 ],      ENDCASE ];	-- constantsserializedFileVersion: LONG CARDINAL = 2;zone: UNCOUNTED ZONE = MailCourier.stubZone;    -- errors:FormatError: PUBLIC ERROR = CODE;NotASerializedFile: PUBLIC ERROR = CODE;     -- public procs to MailStreamSend: PUBLIC PROC [  identity: Auth.IdentityHandle, recipients: MailTransport.NameList,  postIfInvalidRecipients, allowDLRecipients: BOOLEAN, attributes: AttributeList,  sendProc: StreamProc] RETURNS [invalidNames: MailTransport.Undeliverables] =  BEGIN  defaultName: NSName.Name;  aborted, formatError: BOOLEAN ¬ FALSE;  SendData: PROC [sinkStream: NSDataStream.SinkStream] =    BEGIN    stream: SerialStream ¬ MakeSerializer[sinkStream, send];    BEGIN ENABLE {      NSDataStream.Aborted => CONTINUE;      NotASerializedFile, MailAttributes.IllegalAttribute => {        formatError ¬ TRUE; CONTINUE };      UNWIND => Stream.Delete[stream ! NSDataStream.Aborted => CONTINUE] };    -- the third argument to SendAttributes is a 'default' name.    -- if any of the names in 'attributes' are not fully qualified,    -- then qualification will be attained using this default.    SendAttributes[stream, attributes, defaultName];    IF NOT (aborted ¬ sendProc[stream]) THEN Stream.SendNow[stream];    END;	-- 'Enabled'    IF aborted OR formatError THEN NSDataStream.Abort[sinkStream];    Stream.Delete[stream ! NSDataStream.Aborted => CONTINUE];    -- deletes 'real' stream.    END;  [name: defaultName] ¬ Auth.GetIdentityDetails[identity];  invalidNames ¬ MailTransport.Post[    identity, recipients, postIfInvalidRecipients, allowDLRecipients,     MailTransport.ctSerializedFile, [proc[SendData]] !    MailTransport.Error => IF formatError THEN ERROR FormatError];  END;     Retrieve: PUBLIC PROC [session: Inbasket.Session,  message: Inbasket.Index, retrieveProc: StreamProc] =  BEGIN  aborted, formatError: BOOLEAN ¬ FALSE;  envRec: MailAttributes.EnvelopeRecord;  RetrieveData: PROCEDURE [sourceStream: NSDataStream.SourceStream] =    BEGIN    stream: SerialStream ¬ MakeSerializer[sourceStream, receive];    BEGIN    ENABLE {      NSDataStream.Aborted => CONTINUE;      NotASerializedFile, MailAttributes.MalformedAttribute => {        formatError ¬ TRUE; CONTINUE };      UNWIND => Stream.Delete[stream ! NSDataStream.Aborted => CONTINUE] };    aborted ¬ retrieveProc[stream];    END;	-- 'Enabled'    -- this Stream.Delete kills underlying data stream    IF aborted OR formatError THEN NSDataStream.Abort[sourceStream];    Stream.Delete[stream ! NSDataStream.Aborted => CONTINUE];    END;  Inbasket.Retrieve[session, message, MailTransport.ctSerializedFile,     [proc [RetrieveData]], @envRec];  MailAttributes.ClearEnvelope[@envRec];  END;    -- public procs to MailAttributes  MakeSerializer: PUBLIC PROC [source: Stream.Handle, direction: SerialStreamDirection]  RETURNS [SerialStream] =   BEGIN  myS: Handle ¬ zone.NEW[SerialStreamObject];  myS.realStream ¬ source;  myS.userStreamObject.delete ¬ DeleteProc;  IF direction=send THEN    BEGIN    myS.userStreamObject.put ¬ PutProc;    myS.userStreamObject.sendNow ¬ SendNowProc;    myS.variant ¬ send [];    END  ELSE    BEGIN    myS.userStreamObject.get ¬ GetProc;    myS.variant ¬ receive [];    END;  myS.realStream ¬ source;  -- set 'signalEndOfStream':     Stream.SetInputOptions[source, [FALSE, FALSE, FALSE, FALSE, TRUE, FALSE]];  RETURN[@myS.userStreamObject];  END;		-- proc. MakeSerializer    ReceiveAttributes: PUBLIC PROC [source: SerialStream, attributes: Attributes] =  BEGIN OPEN h: LOOPHOLE[source, Handle];    encodedList: MailCourier.EncodedList;  IF h.attributesDone OR h.direction#receive THEN ERROR Stream.InvalidOperation;  [] ¬ DeserializeLongCardinal[h.realStream];  --++Jody 19-Jan-87  9:31:25  Courier.DeserializeParameters[    [@encodedList, MailCourier.DescribeEncodedList], h.realStream, zone !    Courier.Error => ERROR NotASerializedFile ];  MailCourier.DecodeAttributeList[encodedList, attributes !    UNWIND => MailCourier.FreeEncodedList[encodedList]];  MailCourier.FreeEncodedList[encodedList];  h.attributesDone ¬ TRUE;  END;		-- proc. ReceiveAttributes    SendAttributes: PUBLIC PROC [  dest: SerialStream, attrList: AttributeList, defaultName: NSName.Name] =  BEGIN OPEN h: LOOPHOLE[dest, Handle];  encodedList: MailCourier.EncodedList;  IF h.attributesDone OR h.direction#send THEN ERROR Stream.InvalidOperation;  SerializeLongCardinal[h.realStream, serializedFileVersion];  encodedList ¬ MailCourier.EncodeAttributeList[attrList, defaultName];    Courier.SerializeParameters[    [@encodedList, MailCourier.DescribeEncodedList], h.realStream !    Courier.Error => ERROR NotASerializedFile;     UNWIND => MailCourier.FreeEncodedList[encodedList]];  MailCourier.FreeEncodedList[encodedList];  h.attributesDone ¬ TRUE;  END;		-- proc. SendAttributes  -- private procs:DeleteProc: Stream.DeleteProcedure =   BEGIN OPEN h: LOOPHOLE[sH, Handle];  Stream.Delete[h.realStream];  zone.FREE[@sH];  END;	   EatAttributes: PROC [s: Stream.Handle] =  BEGIN  segmentCount: CARDINAL;  IF serializedFileVersion#DeserializeLongCardinal[s] THEN     ERROR NotASerializedFile;  segmentCount ¬ DeserializeSequenceHeader[s];  THROUGH [0..segmentCount) DO    wordCount: CARDINAL;    type: LONG CARDINAL;    type ¬ DeserializeLongCardinal[s];  -- LONG CARDINAL attribute type    wordCount ¬ DeserializeSequenceHeader[s];    THROUGH [0..wordCount) DO [] ¬ Stream.GetWord[s]; ENDLOOP;    ENDLOOP;  END;EmptyAttributes: PROC [s: Stream.Handle] =  BEGIN  SerializeLongCardinal[s, serializedFileVersion];  SerializeSequenceHeader[s, 0];   -- no attributes!!  END;  GetProc: Stream.GetProcedure =   --sH: Handle, block: Block, options: InputOptions  --RETURNS bytesTransferred: CARDINAL, why: CompletionCode, sst;  BEGIN OPEN h: LOOPHOLE[sH, ReceiveHandle];  bytesTransferred ¬ 0;  sst ¬ 0;  BEGIN ENABLE Stream.EndOfStream => ERROR NotASerializedFile;  IF ~h.attributesDone THEN {    EatAttributes[h.realStream]; h.attributesDone ¬ TRUE};  UNTIL h.status=endOfStream DO    bytesMoved: CARDINAL;    ourBlock: Environment.Block;    IF h.bytesLeftInSegment=0 THEN      BEGIN      IF h.lastSegment THEN GOTO endIt;      h.lastSegment ¬ DeserializeBoolChoice[h.realStream];      h.bytesLeftInSegment ¬ DeserializeSequenceHeader[h.realStream]*2;      IF h.bytesLeftInSegment=0 THEN LOOP;      END;    IF block.stopIndexPlusOne=block.startIndex THEN EXIT;    ourBlock ¬ block;    IF h.bytesLeftInSegment < (block.stopIndexPlusOne-block.startIndex) THEN      ourBlock.stopIndexPlusOne ¬ block.startIndex + h.bytesLeftInSegment;    bytesMoved ¬ Stream.GetBlock[h.realStream, ourBlock].bytesTransferred;    h.bytesLeftInSegment ¬ h.bytesLeftInSegment - bytesMoved;    bytesTransferred ¬ bytesTransferred + bytesMoved;    block.startIndex ¬ block.startIndex + bytesMoved;    REPEAT	       endIt =>        BEGIN        -- last byte valid??        IF ~DeserializeBoolean[h.realStream] THEN	  bytesTransferred ¬ bytesTransferred - 1;	-- do something about file children here??        DO  -- flush rest of stream	  [] ¬ Stream.GetByte[h.realStream !	    Stream.EndOfStream => GOTO exit];	  REPEAT exit => NULL;	  ENDLOOP;        h.status ¬ endOfStream;        END;    ENDLOOP;  END;	-- ENABLE Block  why ¬ h.status;  IF options.signalEndOfStream AND h.status=endOfStream THEN    SIGNAL Stream.EndOfStream[block.startIndex];  END;	-- GetProc  PutProc: Stream.PutProcedure =   BEGIN OPEN h: LOOPHOLE[sH, SendHandle];  headerCount: CARDINAL;  nextLeftoverPresent: BOOLEAN;  byteCount: CARDINAL ¬ block.stopIndexPlusOne - block.startIndex;  IF ~h.attributesDone THEN {    EmptyAttributes[h.realStream]; h.attributesDone ¬ TRUE};  IF byteCount=0 THEN RETURN;  IF h.leftoverPresent THEN byteCount ¬ byteCount + 1;  headerCount ¬ byteCount/2;  IF (nextLeftoverPresent ¬ byteCount#headerCount*2) THEN    block.stopIndexPlusOne ¬ block.stopIndexPlusOne - 1;  IF headerCount#0 THEN    BEGIN    SerializeBoolChoice[h.realStream, FALSE];   -- mark not last segment    SerializeSequenceHeader[h.realStream, headerCount];    IF h.leftoverPresent THEN Stream.PutByte[h.realStream, h.leftoverByte];    Stream.PutBlock[h.realStream, block];    END;  IF (h.leftoverPresent ¬ nextLeftoverPresent) THEN    h.leftoverByte ¬ block.blockPointer[block.stopIndexPlusOne];  END;	-- PutProc.    SendNowProc: Stream.SendNowProcedure =  BEGIN OPEN h: LOOPHOLE[sH, SendHandle];  -- finish up serialization:  IF ~h.attributesDone THEN {    EmptyAttributes[h.realStream]; h.attributesDone ¬ TRUE};  SerializeBoolChoice[h.realStream, TRUE];   -- mark last segment  SerializeSequenceHeader[h.realStream, (IF h.leftoverPresent THEN 1 ELSE 0)];  IF h.leftoverPresent THEN { -- null byte for filler    Stream.PutByte[h.realStream, h.leftoverByte]; Stream.PutByte[h.realStream, 0] };    SerializeBoolean[h.realStream, ~h.leftoverPresent];    -- is last byte valid??  SerializeSequenceHeader[h.realStream, 0];    -- no children in this serialized tree.  END;		-- SendNowProc.-- random serialization stuffDeserializeBoolean,DeserializeBoolChoice: PROC [source: Stream.Handle] RETURNS [BOOLEAN] =  {RETURN[Stream.GetWord[source]#0]};    DeserializeLongCardinal: PROC [source: Stream.Handle] RETURNS [LONG CARDINAL] =    BEGIN    number: Inline.LongNumber;     number.high ¬ Stream.GetWord[source];    number.low ¬ Stream.GetWord[source];     RETURN[number.lc];    END;    DeserializeSequenceHeader: PROC [source: Stream.Handle]  RETURNS [CARDINAL] = INLINE {RETURN[Stream.GetWord[source]]};SerializeBoolean,SerializeBoolChoice: PROC [sink: Stream.Handle, boolean: BOOLEAN] =  {Stream.PutWord[sink, (IF boolean THEN 1 ELSE 0)]};    SerializeLongCardinal: PROC [sink: Stream.Handle, lc: LONG CARDINAL] =    {Stream.PutWord[sink, Inline.HighHalf[lc]];     Stream.PutWord[sink, Inline.LowHalf[lc]]};      SerializeSequenceHeader: PROC [sink: Stream.Handle, value: CARDINAL] = INLINE  {Stream.PutWord[sink, value]};END.    	-- LOG-- Hankins 15-Mar-83:   Reworked to create Deserialize and Serialize.  Removed everything else non-necessary. Added Serialize/DeserializeAttributes from old mailcourier(?).-- Wobber 21-Jun-83:   Make GetProc call EatRestOfStream after last byte of top-level file so that NSDataStream.Abort isn't generated.-- AOF 19-Jan-87:   Put in patch described by Jody.
0001					*0002					*0003					*0004					*0005					*0006					* Rigid Disk Microcode for Etch 3 & above, Rev F1 0007					* RDvF2.src --- 23-Sep-88 16:36:18	RLS0008					* RDvF2T.src --- 6-Dec-88 13:45:09	MS0009					*0010					*0011					*	Copyright (C) 1988 Xerox Corporation. All Rights Reserved.  0012					*Copyright protection claimed includes all forms and matters of copyrightable0013					*material and information now allowed by statutory or judicial law or 0014					*hereinafter granted, including without limitation, material generated 0015					*from the software programs which are displayed on the screen such as 0016					*icons, screen display looks, etc.0017					*0018					*0019					*0020					*For use with Etch 3 or higher only0021					*0022					*Derived from RdcE3A.src,  RdcE3B.src, RdcE3C.src & RDvE3D.src, RdcE3E0023					*	with gaps between fields enlarged to correct write performance problem0024					*	Changes to fix sector not found problem;0025					*	sector length changed to agree with Bad Page Utility0026					*	Bug in SKNEQ fixed0027					*	RdGate timing corrected0028					*	Bug in F1 fixed0029					*0030					 	PROG	RDVF20031							OBJ      S/R0032					*0033					*	MAC USE0034					*0035					* L0 = 1; HI = 0 0036					*0037					*      80       40         20         10        80038					*     SRCH     IBLA'     WRITE'     RGATE     ECCIZ'0039					*OFF   LO       HI         HI         LO        HI     = 90X0040					*0041					*0042					*DECLARATIONS0043						8X3050044						DEF	4,1,30045					*Write Commands & Partials0046					*0047					WRSPMA	EQU	2	ScratchPad Memory Address [XMIT  Add,IVL/WRSPMA]0048					INDXOF	EQU	3	Index Off; data not used0049					WDDATA	EQU	4	WRITE DATA TO DISK0050					WRDC1	EQU	5	Write Disk Control Reg 10051					WRLDSP	EQU	6	Left Display 0052					WRRDSP	EQU	15H	Right Display0053					WRMAC	EQU	7	Write into MAC0054					WRDC2	EQU	11H	Write Disk Control Reg 20055					RSTLED	EQU	12H	Reset RDC display LED Control0056					WRSTAT	EQU	13H	Write RDC Status Reg-to IOP0057					TGLA	EQU	14H	Toggle FF A in FIFO controls0058					WRFLO	EQU	16H	Write FIFO Low & Store in FIFO0059					WRFHI	EQU	17H	Write FIFO Hi0060					*0061					*Read Commands & Partials0062					*0063					SPD	EQU	37H	ScratchPadData [MOVE SPD,0,Rg]0064					*			[MOVE  SPD,0,Rg/,1] moves & incrememts SPMA0065					FIFSTA	EQU	2	FIFO Status register0066					RDCTL	EQU	3	Read RDC Control Register-from IOP0067					RDDSK	EQU	4	Read Disk Data0068					DSKST	EQU	5	DISK STATUS0069					RDFLO	EQU	6	Read FIFO Low & cycle FIFO0070					RDFHI	EQU	7	Read FIFO Hi0071					*0072					*DC2 Partials--use: Xmit Partial,IVL/WRDC20073					*0074					STRINT	EQU	00X		Set Rigid Disk Interrupt0075					RSRINT	EQU	80X		Reset Rigid Disk Interrupt0076					STWG	EQU	01X		Set WriteGate = WriteGate on0077					RSWG	EQU	81X		Reset WriteGate = WriteGate off0078					STDIN	EQU	02X		Set Direction in0079					STDOT	EQU	82X		Set Direction Out {=Rst DIN}0080					STLPB	EQU	03X		Set RD LoopBack0081					RSLPB	EQU	83X		Rst RD LoopBack0082					STSTP	EQU	04X		Set Step = Step On0083					RSSTP	EQU	84X		Reset Step = Step Off0084					STWPC	EQU	05X		Set PreComp = PreComp On0085					RSWPC	EQU	85X		Reset PreComp = PreComp Off0086					STCRC	EQU	07X		Set CRC0087					STECC	EQU	87X		Set ECC = Reset CRC0088					*0089					*ScratchPad Constants--use: Xmit Constant,IVL/WRSPMA0090					*0091					HDST	EQU	0DCX		SA OF HEADER IMAGE0092					LBLST	EQU	0EBX		SA OF LABEL IMAGE0093					HDHD	EQU	0DEX		HD Byte in Header Image0094					HDSC	EQU	0DFX		Sector byte in Header Image0095					HDCYH	EQU	0DCX		Cyl hi in Header0096					HDCYL	EQU	0DDX		Cyl lo in Header0097					LBFPL	EQU	0F6X		FILE PAGE LO LO IN LABEL IMAGE0098					LBFPHH	EQU	0F7X		FilePageHi-Hi in Label Image0099					SECNTH	EQU	0C0X		No of sectors to transfer Hi0100					SECNTL	EQU	0C1X		No of sectors to transfer Lo0101					SECPT	EQU	0C3X		NoSectors+1 per track0102					HDSPC	EQU	0C5X		NoHeads+1 per cyl0103					CYLPDL	EQU	0C7X		NoCyls per drive+1-lo0104					CYLPDH	EQU	0C6X		NoCyls per drive+1 hi0105					ECCRF	EQU	0A0X		STCRC or STECC0106					FIFFM	EQU	0A1X		FIFO Full or eMpty flag0107					CURCLH	EQU	0A2X		Current Cylinder Hi0108					CURCLL	EQU	0A3X		Current Cylinder lo0109					OLDCMD	EQU	0A5X		previous command0110					CURCMD	EQU	0A6X		Current Command0111					DIAGF	EQU	0A7X		Diagnostic Flag0112					CURST	EQU	0A8X		Current Status0113					FRSTWT	EQU	0A9X		First Write Flag0114					ECCF	EQU	0DBX		ECC Flag0115					FCURCH	EQU	0D8X		FIFO-CurCyl Hi0116					FCURCL	EQU	0D9X		FIFO-CurCyl Lo0117					FSEC	EQU	0C9X		First Sector Number0118					WICYH	EQU	0CAX		RedWriteCur Cyl Hi0119					WICYL	EQU	0CBX		RedWriteCur Cyl lo0120					PCCYH	EQU	0CCX		PrecompCyl Hi0121					PCCYL	EQU	0CDX		PrecompCyl lo0122					*0123					*Sector length: 1 if 256, 2 if 257, 3 if 2580124					WENDC	EQU	0CFX		sector length0125					WENDCA	EQU	0FFX		a copy of WENDC0126					* loc 0D0X is always zero and = HDRERT Hi0127					HDRERT	EQU	0D1X		Contains HeaderErrType0128					*loc 0D2X is always zero and = LBLERT hi0129					LBLERT	EQU	0D3X		Contains LabelErrorType0130					*loc 0D4X is always 0 and = DTAERT Hi0131					DTAERT	EQU	0D5X		Contains DataErrorType0132					*loc 0D6X is always 0 and = LSTERT Hi0133					LSTERT	EQU	0D7X		Contains LastErrorType0134					*DtaEcc and following 3 locations, 0BDX - 0BFX, contain the0135					*  Data ECC syndrome0136					DTAECC	EQU	0BCX		Start of DataBlock ECC Syndrome0137					DVST	EQU	0E4X		Drive Status0138					CNTST	EQU	0E5X		Controller status0139					OPCODE	EQU	0E7X		Operation to be done0140					TKFH	EQU	0E8X		No of tracks to format, hi0141					TKFL	EQU	0E9X		No of tracks to format, lo0142					*0143					*MAC Constants--use: Xmit Constant,IVL/WRMAC0144					*0145					IBLA	EQU	320H0146					IE	EQU	330H	IBLA + ECCIC ON0147					WIE	EQU	370H	IBLA + WRITE + ECCIC ON0148					WE	EQU	270H	WRITE + ECCIC ON0149					IW	EQU	360H	IBLA + WRITE ON0150					WRT	EQU	260H	WRITE ON0151					*0152					*Registers0153					*0154					CNTRG	EQU	1	Counter Reg0155					SIGN	EQU	1	Sign Reg in arithmetic0156					WRKR	EQU	2	WORKING REGISTER0157					STATRG	EQU	3	STAT INTO R30158					SL	EQU	3	Subtrahend Lo0159					DTARG	EQU	4	DTA REG0160					SH	EQU	4	Subtrahend Hi0161					DTXLO	EQU	5	Data Lo0162					ML	EQU	5	Minuend Lo0163					DTXHI	EQU	6	Data Hi0164					MH	EQU	6	Minuend Lo0165					ECCFLG	EQU	14H	EccFlag; 1=ECC, 0=CRC0166					IMMER	EQU	15H	Immediate error0167					ERRTYP	EQU	16H	Keep error type0168					*0169					*0170					*  The start of this system 0171					* Initalize0172					*0173					*!!!!!!! START AT LOC 1-- LOC 0 IS FOR RESET BY 186 !!!!!!!!!0174					*0175						ORG	00176	00000	7 00004	0000	START	JMP	WTF00177	00001	0 00000	0000		NOP0178					*TST  Next 4 instructions operate RDC LED Display0179	00002	6 07000	0160		XMIT	0,IVL/RSTLED		Reset LED Control0180					*	XMIT	0A5X,IVL/WRLDSP0181					*	XMIT	0A5X,IVL/WRLDSP		'5A' in Left Display0182					*	XMIT	5AX,IVL/WRRDSP0183					*	XMIT	5AX,IVL/WRRDSP		'A5' in Rt Display0184	00003	7 00003	0000	LPHERE	JMP	LPHERE			Wait here for 186 reset0185					*0186					*0187	00004	6 07200	0144	WTF0	XMIT	RSRINT,IVL/WRDC2	Reset interrupt0188	00005	6 07220	0112		XMIT	90X,IVL/WRMAC		Set MAC to OFF states0189	00006	6 07000	0064		XMIT	0,IVL/WDDATA		Write 00190					*Now clear SP to zeros0191	00007	6 00001	0000	CLSP	XMIT	1,AUX0192	00010	6 01000	0000		XMIT	0,CNTRG0193	00011	0 01007	0032	CLSPA	MOVE	CNTRG,IVL/WRSPMA	Address of next mem loc in MA0194	00012	1 01001	0000		ADD	CNTRG,CNTRG		Ready for next location0195	00013	6 17000	0000		XMIT	0,IVR			Zero into loc0196	00014	5 01011	0000		NZT	CNTRG,CLSPA		Loop0197					*now make curcl = FFFF, cyl no not known0198	00015	6 07242	0032		XMIT	CURCLH,IVL/WRSPMA	Address of current cyl hi0199	00016	6 17377	0000		XMIT	0FFX,IVR		Make it FF0200	00017	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA	Address of current cyl lo0201	00020	6 17377	0000		XMIT	0FFX,IVR		Make it FF0202	00021	6 07000	0064		XMIT	0,IVL/WDDATA		Write 00203					*	0204	00022	6 11000	0000	WTZZ	CALL	WTCRS			wait for 000205	00023	7 01331	00000206	00024	6 00377	0000		XMIT	0FFX,AUX0207	00025	3 04002	0000		XOR	DTARG,WRKR0208	00026	5 02022	0000		NZT	WRKR,WTZZ		wait for cmd 000209	00027	6 07377	0176		XMIT	0FFX,IVL/WRSTAT		Send 000210					*TST  Next 4 instructions operate RDC LED Display0211	00030	6 07000	0160		XMIT	0,IVL/RSTLED		Reset LED control0212					*	XMIT	222H,IVL/WRLDSP0213					*	XMIT	222H,IVL/WRLDSP		'6D' in Left Display0214					*	XMIT	222H,IVL/WRRDSP0215					*	XMIT	222H,IVL/WRRDSP		'6D' in Rt Display0216					**Restore - Recalibrate the disk - THIS generates no errors0217	00031	6 11001	0000	IRSTR	CALL	ZROERS			Zero error locs0218	00032	7 02651	00000219					*TST Next 2 cmds operate RDC LED Display0220					*	XMIT	6FX,IVL/WRRDSP0221					*	XMIT	6FX,IVL/WRRDSP		Send 90 to Rt Disp0222	00033	6 07357	0080		XMIT	357H,IVL/WRDC1		Sellect Drive0223	00034	6 11002	0000		CALL	RESTR			Restore the disk0224	00035	7 01363	00000225					*Now set CurCyl to zero0226	00036	6 07242	0032		XMIT	CURCLH,IVL/WRSPMA	Address of CurCylHi0227	00037	6 17000	0000		XMIT	0,IVR			Make it zero0228	00040	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA	Address of CurCylLo0229	00041	6 17000	0000		XMIT	0,IVR			Make it 00230					*TST Next 2 cmds operate RDC LED Display0231					*	XMIT	60X,IVL/WRRDSP0232					*	XMIT	60X,IVL/WRRDSP		Send 9F to Rt Disp0233					*0234					*0235					*Main Loop0236					*0237					*Copmmands follow each in order 0, 1, 2, 3, 0, 1, 2, 3, 0,... EXCEPT0238					*	0, 3 is also allowed.0239					*0240					*Commands are recieved complemented-0 is received as 0FFX, ETC0241					* Command sequence: EXCB checks that 2 is preceded by 1-no0242					*   other sequence checking is done.0243					* 0 = NOP0244					* 1 = Get CB0245					* 2 = Do instruction0246					* 3 = load ending status0247					*0248					*Put old CurrentCommand into OldCommand0249	00042	6 07246	0032	PML	XMIT	CURCMD,IVL/WRSPMA	Address of Current Command0250	00043	0 00000	0000		NOP				Wait for address to settle0251	00044	0 37002	0000		MOVE	SPD,0,WRKR0252	00045	6 07245	0032		XMIT	OLDCMD,IVL/WRSPMA	ADDRESS OF OLDCOMMAND0253	00046	0 02017	0000		MOVE	WRKR,IVR0254					*0255	00047	6 11003	0000		CALL	WTCRS			Get new command0256	00050	7 01331	00000257					*TST Next 2 instructions operate RDC LED Display0258					*	MOVE	DTARG,IVL/WRLDSP0259					*	MOVE	DTARG,IVL/WRLDSP	Comp Cmd in Left Display0260	00051	6 00377	0000		XMIT	0FFX,AUX0261	00052	3 04004	0000		XOR	DTARG,DTARG		Compliment cmd0262	00053	6 07245	0032		XMIT	OLDCMD,IVL/WRSPMA	Address of previous command0263	00054	0 00000	0000		NOP				Wat for address to settle0264	00055	0 37000	0000		MOVE	SPD,0,AUX		Old cmd to AUX0265	00056	3 04002	0000		XOR	DTARG,WRKR 		Are new & old =?0266	00057	5 02061	0000		NZT	WRKR,PMLA		Not same0267					*TST Next 2 instructions operate RDC LED Display0268					*	XMIT	221H,IVL/WRRDSP0269					*	XMIT	221H,IVL/WRRDSP		Display 6E in rt disp0270	00060	7 00042	0000		JMP	PML			Same-try again0271					*Set Diag Flag if a diag command0272	00061	6 00100	0000	PMLA	XMIT	40X,AUX			Mask for diag bit0273	00062	2 04002	0000		AND	DTARG,WRKR		Diag bit in WRKR0274	00063	6 07247	0032		XMIT	DIAGF,IVL/WRSPMA	Address of Diaf Flag0275	00064	6 17000	0000		XMIT	0,IVR			Reset Diag Flag0276	00065	5 02067	0000		NZT	WRKR,PMLB		Not Diagnostic 0277	00066	6 17001	0000		XMIT	1,IVR			set diag flag0278	00067	6 00003	0000	PMLB	XMIT	3,AUX0279	00070	2 04004	0000		AND	DTARG,DTARG		Look at command bits only0280					*Put command into CurrentCommand so that Execute command can check0281					*that  cmd 1, Load CommnadBlock preceeded,cmd 2, ExecuteCommand0282	00071	6 07246	0032		XMIT	CURCMD,IVL/WRSPMA	Address of curcmd0283	00072	0 04017	0000		MOVE	DTARG,IVR		Put current commnad into CurCmd0284					*TST Next 2 commands operate RDC LED Display0285					*	MOVE	DTARG,IVL/WRLDSP0286					*	MOVE	DTARG,IVL/WRLDSP	Current cmd in Lft Display0287	00073	4 04074	0000		XEC	CMPTBL(DTARG),4		Dispatch0288	00074	7 00100	0000	CMPTBL	JMP	NPCB			Noop0289	00075	7 00103	0000		JMP	GTCB			Get CommandBlock0290	00076	7 00151	0000		JMP	EXCB			Execute CommandBlock0291	00077	7 00217	0000		JMP	LDCB			Load CommandBlock0292					*0293					*0294					* Do NOOP command-- Idle Loop0295	00100	6 07200	0144	NPCB	XMIT	RSRINT,IVL/WRDC2	Reset RigidDisk Interrupt0296	00101	6 07377	0176		XMIT	0FFX,IVL/WRSTAT		Send "in idleloop"0297					*TST Next 2 commands operate RDC LED Display0298					*	XMIT	0FFX,IVL/WRRDSP0299					*	XMIT	0FFX,IVL/WRRDSP		0 in RT Display0300	00102	7 00042	0000		JMP	PML			Loop0301					*0302					*COMMAND EXECUTERS0303					*0304					*GTCB0305					*GetCommandBlock  0306					* New  September 11, 1984  4:54 PM-0307					*Rev a0308					*Assume DCB correct for me- compliment for 186,0309					*any byte swap done0310					*0311					*load 23 words starting at loc DTAECC0312					*1 byte of 00313					*10 words of data, the label0314					*check for FIFO empty between each word0315					*0316					*0317					*0318	00103	6 07200	0144	GTCB	XMIT	RSRINT,IVL/WRDC2	Reset RigidDisk Interrupt0319	00104	6 07376	0176		XMIT	0FEX,IVL/WRSTAT		Send " In Get CommandBlock mode"0320					*TST Next 2 commands operate RDC LED Display0321					*	XMIT	0EFX,IVL/WRRDSP0322					*	XMIT	0EFX,IVL/WRRDSP		put 10 in rt display0323	00105	6 15000	0000		XMIT	0,IMMER			Clear immdiate error reg0324	00106	6 01351	0000		XMIT	-23,CNTRG		No of words0325	00107	6 02274	0000		XMIT	DTAECC,WRKR		Address in SP0326	00110	6 05000	0000		XMIT	0,DTXLO			Flag = 00327	00111	6 00001	0000		XMIT	1,AUX0328					* FIFO was empty when last read; now wait until not empty0329					*	then do a dummy read to prime FIFO out0330					*0331	00112	0 26103	0002	GTCBA	MOVE	26H,1,STATRG/,,FIFSTA	Is FIFO empty?0332	00113	5 03112	0000		NZT	STATRG,GTCBA		FIFO is empty-WAIT0333	00114	0 27004	0006		MOVE	27H,0,DTARG/,,RDFLO	Dummy read-cycle FIFO0334					*0335	00115	0 02007	0032	GTCBB	MOVE	WRKR,IVL/WRSPMA		Address of first byte0336	00116	0 00000	0000		NOP				Wait for address to settle0337	00117	0 27004	0007		MOVE	27H,0,DTARG/,,RDFHI	FIFO Hi byte0338	00120	0 04017	0000		MOVE	DTARG,IVR		Dta to SP0339	00121	1 02002	0000		ADD	WRKR,WRKR		Incr SP Address0340	00122	0 02007	0032		MOVE	WRKR,IVL/WRSPMA		Address of lo byte0341	00123	0 00000	0000		NOP				Wait for address to settle0342	00124	0 27004	0006		MOVE	27H,0,DTARG/,,RDFLO	FIFO lo byte, get next word0343	00125	0 04017	0000		MOVE	DTARG,IVR		Data to SP0344	00126	1 02002	0000		ADD	WRKR,WRKR		Next SP address0345	00127	1 01001	0000		ADD	CNTRG,CNTRG		Finished?0346	00130	5 01132	0000		NZT	CNTRG,GTCBC		Continue0347	00131	7 00135	0000		JMP	GTCBF			Finished0348	00132	0 22103	0002	GTCBC	MOVE	22H,1,STATRG/,,FIFSTA	Was FIFO empty at last read?0349	00133	5 03112	0000		NZT	STATRG,GTCBA		Fifo was empty-wait until not empty0350	00134	7 00115	0000		JMP	GTCBB			Not empty-loop0351					*0352	00135	5 05146	0000	GTCBF	NZT	DTXLO,GTCBFF		Flag not zero, over0353	00136	6 01366	0000		XMIT	-10,CNTRG		Cntr for label image0354	00137	0 02007	0032		MOVE	WRKR,IVL/WRSPMA		Not used loc in SP0355	00140	6 17000	0000		XMIT	0,IVR			Put zero in it0356	00141	1 02002	0000		ADD	WRKR,WRKR		Count SP address0357	00142	6 05001	0000		XMIT	1,DTXLO			flag = ,1, label done0358	00143	0 22103	0002		MOVE	22H,1,STATRG/,,FIFSTA	Was FIFO empty at last read?0359	00144	5 03112	0000		NZT	STATRG,GTCBA		Fifo was empty-wait until not empty0360	00145	7 00115	0000		JMP	GTCBB			Get label image0361					*0362	00146	6 07276	0176	GTCBFF	XMIT	0BEX,IVL/WRSTAT		Send "done"0363	00147	6 07000	0144		XMIT	STRINT,IVL/WRDC2	Interrupt on0364					*TST Next 2 cmds operate RDC LED Display0365					*	XMIT	0E0X,IVL/WRRDSP0366					*	XMIT	0E0X,IVL/WRRDSP		Display 1F in right0367	00150	7 00042	0000		JMP	PML			Wait for next command0368					*0369					*0370					*Execute OPERATION0371					*0372	00151	6 07200	0144	EXCB	XMIT	RSRINT,IVL/WRDC2		Reset RigidDisk Interrupt0373					* If OldCmd is not = 1, error0374	00152	6 07245	0032		XMIT	OLDCMD,IVL/WRSPMA		Address of OldCmd0375	00153	6 00001	0000		XMIT	1,AUX0376	00154	0 37004	0000		MOVE	SPD,0,DTARG		Get OldCommand0377	00155	3 04002	0000		XOR	DTARG,WRKR		Compare OldCmd with 10378	00156	5 02212	0000		NZT	WRKR,EXCBER		OldCmd not = 1, error0379	00157	6 07375	0176		XMIT	0FDX,IVL/WRSTAT		Send "in EcexuteCB"0380					*TST Next 2 cmds operate RDC LED Display0381					*	XMIT	0DFX,IVL/WRRDSP0382					*	XMIT	0DFX,IVL/WRRDSP		Send 20 to Rtr Dsp0383					* copy WENDC into WENDCA0384	00160	6 07317	0032		XMIT	WENDC,IVL/WRSPMA	Address of WENDC0385	00161	0 00000	0000		NOP				Wait for address to settle0386	00162	0 37002	0000		MOVE	SPD,0,WRKR0387	00163	6 07377	0032		XMIT	WENDCA,IVL/WRSPMA0388	00164	0 02017	0000		MOVE	WRKR,IVR		WENDC copied to WENDCA0389					*0390					****** Track Read Command0391	00165	6 07347	0032		XMIT	OPCODE,IVL/WRSPMA	Address of opcode0392	00166	6 00020	0000		XMIT	10X,AUX			mask for Track Read Command bits0393	00167	3 37002	0000		XOR	SPD,0,WRKR		Get opcode0394						ORG	3,2560395	00170	5 02172	0000		NZT	WRKR,NTRCK		0396	00171	7 03077	0000		JMP	TRKRD0397					****** Track Read Command0398					0399	00172	6 07347	0032	NTRCK	XMIT	OPCODE,IVL/WRSPMA	Address of opcode0400	00173	6 00110	0000		XMIT	48X,AUX			mask for DIAG bits0401	00174	0 37011	0000		MOVE	SPD,0,R11		Get opcode0402	00175	2 11002	0000		AND	R11,WRKR		look at DIAG bits0403	00176	5 02214	0000		NZT	WRKR,DAGH		Operation is diagnostic0404	00177	6 00007	0000		XMIT	7,AUX			mask for normal opcode0405	00200	2 11011	0000		AND	R11,R11			look at 3 bits0406	00201	4 11202	0000		XEC	OPTBL(R11),8		dispatch on opcode0407	00202	7 00267	0000	OPTBL	JMP	RSTRD			Restore - Recalibrate0408	00203	7 00706	0000		JMP	FRMTT			Format - www0409	00204	7 00363	0000		JMP	REDDSK			Read - vvr0410	00205	7 00444	0000		JMP	WTDSK			Write - vvw0411	00206	7 00521	0000		JMP	WTLBDS			Write Label & Data - vww0412	00207	7 00600	0000		JMP	RDLBS			Read Label & Skip Data - vrn0413	00210	7 00624	0000		JMP	RDLBDS			Read Label & Data - vrr0414	00211	7 00302	0000		JMP	VFYDTA			Verify Data - vvv0415					*0416					*0417					*0418	00212	6 16214	0000	EXCBER	XMIT	8CX,ERRTYP		Protocol sequence error0419					*TST Next 2 cmds operate RDC LED Display0420					*	XMIT	0DEX,IVL/WRRDSP0421					*	XMIT	0DEX,IVL/WRRDSP		Send 21 to Rt Dsp0422	00213	7 01326	0000		JMP	GERENA0423					*0424					* Execute Diagnostic commands0425	00214	0 00000	0000	DAGH	NOP0426	00215	6 16213	0000		XMIT	8BX,ERRTYP		Illegal Diagnostic command0427					*TST Next 2 cmds operate RDC LED Display0428					*	XMIT	0DDX,IVL/WRRDSP0429					*	XMIT	0DDX,IVL/WRRDSP		Send 22 to Rt Disp0430	00216	7 01326	0000		JMP	GERENA0431					*0432					*0433					**************************0434					*Load Command Block0435					*Put Command Block in SP memory into FIFO so the IOP0436					*	& Mesa world can look at it0437					*************************0438					*0439	00217	6 07304	0032	LDCB	XMIT	0C4X,IVL/WRSPMA0440	00220	6 17001	0000		XMIT	1,IVR			Set version number0441					*0442	00221	6 07200	0144		XMIT	RSRINT,IVL/WRDC2	Reset RigidDisk Interrupt0443	00222	6 07374	0176		XMIT	0FCX,IVL/WRSTAT		Send "in Load CB "0444					*TST Next 2 cmds operate RDC LED Display0445					*	XMIT	0CFX,IVL/WRRDSP0446					*	XMIT	0CFX,IVL/WRRDSP		Display 30 in rt dsp0447	00223	6 07310	0032		XMIT	0C8X,IVL/WRSPMA		Addr of inv/non-inv test0448	00224	6 17000	0000		XMIT	0,IVR			Zero in test loc0449	00225	6 15000	0000	LDCBA	XMIT	0,IMMER0450	00226	6 01351	0000		XMIT	-23,CNTRG		No of words0451	00227	6 02274	0000		XMIT	DTAECC,WRKR		SA of Command Block0452	00230	0 26103	0002	LDCBB	MOVE	26H,1,STATRG/,,FIFSTA	Is FIFO empty?0453	00231	5 03233	0000		NZT	STATRG,LDCCC		Yes, go on0454	00232	7 00264	0000		JMP	LDCBER			No, error0455	00233	6 05000	0000	LDCCC	XMIT	0,DTXLO			Pass flag = 00456	00234	6 00001	0000		XMIT	1,AUX0457					*0458	00235	0 02007	0032	LDCBC	MOVE	WRKR,IVL/WRSPMA		Address of first byte in CB0459	00236	0 00000	0000		NOP				Wait for address to settle0460	00237	0 37004	0000		MOVE	SPD,0,DTARG		Get byte0461	00240	0 04007	0240		MOVE	DTARG,IVL/WRFHI		put into FIFO, Hi byte0462	00241	1 02002	0000		ADD	WRKR,WRKR	  	Next SP address0463	00242	0 02007	0032		MOVE	WRKR,IVL/WRSPMA		Next address0464	00243	0 00000	0000		NOP				Wait for address to settle0465	00244	0 37004	0000		MOVE	SPD,0,DTARG		Next byte0466	00245	0 04007	0224		MOVE	DTARG,IVL/WRFLO		Data to FIFO LO, write FIFO0467	00246	1 02002	0000		ADD	WRKR,WRKR0468	00247	1 01001	0000		ADD	CNTRG,CNTRG0469	00250	5 01235	0000		NZT	CNTRG,LDCBC		Not finished0470	00251	5 05256	0000		NZT	DTXLO,LDCBF		Is Pass Flag = 1? 0471	00252	6 05001	0000		XMIT	1,DTXLO			No- make it 10472	00253	6 01366	0000		XMIT	-10,CNTRG0473	00254	1 02002	0000		ADD	WRKR,WRKR		Skip one byte in SP0474	00255	7 00235	0000		JMP	LDCBC			Put Label image into FIFO0475					*0476	00256	5 15262	0000	LDCBF	NZT	IMMER,LDCBFE		Error, go to error exit0477	00257	6 07274	0176		XMIT	0BCX,IVL/WRSTAT		Send done0478	00260	6 07000	0144		XMIT	STRINT,IVL/WRDC2		Rigid Disk Interrupt on0479					*TST Next 2 cmds operate RDC LED Display0480					*	XMIT	0C0X,IVL/WRRDSP0481					*	XMIT	0C0X,IVL/WRRDSP		Send 3F to Rt Disp0482	00261	7 00042	0000		JMP	PML0483					*0484					*Error Exit- an error has occured while loading DCB0485	00262	6 07054	0176	LDCBFE	XMIT	2CX,IVL/WRSTAT		Send error done0486					*TST Next 2 cmds operate RDC LED Display0487					*	XMIT	0CEX,IVL/WRRDSP0488					*	XMIT	0CEX,IVL/WRRDSP		Send 31 to Rt Disp0489	00263	7 01236	0000		JMP	CMPSJ0490					*0491	00264	6 16007	0000	LDCBER	XMIT	7,ERRTYP		FIFO not empty at LDCB0492	00265	6 15007	0000		XMIT	7,IMMER			FIFO not empty at LDCB0493	00266	7 00233	0000		JMP	LDCCC			Resume Loading CB0494					*0495					*0496					*0497					*0498					**Restore - Recalibrate the disk - THIS OP generates no errors0499	00267	6 11004	0000	RSTRD	CALL	ZROERS			Zero error locs0500	00270	7 02651	00000501					*TST Next 2 cmds operate RDC LED Display0502					*	XMIT	6FX,IVL/WRRDSP0503					*	XMIT	6FX,IVL/WRRDSP		Send 90 to Rt Disp0504	00271	6 11005	0000		CALL	SELHD			Sellect Hd & Drive0505	00272	7 01541	00000506	00273	6 11006	0000		CALL	RESTR			Restore the disk0507	00274	7 01363	00000508					*Now set CurCyl to zero0509	00275	6 07242	0032		XMIT	CURCLH,IVL/WRSPMA	Address of CurCylHi0510	00276	6 17000	0000		XMIT	0,IVR			Make it zero0511	00277	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA	Address of CurCylLo0512	00300	6 17000	0000		XMIT	0,IVR			Make it 00513					*TST Next 2 cmds operate RDC LED Display0514					*	XMIT	60X,IVL/WRRDSP0515					*	XMIT	60X,IVL/WRRDSP		Send 9F to Rt Disp0516	00301	7 01221	0000		JMP	OPEND0517					*0518					*0519					*  	VVV   Verify,Verify,Verify0520					*Verify data- compares disk data with memory data0521	00302	0 00000	0000	VFYDTA	NOP0522					*TST Next 2 cmds operate RDC LED Display0523					*	XMIT	0FX,IVL/WRRDSP0524					*	XMIT	0FX,IVL/WRRDSP		Send F0 to Rt Display0525					*0526					*0527	00303	6 11007	0000	VFYDT1	CALL	ZROERS			Zero error locs0528	00304	7 02651	00000529					********************************************************0530					*0531					*The IOCB is to contain:0532					*  If Not Diagnostic command: ECCRF _ STECC0533					*		WENDC _ -10534					*  If Diagnostic command: 0535					*     If CRC  ECCRF _ STCRC; 0536					*     If Long Write & CRC WENDC _ -20537					*     If not Long Write WENDC _ -10538					*0539					*****************************************************0540					*0541					* Set ECCRF according to ECCF0542					* ECCF is 0 for ECC, 1 for CRC (Diag only)0543	00305	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF0544	00306	0 00000	0000		NOP				Wait for addrss to settle0545	00307	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg0546	00310	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA		Address of ECCRF0547	00311	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 10548	00312	5 02314	0000		NZT	WRKR,VFYSKP0549	00313	6 17207	0000		XMIT	STECC,IVR		If ECCF = 00550	00314	6 11010	0000	VFYSKP	CALL	SELHD			Sellect Head & Drive0551	00315	7 01541	00000552	00316	6 07251	0032		XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag0553	00317	6 17001	0000		XMIT	1,IVR			FirstWriteFlag = 10554	00320	6 07241	0032		XMIT	FIFFM,IVL/WRSPMA	Address of FIFO Emptyflag0555	00321	6 17000	0000		XMIT	0,IVR			Make it 00556					*0557					*Compare CurrentCyl with Cyl from HederImage.  If different, seek0558					*0559	00322	6 15000	0000		XMIT	0,IMMER		0560	00323	6 11011	0000		CALL	IMPSK0561	00324	7 01376	00000562					*0563					*If IMMER is not zero, an error has occured0564					*0565						ORG	29,2560566	00325	5 15361	0000		NZT	IMMER,ERENDA0567					*0568	00326	6 15000	0000	VFYSK	XMIT	0,IMMER			Continue Verifying sectors loops here0569	00327	6 01000	0000		XMIT	0,CNTRG0570	00330	6 11012	0000		CALL	WFFCK			Check FIFO full, empty, half full0571	00331	7 01667	00000572	00332	5 15361	0000		NZT	IMMER,ERENDA		an error has occured0573					*0574	00333	6 14001	0000		XMIT	1,ECCFLG		Set to CRC0575	00334	6 11013	0000		CALL	VFYHD			Verify Header0576	00335	7 01734	00000577					* Wait 8 bytes before starting to verify label0578	00336	6 04342	0000		XMIT	-30,DTARG0579	00337	6 11014	0000		CALL	WTINST0580	00340	7 01611	00000581	00341	6 11015	0000		CALL	VFYLBL			Verify Label0582	00342	7 02017	00000583					* Wait 7 bytes before starting to verify data0584	00343	6 04346	0000		XMIT	-26,DTARG0585	00344	6 11016	0000		CALL	WTINST0586	00345	7 01611	00000587	00346	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB0588	00347	0 00000	0000		NOP				Wait for address to settle0589	00350	0 37014	0000		MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag0590	00351	6 11017	0000		CALL	VFDTA			Verify Data0591	00352	7 02371	00000592	00353	5 16361	0000		NZT	ERRTYP,ERENDA		Error has occured-stop process here0593	00354	6 11020	0000		CALL	NXTSC			Next sector?0594	00355	7 02704	00000595	00356	5 15361	0000		NZT	IMMER,ERENDA		Error end0596	00357	5 04326	0000		NZT	DTARG,VFYSK		Do next sector0597	00360	7 01222	0000		JMP	OPCMP			Operation completed0598					*0599	00361	0 00000	0000	ERENDA	NOP0600					*TST Next 2 operate RDC LED Display0601					*	XMIT	00,IVL/WRRDSP0602					*	XMIT	00,IVL/WRRDSP		Send FF to Rt Disp0603	00362	7 01314	0000		JMP	EREND0604					*0605					*0606					*	VVR  Verify, Verify, Read0607					*READ DISK0608					*0609	00363	6 11021	0000	REDDSK	CALL	ZROERS			Zero error locs0610	00364	7 02651	00000611					********************************************************0612					*0613					*The IOCB is to contain:0614					*  If Not Diagnostic command:0615					*		WENDC _ -10616					*  If Diagnostic command: 0617					*     If CRC  ECCRF _ STCRC; 0618					*     IF Long Write & ECC WENDC _ -30619					*     If Long Write & CRC WENDC _ -20620					*     If not Long Write WENDC _ -10621					*0622					*****************************************************0623					*0624					*TST  Next 2 cmds operate RDC LED Display0625					*	XMIT	4FX,IVL/WRRDSP0626					*	XMIT	4FX,IVL/WRRDSP		SEND B0 TO RT DISP0627					* Set ECCRF according to ECCF0628					* ECCF is 0 for ECC, 1 for CRC (Diag only)0629	00365	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF0630	00366	0 00000	0000		NOP				Wait for address to settle0631	00367	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg0632	00370	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF0633	00371	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 10634					*0635						ORG	3,320636	00372	5 02374	0000		NZT	WRKR,RDDSK20637	00373	6 17207	0000		XMIT	STECC,IVR		If ECCF = 00638	00374	6 07241	0032	RDDSK2	XMIT	FIFFM,IVL/WRSPMA	SP address for FIF F/eM flag0639	00375	6 17000	0000		XMIT	0,IVR			Flag _ 00640					*	0641					*Compare CurrentCyl with Cyl from HederImage.  If different, seek0642					*0643	00376	6 11022	0000		CALL	SELHD			Sellect Head & Drive0644	00377	7 01541	00000645	00400	6 15000	0000		XMIT	0,IMMER		0646	00401	6 11023	0000		CALL	IMPSK0647	00402	7 01376	00000648					*0649					*If IMMER is not zero, an error has occured0650					*0651	00403	5 15361	0000		NZT	IMMER,ERENDA0652					*0653						ORG	34,2560654						ORG	4,320655	00404	5 26106	0002		NZT	26H,1,RDSK/,,FIFSTA	Is FIFO Empty?0656	00405	7 00442	0000		JMP	ERR3			FIFO is not empty0657					*0658	00406	6 15000	0000	RDSK	XMIT	0,IMMER			Continue reading sectors loops here0659	00407	6 01000	0000		XMIT	0,CNTRG0660	00410	6 11024	0000		CALL	RFFCK			Check FIFO full, empty, half full0661	00411	7 01623	00000662	00412	5 15043	0000		NZT	IMMER,ERENDB		an error has occured0663	00413	6 07000	0192		XMIT	0,IVL/TGLA		Toggle FF A0664	00414	6 14001	0000		XMIT	1,ECCFLG		Set to CRC0665	00415	6 11025	0000		CALL	VFYHD			Verify Header0666	00416	7 01734	00000667					* Wait 8 bytes before starting to verify label0668	00417	6 04342	0000		XMIT	-30,DTARG0669	00420	6 11026	0000		CALL	WTINST0670	00421	7 01611	00000671	00422	6 11027	0000		CALL	VFYLBL0672	00423	7 02017	00000673					* Wait 7 bytes before starting to read data0674	00424	6 04346	0000		XMIT	-26,DTARG0675	00425	6 11030	0000		CALL	WTINST			Verify Label0676	00426	7 01611	00000677	00427	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB0678	00430	0 00000	0000		NOP				Wait for address to settle0679	00431	0 37014	0000		MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag0680	00432	6 11031	0000		CALL	RDDTA			Read Data0681	00433	7 02305	00000682	00434	5 16043	0000		NZT	ERRTYP,ERENDB		Error has occured-stop process here0683	00435	6 11032	0000		CALL	NXTSC			Next sector?0684	00436	7 02704	00000685	00437	5 15043	0000		NZT	IMMER,ERENDB		Error end0686	00440	5 04006	0000		NZT	DTARG,RDSK		Do next sector0687	00441	7 01222	0000		JMP	OPCMP			Operation completed0688					*0689					*FIFO not empty at beginning of Read Disk0690					*0691	00442	6 16003	0000	ERR3	XMIT	3,ERRTYP0692					*0693					*TST Next 2 cmds operate RDC LED Display0694					*	XMIT	4EX,IVL/WRRDSP0695					*	XMIT	4EX,IVL/WRRDSP		SEND B1 TO RT DISP0696	00443	7 01314	0000	ERENDB	JMP	EREND0697					*0698					*0699					*0700					*	VVW- Verify, Verify, Write0701					* WRITE DISK from FIFO0702					*0703					*0704	00444	6 11033	0000	WTDSK	CALL	ZROERS			Zero error locs0705	00445	7 02651	00000706					********************************************************0707					*0708					**The IOCB is to set:0709					*  If Not Diagnostic command: C0710					*		WENDC _ -10711					*  If Diagnostic command: 0712					*     If CRC  ECCRF _ STCRC; 0713					*     IF Long Write & ECC WENDC _ -30714					*     If Long Write & CRC WENDC _ -20715					*     If not Long Write WENDC _ -10716					*0717					*****************************************************0718					*0719					*TST Next 2 cmds operate RDC LED Display0720					*	XMIT	3FX,IVL/WRRDSP0721					*	XMIT	3FX,IVL/WRRDSP		Send C0 to Rt Disp0722					* Set ECCRF according to ECCF0723					* ECCF is 0 for ECC, 1 for CRC (Diag only)0724	00446	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF0725	00447	0 00000	0000		NOP0726	00450	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg0727	00451	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF0728	00452	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 10729	00453	5 02055	0000		NZT	WRKR,WTDBB0730	00454	6 17207	0000		XMIT	STECC,IVR		If ECCF = 00731	00455	6 11034	0000	WTDBB	CALL	SELHD			Sellect Head & Drive0732	00456	7 01541	00000733	00457	6 07251	0032		XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag0734	00460	6 17001	0000		XMIT	1,IVR			FirstWriteFlag = 10735	00461	6 07241	0032		XMIT	FIFFM,IVL/WRSPMA	Address of FIFO Empty flag0736	00462	6 17000	0000		XMIT	0,IVR			Make it 00737	00463	6 15000	0000		XMIT	0,IMMER			0738					*0739					* Compare CurrentCyl with Cyl from HederImage.  If different, seek0740					*0741	00464	6 11035	0000		CALL	IMPSK0742	00465	7 01376	00000743					*0744					*If IMMER is not zero, an error has occured0745					*0746	00466	5 15117	0000		NZT	IMMER,ERENDD0747					*0748						ORG	25,2560749	00467	6 15000	0000	WTDC	XMIT	0,IMMER			Continue writing sectors loops here0750	00470	6 01000	0000		XMIT	0,CNTRG0751					*0752	00471	6 11036	0000		CALL	WFFCK			Check FIFI full, empty, half full0753	00472	7 01667	00000754	00473	5 15117	0000		NZT	IMMER,ERENDD		Error has occured0755	00474	6 14001	0000		XMIT	1,ECCFLG		Set to CRC0756	00475	6 11037	0000		CALL	VFYHD			Verify Header0757	00476	7 01734	00000758					* Wait 8 bytes before starting to verify label0759	00477	6 04342	0000		XMIT	-30,DTARG0760	00500	6 11040	0000		CALL	WTINST0761	00501	7 01611	00000762	00502	6 11041	0000		CALL	VFYLBL			Verify Label0763	00503	7 02017	00000764	00504	5 16117	0000		NZT	ERRTYP,ERENDD		Error, no write0765					*0766	00505	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB0767	00506	0 00000	0000		NOP				Wait for address to settle0768	00507	0 37014	0000		MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag0769	00510	6 11042	0000		CALL	WTDTA			Write Data0770	00511	7 02226	00000771	00512	6 11043	0000		CALL	NXTSC			Next sector?0772	00513	7 02704	00000773	00514	5 15117	0000		NZT	IMMER,ERENDD		Error end0774	00515	5 04067	0000		NZT	DTARG,WTDC		Do next sector0775					*0776	00516	7 01221	0000		JMP	OPEND			Operation end0777					*0778	00517	0 00000	0000	ERENDD	NOP0779					*TST Next 2 cmds operate RDC LED Display0780					*	XMIT	3EX,IVL/WRRDSP0781					*	XMIT	3EX,IVL/WRRDSP		Send C1 to rt Disp0782	00520	7 01314	0000		JMP	EREND0783					*0784					*0785					*0786					*0787					*	VWW,  Verify, Write, Write0788					* WRITE LABEL & DATA from FIFO0789					*0790					*0791	00521	6 11044	0000	WTLBDS	CALL	ZROERS			Zero error locs0792	00522	7 02651	00000793					********************************************************0794					*0795					*0796					*The IOCB is to set:0797					*  If Not Diagnostic command: 0798					*		WENDC _ -10799					*  If Diagnostic command: 0800					*     If CRC  ECCRF _ STCRC; 0801					*     IF Long Write & ECC WENDC _ -30802					*     If Long Write & CRC WENDC _ -20803					*     If not Long Write WENDC _ -10804					*0805					*****************************************************0806					*0807					*TST Next 2 cmds operate RDC LED Display0808					*	XMIT	2FX,IVL/WRRDSP0809					*	XMIT	2FX,IVL/WRRDSP		Send D0 to Rt Disp0810					* Set ECCRF according to ECCF0811					* ECCF is 0 for ECC, 1 for CRC (Diag only)0812	00523	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF0813	00524	0 00000	0000		NOP				Wait for address to settle0814	00525	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg0815	00526	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF0816	00527	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 10817						ORG	3,2560818	00530	5 02132	0000		NZT	WRKR,WTLBBB0819	00531	6 17207	0000		XMIT	STECC,IVR		If ECCF = 00820	00532	6 11045	0000	WTLBBB	CALL	SELHD			Sellect Head & Drive0821	00533	7 01541	00000822	00534	6 07251	0032		XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag0823	00535	6 17001	0000		XMIT	1,IVR			FirstWriteFlag = 10824	00536	6 07241	0032		XMIT	FIFFM,IVL/WRSPMA	Address of FIFO Empty flag0825	00537	6 17000	0000		XMIT	0,IVR			Make it 0 0826					*0827					* Compare CurrentCyl with Cyl from HederImage.  If different, seek0828					*0829	00540	6 15000	0000		XMIT	0,IMMER0830	00541	6 11046	0000		CALL	IMPSK0831	00542	7 01376	00000832					*0833					*If IMMER is not zero, an error has occured0834					*0835	00543	5 15175	0000		NZT	IMMER,ERENDC0836	00544	6 15000	0000	WTLBDC	XMIT	0,IMMER			Continue writing sectors loops here0837	00545	6 01000	0000		XMIT	0,CNTRG0838					*0839	00546	6 11047	0000		CALL	WFFCK			Check FIFI full, empty, half full0840	00547	7 01667	00000841	00550	5 15175	0000		NZT	IMMER,ERENDC		Error has occured0842	00551	6 14001	0000		XMIT	1,ECCFLG		Set to CRC0843	00552	6 11050	0000		CALL	VFYHD			Verify Header0844	00553	7 01734	00000845	00554	5 16175	0000		NZT	ERRTYP,ERENDC		Error, no write0846					*0847	00555	6 11051	0000		CALL	WTLBL			write Label0848	00556	7 02166	00000849					* Wait 2 byteS before starting to write data 0850	00557	6 04372	0000		XMIT	-6,DTARG0851	00560	6 11052	0000		CALL	WTINST0852	00561	7 01611	00000853	00562	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB0854	00563	0 00000	0000		NOP				Wait for address to settle0855	00564	0 37014	0000		MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag0856	00565	6 11053	0000		CALL	WTDTA			Write Data0857	00566	7 02226	00000858					*0859						ORG	11,2560860	00567	5 16175	0000		NZT	ERRTYP,ERENDC		Error has occured-stop process here0861	00570	6 11054	0000		CALL	NXTSC			Next sector?0862	00571	7 02704	00000863	00572	5 15175	0000		NZT	IMMER,ERENDC		Error end0864	00573	5 04177	0000		NZT	DTARG,WTLBCC		Do next sector0865	00574	7 01221	0000		JMP	OPEND0866	00575	0 00000	0000	ERENDC	NOP0867					*TST Next 2  cmds operate RDC LED Display0868					*	XMIT	20X,IVL/WRRDSP0869					*	XMIT	20X,IVL/WRRDSP		Send DF to Rt Display0870	00576	7 01314	0000		JMP	EREND0871	00577	7 00544	0000	WTLBCC	JMP	WTLBDC0872					*0873					*0874					*	VRN  Verify, Read, Nop0875					****************************************0876					* Read Label0877					*Read Label is a one-sector operation0878					*It will not continue into another sector0879					*The label read replaces the LabelImage in the CommandBlock0880					****************************************0881					*0882					*0883	00600	0 00000	0000	RDLBS	NOP0884					*TST Next 2  cmd operate RDC LED Display0885					*	XMIT	1FX,IVL/WRRDSP0886					*	XMIT	1FX,IVL/WRRDSP		Send E0 to rt Disp0887	00601	6 11055	0000		CALL	ZROERS			Zero error locs0888	00602	7 02651	00000889	00603	6 11056	0000	RLBSKP	CALL	SELHD			Sellect Head & Drive0890	00604	7 01541	00000891	00605	6 15000	0000	RLBSK	XMIT	0,IMMER	0892					*0893					*Compare CurrentCyl with Cyl from HederImage.  If different, seek0894					*0895	00606	6 11057	0000		CALL	IMPSK0896	00607	7 01376	00000897					*0898					*If IMMER is not zero, an error has occureds0899					*0900	00610	5 15175	0000		NZT	IMMER,ERENDC0901	00611	6 14001	0000		XMIT	1,ECCFLG		Set to CRC0902	00612	6 01000	0000		XMIT	0,CNTRG0903	00613	6 11060	0000		CALL	VFYHD			Verify Header0904	00614	7 01734	00000905					* Wait 8 bytes before starting to read label0906	00615	6 04342	0000		XMIT	-30,DTARG0907	00616	6 11061	0000		CALL	WTINST0908	00617	7 01611	00000909	00620	6 11062	0000		CALL	RDLBL			Read Label0910	00621	7 02111	00000911	00622	5 16175	0000		NZT	ERRTYP,ERENDC		Error has occured-stop process0912	00623	7 01222	0000		JMP	OPCMP			Operation completed0913					*0914					*0915					*0916					*	VRR, Verify, Read, Read0917					*READ LABEL & DATA0918					*0919	00624	6 11063	0000	RDLBDS	CALL	ZROERS			Zero error locs0920	00625	7 02651	00000921					********************************************************0922					*0923					*0924					*At end label data read is in DCB; data read is in memory0925					*0926					*The IOCB is to contain:0927					*  If Not Diagnostic command: 0928					*		WENDC _ -10929					*  If Diagnostic command: 0930					*     If CRC  ECCRF _ STCRC; 0931					*     IF Long Write & ECC WENDC _ -30932					*     If Long Write & CRC WENDC _ -20933					*     If not Long Write WENDC _ -10934					*0935					*****************************************************0936					*0937					*TST Next 2 cmds operate RDC LED Display0938					*	XMIT	7FX,IVL/WRRDSP0939					*	XMIT	7FX,IVL/WRRDSP		SEND 80 TO RT DISP0940					* Set ECCRF according to ECCF0941					* ECCF is 0 for ECC, 1 for CRC (Diag only)0942	00626	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF0943	00627	0 00000	0000		NOP				Wait for address to settle0944	00630	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg0945	00631	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF0946	00632	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 10947	00633	5 02235	0000		NZT	WRKR,RDLDS20948	00634	6 17207	0000		XMIT	STECC,IVR		If ECCF = 00949	00635	6 07241	0032	RDLDS2	XMIT	FIFFM,IVL/WRSPMA	SP address for FIF F/eM flag0950	00636	6 17000	0000		XMIT	0,IVR			Flag _ 00951	00637	7 00640	0000		ORG	3,320952	00640	5 26102	0002		NZT	26H,1,RDLDS3/,,FIFSTA	Is FIFO Empty?0953	00641	7 00704	0000		JMP	RDLSE3			FIFO is not empty0954	00642	6 11064	0000	RDLDS3	CALL	SELHD			Sellect Head & Drive0955	00643	7 01541	00000956					*0957					*Compare CurrentCyl with Cyl from HederImage.  If different, seek0958					*0959	00644	6 15000	0000		XMIT	0,IMMER	0960	00645	6 11065	0000		CALL	IMPSK0961	00646	7 01376	00000962					*	0963					*If IMMER is not zero, an error has occured0964					*0965						ORG	30,2560966	00647	5 15303	0000		NZT	IMMER,ERENDF0967	00650	6 01000	0000	RDLDS4	XMIT	0,CNTRG			Continue reading sectors loops here0968	00651	6 11066	0000		CALL	RFFCK			Check FIFO full, empty, half full0969	00652	7 01623	00000970	00653	5 15303	0000		NZT	IMMER,ERENDF		an error has occured0971	00654	6 07000	0192		XMIT	0,IVL/TGLA		Toggle FF A0972	00655	6 14001	0000		XMIT	1,ECCFLG		Set to CRC0973	00656	6 11067	0000		CALL	VFYHD			Verify Header0974	00657	7 01734	00000975					* Wait 8 bytes before starting to read label0976	00660	6 04342	0000		XMIT	-30,DTARG0977	00661	6 11070	0000		CALL	WTINST0978	00662	7 01611	00000979	00663	6 11071	0000		CALL	RDLBL			Read Label0980	00664	7 02111	00000981					* Wait 7 byte before starting to read data0982	00665	6 04346	0000		XMIT	-26,DTARG0983	00666	6 11072	0000		CALL	WTINST0984	00667	7 01611	00000985	00670	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB0986	00671	0 00000	0000		NOP				Wait for address to settle0987	00672	0 37014	0000		MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag0988	00673	6 11073	0000		CALL	RDDTA			Read Data0989	00674	7 02305	00000990	00675	5 16303	0000		NZT	ERRTYP,ERENDF		Error has occured-stop process here0991	00676	6 11074	0000		CALL	NXTSC			Next sector?0992	00677	7 02704	00000993	00700	5 15303	0000		NZT	IMMER,ERENDF		Error end0994	00701	5 04250	0000		NZT	DTARG,RDLDS4		Do next sector0995	00702	7 01222	0000		JMP	OPCMP			Operation completed0996					*0997	00703	7 01314	0000	ERENDF	JMP	EREND0998					*0999					*FIFO not empty at beginning of Read Disk1000					*1001	00704	6 16003	0000	RDLSE3	XMIT	3,ERRTYP1002					*1003					*TST Next 2 cmds operate RDC LED Display1004					*	XMIT	7EX,IVL/WRRDSP1005					*	XMIT	7EX,IVL/WRRDSP		SEND 81 TO RT DISP1006	00705	7 01314	0000	ERENDE	JMP	EREND1007					*1008					*1009					*1010					*1011					*Format the disk   August 3, 1984  4:05 PM-1012					*	Rev  September 25, 1984  11:45 AM 1013					*   Gap length revised  28-Jan-85 10:18:121014					*	&    7-Feb-85 12:38:11*1015					*Format the disk1016					*Minimum format length is one track1017					*dCB specifies start cylinder, in the header, & gives start header1018					*& label1019					*dCB also specifies no of TRACKS to be formatted.1020					*  Header will be forced to have sector number = FSEC,1021					*  First sector number per track1022					*While formatting track, normal incrememts will be made1023					*  to sector no & FPg; after formating one track, normal1024					*  increments will be made to header & label,1025					*  and implied seek & sellect head will functin as normally.1026					*1027					*This process does not check the format-1028					*  it is recommended that a disk scan be done to check the disk1029					*1030					*1031	00706	0 00000	0000	FRMTT	NOP1032					*TST Next 2  cmds operate RDC LED Display1033					*	XMIT	5FX,IVL/WRRDSP1034					*	XMIT	5FX,IVL/WRRDSP		Send A0 to Rt Disp1035	00707	6 15000	0000		XMIT	0,IMMER1036	00710	6 16000	0000		XMIT	0,ERRTYP1037					*force starting sector number = First sector number (FSEC)1038	00711	6 07311	0032		XMIT	FSEC,IVL/WRSPMA		Address of first sec1039	00712	0 00000	0000		NOP				Allow address to settle1040	00713	0 37002	0000		MOVE	SPD,0,WRKR1041	00714	6 07337	0032		XMIT	HDSC,IVL/WRSPMA		Address of sector no in header1042	00715	0 02017	0000		MOVE	WRKR,IVR		Into header1043					* Set ECCFLG & ECCRF to CRC & ECC respectively1044	00716	6 14001	0000		XMIT	1,ECCFLG		Set to CRC1045	00717	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF in SP1046	00720	0 00000	0000		NOP				Allow address to settle1047	00721	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg1048	00722	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF1049	00723	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 11050						ORG	3,2561051	00724	5 02326	0000		NZT	WRKR,C1052	00725	6 17207	0000		XMIT	STECC,IVR		If ECCF = 01053					*1054	00726	6 11075	0000	C	CALL	SELHD			Sellect head & drive1055	00727	7 01541	00001056	00730	6 11076	0000	D	CALL	IMPSK			Do implied seek1057	00731	7 01376	00001058					*1059					*If IMMER is not zero, an error has occured1060					*1061	00732	0 15016	0000		MOVE	IMMER,ERRTYP1062	00733	5 15335	0000		NZT	IMMER,*+2		Command expanded1063	00734	7 00736	0000		JMP	*+2			to avoid page error1064	00735	7 01314	0000		JMP	EREND1065					*1066					*Wait for index1067					*1068					* NOTE  WE WANT TO DETECT THE LEADING EDGE OF THE INDEX PULSE.1069					*  WE ACTUALLY LOOK AT THE INDEX STORAGE FF, WHICH IS SET BY1070					*  INDEX & RESET BY INDXOF.  THEREFORE WE MUST FIRST RESET INDEX1071					*  AND THEN LOOK FOR INDEX .1072					*  1073					*1074	00736	6 07000	0048	A	XMIT	0,IVL/INDXOF		Index Off-INDEX MAY HAVE BEEN ON1075	00737	0 00000	0000		NOP				WAIT FOR INDEX FF TO RESET1076	00740	0 00000	0000		NOP				WAIT SOMEMORE1077	00741	5 24101	0005	B	NZT	24H,1,B/,,DSKST		Wait until INDEX1078	00742	6 07000	0048		XMIT	0,IVL/INDXOF		INDX OFF1079					*1080					*First, write the Initial Gap1081					*1082	00743	6 07007	0144	WIG	XMIT	STCRC,IVL/WRDC2		SET TO CRC1083	00744	6 07000	0064		XMIT	0,IVL/WDDATA		load data = 01084	00745	6 07260	0112		XMIT	WRT,IVL/WRMAC		WRITE ON1085	00746	6 07270	0112		XMIT	WE,IVL/WRMAC		E + WRITE ON1086	00747	6 07260	0112		XMIT	WRT,IVL/WRMAC		WRITE ON-ECCIZ OFF1087	00750	6 04330	0000		XMIT	-40,DTARG		SET UP LOOP COUNT FOR IGAP1088	00751	5 21111	0002		NZT	21H,1,*/,,FIFSTA	WAIT FOR BDONE1089	00752	6 07001	0144		XMIT	STWG,IVL/WRDC2		WRITE GATE ON1090	00753	6 07000	0064		XMIT	0,IVL/WDDATA		write 0s1091	00754	6 11077	0000		CALL	WG			Write Initial Gap1092	00755	7 01615	00001093					*1094					*1095	00756	5 21116	0002	WIG3	NZT	21H,1,WIG3/,,FIFSTA	WAIT FOR BDONE1096	00757	6 07000	0064		XMIT	0,IVL/WDDATA		write 0s1097					* Now write the Header1098	00760	6 04356	0000	WHDR	XMIT	-18,DTARG		Gap Length1099	00761	6 07270	0112		XMIT	WE,IVL/WRMAC		Write + ECCIZ1100	00762	6 07260	0112		XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off1101	00763	5 21123	0002		NZT	21H,1,*/,,FIFSTA		WAIT FOR BDONE1102	00764	6 07000	0064		XMIT	0,IVL/WDDATA		write 0s1103	00765	6 11100	0000		CALL	WG			Write Gap1104	00766	7 01615	00001105	00767	5 21127	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1106	00770	6 07241	0064		XMIT	0A1X,IVL/WDDATA		Write Address Mark byte1107	00771	6 07334	0032		XMIT	HDST,IVL/WRSPMA		SA of Header Image1108	00772	5 21132	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1109	00773	6 07376	0064		XMIT	0FEX,IVL/WDDATA		Write HEADER ID byte1110	00774	0 00000	0000		NOP1111	00775	7 01000	0000		ORG	4,321112	01000	5 21100	0002	WHDR4	NZT	21H,1,WHDR4/,,FIFSTA	Wait for BDONE1113	01001	0 37007	0072		MOVE	SPD,0,IVL/WDDATA,1	Data from mem to disk, incr SPMA1114	01002	0 00000	0000		NOP				Wait for incr to finish1115	01003	5 23100	0002		NZT	23H,1,WHDR4/,,FIFSTA	End of header data?1116	01004	5 21104	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1117	01005	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, CRC out1118	01006	6 07360	0112		XMIT	IW,IVL/WRMAC		Write+IBLA--write CRC1119	01007	5 21107	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1120	01010	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, CRC out1121	01011	6 04363	0000		XMIT	-13,DTARG		Set up gap length1122	01012	5 21112	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1123	01013	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01124	01014	6 11101	0000		CALL	WG			Write gap -incl 3 guard bytes1125	01015	7 01615	00001126	01016	5 21116	0002		NZT	21H,1,*/,,FIFSTA		Wait for BDONE1127	01017	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01128	01020	6 07270	0112		XMIT	WE,IVL/WRMAC		WRITE ON, IBLA OFF1129					*Now write the label1130	01021	6 04371	0000		XMIT	-7,DTARG		Gap length1131	01022	5 21122	0002	WTLBL1	NZT	21H,1,*/,,FIFSTA	Wait for BDONE1132	01023	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01133	01024	6 07270	0112		XMIT	WE,IVL/WRMAC		Write + ECCIZ1134	01025	6 07260	0112		XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off1135	01026	6 11102	0000		CALL	WG			Write Gap1136	01027	7 01615	00001137	01030	5 21130	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1138	01031	6 07241	0064		XMIT	0A1X,IVL/WDDATA		Write Address Mark1139	01032	6 07353	0032		XMIT	LBLST,IVL/WRSPMA	SA of Label Image1140	01033	5 21133	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1141	01034	6 07374	0064		XMIT	0FCX,IVL/WDDATA		Write LABEL ID1142	01035	0 00000	0000		NOP1143	01036	7 01040	0000		ORG	4,321144	01040	5 21100	0002	WTLBL4	NZT	21H,1,*/,,FIFSTA	Wait for BDONE1145	01041	0 37007	0072		MOVE	SPD,0,IVL/WDDATA,1	Data from mem to disk, incr SPMA1146	01042	0 00000	0000		NOP1147	01043	5 24100	0002		NZT	24H,1,WTLBL4/,,FIFSTA	End of label?1148	01044	5 21104	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1149	01045	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, CRC out1150	01046	6 07360	0112		XMIT	IW,IVL/WRMAC		Write+IBLA--write CRC1151	01047	5 21107	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1152	01050	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, CRC out1153	01051	6 04363	0000		XMIT	-13,DTARG		Set Up Gap Length1154	01052	5 21112	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1155	01053	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01156	01054	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF1157	01055	6 11103	0000		CALL	WG			Write Gap, includes guard bytes1158	01056	7 01615	00001159	01057	5 21117	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1160	01060	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01161	01061	6 07270	0112		XMIT	WE,IVL/WRMAC		Write on, IBLA off1162					*Now write data block1163					*Set to ECC/CRC depending on ECCRF1164	01062	0 37007	0144		MOVE	SPD,0,IVL/WRDC2		Set for ECC/CRC (ECC normal)1165	01063	6 01000	0000		XMIT	0,CNTRG			First byte is 01166	01064	6 04372	0000		XMIT	-6,DTARG		Gap Length1167	01065	5 21125	0002	FRDTA1	NZT	21H,1,FRDTA1/,,FIFSTA	Wait for BDONE1168	01066	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01169	01067	6 07270	0112		XMIT	WE,IVL/WRMAC		Write + ECCIZ1170	01070	6 07260	0112		XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off1171	01071	6 11104	0000		CALL	WG			Write Gap1172	01072	7 01615	00001173	01073	5 21133	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1174	01074	6 07241	0064		XMIT	0A1X,IVL/WDDATA		Write Address Mark1175	01075	6 07000	0032		XMIT	0,IVL/WRSPMA		Set up SPMA to count words1176	01076	5 21136	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1177	01077	6 07373	0064		XMIT	0FBX,IVL/WDDATA		Write DATA ID1178	01100	0 00000	0000		NOP1179						ORG	8,321180	01101	5 21101	0002	FRDTA4	NZT	21H,1,FRDTA4/,,FIFSTA	Wait for BDONE1181	01102	0 01007	0064		MOVE	CNTRG,IVL/WDDATA	DATA TO DISK1182	01103	1 01001	0000		ADD	CNTRG,CNTRG1183	01104	0 37002	0008		MOVE	SPD,0,WRKR/,1		Get & ignore data, incr SPMA1184	01105	5 21105	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1185	01106	0 01007	0064		MOVE	CNTRG,IVL/WDDATA	DATA TO DISK1186	01107	1 01001	0000		ADD	CNTRG,CNTRG1187	01110	5 24101	0002		NZT	24H,1,FRDTA4/,,FIFSTA	Finished with count?1188					*SPMA only counts to 255 (0-254), we need 1 more word1189	01111	5 21111	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1190	01112	0 01007	0064		MOVE	CNTRG,IVL/WDDATA	DATA TO DISK1191	01113	1 01001	0000		ADD	CNTRG,CNTRG1192	01114	5 21114	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1193	01115	0 01007	0064		MOVE	CNTRG,IVL/WDDATA	DATA TO DISK1194	01116	0 00000	0000		NOP1195	01117	5 21117	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1196	01120	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, ECC out1197	01121	6 07360	0112		XMIT	IW,IVL/WRMAC		Write+IBLA--write ECC1198	01122	6 04364	0000		XMIT	-12,DTARG		Set Up Gap Length1199	01123	5 21123	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1200	01124	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, ECC out1201	01125	6 11105	0000		CALL	WG			Write Gap, incl guard bytes & ECC1202	01126	7 01615	00001203	01127	5 21127	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE1204	01130	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01205	01131	6 07270	0112		XMIT	WE,IVL/WRMAC		WRITE ON-IBLA OFF1206					*Now, determine if we are at the end of the track1207	01132	6 07337	0032		XMIT	HDSC,IVL/WRSPMA		Address of sector no1208	01133	6 00001	0000		XMIT	1,AUX1209	01134	1 37002	0000		ADD	SPD,0,WRKR	Previous sector + 1, do not put back1210	01135	5 21135	0002		NZT	21H,1,*/,,FIFSTA		Wait for BDONE1211	01136	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01212					* last time for Wait for BDONE & load data1213					* let hardware run writing zeros without attention.1214	01137	6 07303	0032		XMIT	SECPT,IVL/WRSPMA	Addr of last sector no + 11215	01140	0 00000	0000		NOP				Wait for address to settle1216	01141	0 37000	0000		MOVE	SPD,0,AUX1217	01142	3 02002	0000		XOR	WRKR,WRKR		Last sector of track?1218	01143	5 02145	0000		NZT	WRKR,*+2		No-step sec & label1219	01144	7 01146	0000		JMP	*+2			Expand to prevent1220	01145	7 01205	0000		JMP	FRDTAH				page error1221					*We are at the end of a track1222					* continue to write zeros to the end of the track1223	01146	5 24106	0005		NZT	24H,1,*/,,DSKST		Wait for index1224	01147	0 00000	0000		NOP1225	01150	6 07000	0048		XMIT	0,IVL/INDXOF		Index off1226					*Write two words after index to cover any unwritten area just1227					*  when format starts1228	01151	5 21111	0002		NZT	21H,1,*/,,FIFSTA		Wait for BDONE1229	01152	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01230	01153	0 00000	0000		NOP1231	01154	5 21114	0002		NZT	21H,1,*/,,FIFSTA		Wait for BDONE1232	01155	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01233	01156	0 00000	0000		NOP1234	01157	5 21117	0002		NZT	21H,1,*/,,FIFSTA		Wait for BDONE1235	01160	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01236	01161	0 00000	0000		NOP1237	01162	5 21122	0002		NZT	21H,1,*/,,FIFSTA		Wait for BDONE1238	01163	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01239	01164	6 07201	0144		XMIT	RSWG,IVL/WRDC2		write gate off1240	01165	6 07220	0112		XMIT	90X,IVL/WRMAC		write ended1241					*Any more tracks to format?1242	01166	6 07350	0032		XMIT	TKFH,IVL/WRSPMA		Address of no of tracks to format1243	01167	0 00000	0000		NOP				Wait for address to settle1244	01170	0 37006	0000		MOVE	SPD,0,DTXHI		Get hi part1245	01171	6 07351	0032		XMIT	TKFL,IVL/WRSPMA		Address of no of tracks to format1246	01172	6 00001	0000		XMIT	1,AUX1247	01173	0 37005	0000		MOVE	SPD,0,DTXLO		Get Lo part1248	01174	1 05005	0000		ADD	DTXLO,DTXLO1249	01175	0 10000	0000		MOVE	OVF,AUX1250	01176	1 06006	0000		ADD	DTXHI,DTXHI		Add in cary1251	01177	0 05017	0000		MOVE	DTXLO,IVR		Put lo part back1252	01200	6 07350	0032		XMIT	TKFH,IVL/WRSPMA		Address of hi part1253	01201	0 06017	0000		MOVE	DTXHI,IVR		Hi part back1254						ORG	12,2561255	01202	5 05212	0000		NZT	DTXLO,FRDTAJ		Format not over1256	01203	5 06212	0000		NZT	DTXHI,FRDTAJ		Format not over1257	01204	7 01222	0000		JMP	OPCMP			Format ended1258					*Format next sector1259	01205	6 11106	0000	FRDTAH	CALL	NXTSE		Next sector no, head, cylinder1260	01206	7 02725	00001261	01207	5 15216	0000		NZT	IMMER,FMTER		has an error occured? 1262	01210	6 07000	0064		XMIT	0,IVL/WDDATA		Write zeros1263	01211	7 00756	0000		JMP	WIG3			format next sector1264					* Format next track1265	01212	6 11107	0000	FRDTAJ	CALL	NXTSE		Next sector no, head, cylinder1266	01213	7 02725	00001267	01214	5 15216	0000		NZT	IMMER,FMTER		has an error occured? 1268	01215	7 00730	0000		JMP	D			Format next track after next index1269					*1270	01216	0 00000	0000	FMTER	NOP1271					*TST Next 2 cmds operate RDC LED Display1272					*	XMIT	50X,IVL/WRRDSP1273					*	XMIT	50X,IVL/WRRDSP		Send AF to rt Disp1274	01217	0 15016	0000		MOVE	IMMER,ERRTYP1275	01220	7 01314	0000		JMP	EREND1276					*1277					*1278					*Move CurCyl into FCurCyl; put current drive & controller1279					*  status into dCB1280	01221	0 00000	0000	OPEND	NOP1281	01222	6 07275	0176	OPCMP	XMIT	0BDX,IVL/WRSTAT		Execut done to IOP1282					*TST Next 2 cmds operate RDC LED Display1283					*	XMIT	0D0X,IVL/WRRDSP1284					*	XMIT	0D0X,IVL/WRRDSP		Send 2F to Rd Disp1285					*Put Drive Status & Controler Status into SP for Disk Control Block1286	01223	6 07344	0032		XMIT	DVST,IVL/WRSPMA		Address of DriveStatus1287	01224	0 27002	0005		MOVE	27H,0,WRKR/,,DSKST1288	01225	0 02017	0000		MOVE	WRKR,IVR		DiskStatus to DCB1289	01226	6 07345	0032		XMIT	CNTST,IVL/WRSPMA	Address of Controller status1290	01227	0 27002	0002		MOVE	27H,0,WRKR/,,FIFSTA	FIFO, etc, status1291	01230	0 02017	0000		MOVE	WRKR,IVR		Status into DCB1292						ORG	5,2561293					*Deselect drive UNLESS WriteFault on- if on, error1294	01231	0 26102	0005		MOVE	26H,1,WRKR/,,DSKST	Look at WriteFault1295	01232	5 02235	0000		NZT	WRKR,CMPSI		Xfr if not WriteFault1296	01233	6 07075	0176		XMIT	3DX,IVL/WRSTAT		Send execute done error1297	01234	7 01325	0000		JMP	GERENB			Mark WriteFaultError1298	01235	6 07377	0080	CMPSI	XMIT	377H,IVL/WRDC1		Deselect drive,sel hd 01299					* Make FCurCyl = CurCyl1300	01236	6 07242	0032	CMPSJ	XMIT	CURCLH,IVL/WRSPMA	Address of CurCyl, hi1301	01237	0 00000	0000		NOP				Wait for address to settle1302	01240	0 37002	0000		MOVE	SPD,0,WRKR1303	01241	6 07330	0032		XMIT	FCURCH,IVL/WRSPMA	Address of FCurCyl, hi1304	01242	0 02017	0000		MOVE	WRKR,IVR		Hi part moved1305	01243	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA1306	01244	0 00000	0000		NOP				Wait for address to settle1307	01245	0 37002	0000		MOVE	SPD,0,WRKR1308	01246	6 07331	0032		XMIT	FCURCL,IVL/WRSPMA1309	01247	0 02017	0000		MOVE	WRKR,IVR		Lo part moved1310					*Send interrupt to IOP1311	01250	6 07000	0144		XMIT	STRINT,IVL/WRDC2		Set Rigid Disk interrupt1312	01251	7 00042	0000		JMP	PML			To Protocol hnadler1313					*1314					*1315					*DIAGNOSTIC Following is a Diagnostic Display1316						ORG	31,2561317	01252	6 15274	0000	IOCBST	XMIT	DTAECC,R15		Start of IOCB1318	01253	6 00001	0000	OPCMPA	XMIT	1,AUX1319	01254	0 15007	0032		MOVE	R15,IVL/WRSPMA		Address in SP1320	01255	0 00000	0000		NOP				Wait for address to settle1321	01256	0 37012	0008		MOVE	SPD,0,R12/,1		Goes to R0, INCR SPMA1322	01257	1 15015	0000		ADD	R15,R15			Next address1323	01260	0 37001	0008		MOVE	SPD,0,R1/,11324	01261	1 15015	0000		ADD	R15,R151325	01262	0 37002	0008		MOVE	SPD,0,R2/,11326	01263	1 15015	0000		ADD	R15,R151327	01264	0 37003	0008		MOVE	SPD,0,R3/,11328	01265	1 15015	0000		ADD	R15,R15			Next address1329	01266	0 37004	0008		MOVE	SPD,0,R4/,11330	01267	1 15015	0000		ADD	R15,R151331	01270	0 37005	0008		MOVE	SPD,0,R5/,11332	01271	1 15015	0000		ADD	R15,R151333	01272	0 37006	0008		MOVE	SPD,0,R6/,11334	01273	1 15015	0000		ADD	R15,R151335	01274	0 37016	0000		MOVE	SPD,0,R161336	01275	1 15015	0000		ADD	R15,R151337	01276	6 00352	0000		XMIT	0EAX,AUX		Skip this address1338	01277	3 15013	0000		XOR	R15,R13			There yet?1339	01300	6 00001	0000		XMIT	1,AUX1340	01301	5 13304	0000		NZT	R13,OPCMPB1341	01302	1 15015	0000		ADD	R15,R151342	01303	0 37000	0008		MOVE	SPD,0,R0/,1		Incr SPMA throw away data1343	01304	0 12000	0000	OPCMPB	MOVE	R12,R0			1st one in R01344	01305	0 00000	0000	BPHR	NOP				Put a BS in here somewhere1345	01306	0 00000	0000		NOP1346	01307	0 00000	0000		NOP1347	01310	0 00000	0000		NOP	1348	01311	0 00000	0000		NOP1349	01312	7 01253	0000		JMP	OPCMPA1350	01313	7 01313	0000		HALT1351					*1352					*Error handlers1353	01314	6 07075	0176	EREND	XMIT	3DX,IVL/WRSTAT		Send execute done error1354					*Put Drive Status & Controler Status into SP for Disk Control Block1355	01315	6 07344	0032	GEREND	XMIT	DVST,IVL/WRSPMA		Address of DriveStatus1356	01316	0 27002	0005		MOVE	27H,0,WRKR/,,DSKST1357	01317	0 02017	0000		MOVE	WRKR,IVR		DiskStatus to DCB1358	01320	6 07345	0032		XMIT	CNTST,IVL/WRSPMA	Address of Controller status1359	01321	0 27002	0002		MOVE	27H,0,WRKR/,,FIFSTA	FIFO, etc, status1360	01322	0 02017	0000		MOVE	WRKR,IVR		Status into DCB1361					*If WriteFault on, set type 85 error1362	01323	0 26102	0005		MOVE	26H,1,WRKR/,,DSKST	Look at WriteFault1363	01324	5 02326	0000		NZT	WRKR,GERENA		Xfr if not WriteFault1364	01325	6 16205	0000	GERENB	XMIT	85X,ERRTYP		type 85 error1365					*put error type into SP for DiskOpBlock1366	01326	6 07327	0032	GERENA	XMIT	LSTERT,IVL/WRSPMA	Address of LastErrorType1367	01327	0 16017	0000		MOVE	ERRTYP,IVR		Errortype into LastErrorType1368					*Send interrupt to IOP, go to PML1369	01330	7 01236	0000		JMP	CMPSJ1370					*1371					*1372					*1373					**************************************1374					*1375					*    Procedure  WTCRS     Wait for Command Register Same1376					*1377					*      Wait until the command register does not change for 3 readings,1378					*		then return1379					*1380					* 	When return, the Command Register contents are in1381					*		DTARG1382					*1383					*	Uses DTARG and WRKR1384					*1385					*******************************************1386						PROC	WTCRS1387						ORG	6,2561388	01331	0 27004	0003	WTCRA	MOVE	27H,0,DTARG/,,RDCTL1389	01332	0 04000	0000		MOVE	DTARG,AUX1390	01333	3 27002	0003	WTCRB	XOR	27H,0,WRKR/,,RDCTL1391	01334	5 02331	0000		NZT	WRKR,WTCRA		Not same-try again1392	01335	3 27002	0003	WTCRC	XOR	27H,0,WRKR/,,RDCTL1393	01336	5 02331	0000		NZT	WRKR,WTCRA		Not same-try again1394	01337	7 03611	0000		RTN1395						END	WTCRS1396					*1397					*1398					*1399					*********************************************1400					* PROCEDURE STEPS   REV  July 30, 1984  1401					*1402					* Steps drive head no of steps in Double Precision word1403					* with Hi byte in DTXHI and lo byte in DTXLO.  Drection1404					* MUST already be set up.  USES WRKR.1405					* At end, string of step pulses has been sent to drive.1406					* Drive is stepping, and will indicate end stepping when1407					* SEEK COMPLETED signal goes true.1408					********************************************1409						PROC	STEPS1410						ORG	19,256			ALLIGN WITH PAGE BOUNDRY1411	01340	5 21200	0005	STP	NZT	21H,2,STP/,,DSKST	Wait until Ready & SeekComp1412	01341	6 02370	0000	STPA	XMIT	-8,WRKR		Pulse width1413	01342	6 07004	0144		XMIT	STSTP,IVL/WRDC2	Step On1414	01343	6 00001	0000		XMIT	1,AUX1415	01344	1 02002	0000	STPB	ADD	WRKR,WRKR1416	01345	5 02344	0000		NZT	WRKR,STPB	Wait for 3.5 uSec1417	01346	6 07204	0144		XMIT	RSSTP,IVL/WRDC2	Step Off1418	01347	6 02360	0000		XMIT	-16,WRKR	Pulse Off Width1419	01350	1 02002	0000	STPC	ADD	WRKR,WRKR1420	01351	5 02350	0000		NZT	WRKR,STPC	Wait for 32 cmds; total 50 cmds, 10 uSec1421					*Double Precision subtract 1 follows1422	01352	6 00377	0000		XMIT	-1,AUX1423	01353	1 05005	0000		ADD	DTXLO,DTXLO1424	01354	0 10000	0000		MOVE	OVF,AUX1425	01355	1 06006	0000		ADD	DTXHI,DTXHI1426	01356	6 00377	0000		XMIT	-1,AUX1427	01357	1 06006	0000		ADD	DTXHI,DTXHI1428					*  If DTXHI & DTXLO both = 0, seek  pulse string is over1429	01360	5 05341	0000		NZT	DTXLO,STPA1430	01361	5 06341	0000		NZT	DTXHI,STPA	1431	01362	7 03611	0000		RTN1432						END	STEPS1433					*1434					****************************************************1435					*1436					*PROCEDURE RESTR   REV July 30, 1984  1437					*1438					*RESTORES THE DISK TO TRK 0001439					* USES WRKR & DTARG, CALLS STEPS1440					*1441					*****************************************************1442						PROC	RESTR1443						ORG	10,321444	01363	6 07202	0144	RST	XMIT	STDOT,IVL/WRDC2		Direction Out1445	01364	0 11013	0000		MOVE	R11,R13			STORE RETURN1446	01365	6 05001	0000	RSTA	XMIT	1,DTXLO1447	01366	6 06000	0000		XMIT	0,DTXHI1448	01367	6 11110	0000		CALL	STEPS			Step Disk 1 Step1449	01370	7 01340	00001450	01371	5 21231	0005	RSTB	NZT	21H,2,RSTB/,,DSKST	Wait until Ready & SeekComp1451	01372	5 25125	0005		NZT	25H,1,RSTA/,,DSKST	Not Trk000, step again1452	01373	0 13011	0000		MOVE	R13,R11			Restore Rreturn pointer1453	01374	6 07205	0144		XMIT	RSWPC,IVL/WRDC2		Precomp off1454	01375	7 03611	0000	 	RTN1455						END	RESTR1456					*1457					*************************************************1458					*PROCEDURE  IMPSK--Implied Seek-- July 30, 1984-1459					* Tests Current Cylinder No.  If it is FFFF, current cyl no is unknown, 1460					*	recalibrate necessary.  This is indicated by IMMER = FF1461					* Tests CurCyl vs Target Cylinder.  If they are the same, exits.1462					* Subtracts CurCyl from TgtCyl, Which is Cyl No. in header image,1463					*	determines direction to step and distance.  Calls steps1464					* Upon return from Steps, drive is steping.  Puts FFFF into curCyl,1465					*	indicating unknown value.1466					* When SEEK COMPLETE goes true, puts Target Cyl into CurCyl, exits.1467					*1468					*1469					*  This procedure is a SECOND LEVEL PROCEDURE, it cals another1470					* procedure.  Therefore, This procedure's return point must be saved1471					* & restored using R13 1472					*******************************************************1473					*1474					*1475						PROC	IMPSK1476	01376	0 11013	0000		MOVE	R11,R13		Save return pointer1477					*Get CurCyl and Target Cylinder nos1478	01377	6 07242	0032	SKGTCL	XMIT	CURCLH,IVL/WRSPMA	Address of CURCLH1479	01400	0 00000	0000		NOP				Wait for address to settle1480	01401	0 37004	0000		MOVE	SPD,0,SH1481	01402	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA1482	01403	0 00000	0000		NOP				Wait for address to settle1483	01404	0 37003	0000		MOVE	SPD,0,SL1484	01405	6 07334	0032		XMIT	HDCYH,IVL/WRSPMA1485	01406	0 00000	0000		NOP				Wait for address to settle1486	01407	0 37006	0000		MOVE	SPD,0,MH1487	01410	6 07335	0032		XMIT	HDCYL,IVL/WRSPMA1488	01411	0 00000	0000		NOP				Wait for address to settle1489	01412	0 37005	0000		MOVE	SPD,0,ML1490					*Is CurCyl = FFFF?  If so, error.  Make IMMER & ERRTYP = 84.1491	01413	6 00377	0000		XMIT	377H,AUX1492	01414	3 04002	0000		XOR	SH,WRKR1493						ORG	12,2561494	01415	5 02021	0000		NZT	WRKR,SKNCUK		Not cyl unknown, continue1495	01416	3 03002	0000	SPCLUK	XOR	SL,WRKR			SH = FF, possible error1496	01417	5 02021	0000		NZT	WRKR,SKNCUK		Not cyl unknown, continue1497	01420	7 01503	0000		JMP	SKCLUK			SL = FF, error1498					* ARE CurCyl & Target Cyl =?  If so, exit1499	01421	0 04000	0000	SKNCUK	MOVE	SH,AUX1500	01422	3 06002	0000		XOR	MH,WRKR1501	01423	5 02030	0000		NZT	WRKR,SKNEQ		Cyl Nos not equal1502	01424	0 03000	0000	SPNCUK	MOVE	SL,AUX1503	01425	3 05002	0000		XOR	ML,WRKR1504	01426	5 02030	0000		NZT	WRKR,SKNEQ		Cyl nos not equal1505	01427	7 01501	0000		JMP	SKOVR			Cyl nos =, exit1506					*now subtract cylinder nos, determine step direction, seek1507	01430	6 11111	0000	SKNEQ	CALL	DPSUB			Subtract cyl nos1508	01431	7 01506	00001509					*If SIGN = 0, direction is IN, otherwise OUT1510					*remainder is in proper form for  Proc STEPS1511	01432	5 01035	0000		NZT	SIGN,STPOUT1512	01433	6 07002	0144		XMIT	STDIN,IVL/WRDC2		Set step direction IN1513	01434	7 01436	0000		JMP	*+21514	01435	6 07202	0144	STPOUT	XMIT	STDOT,IVL/WRDC2		Set step direction OUT1515					*Now call STEPS1516	01436	6 11112	0000		CALL	STEPS		Deliver string of STEP pulses to drive1517	01437	7 01340	00001518					*now set CurCyl to FFFF, unknown1519	01440	6 07242	0032		XMIT	CURCLH,IVL/WRSPMA1520	01441	6 17377	0000		XMIT	377H,IVR1521	01442	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA1522	01443	6 17377	0000		XMIT	377H,IVR1523					*1524					*Now Set/Reset Write Precomp1525					*Is current cylinder no = or greater than Precomp cyl?1526					*Subtract CurCyl from Precomp Cyl. If result is negative,1527					*    reset Precomp; if not, set Precomp1528					*    use procedure DPSUB1529					*1530					*Put PrecompCyl in MH & ML; put Current cyl in SH & SL1531	01444	6 07334	0032	INPPC	XMIT	HDCYH,IVL/WRSPMA	Address of curCyl H1532	01445	0 00000	0000		NOP				Wait for addrss to settle1533	01446	0 37004	0000		MOVE	SPD,0,SH		Get data1534	01447	6 07335	0032		XMIT	HDCYL,IVL/WRSPMA	Address of CurCyl L1535	01450	0 00000	0000		NOP				Wait for addrss to settle1536	01451	0 37003	0000		MOVE	SPD,0,SL1537	01452	6 07314	0032		XMIT	PCCYH,IVL/WRSPMA	Address of PrecompCyl H1538	01453	0 00000	0000		NOP				Wait for addrss to settle1539	01454	0 37006	0000		MOVE	SPD,0,MH		Get data1540	01455	6 07315	0032		XMIT	PCCYL,IVL/WRSPMA	Address of PrecompCyl L1541	01456	0 00000	0000		NOP				Wait for addrss to settle1542	01457	0 37005	0000		MOVE	SPD,0,ML1543	01460	6 11113	0000		CALL	DPSUB			DoublePrecisonSubtract1544	01461	7 01506	00001545						ORG	4,321546	01462	5 01065	0000		NZT	SIGN,INPPA		sign of remainder1547	01463	6 07205	0144		XMIT	RSWPC,IVL/WRDC2	Reset Precomp1548	01464	7 01466	0000		JMP	SKCMP1549	01465	6 07005	0144	INPPA	XMIT	STWPC,IVL/WRDC2	Set Precomp1550					*1551					*Now wait for READY & SEEK COMPLETE 1552	01466	5 21226	0005	SKCMP	NZT	21H,2,SKCMP/,,DSKST	Wait until READY & SEEK COMPLETE1553					*Now put target Cyl into CurCyl1554	01467	6 07334	0032		XMIT	HDCYH,IVL/WRSPMA1555	01470	0 00000	0000		NOP				Wait for addrss to settle1556	01471	0 37002	0000		MOVE	SPD,0,WRKR1557	01472	6 07242	0032		XMIT	CURCLH,IVL/WRSPMA1558	01473	0 02017	0000		MOVE	WRKR,IVR1559	01474	6 07335	0032		XMIT	HDCYL,IVL/WRSPMA1560	01475	0 00000	0000		NOP				Wait for addrss to settle1561	01476	0 37002	0000		MOVE	SPD,0,WRKR1562	01477	6 07243	0032		XMIT	CURCLL,IVL/WRSPMA1563	01500	0 02017	0000		MOVE	WRKR,IVR1564					*1565					*Seek completed, return1566					*1567	01501	0 13011	0000	SKOVR	MOVE	R13,R11			Restore return pointer1568	01502	7 03611	0000		RTN1569					*1570	01503	6 15204	0000	SKCLUK	XMIT	84X,IMMER1571	01504	6 16204	0000		XMIT	84X,ERRTYP1572	01505	7 01501	0000		JMP	SKOVR1573					*1574						END	IMPSK1575					*1576					*************************************************1577					*PROC  DPSUB   July 30, 1984  1:23 PM1578					*DOES DOUPLE PRECISION SUBTRACT WITH1579					*RESULT IN SIGN - MAGNITUDE FORM1580					*1581					*Uses regs MH = R6 = DTXHI; ML = R5 = DTXLO;1582					*	SH = R4 = DTARG; SL = R3 = STATRG;1583					*	SIGN = R1 = CNTRG; WRKR1584					*1585					* To start, the minuend (number subtracted from) is in 1586					*	MH & ML, with the high order byte in MH, &1587					*	the subtrahend (number subtracted)1588					*	is in SH & SL, all in unsigned (assumed positive)1589					*	binary form.  At return, the remainder is in1590					*	sign - magnitude form. MH & ML contain the 1591					*	remainder, with the high order byte in MH,1592					*	and SIGN contains the sign; 0 = positive and1593					*	1 = negative. This form is required for the step1594					*	procedure. 1595					*1596					*******************************************************1597					*1598						PROC	DPSUB1599					*1600					* Set SIGN for positive result1601					*1602	01506	6 01000	0000		XMIT	0,SIGN1603					*1604					* Form 2's compliment of subtrahend1605					*1606	01507	6 00377	0000		XMIT	377H,AUX1607	01510	3 04004	0000		XOR	SH,SH1608	01511	3 03003	0000		XOR	SL,SL1609	01512	6 00001	0000		XMIT	1,AUX1610	01513	1 03003	0000		ADD	SL,SL1611	01514	0 10000	0000		MOVE	OVF,AUX1612	01515	1 04004	0000		ADD	SH,SH1613					*1614					* Now add1615					*1616	01516	0 03000	0000		MOVE	SL,AUX1617	01517	1 05005	0000		ADD	ML,ML1618	01520	0 10000	0000		MOVE	OVF,AUX1619	01521	1 06006	0000		ADD	MH,MH1620	01522	0 04000	0000		MOVE	SH,AUX1621	01523	1 06006	0000		ADD	MH,MH1622					*1623					* Now test for negative result; If MSB of MH = 1, result is negative1624					*	if MSB of MH = 0, result is positive1625					*1626						ORG	13,2561627	01524	6 00200	0000		XMIT	200H,AUX	Mask for MSB1628	01525	2 06002	0000		AND	MH,WRKR	MSB alone1629	01526	5 02130	0000		NZT	WRKR,*+2	MSB of MH = 1, Recomplement result1630	01527	7 01540	0000		JMP	RSP		MSB of MH = 0, result is positive1631	01530	6 00377	0000		XMIT	377H,AUX	MSB of MH = 1, Recomplement result1632	01531	3 05005	0000		XOR	ML,ML1633	01532	3 06006	0000		XOR	MH,MH1634	01533	6 00001	0000		XMIT	1,AUX1635	01534	1 05005	0000		ADD	ML,ML1636	01535	0 10000	0000		MOVE	OVF,AUX1637	01536	1 06006	0000		ADD	MH,MH1638					*1639	01537	6 01001	0000		XMIT	1,SIGN		Set SIGN negative1640	01540	7 03611	0000	RSP	RTN1641						END	DPSUB1642					*1643					*1644					**********************************************************1645					*PROCEDURE  SELHD, - Sellect Head & Drive1646					*Initial version,  August 1, 19841647					* USE ONLY AT BEGINING OF OPRATION & IN IMPSK1648					*1649					*Sellect head using HD byte in header image.1650					*Sellect drive-always drive 01651					*Set CRC; Reset WriteGate & Loopback,1652					* Set/Reset/Ignore ReduceWriteCurrent1653					* Set/Reset Precomp is done in procedure IMPSK1654					*1655					* Uses  WRKR, DTARG1656					*This procedure calls another procedure and 1657					*   keeps its return pointer in R131658					**********************************************************1659					*1660					*!!! Add part to delay 30 bytes if Head Number Changeed1661					*1662					**********************************************************1663					*1664						PROC	SELHD1665	01541	6 07201	0144		XMIT	RSWG,IVL/WRDC2		Reset WriteGate1666	01542	0 11013	0000		MOVE	R11,R13			Keep return pointer1667					*1668					*If ReduceWriteCurrent word is FFFF, reduce write current not required1669					*by drive1670					*1671	01543	6 07312	0032		XMIT	WICYH,IVL/WRSPMA	Address of hi part of RedICur1672	01544	6 00377	0000		XMIT	377H,AUX1673	01545	3 37004	0000		XOR	SPD,0,DTARG		Get RWC byte1674					*1675						ORG	13,321676	01546	5 04172	0000		NZT	DTARG,SERWT		Possible RWC,Test it1677	01547	6 07313	0032		XMIT	WICYL,IVL/WRSPMA	Address of lo part of RedICur1678	01550	6 01000	0000		XMIT	0,SIGN			make sure is zero if did not go to SERWT1679	01551	3 37004	0000		XOR	SPD,0,DTARG		1st byte FF, test other byte1680	01552	5 04172	0000		NZT	DTARG,SERWT		Possible RWC,Test it1681					*1682	01553	6 07336	0032	SELA	XMIT	HDHD,IVL/WRSPMA		Address of head byte1683	01554	6 00020	0000		XMIT	020H,AUX		Drive sellect bit1684	01555	0 37002	0000		MOVE	SPD,0,WRKR		Get head number1685	01556	1 02002	0000		ADD	WRKR,WRKR		Word with hd & drive sellect1686	01557	5 01162	0000		NZT	SIGN,SERWTA		sign of remainder1687	01560	6 00000	0000		XMIT	0,AUX			Reset RedWtCur1688	01561	7 01563	0000		JMP	SERWTB1689	01562	6 00010	0000	SERWTA	XMIT	010H,AUX		Value to Set RedWtCur1690	01563	1 02002	0000	SERWTB	ADD	WRKR,WRKR1691	01564	6 00377	0000	SECRC	XMIT	377H,AUX		DC1 output is inverted1692	01565	3 02007	0080		XOR	WRKR,IVL/WRDC1		Set up Disk Control Reg 11693					*Reduce Write Current word is FFFF, reduce write current signal is not used1694					*Now set CRC, reset Loopback1695	01566	6 07007	0144		XMIT	STCRC,IVL/WRDC2		Set CRC-for header1696	01567	6 07203	0144		XMIT	RSLPB,IVL/WRDC2		Loopback off1697					*1698	01570	0 13011	0000		MOVE	R13,R11			Restore return pointer1699	01571	7 03611	0000		RTN1700					*1701					*Is current cylinder no = or greater than Reduce Write Current cyl?1702					*Subtract CurCyl from Reduce Write Cyl. If result is negative,1703					*    reset ReduceWriteCurrent; if not, set ReduceWriteCurrent1704					*    use procedure DPSUB1705					*1706					*Put RWCyl in MH & ML; put Current cyl in SH & SL1707					**********************************************************1708					*1709	01572	6 07334	0032	SERWT	XMIT	HDCYH,IVL/WRSPMA	Address of curCyl H1710	01573	0 00000	0000		NOP				Wait for address to settle1711	01574	0 37004	0000		MOVE	SPD,0,SH		Get data1712	01575	6 07335	0032		XMIT	HDCYL,IVL/WRSPMA	Address of curCyl L1713	01576	0 00000	0000		NOP				Wait for address to settle1714	01577	0 37003	0000		MOVE	SPD,0,SL1715	01600	6 07312	0032		XMIT	WICYH,IVL/WRSPMA	Address of RedWtCurCyl H1716	01601	0 00000	0000		NOP				Wait for address to settle1717	01602	0 37006	0000		MOVE	SPD,0,MH		Get data1718	01603	6 07313	0032		XMIT	WICYL,IVL/WRSPMA	Address of RedWtCurCyl L1719	01604	0 00000	0000		NOP				Wait for address to settle1720	01605	0 37005	0000		MOVE	SPD,0,ML1721	01606	6 11114	0000		CALL	DPSUB			DoublePrecisonSubtract1722	01607	7 01506	00001723	01610	7 01553	0000		JMP	SELA1724					*1725						END	SELHD1726					*1727					*1728					*****************************************1729					*1730					*PROCEDURE WTINST1731					*1732					*Wait a number of instructions1733					*1734					* -No of instruction times to wait in DTARG.1735					* count of -4 = 1 byte time; housekeeping1736					*   takes 1/2 byte1737					*1738					* uses R11, return pointer; DTARG; AUX1739					*  Generates no errors1740					*1741					*******************************************1742					*1743						PROC	WTINST1744	01611	6 00001	0000		XMIT	1,AUX1745	01612	1 04004	0000	WTINLP	ADD	DTARG,DTARG1746	01613	5 04212	0000		NZT	DTARG,WTINLP1747	01614	7 03611	0000		RTN1748						END	WTINST1749					*1750					*1751					*********************************************1752					*1753					* PROCEDURE WG--WRITE GAP 1754					*1755					* USES STATRG, AUX1756					* DTARG CONTAINS -NO OF BYTES IN GAP1757					*1758					************************************************1759						PROC WG1760						ORG	5,2561761	01615	6 00001	0000	WGA	XMIT	1,AUX1762	01616	5 21116	0002	WGB	NZT	21H,1,WGB/,,FIFSTA	Wait for BDONE1763	01617	6 07000	0064		XMIT	0,IVL/WDDATA		Write 01764	01620	1 04004	0000		ADD	DTARG,DTARG1765	01621	5 04216	0000		NZT	DTARG,WGB		Loop until all bytes written1766	01622	7 03611	0000		RTN1767						END	WG1768					*1769					*************************************************1770					*1771					*PROCEDURE  RFFCK1772					*1773					*Procedure Read FIFO Check1774					*1. Check FIFO status1775					*	a. If FIFFM flag is not 0, FIFFM Flag _ 0 and read sector1776					*	b. If FIFO is EMPTY, FIFFM Flag _ 1 & read sector1777					*	c. If FIFO is FULL, loop to 1. 1778					*		ERROR IF 4 index pulses1779					*	d. If a1b1 test gives not half empty, loop on 1. 1780					*2. Read sector1781					*1782					*	USES CNTR1783					*1784					*	First level procedure-calls no other procedure1785					*	At exit, if IMMER is NOT = 0, an error has occured1786					*1787					***********************************************1788					*1789						PROC	RFFCK1790	01623	6 15000	0000		XMIT	0,IMMER1791	01624	6 07001	0048		XMIT	1,IVL/INDXOF		Reset index1792	01625	6 07241	0032		XMIT	FIFFM,IVL/WRSPMA	SPMA1793	01626	6 01374	0000		XMIT	-4,CNTRG		Setup to count indexes1794					*1795	01627	7 01640	0000		ORG	20,321796	01640	5 37014	0000	RFFFA	NZT	SPD,0,RFXRD		 IF FIFFM = 1, FIFFM _ 0 & Rd Sector1797	01641	5 26112	0002	RFFFB	NZT	26H,1,RFFM/,,FIFSTA	Is FIFO mpty?1798	01642	5 27117	0002		NZT	27H,1,RFFF/,,FIFSTA	Is FIFO Full?1799	01643	5 25105	0002		NZT	25H,1,*+2/,,FIFSTA	To RFFFB if a1#b11800	01644	7 01641	0000		JMP	RFFFB1801	01645	5 25107	0002		NZT	25H,1,*+2/,,FIFSTA	To RFFFB if a1#b11802	01646	7 01641	0000		JMP	RFFFB1803	01647	5 25111	0002		NZT	25H,1,*+2/,,FIFSTA	To RFFFB if a1#b11804	01650	7 01641	0000		JMP	RFFFB1805	01651	7 01655	0000		JMP	RFFR			Read sector1806					*1807	01652	6 17001	0000	RFFM	XMIT	1,IVR			FIFFM Flag _ 11808	01653	7 01655	0000		JMP	RFFR			Read Sector1809					*1810	01654	6 17000	0000	RFXRD	XMIT	0,IVR			FIFFM Flag _ 01811					*1812	01655	6 01000	0000	RFFR	XMIT	0,CNTRG			zero index cntr1813	01656	7 03611	0000		RTN				Return & read sector1814					*1815	01657	6 00001	0000	RFFF	XMIT	1,AUX1816	01660	5 24100	0005		NZT	24H,1,RFFFA/,,DSKST	Index? if not, try again1817	01661	6 07001	0048		XMIT	1,IVL/INDXOF		Reset Index1818	01662	1 01001	0000		ADD	CNTRG,CNTRG		count indexes1819	01663	5 01240	0000		NZT	CNTRG,RFFFA		4 indexes while FIFO Full1820					*1821	01664	6 16004	0000	RFFER	XMIT	04X,ERRTYP1822	01665	6 15004	0000		XMIT	04X,IMMER1823	01666	7 01655	0000		JMP	RFFR			Exit with error1824					*1825						END	RFFCK1826					*1827					*************************************************1828					*1829					*PROCEDURE  WFFCK1830					*1831					*Procedure Write FIFO Check1832					*1. Check FIFO Empty at Last Read.1833					*	If empty at last read or if FirstWriteFlag = 1,1834					*		wait until not empty & then do prelim 1835					*		FIFO read1836					*2. Check FIFO status1837					*	a. If FIFFM flag is not 0, FIFFM Flag _ 0 and write sector1838					*	b. If FIFO is FULL, FIFFM Flag _ 1 & write sector1839					*	c. If FIFO is EMPTY, loop to 2. 1840					*		ERROR IF 4 index pulses1841					*	d. If a1b1 test gives not half full, loop on 2. 1842					*3. Write sector1843					*1844					*	USES CNTR1845					*1846					*	First level procedure-calls no other procedure1847					*	At exit, if IMMER is NOT = 0, an error has occured1848					*1849					***********************************************1850					*1851						PROC	WFFCK1852	01667	6 15000	0000		XMIT	0,IMMER1853	01670	6 01374	0000		XMIT	-4,CNTRG		Setup to count indexes1854	01671	6 07001	0048		XMIT	1,IVL/INDXOF		Reset index1855	01672	0 22103	0002		MOVE	22H,1,STATRG/,,FIFSTA	Was FIFO Empty at Last Read?1856	01673	5 03317	0000		NZT	STATRG,WFFA		Empty at LR, Wait1857	01674	6 07251	0032		XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag1858	01675	0 00000	0000		NOP				Wait for address to settle1859	01676	7 01700	0000		ORG	18,321860	01700	5 37017	0000		NZT	SPD,0,WFFA		FirstWriteFlag = 1, Prelim read1861					*1862					* Note: If FIFO is Empty at Last Read, we are at the1863					*	start of this write operation.  If FIFO does1864					*	not go notEmpty within 4 revolutions of the disk,1865					*	something is wrong1866					*1867	01701	6 07241	0032	WFFB	XMIT	FIFFM,IVL/WRSPMA	SPMA1868	01702	0 00000	0000		NOP				Wait for address to settle1869						ORG	16,321870	01703	5 37014	0000	WFFFA	NZT	SPD,0,WFXRD	 IF FIFFM = 1, FIFFM _ 0 & Wt Sector1871	01704	5 26104	0002		NZT	26H,1,*/,,FIFSTA	Wait while FIFO mpty1872					* Note: If FIFO was not empty at LastRead and is empty now,1873					*	we are between sectors1874	01705	5 27112	0002	WFFFB	NZT	27H,1,WFFF/,,FIFSTA		Is FIFO Full?1875	01706	5 25105	0002		NZT	25H,1,WFFFB/,,FIFSTA	To WFFFA if a1=b11876	01707	5 25105	0002		NZT	25H,1,WFFFB/,,FIFSTA	To WFFFA if a1=b11877	01710	5 25105	0002		NZT	25H,1,WFFFB/,,FIFSTA	To WFFFA if a1=b11878	01711	7 01715	0000		JMP	WFFR			Write sector1879					*1880	01712	6 17001	0000	WFFF	XMIT	1,IVR		FIFFM Flag _ 11881	01713	7 01715	0000		JMP	WFFR		Write Sector1882					*1883	01714	6 17000	0000	WFXRD	XMIT	0,IVR		FIFFM Flag _ 01884					*1885	01715	6 01000	0000	WFFR	XMIT	0,CNTRG		zero index cntr1886	01716	7 03611	0000		RTN			Return & write sector1887					*1888	01717	5 26124	0002	WFFA	NZT	26H,1,WFFM/,,FIFSTA	Wait while FIFO mpty1889	01720	6 07251	0032		XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag1890	01721	6 17000	0000		XMIT	0,IVR			Make flag = 01891	01722	0 27004	0006		MOVE	27H,0,DTARG/,,RDFLO	Dummy Read,Cycle FIFO1892	01723	7 01701	0000		JMP	WFFB1893	01724	6 00001	0000	WFFM	XMIT	1,AUX1894	01725	5 24117	0005		NZT	24H,1,WFFA/,,DSKST	Index? if not, try again1895	01726	6 07001	0048		XMIT	1,IVL/INDXOF		Reset Index1896	01727	1 01001	0000		ADD	CNTRG,CNTRG		count indexes1897	01730	5 01317	0000		NZT	CNTRG,WFFA		Test FIFO Stat again1898					*1899	01731	6 16005	0000	WFFER	XMIT	05X,ERRTYP		4 indexes while FIFO Empty1900	01732	6 15005	0000		XMIT	05X,IMMER1901	01733	7 01715	0000		JMP	WFFR			Exit with error1902					*1903						END	WFFCK1904					*1905					**************************************************1906					*1907					* PROCEDURE VFYHD1908					*1909					*	Verify Header- against Header image in Scratchpad1910					*1911					* If correct header not found within 4 revolutions,1912					*     HeaderNotFound Error occurs1913					*1914					*   uses R11, R13  for return storage; STATRG,DTARG, CNTRG1915					* 	At End if ERRTYP = NOT 0, error has been found1916					*		and type recorded in HDRERT1917					**************************************************1918					*1919					* Now search for proper header1920					*1921						PROC	VFYHD1922	01734	0 11013	0000		MOVE	R11,R13			Keep return pointer1923	01735	6 07007	0144		XMIT	STCRC,IVL/WRDC2		Set to CRC1924	01736	6 01373	0000		XMIT	-5,CNTRG		Setup for index count1925	01737	6 07334	0032	VFYHDA	XMIT	HDST,IVL/WRSPMA		Load Header Image SA1926	01740	6 11115	0000		CALL	FINDAM			Find Address Mark1927	01741	7 02507	00001928						ORG	3,321929	01742	5 03344	0000		NZT	STATRG,VFYHDB1930	01743	7 02013	0000		JMP	VFYHDW			Not AM try again1931	01744	5 21104	0002	VFYHDB	NZT	21H,1,VFYHDB/,,FIFSTA	WAIT FOR BDONE1932	01745	6 00376	0000		XMIT	0FEX,AUX		Header ID BYTE1933	01746	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	GET DATA1934						ORG	16,321935	01747	5 04366	0000		NZT	DTARG,VFYRST		Not a Header-try again1936	01750	5 21110	0002	VH2	NZT	21H,1,VH2/,,FIFSTA	WAIT FOR BDONE1937	01751	0 37000	0008		MOVE	SPD,0,AUX/,1		Get byte image, Incr SPMA1938	01752	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	Get & test data1939	01753	5 04366	0000		NZT	DTARG,VFYRST		Not proper header, start over1940	01754	5 23110	0002		NZT	23H,1,VH2/,,FIFSTA	End of Header data?1941	01755	5 21115	0002	VF0	NZT	21H,1,VF0/,,FIFSTA		WAIT FOR BDONE1942	01756	6 11116	0000		CALL	ENDRB			End Reading a block1943	01757	7 02562	00001944	01760	5 04362	0000		NZT	DTARG,VFYCRE			A Hdr CRC error was found1945	01761	7 02010	0000		JMP	VFYRTN			exit procedure1946					*1947	01762	6 16024	0000	VFYCRE	XMIT	14X,ERRTYP		Mark error type1948	01763	6 07321	0032		XMIT	HDRERT,IVL/WRSPMA	Address of Header Err Typ1949	01764	6 17024	0000		XMIT	14X,IVR			Hdr CRC Error marked1950	01765	7 02010	0000		JMP	VFYRTN1951					*1952	01766	6 07220	0112	VFYRST	XMIT	90X,IVL/WRMAC		All off, incl ECCIZ' & RdGate1953	01767	7 02000	0000		ORG	14,321954	02000	5 24113	0005		NZT	24H,1,VFYHDW/,,DSKST	Restart if no index1955	02001	6 00001	0000	VFYIDX	XMIT	1,AUX1956	02002	6 07000	0048		XMIT	0,IVL/INDXOF		Reset Index1957	02003	1 01001	0000		ADD	CNTRG,CNTRG1958	02004	5 01013	0000		NZT	CNTRG,VFYHDW		AM, not 4 indexes1959	02005	6 16201	0000		XMIT	81X,ERRTYP		error-Header not found1960	02006	6 07321	0032		XMIT	HDRERT,IVL/WRSPMA	Address of Header Error Type1961	02007	6 17201	0000		XMIT	81X,IVR			NoSectorFound error1962	02010	6 07220	0112	VFYRTN	XMIT	90X,IVL/WRMAC		Read off1963	02011	0 13011	0000		MOVE	R13,R11			Restore return pointer1964	02012	7 03611	0000		RTN1965					*1966					* Wait 6 bytes for read gate to recover1967					*1968	02013	6 04366	0000	VFYHDW	XMIT	-10,DTARG1969	02014	6 11117	0000		CALL	WTINST			Wait 6 byte times1970	02015	7 01611	00001971	02016	7 01737	0000		JMP	VFYHDA			Try again1972					*1973						END	VFYHD1974					*1975					**************************************************1976					*1977					* PROCEDURE RDHD1978					*1979					*	Read Header- put into Header image in Scratchpad1980					*1981					*1982					*   uses R11, R13  for return storage; STATRG,DTARG1983					* 	At End if ERRTYP = NOT 0, error has been found1984					*		and type recorded in HDRERT1985					**************************************************1986					*1987					* Now search for a header1988					*1989					*	PROC	RDHD1990					*	MOVE	R11,R13			Keep return pointer1991					*	XMIT	STCRC,IVL/WRDC2		Set to CRC1992					*	ORG	8,321993					*RDHDA	XMIT	HDST,IVL/WRSPMA		Load Header Image SA1994					*	CALL	FINDAM			Find Address Mark1995					*	NZT	STATRG,RDHDB1996					*	JMP	RDHDA			Not AM try again1997					*RDHDB	NZT	21H,1,RDHDB/,,FIFSTA	WAIT FOR BDONE1998					*	XMIT	0FEX,AUX		Header ID BYTE1999					*	XOR	27H,0,DTARG/,,RDDSK	GET DATA2000					*	NZT	DTARG,RDHDA		Not a Header-try again2001					*RH2	NZT	21H,1,RH2/,,FIFSTA		WAIT FOR BDONE2002					*	MOVE	27H,0,DTARG/,,RDDSK	Get data2003					*	MOVE	DTARG,IVR		Put data in scratchpad2004					*	NOP				SP timing2005					*	MOVE	SPD,0,DTARG/,1		Read & Ignore Sp data-incr SPMA2006					*	NZT	23H,1,RH2/,,FIFSTA		End of Header data?2007					*RF0	NZT	21H,1,RF0/,,FIFSTA		WAIT FOR BDONE2008					*	CALL	ENDRB			End Reading a block2009					*	NZT	DTARG,RHCRE		A Hdr CRC error was found2010					*	JMP	RHRTN			exit procedure2011					**2012					*RHCRE	XMIT	14X,ERRTYP		Mark error type2013					*	XMIT	HDRERT,IVL/WRSPMA	Address of Header Err Typ2014					*	XMIT	14X,IVR			Hdr CRC Error marked2015					*	JMP	RHRTN2016					**2017					*RHRTN	XMIT	90X,IVL/WRMAC		Read off2018					*	MOVE	R13,R11			Restore return pointer2019					*	RTN2020					*	END	RDHD2021					*2022					************************************************2023					*2024					* PROCEDURE VFYLBL2025					*2026					*Verify Label2027					*2028					*Compares disk label with label image in Scratchpad2029					*  uses R11, R13 to hold return pointers,2030					*  uses STATRG, DTARG, ERRTYP, WRKR2031					* 2032					*	At end if ERRTYP is NOT = 0, a verify error has occured2033					*	  and type recorded in LBLERT2034					*2035					*  Revised  15-Feb-85 11:38:31  RLS2036					*2037					************************************************2038					*2039						PROC	VFYLBL2040	02017	0 11013	0000	VFRLBL	MOVE	R11,R13			Keep return pointer2041	02020	6 02000	0000		XMIT	0,WRKR			Clear verf error flag2042	02021	6 07007	0144		XMIT	STCRC,IVL/WRDC2		Set for CRC2043	02022	6 07353	0032		XMIT	LBLST,IVL/WRSPMA	Load Label Image SA2044	02023	7 02040	0000		ORG	30,322045	02040	6 11120	0000		CALL	FINDAM			Find next AM2046	02041	7 02507	00002047	02042	5 03044	0000		NZT	STATRG,VFRLBA2048	02043	7 02062	0000		JMP	VER1			Label AM error2049	02044	5 21104	0002	VFRLBA	NZT	21H,1,VFRLBA/,,FIFSTA	Wait for BDONE2050	02045	6 00374	0000		XMIT	0FCX,AUX		Label ID BYTE2051	02046	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	GET DATA2052	02047	5 04064	0000		NZT	DTARG,VER2		Not Label ID, error2053	02050	0 37000	0008	LR1	MOVE	SPD,0,AUX/,1		Load Lab Img byte, incr SPMA2054	02051	5 21111	0002	LR2	NZT	21H,1,LR2/,,FIFSTA		Wait for BDONE2055	02052	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK		XOR Img with disk data2056	02053	5 04066	0000		NZT	DTARG,VER3			Label error?2057	02054	5 24110	0002		NZT	24H,1,LR1/,,FIFSTA		End of Label data?2058	02055	5 21115	0002	LR3	NZT	21H,1,LR3/,,FIFSTA		Wait for BDONE2059	02056	6 11121	0000		CALL	ENDRB				End Reading a block2060	02057	7 02562	00002061	02060	5 04074	0000	LR4	NZT	DTARG,VER4			Label CRC Error2062	02061	7 02104	0000		JMP	LR52063	02062	6 16041	0000	VER1	XMIT	21X,ERRTYP			Mark LBL Am Error2064	02063	7 02077	0000		JMP	VERG2065	02064	6 16042	0000	VER2	XMIT	22X,ERRTYP			Label ID error2066	02065	7 02077	0000		JMP	VERG2067					*2068	02066	6 02001	0000	VER3	XMIT	1,WRKR				Mark verf. error2069	02067	5 24110	0002		NZT	24H,1,LR1/,,FIFSTA		End of Label data?2070	02070	5 21130	0002	LR3A	NZT	21H,1,LR3A/,,FIFSTA		Wait for BDONE2071	02071	6 11122	0000		CALL	ENDRB			End Reading a block2072	02072	7 02562	00002073	02073	7 02060	0000		JMP	LR4			CRC error?2074	02074	6 00002	0000	VER4	XMIT	2,AUX			Label CRC error2075	02075	1 02002	0000		ADD	WRKR,WRKR		add to label verify error2076						ORG	11,2562077	02076	7 02104	0000		JMP	LR52078	02077	6 07323	0032	VERG	XMIT	LBLERT,IVL/WRSPMA	Set SPMA to LabelErrorType2079	02100	0 16017	0000		MOVE	ERRTYP,IVR		Store error type2080	02101	6 07220	0112	LR6	XMIT	90X,IVL/WRMAC		Read off2081	02102	0 13011	0000		MOVE	R13,R11			Restore return pointer2082	02103	7 03611	0000		RTN2083					*2084	02104	5 02106	0000	LR5	NZT	WRKR,*+22085	02105	7 02101	0000		JMP	LR6			No errors2086	02106	6 00042	0000		XMIT	22X,AUX2087	02107	1 02016	0000		ADD	WRKR,ERRTYP		Fully formed error type2088	02110	7 02077	0000		JMP	VERG2089					*2090						END	VFYLBL2091					*2092					*2093					************************************************2094					*2095					* PROCEDURE RDLBL2096					*2097					*Read Label2098					*2099					*Reads disk label into label image in Scratchpad2100					*  uses R11, R13 to hold return pointers,2101					*  uses STATRG, DTARG, ERRTYP2102					* 2103					*	At end if ERRTYP is NOT = 0, an error has occured2104					*	  and type recorded in LBLERT2105					*2106					************************************************2107					*2108						PROC	RDLBL2109	02111	0 11013	0000	REDLBL	MOVE	R11,R13			Keep return pointer2110	02112	6 07007	0144		XMIT	STCRC,IVL/WRDC2		Set for CRC2111	02113	6 07353	0032		XMIT	LBLST,IVL/WRSPMA	Load Label Image SA2112	02114	6 11123	0000		CALL	FINDAM			Find next AM2113	02115	7 02507	00002114	02116	5 03120	0000		NZT	STATRG,REDLBA2115	02117	7 02154	0000		JMP	RLER1			Label AM error2116	02120	5 21120	0002	REDLBA	NZT	21H,1,REDLBA/,,FIFSTA	Wait for BDONE2117	02121	6 00374	0000		XMIT	0FCX,AUX		Label ID BYTE2118	02122	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	GET DATA2119					*2120	02123	7 02140	0000		ORG	18,32			Make sure pages fit2121	02140	5 04156	0000		NZT	DTARG,RLER2		Not Label ID, error2122	02141	5 21101	0002	RL2	NZT	21H,1,RL2/,,FIFSTA		Wait for BDONE2123	02142	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK		READ disk data2124	02143	0 04017	0000		MOVE	DTARG,IVR			Put into Scratchpad2125	02144	0 37002	0008		MOVE	SPD,0,WRKR/,1		Read & Ignore SP data, incr SPMA.2126	02145	0 00000	0000		NOP				Allow SP MA to settle2127	02146	5 24101	0002		NZT	24H,1,RL2/,,FIFSTA		End of Label data?2128	02147	5 21107	0002	RL3	NZT	21H,1,RL3/,,FIFSTA		Wait for BDONE2129	02150	6 11124	0000		CALL	ENDRB			End Reading a block2130	02151	7 02562	00002131	02152	5 04160	0000		NZT	DTARG,RLER4		Label CRC Error2132	02153	7 02163	0000		JMP	RL42133	02154	6 16041	0000	RLER1	XMIT	21X,ERRTYP			Mark LBL Am Error2134	02155	7 02161	0000		JMP	RLERG2135	02156	6 16042	0000	RLER2	XMIT	22X,ERRTYP			Label ID error2136	02157	7 02161	0000		JMP	RLERG2137	02160	6 16044	0000	RLER4	XMIT	24X,ERRTYP			Label CRC error2138	02161	6 07323	0032	RLERG	XMIT	LBLERT,IVL/WRSPMA	Set SPMA to LabelErrorType2139	02162	0 16017	0000		MOVE	ERRTYP,IVR			Store error type2140	02163	6 07220	0112	RL4	XMIT	90X,IVL/WRMAC		Read off2141	02164	0 13011	0000		MOVE	R13,R11			Restore return pointer2142	02165	7 03611	0000		RTN2143						END	RDLBL2144					*2145					*******************************************2146					*2147					*PROCEDURE WTLBL2148					*2149					*Write Label2150					*2151					* Writes a label using label image in Scratchpad2152					* Uses WRKR2153					*2154					*****************************************2155					*2156						PROC	WTLBL2157	02166	0 11013	0000	WTLB	MOVE	R11,R13			Keep return pointer2158	02167	6 07007	0144		XMIT	STCRC,IVL/WRDC2		Set for CRC2159	02170	6 04362	0000	WTLBA	XMIT	-14,DTARG		Gap Length, incl part of 6 byte gap2160	02171	6 07000	0064		XMIT	0,IVL/WDDATA		Write 02161	02172	6 07270	0112		XMIT	WE,IVL/WRMAC		Write + ECCIC2162	02173	6 07260	0112		XMIT	WRT,IVL/WRMAC		Write on, ECCIC off2163	02174	5 21134	0002	WTLBA2	NZT	21H,1,WTLBA2/,,FIFSTA	Wait for BDONE2164	02175	6 07001	0144		XMIT	STWG,IVL/WRDC2		WriteGate on2165	02176	6 07000	0064		XMIT	0,IVL/WDDATA		Write 02166	02177	6 11125	0000		CALL	WG			Write Gap2167	02200	7 01615	00002168	02201	5 21101	0002	WTLBA3	NZT	21H,1,WTLBA3/,,FIFSTA	Wait for BDONE2169	02202	6 07241	0064		XMIT	0A1X,IVL/WDDATA		Write Address Mark2170	02203	0 00000	0000		NOP2171	02204	5 21104	0002	WTLBA4	NZT	21H,1,WTLBA4/,,FIFSTA	Wait for BDONE2172	02205	6 07374	0064		XMIT	0FCX,IVL/WDDATA		Write Label ID2173	02206	6 07353	0032		XMIT	LBLST,IVL/WRSPMA	Load Label Image SA2174						ORG	4,322175	02207	5 21107	0002	WTLBA5	NZT	21H,1,WTLBA5/,,FIFSTA	Wait for BDONE2176	02210	0 37002	0008		MOVE	SPD,0,WRKR/,1		Get data, incr Ma2177	02211	0 02007	0064		MOVE	WRKR,IVL/WDDATA		Data to disk2178	02212	5 24107	0002		NZT	24H,1,WTLBA5/,,FIFSTA	End of label?2179	02213	5 21113	0002	WTLBA6	NZT	21H,1,WTLBA6/,,FIFSTA	Wait for BDONE2180	02214	6 07360	0112		XMIT	IW,IVL/WRMAC		Write+IBLA--write CRC2181	02215	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, CRC out2182	02216	6 04375	0000		XMIT	-3,DTARG		End gap-guard bytes2183	02217	5 21117	0002	WTLBAA	NZT	21H,1,WTLBAA/,,FIFSTA	Wait for BDONE2184	02220	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, CRC out2185	02221	6 11126	0000		CALL	WG			Write guard bytes2186	02222	7 01615	00002187	02223	5 21123	0002	WTLBAF	NZT	21H,1,WTLBAF/,,FIFSTA	Wait for BDONE2188	02224	0 13011	0000		MOVE	R13,R11		Restore return pointerr2189	02225	7 03611	0000		RTN2190						END	WTLBL2191					*2192					********************************************2193					*2194					* PROCEDURE WTDTA2195					*2196					*   Write a DATA BLOCK using data from FIFO2197					* NOTE: Preliminary readFIFO must be done elsewhere2198					*	uses DTARG, WRKR2199					*2200					*********************************************2201					*2202						PROC	WTDTA2203	02226	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Get ECC/CRC word2204	02227	0 11013	0000		MOVE	R11,R13			Keep return pointer2205	02230	0 37007	0144		MOVE	SPD,IVL/WRDC2		Set for ECC/CRC2206	02231	6 04363	0000	WRDTA	XMIT	-13,DTARG		Gap Length, incl part of 6 byte gap2207	02232	6 07000	0064		XMIT	0,IVL/WDDATA		Write 02208	02233	6 07270	0112		XMIT	WE,IVL/WRMAC		Write + ECCIZ2209	02234	6 07260	0112		XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off2210	02235	5 21135	0002	WRDTA2	NZT	21H,1,WRDTA2/,,FIFSTA	Wait for BDONE2211	02236	6 07001	0144		XMIT	STWG,IVL/WRDC2		WriteGate on2212	02237	6 07000	0064		XMIT	0,IVL/WDDATA		Write 02213	02240	6 11127	0000		CALL	WG			Write Gap2214	02241	7 01615	00002215	02242	5 21102	0002	WRDTA3	NZT	21H,1,WRDTA3/,,FIFSTA	Wait for BDONE2216	02243	6 07241	0064		XMIT	0A1X,IVL/WDDATA		Write Address Mark2217	02244	6 07000	0032		XMIT	0,IVL/WRSPMA		Clear SPMA for counting2218	02245	5 21105	0002	WRDTA4	NZT	21H,1,WRDTA4/,,FIFSTA	Wait for BDONE2219	02246	6 07373	0064		XMIT	0FBX,IVL/WDDATA		Write DATA ID2220	02247	6 00001	0000		XMIT	1,AUX2221						ORG	7,32			next 7 inst on same segment2222	02250	5 21110	0002	WRDTA5	NZT	21H,1,WRDTA5/,,FIFSTA	Wait for BDONE2223	02251	0 27002	0007		MOVE	27H,0,WRKR/,,RDFHI	Get data from FIFO2224	02252	0 02007	0064		MOVE	WRKR,IVL/WDDATA		Data to disk2225	02253	0 27002	0014		MOVE	27H,0,WRKR/,1,RDFLO	data from FIFO, Cycle FIFO, Incr SPMA2226	02254	5 21114	0002	WRDTA6	NZT	21H,1,WRDTA6/,,FIFSTA	Wait for BDONE2227	02255	0 02007	0064		MOVE	WRKR,IVL/WDDATA		Data to disk2228	02256	5 24110	0002		NZT	24H,1,WRDTA5/,,FIFSTA	Finished with count ?2229					* SPMA only counts to 255 (0-254), we need more words, depending on WENDC2230					*		-1 for normal, -2 or -3 for WRITE LONG2231					*  NOTE: The SP MA now points to 0FFX, location WENDCA2232					*	which is a copy of WENDC2233					*2234						ORG	9,322235	02257	0 37001	0000		MOVE	SPD,0,CNTRG		get WENDCA-ending count2236	02260	5 21120	0002	WRDTA7	NZT	21H,1,WRDTA7/,,FIFSTA	Wait for BDONE2237	02261	0 27002	0007		MOVE	27H,0,WRKR/,,RDFHI	Get data from FIFO2238	02262	0 02007	0064		MOVE	WRKR,IVL/WDDATA		Data to disk2239	02263	1 01001	0000		ADD	CNTRG,CNTRG		Is WENDC over?2240	02264	5 21124	0002	WRDTA8	NZT	21H,1,WRDTA8/,,FIFSTA	Wait for BDONE2241	02265	0 27002	0006		MOVE	27H,0,WRKR/,,RDFLO	data from FIFO, Cycle FIFO2242	02266	0 02007	0064		MOVE	WRKR,IVL/WDDATA		Data to disk2243	02267	5 01260	0000		NZT	CNTRG,WRDTA7		More data as reqd2244					*2245	02270	5 21130	0002	WRDTA9	NZT	21H,1,WRDTA9/,,FIFSTA	Wait for BDONE2246	02271	6 07360	0112		XMIT	IW,IVL/WRMAC		Write+IBLA--write ECC2247	02272	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, ECC out2248	02273	6 04373	0000		XMIT	-5,DTARG		Write gap length2249	02274	5 21134	0002	WRDTAA	NZT	21H,1,WRDTAA/,,FIFSTA	Wait for BDONE2250	02275	6 07000	0064		XMIT	0,IVL/WDDATA		0 gets lost, ECC out2251	02276	6 11130	0000		CALL	WG			Write gap2252	02277	7 01615	00002253	02300	5 21100	0002	WRDTAH	NZT	21H,1,WRDTAH/,,FIFSTA	Wait for BDONE2254	02301	6 07201	0144		XMIT	RSWG,IVL/WRDC2		WriteGate off2255	02302	6 07220	0112		XMIT	90X,IVL/WRMAC		Write off2256	02303	0 13011	0000		MOVE	R13,R11			Restore return pointerr2257	02304	7 03611	0000		RTN2258						END	WTDTA2259					*2260					*2261					****************************************2262					*2263					* PROCEDURE RDDTA2264					*2265					* Read a data block putting data into FIFO2266					*2267					* 	uses STATRG, DTARG,WRKR2268					*	USES R11, R13 to hold return pointers2269					*	SPMA is used as word counter2270					*2271					*   At end if ERRTYP is NOT = 0, an error has ocured2272					*       and type recorded in DTAERT2273					*2274					*******************************************2275					*2276						PROC	RDDTA2277					*2278					*2279	02305	0 11013	0000	RDTA	MOVE	R11,R13			Keep return pointer2280	02306	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Get ECC/CRC word2281	02307	0 00000	0000		NOP				Wait for address to settle2282	02310	0 37007	0144		MOVE	SPD,IVL/WRDC2		Set for ECC/CRC2283	02311	6 11131	0000		CALL	FINDAM			Find next AM2284	02312	7 02507	00002285	02313	5 03315	0000		NZT	STATRG,RDTB2286	02314	7 02356	0000		JMP	DER1			Data AM error2287	02315	6 00373	0000	RDTB	XMIT	0FBX,AUX		Data ID BYTE2288	02316	5 21116	0002	RDTBB	NZT	21H,1,RDTBB/,,FIFSTA	Wait for BDONE2289	02317	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	GET DATA2290	02320	5 04360	0000		NZT	DTARG,DER2		Not Data ID, error2291	02321	6 07000	0032		XMIT	0,IVL/WRSPMA		Clear SPMA for counting2292	02322	6 00001	0000		XMIT	1,AUX			for counting2293						ORG	9,322294	02323	5 21123	0002	RDTC	NZT	21H,1,RDTC/,,FIFSTA	Wait for BDONE2295	02324	0 27002	0004		MOVE	27H,0,WRKR/,,RDDSK	Get Disk Byte2296	02325	0 02007	0240		MOVE	WRKR,IVL/WRFHI		Put data into FIFO2297	02326	5 21126	0002	RDTD	NZT	21H,1,RDTD/,,FIFSTA	Wait for BDONE2298	02327	0 27002	0012		MOVE	27H,0,WRKR/,1,RDDSK	Get Disk Byte, incr SPMA2299	02330	0 02007	0224		MOVE	WRKR,IVL/WRFLO		Put data into FIFO, Store FIFO2300	02331	5 24123	0002		NZT	24H,1,RDTC/,,FIFSTA	Finished with count ?2301					*SPMA only counts to 255 (0-254), we need more words,  depending on2302					*     WENDC; -1=normal, -2 or -3 for READ LONG2303					* NOTE: The SP MA now points to 0FFX, which is location WENDCA, 2304					*		a copy of WENDC2305					*2306	02332	0 37001	0000		MOVE	SPD,0,CNTRG		No of final wrrds2307	02333	5 21133	0002	RDTE	NZT	21H,1,RDTE/,,FIFSTA	Wait for BDONE2308	02334	0 27002	0004		MOVE	27H,0,WRKR/,,RDDSK	Get Disk Byte2309	02335	0 02007	0240		MOVE	WRKR,IVL/WRFHI		Put data into FIFO2310	02336	1 01001	0000		ADD	CNTRG,CNTRG2311	02337	5 21137	0002	RDTF	NZT	21H,1,RDTF/,,FIFSTA	Wait for BDONE2312	02340	0 27002	0004		MOVE	27H,0,WRKR/,,RDDSK	Get Disk Byte2313	02341	0 02007	0224		MOVE	WRKR,IVL/WRFLO		Put data into FIFO, Store FIFO2314	02342	5 01333	0000		NZT	CNTRG,RDTE		Additional bytes2315	02343	5 14351	0000		NZT	ECCFLG,RDTH		End reading a block-CRC2316	02344	5 21104	0002	RDTG	NZT	21H,1,RDTG/,,FIFSTA	Wait for BDONE2317	02345	6 11132	0000		CALL	ENDRC			End reading a block-ECC2318	02346	7 02611	00002319	02347	5 04362	0000		NZT	DTARG,RDCRE		A ECC error was found2320	02350	7 02366	0000		JMP	RDRTN2321					*2322	02351	5 21111	0002	RDTH	NZT	21H,1,RDTH/,,FIFSTA	Wait for BDONE2323	02352	6 11133	0000		CALL	ENDRB			End reading a block-CRC2324	02353	7 02562	00002325	02354	5 04362	0000		NZT	DTARG,RDCRE		A CRC error was found2326	02355	7 02366	0000		JMP	RDRTN2327					*2328	02356	6 16061	0000	DER1	XMIT	31X,ERRTYP2329	02357	7 02364	0000		JMP	RDRER2330					*2331	02360	6 16062	0000	DER2	XMIT	32X,ERRTYP2332	02361	7 02364	0000		JMP	RDRER2333					*2334	02362	6 16064	0000	RDCRE	XMIT	34X,ERRTYP2335	02363	7 02364	0000		JMP	RDRER2336					*2337	02364	6 07325	0032	RDRER	XMIT	DTAERT,IVL/WRSPMA	Address of Data Err2338	02365	0 16017	0000		MOVE	ERRTYP,IVR		Keep error type2339					*2340	02366	6 07220	0112	RDRTN	XMIT	90X,IVL/WRMAC		Read off2341	02367	0 13011	0000		MOVE	R13,R11			Restore return pointer2342	02370	7 03611	0000		RTN2343						END	RDDTA2344					*2345					*2346					****************************************2347					*2348					* PROCEDURE VFDTA2349					*2350					* Verify a data block agaainst data in FIFO2351					* Preliminary ReadFIFO must be done elsewhere2352					*2353					* 	uses STATRG, DTARG,WRKR, CNTRG, R62354					*	USES R11, R13 to hold return pointers2355					*2356					*   At end if ERRTYP is NOT = 0, an error has ocured2357					*       and type recorded in DTAERT2358					*2359					* Revised  27-Feb-85 12:00:31  RLS2360					*2361					*2362					*******************************************2363					*2364						PROC	VFDTA2365					*2366					*2367	02371	0 11013	0000	VFTA	MOVE	R11,R13			Keep return pointer2368	02372	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Get ECC/CRC word2369	02373	6 06000	0000		XMIT	0,R6			Clear Vrfy Er Flag2370	02374	0 37007	0144		MOVE	SPD,IVL/WRDC2		Set for ECC/CRC2371	02375	6 11134	0000		CALL	FINDAM			Find next AM2372	02376	7 02507	00002373					*2374	02377	7 02400	0000		ORG	68,2562375	02400	5 03002	0000		NZT	STATRG,VFTB2376	02401	7 02450	0000		JMP	VFDER1			Data AM error2377	02402	6 00373	0000	VFTB	XMIT	0FBX,AUX		Data ID BYTE2378	02403	5 21103	0002	VFTBB	NZT	21H,1,VFTBB/,,FIFSTA	Wait for BDONE2379	02404	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	GET DATA2380	02405	5 04052	0000		NZT	DTARG,VFDER2		Not Data ID, error2381	02406	6 07000	0032		XMIT	0,IVL/WRSPMA		Clear SPMA for counting2382					*2383					        ORG     22,322384	02407	5 21107	0002	VFDTC	NZT	21H,1,VFDTC/,,FIFSTA	Wait for BDONE2385	02410	0 27000	0007		MOVE	27H,0,AUX/,,RDFHI	FIFO data for compare2386	02411	3 27002	0004		XOR	27H,0,WRKR/,,RDDSK	COMPARE Disk Byte2387	02412	5 02054	0000		NZT	WRKR,VFDER3		Comp error2388	02413	5 21113	0002	VFDTD	NZT	21H,1,VFDTD/,,FIFSTA	Wait for BDONE2389	02414	0 27000	0014		MOVE	27H,0,AUX/,1,RDFLO	FIFO data for compare,2390					*					Cycle FIFO,inc SPMA2391	02415	3 27002	0004		XOR	27H,0,WRKR/,,RDDSK	Comp Disk Byte2392	02416	5 02032	0000		NZT	WRKR,VFDER4		Comp error2393	02417	5 24107	0002		NZT	24H,1,VFDTC/,,FIFSTA	Finished with count ?2394					*SPMA only counts to 255 (0-254), we need 1 more word2395					*2396	02420	5 21120	0002	VFDTE	NZT	21H,1,VFDTE/,,FIFSTA	Wait for BDONE2397	02421	0 27000	0007		MOVE	27H,0,AUX/,,RDFHI	FIFO data for compare2398	02422	3 27002	0004		XOR	27H,0,WRKR/,,RDDSK	COMP Disk Byte2399	02423	5 02056	0000		NZT	WRKR,VFDER5		Comp error2400	02424	0 27000	0006		MOVE	27H,0,AUX/,,RDFLO	FIFO data for compare, Cycle FIFO2401	02425	5 21125	0002	VFDTF	NZT	21H,1,VFDTF/,,FIFSTA	Wait for BDONE2402	02426	3 27002	0004		XOR	27H,0,WRKR/,,RDDSK	COMP Disk Byte2403	02427	5 02060	0000		NZT	WRKR,VFDER6		Comp error - last byte?2404	02430	5 14037	0000		NZT	ECCFLG,VFDTG		End - CRC2405	02431	7 02444	0000		JMP	VFE			End- ECC2406					*2407	02432	6 06001	0000	VFDER4	XMIT	1,R62408	02433	5 24107	0002		NZT	24H,1,VFDTC/,,FIFSTA	Finished with count ?2409					*SPMA only counts to 255 (0-254), we need 1 more word2410					*2411	02434	5 21134	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE2412	02435	0 27000	0007		MOVE	27H,0,AUX/,,RDFHI	FIFO data for compare2413					* Compare not necessary- error already logged2414	02436	7 02425	0000		JMP	VFDTF2415					*2416	02437	5 21137	0002	VFDTG	NZT	21H,1,*/,,FIFSTA	Wait for BDONE2417	02440	6 11135	0000		CALL	ENDRB			End reading a block-CRC2418	02441	7 02562	00002419	02442	5 04073	0000	VFDTK	NZT	DTARG,VFDCRE		A CRC error was found2420	02443	7 02476	0000		JMP	VFDRTN2421					*2422	02444	5 21104	0002	VFE	NZT	21H,1,*/,,FIFSTA	Wait for BDONE2423	02445	6 11136	0000		CALL	ENDRC			End reading a block-ECC2424	02446	7 02611	00002425	02447	7 02442	0000		JMP	VFDTK2426					*2427	02450	6 16061	0000	VFDER1	XMIT	31X,ERRTYP2428	02451	7 02502	0000		JMP	VFDRER2429					*2430	02452	6 16062	0000	VFDER2	XMIT	32X,ERRTYP2431	02453	7 02502	0000		JMP	VFDRER2432					*2433					*A compare error has occured.  Mark the error2434	02454	6 06001	0000	VFDER3	XMIT	1,R62435	02455	7 02413	0000		JMP	VFDTD2436					*2437	02456	6 06001	0000	VFDER5	XMIT	1,R62438	02457	7 02425	0000		JMP	VFDTF2439					*2440	02460	6 06001	0000	VFDER6	XMIT	1,R62441	02461	5 14063	0000		NZT	ECCFLG,VFDTH		End - CRC2442	02462	7 02467	0000		JMP	VFDTJ			End - ECC2443					*2444	02463	5 21123	0002	VFDTH	NZT	21H,1,VFDTH/,,FIFSTA	Wait for BDONE2445	02464	6 11137	0000		CALL	ENDRB			End reading a block- CRC2446	02465	7 02562	00002447	02466	7 02442	0000		JMP	VFDTK2448					*2449	02467	5 21104	0002	VFDTJ	NZT	21H,1,VFE/,,FIFSTA	Wait for BDONE2450	02470	6 11140	0000		CALL	ENDRC			End reading a block-ECC2451	02471	7 02611	00002452	02472	7 02442	0000		JMP	VFDTK2453					*2454					* Add CRC/ECC error to R62455	02473	6 00002	0000	VFDCRE	XMIT	2X,AUX2456	02474	1 06006	0000		ADD	R6,R6	2457	02475	7 02500	0000		JMP	VFDREQ2458					*2459					        ORG     4,2562460	02476	5 06100	0000	VFDRTN	NZT	R6,*+2			Error found2461	02477	7 02504	0000		JMP	VFDRTP			No Error2462	02500	6 00062	0000	VFDREQ	XMIT	32X,AUX2463	02501	1 06016	0000		ADD	R6,ERRTYP		Fully formed error type2464	02502	6 07325	0032	VFDRER	XMIT	DTAERT,IVL/WRSPMA	Address of Data Err2465	02503	0 16017	0000		MOVE	ERRTYP,IVR		Keep error type2466					*2467	02504	6 07220	0112	VFDRTP	XMIT	90X,IVL/WRMAC		Read off2468	02505	0 13011	0000		MOVE	R13,R11			Restore return pointer2469	02506	7 03611	0000		RTN2470						END	VFDTA2471					*2472					*2473					***************************************************2474					*2475					* Procedure FINDAM2476					*2477					* Find next Address Mark2478					* uses DTARG, STATRG2479					*2480					*At exit, if STATRG = 0, AM not found2481					*2482					* Error possible-if no address marks found use Mesa timeout to catch2483					*   Proper sector not found detected by code which2484					*   calls this proc2485					************************************2486					*2487						PROC	FINDAM2488	02507	6 07220	0112	FINAM	XMIT	90X,IVL/WRMAC		All Off, incl ECCIZ' & ReadGate2489	02510	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	CLEAR SER-PAR CONV2490	02511	6 07007	0144		XMIT	STCRC,IVL/WRDC2		SET TO CRC2491	02512	6 07230	0112		XMIT	98X,IVL/WRMAC		MAKE ECCIZ' = LO2492	02513	6 07220	0112		XMIT	90X,IVL/WRMAC		ECCIZ' BACK HI2493	02514	6 07200	0112		XMIT	80X,IVL/WRMAC		READ GATE ON2494					*2495	02515	0 27103	0005	WTLOCK	MOVE	27H,1,STATRG/,,DSKST	PPLL LOCK BIT2496					*2497						ORG	6,32			No splintered addresses2498	02516	5 03120	0000		NZT	STATRG,PLLWT		LOCK FOUND2499	02517	7 02515	0000		JMP	WTLOCK			WAIT FOR PLL LOCK2500					* Now to make certain that it is truly locked2501	02520	0 00000	0000	PLLWT	NOP2502	02521	5 27123	0005		NZT	27H,1,PLLOK/,,DSKST	PLL LOCK BIT2503	02522	7 02515	0000		JMP	WTLOCK			WAIT FOR PLL LOCK2504	02523	6 07000	0112	PLLOK	XMIT	00,IVL/WRMAC		SEARCH ON2505					*2506					*WAIT FOR RDDTAFND2507	02524	0 20103	0002	GDRN	MOVE	20H,1,STATRG/,,FIFSTA	READ RdDtaFnd'2508					*2509	02525	7 02540	0000		ORG	22,322510	02540	5 03142	0000		NZT	STATRG,DTAF2511	02541	7 02524	0000		JMP	GDRN			WAIT FOR RdDtaFnd'2512	02542	6 03001	0000	DTAF	XMIT	1,STATRG		Mark as AM Found2513					*NOTE: Timing between DTAF & AMFND must not be changed!!!2514	02543	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2515	02544	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2516	02545	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2517	02546	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2518	02547	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2519	02550	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2520	02551	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2521	02552	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2522	02553	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2523	02554	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2524	02555	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2525	02556	5 23121	0005		NZT	23H,1,AMFND/,,DSKST	End it if AM found2526	02557	6 07220	0112		XMIT	90X,IVL/WRMAC		All off, incl ECCIZ' & RdGate2527	02560	6 03000	0000		XMIT	0,STATRG		Mark as error if no AM by now2528	02561	7 03611	0000	AMFND	RTN2529						END	FINDAM2530					*2531					****************************************2532					*2533					*	Procedure ENDRB2534					*2535					* End Reading a Block-2536					* If ECCFLG = 1, does CRC check2537					*	=0, does ECC check2538					*  Puts syndrome into ScratchPad2539					* ENTRB = check for CRC; ENDRC = check for ECC2540					*2541					* Uses DTARG, R112542					* At End, if DTARG = NOT 0, CRC/ECC error has been found2543					******************************************2544					*2545						PROC	ENDRB2546	02562	6 07274	0032	ENDRBA	XMIT	DTAECC,IVL/WRSPMA	Syndrome SA2547	02563	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	RD DATA & IGNORE2548	02564	6 07100	0112		XMIT	40X,IVL/WRMAC		IBLA' ON; RD STILL ON2549	02565	5 21125	0002	ENDRB1	NZT	21H,1,ENDRB1/,,FIFSTA	WAIT FOR BDONE2550	02566	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE2551	02567	6 07120	0112		XMIT	50X,IVL/WRMAC		READ OFF, IBLA' STILL ON2552	02570	5 21130	0002	ENDRB2	NZT	21H,1,ENDRB2/,,FIFSTA	WAIT FOR BDONE2553	02571	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	Get check byte2554	02572	0 04017	0000		MOVE	DTARG,IVR		Put into syndrome2555	02573	5 21133	0002	ENDRB3	NZT	21H,1,ENDRB3/,,FIFSTA	Wait for BDONE2556	02574	0 37004	0008		MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA2557	02575	0 27004	0004	       	MOVE	27H,0,DTARG/,,RDDSK	Get check byte2558	02576	0 04017	0000		MOVE	DTARG,IVR		Put into syndrome2559	02577	6 07220	0112	ENDRBC	XMIT	90X,IVL/WRMAC		OFF2560	02600	6 07274	0032	ENDRBD	XMIT	DTAECC,IVL/WRSPMA	Address of syndrome2561	02601	0 00000	0000		NOP				Wait for address to settle2562					*If Syndrome = 0, no error: otherwise, error2563	02602	0 37004	0008		MOVE	SPD,0,DTARG/,1		Get syndrome byte, incr SPMA2564						ORG	36,2562565	02603	5 04210	0000		NZT	DTARG,ECCSR		Test for error2566	02604	0 37004	0008		MOVE	SPD,0,DTARG/,1		Get syndrome byte, incr SPMA2567	02605	5 04210	0000		NZT	DTARG,ECCSR		Test for error2568	02606	5 14210	0000		NZT	ECCFLG,ECCSR2569	02607	7 02645	0000		JMP	ECCSK			2 more bytes if ECC2570	02610	7 03611	0000	ECCSR	RTN2571					*2572					* Entry ENDRC  Like ENDRB but for ECC2573						ENTRY	ENDRC2574	02611	6 07274	0032	ENDRCA	XMIT	DTAECC,IVL/WRSPMA	Syndrome SA2575	02612	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	RD DATA & IGNORE2576	02613	5 21113	0002		NZT	21H,1,*/,,FIFSTA	WAIT FOR BDONE2577	02614	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE2578	02615	0 00000	0000		NOP				Wait for BDONE to go away2579	02616	5 21116	0002	ENDRCB	NZT	21H,1,ENDRCB/,,FIFSTA	WAIT FOR BDONE2580	02617	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE2581	02620	6 07100	0112		XMIT	40X,IVL/WRMAC		IBLA' ON; RD STILL ON2582	02621	5 21121	0002	ENDRC1	NZT	21H,1,ENDRC1/,,FIFSTA	WAIT FOR BDONE2583	02622	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE2584	02623	6 07120	0112		XMIT	50X,IVL/WRMAC		READ OFF, IBLA' STILL ON2585	02624	5 21124	0002	ENDRC2	NZT	21H,1,ENDRC2/,,FIFSTA	WAIT FOR BDONE2586	02625	0 27004	0004	       	MOVE	27H,0,DTARG/,,RDDSK	Get check byte2587	02626	0 04017	0000		MOVE	DTARG,IVR		Put into syndrome2588	02627	5 21127	0002	ENDRC3	NZT	21H,1,ENDRC3/,,FIFSTA	Wait for BDONE2589	02630	0 37004	0008		MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA2590	02631	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	Get check byte2591	02632	0 04017	0000		MOVE	DTARG,IVR		Put into syndrome2592	02633	5 21133	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE2593	02634	0 37004	0008		MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA2594	02635	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	Get check byte2595	02636	0 04017	0000		MOVE	DTARG,IVR		Put into syndrome2596	02637	5 21137	0002		NZT	21H,1,*/,,FIFSTA	Wait for BDONE2597	02640	0 37004	0008		MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA2598	02641	0 27004	0004	       	MOVE	27H,0,DTARG/,,RDDSK	Get check byte2599	02642	0 04017	0000		MOVE	DTARG,IVR		Put into syndrome2600	02643	6 07220	0112		XMIT	90X,IVL/WRMAC		OFF2601	02644	7 02600	0000		JMP	ENDRBD			Check ECC/CRC2602					*2603	02645	0 37004	0008	ECCSK	MOVE	SPD,0,DTARG/,1		Get syndrome byte, incr SPMA2604	02646	5 04210	0000		NZT	DTARG,ECCSR		Test for error2605	02647	0 37004	0000		MOVE	SPD,0,DTARG		Get syndrome byte2606	02650	7 02610	0000		JMP	ECCSR			end2607					*2608						END	ENDRB2609					*2610					*2611					**********************************************2612					*2613					*  PROCEDURE ZROERS2614					*2615					* This procedure zeros all Error Type and ECC syndrome locations2616					*   in ScratchPad memory and zeros Reg ERRTYP & IMMER2617					*2618					*************************************************2619					*2620						PROC	ZROERS2621	02651	6 07320	0032	ZROE	XMIT	HDRERT-1,IVL/WRSPMA2622	02652	6 17000	0000		XMIT	0,IVR2623	02653	6 07321	0032		XMIT	HDRERT,IVL/WRSPMA2624	02654	6 17000	0000		XMIT	0,IVR2625	02655	6 07322	0032		XMIT	LBLERT-1,IVL/WRSPMA2626	02656	6 17000	0000		XMIT	0,IVR2627	02657	6 07323	0032		XMIT	LBLERT,IVL/WRSPMA2628	02660	6 17000	0000		XMIT	0,IVR2629	02661	6 07324	0032		XMIT	DTAERT-1,IVL/WRSPMA2630	02662	6 17000	0000		XMIT	0,IVR2631	02663	6 07325	0032		XMIT	DTAERT,IVL/WRSPMA2632	02664	6 17000	0000		XMIT	0,IVR2633	02665	6 07326	0032		XMIT	LSTERT-1,IVL/WRSPMA2634	02666	6 17000	0000		XMIT	0,IVR2635	02667	6 07327	0032		XMIT	LSTERT,IVL/WRSPMA2636	02670	6 17000	0000		XMIT	0,IVR2637	02671	6 07274	0032		XMIT	DTAECC,IVL/WRSPMA2638	02672	6 17000	0000		XMIT	0,IVR2639	02673	6 07275	0032		XMIT	DTAECC+1,IVL/WRSPMA2640	02674	6 17000	0000		XMIT	0,IVR2641	02675	6 07276	0032		XMIT	DTAECC+2,IVL/WRSPMA2642	02676	6 17000	0000		XMIT	0,IVR2643	02677	6 07277	0032		XMIT	DTAECC+3,IVL/WRSPMA2644	02700	6 17000	0000		XMIT	0,IVR2645	02701	6 16000	0000		XMIT	0,ERRTYP2646	02702	6 15000	0000		XMIT	0,IMMER2647	02703	7 03611	0000		RTN2648						END	ZROERS2649					*2650					**********************************************2651					*2652					*PROCEDURE NXTSC2653					*2654					* THIS PROCEDURE sets up for next sector2655					*  It tests wether the number of sectors to be transfered has been done2656					*  If not2657					*    Increment FilePageLo in labelImage2658					*    Increment sector number in HeaderImage2659					*    is "new" sector number too big?  If so2660					*        Put lowest sector number into HeaderImage2661					*        Incrememt Track Number2662					*        Is new Track Number too big?  If so2663					*            Put 0 into track number2664					*            Incrememt Cylinder Number2665					*            Is new Cylinder number too big?  If so2666					*	ERROR 82X2667					*2668					*	At end if DTARG = NOT 0, do next sector2669					*	If DTARG = 0, end operation2670					*	If ERRTYP = NOT 0, a fatal error has occured2671					*2672					***********************************************2673					*2674						PROC	NXTSC2675	02704	6 15000	0000		XMIT	0,IMMER			Reset ImmediateError2676					*2677					*Transfered all sectors commanded?2678					*2679	02705	6 07300	0032	NXTS	XMIT	SECNTH,IVL/WRSPMA	SP loc cont no of sectors left HI2680	02706	6 00001	0000		XMIT	1,AUX2681	02707	0 37006	0000		MOVE	SPD,0,DTXHI		Get hi part2682	02710	6 07301	0032		XMIT	SECNTL,IVL/WRSPMA	SP loc cont no of sectors left Lo2683	02711	0 00000	0000		NOP				Time for Address to settle2684	02712	1 37005	0000		ADD	SPD,0,DTXLO		Add 1 to neg numberof sectors left, lo2685	02713	0 10000	0000		MOVE	OVF,AUX2686	02714	1 06006	0000		ADD	DTXHI,DTXHI		Cary into hi part2687	02715	0 05017	0000		MOVE	DTXLO,IVR		Lo part back--SPMA still at SECNTL2688	02716	6 07300	0032		XMIT	SECNTH,IVL/WRSPMA	Address of sectors to xfr, hi2689	02717	0 06017	0000		MOVE	DTXHI,IVR		Put hi part back2690					* Is result = 0?2691	02720	6 04001	0000		XMIT	1,DTARG		Setup for not ended2692	02721	5 05325	0000		NZT	DTXLO,NXNZ	Not zero, go on2693	02722	5 06325	0000		NZT	DTXHI,NXNZ2694	02723	6 04000	0000		XMIT	0,DTARG		Mark ended2695	02724	7 03071	0000		JMP	NXEND		Transfer Completed2696					*2697					*Transfer not completed, so set up for next sector2698					*Double Precision Increment of FilePageLo in label2699					*2700						ENTRY	NXTSE2701	02725	6 07366	0032	NXNZ	XMIT	LBFPL,IVL/WRSPMA	Addr of FilePageLoLo2702	02726	6 00001	0000		XMIT	1,AUX2703	02727	1 37002	0000		ADD	SPD,0,WRKR		Incr FPLoLo2704	02730	0 02017	0000		MOVE	WRKR,IVR		Back to FPLoLo2705	02731	0 10000	0000		MOVE	OVF,AUX			Get cary bit2706	02732	6 07365	0032		XMIT	LBFPL-1,IVL/WRSPMA	Addr of FPLoHi2707	02733	0 00000	0000		NOP				Allow address to settle2708	02734	1 37002	0000		ADD	SPD,0,WRKR		2d part of DP add2709	02735	0 02017	0000		MOVE	WRKR,IVR		Put back FPLoHi2710	02736	5 10340	0000		NZT	OVF,*+2			T if carry into FPH-HI2711	02737	7 02750	0000		JMP	NXISC			No carry2712					*A carry into FilePageHi-hi has occured.  The LSB of that byte is2713					*a flag and must be preserved.  So, add 2. If overflow2714					*has occured, FilePageHi has overflowed, an error. put 085X into ERRTYP2715					*2716	02740	6 07367	0032		XMIT	LBFPHH,IVL/WRSPMA	Address of FilePageHi-hi2717	02741	0 00000	0000		NOP				Allow address to settle2718	02742	0 37002	0000		MOVE	SPD,0,WRKR		Get it2719					*Since the LS position is not part of the FP, add 2 instead of 12720	02743	6 00002	0000		XMIT	2,AUX2721	02744	1 02017	0000		ADD	WRKR,IVR		Add & put back2722						ORG	3,2562723	02745	5 10347	0000		NZT	OVF,FPOFA		FilePage overflow2724	02746	7 02750	0000		JMP	NXISC2725	02747	7 03074	0000	FPOFA	JMP	FPOF2726					*2727					*Increment sector number in headerImage2728					*2729	02750	6 00001	0000	NXISC	XMIT	1,AUX2730	02751	6 07337	0032		XMIT	HDSC,IVL/WRSPMA		Addr of sector no.2731	02752	0 00000	0000		NOP				Allow address to settle2732	02753	1 37002	0000		ADD	SPD,0,WRKR		sector no + 12733	02754	0 02017	0000		MOVE	WRKR,IVR		new sector no into header2734	02755	6 07303	0032		XMIT	SECPT,IVL/WRSPMA	Add of MaxSecNo+12735	02756	0 00000	0000		NOP				Allow address to settle2736	02757	0 37000	0000		MOVE	SPD,0,AUX		MaxSecNo+1 per track2737	02760	3 02002	0000		XOR	WRKR,WRKR		Current SecNo = Max+1?2738	02761	7 03000	0000		ORG	40,2562739	03000	5 02071	0000		NZT	WRKR,NXEND		If not, exit2740					*2741	03001	6 07311	0032		XMIT	FSEC,IVL/WRSPMA2742	03002	0 00000	0000		NOP				Allow address to settle2743	03003	0 37002	0000		MOVE	SPD,0,WRKR		Starting sector no2744	03004	6 07337	0032		XMIT	HDSC,IVL/WRSPMA2745	03005	0 02017	0000		MOVE	WRKR,IVR		New sector number is starting no2746					*2747					*Increment Head No.2748					*2749	03006	6 00001	0000		XMIT	1,AUX2750	03007	6 07336	0032		XMIT	HDHD,IVL/WRSPMA		Address of Head byte2751	03010	0 00000	0000		NOP				Allow address to settle2752	03011	1 37002	0000		ADD	SPD,0,WRKR		Head + 12753	03012	0 02017	0000		MOVE	WRKR,IVR		New Head no in SP2754	03013	6 07305	0032		XMIT	HDSPC,IVL/WRSPMA	Address of Heads + 1 Per Cylinder2755	03014	0 00000	0000		NOP				Allow address to settle2756	03015	0 37000	0000		MOVE	SPD,0,AUX2757	03016	3 02002	0000		XOR	WRKR,WRKR		Compare new head no with max2758	03017	5 02064	0000		NZT	WRKR,NXSH		Not too big2759					*2760	03020	6 07336	0032		XMIT	HDHD,IVL/WRSPMA		Address of Head byte2761	03021	6 17000	0000		XMIT	0,IVR			New head number = 02762	03022	6 07334	0032		XMIT	HDCYH,IVL/WRSPMA	Address of cylinder in header, hi2763	03023	0 00000	0000		NOP				Allow address to settle2764	03024	0 37006	0000		MOVE	SPD,0,DTXHI		Hi part of cyl number2765	03025	6 07335	0032		XMIT	HDCYL,IVL/WRSPMA	Address of cylinder in header, lo2766	03026	6 00001	0000		XMIT	1,AUX2767	03027	0 37005	0000		MOVE	SPD,0,DTXLO		Lo part of cyl number2768					*Increment cylinder number2769	03030	1 05005	0000		ADD	DTXLO,DTXLO2770	03031	0 10000	0000		MOVE	OVF,AUX2771	03032	1 06006	0000		ADD	DTXHI,DTXHI2772	03033	0 05017	0000		MOVE	DTXLO,IVR		New cylinder no, lo2773	03034	6 07334	0032		XMIT	HDCYH,IVL/WRSPMA	Addrerss of cylinder in header, hi2774	03035	0 06017	0000		MOVE	DTXHI,IVR		New cylinder no, hi2775					*Is new cylinder no too big?2776	03036	6 07306	0032		XMIT	CYLPDH,IVL/WRSPMA	Address of cyl too big, hi2777	03037	0 00000	0000		NOP				Wait for address to settle2778	03040	0 37000	0000		MOVE	SPD,0,AUX2779	03041	3 06002	0000		XOR	DTXHI,WRKR		Compare new cl hi/too big hi2780	03042	5 02053	0000		NZT	WRKR,NXSK		Not too big2781	03043	6 07307	0032		XMIT	CYLPDL,IVL/WRSPMA	Address of cyl too big, lo2782	03044	0 00000	0000		NOP				Wait for address to settle2783	03045	0 37000	0000		MOVE	SPD,0,AUX2784	03046	3 05002	0000		XOR	DTXLO,WRKR		Too big?2785	03047	5 02053	0000		NZT	WRKR,NXSK		Not too big2786	03050	6 16202	0000		XMIT	82X,ERRTYP2787	03051	6 15202	0000		XMIT	82X,IMMER		Mark error2788	03052	7 03071	0000		JMP	NXEND			Do not seek if too big error2789	03053	0 11012	0000	NXSK	MOVE	R11,R12			Save return pointer2790	03054	6 11141	0000		CALL	SELHD			Sellect Head & Drive2791	03055	7 01541	00002792	03056	6 15000	0000		XMIT	0,IMMER			Ready for implied seek2793	03057	6 11142	0000		CALL	IMPSK			Seek2794	03060	7 01376	00002795	03061	0 12011	0000		MOVE	R12,R11			Restore return pointer2796	03062	5 15071	0000		NZT	IMMER,NXEND		Seek error2797	03063	7 03070	0000		JMP	NXSHA			Good, exit2798	03064	0 11012	0000	NXSH	MOVE	R11,R12			Save return pointer2799	03065	6 11143	0000		CALL	SELHD			Sellect Head & Drive2800	03066	7 01541	00002801	03067	0 12011	0000		MOVE	R12,R11			Restore return pointer2802	03070	6 04001	0000	NXSHA	XMIT	1,DTARG			Mark transfer not ended2803	03071	6 07327	0032	NXEND	XMIT	LSTERT,IVL/WRSPMA	Address of Last Error Type2804	03072	0 16017	0000		MOVE	ERRTYP,IVR		Put into SP2805	03073	7 03611	0000		RTN2806					*2807	03074	6 16206	0000	FPOF	XMIT	086X,ERRTYP		Mark FP overflow error2808	03075	6 15206	0000		XMIT	086X,IMMER2809	03076	7 03071	0000		JMP	NXEND2810					*2811						END	NXTSC2812					*2813					************************************************************2814					************************************************************2815					****	Code for Track Read Command2816					************************************************************2817					************************************************************2818					*2819					*2820	03077	6 11144	0000	TRKRD	CALL	ZROERS			Zero error locs2821	03100	7 02651	00002822					*TST ONLY Remove the next 2 cmds for Product2823					*	XMIT	0B0X,IVL/WRRDSP2824					*	XMIT	0B0X,IVL/WRRDSP		SEND 4F TO RT DISP2825	03101	6 07337	0032		XMIT	HDSC,IVL/WRSPMA2826	03102	6 17000	0000		XMIT	0,IVR			Clear  HDSC2827	03103	6 07260	0032		XMIT	0B0X,IVL/WRSPMA2828	03104	6 17000	0000		XMIT	0,IVR			Clear Sector Count2829	03105	6 07261	0032		XMIT	0B1X,IVL/WRSPMA2830	03106	6 17000	0000		XMIT	0,IVR			Flag for first Sector read2831	03107	6 07340	0032		XMIT	0E0X,IVL/WRSPMA2832	03110	6 17000	0000		XMIT	0,IVR			Clear High Byte of Sector Valid2833	03111	6 07341	0032		XMIT	0E1X,IVL/WRSPMA2834	03112	6 17000	0000		XMIT	0,IVR			Clear Low Byte of Sector Valid2835					2836					* Set ECCRF according to ECCF2837					* ECCF is 0 for ECC, 1 for CRC (Diag only)2838	03113	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECCF2839	03114	0 00000	0000		NOP				Wait for address to settle2840	03115	0 37002	0000		MOVE	SPD,0,WRKR		ECCF into reg2841	03116	6 07240	0032		XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF2842	03117	6 17007	0000		XMIT	STCRC,IVR		If ECCF is 12843					*2844						ORG	3,322845	03120	5 02122	0000		NZT	WRKR,TRKRD12846	03121	6 17207	0000		XMIT	STECC,IVR		If ECCF = 02847	03122	6 07241	0032	TRKRD1	XMIT	FIFFM,IVL/WRSPMA	SP address for FIF F/eM flag2848	03123	6 17000	0000		XMIT	0,IVR			Flag _ 02849					*	2850					*Compare CurrentCyl with Cyl from HederImage.  If different, seek2851					*2852	03124	6 11145	0000		CALL	SELHD			Sellect Head & Drive2853	03125	7 01541	00002854	03126	6 15000	0000		XMIT	0,IMMER		2855	03127	6 11146	0000		CALL	IMPSK2856	03130	7 01376	00002857					*2858					*If IMMER is not zero, an error has occured2859					*2860						ORG	11,2562861	03131	5 15133	0000		NZT	IMMER,TRKRDA2862	03132	7 03140	0000		JMP	TRKRD82863	03133	7 01314	0000	TRKRDA	JMP	EREND2864					2865					*2866	03134	7 03140	0000		ORG	4,322867	03140	5 26103	0002	TRKRD8	NZT	26H,1,TRKRD2/,,FIFSTA	Is FIFO Empty?2868	03141	6 16003	0000		XMIT	3,ERRTYP		FIFO is not empty2869	03142	7 01314	0000		JMP	EREND2870					*2871	03143	6 15000	0000	TRKRD2	XMIT	0,IMMER			Continue reading sectors loops here2872	03144	6 01000	0000		XMIT	0,CNTRG2873	03145	6 11147	0000		CALL	RFFCK			Check FIFO full, empty, half full2874	03146	7 01623	00002875	03147	5 15133	0000		NZT	IMMER,TRKRDA		an error has occured2876	03150	6 07000	0192		XMIT	0,IVL/TGLA		Toggle FF A2877	03151	6 14001	0000		XMIT	1,ECCFLG		Set to CRC2878	03152	6 07261	0032		XMIT	0B1X,IVL/WRSPMA2879	03153	0 00000	0000		NOP2880						ORG	8,322881	03154	5 37023	0000		NZT	SPD,0,TRKRD32882	03155	6 11150	0000		CALL	VFYCYLHD		Read Sector2883	03156	7 03243	00002884	03157	5 16165	0000		NZT	ERRTYP,TRKRD52885	03160	6 07261	0032		XMIT	0B1X,IVL/WRSPMA2886	03161	6 17001	0000		XMIT	1,IVR2887	03162	7 03165	0000		JMP	TRKRD52888					* Wait 8 bytes before starting to verify label2889	03163	6 11151	0000	TRKRD3	CALL	VFYHD			Verify Header2890	03164	7 01734	00002891	03165	6 04342	0000	TRKRD5	XMIT	-30,DTARG2892	03166	6 11152	0000		CALL	WTINST2893	03167	7 01611	00002894	03170	6 11153	0000		CALL	RDLBL2895	03171	7 02111	00002896					* Wait 7 bytes before starting to read data2897	03172	6 04346	0000		XMIT	-26,DTARG2898	03173	6 11154	0000		CALL	WTINST			2899	03174	7 01611	00002900	03175	6 07333	0032		XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB2901	03176	0 00000	0000		NOP				Wait for address to settle2902	03177	0 37014	0000		MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag2903	03200	6 11155	0000	TRKRD6	CALL	RDDTA			Read Data2904	03201	7 02305	00002905						ORG	33,2562906	03202	5 16204	0000		NZT	ERRTYP,*+22907	03203	7 03232	0000		JMP	TRKRD72908	03204	0 16000	0000		MOVE	ERRTYP,AUX		IF Error Type = DATA AM,ID Error2909	03205	6 02061	0000		XMIT	31X,WRKR		 then must set Dummy Data to FIFO2910	03206	3 02002	0000		XOR	WRKR,WRKR		AM Error ?2911	03207	5 02211	0000		NZT	WRKR,*+22912	03210	7 03217	0000		JMP	TRKRD9			If AM Error, Jmp to TRKRD92913	03211	0 16000	0000		MOVE	ERRTYP,AUX2914	03212	6 02062	0000		XMIT	32X,WRKR2915	03213	3 02002	0000		XOR	WRKR,WRKR		ID Error ?2916	03214	5 02216	0000		NZT	WRKR,*+22917	03215	7 03217	0000		JMP	TRKRD9			If ID Error, Jmp to TRKRD92918	03216	7 03232	0000		JMP	TRKRD7			Other Error2919	03217	6 11156	0000	TRKRD9	CALL	DUMMYDATA		About 128 byte Time2920	03220	7 03357	00002921	03221	6 04000	0000		XMIT	0,DTARG			2922	03222	6 11157	0000		CALL	WTINST			About 128 byte Time2923	03223	7 01611	00002924	03224	6 04000	0000		XMIT	0,DTARG			2925	03225	6 11160	0000		CALL	WTINST			About 128 byte Time2926	03226	7 01611	00002927	03227	6 04000	0000		XMIT	0,DTARG			2928	03230	6 11161	0000		CALL	WTINST			About 128 byte Time2929	03231	7 01611	00002930	03232	6 11162	0000	TRKRD7	CALL	NXSCINTCK		Next sector?2931	03233	7 03373	00002932	03234	6 07260	0032		XMIT	0B0X,IVL/WRSPMA2933	03235	6 00020	0000		XMIT	16,AUX2934	03236	3 37002	0000		XOR	SPD,0,WRKR2935	03237	6 16000	0000		XMIT	0,ERRTYP2936	03240	5 02242	0000		NZT	WRKR,*+22937	03241	7 01222	0000		JMP	OPCMP			Operation completed2938	03242	7 03143	0000		JMP	TRKRD22939						2940					*2941					*2942					*****************************************************************2943					*PROCEDURE VFYCYLHD2944					*	Verify Cylinder & Head,2945					*		Sector stores to DOB.2946					*		And Only First Secter is Returned to Mesa.2947					*****************************************************************2948					*2949						PROC	VFYCYLHD2950	03243	0 11013	0000		MOVE	R11,R13			Keep return pointer2951	03244	6 07007	0144		XMIT	STCRC,IVL/WRDC2		Set to CRC2952	03245	6 01373	0000		XMIT	-5,CNTRG		Setup for index count2953	03246	6 07334	0032	VFCHDA	XMIT	HDST,IVL/WRSPMA		Load Header Image SA2954	03247	6 11163	0000		CALL	FINDAM			Find Address, Mark2955	03250	7 02507	00002956						ORG	3,322957	03251	5 03253	0000		NZT	STATRG,VFCHDB2958	03252	7 03353	0000		JMP	VFYCHDW			Not AM try again2959	03253	5 21113	0002	VFCHDB	NZT	21H,1,VFCHDB/,,FIFSTA	WAIT FOR BDONE2960	03254	6 00376	0000		XMIT	0FEX,AUX		Header ID BYTE2961	03255	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	GET DATA2962	03256	7 03300	0000		ORG	23,322963	03300	5 04325	0000		NZT	DTARG,VFYCYLRST		Not a Header-try again2964	03301	6 02375	0000		XMIT	-3,WRKR2965	03302	5 21102	0002	VFCYL	NZT	21H,1,VFCYL/,,FIFSTA	WAIT FOR BDONE2966	03303	0 37000	0008		MOVE	SPD,0,AUX/,1		Get byte image, Incr SPMA2967	03304	3 27004	0004		XOR	27H,0,DTARG/,,RDDSK	Get & test data2968	03305	5 04325	0000		NZT	DTARG,VFYCYLRST		Not proper header, start over2969	03306	6 00001	0000		XMIT	1,AUX2970	03307	1 02002	0000		ADD	WRKR,WRKR2971	03310	5 02302	0000		NZT	WRKR,VFCYL2972	03311	5 21111	0002	STRSC	NZT	21H,1,STRSC/,,FIFSTA	WAIT FOR BDONE2973	03312	0 27004	0004		MOVE	27H,0,DTARG/,,RDDSK	Get First Sector2974	03313	0 04017	0000		MOVE	DTARG,IVR		Store Sector Number2975					*	JMP	VFCYL02976	03314	5 21114	0002	VFCYL0	NZT	21H,1,VFCYL0/,,FIFSTA	WAIT FOR BDONE2977	03315	6 11164	0000		CALL	ENDRB			End Reading a block2978	03316	7 02562	00002979	03317	5 04321	0000		NZT	DTARG,VFYCYLCRE		A Hdr CRC error was found2980	03320	7 03350	0000		JMP	VFYCYLRTN		exit procedure2981					*2982	03321	6 16024	0000	VFYCYLCRE	XMIT	14X,ERRTYP	Mark error type2983	03322	6 07321	0032		XMIT	HDRERT,IVL/WRSPMA	Address of Header Err Typ2984	03323	6 17024	0000		XMIT	14X,IVR			Hdr CRC Error marked2985	03324	7 03350	0000		JMP	VFYCYLRTN2986					*2987	03325	6 07220	0112	VFYCYLRST	XMIT	90X,IVL/WRMAC		All off, incl ECCIZ' & RdGate2988	03326	7 03340	0000		ORG	14,322989	03340	5 24113	0005		NZT	24H,1,VFYCHDW/,,DSKST	Restart if no index2990	03341	6 00001	0000	VFYCYLIDX	XMIT	1,AUX2991	03342	6 07000	0048		XMIT	0,IVL/INDXOF		Reset Index2992	03343	1 01001	0000		ADD	CNTRG,CNTRG2993	03344	5 01353	0000		NZT	CNTRG,VFYCHDW		AM, not 4 indexes2994	03345	6 16201	0000		XMIT	81X,ERRTYP		error-Header not found2995	03346	6 07321	0032		XMIT	HDRERT,IVL/WRSPMA	Address of Header Error Type2996	03347	6 17201	0000		XMIT	81X,IVR			NoSectorFound error2997	03350	6 07220	0112	VFYCYLRTN	XMIT	90X,IVL/WRMAC		Read off2998	03351	0 13011	0000		MOVE	R13,R11			Restore return pointer2999	03352	7 03611	0000		RTN3000						3001	03353	6 04366	0000	VFYCHDW	XMIT	-10,DTARG3002	03354	6 11165	0000		CALL	WTINST			Wait 6 byte times3003	03355	7 01611	00003004	03356	7 03246	0000		JMP	VFCHDA			Try again3005						3006						END	VFYCYLHD3007					*3008					*****************************************************************3009					*PROCEDURE DUMMYDATA3010					*Write Dumy Data to FIFO 3011					*****************************************************************3012						PROC	DUMMYDATA3013	03357	0 11013	0000		MOVE	R11,R133014	03360	6 07000	0032		XMIT	0,IVL/WRSPMA3015	03361	6 00001	0000		XMIT	1,AUX3016	03362	6 02000	0000		XMIT	0,WRKR3017	03363	0 02007	0240	DMYDTA1	MOVE	WRKR,IVL/WRFHI		Write Dummy DATA3018	03364	0 02007	0232		MOVE	WRKR,IVL/WRFLO,1	Write Dummy DATA3019	03365	0 00000	0000		NOP3020	03366	5 24123	0002		NZT	24H,1,DMYDTA1/,,FIFSTA	Write 255 Word to FIFO3021	03367	0 02007	0240		MOVE	WRKR,IVL/WRFHI3022	03370	0 02007	0224		MOVE	WRKR,IVL/WRFLO3023	03371	0 13011	0000		MOVE	R13,R113024	03372	7 03611	0000		RTN3025						END	DUMMYDATA3026					*3027					**********************************************************************3028					*  PROCEDURE NXSCINTCK3029					*Set up for next Sector, Increment Sector Number3030					*		and set SectorValid3031					*3032					**********************************************************************3033						PROC	NXSCINTCK3034	03373	0 11013	0000		MOVE	R11,R133035	03374	6 07337	0032		XMIT	HDSC,IVL/WRSPMA3036	03375	6 00001	0000		XMIT	1,AUX3037	03376	1 37002	0000		ADD	SPD,0,WRKR3038	03377	6 00020	0000		XMIT	16,AUX3039	03400	0 02004	0000		MOVE	WRKR,DTARG3040	03401	3 02002	0000		XOR	WRKR,WRKR3041						ORG	38,2563042	03402	5 02004	0000		NZT	WRKR,*+23043	03403	6 04000	0000		XMIT	0,DTARG			16 => 03044	03404	0 04017	0000		MOVE	DTARG,IVR		Increment HDSC3045	03405	6 07260	0032		XMIT	0B0X,IVL/WRSPMA3046	03406	6 00010	0000		XMIT	8X,AUX3047	03407	0 37002	0000		MOVE	SPD,0,WRKR3048	03410	0 02004	0000		MOVE	WRKR,DTARG		Save Content of WRKR3049	03411	2 04004	0000		AND	DTARG,DTARG		Check Bit4 of DTARG3050	03412	5 04025	0000		NZT	DTARG,HByte3051	03413	6 07341	0032	LByte	XMIT	0E1X,IVL/WRSPMA		Low Byte of Reserved13052	03414	0 00000	0000		NOP3053	03415	5 16020	0000		NZT	ERRTYP,*+33054	03416	6 00001	0000		XMIT	1,AUX3055	03417	7 03421	0000		JMP	*+23056	03420	6 00000	0000		XMIT	0,AUX3057	03421	1 37002	0000		ADD	SPD,0,WRKR3058	03422	0 02102	0000		MOVE	WRKR(1),WRKR3059	03423	0 02017	0000		MOVE	WRKR,IVR3060	03424	7 03436	0000		JMP	EndNX3061	03425	6 07340	0032	HByte	XMIT	0E0X,IVL/WRSPMA		High Byte of Reserved13062	03426	0 00000	0000		NOP3063	03427	5 16032	0000		NZT	ERRTYP,*+33064	03430	6 00001	0000		XMIT	1,AUX3065	03431	7 03433	0000		JMP	*+23066	03432	6 00000	0000		XMIT	0,AUX3067	03433	1 37002	0000		ADD	SPD,0,WRKR3068	03434	0 02102	0000		MOVE	WRKR(1),WRKR3069	03435	0 02017	0000		MOVE	WRKR,IVR3070	03436	6 07260	0032	EndNX	XMIT	0B0X,IVL/WRSPMA	3071	03437	6 00001	0000		XMIT	1,AUX3072	03440	1 37002	0000		ADD	SPD,0,WRKR		Increment Sector Count3073	03441	0 02017	0000		MOVE	WRKR,IVR		Store Sector Count3074	03442	5 16044	0000		NZT	ERRTYP,*+23075	03443	7 03446	0000		JMP	ENDNX13076	03444	6 07327	0032		XMIT	LSTERT,IVL/WRSPMA3077	03445	0 16017	0000		MOVE	ERRTYP,IVR3078	03446	0 13011	0000	ENDNX1	MOVE	R13,R113079	03447	7 03611	0000		RTN3080					*	3081						END	NXSCINTCK3082					*3083					3084						END	RDVF2		03611	4 11212	0000	03612	7 00024	0000	03613	7 00033	0000	03614	7 00036	0000	03615	7 00051	0000	03616	7 00271	0000	03617	7 00273	0000	03620	7 00275	0000	03621	7 00305	0000	03622	7 00316	0000	03623	7 00325	0000	03624	7 00332	0000	03625	7 00336	0000	03626	7 00341	0000	03627	7 00343	0000	03630	7 00346	0000	03631	7 00353	0000	03632	7 00356	0000	03633	7 00365	0000	03634	7 00400	0000	03635	7 00403	0000	03636	7 00412	0000	03637	7 00417	0000	03640	7 00422	0000	03641	7 00424	0000	03642	7 00427	0000	03643	7 00434	0000	03644	7 00437	0000	03645	7 00446	0000	03646	7 00457	0000	03647	7 00466	0000	03650	7 00473	0000	03651	7 00477	0000	03652	7 00502	0000	03653	7 00504	0000	03654	7 00512	0000	03655	7 00514	0000	03656	7 00523	0000	03657	7 00534	0000	03660	7 00543	0000	03661	7 00550	0000	03662	7 00554	0000	03663	7 00557	0000	03664	7 00562	0000	03665	7 00567	0000	03666	7 00572	0000	03667	7 00603	0000	03670	7 00605	0000	03671	7 00610	0000	03672	7 00615	0000	03673	7 00620	0000	03674	7 00622	0000	03675	7 00626	0000	03676	7 00644	0000	03677	7 00647	0000	03700	7 00653	0000	03701	7 00660	0000	03702	7 00663	0000	03703	7 00665	0000	03704	7 00670	0000	03705	7 00675	0000	03706	7 00700	0000	03707	7 00730	0000	03710	7 00732	0000	03711	7 00756	0000	03712	7 00767	0000	03713	7 01016	0000	03714	7 01030	0000	03715	7 01057	0000	03716	7 01073	0000	03717	7 01127	0000	03720	7 01207	0000	03721	7 01214	0000	03722	7 01371	0000	03723	7 01432	0000	03724	7 01440	0000	03725	7 01462	0000	03726	7 01610	0000	03727	7 01742	0000	03730	7 01760	0000	03731	7 02016	0000	03732	7 02042	0000	03733	7 02060	0000	03734	7 02073	0000	03735	7 02116	0000	03736	7 02152	0000	03737	7 02201	0000	03740	7 02223	0000	03741	7 02242	0000	03742	7 02300	0000	03743	7 02313	0000	03744	7 02347	0000	03745	7 02354	0000	03746	7 02377	0000	03747	7 02442	0000	03750	7 02447	0000	03751	7 02466	0000	03752	7 02472	0000	03753	7 03056	0000	03754	7 03061	0000	03755	7 03067	0000	03756	7 03101	0000	03757	7 03126	0000	03760	7 03131	0000	03761	7 03147	0000	03762	7 03157	0000	03763	7 03165	0000	03764	7 03170	0000	03765	7 03172	0000	03766	7 03175	0000	03767	7 03202	0000	03770	7 03221	0000	03771	7 03224	0000	03772	7 03227	0000	03773	7 03232	0000	03774	7 03234	0000	03775	7 03251	0000	03776	7 03317	0000	03777	7 03356	0000
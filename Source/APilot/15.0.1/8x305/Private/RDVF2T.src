****** Rigid Disk Microcode for Etch 3 & above, Rev F1 * RDvF2.src --- 23-Sep-88 16:36:18	RLS* RDvF2T.src --- 6-Dec-88 13:45:09	MS***	Copyright (C) 1988 Xerox Corporation. All Rights Reserved.  *Copyright protection claimed includes all forms and matters of copyrightable*material and information now allowed by statutory or judicial law or *hereinafter granted, including without limitation, material generated *from the software programs which are displayed on the screen such as *icons, screen display looks, etc.****For use with Etch 3 or higher only**Derived from RdcE3A.src,  RdcE3B.src, RdcE3C.src & RDvE3D.src, RdcE3E*	with gaps between fields enlarged to correct write performance problem*	Changes to fix sector not found problem;*	sector length changed to agree with Bad Page Utility*	Bug in SKNEQ fixed*	RdGate timing corrected*	Bug in F1 fixed* 	PROG	RDVF2		OBJ      S/R**	MAC USE** L0 = 1; HI = 0 **      80       40         20         10        8*     SRCH     IBLA'     WRITE'     RGATE     ECCIZ'*OFF   LO       HI         HI         LO        HI     = 90X***DECLARATIONS	8X305	DEF	4,1,3*Write Commands & Partials*WRSPMA	EQU	2	ScratchPad Memory Address [XMIT  Add,IVL/WRSPMA]INDXOF	EQU	3	Index Off; data not usedWDDATA	EQU	4	WRITE DATA TO DISKWRDC1	EQU	5	Write Disk Control Reg 1WRLDSP	EQU	6	Left Display WRRDSP	EQU	15H	Right DisplayWRMAC	EQU	7	Write into MACWRDC2	EQU	11H	Write Disk Control Reg 2RSTLED	EQU	12H	Reset RDC display LED ControlWRSTAT	EQU	13H	Write RDC Status Reg-to IOPTGLA	EQU	14H	Toggle FF A in FIFO controlsWRFLO	EQU	16H	Write FIFO Low & Store in FIFOWRFHI	EQU	17H	Write FIFO Hi**Read Commands & Partials*SPD	EQU	37H	ScratchPadData [MOVE SPD,0,Rg]*			[MOVE  SPD,0,Rg/,1] moves & incrememts SPMAFIFSTA	EQU	2	FIFO Status registerRDCTL	EQU	3	Read RDC Control Register-from IOPRDDSK	EQU	4	Read Disk DataDSKST	EQU	5	DISK STATUSRDFLO	EQU	6	Read FIFO Low & cycle FIFORDFHI	EQU	7	Read FIFO Hi**DC2 Partials--use: Xmit Partial,IVL/WRDC2*STRINT	EQU	00X		Set Rigid Disk InterruptRSRINT	EQU	80X		Reset Rigid Disk InterruptSTWG	EQU	01X		Set WriteGate = WriteGate onRSWG	EQU	81X		Reset WriteGate = WriteGate offSTDIN	EQU	02X		Set Direction inSTDOT	EQU	82X		Set Direction Out {=Rst DIN}STLPB	EQU	03X		Set RD LoopBackRSLPB	EQU	83X		Rst RD LoopBackSTSTP	EQU	04X		Set Step = Step OnRSSTP	EQU	84X		Reset Step = Step OffSTWPC	EQU	05X		Set PreComp = PreComp OnRSWPC	EQU	85X		Reset PreComp = PreComp OffSTCRC	EQU	07X		Set CRCSTECC	EQU	87X		Set ECC = Reset CRC**ScratchPad Constants--use: Xmit Constant,IVL/WRSPMA*HDST	EQU	0DCX		SA OF HEADER IMAGELBLST	EQU	0EBX		SA OF LABEL IMAGEHDHD	EQU	0DEX		HD Byte in Header ImageHDSC	EQU	0DFX		Sector byte in Header ImageHDCYH	EQU	0DCX		Cyl hi in HeaderHDCYL	EQU	0DDX		Cyl lo in HeaderLBFPL	EQU	0F6X		FILE PAGE LO LO IN LABEL IMAGELBFPHH	EQU	0F7X		FilePageHi-Hi in Label ImageSECNTH	EQU	0C0X		No of sectors to transfer HiSECNTL	EQU	0C1X		No of sectors to transfer LoSECPT	EQU	0C3X		NoSectors+1 per trackHDSPC	EQU	0C5X		NoHeads+1 per cylCYLPDL	EQU	0C7X		NoCyls per drive+1-loCYLPDH	EQU	0C6X		NoCyls per drive+1 hiECCRF	EQU	0A0X		STCRC or STECCFIFFM	EQU	0A1X		FIFO Full or eMpty flagCURCLH	EQU	0A2X		Current Cylinder HiCURCLL	EQU	0A3X		Current Cylinder loOLDCMD	EQU	0A5X		previous commandCURCMD	EQU	0A6X		Current CommandDIAGF	EQU	0A7X		Diagnostic FlagCURST	EQU	0A8X		Current StatusFRSTWT	EQU	0A9X		First Write FlagECCF	EQU	0DBX		ECC FlagFCURCH	EQU	0D8X		FIFO-CurCyl HiFCURCL	EQU	0D9X		FIFO-CurCyl LoFSEC	EQU	0C9X		First Sector NumberWICYH	EQU	0CAX		RedWriteCur Cyl HiWICYL	EQU	0CBX		RedWriteCur Cyl loPCCYH	EQU	0CCX		PrecompCyl HiPCCYL	EQU	0CDX		PrecompCyl lo**Sector length: 1 if 256, 2 if 257, 3 if 258WENDC	EQU	0CFX		sector lengthWENDCA	EQU	0FFX		a copy of WENDC* loc 0D0X is always zero and = HDRERT HiHDRERT	EQU	0D1X		Contains HeaderErrType*loc 0D2X is always zero and = LBLERT hiLBLERT	EQU	0D3X		Contains LabelErrorType*loc 0D4X is always 0 and = DTAERT HiDTAERT	EQU	0D5X		Contains DataErrorType*loc 0D6X is always 0 and = LSTERT HiLSTERT	EQU	0D7X		Contains LastErrorType*DtaEcc and following 3 locations, 0BDX - 0BFX, contain the*  Data ECC syndromeDTAECC	EQU	0BCX		Start of DataBlock ECC SyndromeDVST	EQU	0E4X		Drive StatusCNTST	EQU	0E5X		Controller statusOPCODE	EQU	0E7X		Operation to be doneTKFH	EQU	0E8X		No of tracks to format, hiTKFL	EQU	0E9X		No of tracks to format, lo**MAC Constants--use: Xmit Constant,IVL/WRMAC*IBLA	EQU	320HIE	EQU	330H	IBLA + ECCIC ONWIE	EQU	370H	IBLA + WRITE + ECCIC ONWE	EQU	270H	WRITE + ECCIC ONIW	EQU	360H	IBLA + WRITE ONWRT	EQU	260H	WRITE ON**Registers*CNTRG	EQU	1	Counter RegSIGN	EQU	1	Sign Reg in arithmeticWRKR	EQU	2	WORKING REGISTERSTATRG	EQU	3	STAT INTO R3SL	EQU	3	Subtrahend LoDTARG	EQU	4	DTA REGSH	EQU	4	Subtrahend HiDTXLO	EQU	5	Data LoML	EQU	5	Minuend LoDTXHI	EQU	6	Data HiMH	EQU	6	Minuend LoECCFLG	EQU	14H	EccFlag; 1=ECC, 0=CRCIMMER	EQU	15H	Immediate errorERRTYP	EQU	16H	Keep error type***  The start of this system * Initalize**!!!!!!! START AT LOC 1-- LOC 0 IS FOR RESET BY 186 !!!!!!!!!*	ORG	0START	JMP	WTF0	NOP*TST  Next 4 instructions operate RDC LED Display	XMIT	0,IVL/RSTLED		Reset LED Control*	XMIT	0A5X,IVL/WRLDSP*	XMIT	0A5X,IVL/WRLDSP		'5A' in Left Display*	XMIT	5AX,IVL/WRRDSP*	XMIT	5AX,IVL/WRRDSP		'A5' in Rt DisplayLPHERE	JMP	LPHERE			Wait here for 186 reset**WTF0	XMIT	RSRINT,IVL/WRDC2	Reset interrupt	XMIT	90X,IVL/WRMAC		Set MAC to OFF states	XMIT	0,IVL/WDDATA		Write 0*Now clear SP to zerosCLSP	XMIT	1,AUX	XMIT	0,CNTRGCLSPA	MOVE	CNTRG,IVL/WRSPMA	Address of next mem loc in MA	ADD	CNTRG,CNTRG		Ready for next location	XMIT	0,IVR			Zero into loc	NZT	CNTRG,CLSPA		Loop*now make curcl = FFFF, cyl no not known	XMIT	CURCLH,IVL/WRSPMA	Address of current cyl hi	XMIT	0FFX,IVR		Make it FF	XMIT	CURCLL,IVL/WRSPMA	Address of current cyl lo	XMIT	0FFX,IVR		Make it FF	XMIT	0,IVL/WDDATA		Write 0*	WTZZ	CALL	WTCRS			wait for 00	XMIT	0FFX,AUX	XOR	DTARG,WRKR	NZT	WRKR,WTZZ		wait for cmd 00	XMIT	0FFX,IVL/WRSTAT		Send 00*TST  Next 4 instructions operate RDC LED Display	XMIT	0,IVL/RSTLED		Reset LED control*	XMIT	222H,IVL/WRLDSP*	XMIT	222H,IVL/WRLDSP		'6D' in Left Display*	XMIT	222H,IVL/WRRDSP*	XMIT	222H,IVL/WRRDSP		'6D' in Rt Display**Restore - Recalibrate the disk - THIS generates no errorsIRSTR	CALL	ZROERS			Zero error locs*TST Next 2 cmds operate RDC LED Display*	XMIT	6FX,IVL/WRRDSP*	XMIT	6FX,IVL/WRRDSP		Send 90 to Rt Disp	XMIT	357H,IVL/WRDC1		Sellect Drive	CALL	RESTR			Restore the disk*Now set CurCyl to zero	XMIT	CURCLH,IVL/WRSPMA	Address of CurCylHi	XMIT	0,IVR			Make it zero	XMIT	CURCLL,IVL/WRSPMA	Address of CurCylLo	XMIT	0,IVR			Make it 0*TST Next 2 cmds operate RDC LED Display*	XMIT	60X,IVL/WRRDSP*	XMIT	60X,IVL/WRRDSP		Send 9F to Rt Disp***Main Loop**Copmmands follow each in order 0, 1, 2, 3, 0, 1, 2, 3, 0,... EXCEPT*	0, 3 is also allowed.**Commands are recieved complemented-0 is received as 0FFX, ETC* Command sequence: EXCB checks that 2 is preceded by 1-no*   other sequence checking is done.* 0 = NOP* 1 = Get CB* 2 = Do instruction* 3 = load ending status**Put old CurrentCommand into OldCommandPML	XMIT	CURCMD,IVL/WRSPMA	Address of Current Command	NOP				Wait for address to settle	MOVE	SPD,0,WRKR	XMIT	OLDCMD,IVL/WRSPMA	ADDRESS OF OLDCOMMAND	MOVE	WRKR,IVR*	CALL	WTCRS			Get new command*TST Next 2 instructions operate RDC LED Display*	MOVE	DTARG,IVL/WRLDSP*	MOVE	DTARG,IVL/WRLDSP	Comp Cmd in Left Display	XMIT	0FFX,AUX	XOR	DTARG,DTARG		Compliment cmd	XMIT	OLDCMD,IVL/WRSPMA	Address of previous command	NOP				Wat for address to settle	MOVE	SPD,0,AUX		Old cmd to AUX	XOR	DTARG,WRKR 		Are new & old =?	NZT	WRKR,PMLA		Not same*TST Next 2 instructions operate RDC LED Display*	XMIT	221H,IVL/WRRDSP*	XMIT	221H,IVL/WRRDSP		Display 6E in rt disp	JMP	PML			Same-try again*Set Diag Flag if a diag commandPMLA	XMIT	40X,AUX			Mask for diag bit	AND	DTARG,WRKR		Diag bit in WRKR	XMIT	DIAGF,IVL/WRSPMA	Address of Diaf Flag	XMIT	0,IVR			Reset Diag Flag	NZT	WRKR,PMLB		Not Diagnostic 	XMIT	1,IVR			set diag flagPMLB	XMIT	3,AUX	AND	DTARG,DTARG		Look at command bits only*Put command into CurrentCommand so that Execute command can check*that  cmd 1, Load CommnadBlock preceeded,cmd 2, ExecuteCommand	XMIT	CURCMD,IVL/WRSPMA	Address of curcmd	MOVE	DTARG,IVR		Put current commnad into CurCmd*TST Next 2 commands operate RDC LED Display*	MOVE	DTARG,IVL/WRLDSP*	MOVE	DTARG,IVL/WRLDSP	Current cmd in Lft Display	XEC	CMPTBL(DTARG),4		DispatchCMPTBL	JMP	NPCB			Noop	JMP	GTCB			Get CommandBlock	JMP	EXCB			Execute CommandBlock	JMP	LDCB			Load CommandBlock*** Do NOOP command-- Idle LoopNPCB	XMIT	RSRINT,IVL/WRDC2	Reset RigidDisk Interrupt	XMIT	0FFX,IVL/WRSTAT		Send "in idleloop"*TST Next 2 commands operate RDC LED Display*	XMIT	0FFX,IVL/WRRDSP*	XMIT	0FFX,IVL/WRRDSP		0 in RT Display	JMP	PML			Loop**COMMAND EXECUTERS**GTCB*GetCommandBlock  * New  September 11, 1984  4:54 PM-*Rev a*Assume DCB correct for me- compliment for 186,*any byte swap done**load 23 words starting at loc DTAECC*1 byte of 0*10 words of data, the label*check for FIFO empty between each word***GTCB	XMIT	RSRINT,IVL/WRDC2	Reset RigidDisk Interrupt	XMIT	0FEX,IVL/WRSTAT		Send " In Get CommandBlock mode"*TST Next 2 commands operate RDC LED Display*	XMIT	0EFX,IVL/WRRDSP*	XMIT	0EFX,IVL/WRRDSP		put 10 in rt display	XMIT	0,IMMER			Clear immdiate error reg	XMIT	-23,CNTRG		No of words	XMIT	DTAECC,WRKR		Address in SP	XMIT	0,DTXLO			Flag = 0	XMIT	1,AUX* FIFO was empty when last read; now wait until not empty*	then do a dummy read to prime FIFO out*GTCBA	MOVE	26H,1,STATRG/,,FIFSTA	Is FIFO empty?	NZT	STATRG,GTCBA		FIFO is empty-WAIT	MOVE	27H,0,DTARG/,,RDFLO	Dummy read-cycle FIFO*GTCBB	MOVE	WRKR,IVL/WRSPMA		Address of first byte	NOP				Wait for address to settle	MOVE	27H,0,DTARG/,,RDFHI	FIFO Hi byte	MOVE	DTARG,IVR		Dta to SP	ADD	WRKR,WRKR		Incr SP Address	MOVE	WRKR,IVL/WRSPMA		Address of lo byte	NOP				Wait for address to settle	MOVE	27H,0,DTARG/,,RDFLO	FIFO lo byte, get next word	MOVE	DTARG,IVR		Data to SP	ADD	WRKR,WRKR		Next SP address	ADD	CNTRG,CNTRG		Finished?	NZT	CNTRG,GTCBC		Continue	JMP	GTCBF			FinishedGTCBC	MOVE	22H,1,STATRG/,,FIFSTA	Was FIFO empty at last read?	NZT	STATRG,GTCBA		Fifo was empty-wait until not empty	JMP	GTCBB			Not empty-loop*GTCBF	NZT	DTXLO,GTCBFF		Flag not zero, over	XMIT	-10,CNTRG		Cntr for label image	MOVE	WRKR,IVL/WRSPMA		Not used loc in SP	XMIT	0,IVR			Put zero in it	ADD	WRKR,WRKR		Count SP address	XMIT	1,DTXLO			flag = ,1, label done	MOVE	22H,1,STATRG/,,FIFSTA	Was FIFO empty at last read?	NZT	STATRG,GTCBA		Fifo was empty-wait until not empty	JMP	GTCBB			Get label image*GTCBFF	XMIT	0BEX,IVL/WRSTAT		Send "done"	XMIT	STRINT,IVL/WRDC2	Interrupt on*TST Next 2 cmds operate RDC LED Display*	XMIT	0E0X,IVL/WRRDSP*	XMIT	0E0X,IVL/WRRDSP		Display 1F in right	JMP	PML			Wait for next command***Execute OPERATION*EXCB	XMIT	RSRINT,IVL/WRDC2		Reset RigidDisk Interrupt* If OldCmd is not = 1, error	XMIT	OLDCMD,IVL/WRSPMA		Address of OldCmd	XMIT	1,AUX	MOVE	SPD,0,DTARG		Get OldCommand	XOR	DTARG,WRKR		Compare OldCmd with 1	NZT	WRKR,EXCBER		OldCmd not = 1, error	XMIT	0FDX,IVL/WRSTAT		Send "in EcexuteCB"*TST Next 2 cmds operate RDC LED Display*	XMIT	0DFX,IVL/WRRDSP*	XMIT	0DFX,IVL/WRRDSP		Send 20 to Rtr Dsp* copy WENDC into WENDCA	XMIT	WENDC,IVL/WRSPMA	Address of WENDC	NOP				Wait for address to settle	MOVE	SPD,0,WRKR	XMIT	WENDCA,IVL/WRSPMA	MOVE	WRKR,IVR		WENDC copied to WENDCA******* Track Read Command	XMIT	OPCODE,IVL/WRSPMA	Address of opcode	XMIT	10X,AUX			mask for Track Read Command bits	XOR	SPD,0,WRKR		Get opcode	ORG	3,256	NZT	WRKR,NTRCK			JMP	TRKRD****** Track Read CommandNTRCK	XMIT	OPCODE,IVL/WRSPMA	Address of opcode	XMIT	48X,AUX			mask for DIAG bits	MOVE	SPD,0,R11		Get opcode	AND	R11,WRKR		look at DIAG bits	NZT	WRKR,DAGH		Operation is diagnostic	XMIT	7,AUX			mask for normal opcode	AND	R11,R11			look at 3 bits	XEC	OPTBL(R11),8		dispatch on opcodeOPTBL	JMP	RSTRD			Restore - Recalibrate	JMP	FRMTT			Format - www	JMP	REDDSK			Read - vvr	JMP	WTDSK			Write - vvw	JMP	WTLBDS			Write Label & Data - vww	JMP	RDLBS			Read Label & Skip Data - vrn	JMP	RDLBDS			Read Label & Data - vrr	JMP	VFYDTA			Verify Data - vvv***EXCBER	XMIT	8CX,ERRTYP		Protocol sequence error*TST Next 2 cmds operate RDC LED Display*	XMIT	0DEX,IVL/WRRDSP*	XMIT	0DEX,IVL/WRRDSP		Send 21 to Rt Dsp	JMP	GERENA** Execute Diagnostic commandsDAGH	NOP	XMIT	8BX,ERRTYP		Illegal Diagnostic command*TST Next 2 cmds operate RDC LED Display*	XMIT	0DDX,IVL/WRRDSP*	XMIT	0DDX,IVL/WRRDSP		Send 22 to Rt Disp	JMP	GERENA*****************************Load Command Block*Put Command Block in SP memory into FIFO so the IOP*	& Mesa world can look at it**************************LDCB	XMIT	0C4X,IVL/WRSPMA	XMIT	1,IVR			Set version number*	XMIT	RSRINT,IVL/WRDC2	Reset RigidDisk Interrupt	XMIT	0FCX,IVL/WRSTAT		Send "in Load CB "*TST Next 2 cmds operate RDC LED Display*	XMIT	0CFX,IVL/WRRDSP*	XMIT	0CFX,IVL/WRRDSP		Display 30 in rt dsp	XMIT	0C8X,IVL/WRSPMA		Addr of inv/non-inv test	XMIT	0,IVR			Zero in test locLDCBA	XMIT	0,IMMER	XMIT	-23,CNTRG		No of words	XMIT	DTAECC,WRKR		SA of Command BlockLDCBB	MOVE	26H,1,STATRG/,,FIFSTA	Is FIFO empty?	NZT	STATRG,LDCCC		Yes, go on	JMP	LDCBER			No, errorLDCCC	XMIT	0,DTXLO			Pass flag = 0	XMIT	1,AUX*LDCBC	MOVE	WRKR,IVL/WRSPMA		Address of first byte in CB	NOP				Wait for address to settle	MOVE	SPD,0,DTARG		Get byte	MOVE	DTARG,IVL/WRFHI		put into FIFO, Hi byte	ADD	WRKR,WRKR	  	Next SP address	MOVE	WRKR,IVL/WRSPMA		Next address	NOP				Wait for address to settle	MOVE	SPD,0,DTARG		Next byte	MOVE	DTARG,IVL/WRFLO		Data to FIFO LO, write FIFO	ADD	WRKR,WRKR	ADD	CNTRG,CNTRG	NZT	CNTRG,LDCBC		Not finished	NZT	DTXLO,LDCBF		Is Pass Flag = 1? 	XMIT	1,DTXLO			No- make it 1	XMIT	-10,CNTRG	ADD	WRKR,WRKR		Skip one byte in SP	JMP	LDCBC			Put Label image into FIFO*LDCBF	NZT	IMMER,LDCBFE		Error, go to error exit	XMIT	0BCX,IVL/WRSTAT		Send done	XMIT	STRINT,IVL/WRDC2		Rigid Disk Interrupt on*TST Next 2 cmds operate RDC LED Display*	XMIT	0C0X,IVL/WRRDSP*	XMIT	0C0X,IVL/WRRDSP		Send 3F to Rt Disp	JMP	PML**Error Exit- an error has occured while loading DCBLDCBFE	XMIT	2CX,IVL/WRSTAT		Send error done*TST Next 2 cmds operate RDC LED Display*	XMIT	0CEX,IVL/WRRDSP*	XMIT	0CEX,IVL/WRRDSP		Send 31 to Rt Disp	JMP	CMPSJ*LDCBER	XMIT	7,ERRTYP		FIFO not empty at LDCB	XMIT	7,IMMER			FIFO not empty at LDCB	JMP	LDCCC			Resume Loading CB******Restore - Recalibrate the disk - THIS OP generates no errorsRSTRD	CALL	ZROERS			Zero error locs*TST Next 2 cmds operate RDC LED Display*	XMIT	6FX,IVL/WRRDSP*	XMIT	6FX,IVL/WRRDSP		Send 90 to Rt Disp	CALL	SELHD			Sellect Hd & Drive	CALL	RESTR			Restore the disk*Now set CurCyl to zero	XMIT	CURCLH,IVL/WRSPMA	Address of CurCylHi	XMIT	0,IVR			Make it zero	XMIT	CURCLL,IVL/WRSPMA	Address of CurCylLo	XMIT	0,IVR			Make it 0*TST Next 2 cmds operate RDC LED Display*	XMIT	60X,IVL/WRRDSP*	XMIT	60X,IVL/WRRDSP		Send 9F to Rt Disp	JMP	OPEND***  	VVV   Verify,Verify,Verify*Verify data- compares disk data with memory dataVFYDTA	NOP*TST Next 2 cmds operate RDC LED Display*	XMIT	0FX,IVL/WRRDSP*	XMIT	0FX,IVL/WRRDSP		Send F0 to Rt Display**VFYDT1	CALL	ZROERS			Zero error locs**********************************************************The IOCB is to contain:*  If Not Diagnostic command: ECCRF _ STECC*		WENDC _ -1*  If Diagnostic command: *     If CRC  ECCRF _ STCRC; *     If Long Write & CRC WENDC _ -2*     If not Long Write WENDC _ -1******************************************************** Set ECCRF according to ECCF* ECCF is 0 for ECC, 1 for CRC (Diag only)	XMIT	ECCF,IVL/WRSPMA		Address of ECCF	NOP				Wait for addrss to settle	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA		Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1	NZT	WRKR,VFYSKP	XMIT	STECC,IVR		If ECCF = 0VFYSKP	CALL	SELHD			Sellect Head & Drive	XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag	XMIT	1,IVR			FirstWriteFlag = 1	XMIT	FIFFM,IVL/WRSPMA	Address of FIFO Emptyflag	XMIT	0,IVR			Make it 0**Compare CurrentCyl with Cyl from HederImage.  If different, seek*	XMIT	0,IMMER			CALL	IMPSK**If IMMER is not zero, an error has occured*	ORG	29,256	NZT	IMMER,ERENDA*VFYSK	XMIT	0,IMMER			Continue Verifying sectors loops here	XMIT	0,CNTRG	CALL	WFFCK			Check FIFO full, empty, half full	NZT	IMMER,ERENDA		an error has occured*	XMIT	1,ECCFLG		Set to CRC	CALL	VFYHD			Verify Header* Wait 8 bytes before starting to verify label	XMIT	-30,DTARG	CALL	WTINST	CALL	VFYLBL			Verify Label* Wait 7 bytes before starting to verify data	XMIT	-26,DTARG	CALL	WTINST	XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB	NOP				Wait for address to settle	MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag	CALL	VFDTA			Verify Data	NZT	ERRTYP,ERENDA		Error has occured-stop process here	CALL	NXTSC			Next sector?	NZT	IMMER,ERENDA		Error end	NZT	DTARG,VFYSK		Do next sector	JMP	OPCMP			Operation completed*ERENDA	NOP*TST Next 2 operate RDC LED Display*	XMIT	00,IVL/WRRDSP*	XMIT	00,IVL/WRRDSP		Send FF to Rt Disp	JMP	EREND***	VVR  Verify, Verify, Read*READ DISK*REDDSK	CALL	ZROERS			Zero error locs**********************************************************The IOCB is to contain:*  If Not Diagnostic command:*		WENDC _ -1*  If Diagnostic command: *     If CRC  ECCRF _ STCRC; *     IF Long Write & ECC WENDC _ -3*     If Long Write & CRC WENDC _ -2*     If not Long Write WENDC _ -1********************************************************TST  Next 2 cmds operate RDC LED Display*	XMIT	4FX,IVL/WRRDSP*	XMIT	4FX,IVL/WRRDSP		SEND B0 TO RT DISP* Set ECCRF according to ECCF* ECCF is 0 for ECC, 1 for CRC (Diag only)	XMIT	ECCF,IVL/WRSPMA		Address of ECCF	NOP				Wait for address to settle	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1*	ORG	3,32	NZT	WRKR,RDDSK2	XMIT	STECC,IVR		If ECCF = 0RDDSK2	XMIT	FIFFM,IVL/WRSPMA	SP address for FIF F/eM flag	XMIT	0,IVR			Flag _ 0*	*Compare CurrentCyl with Cyl from HederImage.  If different, seek*	CALL	SELHD			Sellect Head & Drive	XMIT	0,IMMER			CALL	IMPSK**If IMMER is not zero, an error has occured*	NZT	IMMER,ERENDA*	ORG	34,256	ORG	4,32	NZT	26H,1,RDSK/,,FIFSTA	Is FIFO Empty?	JMP	ERR3			FIFO is not empty*RDSK	XMIT	0,IMMER			Continue reading sectors loops here	XMIT	0,CNTRG	CALL	RFFCK			Check FIFO full, empty, half full	NZT	IMMER,ERENDB		an error has occured	XMIT	0,IVL/TGLA		Toggle FF A	XMIT	1,ECCFLG		Set to CRC	CALL	VFYHD			Verify Header* Wait 8 bytes before starting to verify label	XMIT	-30,DTARG	CALL	WTINST	CALL	VFYLBL* Wait 7 bytes before starting to read data	XMIT	-26,DTARG	CALL	WTINST			Verify Label	XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB	NOP				Wait for address to settle	MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag	CALL	RDDTA			Read Data	NZT	ERRTYP,ERENDB		Error has occured-stop process here	CALL	NXTSC			Next sector?	NZT	IMMER,ERENDB		Error end	NZT	DTARG,RDSK		Do next sector	JMP	OPCMP			Operation completed**FIFO not empty at beginning of Read Disk*ERR3	XMIT	3,ERRTYP**TST Next 2 cmds operate RDC LED Display*	XMIT	4EX,IVL/WRRDSP*	XMIT	4EX,IVL/WRRDSP		SEND B1 TO RT DISPERENDB	JMP	EREND****	VVW- Verify, Verify, Write* WRITE DISK from FIFO**WTDSK	CALL	ZROERS			Zero error locs***********************************************************The IOCB is to set:*  If Not Diagnostic command: C*		WENDC _ -1*  If Diagnostic command: *     If CRC  ECCRF _ STCRC; *     IF Long Write & ECC WENDC _ -3*     If Long Write & CRC WENDC _ -2*     If not Long Write WENDC _ -1********************************************************TST Next 2 cmds operate RDC LED Display*	XMIT	3FX,IVL/WRRDSP*	XMIT	3FX,IVL/WRRDSP		Send C0 to Rt Disp* Set ECCRF according to ECCF* ECCF is 0 for ECC, 1 for CRC (Diag only)	XMIT	ECCF,IVL/WRSPMA		Address of ECCF	NOP	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1	NZT	WRKR,WTDBB	XMIT	STECC,IVR		If ECCF = 0WTDBB	CALL	SELHD			Sellect Head & Drive	XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag	XMIT	1,IVR			FirstWriteFlag = 1	XMIT	FIFFM,IVL/WRSPMA	Address of FIFO Empty flag	XMIT	0,IVR			Make it 0	XMIT	0,IMMER			** Compare CurrentCyl with Cyl from HederImage.  If different, seek*	CALL	IMPSK**If IMMER is not zero, an error has occured*	NZT	IMMER,ERENDD*	ORG	25,256WTDC	XMIT	0,IMMER			Continue writing sectors loops here	XMIT	0,CNTRG*	CALL	WFFCK			Check FIFI full, empty, half full	NZT	IMMER,ERENDD		Error has occured	XMIT	1,ECCFLG		Set to CRC	CALL	VFYHD			Verify Header* Wait 8 bytes before starting to verify label	XMIT	-30,DTARG	CALL	WTINST	CALL	VFYLBL			Verify Label	NZT	ERRTYP,ERENDD		Error, no write*	XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB	NOP				Wait for address to settle	MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag	CALL	WTDTA			Write Data	CALL	NXTSC			Next sector?	NZT	IMMER,ERENDD		Error end	NZT	DTARG,WTDC		Do next sector*	JMP	OPEND			Operation end*ERENDD	NOP*TST Next 2 cmds operate RDC LED Display*	XMIT	3EX,IVL/WRRDSP*	XMIT	3EX,IVL/WRRDSP		Send C1 to rt Disp	JMP	EREND*****	VWW,  Verify, Write, Write* WRITE LABEL & DATA from FIFO**WTLBDS	CALL	ZROERS			Zero error locs***********************************************************The IOCB is to set:*  If Not Diagnostic command: *		WENDC _ -1*  If Diagnostic command: *     If CRC  ECCRF _ STCRC; *     IF Long Write & ECC WENDC _ -3*     If Long Write & CRC WENDC _ -2*     If not Long Write WENDC _ -1********************************************************TST Next 2 cmds operate RDC LED Display*	XMIT	2FX,IVL/WRRDSP*	XMIT	2FX,IVL/WRRDSP		Send D0 to Rt Disp* Set ECCRF according to ECCF* ECCF is 0 for ECC, 1 for CRC (Diag only)	XMIT	ECCF,IVL/WRSPMA		Address of ECCF	NOP				Wait for address to settle	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1	ORG	3,256	NZT	WRKR,WTLBBB	XMIT	STECC,IVR		If ECCF = 0WTLBBB	CALL	SELHD			Sellect Head & Drive	XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag	XMIT	1,IVR			FirstWriteFlag = 1	XMIT	FIFFM,IVL/WRSPMA	Address of FIFO Empty flag	XMIT	0,IVR			Make it 0 ** Compare CurrentCyl with Cyl from HederImage.  If different, seek*	XMIT	0,IMMER	CALL	IMPSK**If IMMER is not zero, an error has occured*	NZT	IMMER,ERENDCWTLBDC	XMIT	0,IMMER			Continue writing sectors loops here	XMIT	0,CNTRG*	CALL	WFFCK			Check FIFI full, empty, half full	NZT	IMMER,ERENDC		Error has occured	XMIT	1,ECCFLG		Set to CRC	CALL	VFYHD			Verify Header	NZT	ERRTYP,ERENDC		Error, no write*	CALL	WTLBL			write Label* Wait 2 byteS before starting to write data 	XMIT	-6,DTARG	CALL	WTINST	XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB	NOP				Wait for address to settle	MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag	CALL	WTDTA			Write Data*	ORG	11,256	NZT	ERRTYP,ERENDC		Error has occured-stop process here	CALL	NXTSC			Next sector?	NZT	IMMER,ERENDC		Error end	NZT	DTARG,WTLBCC		Do next sector	JMP	OPENDERENDC	NOP*TST Next 2  cmds operate RDC LED Display*	XMIT	20X,IVL/WRRDSP*	XMIT	20X,IVL/WRRDSP		Send DF to Rt Display	JMP	ERENDWTLBCC	JMP	WTLBDC***	VRN  Verify, Read, Nop***************************************** Read Label*Read Label is a one-sector operation*It will not continue into another sector*The label read replaces the LabelImage in the CommandBlock******************************************RDLBS	NOP*TST Next 2  cmd operate RDC LED Display*	XMIT	1FX,IVL/WRRDSP*	XMIT	1FX,IVL/WRRDSP		Send E0 to rt Disp	CALL	ZROERS			Zero error locsRLBSKP	CALL	SELHD			Sellect Head & DriveRLBSK	XMIT	0,IMMER	**Compare CurrentCyl with Cyl from HederImage.  If different, seek*	CALL	IMPSK**If IMMER is not zero, an error has occureds*	NZT	IMMER,ERENDC	XMIT	1,ECCFLG		Set to CRC	XMIT	0,CNTRG	CALL	VFYHD			Verify Header* Wait 8 bytes before starting to read label	XMIT	-30,DTARG	CALL	WTINST	CALL	RDLBL			Read Label	NZT	ERRTYP,ERENDC		Error has occured-stop process	JMP	OPCMP			Operation completed****	VRR, Verify, Read, Read*READ LABEL & DATA*RDLBDS	CALL	ZROERS			Zero error locs***********************************************************At end label data read is in DCB; data read is in memory**The IOCB is to contain:*  If Not Diagnostic command: *		WENDC _ -1*  If Diagnostic command: *     If CRC  ECCRF _ STCRC; *     IF Long Write & ECC WENDC _ -3*     If Long Write & CRC WENDC _ -2*     If not Long Write WENDC _ -1********************************************************TST Next 2 cmds operate RDC LED Display*	XMIT	7FX,IVL/WRRDSP*	XMIT	7FX,IVL/WRRDSP		SEND 80 TO RT DISP* Set ECCRF according to ECCF* ECCF is 0 for ECC, 1 for CRC (Diag only)	XMIT	ECCF,IVL/WRSPMA		Address of ECCF	NOP				Wait for address to settle	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1	NZT	WRKR,RDLDS2	XMIT	STECC,IVR		If ECCF = 0RDLDS2	XMIT	FIFFM,IVL/WRSPMA	SP address for FIF F/eM flag	XMIT	0,IVR			Flag _ 0	ORG	3,32	NZT	26H,1,RDLDS3/,,FIFSTA	Is FIFO Empty?	JMP	RDLSE3			FIFO is not emptyRDLDS3	CALL	SELHD			Sellect Head & Drive**Compare CurrentCyl with Cyl from HederImage.  If different, seek*	XMIT	0,IMMER		CALL	IMPSK*	*If IMMER is not zero, an error has occured*	ORG	30,256	NZT	IMMER,ERENDFRDLDS4	XMIT	0,CNTRG			Continue reading sectors loops here	CALL	RFFCK			Check FIFO full, empty, half full	NZT	IMMER,ERENDF		an error has occured	XMIT	0,IVL/TGLA		Toggle FF A	XMIT	1,ECCFLG		Set to CRC	CALL	VFYHD			Verify Header* Wait 8 bytes before starting to read label	XMIT	-30,DTARG	CALL	WTINST	CALL	RDLBL			Read Label* Wait 7 byte before starting to read data	XMIT	-26,DTARG	CALL	WTINST	XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB	NOP				Wait for address to settle	MOVE	SPD,0,ECCFLG		Set Reg = IOCB flag	CALL	RDDTA			Read Data	NZT	ERRTYP,ERENDF		Error has occured-stop process here	CALL	NXTSC			Next sector?	NZT	IMMER,ERENDF		Error end	NZT	DTARG,RDLDS4		Do next sector	JMP	OPCMP			Operation completed*ERENDF	JMP	EREND**FIFO not empty at beginning of Read Disk*RDLSE3	XMIT	3,ERRTYP**TST Next 2 cmds operate RDC LED Display*	XMIT	7EX,IVL/WRRDSP*	XMIT	7EX,IVL/WRRDSP		SEND 81 TO RT DISPERENDE	JMP	EREND*****Format the disk   August 3, 1984  4:05 PM-*	Rev  September 25, 1984  11:45 AM *   Gap length revised  28-Jan-85 10:18:12*	&    7-Feb-85 12:38:11**Format the disk*Minimum format length is one track*dCB specifies start cylinder, in the header, & gives start header*& label*dCB also specifies no of TRACKS to be formatted.*  Header will be forced to have sector number = FSEC,*  First sector number per track*While formatting track, normal incrememts will be made*  to sector no & FPg; after formating one track, normal*  increments will be made to header & label,*  and implied seek & sellect head will functin as normally.**This process does not check the format-*  it is recommended that a disk scan be done to check the disk**FRMTT	NOP*TST Next 2  cmds operate RDC LED Display*	XMIT	5FX,IVL/WRRDSP*	XMIT	5FX,IVL/WRRDSP		Send A0 to Rt Disp	XMIT	0,IMMER	XMIT	0,ERRTYP*force starting sector number = First sector number (FSEC)	XMIT	FSEC,IVL/WRSPMA		Address of first sec	NOP				Allow address to settle	MOVE	SPD,0,WRKR	XMIT	HDSC,IVL/WRSPMA		Address of sector no in header	MOVE	WRKR,IVR		Into header* Set ECCFLG & ECCRF to CRC & ECC respectively	XMIT	1,ECCFLG		Set to CRC	XMIT	ECCF,IVL/WRSPMA		Address of ECCF in SP	NOP				Allow address to settle	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1	ORG	3,256	NZT	WRKR,C	XMIT	STECC,IVR		If ECCF = 0*C	CALL	SELHD			Sellect head & driveD	CALL	IMPSK			Do implied seek**If IMMER is not zero, an error has occured*	MOVE	IMMER,ERRTYP	NZT	IMMER,*+2		Command expanded	JMP	*+2			to avoid page error	JMP	EREND**Wait for index** NOTE  WE WANT TO DETECT THE LEADING EDGE OF THE INDEX PULSE.*  WE ACTUALLY LOOK AT THE INDEX STORAGE FF, WHICH IS SET BY*  INDEX & RESET BY INDXOF.  THEREFORE WE MUST FIRST RESET INDEX*  AND THEN LOOK FOR INDEX .*  *A	XMIT	0,IVL/INDXOF		Index Off-INDEX MAY HAVE BEEN ON	NOP				WAIT FOR INDEX FF TO RESET	NOP				WAIT SOMEMOREB	NZT	24H,1,B/,,DSKST		Wait until INDEX	XMIT	0,IVL/INDXOF		INDX OFF**First, write the Initial Gap*WIG	XMIT	STCRC,IVL/WRDC2		SET TO CRC	XMIT	0,IVL/WDDATA		load data = 0	XMIT	WRT,IVL/WRMAC		WRITE ON	XMIT	WE,IVL/WRMAC		E + WRITE ON	XMIT	WRT,IVL/WRMAC		WRITE ON-ECCIZ OFF	XMIT	-40,DTARG		SET UP LOOP COUNT FOR IGAP	NZT	21H,1,*/,,FIFSTA	WAIT FOR BDONE	XMIT	STWG,IVL/WRDC2		WRITE GATE ON	XMIT	0,IVL/WDDATA		write 0s	CALL	WG			Write Initial Gap**WIG3	NZT	21H,1,WIG3/,,FIFSTA	WAIT FOR BDONE	XMIT	0,IVL/WDDATA		write 0s* Now write the HeaderWHDR	XMIT	-18,DTARG		Gap Length	XMIT	WE,IVL/WRMAC		Write + ECCIZ	XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off	NZT	21H,1,*/,,FIFSTA		WAIT FOR BDONE	XMIT	0,IVL/WDDATA		write 0s	CALL	WG			Write Gap	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0A1X,IVL/WDDATA		Write Address Mark byte	XMIT	HDST,IVL/WRSPMA		SA of Header Image	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0FEX,IVL/WDDATA		Write HEADER ID byte	NOP	ORG	4,32WHDR4	NZT	21H,1,WHDR4/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,IVL/WDDATA,1	Data from mem to disk, incr SPMA	NOP				Wait for incr to finish	NZT	23H,1,WHDR4/,,FIFSTA	End of header data?	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, CRC out	XMIT	IW,IVL/WRMAC		Write+IBLA--write CRC	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, CRC out	XMIT	-13,DTARG		Set up gap length	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	CALL	WG			Write gap -incl 3 guard bytes	NZT	21H,1,*/,,FIFSTA		Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		WRITE ON, IBLA OFF*Now write the label	XMIT	-7,DTARG		Gap lengthWTLBL1	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		Write + ECCIZ	XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off	CALL	WG			Write Gap	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0A1X,IVL/WDDATA		Write Address Mark	XMIT	LBLST,IVL/WRSPMA	SA of Label Image	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0FCX,IVL/WDDATA		Write LABEL ID	NOP	ORG	4,32WTLBL4	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,IVL/WDDATA,1	Data from mem to disk, incr SPMA	NOP	NZT	24H,1,WTLBL4/,,FIFSTA	End of label?	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, CRC out	XMIT	IW,IVL/WRMAC		Write+IBLA--write CRC	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, CRC out	XMIT	-13,DTARG		Set Up Gap Length	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	CALL	WG			Write Gap, includes guard bytes	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		Write on, IBLA off*Now write data block*Set to ECC/CRC depending on ECCRF	MOVE	SPD,0,IVL/WRDC2		Set for ECC/CRC (ECC normal)	XMIT	0,CNTRG			First byte is 0	XMIT	-6,DTARG		Gap LengthFRDTA1	NZT	21H,1,FRDTA1/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		Write + ECCIZ	XMIT	WRT,IVL/WRMAC		Write on, ECCIZ off	CALL	WG			Write Gap	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0A1X,IVL/WDDATA		Write Address Mark	XMIT	0,IVL/WRSPMA		Set up SPMA to count words	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0FBX,IVL/WDDATA		Write DATA ID	NOP	ORG	8,32FRDTA4	NZT	21H,1,FRDTA4/,,FIFSTA	Wait for BDONE	MOVE	CNTRG,IVL/WDDATA	DATA TO DISK	ADD	CNTRG,CNTRG	MOVE	SPD,0,WRKR/,1		Get & ignore data, incr SPMA	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	CNTRG,IVL/WDDATA	DATA TO DISK	ADD	CNTRG,CNTRG	NZT	24H,1,FRDTA4/,,FIFSTA	Finished with count?*SPMA only counts to 255 (0-254), we need 1 more word	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	CNTRG,IVL/WDDATA	DATA TO DISK	ADD	CNTRG,CNTRG	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	CNTRG,IVL/WDDATA	DATA TO DISK	NOP	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, ECC out	XMIT	IW,IVL/WRMAC		Write+IBLA--write ECC	XMIT	-12,DTARG		Set Up Gap Length	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, ECC out	CALL	WG			Write Gap, incl guard bytes & ECC	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		WRITE ON-IBLA OFF*Now, determine if we are at the end of the track	XMIT	HDSC,IVL/WRSPMA		Address of sector no	XMIT	1,AUX	ADD	SPD,0,WRKR	Previous sector + 1, do not put back	NZT	21H,1,*/,,FIFSTA		Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0* last time for Wait for BDONE & load data* let hardware run writing zeros without attention.	XMIT	SECPT,IVL/WRSPMA	Addr of last sector no + 1	NOP				Wait for address to settle	MOVE	SPD,0,AUX	XOR	WRKR,WRKR		Last sector of track?	NZT	WRKR,*+2		No-step sec & label	JMP	*+2			Expand to prevent	JMP	FRDTAH				page error*We are at the end of a track* continue to write zeros to the end of the track	NZT	24H,1,*/,,DSKST		Wait for index	NOP	XMIT	0,IVL/INDXOF		Index off*Write two words after index to cover any unwritten area just*  when format starts	NZT	21H,1,*/,,FIFSTA		Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	NOP	NZT	21H,1,*/,,FIFSTA		Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	NOP	NZT	21H,1,*/,,FIFSTA		Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	NOP	NZT	21H,1,*/,,FIFSTA		Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	XMIT	RSWG,IVL/WRDC2		write gate off	XMIT	90X,IVL/WRMAC		write ended*Any more tracks to format?	XMIT	TKFH,IVL/WRSPMA		Address of no of tracks to format	NOP				Wait for address to settle	MOVE	SPD,0,DTXHI		Get hi part	XMIT	TKFL,IVL/WRSPMA		Address of no of tracks to format	XMIT	1,AUX	MOVE	SPD,0,DTXLO		Get Lo part	ADD	DTXLO,DTXLO	MOVE	OVF,AUX	ADD	DTXHI,DTXHI		Add in cary	MOVE	DTXLO,IVR		Put lo part back	XMIT	TKFH,IVL/WRSPMA		Address of hi part	MOVE	DTXHI,IVR		Hi part back	ORG	12,256	NZT	DTXLO,FRDTAJ		Format not over	NZT	DTXHI,FRDTAJ		Format not over	JMP	OPCMP			Format ended*Format next sectorFRDTAH	CALL	NXTSE		Next sector no, head, cylinder	NZT	IMMER,FMTER		has an error occured? 	XMIT	0,IVL/WDDATA		Write zeros	JMP	WIG3			format next sector* Format next trackFRDTAJ	CALL	NXTSE		Next sector no, head, cylinder	NZT	IMMER,FMTER		has an error occured? 	JMP	D			Format next track after next index*FMTER	NOP*TST Next 2 cmds operate RDC LED Display*	XMIT	50X,IVL/WRRDSP*	XMIT	50X,IVL/WRRDSP		Send AF to rt Disp	MOVE	IMMER,ERRTYP	JMP	EREND***Move CurCyl into FCurCyl; put current drive & controller*  status into dCBOPEND	NOPOPCMP	XMIT	0BDX,IVL/WRSTAT		Execut done to IOP*TST Next 2 cmds operate RDC LED Display*	XMIT	0D0X,IVL/WRRDSP*	XMIT	0D0X,IVL/WRRDSP		Send 2F to Rd Disp*Put Drive Status & Controler Status into SP for Disk Control Block	XMIT	DVST,IVL/WRSPMA		Address of DriveStatus	MOVE	27H,0,WRKR/,,DSKST	MOVE	WRKR,IVR		DiskStatus to DCB	XMIT	CNTST,IVL/WRSPMA	Address of Controller status	MOVE	27H,0,WRKR/,,FIFSTA	FIFO, etc, status	MOVE	WRKR,IVR		Status into DCB	ORG	5,256*Deselect drive UNLESS WriteFault on- if on, error	MOVE	26H,1,WRKR/,,DSKST	Look at WriteFault	NZT	WRKR,CMPSI		Xfr if not WriteFault	XMIT	3DX,IVL/WRSTAT		Send execute done error	JMP	GERENB			Mark WriteFaultErrorCMPSI	XMIT	377H,IVL/WRDC1		Deselect drive,sel hd 0* Make FCurCyl = CurCylCMPSJ	XMIT	CURCLH,IVL/WRSPMA	Address of CurCyl, hi	NOP				Wait for address to settle	MOVE	SPD,0,WRKR	XMIT	FCURCH,IVL/WRSPMA	Address of FCurCyl, hi	MOVE	WRKR,IVR		Hi part moved	XMIT	CURCLL,IVL/WRSPMA	NOP				Wait for address to settle	MOVE	SPD,0,WRKR	XMIT	FCURCL,IVL/WRSPMA	MOVE	WRKR,IVR		Lo part moved*Send interrupt to IOP	XMIT	STRINT,IVL/WRDC2		Set Rigid Disk interrupt	JMP	PML			To Protocol hnadler***DIAGNOSTIC Following is a Diagnostic Display	ORG	31,256IOCBST	XMIT	DTAECC,R15		Start of IOCBOPCMPA	XMIT	1,AUX	MOVE	R15,IVL/WRSPMA		Address in SP	NOP				Wait for address to settle	MOVE	SPD,0,R12/,1		Goes to R0, INCR SPMA	ADD	R15,R15			Next address	MOVE	SPD,0,R1/,1	ADD	R15,R15	MOVE	SPD,0,R2/,1	ADD	R15,R15	MOVE	SPD,0,R3/,1	ADD	R15,R15			Next address	MOVE	SPD,0,R4/,1	ADD	R15,R15	MOVE	SPD,0,R5/,1	ADD	R15,R15	MOVE	SPD,0,R6/,1	ADD	R15,R15	MOVE	SPD,0,R16	ADD	R15,R15	XMIT	0EAX,AUX		Skip this address	XOR	R15,R13			There yet?	XMIT	1,AUX	NZT	R13,OPCMPB	ADD	R15,R15	MOVE	SPD,0,R0/,1		Incr SPMA throw away dataOPCMPB	MOVE	R12,R0			1st one in R0BPHR	NOP				Put a BS in here somewhere	NOP	NOP	NOP		NOP	JMP	OPCMPA	HALT**Error handlersEREND	XMIT	3DX,IVL/WRSTAT		Send execute done error*Put Drive Status & Controler Status into SP for Disk Control BlockGEREND	XMIT	DVST,IVL/WRSPMA		Address of DriveStatus	MOVE	27H,0,WRKR/,,DSKST	MOVE	WRKR,IVR		DiskStatus to DCB	XMIT	CNTST,IVL/WRSPMA	Address of Controller status	MOVE	27H,0,WRKR/,,FIFSTA	FIFO, etc, status	MOVE	WRKR,IVR		Status into DCB*If WriteFault on, set type 85 error	MOVE	26H,1,WRKR/,,DSKST	Look at WriteFault	NZT	WRKR,GERENA		Xfr if not WriteFaultGERENB	XMIT	85X,ERRTYP		type 85 error*put error type into SP for DiskOpBlockGERENA	XMIT	LSTERT,IVL/WRSPMA	Address of LastErrorType	MOVE	ERRTYP,IVR		Errortype into LastErrorType*Send interrupt to IOP, go to PML	JMP	CMPSJ*******************************************    Procedure  WTCRS     Wait for Command Register Same**      Wait until the command register does not change for 3 readings,*		then return** 	When return, the Command Register contents are in*		DTARG**	Uses DTARG and WRKR********************************************	PROC	WTCRS	ORG	6,256WTCRA	MOVE	27H,0,DTARG/,,RDCTL	MOVE	DTARG,AUXWTCRB	XOR	27H,0,WRKR/,,RDCTL	NZT	WRKR,WTCRA		Not same-try againWTCRC	XOR	27H,0,WRKR/,,RDCTL	NZT	WRKR,WTCRA		Not same-try again	RTN	END	WTCRS************************************************* PROCEDURE STEPS   REV  July 30, 1984  ** Steps drive head no of steps in Double Precision word* with Hi byte in DTXHI and lo byte in DTXLO.  Drection* MUST already be set up.  USES WRKR.* At end, string of step pulses has been sent to drive.* Drive is stepping, and will indicate end stepping when* SEEK COMPLETED signal goes true.********************************************	PROC	STEPS	ORG	19,256			ALLIGN WITH PAGE BOUNDRYSTP	NZT	21H,2,STP/,,DSKST	Wait until Ready & SeekCompSTPA	XMIT	-8,WRKR		Pulse width	XMIT	STSTP,IVL/WRDC2	Step On	XMIT	1,AUXSTPB	ADD	WRKR,WRKR	NZT	WRKR,STPB	Wait for 3.5 uSec	XMIT	RSSTP,IVL/WRDC2	Step Off	XMIT	-16,WRKR	Pulse Off WidthSTPC	ADD	WRKR,WRKR	NZT	WRKR,STPC	Wait for 32 cmds; total 50 cmds, 10 uSec*Double Precision subtract 1 follows	XMIT	-1,AUX	ADD	DTXLO,DTXLO	MOVE	OVF,AUX	ADD	DTXHI,DTXHI	XMIT	-1,AUX	ADD	DTXHI,DTXHI*  If DTXHI & DTXLO both = 0, seek  pulse string is over	NZT	DTXLO,STPA	NZT	DTXHI,STPA		RTN	END	STEPS*******************************************************PROCEDURE RESTR   REV July 30, 1984  **RESTORES THE DISK TO TRK 000* USES WRKR & DTARG, CALLS STEPS******************************************************	PROC	RESTR	ORG	10,32RST	XMIT	STDOT,IVL/WRDC2		Direction Out	MOVE	R11,R13			STORE RETURNRSTA	XMIT	1,DTXLO	XMIT	0,DTXHI	CALL	STEPS			Step Disk 1 StepRSTB	NZT	21H,2,RSTB/,,DSKST	Wait until Ready & SeekComp	NZT	25H,1,RSTA/,,DSKST	Not Trk000, step again	MOVE	R13,R11			Restore Rreturn pointer	XMIT	RSWPC,IVL/WRDC2		Precomp off 	RTN	END	RESTR***************************************************PROCEDURE  IMPSK--Implied Seek-- July 30, 1984-* Tests Current Cylinder No.  If it is FFFF, current cyl no is unknown, *	recalibrate necessary.  This is indicated by IMMER = FF* Tests CurCyl vs Target Cylinder.  If they are the same, exits.* Subtracts CurCyl from TgtCyl, Which is Cyl No. in header image,*	determines direction to step and distance.  Calls steps* Upon return from Steps, drive is steping.  Puts FFFF into curCyl,*	indicating unknown value.* When SEEK COMPLETE goes true, puts Target Cyl into CurCyl, exits.***  This procedure is a SECOND LEVEL PROCEDURE, it cals another* procedure.  Therefore, This procedure's return point must be saved* & restored using R13 *********************************************************	PROC	IMPSK	MOVE	R11,R13		Save return pointer*Get CurCyl and Target Cylinder nosSKGTCL	XMIT	CURCLH,IVL/WRSPMA	Address of CURCLH	NOP				Wait for address to settle	MOVE	SPD,0,SH	XMIT	CURCLL,IVL/WRSPMA	NOP				Wait for address to settle	MOVE	SPD,0,SL	XMIT	HDCYH,IVL/WRSPMA	NOP				Wait for address to settle	MOVE	SPD,0,MH	XMIT	HDCYL,IVL/WRSPMA	NOP				Wait for address to settle	MOVE	SPD,0,ML*Is CurCyl = FFFF?  If so, error.  Make IMMER & ERRTYP = 84.	XMIT	377H,AUX	XOR	SH,WRKR	ORG	12,256	NZT	WRKR,SKNCUK		Not cyl unknown, continueSPCLUK	XOR	SL,WRKR			SH = FF, possible error	NZT	WRKR,SKNCUK		Not cyl unknown, continue	JMP	SKCLUK			SL = FF, error* ARE CurCyl & Target Cyl =?  If so, exitSKNCUK	MOVE	SH,AUX	XOR	MH,WRKR	NZT	WRKR,SKNEQ		Cyl Nos not equalSPNCUK	MOVE	SL,AUX	XOR	ML,WRKR	NZT	WRKR,SKNEQ		Cyl nos not equal	JMP	SKOVR			Cyl nos =, exit*now subtract cylinder nos, determine step direction, seekSKNEQ	CALL	DPSUB			Subtract cyl nos*If SIGN = 0, direction is IN, otherwise OUT*remainder is in proper form for  Proc STEPS	NZT	SIGN,STPOUT	XMIT	STDIN,IVL/WRDC2		Set step direction IN	JMP	*+2STPOUT	XMIT	STDOT,IVL/WRDC2		Set step direction OUT*Now call STEPS	CALL	STEPS		Deliver string of STEP pulses to drive*now set CurCyl to FFFF, unknown	XMIT	CURCLH,IVL/WRSPMA	XMIT	377H,IVR	XMIT	CURCLL,IVL/WRSPMA	XMIT	377H,IVR**Now Set/Reset Write Precomp*Is current cylinder no = or greater than Precomp cyl?*Subtract CurCyl from Precomp Cyl. If result is negative,*    reset Precomp; if not, set Precomp*    use procedure DPSUB**Put PrecompCyl in MH & ML; put Current cyl in SH & SLINPPC	XMIT	HDCYH,IVL/WRSPMA	Address of curCyl H	NOP				Wait for addrss to settle	MOVE	SPD,0,SH		Get data	XMIT	HDCYL,IVL/WRSPMA	Address of CurCyl L	NOP				Wait for addrss to settle	MOVE	SPD,0,SL	XMIT	PCCYH,IVL/WRSPMA	Address of PrecompCyl H	NOP				Wait for addrss to settle	MOVE	SPD,0,MH		Get data	XMIT	PCCYL,IVL/WRSPMA	Address of PrecompCyl L	NOP				Wait for addrss to settle	MOVE	SPD,0,ML	CALL	DPSUB			DoublePrecisonSubtract	ORG	4,32	NZT	SIGN,INPPA		sign of remainder	XMIT	RSWPC,IVL/WRDC2	Reset Precomp	JMP	SKCMPINPPA	XMIT	STWPC,IVL/WRDC2	Set Precomp**Now wait for READY & SEEK COMPLETE SKCMP	NZT	21H,2,SKCMP/,,DSKST	Wait until READY & SEEK COMPLETE*Now put target Cyl into CurCyl	XMIT	HDCYH,IVL/WRSPMA	NOP				Wait for addrss to settle	MOVE	SPD,0,WRKR	XMIT	CURCLH,IVL/WRSPMA	MOVE	WRKR,IVR	XMIT	HDCYL,IVL/WRSPMA	NOP				Wait for addrss to settle	MOVE	SPD,0,WRKR	XMIT	CURCLL,IVL/WRSPMA	MOVE	WRKR,IVR**Seek completed, return*SKOVR	MOVE	R13,R11			Restore return pointer	RTN*SKCLUK	XMIT	84X,IMMER	XMIT	84X,ERRTYP	JMP	SKOVR*	END	IMPSK***************************************************PROC  DPSUB   July 30, 1984  1:23 PM*DOES DOUPLE PRECISION SUBTRACT WITH*RESULT IN SIGN - MAGNITUDE FORM**Uses regs MH = R6 = DTXHI; ML = R5 = DTXLO;*	SH = R4 = DTARG; SL = R3 = STATRG;*	SIGN = R1 = CNTRG; WRKR** To start, the minuend (number subtracted from) is in *	MH & ML, with the high order byte in MH, &*	the subtrahend (number subtracted)*	is in SH & SL, all in unsigned (assumed positive)*	binary form.  At return, the remainder is in*	sign - magnitude form. MH & ML contain the *	remainder, with the high order byte in MH,*	and SIGN contains the sign; 0 = positive and*	1 = negative. This form is required for the step*	procedure. *********************************************************	PROC	DPSUB** Set SIGN for positive result*	XMIT	0,SIGN** Form 2's compliment of subtrahend*	XMIT	377H,AUX	XOR	SH,SH	XOR	SL,SL	XMIT	1,AUX	ADD	SL,SL	MOVE	OVF,AUX	ADD	SH,SH** Now add*	MOVE	SL,AUX	ADD	ML,ML	MOVE	OVF,AUX	ADD	MH,MH	MOVE	SH,AUX	ADD	MH,MH** Now test for negative result; If MSB of MH = 1, result is negative*	if MSB of MH = 0, result is positive*	ORG	13,256	XMIT	200H,AUX	Mask for MSB	AND	MH,WRKR	MSB alone	NZT	WRKR,*+2	MSB of MH = 1, Recomplement result	JMP	RSP		MSB of MH = 0, result is positive	XMIT	377H,AUX	MSB of MH = 1, Recomplement result	XOR	ML,ML	XOR	MH,MH	XMIT	1,AUX	ADD	ML,ML	MOVE	OVF,AUX	ADD	MH,MH*	XMIT	1,SIGN		Set SIGN negativeRSP	RTN	END	DPSUB*************************************************************PROCEDURE  SELHD, - Sellect Head & Drive*Initial version,  August 1, 1984* USE ONLY AT BEGINING OF OPRATION & IN IMPSK**Sellect head using HD byte in header image.*Sellect drive-always drive 0*Set CRC; Reset WriteGate & Loopback,* Set/Reset/Ignore ReduceWriteCurrent* Set/Reset Precomp is done in procedure IMPSK** Uses  WRKR, DTARG*This procedure calls another procedure and *   keeps its return pointer in R13************************************************************!!! Add part to delay 30 bytes if Head Number Changeed************************************************************	PROC	SELHD	XMIT	RSWG,IVL/WRDC2		Reset WriteGate	MOVE	R11,R13			Keep return pointer**If ReduceWriteCurrent word is FFFF, reduce write current not required*by drive*	XMIT	WICYH,IVL/WRSPMA	Address of hi part of RedICur	XMIT	377H,AUX	XOR	SPD,0,DTARG		Get RWC byte*	ORG	13,32	NZT	DTARG,SERWT		Possible RWC,Test it	XMIT	WICYL,IVL/WRSPMA	Address of lo part of RedICur	XMIT	0,SIGN			make sure is zero if did not go to SERWT	XOR	SPD,0,DTARG		1st byte FF, test other byte	NZT	DTARG,SERWT		Possible RWC,Test it*SELA	XMIT	HDHD,IVL/WRSPMA		Address of head byte	XMIT	020H,AUX		Drive sellect bit	MOVE	SPD,0,WRKR		Get head number	ADD	WRKR,WRKR		Word with hd & drive sellect	NZT	SIGN,SERWTA		sign of remainder	XMIT	0,AUX			Reset RedWtCur	JMP	SERWTBSERWTA	XMIT	010H,AUX		Value to Set RedWtCurSERWTB	ADD	WRKR,WRKRSECRC	XMIT	377H,AUX		DC1 output is inverted	XOR	WRKR,IVL/WRDC1		Set up Disk Control Reg 1*Reduce Write Current word is FFFF, reduce write current signal is not used*Now set CRC, reset Loopback	XMIT	STCRC,IVL/WRDC2		Set CRC-for header	XMIT	RSLPB,IVL/WRDC2		Loopback off*	MOVE	R13,R11			Restore return pointer	RTN**Is current cylinder no = or greater than Reduce Write Current cyl?*Subtract CurCyl from Reduce Write Cyl. If result is negative,*    reset ReduceWriteCurrent; if not, set ReduceWriteCurrent*    use procedure DPSUB**Put RWCyl in MH & ML; put Current cyl in SH & SL***********************************************************SERWT	XMIT	HDCYH,IVL/WRSPMA	Address of curCyl H	NOP				Wait for address to settle	MOVE	SPD,0,SH		Get data	XMIT	HDCYL,IVL/WRSPMA	Address of curCyl L	NOP				Wait for address to settle	MOVE	SPD,0,SL	XMIT	WICYH,IVL/WRSPMA	Address of RedWtCurCyl H	NOP				Wait for address to settle	MOVE	SPD,0,MH		Get data	XMIT	WICYL,IVL/WRSPMA	Address of RedWtCurCyl L	NOP				Wait for address to settle	MOVE	SPD,0,ML	CALL	DPSUB			DoublePrecisonSubtract	JMP	SELA*	END	SELHD*********************************************PROCEDURE WTINST**Wait a number of instructions** -No of instruction times to wait in DTARG.* count of -4 = 1 byte time; housekeeping*   takes 1/2 byte** uses R11, return pointer; DTARG; AUX*  Generates no errors*********************************************	PROC	WTINST	XMIT	1,AUXWTINLP	ADD	DTARG,DTARG	NZT	DTARG,WTINLP	RTN	END	WTINST************************************************* PROCEDURE WG--WRITE GAP ** USES STATRG, AUX* DTARG CONTAINS -NO OF BYTES IN GAP*************************************************	PROC WG	ORG	5,256WGA	XMIT	1,AUXWGB	NZT	21H,1,WGB/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		Write 0	ADD	DTARG,DTARG	NZT	DTARG,WGB		Loop until all bytes written	RTN	END	WG****************************************************PROCEDURE  RFFCK**Procedure Read FIFO Check*1. Check FIFO status*	a. If FIFFM flag is not 0, FIFFM Flag _ 0 and read sector*	b. If FIFO is EMPTY, FIFFM Flag _ 1 & read sector*	c. If FIFO is FULL, loop to 1. *		ERROR IF 4 index pulses*	d. If a1b1 test gives not half empty, loop on 1. *2. Read sector**	USES CNTR**	First level procedure-calls no other procedure*	At exit, if IMMER is NOT = 0, an error has occured*************************************************	PROC	RFFCK	XMIT	0,IMMER	XMIT	1,IVL/INDXOF		Reset index	XMIT	FIFFM,IVL/WRSPMA	SPMA	XMIT	-4,CNTRG		Setup to count indexes*	ORG	20,32RFFFA	NZT	SPD,0,RFXRD		 IF FIFFM = 1, FIFFM _ 0 & Rd SectorRFFFB	NZT	26H,1,RFFM/,,FIFSTA	Is FIFO mpty?	NZT	27H,1,RFFF/,,FIFSTA	Is FIFO Full?	NZT	25H,1,*+2/,,FIFSTA	To RFFFB if a1#b1	JMP	RFFFB	NZT	25H,1,*+2/,,FIFSTA	To RFFFB if a1#b1	JMP	RFFFB	NZT	25H,1,*+2/,,FIFSTA	To RFFFB if a1#b1	JMP	RFFFB	JMP	RFFR			Read sector*RFFM	XMIT	1,IVR			FIFFM Flag _ 1	JMP	RFFR			Read Sector*RFXRD	XMIT	0,IVR			FIFFM Flag _ 0*RFFR	XMIT	0,CNTRG			zero index cntr	RTN				Return & read sector*RFFF	XMIT	1,AUX	NZT	24H,1,RFFFA/,,DSKST	Index? if not, try again	XMIT	1,IVL/INDXOF		Reset Index	ADD	CNTRG,CNTRG		count indexes	NZT	CNTRG,RFFFA		4 indexes while FIFO Full*RFFER	XMIT	04X,ERRTYP	XMIT	04X,IMMER	JMP	RFFR			Exit with error*	END	RFFCK****************************************************PROCEDURE  WFFCK**Procedure Write FIFO Check*1. Check FIFO Empty at Last Read.*	If empty at last read or if FirstWriteFlag = 1,*		wait until not empty & then do prelim *		FIFO read*2. Check FIFO status*	a. If FIFFM flag is not 0, FIFFM Flag _ 0 and write sector*	b. If FIFO is FULL, FIFFM Flag _ 1 & write sector*	c. If FIFO is EMPTY, loop to 2. *		ERROR IF 4 index pulses*	d. If a1b1 test gives not half full, loop on 2. *3. Write sector**	USES CNTR**	First level procedure-calls no other procedure*	At exit, if IMMER is NOT = 0, an error has occured*************************************************	PROC	WFFCK	XMIT	0,IMMER	XMIT	-4,CNTRG		Setup to count indexes	XMIT	1,IVL/INDXOF		Reset index	MOVE	22H,1,STATRG/,,FIFSTA	Was FIFO Empty at Last Read?	NZT	STATRG,WFFA		Empty at LR, Wait	XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag	NOP				Wait for address to settle	ORG	18,32	NZT	SPD,0,WFFA		FirstWriteFlag = 1, Prelim read** Note: If FIFO is Empty at Last Read, we are at the*	start of this write operation.  If FIFO does*	not go notEmpty within 4 revolutions of the disk,*	something is wrong*WFFB	XMIT	FIFFM,IVL/WRSPMA	SPMA	NOP				Wait for address to settle	ORG	16,32WFFFA	NZT	SPD,0,WFXRD	 IF FIFFM = 1, FIFFM _ 0 & Wt Sector	NZT	26H,1,*/,,FIFSTA	Wait while FIFO mpty* Note: If FIFO was not empty at LastRead and is empty now,*	we are between sectorsWFFFB	NZT	27H,1,WFFF/,,FIFSTA		Is FIFO Full?	NZT	25H,1,WFFFB/,,FIFSTA	To WFFFA if a1=b1	NZT	25H,1,WFFFB/,,FIFSTA	To WFFFA if a1=b1	NZT	25H,1,WFFFB/,,FIFSTA	To WFFFA if a1=b1	JMP	WFFR			Write sector*WFFF	XMIT	1,IVR		FIFFM Flag _ 1	JMP	WFFR		Write Sector*WFXRD	XMIT	0,IVR		FIFFM Flag _ 0*WFFR	XMIT	0,CNTRG		zero index cntr	RTN			Return & write sector*WFFA	NZT	26H,1,WFFM/,,FIFSTA	Wait while FIFO mpty	XMIT	FRSTWT,IVL/WRSPMA	Address of FirstWriteFlag	XMIT	0,IVR			Make flag = 0	MOVE	27H,0,DTARG/,,RDFLO	Dummy Read,Cycle FIFO	JMP	WFFBWFFM	XMIT	1,AUX	NZT	24H,1,WFFA/,,DSKST	Index? if not, try again	XMIT	1,IVL/INDXOF		Reset Index	ADD	CNTRG,CNTRG		count indexes	NZT	CNTRG,WFFA		Test FIFO Stat again*WFFER	XMIT	05X,ERRTYP		4 indexes while FIFO Empty	XMIT	05X,IMMER	JMP	WFFR			Exit with error*	END	WFFCK***************************************************** PROCEDURE VFYHD**	Verify Header- against Header image in Scratchpad** If correct header not found within 4 revolutions,*     HeaderNotFound Error occurs**   uses R11, R13  for return storage; STATRG,DTARG, CNTRG* 	At End if ERRTYP = NOT 0, error has been found*		and type recorded in HDRERT**************************************************** Now search for proper header*	PROC	VFYHD	MOVE	R11,R13			Keep return pointer	XMIT	STCRC,IVL/WRDC2		Set to CRC	XMIT	-5,CNTRG		Setup for index countVFYHDA	XMIT	HDST,IVL/WRSPMA		Load Header Image SA	CALL	FINDAM			Find Address Mark	ORG	3,32	NZT	STATRG,VFYHDB	JMP	VFYHDW			Not AM try againVFYHDB	NZT	21H,1,VFYHDB/,,FIFSTA	WAIT FOR BDONE	XMIT	0FEX,AUX		Header ID BYTE	XOR	27H,0,DTARG/,,RDDSK	GET DATA	ORG	16,32	NZT	DTARG,VFYRST		Not a Header-try againVH2	NZT	21H,1,VH2/,,FIFSTA	WAIT FOR BDONE	MOVE	SPD,0,AUX/,1		Get byte image, Incr SPMA	XOR	27H,0,DTARG/,,RDDSK	Get & test data	NZT	DTARG,VFYRST		Not proper header, start over	NZT	23H,1,VH2/,,FIFSTA	End of Header data?VF0	NZT	21H,1,VF0/,,FIFSTA		WAIT FOR BDONE	CALL	ENDRB			End Reading a block	NZT	DTARG,VFYCRE			A Hdr CRC error was found	JMP	VFYRTN			exit procedure*VFYCRE	XMIT	14X,ERRTYP		Mark error type	XMIT	HDRERT,IVL/WRSPMA	Address of Header Err Typ	XMIT	14X,IVR			Hdr CRC Error marked	JMP	VFYRTN*VFYRST	XMIT	90X,IVL/WRMAC		All off, incl ECCIZ' & RdGate	ORG	14,32	NZT	24H,1,VFYHDW/,,DSKST	Restart if no indexVFYIDX	XMIT	1,AUX	XMIT	0,IVL/INDXOF		Reset Index	ADD	CNTRG,CNTRG	NZT	CNTRG,VFYHDW		AM, not 4 indexes	XMIT	81X,ERRTYP		error-Header not found	XMIT	HDRERT,IVL/WRSPMA	Address of Header Error Type	XMIT	81X,IVR			NoSectorFound errorVFYRTN	XMIT	90X,IVL/WRMAC		Read off	MOVE	R13,R11			Restore return pointer	RTN** Wait 6 bytes for read gate to recover*VFYHDW	XMIT	-10,DTARG	CALL	WTINST			Wait 6 byte times	JMP	VFYHDA			Try again*	END	VFYHD***************************************************** PROCEDURE RDHD**	Read Header- put into Header image in Scratchpad***   uses R11, R13  for return storage; STATRG,DTARG* 	At End if ERRTYP = NOT 0, error has been found*		and type recorded in HDRERT**************************************************** Now search for a header**	PROC	RDHD*	MOVE	R11,R13			Keep return pointer*	XMIT	STCRC,IVL/WRDC2		Set to CRC*	ORG	8,32*RDHDA	XMIT	HDST,IVL/WRSPMA		Load Header Image SA*	CALL	FINDAM			Find Address Mark*	NZT	STATRG,RDHDB*	JMP	RDHDA			Not AM try again*RDHDB	NZT	21H,1,RDHDB/,,FIFSTA	WAIT FOR BDONE*	XMIT	0FEX,AUX		Header ID BYTE*	XOR	27H,0,DTARG/,,RDDSK	GET DATA*	NZT	DTARG,RDHDA		Not a Header-try again*RH2	NZT	21H,1,RH2/,,FIFSTA		WAIT FOR BDONE*	MOVE	27H,0,DTARG/,,RDDSK	Get data*	MOVE	DTARG,IVR		Put data in scratchpad*	NOP				SP timing*	MOVE	SPD,0,DTARG/,1		Read & Ignore Sp data-incr SPMA*	NZT	23H,1,RH2/,,FIFSTA		End of Header data?*RF0	NZT	21H,1,RF0/,,FIFSTA		WAIT FOR BDONE*	CALL	ENDRB			End Reading a block*	NZT	DTARG,RHCRE		A Hdr CRC error was found*	JMP	RHRTN			exit procedure***RHCRE	XMIT	14X,ERRTYP		Mark error type*	XMIT	HDRERT,IVL/WRSPMA	Address of Header Err Typ*	XMIT	14X,IVR			Hdr CRC Error marked*	JMP	RHRTN***RHRTN	XMIT	90X,IVL/WRMAC		Read off*	MOVE	R13,R11			Restore return pointer*	RTN*	END	RDHD*************************************************** PROCEDURE VFYLBL**Verify Label**Compares disk label with label image in Scratchpad*  uses R11, R13 to hold return pointers,*  uses STATRG, DTARG, ERRTYP, WRKR* *	At end if ERRTYP is NOT = 0, a verify error has occured*	  and type recorded in LBLERT**  Revised  15-Feb-85 11:38:31  RLS**************************************************	PROC	VFYLBLVFRLBL	MOVE	R11,R13			Keep return pointer	XMIT	0,WRKR			Clear verf error flag	XMIT	STCRC,IVL/WRDC2		Set for CRC	XMIT	LBLST,IVL/WRSPMA	Load Label Image SA	ORG	30,32	CALL	FINDAM			Find next AM	NZT	STATRG,VFRLBA	JMP	VER1			Label AM errorVFRLBA	NZT	21H,1,VFRLBA/,,FIFSTA	Wait for BDONE	XMIT	0FCX,AUX		Label ID BYTE	XOR	27H,0,DTARG/,,RDDSK	GET DATA	NZT	DTARG,VER2		Not Label ID, errorLR1	MOVE	SPD,0,AUX/,1		Load Lab Img byte, incr SPMALR2	NZT	21H,1,LR2/,,FIFSTA		Wait for BDONE	XOR	27H,0,DTARG/,,RDDSK		XOR Img with disk data	NZT	DTARG,VER3			Label error?	NZT	24H,1,LR1/,,FIFSTA		End of Label data?LR3	NZT	21H,1,LR3/,,FIFSTA		Wait for BDONE	CALL	ENDRB				End Reading a blockLR4	NZT	DTARG,VER4			Label CRC Error	JMP	LR5VER1	XMIT	21X,ERRTYP			Mark LBL Am Error	JMP	VERGVER2	XMIT	22X,ERRTYP			Label ID error	JMP	VERG*VER3	XMIT	1,WRKR				Mark verf. error	NZT	24H,1,LR1/,,FIFSTA		End of Label data?LR3A	NZT	21H,1,LR3A/,,FIFSTA		Wait for BDONE	CALL	ENDRB			End Reading a block	JMP	LR4			CRC error?VER4	XMIT	2,AUX			Label CRC error	ADD	WRKR,WRKR		add to label verify error	ORG	11,256	JMP	LR5VERG	XMIT	LBLERT,IVL/WRSPMA	Set SPMA to LabelErrorType	MOVE	ERRTYP,IVR		Store error typeLR6	XMIT	90X,IVL/WRMAC		Read off	MOVE	R13,R11			Restore return pointer	RTN*LR5	NZT	WRKR,*+2	JMP	LR6			No errors	XMIT	22X,AUX	ADD	WRKR,ERRTYP		Fully formed error type	JMP	VERG*	END	VFYLBL**************************************************** PROCEDURE RDLBL**Read Label**Reads disk label into label image in Scratchpad*  uses R11, R13 to hold return pointers,*  uses STATRG, DTARG, ERRTYP* *	At end if ERRTYP is NOT = 0, an error has occured*	  and type recorded in LBLERT**************************************************	PROC	RDLBLREDLBL	MOVE	R11,R13			Keep return pointer	XMIT	STCRC,IVL/WRDC2		Set for CRC	XMIT	LBLST,IVL/WRSPMA	Load Label Image SA	CALL	FINDAM			Find next AM	NZT	STATRG,REDLBA	JMP	RLER1			Label AM errorREDLBA	NZT	21H,1,REDLBA/,,FIFSTA	Wait for BDONE	XMIT	0FCX,AUX		Label ID BYTE	XOR	27H,0,DTARG/,,RDDSK	GET DATA*	ORG	18,32			Make sure pages fit	NZT	DTARG,RLER2		Not Label ID, errorRL2	NZT	21H,1,RL2/,,FIFSTA		Wait for BDONE	MOVE	27H,0,DTARG/,,RDDSK		READ disk data	MOVE	DTARG,IVR			Put into Scratchpad	MOVE	SPD,0,WRKR/,1		Read & Ignore SP data, incr SPMA.	NOP				Allow SP MA to settle	NZT	24H,1,RL2/,,FIFSTA		End of Label data?RL3	NZT	21H,1,RL3/,,FIFSTA		Wait for BDONE	CALL	ENDRB			End Reading a block	NZT	DTARG,RLER4		Label CRC Error	JMP	RL4RLER1	XMIT	21X,ERRTYP			Mark LBL Am Error	JMP	RLERGRLER2	XMIT	22X,ERRTYP			Label ID error	JMP	RLERGRLER4	XMIT	24X,ERRTYP			Label CRC errorRLERG	XMIT	LBLERT,IVL/WRSPMA	Set SPMA to LabelErrorType	MOVE	ERRTYP,IVR			Store error typeRL4	XMIT	90X,IVL/WRMAC		Read off	MOVE	R13,R11			Restore return pointer	RTN	END	RDLBL**********************************************PROCEDURE WTLBL**Write Label** Writes a label using label image in Scratchpad* Uses WRKR*******************************************	PROC	WTLBLWTLB	MOVE	R11,R13			Keep return pointer	XMIT	STCRC,IVL/WRDC2		Set for CRCWTLBA	XMIT	-14,DTARG		Gap Length, incl part of 6 byte gap	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		Write + ECCIC	XMIT	WRT,IVL/WRMAC		Write on, ECCIC offWTLBA2	NZT	21H,1,WTLBA2/,,FIFSTA	Wait for BDONE	XMIT	STWG,IVL/WRDC2		WriteGate on	XMIT	0,IVL/WDDATA		Write 0	CALL	WG			Write GapWTLBA3	NZT	21H,1,WTLBA3/,,FIFSTA	Wait for BDONE	XMIT	0A1X,IVL/WDDATA		Write Address Mark	NOPWTLBA4	NZT	21H,1,WTLBA4/,,FIFSTA	Wait for BDONE	XMIT	0FCX,IVL/WDDATA		Write Label ID	XMIT	LBLST,IVL/WRSPMA	Load Label Image SA	ORG	4,32WTLBA5	NZT	21H,1,WTLBA5/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,WRKR/,1		Get data, incr Ma	MOVE	WRKR,IVL/WDDATA		Data to disk	NZT	24H,1,WTLBA5/,,FIFSTA	End of label?WTLBA6	NZT	21H,1,WTLBA6/,,FIFSTA	Wait for BDONE	XMIT	IW,IVL/WRMAC		Write+IBLA--write CRC	XMIT	0,IVL/WDDATA		0 gets lost, CRC out	XMIT	-3,DTARG		End gap-guard bytesWTLBAA	NZT	21H,1,WTLBAA/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, CRC out	CALL	WG			Write guard bytesWTLBAF	NZT	21H,1,WTLBAF/,,FIFSTA	Wait for BDONE	MOVE	R13,R11		Restore return pointerr	RTN	END	WTLBL*********************************************** PROCEDURE WTDTA**   Write a DATA BLOCK using data from FIFO* NOTE: Preliminary readFIFO must be done elsewhere*	uses DTARG, WRKR***********************************************	PROC	WTDTA	XMIT	ECCRF,IVL/WRSPMA	Get ECC/CRC word	MOVE	R11,R13			Keep return pointer	MOVE	SPD,IVL/WRDC2		Set for ECC/CRCWRDTA	XMIT	-13,DTARG		Gap Length, incl part of 6 byte gap	XMIT	0,IVL/WDDATA		Write 0	XMIT	WE,IVL/WRMAC		Write + ECCIZ	XMIT	WRT,IVL/WRMAC		Write on, ECCIZ offWRDTA2	NZT	21H,1,WRDTA2/,,FIFSTA	Wait for BDONE	XMIT	STWG,IVL/WRDC2		WriteGate on	XMIT	0,IVL/WDDATA		Write 0	CALL	WG			Write GapWRDTA3	NZT	21H,1,WRDTA3/,,FIFSTA	Wait for BDONE	XMIT	0A1X,IVL/WDDATA		Write Address Mark	XMIT	0,IVL/WRSPMA		Clear SPMA for countingWRDTA4	NZT	21H,1,WRDTA4/,,FIFSTA	Wait for BDONE	XMIT	0FBX,IVL/WDDATA		Write DATA ID	XMIT	1,AUX	ORG	7,32			next 7 inst on same segmentWRDTA5	NZT	21H,1,WRDTA5/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,,RDFHI	Get data from FIFO	MOVE	WRKR,IVL/WDDATA		Data to disk	MOVE	27H,0,WRKR/,1,RDFLO	data from FIFO, Cycle FIFO, Incr SPMAWRDTA6	NZT	21H,1,WRDTA6/,,FIFSTA	Wait for BDONE	MOVE	WRKR,IVL/WDDATA		Data to disk	NZT	24H,1,WRDTA5/,,FIFSTA	Finished with count ?* SPMA only counts to 255 (0-254), we need more words, depending on WENDC*		-1 for normal, -2 or -3 for WRITE LONG*  NOTE: The SP MA now points to 0FFX, location WENDCA*	which is a copy of WENDC*	ORG	9,32	MOVE	SPD,0,CNTRG		get WENDCA-ending countWRDTA7	NZT	21H,1,WRDTA7/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,,RDFHI	Get data from FIFO	MOVE	WRKR,IVL/WDDATA		Data to disk	ADD	CNTRG,CNTRG		Is WENDC over?WRDTA8	NZT	21H,1,WRDTA8/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,,RDFLO	data from FIFO, Cycle FIFO	MOVE	WRKR,IVL/WDDATA		Data to disk	NZT	CNTRG,WRDTA7		More data as reqd*WRDTA9	NZT	21H,1,WRDTA9/,,FIFSTA	Wait for BDONE	XMIT	IW,IVL/WRMAC		Write+IBLA--write ECC	XMIT	0,IVL/WDDATA		0 gets lost, ECC out	XMIT	-5,DTARG		Write gap lengthWRDTAA	NZT	21H,1,WRDTAA/,,FIFSTA	Wait for BDONE	XMIT	0,IVL/WDDATA		0 gets lost, ECC out	CALL	WG			Write gapWRDTAH	NZT	21H,1,WRDTAH/,,FIFSTA	Wait for BDONE	XMIT	RSWG,IVL/WRDC2		WriteGate off	XMIT	90X,IVL/WRMAC		Write off	MOVE	R13,R11			Restore return pointerr	RTN	END	WTDTA******************************************** PROCEDURE RDDTA** Read a data block putting data into FIFO** 	uses STATRG, DTARG,WRKR*	USES R11, R13 to hold return pointers*	SPMA is used as word counter**   At end if ERRTYP is NOT = 0, an error has ocured*       and type recorded in DTAERT*********************************************	PROC	RDDTA**RDTA	MOVE	R11,R13			Keep return pointer	XMIT	ECCRF,IVL/WRSPMA	Get ECC/CRC word	NOP				Wait for address to settle	MOVE	SPD,IVL/WRDC2		Set for ECC/CRC	CALL	FINDAM			Find next AM	NZT	STATRG,RDTB	JMP	DER1			Data AM errorRDTB	XMIT	0FBX,AUX		Data ID BYTERDTBB	NZT	21H,1,RDTBB/,,FIFSTA	Wait for BDONE	XOR	27H,0,DTARG/,,RDDSK	GET DATA	NZT	DTARG,DER2		Not Data ID, error	XMIT	0,IVL/WRSPMA		Clear SPMA for counting	XMIT	1,AUX			for counting	ORG	9,32RDTC	NZT	21H,1,RDTC/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,,RDDSK	Get Disk Byte	MOVE	WRKR,IVL/WRFHI		Put data into FIFORDTD	NZT	21H,1,RDTD/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,1,RDDSK	Get Disk Byte, incr SPMA	MOVE	WRKR,IVL/WRFLO		Put data into FIFO, Store FIFO	NZT	24H,1,RDTC/,,FIFSTA	Finished with count ?*SPMA only counts to 255 (0-254), we need more words,  depending on*     WENDC; -1=normal, -2 or -3 for READ LONG* NOTE: The SP MA now points to 0FFX, which is location WENDCA, *		a copy of WENDC*	MOVE	SPD,0,CNTRG		No of final wrrdsRDTE	NZT	21H,1,RDTE/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,,RDDSK	Get Disk Byte	MOVE	WRKR,IVL/WRFHI		Put data into FIFO	ADD	CNTRG,CNTRGRDTF	NZT	21H,1,RDTF/,,FIFSTA	Wait for BDONE	MOVE	27H,0,WRKR/,,RDDSK	Get Disk Byte	MOVE	WRKR,IVL/WRFLO		Put data into FIFO, Store FIFO	NZT	CNTRG,RDTE		Additional bytes	NZT	ECCFLG,RDTH		End reading a block-CRCRDTG	NZT	21H,1,RDTG/,,FIFSTA	Wait for BDONE	CALL	ENDRC			End reading a block-ECC	NZT	DTARG,RDCRE		A ECC error was found	JMP	RDRTN*RDTH	NZT	21H,1,RDTH/,,FIFSTA	Wait for BDONE	CALL	ENDRB			End reading a block-CRC	NZT	DTARG,RDCRE		A CRC error was found	JMP	RDRTN*DER1	XMIT	31X,ERRTYP	JMP	RDRER*DER2	XMIT	32X,ERRTYP	JMP	RDRER*RDCRE	XMIT	34X,ERRTYP	JMP	RDRER*RDRER	XMIT	DTAERT,IVL/WRSPMA	Address of Data Err	MOVE	ERRTYP,IVR		Keep error type*RDRTN	XMIT	90X,IVL/WRMAC		Read off	MOVE	R13,R11			Restore return pointer	RTN	END	RDDTA******************************************** PROCEDURE VFDTA** Verify a data block agaainst data in FIFO* Preliminary ReadFIFO must be done elsewhere** 	uses STATRG, DTARG,WRKR, CNTRG, R6*	USES R11, R13 to hold return pointers**   At end if ERRTYP is NOT = 0, an error has ocured*       and type recorded in DTAERT** Revised  27-Feb-85 12:00:31  RLS**********************************************	PROC	VFDTA**VFTA	MOVE	R11,R13			Keep return pointer	XMIT	ECCRF,IVL/WRSPMA	Get ECC/CRC word	XMIT	0,R6			Clear Vrfy Er Flag	MOVE	SPD,IVL/WRDC2		Set for ECC/CRC	CALL	FINDAM			Find next AM*	ORG	68,256	NZT	STATRG,VFTB	JMP	VFDER1			Data AM errorVFTB	XMIT	0FBX,AUX		Data ID BYTEVFTBB	NZT	21H,1,VFTBB/,,FIFSTA	Wait for BDONE	XOR	27H,0,DTARG/,,RDDSK	GET DATA	NZT	DTARG,VFDER2		Not Data ID, error	XMIT	0,IVL/WRSPMA		Clear SPMA for counting*        ORG     22,32VFDTC	NZT	21H,1,VFDTC/,,FIFSTA	Wait for BDONE	MOVE	27H,0,AUX/,,RDFHI	FIFO data for compare	XOR	27H,0,WRKR/,,RDDSK	COMPARE Disk Byte	NZT	WRKR,VFDER3		Comp errorVFDTD	NZT	21H,1,VFDTD/,,FIFSTA	Wait for BDONE	MOVE	27H,0,AUX/,1,RDFLO	FIFO data for compare,*					Cycle FIFO,inc SPMA	XOR	27H,0,WRKR/,,RDDSK	Comp Disk Byte	NZT	WRKR,VFDER4		Comp error	NZT	24H,1,VFDTC/,,FIFSTA	Finished with count ?*SPMA only counts to 255 (0-254), we need 1 more word*VFDTE	NZT	21H,1,VFDTE/,,FIFSTA	Wait for BDONE	MOVE	27H,0,AUX/,,RDFHI	FIFO data for compare	XOR	27H,0,WRKR/,,RDDSK	COMP Disk Byte	NZT	WRKR,VFDER5		Comp error	MOVE	27H,0,AUX/,,RDFLO	FIFO data for compare, Cycle FIFOVFDTF	NZT	21H,1,VFDTF/,,FIFSTA	Wait for BDONE	XOR	27H,0,WRKR/,,RDDSK	COMP Disk Byte	NZT	WRKR,VFDER6		Comp error - last byte?	NZT	ECCFLG,VFDTG		End - CRC	JMP	VFE			End- ECC*VFDER4	XMIT	1,R6	NZT	24H,1,VFDTC/,,FIFSTA	Finished with count ?*SPMA only counts to 255 (0-254), we need 1 more word*	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	27H,0,AUX/,,RDFHI	FIFO data for compare* Compare not necessary- error already logged	JMP	VFDTF*VFDTG	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	CALL	ENDRB			End reading a block-CRCVFDTK	NZT	DTARG,VFDCRE		A CRC error was found	JMP	VFDRTN*VFE	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	CALL	ENDRC			End reading a block-ECC	JMP	VFDTK*VFDER1	XMIT	31X,ERRTYP	JMP	VFDRER*VFDER2	XMIT	32X,ERRTYP	JMP	VFDRER**A compare error has occured.  Mark the errorVFDER3	XMIT	1,R6	JMP	VFDTD*VFDER5	XMIT	1,R6	JMP	VFDTF*VFDER6	XMIT	1,R6	NZT	ECCFLG,VFDTH		End - CRC	JMP	VFDTJ			End - ECC*VFDTH	NZT	21H,1,VFDTH/,,FIFSTA	Wait for BDONE	CALL	ENDRB			End reading a block- CRC	JMP	VFDTK*VFDTJ	NZT	21H,1,VFE/,,FIFSTA	Wait for BDONE	CALL	ENDRC			End reading a block-ECC	JMP	VFDTK** Add CRC/ECC error to R6VFDCRE	XMIT	2X,AUX	ADD	R6,R6		JMP	VFDREQ*        ORG     4,256VFDRTN	NZT	R6,*+2			Error found	JMP	VFDRTP			No ErrorVFDREQ	XMIT	32X,AUX	ADD	R6,ERRTYP		Fully formed error typeVFDRER	XMIT	DTAERT,IVL/WRSPMA	Address of Data Err	MOVE	ERRTYP,IVR		Keep error type*VFDRTP	XMIT	90X,IVL/WRMAC		Read off	MOVE	R13,R11			Restore return pointer	RTN	END	VFDTA******************************************************* Procedure FINDAM** Find next Address Mark* uses DTARG, STATRG**At exit, if STATRG = 0, AM not found** Error possible-if no address marks found use Mesa timeout to catch*   Proper sector not found detected by code which*   calls this proc*************************************	PROC	FINDAMFINAM	XMIT	90X,IVL/WRMAC		All Off, incl ECCIZ' & ReadGate	MOVE	27H,0,DTARG/,,RDDSK	CLEAR SER-PAR CONV	XMIT	STCRC,IVL/WRDC2		SET TO CRC	XMIT	98X,IVL/WRMAC		MAKE ECCIZ' = LO	XMIT	90X,IVL/WRMAC		ECCIZ' BACK HI	XMIT	80X,IVL/WRMAC		READ GATE ON*WTLOCK	MOVE	27H,1,STATRG/,,DSKST	PPLL LOCK BIT*	ORG	6,32			No splintered addresses	NZT	STATRG,PLLWT		LOCK FOUND	JMP	WTLOCK			WAIT FOR PLL LOCK* Now to make certain that it is truly lockedPLLWT	NOP	NZT	27H,1,PLLOK/,,DSKST	PLL LOCK BIT	JMP	WTLOCK			WAIT FOR PLL LOCKPLLOK	XMIT	00,IVL/WRMAC		SEARCH ON**WAIT FOR RDDTAFNDGDRN	MOVE	20H,1,STATRG/,,FIFSTA	READ RdDtaFnd'*	ORG	22,32	NZT	STATRG,DTAF	JMP	GDRN			WAIT FOR RdDtaFnd'DTAF	XMIT	1,STATRG		Mark as AM Found*NOTE: Timing between DTAF & AMFND must not be changed!!!	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	NZT	23H,1,AMFND/,,DSKST	End it if AM found	XMIT	90X,IVL/WRMAC		All off, incl ECCIZ' & RdGate	XMIT	0,STATRG		Mark as error if no AM by nowAMFND	RTN	END	FINDAM*******************************************	Procedure ENDRB** End Reading a Block-* If ECCFLG = 1, does CRC check*	=0, does ECC check*  Puts syndrome into ScratchPad* ENTRB = check for CRC; ENDRC = check for ECC** Uses DTARG, R11* At End, if DTARG = NOT 0, CRC/ECC error has been found*******************************************	PROC	ENDRBENDRBA	XMIT	DTAECC,IVL/WRSPMA	Syndrome SA	MOVE	27H,0,DTARG/,,RDDSK	RD DATA & IGNORE	XMIT	40X,IVL/WRMAC		IBLA' ON; RD STILL ONENDRB1	NZT	21H,1,ENDRB1/,,FIFSTA	WAIT FOR BDONE	MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE	XMIT	50X,IVL/WRMAC		READ OFF, IBLA' STILL ONENDRB2	NZT	21H,1,ENDRB2/,,FIFSTA	WAIT FOR BDONE	MOVE	27H,0,DTARG/,,RDDSK	Get check byte	MOVE	DTARG,IVR		Put into syndromeENDRB3	NZT	21H,1,ENDRB3/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA       	MOVE	27H,0,DTARG/,,RDDSK	Get check byte	MOVE	DTARG,IVR		Put into syndromeENDRBC	XMIT	90X,IVL/WRMAC		OFFENDRBD	XMIT	DTAECC,IVL/WRSPMA	Address of syndrome	NOP				Wait for address to settle*If Syndrome = 0, no error: otherwise, error	MOVE	SPD,0,DTARG/,1		Get syndrome byte, incr SPMA	ORG	36,256	NZT	DTARG,ECCSR		Test for error	MOVE	SPD,0,DTARG/,1		Get syndrome byte, incr SPMA	NZT	DTARG,ECCSR		Test for error	NZT	ECCFLG,ECCSR	JMP	ECCSK			2 more bytes if ECCECCSR	RTN** Entry ENDRC  Like ENDRB but for ECC	ENTRY	ENDRCENDRCA	XMIT	DTAECC,IVL/WRSPMA	Syndrome SA	MOVE	27H,0,DTARG/,,RDDSK	RD DATA & IGNORE	NZT	21H,1,*/,,FIFSTA	WAIT FOR BDONE	MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE	NOP				Wait for BDONE to go awayENDRCB	NZT	21H,1,ENDRCB/,,FIFSTA	WAIT FOR BDONE	MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE	XMIT	40X,IVL/WRMAC		IBLA' ON; RD STILL ONENDRC1	NZT	21H,1,ENDRC1/,,FIFSTA	WAIT FOR BDONE	MOVE	27H,0,DTARG/,,RDDSK	READ data & IGNORE	XMIT	50X,IVL/WRMAC		READ OFF, IBLA' STILL ONENDRC2	NZT	21H,1,ENDRC2/,,FIFSTA	WAIT FOR BDONE       	MOVE	27H,0,DTARG/,,RDDSK	Get check byte	MOVE	DTARG,IVR		Put into syndromeENDRC3	NZT	21H,1,ENDRC3/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA	MOVE	27H,0,DTARG/,,RDDSK	Get check byte	MOVE	DTARG,IVR		Put into syndrome	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA	MOVE	27H,0,DTARG/,,RDDSK	Get check byte	MOVE	DTARG,IVR		Put into syndrome	NZT	21H,1,*/,,FIFSTA	Wait for BDONE	MOVE	SPD,0,DTARG/,1		Ignore data, incr SPMA       	MOVE	27H,0,DTARG/,,RDDSK	Get check byte	MOVE	DTARG,IVR		Put into syndrome	XMIT	90X,IVL/WRMAC		OFF	JMP	ENDRBD			Check ECC/CRC*ECCSK	MOVE	SPD,0,DTARG/,1		Get syndrome byte, incr SPMA	NZT	DTARG,ECCSR		Test for error	MOVE	SPD,0,DTARG		Get syndrome byte	JMP	ECCSR			end*	END	ENDRB**************************************************  PROCEDURE ZROERS** This procedure zeros all Error Type and ECC syndrome locations*   in ScratchPad memory and zeros Reg ERRTYP & IMMER***************************************************	PROC	ZROERSZROE	XMIT	HDRERT-1,IVL/WRSPMA	XMIT	0,IVR	XMIT	HDRERT,IVL/WRSPMA	XMIT	0,IVR	XMIT	LBLERT-1,IVL/WRSPMA	XMIT	0,IVR	XMIT	LBLERT,IVL/WRSPMA	XMIT	0,IVR	XMIT	DTAERT-1,IVL/WRSPMA	XMIT	0,IVR	XMIT	DTAERT,IVL/WRSPMA	XMIT	0,IVR	XMIT	LSTERT-1,IVL/WRSPMA	XMIT	0,IVR	XMIT	LSTERT,IVL/WRSPMA	XMIT	0,IVR	XMIT	DTAECC,IVL/WRSPMA	XMIT	0,IVR	XMIT	DTAECC+1,IVL/WRSPMA	XMIT	0,IVR	XMIT	DTAECC+2,IVL/WRSPMA	XMIT	0,IVR	XMIT	DTAECC+3,IVL/WRSPMA	XMIT	0,IVR	XMIT	0,ERRTYP	XMIT	0,IMMER	RTN	END	ZROERS*************************************************PROCEDURE NXTSC** THIS PROCEDURE sets up for next sector*  It tests wether the number of sectors to be transfered has been done*  If not*    Increment FilePageLo in labelImage*    Increment sector number in HeaderImage*    is "new" sector number too big?  If so*        Put lowest sector number into HeaderImage*        Incrememt Track Number*        Is new Track Number too big?  If so*            Put 0 into track number*            Incrememt Cylinder Number*            Is new Cylinder number too big?  If so*	ERROR 82X**	At end if DTARG = NOT 0, do next sector*	If DTARG = 0, end operation*	If ERRTYP = NOT 0, a fatal error has occured*************************************************	PROC	NXTSC	XMIT	0,IMMER			Reset ImmediateError**Transfered all sectors commanded?*NXTS	XMIT	SECNTH,IVL/WRSPMA	SP loc cont no of sectors left HI	XMIT	1,AUX	MOVE	SPD,0,DTXHI		Get hi part	XMIT	SECNTL,IVL/WRSPMA	SP loc cont no of sectors left Lo	NOP				Time for Address to settle	ADD	SPD,0,DTXLO		Add 1 to neg numberof sectors left, lo	MOVE	OVF,AUX	ADD	DTXHI,DTXHI		Cary into hi part	MOVE	DTXLO,IVR		Lo part back--SPMA still at SECNTL	XMIT	SECNTH,IVL/WRSPMA	Address of sectors to xfr, hi	MOVE	DTXHI,IVR		Put hi part back* Is result = 0?	XMIT	1,DTARG		Setup for not ended	NZT	DTXLO,NXNZ	Not zero, go on	NZT	DTXHI,NXNZ	XMIT	0,DTARG		Mark ended	JMP	NXEND		Transfer Completed**Transfer not completed, so set up for next sector*Double Precision Increment of FilePageLo in label*	ENTRY	NXTSENXNZ	XMIT	LBFPL,IVL/WRSPMA	Addr of FilePageLoLo	XMIT	1,AUX	ADD	SPD,0,WRKR		Incr FPLoLo	MOVE	WRKR,IVR		Back to FPLoLo	MOVE	OVF,AUX			Get cary bit	XMIT	LBFPL-1,IVL/WRSPMA	Addr of FPLoHi	NOP				Allow address to settle	ADD	SPD,0,WRKR		2d part of DP add	MOVE	WRKR,IVR		Put back FPLoHi	NZT	OVF,*+2			T if carry into FPH-HI	JMP	NXISC			No carry*A carry into FilePageHi-hi has occured.  The LSB of that byte is*a flag and must be preserved.  So, add 2. If overflow*has occured, FilePageHi has overflowed, an error. put 085X into ERRTYP*	XMIT	LBFPHH,IVL/WRSPMA	Address of FilePageHi-hi	NOP				Allow address to settle	MOVE	SPD,0,WRKR		Get it*Since the LS position is not part of the FP, add 2 instead of 1	XMIT	2,AUX	ADD	WRKR,IVR		Add & put back	ORG	3,256	NZT	OVF,FPOFA		FilePage overflow	JMP	NXISCFPOFA	JMP	FPOF**Increment sector number in headerImage*NXISC	XMIT	1,AUX	XMIT	HDSC,IVL/WRSPMA		Addr of sector no.	NOP				Allow address to settle	ADD	SPD,0,WRKR		sector no + 1	MOVE	WRKR,IVR		new sector no into header	XMIT	SECPT,IVL/WRSPMA	Add of MaxSecNo+1	NOP				Allow address to settle	MOVE	SPD,0,AUX		MaxSecNo+1 per track	XOR	WRKR,WRKR		Current SecNo = Max+1?	ORG	40,256	NZT	WRKR,NXEND		If not, exit*	XMIT	FSEC,IVL/WRSPMA	NOP				Allow address to settle	MOVE	SPD,0,WRKR		Starting sector no	XMIT	HDSC,IVL/WRSPMA	MOVE	WRKR,IVR		New sector number is starting no**Increment Head No.*	XMIT	1,AUX	XMIT	HDHD,IVL/WRSPMA		Address of Head byte	NOP				Allow address to settle	ADD	SPD,0,WRKR		Head + 1	MOVE	WRKR,IVR		New Head no in SP	XMIT	HDSPC,IVL/WRSPMA	Address of Heads + 1 Per Cylinder	NOP				Allow address to settle	MOVE	SPD,0,AUX	XOR	WRKR,WRKR		Compare new head no with max	NZT	WRKR,NXSH		Not too big*	XMIT	HDHD,IVL/WRSPMA		Address of Head byte	XMIT	0,IVR			New head number = 0	XMIT	HDCYH,IVL/WRSPMA	Address of cylinder in header, hi	NOP				Allow address to settle	MOVE	SPD,0,DTXHI		Hi part of cyl number	XMIT	HDCYL,IVL/WRSPMA	Address of cylinder in header, lo	XMIT	1,AUX	MOVE	SPD,0,DTXLO		Lo part of cyl number*Increment cylinder number	ADD	DTXLO,DTXLO	MOVE	OVF,AUX	ADD	DTXHI,DTXHI	MOVE	DTXLO,IVR		New cylinder no, lo	XMIT	HDCYH,IVL/WRSPMA	Addrerss of cylinder in header, hi	MOVE	DTXHI,IVR		New cylinder no, hi*Is new cylinder no too big?	XMIT	CYLPDH,IVL/WRSPMA	Address of cyl too big, hi	NOP				Wait for address to settle	MOVE	SPD,0,AUX	XOR	DTXHI,WRKR		Compare new cl hi/too big hi	NZT	WRKR,NXSK		Not too big	XMIT	CYLPDL,IVL/WRSPMA	Address of cyl too big, lo	NOP				Wait for address to settle	MOVE	SPD,0,AUX	XOR	DTXLO,WRKR		Too big?	NZT	WRKR,NXSK		Not too big	XMIT	82X,ERRTYP	XMIT	82X,IMMER		Mark error	JMP	NXEND			Do not seek if too big errorNXSK	MOVE	R11,R12			Save return pointer	CALL	SELHD			Sellect Head & Drive	XMIT	0,IMMER			Ready for implied seek	CALL	IMPSK			Seek	MOVE	R12,R11			Restore return pointer	NZT	IMMER,NXEND		Seek error	JMP	NXSHA			Good, exitNXSH	MOVE	R11,R12			Save return pointer	CALL	SELHD			Sellect Head & Drive	MOVE	R12,R11			Restore return pointerNXSHA	XMIT	1,DTARG			Mark transfer not endedNXEND	XMIT	LSTERT,IVL/WRSPMA	Address of Last Error Type	MOVE	ERRTYP,IVR		Put into SP	RTN*FPOF	XMIT	086X,ERRTYP		Mark FP overflow error	XMIT	086X,IMMER	JMP	NXEND*	END	NXTSC*****************************************************************************************************************************	Code for Track Read Command**************************************************************************************************************************TRKRD	CALL	ZROERS			Zero error locs*TST ONLY Remove the next 2 cmds for Product*	XMIT	0B0X,IVL/WRRDSP*	XMIT	0B0X,IVL/WRRDSP		SEND 4F TO RT DISP	XMIT	HDSC,IVL/WRSPMA	XMIT	0,IVR			Clear  HDSC	XMIT	0B0X,IVL/WRSPMA	XMIT	0,IVR			Clear Sector Count	XMIT	0B1X,IVL/WRSPMA	XMIT	0,IVR			Flag for first Sector read	XMIT	0E0X,IVL/WRSPMA	XMIT	0,IVR			Clear High Byte of Sector Valid	XMIT	0E1X,IVL/WRSPMA	XMIT	0,IVR			Clear Low Byte of Sector Valid* Set ECCRF according to ECCF* ECCF is 0 for ECC, 1 for CRC (Diag only)	XMIT	ECCF,IVL/WRSPMA		Address of ECCF	NOP				Wait for address to settle	MOVE	SPD,0,WRKR		ECCF into reg	XMIT	ECCRF,IVL/WRSPMA	Address of ECCRF	XMIT	STCRC,IVR		If ECCF is 1*	ORG	3,32	NZT	WRKR,TRKRD1	XMIT	STECC,IVR		If ECCF = 0TRKRD1	XMIT	FIFFM,IVL/WRSPMA	SP address for FIF F/eM flag	XMIT	0,IVR			Flag _ 0*	*Compare CurrentCyl with Cyl from HederImage.  If different, seek*	CALL	SELHD			Sellect Head & Drive	XMIT	0,IMMER			CALL	IMPSK**If IMMER is not zero, an error has occured*	ORG	11,256	NZT	IMMER,TRKRDA	JMP	TRKRD8TRKRDA	JMP	EREND*	ORG	4,32TRKRD8	NZT	26H,1,TRKRD2/,,FIFSTA	Is FIFO Empty?	XMIT	3,ERRTYP		FIFO is not empty	JMP	EREND*TRKRD2	XMIT	0,IMMER			Continue reading sectors loops here	XMIT	0,CNTRG	CALL	RFFCK			Check FIFO full, empty, half full	NZT	IMMER,TRKRDA		an error has occured	XMIT	0,IVL/TGLA		Toggle FF A	XMIT	1,ECCFLG		Set to CRC	XMIT	0B1X,IVL/WRSPMA	NOP	ORG	8,32	NZT	SPD,0,TRKRD3	CALL	VFYCYLHD		Read Sector	NZT	ERRTYP,TRKRD5	XMIT	0B1X,IVL/WRSPMA	XMIT	1,IVR	JMP	TRKRD5* Wait 8 bytes before starting to verify labelTRKRD3	CALL	VFYHD			Verify HeaderTRKRD5	XMIT	-30,DTARG	CALL	WTINST	CALL	RDLBL* Wait 7 bytes before starting to read data	XMIT	-26,DTARG	CALL	WTINST				XMIT	ECCF,IVL/WRSPMA		Address of ECC flag in IOCB	NOP				Wait for address to settle	MOVE	SPD,0,ECCFLG		Set Reg = IOCB flagTRKRD6	CALL	RDDTA			Read Data	ORG	33,256	NZT	ERRTYP,*+2	JMP	TRKRD7	MOVE	ERRTYP,AUX		IF Error Type = DATA AM,ID Error	XMIT	31X,WRKR		 then must set Dummy Data to FIFO	XOR	WRKR,WRKR		AM Error ?	NZT	WRKR,*+2	JMP	TRKRD9			If AM Error, Jmp to TRKRD9	MOVE	ERRTYP,AUX	XMIT	32X,WRKR	XOR	WRKR,WRKR		ID Error ?	NZT	WRKR,*+2	JMP	TRKRD9			If ID Error, Jmp to TRKRD9	JMP	TRKRD7			Other ErrorTRKRD9	CALL	DUMMYDATA		About 128 byte Time	XMIT	0,DTARG				CALL	WTINST			About 128 byte Time	XMIT	0,DTARG				CALL	WTINST			About 128 byte Time	XMIT	0,DTARG				CALL	WTINST			About 128 byte TimeTRKRD7	CALL	NXSCINTCK		Next sector?	XMIT	0B0X,IVL/WRSPMA	XMIT	16,AUX	XOR	SPD,0,WRKR	XMIT	0,ERRTYP	NZT	WRKR,*+2	JMP	OPCMP			Operation completed	JMP	TRKRD2	********************************************************************PROCEDURE VFYCYLHD*	Verify Cylinder & Head,*		Sector stores to DOB.*		And Only First Secter is Returned to Mesa.******************************************************************	PROC	VFYCYLHD	MOVE	R11,R13			Keep return pointer	XMIT	STCRC,IVL/WRDC2		Set to CRC	XMIT	-5,CNTRG		Setup for index countVFCHDA	XMIT	HDST,IVL/WRSPMA		Load Header Image SA	CALL	FINDAM			Find Address, Mark	ORG	3,32	NZT	STATRG,VFCHDB	JMP	VFYCHDW			Not AM try againVFCHDB	NZT	21H,1,VFCHDB/,,FIFSTA	WAIT FOR BDONE	XMIT	0FEX,AUX		Header ID BYTE	XOR	27H,0,DTARG/,,RDDSK	GET DATA	ORG	23,32	NZT	DTARG,VFYCYLRST		Not a Header-try again	XMIT	-3,WRKRVFCYL	NZT	21H,1,VFCYL/,,FIFSTA	WAIT FOR BDONE	MOVE	SPD,0,AUX/,1		Get byte image, Incr SPMA	XOR	27H,0,DTARG/,,RDDSK	Get & test data	NZT	DTARG,VFYCYLRST		Not proper header, start over	XMIT	1,AUX	ADD	WRKR,WRKR	NZT	WRKR,VFCYLSTRSC	NZT	21H,1,STRSC/,,FIFSTA	WAIT FOR BDONE	MOVE	27H,0,DTARG/,,RDDSK	Get First Sector	MOVE	DTARG,IVR		Store Sector Number*	JMP	VFCYL0VFCYL0	NZT	21H,1,VFCYL0/,,FIFSTA	WAIT FOR BDONE	CALL	ENDRB			End Reading a block	NZT	DTARG,VFYCYLCRE		A Hdr CRC error was found	JMP	VFYCYLRTN		exit procedure*VFYCYLCRE	XMIT	14X,ERRTYP	Mark error type	XMIT	HDRERT,IVL/WRSPMA	Address of Header Err Typ	XMIT	14X,IVR			Hdr CRC Error marked	JMP	VFYCYLRTN*VFYCYLRST	XMIT	90X,IVL/WRMAC		All off, incl ECCIZ' & RdGate	ORG	14,32	NZT	24H,1,VFYCHDW/,,DSKST	Restart if no indexVFYCYLIDX	XMIT	1,AUX	XMIT	0,IVL/INDXOF		Reset Index	ADD	CNTRG,CNTRG	NZT	CNTRG,VFYCHDW		AM, not 4 indexes	XMIT	81X,ERRTYP		error-Header not found	XMIT	HDRERT,IVL/WRSPMA	Address of Header Error Type	XMIT	81X,IVR			NoSectorFound errorVFYCYLRTN	XMIT	90X,IVL/WRMAC		Read off	MOVE	R13,R11			Restore return pointer	RTN	VFYCHDW	XMIT	-10,DTARG	CALL	WTINST			Wait 6 byte times	JMP	VFCHDA			Try again		END	VFYCYLHD*******************************************************************PROCEDURE DUMMYDATA*Write Dumy Data to FIFO *****************************************************************	PROC	DUMMYDATA	MOVE	R11,R13	XMIT	0,IVL/WRSPMA	XMIT	1,AUX	XMIT	0,WRKRDMYDTA1	MOVE	WRKR,IVL/WRFHI		Write Dummy DATA	MOVE	WRKR,IVL/WRFLO,1	Write Dummy DATA	NOP	NZT	24H,1,DMYDTA1/,,FIFSTA	Write 255 Word to FIFO	MOVE	WRKR,IVL/WRFHI	MOVE	WRKR,IVL/WRFLO	MOVE	R13,R11	RTN	END	DUMMYDATA************************************************************************  PROCEDURE NXSCINTCK*Set up for next Sector, Increment Sector Number*		and set SectorValid***********************************************************************	PROC	NXSCINTCK	MOVE	R11,R13	XMIT	HDSC,IVL/WRSPMA	XMIT	1,AUX	ADD	SPD,0,WRKR	XMIT	16,AUX	MOVE	WRKR,DTARG	XOR	WRKR,WRKR	ORG	38,256	NZT	WRKR,*+2	XMIT	0,DTARG			16 => 0	MOVE	DTARG,IVR		Increment HDSC	XMIT	0B0X,IVL/WRSPMA	XMIT	8X,AUX	MOVE	SPD,0,WRKR	MOVE	WRKR,DTARG		Save Content of WRKR	AND	DTARG,DTARG		Check Bit4 of DTARG	NZT	DTARG,HByteLByte	XMIT	0E1X,IVL/WRSPMA		Low Byte of Reserved1	NOP	NZT	ERRTYP,*+3	XMIT	1,AUX	JMP	*+2	XMIT	0,AUX	ADD	SPD,0,WRKR	MOVE	WRKR(1),WRKR	MOVE	WRKR,IVR	JMP	EndNXHByte	XMIT	0E0X,IVL/WRSPMA		High Byte of Reserved1	NOP	NZT	ERRTYP,*+3	XMIT	1,AUX	JMP	*+2	XMIT	0,AUX	ADD	SPD,0,WRKR	MOVE	WRKR(1),WRKR	MOVE	WRKR,IVREndNX	XMIT	0B0X,IVL/WRSPMA		XMIT	1,AUX	ADD	SPD,0,WRKR		Increment Sector Count	MOVE	WRKR,IVR		Store Sector Count	NZT	ERRTYP,*+2	JMP	ENDNX1	XMIT	LSTERT,IVL/WRSPMA	MOVE	ERRTYP,IVRENDNX1	MOVE	R13,R11	RTN*		END	NXSCINTCK*	END	RDVF2	***
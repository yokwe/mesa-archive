-- XTimeImpl.mesa   derived from TimeImpl-- last edited by: -- JGS on     16-Dec-83 13:42:40DIRECTORY  Inline USING [DIVMOD, LDIVMOD, LongNumber],  System USING [GetGreenwichMeanTime, GetLocalTimeParameters,    GreenwichMeanTime, gmtEpoch, LocalTimeParameters, SecondsSinceEpoch],  XChar USING [Character, not],  XCharSet0 USING [Make],  XMessage,  XComSoftMessage,  XFormat,  XString,  XTime USING [defaultTime, LTP, Unpacked, useSystem];XTimeImpl: PROGRAM  IMPORTS Inline, System, XComSoftMessage, XCharSet0, XFormat, XMessage, XString  EXPORTS XTime =  BEGIN OPEN XS: XString;    dateAndTime, dateOnly, timeOnly: PUBLIC XString.Reader _ NIL;  messages: XMessage.Handle _ NIL;    StartWeekDay: CARDINAL = 0; -- Jan. 1, 1968 was a Monday  BaseYear: CARDINAL = 1968;  DaysInFourYears: CARDINAL = 4*365+1;  Unpacked: TYPE = XTime.Unpacked;  UP: TYPE = POINTER TO Unpacked;  Number: TYPE = Inline.LongNumber;  LTP: TYPE = XTime.LTP;    DivideTime: PROC [num: Number, den: CARDINAL]    RETURNS [quotient: LONG CARDINAL, remainder: CARDINAL] =    BEGIN OPEN Inline;    q: Number;    t: CARDINAL;    [q.highbits, t] _ LDIVMOD[num.highbits,0,den];    [q.lowbits, remainder] _ LDIVMOD[num.lowbits,t,den];    RETURN[quotient: q.lc, remainder: remainder]    END;  Current: PUBLIC PROCEDURE RETURNS [System.GreenwichMeanTime] =    {RETURN[System.GetGreenwichMeanTime[]]};  TP: TYPE = RECORD [    beginDST, endDST: CARDINAL,    zone, zoneMinutes: INTEGER];  TimeParameters: PROCEDURE [l: LTP] RETURNS [TP] =    BEGIN    ltp: System.LocalTimeParameters;    p: TP;    WITH tp: l SELECT FROM       useThese => ltp _ tp.ltp;      useSystem => ltp _ System.GetLocalTimeParameters[];      ENDCASE;    p _ [ltp.beginDST, ltp.endDST, ltp.zone, ltp.zoneMinutes];    IF ltp.direction # west THEN      {p.zone _ -p.zone; p.zoneMinutes _ -p.zoneMinutes};    RETURN[p]    END;  MonthTable: ARRAY [0..12] OF CARDINAL =    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];  Unpack: PUBLIC PROCEDURE [time: System.GreenwichMeanTime, ltp: LTP]    RETURNS [unpacked: Unpacked] =    BEGIN    seconds: LONG CARDINAL;    u: UP = @unpacked;    day4, day, yr4: CARDINAL;    month: CARDINAL _ 1;    t: Number;    parms: TP = TimeParameters[ltp];    WITH tp: ltp SELECT FROM      useThese => u.zone _ tp.ltp;      useSystem => u.zone _ System.GetLocalTimeParameters[];      ENDCASE;    IF time = XTime.defaultTime THEN time _ System.GetGreenwichMeanTime[];    seconds _ System.SecondsSinceEpoch[time];    [seconds, u.second] _ DivideTime[[lc[seconds]],60];    seconds _ seconds-parms.zoneMinutes; -- ignore underflow    [seconds, u.minute] _ DivideTime[[lc[seconds]],60];    u.dst _ FALSE;    seconds _ seconds-parms.zone; -- ignore underflow    DO -- have to repeat if DST      [t.lc, u.hour] _ DivideTime[[lc[seconds]],24];      u.weekday _ (t.lowbits + StartWeekDay) MOD 7;      [yr4,day4] _ Inline.DIVMOD[t.lowbits,DaysInFourYears];      IF day4 >= (365+31+29) THEN	day4 _ (day4-31-29)/365 + day4;      [day4, day] _ Inline.DIVMOD[day4, 366];      u.year _ BaseYear + yr4*4 + day4;      WHILE day >= MonthTable[month] DO month _ month + 1 ENDLOOP;      u.month _ month _ month-1;      day _ day + 1;      u.day _ day - MonthTable[month];      IF u.dst OR NOT CheckDateGE[u, parms.beginDST, 2]        OR CheckDateGE[u, parms.endDST, 1] THEN EXIT;      seconds _ seconds + 1;      u.dst _ TRUE;      ENDLOOP;    RETURN    END;  Invalid: PUBLIC ERROR = CODE;  Pack: PUBLIC PROCEDURE [unpacked: Unpacked, useSystemLTP: BOOLEAN]      RETURNS [time: System.GreenwichMeanTime] =    BEGIN    u: UP = @unpacked;    year, month, day, day1, hour, minute, second: CARDINAL;    yr3: [0..3];    t: Number;    tp: TP _ TimeParameters[      IF useSystemLTP THEN XTime.useSystem ELSE [useThese[u.zone]]];    [     year: year, month: month, day: day, hour: hour, minute: minute,     second: second] _ u^;    IF (year _ year-BaseYear) >= 136 OR      month >=12 OR day ~IN[1..31] OR      hour >= 24 OR minute >= 60 OR second >= 60 THEN ERROR Invalid;    yr3 _ year MOD 4;    IF day > LOOPHOLE[MonthTable[month+1] - MonthTable[month], CARDINAL] OR      (month = 1 AND day = 29 AND yr3 # 0) THEN ERROR Invalid;    -- compute days this year in day1    day1 _ MonthTable[month] + day;    IF yr3 # 0 AND month > 1 THEN day1 _ day1 - 1;    t _ Number[num[      highbits: 0,      lowbits: (year/4)*DaysInFourYears + yr3*365 + day1 - 1]];    IF yr3 # 0 THEN t.lowbits _ t.lowbits + 1; -- first of four year cycle is leap    u.weekday _ (t.lowbits + StartWeekDay) MOD 7;    IF CheckDateGE[u, tp.beginDST, 2]      AND NOT CheckDateGE[u, tp.endDST, 2] THEN tp.zone _ tp.zone - 1;    RETURN[[System.gmtEpoch +     ((t.lc*24+hour+tp.zone)*60+minute+tp.zoneMinutes)*60+second]]    END;  Append: PUBLIC PROC [    w: XS.Writer, time: System.GreenwichMeanTime, template: XS.Reader, ltp: LTP] =    BEGIN    fObject: XFormat.Object _ XFormat.WriterObject[w];    fH: XFormat.Handle _ @fObject;    openAngle: XChar.Character = XCharSet0.Make[lessThan];    closeAngle: XChar.Character = XCharSet0.Make[greaterThan];    break: XChar.Character _ XChar.not;    rest, front: XS.ReaderBody;    leadingZero: BOOLEAN;    number: CARDINAL;    unpacked: Unpacked _ Unpack[time, ltp];    u: UP = @unpacked;    IF template = NIL THEN template _ dateAndTime;    rest _ template^;    DO      front _ XS.ScanForCharacter[@rest, openAngle, ignore, @break];      XFormat.Reader[fH, @front];      IF XS.Empty[@rest] THEN {        IF break # XChar.not THEN fH.Char[openAngle]; RETURN};      front _ XS.ScanForCharacter[@rest, closeAngle, ignore, @break];      number _ CARDINAL[XS.ReaderToNumber[@front !        XS.InvalidNumber, XS.Overflow => {	  fH.Char[openAngle];	  fH.Reader[@front];	  IF break # XChar.not THEN fH.Char[closeAngle];	  number _ CARDINAL.LAST;	  CONTINUE}]];      leadingZero _ (XS.First[@front] = '0.ORD);      SELECT (number-1) FROM        MessageIndex.monthNumber.ORD =>	  XFormat.Number[h: fH, n: u.month+1, format: [	    base: 10, zerofill: leadingZero,	    columns: IF leadingZero THEN 2 ELSE 1]];        MessageIndex.dayNumber.ORD =>	  XFormat.Number[h: fH, n: u.day, format: [	    base: 10, zerofill: leadingZero,	    columns: IF leadingZero THEN 2 ELSE 1]];        MessageIndex.year4.ORD =>	  XFormat.Number[fH, u.year, [base: 10, columns: 4]];        MessageIndex.year2.ORD =>	  XFormat.Number[fH, u.year MOD 100, [base: 10, columns: 2]];        MessageIndex.monthMessage.ORD => 	  XFormat.Reader[fH, messages.Get[month[u.month].ORD]];        MessageIndex.monthMessage3.ORD => {	  rb: XS.ReaderBody _ messages.Get[month[u.month].ORD]^;	  XFormat.ReaderBody[fH, XS.Piece[@rb, 0, 3].piece]};        MessageIndex.hour12.ORD => {	  hour: NATURAL _ u.hour MOD 12;	  IF hour = 0 THEN hour _ 12;	  XFormat.Number[h: fH, n: hour, format: [	    base: 10, zerofill: leadingZero,	    columns: IF leadingZero THEN 2 ELSE 1]]};        MessageIndex.hour24.ORD =>	  XFormat.Number[h: fH, n: u.hour, format: [	    base: 10, zerofill: leadingZero,	    columns: IF leadingZero THEN 2 ELSE 1]];        MessageIndex.minutes.ORD =>	  XFormat.Number[fH, u.minute, [zerofill: TRUE, columns: 2]];        MessageIndex.seconds.ORD =>	  XFormat.Number[fH, u.second, [zerofill: TRUE, columns: 2]];        MessageIndex.day.ORD =>	  XFormat.Reader[fH, messages.Get[dayOfWeek[u.weekday].ORD]];        MessageIndex.zone.ORD => AppendZone[fH, u];        MessageIndex.ampm.ORD => 	  XFormat.Reader[fH, messages.Get[AmPm[u].key.ORD]];        ENDCASE;      ENDLOOP;    END;  AmPm: PROC [u: UP] RETURNS [key: XComSoftMessage.Keys] = {    SELECT TRUE FROM      u.hour = 0 AND u.minute = 0 AND u.second = 0 => RETURN[pm];      u.hour = 12 AND u.minute = 0 AND u.second = 0 => RETURN[am];      u.hour IN [1..11] => RETURN[am];      ENDCASE => RETURN[pm]};      MessageIndex: TYPE = {    monthNumber, dayNumber, year4, year2, monthMessage, monthMessage3,    hour12, hour24, minutes, seconds, day, zone, ampm};    dayOfWeek: ARRAY [0..7) OF XComSoftMessage.Keys = [    monday, tuesday, wednesday, thursday, friday, saturday, sunday];    month: ARRAY [0..12) OF XComSoftMessage.Keys = [    january, february, march, april, may, june,    july, august, september, october, november, december];      AppendZone: PROCEDURE [fH: XFormat.Handle, u: UP] =    BEGIN    parms: TP = TimeParameters[[useThese[u.zone]]];    USZones: TYPE = [4..10];    space: XChar.Character = XCharSet0.Make[space];    zones: PACKED ARRAY USZones OF CHARACTER = ['A,'E,'C,'M,'P,'Y,'H];    west: CHARACTER _ '-;    east: CHARACTER _ '+;    z: INTEGER;    dst: BOOLEAN _ CheckDateGE[u, parms.beginDST, 2]      AND NOT CheckDateGE[u, parms.endDST, 2];    IF (z _ parms.zone) IN USZones AND parms.zoneMinutes = 0 THEN    -- Newfoundland/Labrador zone is checked for below      BEGIN      XFormat.Char[fH, zones[z].ORD];      XFormat.Char[fH, IF dst THEN 'D.ORD ELSE 'S.ORD];      XFormat.Char[fH,'T.ORD];      RETURN      END;    IF parms.zone = 3 AND parms.zoneMinutes = 30 THEN {      XFormat.ReaderBody[fH, XS.FromSTRING[IF dst THEN "NDT"L ELSE "NST"L]];      RETURN};    IF dst THEN z _ z - 1;    IF z = 0 THEN XFormat.ReaderBody[fH, XS.FromSTRING["GMT"L]]    ELSE {      XFormat.Char[fH, IF z > 0 THEN west.ORD ELSE east.ORD];      XFormat.Number[        h: fH, n: ABS[z],	format: [base: 10, zerofill: FALSE, signed: FALSE, columns: 0]];      IF (z _ ABS[parms.zoneMinutes]) # 0 THEN {	XFormat.Char[fH, ':.ORD];	XFormat.Number[	  h: fH, n: z,	  format: [base: 10, zerofill: TRUE, signed: FALSE, columns: 2]]}};    END;  CheckDateGE: PROC [u: UP, dstDay, dstHour: INTEGER] RETURNS [BOOLEAN] =    BEGIN    weekday: INTEGER _ u.weekday;    day: INTEGER = MonthTable[u.month] + u.day;    RETURN[      IF day < dstDay-6 THEN FALSE      ELSE IF day > dstDay THEN TRUE      ELSE IF weekday = 6 THEN u.hour >= dstHour      ELSE day-weekday > dstDay-6]    END;  Init: PROC = {    messages _ XComSoftMessage.GetHandle[];    dateAndTime _ messages.Get[XComSoftMessage.Keys.dateAndTime.ORD];    dateOnly _ messages.Get[XComSoftMessage.Keys.date.ORD];    timeOnly _ messages.Get[XComSoftMessage.Keys.time.ORD]};      Init[];      END.LOGJuly 15, 1979  3:33 PM	Johnsson	Create fileFebruary 9, 1980  1:44 PM	McJones	Use System.GreenwichMeanTimeMarch 1, 1980  3:50 PM	Johnsson	Fix leapyear bug introduced in change of epochApril 17, 1980  11:14 AM	McJones	Change default time for Unpack to gmtEpochSeptember 30, 1980  9:36 AM	Johnsson	Various bugsJanuary 28, 1981  4:40 PM	McJones	Use System.GetLocalTimeParameters
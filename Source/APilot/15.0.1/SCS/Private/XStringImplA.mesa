-- File: XStringImplA.mesa - last edit by-- JGS on	19-Dec-83 14:12:37-- Ching	 6-Apr-84 11:31:32 	Fix AR 5936.DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block, Byte, bytesPerWord, nullBlock],  NSString USING [String],  XChar USING [    ArabicFirstRightToLeftCharCode, Character, JoinDirection, Make, not, Set],  XCharSets USING [Sets],  XString USING [    BreakTableObject, Byte, Bytes, ByteSequence, Character, Context, Empty,    emptyContext, ErrorCode, MapCharProc, nullReaderBody, nullWriterBody, Reader,    ReaderBody, ReadOnlyBytes, Scan, vanillaContext, unknownContext,    Writer, WriterBody];XStringImplA: PROGRAM  IMPORTS ByteBlt, XChar, XString EXPORTS XChar, XString SHARES XString =  BEGIN OPEN XString;  State: TYPE = {char8, char16High, char16Low, esc1, esc2};  selectCode: Environment.Byte = 377B;  Error: PUBLIC ERROR [code: ErrorCode] = CODE;  InvalidEncoding: PUBLIC ERROR [    invalidReader: Reader, firstBadByteOffset: CARDINAL] = CODE;  Deref: PROC [r: Reader] RETURNS [ReaderBody] = INLINE {    RETURN[IF r = NIL THEN nullReaderBody ELSE r^]};      Length: PROC [r: Reader] RETURNS [CARDINAL] = INLINE {    RETURN[r.limit-r.offset]};      Block: PUBLIC PROC [    r: Reader] RETURNS [block: Environment.Block, context: Context] = {    IF r = NIL THEN RETURN[block: Environment.nullBlock, context: vanillaContext]    ELSE RETURN[      block: [blockPointer: LOOPHOLE[r.bytes], startIndex: r.offset,        stopIndexPlusOne: r.limit],      context: r.context]};  CharacterLength: PUBLIC PROC [r: Reader] RETURNS [nChars: CARDINAL] = {    CountChars: MapCharProc = {nChars _ nChars + 1; RETURN[FALSE]};    SELECT TRUE FROM      Empty[r] => RETURN[0];      r.context.homogeneous => RETURN[(r.limit-r.offset)/r.context.suffixSize];      ENDCASE => {        nChars _ 0;        [] _ Map[r, CountChars];        RETURN[nChars]}};  ClearWriter: PUBLIC PROC [w: Writer] = {    IF w # NIL THEN {      w.limit _ w.offset;      w.endContext _ w.context _ emptyContext}};      ComputeEndContext: PUBLIC PROC [r: Reader] RETURNS [c: Context] = {    rb: ReaderBody _ Deref[r];    state: State;    IF rb.context.homogeneous THEN RETURN[rb.context];    state _ IF rb.context.suffixSize = 1 THEN char8 ELSE char16High;    c _ [      suffixSize: rb.context.suffixSize, homogeneous: TRUE,      prefix: rb.context.prefix];    WHILE rb.offset # rb.limit DO      byte: Environment.Byte _ rb.bytes[rb.offset];      SELECT state FROM        char8 =>          DO            IF byte = selectCode THEN {state _ esc1; EXIT};            IF (rb.offset _ rb.offset + 1) = rb.limit THEN RETURN[c];            byte _ rb.bytes[rb.offset];            ENDLOOP;        char16High =>          IF byte = selectCode THEN state _ esc1 ELSE state _ char16Low;        char16Low =>          IF byte = selectCode THEN GOTO invalidEncoding ELSE state _ char16High;        esc1 =>          IF byte = selectCode THEN {c.homogeneous _ FALSE; state _ esc2}          ELSE {	    c _ [prefix: byte, suffixSize: 1, homogeneous: FALSE];	    state _ char8};        esc2 =>          IF byte # 0 THEN GOTO invalidEncoding          ELSE {c.suffixSize _ 2; state _ char16High};        ENDCASE => ERROR;  -- EXHAUSTED      rb.offset _ rb.offset + 1;      REPEAT invalidEncoding => {}      ENDLOOP;    RETURN};  Dereference: PUBLIC PROC [r: Reader] RETURNS [ReaderBody] = {RETURN[Deref[r]]};  Equal: PUBLIC PROC [r1, r2: Reader] RETURNS [BOOLEAN] = {    rb1: ReaderBody _ Deref[r1];    rb2: ReaderBody _ Deref[r2];    c1, c2: Character;    DO      c2 _ Lop[@rb2];      IF (c1 _ Lop[@rb1]) = XChar.not THEN RETURN[c2 = XChar.not];      IF c2 = XChar.not THEN RETURN[FALSE];      IF c1 # c2 THEN RETURN[FALSE];      ENDLOOP};  First: PUBLIC PROC [r: Reader] RETURNS [c: Character] = {    byte: Environment.Byte;    IF Empty[r] THEN RETURN[XChar.not];    byte _ r.bytes[r.offset];    RETURN[      SELECT TRUE FROM	byte = selectCode => NthCharacter[r, 0],	r.context.suffixSize = 1 =>	  XChar.Make[set: r.context.prefix, code: byte],	r.limit = r.offset+1 => XChar.not,	ENDCASE =>	  XChar.Make[set: byte, code: r.bytes[r.offset + 1]]]};  Lop: PUBLIC PROC [r: Reader] RETURNS [c: Character] = {    state: State;    rb: ReaderBody _ Deref[r];    set: Environment.Byte;    IF rb.context.suffixSize = 1 THEN {      set _ VAL[rb.context.prefix]; state _ char8}    ELSE state _ char16High;    WHILE rb.limit # rb.offset DO      byte: Environment.Byte = rb.bytes[rb.offset];      SELECT state FROM        char8 =>          IF byte = selectCode THEN state _ esc1          ELSE {            r.offset _ rb.offset + 1;            RETURN[XChar.Make[set: set, code: byte]]};        char16High =>          IF byte = selectCode THEN state _ esc1          ELSE {set _ VAL[byte]; state _ char16Low};        char16Low =>          IF byte = selectCode THEN GOTO invalidEncoding          ELSE {            r.offset _ rb.offset + 1;            RETURN[XChar.Make[set: set, code: byte]]};        esc1 =>          IF byte = selectCode THEN state _ esc2          ELSE {	    r.context.suffixSize _ 1;	    set _ VAL[r.context.prefix _ byte];	    state _ char8};        esc2 =>	  IF byte # 0 THEN GOTO invalidEncoding	  ELSE {r.context.suffixSize _ 2; state _ char16High};        ENDCASE => ERROR;  -- EXHAUSTED      rb.offset _ rb.offset + 1;      REPEAT invalidEncoding => {r.limit _ rb.offset}      ENDLOOP;    RETURN[XChar.not]};  Map: PUBLIC PROC [r: Reader, proc: MapCharProc] RETURNS [c: Character] = {    rb: ReaderBody _ Deref[r];    state: State;    byte: Environment.Byte;    set: Environment.Byte;    IF rb.context.suffixSize = 1 THEN {      set _ VAL[rb.context.prefix]; state _ char8}    ELSE state _ char16High;    WHILE rb.offset # rb.limit DO      byte _ rb.bytes[rb.offset];      SELECT state FROM        char8 =>          DO            IF byte = selectCode THEN {state _ esc1; EXIT};            IF proc[c _ XChar.Make[set: set, code: byte]] THEN RETURN;            IF (rb.offset _ rb.offset + 1) = rb.limit THEN RETURN[XChar.not];            byte _ rb.bytes[rb.offset];            ENDLOOP;        char16High =>          IF byte = selectCode THEN state _ esc1          ELSE {set _ VAL[byte]; state _ char16Low};        char16Low =>          IF byte = selectCode THEN GOTO invalidEncoding          ELSE {            state _ char16High;            IF proc[c _ XChar.Make[set: set, code: byte]] THEN RETURN};        esc1 =>          IF byte = selectCode THEN state _ esc2          ELSE {set _ VAL[byte]; state _ char8};        esc2 => IF byte # 0 THEN GOTO invalidEncoding ELSE state _ char16High;        ENDCASE => ERROR;  -- EXHAUSTED      rb.offset _ rb.offset + 1;      REPEAT invalidEncoding => {}      ENDLOOP;    RETURN[XChar.not]};  NthCharacter: PUBLIC PROC [r: Reader, n: CARDINAL] RETURNS [c: Character] = {    CountChars: MapCharProc = {      IF n = 0 THEN RETURN[TRUE]; n _ n - 1; RETURN[FALSE]};    RETURN[Map[r, CountChars]]};  FromBlock: PUBLIC PROC [block: Environment.Block, context: Context]    RETURNS [ReaderBody] = {    RETURN[[      limit: block.stopIndexPlusOne, context: context,      bytes: LOOPHOLE[block.blockPointer], offset: block.startIndex]]};  FromChar: PUBLIC PROC [    char: LONG POINTER TO Character] RETURNS [ReaderBody] = {    set: Environment.Byte = XChar.Set[char^];    RETURN[[      limit: 2, bytes: LOOPHOLE[char], offset: 1, context: [        suffixSize: 1, homogeneous: TRUE, prefix: set]]]};  FromNSString: PUBLIC PROC [    s: NSString.String, homogeneous: BOOLEAN _ FALSE] RETURNS [ReaderBody] = {    RETURN[[      limit: s.length, offset: 0, bytes: LOOPHOLE[s.bytes],      context: IF homogeneous THEN emptyContext ELSE vanillaContext]]};  FromSTRING: PUBLIC PROC [    s: LONG STRING, homogeneous: BOOLEAN _ FALSE] RETURNS [ReaderBody] = {    offset: CARDINAL = SIZE[StringBody]*Environment.bytesPerWord;    IF s # NIL AND s.length > CARDINAL.LAST-offset THEN      ERROR Error[tooManyBytes];    RETURN[[      limit: s.length + offset, offset: offset, bytes: LOOPHOLE[s],      context: IF homogeneous THEN emptyContext ELSE vanillaContext]]};  ReaderInfo: PUBLIC PROC [    r: Reader] RETURNS [context: Context, startsWith377B: BOOLEAN] = {    IF r = NIL THEN RETURN[vanillaContext, FALSE];    RETURN[      context: r.context,      startsWith377B:        IF Length[r] = 0 THEN FALSE ELSE r.bytes[r.offset] = 377B]};    ReverseMap: PUBLIC PROC [    r: Reader, proc: MapCharProc] RETURNS [c: Character] = {    RunCount: CARDINAL = 8;    runs: ARRAY [0..RunCount) OF ReaderBody;    nRuns: NATURAL _ 0;    rb: ReaderBody;    IF Empty[r] THEN RETURN[XChar.not];    rb _ r^;    DO      runs[nRuns] _ Run[@rb];      IF Length[@runs[nRuns]] = 0 THEN EXIT;      IF (nRuns _ nRuns + 1) = RunCount THEN {        IF (c _ ReverseMap[@rb, proc]) # XChar.not THEN RETURN ELSE EXIT};      ENDLOOP;    FOR i: CARDINAL DECREASING IN [0..nRuns) DO      rb _ runs[i];      IF rb.context.suffixSize = 1 THEN {	UNTIL rb.limit = rb.offset DO	  c _ XChar.Make[	    set: rb.context.prefix, code: rb.bytes[rb.limit _ rb.limit - 1]];          IF proc[c] THEN RETURN;	  ENDLOOP}      ELSE {        IF Length[@rb] MOD 2 # 0 THEN RETURN[XChar.not];	UNTIL rb.limit = rb.offset DO	  c _ XChar.Make[	    set: rb.bytes[rb.limit _ rb.limit - 1],	    code: rb.bytes[rb.limit _ rb.limit - 1]];          IF proc[c] THEN RETURN;	  ENDLOOP}      ENDLOOP;    RETURN[XChar.not]};	    Run: PUBLIC PROC [r: Reader] RETURNS [run: ReaderBody] = {    char: Character;    break: BreakTableObject _ [otherSets: stop, set:, codes: ALL[not]];    IF r = NIL THEN RETURN[nullReaderBody];    run _ r^;    IF run.context.homogeneous THEN {r^ _ nullReaderBody; RETURN};    break.set _ XChar.Set[char _ First[r]];    RETURN[Scan[r, @break, leaveOnRest, @char]]};  ValidateReader: PUBLIC PROC [r: Reader] = {    rb: ReaderBody _ Deref[r];    state: State;    firstBad: CARDINAL _ rb.offset;    state _ IF rb.context.suffixSize = 1 THEN char8 ELSE char16High;    IF rb.limit < rb.offset OR (rb.bytes = NIL AND rb.limit # rb.offset) THEN      ERROR Error[invalidParameter];    WHILE rb.offset # rb.limit DO      byte: Environment.Byte _ rb.bytes[rb.offset];      SELECT state FROM        char8 =>          DO            IF byte = selectCode THEN {state _ esc1; EXIT};            rb.offset _ firstBad _ rb.offset + 1;            IF rb.offset = rb.limit THEN GOTO done;            byte _ rb.bytes[rb.offset];            ENDLOOP;        char16High =>          IF byte = selectCode THEN state _ esc1 ELSE state _ char16Low;        char16Low =>          IF byte = selectCode THEN ERROR InvalidEncoding[r, firstBad]          ELSE {firstBad _ rb.offset + 1; state _ char16High};        esc1 => IF byte = selectCode THEN state _ esc2 ELSE state _ char8;        esc2 =>          IF byte # 0 THEN ERROR InvalidEncoding[r, firstBad]	  ELSE state _ char16High;        ENDCASE => ERROR;  -- EXHAUSTED      rb.offset _ rb.offset + 1;      REPEAT done => {};      ENDLOOP;    IF firstBad # rb.offset THEN ERROR InvalidEncoding[r, firstBad]};  WriterBodyFromBlock: PUBLIC PROC [block: Environment.Block, inUse: CARDINAL]    RETURNS [WriterBody] = {    OPEN b: block;    RETURN[[      limit: inUse + b.startIndex, bytes: LOOPHOLE[b.blockPointer],      context: vanillaContext, offset: b.startIndex, zone: NIL,      maxLimit: b.stopIndexPlusOne,      endContext: unknownContext]]};  WriterBodyFromNSString: PUBLIC PROC [    s: NSString.String, homogeneous: BOOLEAN _ FALSE]    RETURNS [WriterBody] = {    RETURN[[      limit: s.length, offset: 0, bytes: LOOPHOLE[s.bytes], zone: NIL,      context: IF homogeneous THEN emptyContext ELSE vanillaContext,      endContext: IF homogeneous THEN emptyContext ELSE unknownContext,      maxLimit: s.maxlength]]};  WriterBodyFromSTRING: PUBLIC PROC [    s: LONG STRING, homogeneous: BOOLEAN _ FALSE] RETURNS [WriterBody] = {    offset: CARDINAL = SIZE[StringBody]*Environment.bytesPerWord;    IF s # NIL AND s.length > CARDINAL.LAST-offset THEN      ERROR Error[tooManyBytes];    RETURN[[      limit: s.length + offset, offset: offset, bytes: LOOPHOLE[s], zone: NIL,      context: IF homogeneous THEN emptyContext ELSE vanillaContext,      endContext: IF homogeneous THEN emptyContext ELSE unknownContext,      maxLimit: s.maxlength + offset]]};  WriterInfo: PUBLIC PROC [w: Writer] RETURNS [    unused: CARDINAL, endContext: Context, zone: UNCOUNTED ZONE] = {    IF w = NIL THEN RETURN[0, vanillaContext, NIL] ELSE    RETURN[w.maxLimit-w.limit, w.endContext, w.zone]};    CopyToNewReaderBody: PUBLIC PROC [    r: Reader, z: UNCOUNTED ZONE] RETURNS [ReaderBody] = {    IF r = NIL THEN RETURN[nullReaderBody]    ELSE {      rb: ReaderBody _ [limit: r.limit-r.offset, context: r.context, offset: 0,        bytes: z.NEW[ByteSequence[r.limit-r.offset]]];      [] _ ByteBlt.ByteBlt[from: Block[r].block, to: Block[@rb].block];      RETURN[rb]}};  FreeReaderBytes: PUBLIC PROC [r: Reader, z: UNCOUNTED ZONE] = {    IF r = NIL THEN RETURN; z.FREE[@r.bytes]};  CopyReader: PUBLIC PROC [    r: Reader, z: UNCOUNTED ZONE] RETURNS [new: Reader] = {    offset: CARDINAL = SIZE[XString.ReaderBody] * Environment.bytesPerWord;    BodyAndBytes: TYPE = RECORD [      body: ReaderBody, byteSeq: PACKED SEQUENCE COMPUTED CARDINAL OF Byte];    bnb: LONG POINTER TO BodyAndBytes;    IF r = NIL THEN RETURN[NIL];    IF Length[r] > CARDINAL.LAST-offset THEN ERROR Error[tooManyBytes];    bnb _ z.NEW[BodyAndBytes[r.limit-r.offset] _ [      body: [        context: r.context, limit: r.limit-r.offset + offset, offset:offset,        bytes: NIL],       byteSeq:]];    bnb.body.bytes _ LOOPHOLE[bnb];    [] _ ByteBlt.ByteBlt[from: Block[r].block, to: Block[@bnb.body].block];    RETURN[@bnb.body]};  -- allocation and deallocation of writers  NewWriterBody: PUBLIC PROC [maxLength: CARDINAL, z: UNCOUNTED ZONE]    RETURNS [WriterBody] = {    IF z = NIL THEN RETURN[nullWriterBody];    RETURN[[      limit: 0, offset: 0, bytes: z.NEW[ByteSequence[maxLength]], zone: z,      maxLimit: maxLength, endContext: emptyContext, context: emptyContext]]};  FreeWriterBytes: PUBLIC PROC [w: Writer] = {    IF w = NIL OR w.zone = NIL THEN RETURN; w.zone.FREE[@w.bytes]};  GetJoinDirection: PUBLIC PROCEDURE [set, code: Environment.Byte] RETURNS [XChar.JoinDirection] = {    specialCode: Environment.Byte = XChar.ArabicFirstRightToLeftCharCode;    RETURN[SELECT set FROM      < XCharSets.Sets.arabic.ORD => nextCharToRight,  -- arabic & hebrew      > XCharSets.Sets.hebrew.ORD => nextCharToRight,  -- are only right to left      = XCharSets.Sets.arabic.ORD =>	IF code < specialCode THEN nextCharToRight ELSE nextCharToLeft,	  -- Arabic Arabic numerals are left-to-right!      ENDCASE => nextCharToLeft]};  -- Arabic & Hebrew characters  END.  -- of XStringImplA
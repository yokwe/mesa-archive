-- File: XStringCompareImpl.mesa - last edit:-- AOF                  8-Jan-87 18:09:28-- Revised by: Ching	       10-Apr-84 15:37:33-- Revised by: Seto.ES	       12-Jan-84 15:03:36-- Revised by: JGS	       17-Sep-84 15:45:18-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- This pack contains one public procedure, Compare, that compares two workstation strings and decides if they are equal or which one is lesser.  The characters in the strings can be any code of the 64K character set.-- Any character in the 64K set belongs to a class:  Latin, Greek, Cyrillic, Kana, Kanji, Arabic, Graphic, etc...-- Within its class, a character has a first order alphabetic order:--	a, b... z... aaDanish... aRingNorwegian... for Latin--	a, i, u... for Japanese--	alpha, beta, gamma... for Greek --	the binary code itself for Graphic--	etc...-- Characters of certain classes have a second order alphabetic order:--	acute, grave, cedilla accents or marks for Latin, Cyrillic, Greek...--	dakuon, han-dakuon... for Japanese-- Characters of certain classes have a third order alphabetic order:--	upper case and lower case for Latin, Cyrillic, Greek...--	hiragana and katakana for Japanese--	isolated, beginning, middle or ending forms for Arabic-- String comparison proceeds as follows:  fetch the next character from each string.  If a string runs out of characters and was equal this far to the other, it is declared lesser.  Convert the two characters to get their class, first, second and third orders.  The language-dependent procedures that convert the characters are also responsible for special character handling, such as:--   mapping digraphs (Spanish ch and ll, Danish aa...) into single characters--   mapping ligatures (German esszed, French oe and ae...) into two letters--   handling Japanese repeat characters...--Keep looking as long as the class and first orders are the same, remembering along the way of the first time the second and third order are different.DIRECTORY  Environment USING [Byte, wordsPerPage],  Inline USING [BITAND],  Space USING [ScratchMap],  XChar USING [Code, LowerCase, Make, not, Set],  XCharSets USING [Sets],  XCharSet0 USING [Codes0, Make],  XCharSet41 USING [Codes41],  XCharSet44 USING [Codes44],  XCharSet45 USING [Codes45],  XCharSet46 USING [Codes46, Make],  XCharSet47 USING [Codes47, Make],  XString USING [Character, Lop, Reader, ReaderBody, Relation, SortOrder],  XStringExtra USING [],  XStringX USING [];XStringCompareImpl: MONITOR  IMPORTS    Inline, Space, XChar, XCharSet0, XCharSet46, XCharSet47, XString   EXPORTS XChar, XString, XStringExtra, XStringX =  BEGIN OPEN XString;  --  =========================================  --  TYPES AND VARIABLES  --  =========================================  Class: TYPE = MACHINE DEPENDENT{    Latin,  -- Latin letters, digits, punctuation symbols in chset 0 and 40    Greek,  -- Greek letters    Cyrillic,  -- Russian and other Cyrillic letters    Kana,  -- Hiragana and Katakana    Kanji, Graphics};  Alphabet: TYPE = MACHINE DEPENDENT    -- combination of all Latin-based alphabets    -- letters, digits and punctuations come in the following order    -- (first approximation sort)    {    unused, tab, lineFeed, formFeed, newLine, esc, region,     space, exclamationPoint, neutralDoubleQuote, numberSign, currency,    percentSign, ampersand, apostrophe, openParenthesis, closeParenthesis,    asterisk, plus, comma, minus, period, slash,    zero, one, two, three, four, five, six, seven, eight, nine,    colon, semicolon, lessThan, equals, greaterThan, questionMark,    commercialAt,    a, b, c, ch,  --Spanish     d, e, f, g, h, i, j, k, l, ll,  --Spanish     m, n, nTilde,  --Spanish     o, p, q, r, s, t, u, v, w, x, y, z, aRing, aDieresis, oDieresis,  --Swedish     ae, oSlash, aa, aRingNorwegian,  --Norwegian & Danish     accents, openBracket, backSlash, closeBracket, circumflex, lowBar,    grave, openBrace, verticalBar, closeBrace, tilde,    invertedExclamation, cent, poundSterlingSign, dollar, yen,    section, leftSingleQuote, leftDoubleQuote, leftDoubleGuillemet,    leftArrow, upArrow, rightArrow, downArrow, degree, plusOrMinus,    superscript2, superscript3, multiply, micro, paragraph, centeredDot, divide,    rightSingleQuote, rightDoubleQuote, rightDoubleGuillemet, oneQuarter,     oneHalf, threeQuarters, invertedQuestionMark, horizontalBar, superscript1,    registered, copyright, trademark, musicNote, oneEighth, threeEighths,     fiveEighths, sevenEighths, ohmSign, (255)};  Mark: TYPE = MACHINE DEPENDENT    -- accents come in the following order (second approximation sort)    {    noAccent, acute, grave, circumflex, dieresis, tilde, macron, breve, overDot,    centerDot, noDot, overRing, doubleAcute, ogonek, hacek, midBar, midSlant, cedilla,    (31)};  Form: TYPE = MACHINE DEPENDENT{lower(0), upper(1)};  Treatment: TYPE = MACHINE DEPENDENT{  -- to handle special case letters    singlet(0),  -- ordinary letter (a, b, aRing...), digit (0..9) or mark (? ! @ # ...)    ligature(1),  -- one letter treated as two (German esstzed, French OE...)    digraph(2),  -- two letters treated as one (Spanish CH or LL, Danish AA...)    symbol(3)};  -- anything not Latin, Greek, Japanese, Cyrillic, Chinese...  LatinEncoding: TYPE = RECORD [    second: Mark,  -- second approximation order    third: Form,  -- third approximation order    variant: SELECT treatment: Treatment FROM      singlet => [first: Alphabet],  -- singlet first approx order.      digraph => [        nextInDoublet: XCharSet0.Codes0,  -- if next letter equals this one        firstForDoublet: Alphabet,  -- then use this first order        firstForSinglet: Alphabet],  -- else use this first order      ligature => [leftLetter: XCharSet0.Codes0, rightLetter: XCharSet0.Codes0],      ENDCASE];  TranslateTable: TYPE = LONG POINTER TO AqTranslateTable;  AqTranslateTable: TYPE = ARRAY Environment.Byte OF LatinEncoding;  TextHandle: TYPE = LONG POINTER TO AqTextHandle;  AqTextHandle: TYPE = MACHINE DEPENDENT RECORD [    prevChar(0): Character _ XChar.not,    currChar(1): Character _ XChar.not,    nextChar(2): Character _ XChar.not,    classOrder(3): Class _ NULL,    firstOrder(4): CARDINAL _ NULL,    secondOrder(5): CARDINAL _ NULL,    thirdOrder(6): CARDINAL _ NULL,    endsInAccent(7): BOOLEAN _ FALSE];  RomanChange: TYPE = RECORD [  -- to update Roman translation table    entry: XCharSet0.Codes0,  -- index into translation table    encoding: LatinEncoding];  RenderingChange: TYPE = RECORD [  -- to update rendering translation table    entry: Codes361,  -- index into translation table    encoding: LatinEncoding];  -- Global frame items  currentSortOrder: SortOrder _ standard;  RomanTable: TranslateTable _ NIL;  renderingTable: TranslateTable _ NIL;  selectCode: Environment.Byte = 377B;  --  =========================================  --  TYPES AND VARIABLES USED BY ConvertKana  --  =========================================  HiraganaCodes: TYPE = XCharSet44.Codes44;  KatakanaCodes: TYPE = XCharSet45.Codes45;  KatakanaSortCodesTable: TYPE = PACKED ARRAY KatakanaCodes    [katSmallA..katSmallKe] OF Environment.Byte;  HiraganaSortCodesTable: TYPE = PACKED ARRAY HiraganaCodes [hirSmallA..hirN] OF    Environment.Byte;  katakanaSortCodes: LONG POINTER TO KatakanaSortCodesTable _ @katakanaSortCodesTable;  hiraganaSortCodes: LONG POINTER TO HiraganaSortCodesTable _    LOOPHOLE[katakanaSortCodes];  katakanaSortCodesTable: KatakanaSortCodesTable _ [    0B, 1B, 4B, 5B, 10B, 11B, 14B, 15B, 20B, 21B, 25B, 26B, 31B, 32B, 35B, 36B,    41B, 42B, 45B, 46B, 51B, 52B, 55B, 56B, 61B, 62B, 65B, 66B, 71B, 72B, 75B,    76B, 101B, 102B, 104B, 105B, 106B, 111B, 112B, 115B, 116B, 121B, 125B, 131B,    135B, 141B, 145B, 146B, 147B, 151B, 152B, 153B, 155B, 156B, 157B, 161B, 162B,    163B, 165B, 166B, 167B, 171B, 175B, 201B, 205B, 211B, 214B, 215B, 224B, 225B,    234B, 235B, 241B, 245B, 251B, 255B, 261B, 264B, 265B, 271B, 301B, 305B, 311B,    12B, 24B, 40B];  nullSortCode: Environment.Byte = 376B;  jkanaMarkMask: CARDINAL = 3B;  -- used for kana mark stripping  jkanaMarkMaskComplement: CARDINAL = 177774B;  -- used for kana mark stripping  --    JkanaMark: TYPE =  {yousokuon, normal, dakuon, handakuon};  --    JkanaType: TYPE =  {hiragana, katakana};       --  =========================================  --  INLINE PROCEDURES  --  INLINE procedures should be defined before they are used for compiler efficiency.  --  =========================================   InlineUpperCase: PROCEDURE [c: Character] RETURNS [Character] = INLINE    BEGIN    set: Environment.Byte _ XChar.Set[c];    RETURN[      SELECT LOOPHOLE[set, XCharSets.Sets] FROM        latin => XCharSet0.Make[VAL[UpperCaseLatin[VAL[XChar.Code[c]]]]],        greek => XCharSet46.Make[VAL[UpperCaseGreek[VAL[XChar.Code[c]]]]],        cyrillic => XCharSet47.Make[VAL[UpperCaseCyrillic[VAL[XChar.Code[c]]]]],        ENDCASE => c];    END;  -- of InlineUpperCase  --  =========================================    QuickLop: PROCEDURE [r: POINTER TO ReaderBody] RETURNS [Character] = INLINE    BEGIN    SELECT TRUE FROM      (r.offset = r.limit) => RETURN[XChar.not];      (r.context.suffixSize) = 2 => RETURN[Lop[r]];      ENDCASE =>        BEGIN        byte: Environment.Byte _ r.bytes[r.offset];        IF byte = selectCode THEN RETURN[Lop[r]];        r.offset _ r.offset +1;        RETURN[XChar.Make[set: r.context.prefix, code: byte]];        END;    END;  -- of QuickLop  --  =========================================  Set: PROCEDURE [c: Character] RETURNS [XCharSets.Sets] = INLINE {    RETURN[VAL[XChar.Set[c]]]};  -- of Set   --  =========================================  StripMark: PROC [c: UNSPECIFIED] RETURNS [UNSPECIFIED] = INLINE {    RETURN[Inline.BITAND[c, jkanaMarkMaskComplement]]};  --  =========================================         UpperCaseLatin: PROCEDURE [c: XCharSet0.Codes0] RETURNS [Environment.Byte] = INLINE    BEGIN    code: Environment.Byte _ c.ORD;    RETURN[      SELECT c FROM        IN [lowerA .. lowerZ] => code - 40B,	lowerAEdigraph, lowerDstroke, lowerHstroke, 	  IN [lowerIJdiagraph .. lowerOEdiagraph],	  IN [lowerThorn .. lowerEng] => code - 20B,	ENDCASE => code];    END;  -- of UpperCaseLatin        --  =========================================  --  PUBLIC PROCEDURES  --  =========================================        Compare: PUBLIC PROCEDURE [    r1, r2: Reader, ignoreCase: BOOLEAN _ TRUE, sortOrder: SortOrder _ standard]    RETURNS [Relation] = {    RETURN[CompareStringsAndStems[r1, r2, ignoreCase, sortOrder].relation]};  --  =========================================    CompareStringsAndStems: PUBLIC ENTRY PROCEDURE [    r1, r2: Reader, ignoreCase: BOOLEAN _ TRUE, sortOrder: SortOrder _ standard]    RETURNS [relation: Relation, equalStems: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    rb1, rb2: ReaderBody;    aqhandle1, aqhandle2: AqTextHandle;    handle1, handle2: TextHandle;    currentRel, secondRel, thirdRel: Relation _ equal;    IF r1 = NIL THEN RETURN[IF r2 = NIL THEN equal ELSE less, TRUE];    IF r2 = NIL THEN RETURN[greater, TRUE];    -- Avoid changing the original readers, and avoid problems if r1 = r2    rb1 _ r1^;    rb2 _ r2^;    aqhandle1 _ [currChar: Lop[@rb1]];    aqhandle2 _ [currChar: Lop[@rb2]];    handle1 _ @aqhandle1;    handle2 _ @aqhandle2;    -- Make language-dependent changes to translation tables.    -- The Japanese tables and the Latin tables (applicable to most Western languages)     -- are set up when the program is started, at which point the "current language"     -- is set to USEnglish.  If the language does not change between calls, the tables     -- do not need to be changed.  If the language changes but has the same rules as     -- the prior language, again the tables do not need to be changed.  But if the new    -- language has different rules from the old one, the tables must be updated.    SELECT sortOrder FROM      swedish, spanish => NULL;      ENDCASE => sortOrder _ standard;    IF sortOrder # currentSortOrder THEN      BEGIN      IF (sortOrder = standard) OR (currentSortOrder # standard) THEN        SetupLatin[];      SELECT sortOrder FROM        swedish => InitializeSwedishOrder[];        spanish => InitializeSpanishOrder[];        ENDCASE;  -- other languages do not need special initialization      currentSortOrder _ sortOrder;      END;    WHILE (handle1.currChar # XChar.not) AND (handle2.currChar # XChar.not) DO      -- got a char from each string      Convert[handle1, @rb1, ignoreCase];  -- find class and orders of char 1      Convert[handle2, @rb2, ignoreCase];  -- find class and orders of char 2      SELECT handle1.classOrder FROM        = handle2.classOrder =>  -- most frequent case, chars of same class          BEGIN          SELECT handle1.firstOrder FROM            < handle2.firstOrder => {	      relation _ less; GOTO checkForEndInAccent};            > handle2.firstOrder => {	      relation _ greater; GOTO checkForEndInAccent};            ENDCASE =>              BEGIN              IF secondRel = equal THEN                secondRel _                  SELECT handle1.secondOrder FROM                    < handle2.secondOrder => less,                    > handle2.secondOrder => greater,                    ENDCASE => equal;              IF thirdRel = equal THEN                thirdRel _                  SELECT handle1.thirdOrder FROM                    < handle2.thirdOrder => less,                    > handle2.thirdOrder => greater,                    ENDCASE => equal;              END;          END;        < handle2.classOrder => RETURN[less, FALSE];        ENDCASE => RETURN[greater, FALSE];      handle1.prevChar _ handle1.currChar;      handle2.prevChar _ handle2.currChar;      handle1.currChar _ NextChar[handle1, @rb1];  -- get next char from string 1      handle2.currChar _ NextChar[handle2, @rb2];  -- get next char from string 2      REPEAT        checkForEndInAccent => {	  c: XString.Character;	  IF ~handle1.endsInAccent AND ~handle2.endsInAccent THEN	    RETURN[relation, FALSE];	  IF (c _ handle1.prevChar) = handle2.prevChar	    AND XChar.Set[c] = XCharSets.Sets.latin.ORD AND	    VAL[XChar.Code[c]] IN	      [XCharSet0.Codes0.graveAccent..XCharSet0.Codes0.hachekAccent] THEN	    RETURN[relation, TRUE]	  ELSE RETURN[relation, FALSE]};      ENDLOOP;    currentRel _      SELECT TRUE FROM        secondRel # equal => secondRel,        ENDCASE => thirdRel;    equalStems _ currentRel = equal;    relation _      SELECT TRUE FROM        handle1.currChar = XChar.not AND handle2.currChar = XChar.not =>	   currentRel, -- both strings ended at same time        handle1.currChar = XChar.not => less,  -- string 1 ended before string 2        ENDCASE => greater;  -- string 2 ended before string 1    END;  -- of CompareStringsAndStems  --  =========================================    Decase: PUBLIC PROCEDURE [c: Character] RETURNS [Character] = UpperCase;  --  =========================================      Equivalent: PUBLIC PROCEDURE [r1, r2: XString.Reader] RETURNS [BOOLEAN] =     BEGIN    c1, c2: Character;    rb1, rb2: ReaderBody;    IF r1 = NIL THEN RETURN[r2 = NIL];    IF r2 = NIL THEN RETURN[FALSE];    rb1 _ r1^;    rb2 _ r2^;    DO      c2 _ QuickLop[@rb2];      IF (c1 _ QuickLop[@rb1]) = XChar.not THEN        RETURN[c2 = XChar.not];      IF c2 = XChar.not THEN RETURN[FALSE];      IF c1 # c2 AND InlineUpperCase[c1] # InlineUpperCase[c2] THEN        RETURN[FALSE];      ENDLOOP;    END; -- of Equivalent  --  =========================================    LowerCase: PUBLIC PROCEDURE [c: Character] RETURNS [Character] =     BEGIN    set: Environment.Byte _ XChar.Set[c];    RETURN[      SELECT LOOPHOLE[set, XCharSets.Sets] FROM        latin => XCharSet0.Make[VAL[LowerCaseLatin[VAL[XChar.Code[c]]]]],        greek => XCharSet46.Make[VAL[LowerCaseGreek[VAL[XChar.Code[c]]]]],        cyrillic => XCharSet47.Make[VAL[LowerCaseCyrillic[VAL[XChar.Code[c]]]]],        ENDCASE => c];    END;  -- of LowerCase  --  =========================================  UpperCase: PUBLIC PROCEDURE [c: Character] RETURNS [Character] = {    RETURN[InlineUpperCase[c]]};      --  =========================================  --  PRIVATE PROCEDURES  --  =========================================  Convert: PROC [h: TextHandle, r: Reader, ignoreCase: BOOLEAN] =    BEGIN    SELECT Set[h.currChar] FROM      latin => ConvertLatin[h, r, ignoreCase];      jisSymbol1 => {        code: XCharSet41.Codes41 = VAL[XChar.Code[h.currChar]];        SELECT code FROM          longVowelBar, IN [repeatHiragana..repeatKatakanaWithDakuon] =>            ConvertKana[h];          ENDCASE => ConvertOthers[h]};      katakana, hiragana => ConvertKana[h];      IN [firstUserKanji1..lastUserKanji1], IN        [firstLevel1Kanji..lastLevel1Kanji], IN        [firstLevel2Kanji..lastLevel2Kanji], IN [firstUserKanji2..lastUserKanji2]        => ConvertKanji[h];      cyrillic => ConvertCyrillic[h, ignoreCase];      greek => ConvertGreek[h, ignoreCase];      VAL[361B] => Convert361[h, r, ignoreCase];      ENDCASE => ConvertOthers[h];    END;  -- of Convert  --  =========================================  ConvertCyrillic: PROC [h: TextHandle, ignoreCase: BOOLEAN] =    BEGIN    c: XCharSet47.Codes47 = VAL[XChar.Code[h.currChar]];    h.classOrder _ Cyrillic;    SELECT c FROM      IN [upperA..upperYa] => {        h.firstOrder _ LOOPHOLE[LowerCaseCyrillic[c], CARDINAL];        h.thirdOrder _ Form.upper.ORD};      IN [lowerA..lowerYa] => {        h.firstOrder _ c.ORD; h.thirdOrder _ Form.lower.ORD};      ENDCASE => NULL;    h.secondOrder _ 0;    IF c = upperYo OR c = lowerYo THEN {      h.secondOrder _ 1; h.firstOrder _ XCharSet47.Codes47.lowerYe.ORD; };    IF ignoreCase THEN h.thirdOrder _ Form.lower.ORD;        END;  -- of ConvertCyrillic  --  =========================================  ConvertGreek: PROC [h: TextHandle, ignoreCase: BOOLEAN] =    BEGIN    c: XCharSet46.Codes46 = VAL[XChar.Code[h.currChar]];    h.classOrder _ Greek;    SELECT c FROM      IN [upperAlpha..upperOmega] => {        h.firstOrder _ LOOPHOLE[LowerCaseGreek[c], CARDINAL];        h.thirdOrder _ Form.upper.ORD};      IN [lowerAlpha..lowerOmega] => {        h.firstOrder _ c.ORD; h.thirdOrder _ Form.lower.ORD};      ENDCASE => NULL;    h.secondOrder _ 0;    IF ignoreCase THEN h.thirdOrder _ Form.lower.ORD;    END;  -- of ConvertGreek  --  =========================================  ConvertKana: PROC [h: TextHandle] =    BEGIN OPEN Environment;    kurikaeshi: Byte = 314B;  -- StripMark[SortCode[hiragana, repeatHiragana]];    longVowel: Byte = 320B;  -- StripMark[SortCode[jisSymbol1, longVowelBar]];    -- longVowelCode: Byte = 323B;	- - SortCode[jisSymbol1, longVowelBar];    c: Byte;    h.classOrder _ Kana;    h.thirdOrder _      SELECT Set[h.currChar] FROM        hiragana => 0,        katakana => 1,        jisSymbol1 =>          SELECT LOOPHOLE[XChar.Code[h.currChar], XCharSet41.Codes41] FROM            longVowelBar => 1,            repeatHiragana, repeatHiraganaWithDakuon => 0,            repeatKatakana, repeatKatakanaWithDakuon => 1,            ENDCASE => 0,        ENDCASE => 0;    c _ SortCode[h.currChar];    h.secondOrder _ Inline.BITAND[jkanaMarkMask, c];    c _ StripMark[c];    h.firstOrder _ LOOPHOLE[c, CARDINAL];    IF (c = kurikaeshi) OR (c = longVowel) THEN      BEGIN      SELECT Set[h.prevChar] FROM        katakana, hiragana =>          BEGIN          cs: Byte _ StripMark[SortCode[h.prevChar]];          SELECT c FROM            kurikaeshi => h.firstOrder _ LOOPHOLE[cs, CARDINAL];            longVowel => {              h.firstOrder _ LOOPHOLE[cs MOD 20, CARDINAL];              h.thirdOrder _ IF Set[h.prevChar] = katakana THEN 1 ELSE 0};            ENDCASE;          END;        ENDCASE;      END;    END;  -- of ConvertKana  --  =========================================  ConvertKanji: PROCEDURE [h: TextHandle] =    BEGIN    h.classOrder _ Kanji;    h.firstOrder _ h.currChar;    h.secondOrder _ 0;    h.thirdOrder _ 0;    END;  -- of ConvertKanji  --  =========================================  ConvertLatin: PROCEDURE [h: TextHandle, r: Reader, ignoreCase: BOOLEAN] =    BEGIN    encoding, singletEncoding: LatinEncoding;    encoding _ RomanTable[XChar.Code[h.currChar]];    h.classOrder _ Latin;    h.secondOrder _ encoding.second.ORD;    h.thirdOrder _ encoding.third.ORD;    WITH enc: encoding SELECT FROM      = singlet =>  -- most frequent case        BEGIN        h.firstOrder _ enc.first.ORD;        SELECT enc.second FROM          noAccent, centerDot, noDot, midBar, midSlant => NULL;          tilde => { -- Ntilde in spanish sorts differently            h.prevChar _ h.currChar; h.currChar _ Lop[r];            IF h.currChar # XChar.not THEN              BEGIN	      encoding _ RomanTable[XChar.Code[h.currChar]];              h.thirdOrder _ encoding.third.ORD;              IF currentSortOrder = spanish AND enc.first = n THEN {	        h.secondOrder _ Mark.noAccent.ORD;		h.firstOrder _ Alphabet.nTilde.ORD}	      ELSE h.firstOrder _ enc.first.ORD; -- note this gets encoding.first	      END	    ELSE {h.endsInAccent _ TRUE; h.firstOrder _ Alphabet.unused.ORD}};          overRing => { -- Aring in swedish sorts differently            h.prevChar _ h.currChar; h.currChar _ Lop[r];            IF h.currChar # XChar.not THEN              BEGIN	      encoding _ RomanTable[XChar.Code[h.currChar]];              h.thirdOrder _ encoding.third.ORD;              IF currentSortOrder = swedish AND enc.first = a THEN {		h.secondOrder _ Mark.noAccent.ORD;	        h.firstOrder _ Alphabet.aRing.ORD}	      ELSE h.firstOrder _ enc.first.ORD; -- note this gets encoding.first	      END	    ELSE {h.endsInAccent _ TRUE; h.firstOrder _ Alphabet.unused.ORD}};          dieresis => { -- aDieresis and oDieresis in swedish sort differently            h.prevChar _ h.currChar; h.currChar _ Lop[r];            IF h.currChar # XChar.not THEN              BEGIN	      encoding _ RomanTable[XChar.Code[h.currChar]];              h.thirdOrder _ encoding.third.ORD;              IF currentSortOrder = swedish THEN {	        SELECT enc.first FROM		  a => {		    h.secondOrder _ Mark.noAccent.ORD;	            h.firstOrder _ Alphabet.aDieresis.ORD};		  o => {		    h.secondOrder _ Mark.noAccent.ORD;	            h.firstOrder _ Alphabet.oDieresis.ORD};		  ENDCASE => h.firstOrder _ enc.first.ORD}	      ELSE h.firstOrder _ enc.first.ORD;  	      END	    ELSE {h.endsInAccent _ TRUE; h.firstOrder _ Alphabet.unused.ORD}};          ENDCASE =>  -- all other accents            BEGIN  -- find out what character is accented            h.prevChar _ h.currChar; h.currChar _ Lop[r];            IF h.currChar # XChar.not THEN              BEGIN	      encoding _ RomanTable[XChar.Code[h.currChar]];              h.thirdOrder _ encoding.third.ORD;              h.firstOrder _ enc.first.ORD; -- note this gets encoding.first              END	    ELSE {h.endsInAccent _ TRUE; h.firstOrder _ Alphabet.unused.ORD};            END        END;      = digraph =>        BEGIN        h.nextChar _ NextChar[h, r];        IF h.nextChar # XChar.not THEN          BEGIN          -- check if we have a real digraph or simply a letter that begins like a digraph          IF XChar.LowerCase[XChar.Code[h.nextChar]] = LOOPHOLE[enc.nextInDoublet,            Environment.Byte] THEN            BEGIN  -- we have a real digraph            h.firstOrder _ enc.firstForDoublet.ORD;            h.nextChar _ XChar.not;  -- to drop that second letter next time around            END          ELSE            BEGIN  -- we don't have a digraph            h.firstOrder _ enc.firstForSinglet.ORD;            END;          END        ELSE BEGIN h.firstOrder _ enc.firstForSinglet.ORD; END;        END;      = ligature =>        BEGIN        latin: Environment.Byte = XCharSets.Sets.latin.ORD;        -- replace ligature with two equivalent letters        h.currChar _ XChar.Make[latin, enc.leftLetter.ORD];        h.nextChar _ XChar.Make[latin, enc.rightLetter.ORD];        singletEncoding _ RomanTable[XChar.Code[h.currChar]];  -- update translation for first letter        WITH newEnc: singletEncoding SELECT FROM          = singlet => h.firstOrder _ newEnc.first.ORD;          ENDCASE;        END;      ENDCASE;    IF ignoreCase THEN h.thirdOrder _ Form.lower.ORD;    END;  -- of ConvertLatin  Convert361: PROCEDURE [h: TextHandle, r: Reader, ignoreCase: BOOLEAN] =    BEGIN    encoding: LatinEncoding = renderingTable[XChar.Code[h.currChar]];    h.classOrder _ Latin;    h.secondOrder _ encoding.second.ORD;    h.thirdOrder _ IF ignoreCase THEN Form.lower.ORD ELSE encoding.third.ORD;    WITH enc: encoding SELECT FROM      singlet => h.firstOrder _ enc.first.ORD;      ENDCASE;    END;  -- of Convert361  --  =========================================  ConvertOthers: PROCEDURE [h: TextHandle] =    BEGIN    h.classOrder _ Graphics;    h.firstOrder _ LOOPHOLE[h.currChar, CARDINAL];    h.secondOrder _ 0;    h.thirdOrder _ 0;    END;  -- of ConvertOthers  --  =========================================  InitializeLatinOrder: PROC =    BEGIN    wpp: CARDINAL = Environment.wordsPerPage;    spPages: CARDINAL = (2 * AqTranslateTable.SIZE + wpp - 1)/wpp;    RomanTable _ Space.ScratchMap[count: spPages];    renderingTable _ RomanTable + AqTranslateTable.SIZE;    SetupLatin[];    END;  -- of InitializeLatinOrder  --  =========================================  InitializeSpanishOrder: PROC =    BEGIN    ns1: TYPE = [0..4);  -- number of Roman translation changes for Spanish    ns2: TYPE = [0..2);  -- number of Rendering translation changes for Spanish        S1changes: ARRAY ns1 OF RomanChange = [      [lowerC, [noAccent, lower, digraph[lowerH, ch, c]]], [      upperC, [noAccent, upper, digraph[lowerH, ch, c]]], [      lowerL, [noAccent, lower, digraph[lowerL, ll, l]]], [      upperL, [noAccent, upper, digraph[lowerL, ll, l]]]];    S2changes: ARRAY ns2 OF RenderingChange = [     [lowerNtilde, [noAccent, lower, singlet [nTilde]] ],     [upperNtilde, [noAccent, upper, singlet [nTilde]] ] ];       FOR k: CARDINAL IN ns1 DO      RomanTable[S1changes[k].entry.ORD] _ S1changes[k].encoding; ENDLOOP;    FOR k: CARDINAL IN ns2 DO      renderingTable[S2changes[k].entry.ORD] _ S2changes[k].encoding; ENDLOOP;    END;  -- of InitializeSpanishOrder  --  =========================================  InitializeSwedishOrder: PROC =    BEGIN    ns1: TYPE = [0..4);  -- number of Roman translation changes for Swedish    ns2: TYPE = [0..6);  -- number of Rendering translation changes for Swedish    S1changes: ARRAY ns1 OF RomanChange = [      [lowerAEdigraph, [noAccent, lower, singlet[aDieresis]]],  -- misspellings in CharADefs!      [upperAEdigraph, [noAccent, upper, singlet[aDieresis]]], [      lowerOslash, [noAccent, lower, singlet[oDieresis]]], [      upperOslash, [noAccent, upper, singlet[oDieresis]]]];    S2changes: ARRAY ns2 OF RenderingChange = [     [lowerAring,   [noAccent, lower, singlet [aRing]] ],     [upperAring,   [noAccent, upper, singlet [aRing]] ],     [lowerAumlaut, [noAccent, lower, singlet [aDieresis]] ],     [upperAumlaut, [noAccent, upper, singlet [aDieresis]] ],     [lowerOumlaut, [noAccent, lower, singlet [oDieresis]] ],     [upperOumlaut, [noAccent, upper, singlet [oDieresis]] ] ];       FOR k: CARDINAL IN ns1 DO      RomanTable[S1changes[k].entry.ORD] _ S1changes[k].encoding; ENDLOOP;    FOR k: CARDINAL IN ns2 DO      renderingTable[S2changes[k].entry.ORD] _ S2changes[k].encoding; ENDLOOP;    END;  -- of InitializeSwedishOrder  --  =========================================  LowerCaseCyrillic: PROCEDURE [c: XCharSet47.Codes47]    RETURNS [Environment.Byte] =    BEGIN    code: Environment.Byte _ c.ORD;    IF c IN [upperA..upperYa] THEN RETURN[code + 60B] ELSE RETURN[code];    END;  -- of LowerCaseCyrillic   --  =============================================  LowerCaseGreek: PROCEDURE [c: XCharSet46.Codes46]    RETURNS [Environment.Byte] =    BEGIN    code: Environment.Byte _ c.ORD;    IF c IN [upperAlpha..upperOmega] THEN RETURN[code + 40B] ELSE RETURN[code];    END;  -- of LowerCaseGreek   --  =============================================  LowerCaseLatin: PROCEDURE [c: XCharSet0.Codes0]    RETURNS [Environment.Byte] =    BEGIN    code: Environment.Byte _ c.ORD;    RETURN[      SELECT c FROM        IN [upperA .. upperZ] => code + 40B,	IN [upperAEdigraph .. upperDstroke], IN [upperHstroke .. upperOEdiagraph],	  IN [upperThorn .. upperEng] => code + 20B,	ENDCASE => code];    END;  -- of LowerCaseLatin  --  =============================================  NextChar: PROCEDURE [handle: TextHandle, r: Reader] RETURNS [Character] =    BEGIN    -- get the next available character (chset and code)    IF handle.nextChar # XChar.not THEN      BEGIN      temp: Character _ handle.nextChar;      handle.nextChar _ XChar.not;      RETURN[temp];      END    ELSE RETURN[Lop[r]];    END;  -- of NextChar  --  =========================================  SetupLatin: PROC =    BEGIN    empty: LatinEncoding = [noAccent, lower, singlet[unused]];    currentSortOrder _ standard;    RomanTable^ _ [      empty, empty, empty, empty, empty, empty, empty, empty,  -- 0B to 7B      empty, [noAccent, lower, singlet[tab]], [      noAccent, lower, singlet[lineFeed]], empty, [      noAccent, lower, singlet[formFeed]], [      noAccent, lower, singlet[newLine]], empty, empty,  -- 10B to 17B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 20B to 27B      empty, empty, empty, [noAccent, lower, singlet[esc]], empty, empty,      empty, empty,  -- 30B to 37B      [noAccent, lower, singlet[space]], [      noAccent, lower, singlet[exclamationPoint]], [      noAccent, lower, singlet[neutralDoubleQuote]], [      noAccent, lower, singlet[numberSign]], [      noAccent, lower, singlet[currency]], [      noAccent, lower, singlet[percentSign]], [      noAccent, lower, singlet[ampersand]], [      noAccent, lower, singlet[apostrophe]],  -- 40B to 47B      [noAccent, lower, singlet[openParenthesis]], [      noAccent, lower, singlet[closeParenthesis]], [      noAccent, lower, singlet[asterisk]], [noAccent, lower, singlet[plus]], [      noAccent, lower, singlet[comma]], [noAccent, lower, singlet[minus]], [      noAccent, lower, singlet[period]], [      noAccent, lower, singlet[slash]],  -- 50B to 57B      [noAccent, lower, singlet[zero]], [noAccent, lower, singlet[one]], [      noAccent, lower, singlet[two]], [noAccent, lower, singlet[three]], [      noAccent, lower, singlet[four]], [noAccent, lower, singlet[five]], [      noAccent, lower, singlet[six]], [noAccent, lower, singlet[seven]], [      noAccent, lower, singlet[eight]], [      noAccent, lower, singlet[nine]],  -- 60B to 71B      [noAccent, lower, singlet[colon]], [noAccent, lower, singlet[semicolon]], [      noAccent, lower, singlet[lessThan]], [      noAccent, lower, singlet[equals]], [      noAccent, lower, singlet[greaterThan]], [      noAccent, lower, singlet[questionMark]], [      noAccent, lower, singlet[commercialAt]],  -- 72B to 100B      [noAccent, upper, singlet[a]], [noAccent, upper, singlet[b]], [      noAccent, upper, singlet[c]], [noAccent, upper, singlet[d]], [      noAccent, upper, singlet[e]], [noAccent, upper, singlet[f]], [      noAccent, upper, singlet[g]], [noAccent, upper, singlet[h]], [      noAccent, upper, singlet[i]], [noAccent, upper, singlet[j]], [      noAccent, upper, singlet[k]], [noAccent, upper, singlet[l]], [      noAccent, upper, singlet[m]], [noAccent, upper, singlet[n]], [      noAccent, upper, singlet[o]], [noAccent, upper, singlet[p]], [      noAccent, upper, singlet[q]], [noAccent, upper, singlet[r]], [      noAccent, upper, singlet[s]], [noAccent, upper, singlet[t]], [      noAccent, upper, singlet[u]], [noAccent, upper, singlet[v]], [      noAccent, upper, singlet[w]], [noAccent, upper, singlet[x]], [      noAccent, upper, singlet[y]], [noAccent, upper, singlet[z]],      [noAccent, lower, singlet[openBracket]], [      noAccent, lower, singlet[backSlash]], [      noAccent, lower, singlet[closeBracket]], [      noAccent, lower, singlet[circumflex]], [noAccent, lower, singlet[lowBar]], [      noAccent, lower, singlet[grave]],  -- 133B to 140B      [noAccent, lower, singlet[a]], [noAccent, lower, singlet[b]], [      noAccent, lower, singlet[c]], [noAccent, lower, singlet[d]], [      noAccent, lower, singlet[e]], [noAccent, lower, singlet[f]], [      noAccent, lower, singlet[g]], [noAccent, lower, singlet[h]], [      noAccent, lower, singlet[i]], [noAccent, lower, singlet[j]], [      noAccent, lower, singlet[k]], [noAccent, lower, singlet[l]], [      noAccent, lower, singlet[m]], [noAccent, lower, singlet[n]], [      noAccent, lower, singlet[o]], [noAccent, lower, singlet[p]], [      noAccent, lower, singlet[q]], [noAccent, lower, singlet[r]], [      noAccent, lower, singlet[s]], [noAccent, lower, singlet[t]], [      noAccent, lower, singlet[u]], [noAccent, lower, singlet[v]], [      noAccent, lower, singlet[w]], [noAccent, lower, singlet[x]], [      noAccent, lower, singlet[y]], [noAccent, lower, singlet[z]],      [noAccent, lower, singlet[openBrace]], [      noAccent, lower, singlet[verticalBar]], [      noAccent, lower, singlet[closeBrace]], [      noAccent, lower, singlet[tilde]], empty,  -- 173B to 177B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 200B to 207B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 210B to 217B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 220B to 227B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 230B to 237B      empty, [noAccent, lower, singlet[invertedExclamation]], [      noAccent, lower, singlet[cent]], [      noAccent, lower, singlet[poundSterlingSign]], [      noAccent, lower, singlet[dollar]], [noAccent, lower, singlet[yen]],       empty, [noAccent, lower, singlet[section]],  -- 240B to 247B      empty, [noAccent, lower, singlet[leftSingleQuote]], [      noAccent, lower, singlet[leftDoubleQuote]], [      noAccent, lower, singlet[leftDoubleGuillemet]], [      noAccent, lower, singlet[leftArrow]], [      noAccent, lower, singlet[upArrow]], [      noAccent, lower, singlet[rightArrow]], [      noAccent, lower, singlet[downArrow]],  -- 250B to 257B      [noAccent, lower, singlet[degree]], [      noAccent, lower, singlet[plusOrMinus]], [      noAccent, lower, singlet[superscript2]], [      noAccent, lower, singlet[superscript3]], [noAccent, lower, singlet[multiply]],      [noAccent, lower, singlet[micro]], [noAccent, lower, singlet[paragraph]], [      noAccent, lower, singlet[centeredDot]],  -- 260B to 267B      [noAccent, lower, singlet[divide]], [      noAccent, lower, singlet[rightSingleQuote]], [      noAccent, lower, singlet[rightDoubleQuote]], [      noAccent, lower, singlet[rightDoubleGuillemet]], [      noAccent, lower, singlet[oneQuarter]], [noAccent, lower, singlet[oneHalf]],      [noAccent, lower, singlet[threeQuarters]], [      noAccent, lower, singlet[invertedQuestionMark]],  -- 270B to 277B      empty, [grave, lower, singlet[accents]], [acute, lower, singlet[accents]], [      circumflex, lower, singlet[accents]], [tilde, lower, singlet[accents]], [      macron, lower, singlet[accents]], [breve, lower, singlet[accents]], [      overDot, lower, singlet[accents]],  -- 300B to 307B      [dieresis, lower, singlet[accents]], empty, [overRing, lower, singlet[accents]],      [cedilla, lower, singlet[accents]], [noAccent, lower, singlet[space]], [      doubleAcute, lower, singlet[accents]], [ogonek, lower, singlet[accents]], [      hacek, lower, singlet[accents]],  -- 310B to 317B      [noAccent, lower, singlet[horizontalBar]], [      noAccent, lower, singlet[superscript1]], [      noAccent, lower, singlet[registered]], [      noAccent, lower, singlet[copyright]], [      noAccent, lower, singlet[trademark]], [      noAccent, lower, singlet[musicNote]], empty, empty,  -- 320B to 327B      empty, empty, empty, empty, [noAccent, lower, singlet[oneEighth]], [      noAccent, lower, singlet[threeEighths]], [      noAccent, lower, singlet[fiveEighths]], [      noAccent, lower, singlet[sevenEighths]],  -- 330B to 337B      [noAccent, lower, singlet[ohmSign]],  -- 340B  ohm      [noAccent, upper, ligature[lowerA, lowerE]],  -- 341B  French AE      [midSlant, upper, singlet[d]],  -- 342B  Serbian D      empty,  -- 343B  Spanish feminine ordinal      [midBar, upper, singlet[h]],  -- 344B  ? H      empty,  -- 245B      [noAccent, upper, ligature[lowerI, lowerJ]],  -- 346B  Dutch IJ      [centerDot, upper, singlet[l]],  -- 347B  ? L      [midSlant, upper, singlet[l]],  -- 350B  Polish L      [midSlant, upper, singlet[o]],  -- 351B  Norwegian O      [noAccent, upper, ligature[lowerO, lowerE]],  -- 352B  French OE      empty,  -- 353B  Spanish masculine ordinal      [noAccent, upper, singlet[b]],  -- 354B  Icelandic B      [noAccent, upper, singlet[t]],  -- 355B  ? T      [noAccent, upper, singlet[n]],  -- 356B  Lapp N      [noAccent, lower, singlet[n]],  -- 357B  Afrikaner 'n      [noAccent, lower, singlet[k]],  -- 360B  Greenlandese k      [noAccent, lower, ligature[lowerA, lowerE]],  -- 361B  French ae      [midSlant, lower, singlet[d]],  -- 362B  Serbian d      [midSlant, lower, singlet[d]],  -- 363B  Icelandic d      [midBar, lower, singlet[h]],  -- 364B  ? h      [noDot, lower, singlet[i]],  -- 365B  Turkish i      [noAccent, lower, ligature[lowerI, lowerJ]],  -- 366B  Dutch ij      [centerDot, lower, singlet[l]],  -- 367B  ? l      [midSlant, lower, singlet[l]],  -- 370B  Polish l      [midSlant, lower, singlet[o]],  -- 371B  Norwegian o      [noAccent, lower, ligature[lowerO, lowerE]],  -- 372B  French oe      [noAccent, lower, ligature[lowerS, lowerS]],  -- 373B  German esszed      [noAccent, lower, singlet[b]],  -- 374B  Icelandic b      [noAccent, upper, singlet[t]],  -- 375B  ? t      [noAccent, upper, singlet[n]],  -- 376B  Lapp n      empty];  -- 377B    renderingTable^ _ [      empty, empty, empty, empty, empty, empty, empty, empty,  -- 0B to 7B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 10B to 17B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 20B to 27B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 30B to 37B      empty,  -- 40B      [grave, upper, singlet [a]],      [acute, upper, singlet [a]],      [circumflex, upper, singlet [a]],      [tilde, upper, singlet [a]],      [macron, upper, singlet [a]],      [breve, upper, singlet [a]],      [dieresis, upper, singlet [a]],      [overRing, upper, singlet [a]],      [ogonek, upper, singlet [a]],  -- 41B to 51B            [acute, upper, singlet [c]],      [circumflex, upper, singlet [c]],      [overDot, upper, singlet [c]],      [cedilla, upper, singlet [c]],      [hacek, upper, singlet [a]],  -- 52B to 56B            [hacek, upper, singlet [d]],  -- 57B            [grave, upper, singlet [e]],      [acute, upper, singlet [e]],      [circumflex, upper, singlet [e]],      [tilde, upper, singlet [e]],      [macron, upper, singlet [e]],      [overDot, upper, singlet [e]],      [dieresis, upper, singlet [e]],      [ogonek, upper, singlet [e]],      [hacek, upper, singlet [e]],  -- 60B to 67B            [circumflex, upper, singlet [g]],      [breve, upper, singlet [g]],      [overDot, upper, singlet [g]],      [cedilla, upper, singlet [g]],  -- 70B to 74B            [circumflex, upper, singlet [h]],  -- 75B            [grave, upper, singlet [i]],      [acute, upper, singlet [i]],      [circumflex, upper, singlet [i]],      [tilde, upper, singlet [i]],      [macron, upper, singlet [i]],      [overDot, upper, singlet [i]],      [dieresis, upper, singlet [i]],      [ogonek, upper, singlet [i]],  -- 76B to 105B            [circumflex, upper, singlet [j]],  -- 106B            [cedilla, upper, singlet [k]],  -- 107B            [acute, upper, singlet [l]],      [cedilla, upper, singlet [l]],      [hacek, upper, singlet [l]],  -- 110B to 112B            [acute, upper, singlet [n]],      [tilde, upper, singlet [n]],      [cedilla, upper, singlet [n]],      [hacek, upper, singlet [n]],  -- 113B to 116B            [grave, upper, singlet [o]],      [acute, upper, singlet [o]],      [circumflex, upper, singlet [o]],      [tilde, upper, singlet [o]],      [macron, upper, singlet [o]],      [dieresis, upper, singlet [o]],      [doubleAcute, upper, singlet [o]],  -- 117B to 125B            [acute, upper, singlet [r]],      [ogonek, upper, singlet [r]],      [hacek, upper, singlet [r]],  -- 126B to 130B            [acute, upper, singlet [s]],      [circumflex, upper, singlet [s]],      [cedilla, upper, singlet [s]],      [hacek, upper, singlet [s]],  -- 131B to 134B            [cedilla, upper, singlet [t]],      [hacek, upper, singlet [t]],  -- 135B to 136B            [grave, upper, singlet [u]],      [acute, upper, singlet [u]],      [circumflex, upper, singlet [u]],      [tilde, upper, singlet [u]],      [macron, upper, singlet [u]],      [breve, upper, singlet [u]],      [dieresis, upper, singlet [u]],      [overRing, upper, singlet [u]],      [doubleAcute, upper, singlet [u]],      [ogonek, upper, singlet [u]],  -- 137B to 150B            [circumflex, upper, singlet [w]],  -- 151B            [grave, upper, singlet [y]],      [acute, upper, singlet [y]],      [circumflex, upper, singlet [y]],      [dieresis, upper, singlet [y]],  -- 152B to 155B            [acute, upper, singlet [z]],      [overDot, upper, singlet [z]],      [hacek, upper, singlet [z]],  -- 156B to 160B            empty, empty, empty, empty, empty, empty, empty,  -- 161B to 167B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 170B to 177B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 200B to 207B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 210B to 217B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 220B to 227B      empty, empty, empty, empty, empty, empty, empty, empty,  -- 230B to 237B      empty,  -- 240B      [grave, lower, singlet [a]],      [acute, lower, singlet [a]],      [circumflex, lower, singlet [a]],      [tilde, lower, singlet [a]],      [macron, lower, singlet [a]],      [breve, lower, singlet [a]],      [dieresis, lower, singlet [a]],      [overRing, lower, singlet [a]],      [ogonek, lower, singlet [a]],  -- 241B to 251B            [acute, lower, singlet [c]],      [circumflex, lower, singlet [c]],      [overDot, lower, singlet [c]],      [cedilla, lower, singlet [c]],      [hacek, lower, singlet [a]],  -- 252B to 256B            [hacek, lower, singlet [d]],  -- 257B            [grave, lower, singlet [e]],      [acute, lower, singlet [e]],      [circumflex, lower, singlet [e]],      [tilde, lower, singlet [e]],      [macron, lower, singlet [e]],      [overDot, lower, singlet [e]],      [dieresis, lower, singlet [e]],      [ogonek, lower, singlet [e]],      [hacek, lower, singlet [e]],  -- 260B to 267B            [circumflex, lower, singlet [g]],      [breve, lower, singlet [g]],      [overDot, lower, singlet [g]],      [cedilla, lower, singlet [g]],  -- 270B to 274B            [circumflex, lower, singlet [h]],  -- 275B            [grave, lower, singlet [i]],      [acute, lower, singlet [i]],      [circumflex, lower, singlet [i]],      [tilde, lower, singlet [i]],      [macron, lower, singlet [i]],      [overDot, lower, singlet [i]],      [dieresis, lower, singlet [i]],      [ogonek, lower, singlet [i]],  -- 276B to 305B            [circumflex, lower, singlet [j]],  -- 306B            [cedilla, lower, singlet [k]],  -- 307B            [acute, lower, singlet [l]],      [cedilla, lower, singlet [l]],      [hacek, lower, singlet [l]],  -- 310B to 312B            [acute, lower, singlet [n]],      [tilde, lower, singlet [n]],      [cedilla, lower, singlet [n]],      [hacek, lower, singlet [n]],  -- 313B to 316B            [grave, lower, singlet [o]],      [acute, lower, singlet [o]],      [circumflex, lower, singlet [o]],      [tilde, lower, singlet [o]],      [macron, lower, singlet [o]],      [dieresis, lower, singlet [o]],      [doubleAcute, lower, singlet [o]],  -- 317B to 325B            [acute, lower, singlet [r]],      [ogonek, lower, singlet [r]],      [hacek, lower, singlet [r]],  -- 326B to 330B            [acute, lower, singlet [s]],      [circumflex, lower, singlet [s]],      [cedilla, lower, singlet [s]],      [hacek, lower, singlet [s]],  -- 331B to 334B            [cedilla, lower, singlet [t]],      [hacek, lower, singlet [t]],  -- 335B to 336B            [grave, lower, singlet [u]],      [acute, lower, singlet [u]],      [circumflex, lower, singlet [u]],      [tilde, lower, singlet [u]],      [macron, lower, singlet [u]],      [breve, lower, singlet [u]],      [dieresis, lower, singlet [u]],      [overRing, lower, singlet [u]],      [doubleAcute, lower, singlet [u]],      [ogonek, lower, singlet [u]],  -- 337B to 350B            [circumflex, lower, singlet [w]],  -- 351B            [grave, lower, singlet [y]],      [acute, lower, singlet [y]],      [circumflex, lower, singlet [y]],      [dieresis, lower, singlet [y]],  -- 352B to 355B            [acute, lower, singlet [z]],      [overDot, lower, singlet [z]],      [hacek, lower, singlet [z]],  -- 356B to 360B            empty, empty, empty, empty, empty, empty, empty,  -- 361B to 367B      empty, empty, empty, empty, empty, empty, empty,  -- 370B to 376B      empty];  -- 377B    END;  -- of SetupLatin  Codes361: TYPE = MACHINE DEPENDENT{  --Symbolic names for character set 361B    -- Accented Latin Characters        -- UPPER CASE --        upperAgrave(41B), upperAacute(42B),  upperAcircumflex(43B), upperAtilde(44B),    upperAmacron(45B), upperAbrev(46B), upperAumlaut(47B), upperAring(50B), upperAogonek(51B),        upperCacute(52B),  upperCcircumflex(53B), upperChighDot(54B),    upperCcedilla(55B), upperChachek(56B),     upperDhachek(57B),        upperEgrave(60B), upperEacute(61B),  upperEcircumflex(62B),     upperEmacron(63B), upperEhighDot(64B), upperEumlaut(65B), upperEogonek(66B), upperEhachek(67B),        upperGcircumflex(71B),  upperGbrev(72B), upperGhighDot(73B), upperGcedilla(74B),          upperHcircumflex(75B),        upperIgrave(76B), upperIacute(77B), upperIcircumflex(100B), upperItilde(101B), upperImacron(102B), upperIhighDot(103B), upperIumlaut(104B), upperIogonek(105B),        upperJcircumflex(106B),        upperKcedilla(107B),        upperLacute(110B), upperLcedilla(111B), upperLhachek(112B),        upperNacute(113B),  upperNtilde(114B), upperNcedilla(115B), upperNhachek(116B),         upperOgrave(117B), upperOacute(120B),  upperOcircumflex(121B), upperOtilde(122B),    upperOmacron(123B), upperOumlaut(124B), upperODoubleAcute(125B),         upperRacute(126B), upperRogonek(127B), upperRhachek(130B),        upperSacute(131B),  upperScircumflex(132B),   upperScedilla(133B), upperShachek(134B),         upperTcedilla(135B), upperThachek(136B),        upperUgrave(137B), upperUacute(140B),  upperUcircumflex(141B), upperUtilde(142B),    upperUmacron(143B), upperUbrev(144B), upperUumlaut(145B), upperUring(146B), upperUDoubleAcute(147B), upperUogonek(150B),        upperWcircumflex(151B),        upperYgrave(152B), upperYacute(153B),  upperYcircumflex(154B), upperYumlaut(155B),        upperZacute(156B), upperZhighDot(157B), upperZhachek(160B),        -- LOWER CASE--    lowerAgrave(241B), lowerAacute(242B),  lowerAcircumflex(243B), lowerAtilde(244B),    lowerAmacron(245B), lowerAbrev(246B), lowerAumlaut(247B), lowerAring(250B), lowerAogonek(251B),        lowerCacute(252B),  lowerCcircumflex(253B), lowerChighDot(254B),    lowerCcedilla(255B), lowerChachek(256B),     lowerDhachek(257B),        lowerEgrave(260B), lowerEacute(261B),  lowerEcircumflex(262B),     lowerEmacron(263B), lowerEhighDot(264B), lowerEumlaut(265B), lowerEogonek(266B), lowerEhachek(267B),        lowerGacute(270B), lowerGcircumflex(271B),  lowerGbrev(272B), lowerGhighDot(273B),           lowerHcircumflex(275B),        lowerIgrave(276B), lowerIacute(277B), lowerIcircumflex(300B), lowerItilde(301B), lowerImacron(302B), lowerIumlaut(304B), lowerIogonek(305B),        lowerJcircumflex(306B),        lowerKcedilla(307B),        lowerLacute(310B), lowerLcedilla(311B), lowerLhachek(312B),        lowerNacute(313B),  lowerNtilde(314B), lowerNcedilla(315B), lowerNhachek(316B),         lowerOgrave(317B), lowerOacute(320B),  lowerOcircumflex(321B), lowerOtilde(322B),    lowerOmacron(323B), lowerOumlaut(324B), lowerODoubleAcute(325B),         lowerRacute(326B), lowerRogonek(327B), lowerRhachek(330B),        lowerSacute(331B),  lowerScircumflex(332B),   lowerScedilla(333B), lowerShachek(334B),         lowerTcedilla(335B), lowerThachek(336B),        lowerUgrave(337B), lowerUacute(340B),  lowerUcircumflex(341B), lowerUtilde(342B),    lowerUmacron(343B), lowerUbrev(344B), lowerUumlaut(345B), lowerUring(346B), lowerUDoubleAcute(347B), lowerUogonek(350B),        lowerWcircumflex(351B),        lowerYgrave(352B), lowerYacute(353B),  lowerYcircumflex(354B), lowerYumlaut(355B),        lowerZacute(356B), lowerZhighDot(357B), lowerZhachek(360B)         };       --  =========================================  bpB: HiraganaCodes = VAL[161];  bpNG: HiraganaCodes = VAL[204];    SortCode: PROC [c: Character] RETURNS [CARDINAL] =    BEGIN    SELECT Set[c] FROM      hiragana => {        code: HiraganaCodes = VAL[XChar.Code[c]];        RETURN[          SELECT code FROM          IN [hirSmallA..hirN] => hiraganaSortCodes[code],          IN [bpB..bpNG] => 400B+code.ORD*4,-- after hiragana & no mark          ENDCASE => nullSortCode]};      katakana => {        code: KatakanaCodes = VAL[XChar.Code[c]];        RETURN[          IF code IN KatakanaCodes[katSmallA..katSmallKe] THEN katakanaSortCodes[code]	  ELSE nullSortCode]};      jisSymbol1 => {        code: XCharSet41.Codes41 = VAL[XChar.Code[c]];        RETURN[          SELECT code FROM            repeatHiragana => 315B,            repeatHiraganaWithDakuon => 316B,            repeatKatakana => 315B,            repeatKatakanaWithDakuon => 316B,            longVowelBar => 323B,            ENDCASE => nullSortCode]};      ENDCASE => RETURN[nullSortCode];    END;  -- of SortCode  --  =========================================  UpperCaseCyrillic: PROCEDURE [c: XCharSet47.Codes47]    RETURNS [Environment.Byte] =    BEGIN    code: Environment.Byte _ c.ORD;    IF c IN [lowerA..lowerYa] THEN RETURN[code - 60B] ELSE RETURN[code];    END;  -- of UpperCaseCyrillic   --  =========================================        UpperCaseGreek: PROCEDURE [c: XCharSet46.Codes46]    RETURNS [Environment.Byte] =    BEGIN    code: Environment.Byte _ c.ORD;    IF c IN [lowerAlpha..lowerOmega] THEN RETURN[code - 40B] ELSE RETURN[code];    END;  -- of UpperCaseGreek       --  =========================================  -- MAIN LINE CODE  InitializeLatinOrder[];  END.	-- of XStringCompareImplLOG  date - person - comment 9-Dec-83 - Ching - Created from OrderPack.mesa15-Mar-84 - Ching - Make XStringCompareImpl a MONITOR 6-Apr-84 - Ching - Change Latin tables to Xerox Character set in XCharSet0.  Move 	Equivalent, LowerCase, UpperCase, and Decase from XStringImplB.  Make those	procedures work for Greek, Cyrillic, and special Latin characters, too.10-Apr-84 - Ching - Add CompareStringsAndStems. 8-Jan-87 18:08:47 - AOF - LONG POINTERS for MDS Relief.      
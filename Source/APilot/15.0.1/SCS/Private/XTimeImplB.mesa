-- File: XTimeImplB.mesa, from DateImpl.mesa - last edit by-- Ching.pa	 3-Apr-84 11:26:35    -- JGS		29-Aug-84 15:24:05    DIRECTORY  Inline USING [LongNumber],  System USING [    GetLocalTimeParameters, gmtEpoch, GreenwichMeanTime, LocalTimeParameters,     LocalTimeParametersUnknown],  XChar USING [Character, Code, not, UpperCase],  XCharSet0 USING [Codes0],  XComSoftMessage USING [GetHandle, Keys],  XMessage USING [Get],  XString USING [    CharacterLength, Empty, Equal, Equivalent, First, FromSTRING, Lop, NthCharacter,     Overflow, Reader, ReaderBody, ReaderToNumber, Piece],  XTime USING [Notes, Unpack, Unpacked],  XTimeX USING [];XTimeImplB: PROGRAM   IMPORTS System, XChar, XComSoftMessage, XMessage, XString, XTime  EXPORTS XTime, XTimeX   SHARES XString =  BEGIN OPEN XS: XString;  Unintelligible: PUBLIC ERROR [vicinity: CARDINAL] = CODE;  InvalidTemplate: PUBLIC ERROR [vicinity: CARDINAL] = CODE;  BadZone: ERROR = CODE;  space: XChar.Character = ' .ORD;  comma: XChar.Character = ',.ORD;  plus: XChar.Character = '+.ORD;  minus: XChar.Character = '-.ORD;  tab: XChar.Character = XCharSet0.Codes0.tab.ORD;  tilde: XChar.Character = '~.ORD;    hoursPerDay: INTEGER = 24;  minutesPerHour: INTEGER = 60;  secondsPerMinute: INTEGER = 60;  secondsPerDay: LONG CARDINAL = LONG[hoursPerDay]*minutesPerHour*secondsPerMinute;  baseYear: CARDINAL = 1968;  baseDay: CARDINAL [0..7) = 1;  -- January 1, 1968 was a Monday (0 = Sunday)  epochDaysTemp: LONG CARDINAL = LAST[LONG CARDINAL]/secondsPerDay;  EpochDays: TYPE = INTEGER [0..LOOPHOLE[epochDaysTemp, Inline.LongNumber].lowbits];  YearDays: TYPE = INTEGER [0..366];  YearForm: TYPE = {twoDigits, fourDigits, unspecified};  <<   The following computation isn't exactly correct, since it doesn't     account for the absence of leap days in century years not divisible by     400.  As it happens, the actual values for baseYear and LAST[EpochDays]     are such that there is only one such day, and it doesn't affect the     arithmetic.		>>       Year: TYPE = [baseYear..baseYear + (LAST[EpochDays]/(4*365 + 1))*4];  Month: TYPE = [1..12];    Day: TYPE = [1..31];    Hour: TYPE = [0..hoursPerDay);  Minute: TYPE = [0..minutesPerHour);  Second: TYPE = [0..secondsPerMinute);  DeltaMinutes: TYPE = LONG INTEGER  --(-hoursPerDay*minutesPerHour..hoursPerDay*minutesPerHour)-- ;  ZoneIndex: TYPE = INTEGER [-12..12];  NAZones: TYPE = ZoneIndex [-11..-4];  maxReasonableTokens: CARDINAL = 30;  TokenCount: TYPE = CARDINAL [0..maxReasonableTokens];  TokenIndex: TYPE = CARDINAL [FIRST[TokenCount]..LAST[TokenCount]);  CharIndex: TYPE = CARDINAL [0..37777B]; -- this upper bound saves a word in Token  CharCount: TYPE = CARDINAL [0..37777B];  Tokens: TYPE = RECORD [    nTokens: TokenCount _ 0,    tokens: SEQUENCE length: TokenCount OF Token _ NULL];  Token: TYPE = RECORD [      offset: CharIndex,      kind: SELECT type: * FROM        alpha => [length: CharCount],        num => [length: CharCount],	field => [length: CharCount],        sep => [char: XChar.Character],        ENDCASE];  TokenArray: TYPE =ARRAY TokenCount OF Token;  ParseReader: PUBLIC PROCEDURE [r: XString.Reader, template: XString.Reader]    RETURNS [time: System.GreenwichMeanTime, notes: XTime.Notes, length: CARDINAL] =     BEGIN    RETURN ParseReaderImpl[r, template, FALSE]    END;      ParseReaderX: PUBLIC PROCEDURE [r: XString.Reader, dayBeforeMonth: BOOLEAN]    RETURNS [time: System.GreenwichMeanTime, notes: XTime.Notes, length: CARDINAL] =     BEGIN    RETURN ParseReaderImpl[r, NIL, dayBeforeMonth]    END;      ParseReaderImpl: PROCEDURE [    r: XString.Reader, template: XString.Reader _ NIL, dayBeforeMonth: BOOLEAN]    RETURNS [      time: System.GreenwichMeanTime, notes: XTime.Notes, length: CARDINAL] =     BEGIN    maxReasonableTokens: CARDINAL = 30;    nStringTokens: TokenCount _ 0;    nTemplateTokens: TokenCount _ 0;    stringTokens, templateTokens: TokenArray;    sentinel: XChar.Character = XChar.not;        Bogus: PROCEDURE [ti: TokenIndex] = {      ERROR Unintelligible[stringTokens[ti].offset]};            Tokenize: PROCEDURE [r: XString.Reader, parsingTemplate: BOOLEAN _ FALSE] =       BEGIN      state: {initial, num, alpha, field} _ initial;      i: CARDINAL _ 0;       tStart: CARDINAL;      nTokens: LONG POINTER TO TokenCount;      tokens: LONG POINTER TO TokenArray;	      AddToken: PROCEDURE [t: Token] =        BEGIN        IF nTokens^ = length - 1 THEN ERROR Unintelligible[t.offset];        tokens[nTokens^] _ t;        nTokens^ _ nTokens^ + 1;        END;  -- of AddToken            -- save original values from r      offset: CARDINAL _ r.offset;        limit: CARDINAL _ r.limit;             IF parsingTemplate THEN {tokens _ @templateTokens;  nTokens _ @nTemplateTokens}      ELSE {tokens _ @stringTokens;  nTokens _ @nStringTokens};            AddToken[[0, sep[sentinel]]];      DO        char: XChar.Character _ XS.Lop[r];        SELECT char FROM          tab => IF template = NIL THEN char _ space;          IN [space..tilde] => NULL;          ENDCASE => char _ sentinel;  -- illegal, terminate scan	          SELECT char FROM          IN ['0.ORD..'9.ORD] =>            SELECT state FROM              initial => {state _ num; tStart _ i};              num, field => NULL;              alpha => {AddToken[[tStart, alpha[i - tStart]]]; state _ num; tStart _ i};              ENDCASE; 	  '<.ORD => 	    IF parsingTemplate THEN	      SELECT state FROM                initial => {state _ field; tStart _ i + 1};	        ENDCASE => ERROR InvalidTemplate[i];	      	  '>.ORD => 	    IF parsingTemplate THEN	      SELECT state FROM	        field => {AddToken[[tStart, field[i - tStart]]]; state _ initial};	        ENDCASE => ERROR InvalidTemplate[i];	                comma, '..ORD, ':.ORD, '/.ORD, minus, plus, space, sentinel, tab => 	    BEGIN            SELECT state FROM              initial => NULL;              num => {AddToken[[tStart, num[i - tStart]]]; state _ initial};              alpha => {AddToken[[tStart, alpha[i - tStart]]]; state _ initial};              ENDCASE => ERROR InvalidTemplate[i];            -- When there is no template, we ignore spaces as separators unless 	    -- there is nothing else, and terminate the scan if two separator 	    -- characters are adjacent.	    IF template # NIL THEN AddToken[[i, sep[char]]]	    ELSE              WITH t: tokens[nTokens^ - 1] SELECT FROM                sep =>                  IF t.char = space THEN t.char _ char                  ELSE {IF char ~= space THEN t.char _ char _ sentinel};                ENDCASE => AddToken[[i, sep[char]]];            IF char = sentinel THEN EXIT;	    END;	              ENDCASE =>            SELECT state FROM              initial => {state _ alpha; tStart _ i};              num => {AddToken[[tStart, num[i - tStart]]]; state _ alpha; tStart _ i};              alpha => NULL;              ENDCASE => ERROR InvalidTemplate[i];        i _ i + 1;        ENDLOOP;      -- restore original values of r      r.offset _ offset;      r.limit _ limit;      END;  -- of Tokenize    -- The defaults in the following variables are only used when the user specifies a     -- template that doesn't include that field.    year: Year _ baseYear;  -- might want to make this current year.    month: Month _ 1;    day: Day _ 1;    hour: Hour _ 0;    minute: Minute _ 0;    second: Second _ 0;    zoneAdjust: DeltaMinutes;    dst: BOOLEAN;    cumDays: ARRAY [FIRST[Month] - 1..LAST[Month]] OF CARDINAL = [      0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];    OutOfRange: ERROR [errorPos: CARDINAL] = CODE;    BogusMonth: ERROR = CODE;        CollectValue: PROCEDURE [r: XString.Reader, t: num Token, low, high: CARDINAL]      RETURNS [value: CARDINAL _ 0] =       BEGIN      rb: XS.ReaderBody _ XS.Piece[r, t.offset, t.length].piece;      num: LONG CARDINAL;      num _ XS.ReaderToNumber[@rb !        XS.Overflow => ERROR OutOfRange[t.offset + t.length]];      IF num > high OR num < low THEN ERROR OutOfRange[t.offset + t.length];      RETURN[CARDINAL[num]];      END;  -- CollectValue          ParseEnglishMonth: PROCEDURE [r: XString.Reader] RETURNS [month: Month] =      BEGIN      monthKeys: ARRAY Month OF XComSoftMessage.Keys = [        january, february, march, april, may, june, july,        august, september, october, november, december];      FOR month IN Month DO        monthName: XS.ReaderBody _	  XComSoftMessage.GetHandle[].Get[ORD[monthKeys[month]]]^;         -- allow r to be a prefix of monthName	IF XS.CharacterLength[r] < XS.CharacterLength[@monthName] THEN	  monthName _	    XS.Piece[@monthName, 0, XS.CharacterLength[r]].piece;	IF XS.Equivalent[@monthName, r] THEN RETURN[month];        ENDLOOP;      END;  -- of ParseEnglishMonth           ParseRomanMonth: PROCEDURE [r: XString.Reader] RETURNS [month: Month] =      BEGIN      MonthNames: TYPE = ARRAY Month OF STRING;      roman: MonthNames _ [        "I"L, "II"L, "III"L, "IV"L, "V"L, "VI"L, "VII"L, "VIII"L, "IX"L,        "X"L, "XI"L, "XII"L];      FOR month IN Month DO        mm: XS.ReaderBody _ XS.FromSTRING[roman[month]];        IF XS.Equivalent[@mm, r] THEN RETURN[month];        REPEAT FINISHED => ERROR BogusMonth;        ENDLOOP;      END;  -- of ParseRomanMonth    ParseSymbolicMonth: PROCEDURE [t: alpha Token] RETURNS [month: Month] =       BEGIN      rb: XS.ReaderBody _ XS.Piece[r, t.offset, t.length].piece;      SELECT VAL[XChar.Code[XChar.UpperCase[XS.First[@rb]]]] FROM        'A, 'D, 'F, 'J, 'M, 'N, 'O, 'S => RETURN[ParseEnglishMonth[@rb]];        'I, 'V, 'X => RETURN[ParseRomanMonth[@rb]];	ENDCASE => ERROR BogusMonth;      END;  -- of ParseSymbolicMonth	    CollectYear: PROCEDURE [y: num Token, form: YearForm _ unspecified]       RETURNS [Year] =       BEGIN      SELECT form FROM         twoDigits =>           RETURN[1900 + CollectValue[             r, y, FIRST[Year] - 1900, 99 ! OutOfRange => ERROR Unintelligible[y.offset]]];        fourDigits =>          RETURN[CollectValue[r, y, FIRST[Year], LAST[Year]]];        ENDCASE =>          RETURN[1900 + CollectValue[            r, y, FIRST[Year] - 1900, 99 ! OutOfRange => CONTINUE]];          RETURN[CollectValue[r, y, FIRST[Year], LAST[Year]]];      END;  -- of CollectYear	    CollectMonth: PROCEDURE [m: num Token] RETURNS [Month] = INLINE {      RETURN[CollectValue[r, m, FIRST[Month], LAST[Month]]]};	    CollectDay: PROCEDURE [d: num Token, m: Month] RETURNS [Day] = INLINE {      RETURN[CollectValue[r, d, FIRST[Day], cumDays[m] - cumDays[m - 1]]]};    ParseDate: PROCEDURE [first: TokenIndex] RETURNS [next: TokenIndex] =       BEGIN            DO          ENABLE OutOfRange => ERROR Unintelligible[errorPos];        second, third: TokenIndex;        t: num Token;        GetThird: PROCEDURE = {          WITH token: stringTokens[third] SELECT FROM            num => t _ token;            ENDCASE => Bogus[third]};        IF nStringTokens < first + 3 OR stringTokens[first].type = sep THEN          Bogus[first];        -- Assert: 'first' is alpha or num and at least two tokens follow it.        IF stringTokens[second _ first + 1].type = sep THEN second _ second + 1;        -- Assert: 'second' is alpha or num.        -- Ergo, second+1 < nStringTokens since tokens[nStringTokens-1].type = sep        IF stringTokens[third _ second + 1].type = sep THEN {          IF third = nStringTokens - 1 THEN Bogus[third]; third _ third + 1};        << Assert: 'third' is alpha or num.  If we are really processing a date,	  'third' will have to be numeric to make sense.  However, we might be 	   processing something like Wednesday, 26 May 1981, in which there is a	   valid date, but 'first' isn't pointing to it yet (it's still on	   Wednesday).  So, we don't check that 'third' is numeric until	   we are sure that 'first' is pointing to something reasonable. >>        WITH f: stringTokens[first] SELECT FROM          alpha => {            << The first token is alpha.  If it isn't a recognizable month,	      it might be some form of the day of the week.  Whatever it is,	      we simply skip over it (and the separator following it, if any)	      and try again.  >>            month _ ParseSymbolicMonth[f ! BogusMonth => {first _ second; LOOP}];            << 'first' corresponds to a valid month.  We now require that	       'second' be the day of the month and 'third' be the year.>>            WITH d: stringTokens[second] SELECT FROM              num => day _ CollectDay[d, month];              ENDCASE => Bogus[second];            GetThird[];            year _ CollectYear[t]};          num => {            GetThird[];            WITH s: stringTokens[second] SELECT FROM              alpha => {                -- The second token is alpha, so we will require it to be the month.                month _ ParseSymbolicMonth[s ! BogusMonth => Bogus[second]];                -- Now we must decide if we have <day><month><year> or <year><month><day>                day _ CollectDay[f, month ! OutOfRange => GO TO yearFirst];                year _ CollectYear[t];                EXITS                  yearFirst => {                    year _ CollectYear[f]; day _ CollectDay[t, month]}};              num => {                -- All three parts are numeric.                year _ CollectYear[t ! OutOfRange => GO TO yearFirst];                IF dayBeforeMonth THEN {		  month _ CollectMonth[s]; day _ CollectDay[f, month]}		ELSE {		  month _ CollectMonth[f]; day _ CollectDay[s, month]};                EXITS                  yearFirst => {                    year _ CollectYear[f];                    month _ CollectMonth[s];                    day _ CollectDay[t, month]}};              ENDCASE};          ENDCASE;        next _ third + 1;        EXIT        ENDLOOP;      -- Be sure we weren't slipped a bogus leap year...      IF month = 2 AND day = 29 AND ~LeapYear[year] THEN Bogus[next];      END;  -- of ParseDate    CollectHour: PROCEDURE [h: num Token] RETURNS [Hour] = {      RETURN[CollectValue[r, h, FIRST[Hour], LAST[Hour]]]};	    CollectMinute: PROCEDURE [m: num Token] RETURNS [Minute] = INLINE {      RETURN[CollectValue[r, m, FIRST[Minute], LAST[Minute]]]};	    CollectSecond: PROCEDURE [s: num Token] RETURNS [Second] = INLINE {      RETURN[CollectValue[r, s, FIRST[Second], LAST[Second]]]};	    AMorPM: PROCEDURE [t: TokenIndex] RETURNS [BOOLEAN] =      BEGIN      WITH m: stringTokens[t] SELECT FROM        alpha => 	  BEGIN	  offset: Hour _ 0;          rb: XS.ReaderBody _ XS.Piece[r, m.offset, m.length].piece;          SELECT TRUE FROM	    XS.Equivalent[	      XComSoftMessage.GetHandle[].Get[XComSoftMessage.Keys.am.ORD], 	      @rb] => offset _ 0;	    XS.Equivalent[	      XComSoftMessage.GetHandle[].Get[XComSoftMessage.Keys.pm.ORD], 	      @rb] => offset _ 12;	    ENDCASE => RETURN[FALSE];          IF ~(hour IN [1..12]) THEN Bogus[t];          hour _ (hour MOD 12) + offset;          RETURN[TRUE];	  END;        ENDCASE;      RETURN[FALSE];      END;  -- AMorPM 	   ParseTime: PROCEDURE [first: TokenIndex] RETURNS [next: TokenIndex] =        BEGIN      ENABLE OutOfRange => ERROR Unintelligible[errorPos];            n: num Token;      next _ first;      hour _ minute _ second _ 0;      WITH f: stringTokens[first] SELECT FROM        num => {next _ next + 1; n _ f};        sep =>          IF f.char = sentinel THEN {notes _ noTime; RETURN} ELSE Bogus[first];        ENDCASE => Bogus[first];      SELECT n.length FROM 1, 2, 4, 6 => NULL; ENDCASE => Bogus[first];      hour _ CollectHour[[n.offset, num[MIN[n.length, 2]]]];      IF n.length <= 2 THEN {        -- A separator must follow a 1- or 2- digit hour field.        IF next + 1 >= nStringTokens OR stringTokens[next].type ~= sep THEN          Bogus[next];        -- Assert: tokens[next+1] is alpha or num.        next _ next + 1;        WITH s: stringTokens[next] SELECT FROM          num => n _ s;          ENDCASE => Bogus[next];        SELECT n.length FROM 2, 4 => next _ next + 1; ENDCASE => Bogus[next]}      ELSE {n.offset _ n.offset + 2; n.length _ n.length - 2};      minute _ CollectMinute[[n.offset, num[2]]];      -- Assert: 'next' indexes the token following the minutes.      IF n.length > 2 THEN        -- The minutes and seconds are concatenated.        second _ CollectSecond[[n.offset + 2, num[2]]]      ELSE        -- Now look for optional seconds field.  We assume it is present if there 	-- is a colon separator following the minutes.        WITH sep: stringTokens[next] SELECT FROM          sep =>            IF sep.char = ':.ORD THEN              -- Assert: tokens[next+1] is alpha or num.              WITH s: stringTokens[next + 1] SELECT FROM                num => {second _ CollectSecond[s]; next _ next + 2};                ENDCASE => Bogus[next + 1];          ENDCASE;      -- Assert: 'next' indexes the token following the last time part (minutes or seconds).      WITH s: stringTokens[next] SELECT FROM        sep => IF s.char ~= sentinel AND AMorPM[next + 1] THEN next _ next + 2;        alpha => IF AMorPM[next] THEN next _ next + 1;        ENDCASE;      END;  -- of ParseTime          ParseMilitaryZone: PROCEDURE [char: XChar.Character]       RETURNS [zoneAdjust: DeltaMinutes] =      BEGIN      zones: PACKED ARRAY ZoneIndex OF CHARACTER = [        'M, 'L, 'K, 'I, 'H, 'G, 'F, 'E, 'D, 'C, 'B, 'A, 'Z, 'N, 'O, 'P, 'Q,        'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y];      FOR hour: ZoneIndex IN ZoneIndex DO        IF char = zones[hour].ORD THEN {	  zoneAdjust _ hour*minutesPerHour; EXIT};        REPEAT FINISHED => ERROR BadZone;        ENDLOOP;      END;  -- of ParseMilitaryZone          ParseNAZone: PROCEDURE [rb: XString.ReaderBody, char: XChar.Character]       RETURNS [zoneAdjust: DeltaMinutes] =      BEGIN      naZones: PACKED ARRAY NAZones OF CHARACTER = [        'B, 'H, 'Y, 'P, 'M, 'C, 'E, 'A];      IF XChar.UpperCase[XS.NthCharacter[@rb, 2]] ~= 'T.ORD THEN ERROR BadZone;      SELECT XChar.UpperCase[XS.NthCharacter[@rb, 1]] FROM        'S.ORD, 'M.ORD => NULL;  -- treat "mean" same as "standard"        'D.ORD => dst _ TRUE;        ENDCASE => ERROR BadZone;      SELECT char FROM        'G.ORD => IF dst THEN ERROR BadZone;        'N.ORD =>          IF dst THEN ERROR BadZone          ELSE zoneAdjust _ -(3*minutesPerHour + 30);        ENDCASE =>          FOR hour: NAZones IN NAZones DO            IF char = naZones[hour].ORD THEN {              zoneAdjust _ hour*minutesPerHour; EXIT};            REPEAT FINISHED => ERROR BadZone;            ENDLOOP;      END;  -- of ParseNAZone          ParseAbsoluteZone: PROCEDURE [z: num Token] RETURNS [DeltaMinutes] =      BEGIN      hour: Hour;      hourLength: CARDINAL;      minute: Minute _ 0;      IF ~(z.length IN [1..4]) THEN ERROR OutOfRange[z.offset + z.length];      hourLength _ 2 - (z.length MOD 2);      hour _ CollectValue[r, [z.offset, num[hourLength]], FIRST[Hour], LAST[Hour]];      IF z.length > 2 THEN        minute _ CollectValue[          r, [z.offset + hourLength, num[2]], FIRST[Minute], LAST[Minute]];      RETURN[hour*minutesPerHour + minute];      END;  -- of ParseAbsoluteZone          ParseZone: PROCEDURE [first: TokenIndex] RETURNS [next: TokenIndex] =       BEGIN      ENABLE OutOfRange => ERROR Unintelligible[errorPos];            CollectSymbolic: PROCEDURE [z: alpha Token] RETURNS [DeltaMinutes] =         BEGIN        rb: XS.ReaderBody _ XS.Piece[r, z.offset, z.length].piece;	char: XChar.Character _ XS.First[@rb];        SELECT XS.CharacterLength[@rb] FROM          1 => RETURN[ParseMilitaryZone[char]];          3 => RETURN[ParseNAZone[rb, char]];          ENDCASE => ERROR BadZone;        END;  -- of CollectSymbolic	      -- Body of ParseZone --      zoneAdjust _ 0;      dst _ FALSE;      next _ first;      IF notes = noTime THEN RETURN;      WITH z: stringTokens[next] SELECT FROM        sep => {          zone: Token;          SELECT z.char FROM            space, plus, minus => zone _ stringTokens[next + 1];            ENDCASE => GO TO noZone;  -- includes sentinel          WITH zone: zone SELECT FROM            num => {              SELECT z.char FROM                space => GO TO noZone;                plus => zoneAdjust _ ParseAbsoluteZone[zone];                minus => zoneAdjust _ -ParseAbsoluteZone[zone];                ENDCASE};            alpha =>              IF z.char = plus THEN Bogus[next]              ELSE                zoneAdjust _ CollectSymbolic[                  zone !                  BadZone =>                    IF z.char = space THEN GO TO noZone ELSE Bogus[next + 1]];            ENDCASE;  -- can't happen          next _ next + 1};        alpha => zoneAdjust _ CollectSymbolic[z ! BadZone => GO TO noZone];        ENDCASE => GO TO noZone;      EXITS noZone =>         {notes _ nozone; IF template # NIL THEN 	  ERROR Unintelligible[stringTokens[first].offset]};      END;  -- of ParseZone          ParseDayOfWeek: PROCEDURE [t: alpha Token] =      BEGIN      -- This procedure only verifies that a valid day-of-week or abbreviation has been given.      -- It does not check against the date to see if the correct day is given.      WeekDays: TYPE = [1..7];      rb: XS.ReaderBody _ XS.Piece[r, t.offset, t.length].piece;      dayKeys: ARRAY WeekDays OF XComSoftMessage.Keys = [        monday, tuesday, wednesday, thursday, friday,        saturday, sunday];      FOR day: CARDINAL IN WeekDays DO        dd: XString.ReaderBody _	  XComSoftMessage.GetHandle[].Get[ORD[dayKeys[day]]]^;        -- allow rb to be a prefix of dd	IF XS.CharacterLength[@rb] < XS.CharacterLength[@dd] THEN	  dd _ XS.Piece[@dd, 0, XS.CharacterLength[@rb]].piece;        IF XS.Equivalent[@dd, @rb] THEN RETURN;      ENDLOOP;      ERROR Unintelligible[t.offset];      END;  -- of ParseDayOfWeek    LeapYear: PROCEDURE [year: Year] RETURNS [BOOLEAN] = {      RETURN[year MOD 4 = 0 AND (year MOD 100 ~= 0 OR year MOD 400 = 0)]};          ConsumeSpace: PROCEDURE [tokens: TokenArray, t: TokenIndex] RETURNS [TokenIndex] =       BEGIN      WITH s: tokens[t] SELECT FROM        sep => SELECT s.char FROM 	  space, comma => RETURN[t + 1]; 	  ENDCASE;        ENDCASE;      RETURN[t];      END;  -- of ConsumeSpace          AssembleGMT: PROCEDURE [notes: XTime.Notes]      RETURNS [XTime.Notes, System.GreenwichMeanTime] =       BEGIN            DetermineZoneCorrection: PROCEDURE = {        << We need to compute the local time parameters in effect at this	   zone on the date in question.  Note that this is an imperfect	   simulation, since it assumes uniform dates and times for start	   and end of daylight savings time within the local zone. >>        FirstSundayAfter: PROCEDURE [ed: EpochDays] RETURNS [EpochDays] = {          RETURN[ed + 7 - ((ed + baseDay) MOD 7)]};        ltp: System.LocalTimeParameters _ [          direction: west, zone: 8, zoneMinutes: 0, beginDST: 121, endDST: 305];        ltp _ System.GetLocalTimeParameters[          !          System.LocalTimeParametersUnknown => {            notes _ IF notes = nozone THEN zonedGuessed ELSE timeAndZoneGuessed;            CONTINUE}];        zoneAdjust _ ltp.zone*minutesPerHour + ltp.zoneMinutes;        IF ltp.direction = west THEN zoneAdjust _ -zoneAdjust;	IF ltp.beginDST # ltp.endDST THEN {	  ltp.beginDST _	    FirstSundayAfter[	      epochToJan1 + (ltp.beginDST - 9 + (	        IF LeapYear[year] THEN 1 ELSE 0))] - epochToJan1;	  ltp.endDST _	    FirstSundayAfter[	      epochToJan1 + (ltp.endDST - 9 + (IF LeapYear[year] THEN 1 ELSE 0))]	      - epochToJan1;	  dst _	    SELECT jan1ToDate FROM	      IN (ltp.beginDST..ltp.endDST) => TRUE,	      = ltp.beginDST => (hour >= 2),	      = ltp.endDST => (hour < 2),	      ENDCASE => FALSE}	ELSE dst _ FALSE;        };	      YearBoundaries: PROCEDURE [year: Year, span: CARDINAL] RETURNS [CARDINAL] = INLINE {        -- The following expression computes the number of years y in [FIRST[Year]..year) 	-- for which y MOD span is 0.        RETURN[(year + span - 1)/span - (FIRST[Year] + span - 1)/span]};	      -- body of AssembleGMT --      epochToJan1: EpochDays _        (year - FIRST[Year])*365 + YearBoundaries[year, 4] - YearBoundaries[          year, 100] + YearBoundaries[year, 400];      jan1ToDate: YearDays _        cumDays[month - 1] + (day - 1) -          (IF ~LeapYear[year] AND month > 2 THEN 1 ELSE 0);      IF notes ~= normal THEN DetermineZoneCorrection[];      -- The following gross arithmetic is required to avoid overflows.      RETURN[notes,         System.GreenwichMeanTime[          ((epochToJan1 + jan1ToDate) +             (System.gmtEpoch/secondsPerDay))*secondsPerDay +            ((INTEGER[hour] - (IF dst THEN 1 ELSE 0))*minutesPerHour + minute -               zoneAdjust)*secondsPerMinute + second]];      END;  -- of AssembleGMT                -- A template that repeats fields is invalid.    -- If fields are missing their default values are used.  For day, month, and year    --   the defaults are the current values.  For hour, minute, and second the defaults    --   are zero.  The zone default is the local zone.  If a 12 hour clock is used and    --   AM or PM is not specified, AM is assumed.        ParseWithTemplate: PROCEDURE [r: XString.Reader, template: XString.Reader _ NIL]      RETURNS [time: System.GreenwichMeanTime, notes: XTime.Notes, length: CARDINAL] =      BEGIN      numberOfFields: CARDINAL = 13;      fieldsPresent: PACKED ARRAY [1..13] OF BOOLEAN _ ALL[FALSE];      amPm: TokenIndex _ 0;      zoneIndex: TokenIndex _ 0;      hourPos: CARDINAL;            -- Usually, nextTemplateToken = nextToken.  The only time they will differ is if      -- the absolute form of the zone is used.  Then, one template token will have two      -- corresponding string tokens: the plus or minus sign and a number.      nextTemplateToken: TokenIndex _ nextToken;            notes _ noTime;      length _ 0;      Tokenize[template, TRUE];      DO        WITH t: templateTokens[nextTemplateToken] SELECT FROM	  sep => 	    BEGIN	    IF t.char = sentinel THEN EXIT;	    WITH s: stringTokens[nextToken] SELECT FROM	      sep => IF t.char # s.char THEN ERROR Unintelligible[s.offset];	      ENDCASE => ERROR Unintelligible[s.offset];	    END;	  field =>	    BEGIN	    f: CARDINAL _ CollectValue[template, LOOPHOLE[t], 1, 13];	    IF fieldsPresent[f] THEN ERROR InvalidTemplate[t.offset]	    ELSE fieldsPresent[f] _ TRUE;	    WITH s: stringTokens[nextToken] SELECT FROM	      alpha =>		SELECT f FROM		  5 => 		    BEGIN		    rb: XS.ReaderBody;		    IF fieldsPresent[1] OR fieldsPresent[6] THEN 		      ERROR InvalidTemplate[t.offset];		    rb _ XS.Piece[r, s.offset, s.length].piece;		    month _ ParseEnglishMonth[@rb];		    END;		  6 => 		    BEGIN		    rb: XS.ReaderBody;		    IF fieldsPresent[1] OR fieldsPresent[5] THEN 		      ERROR InvalidTemplate[t.offset];		    rb _ XS.Piece[r, s.offset, s.length].piece;		    IF s.length # 3 THEN ERROR Unintelligible[s.offset]		    ELSE month _ ParseEnglishMonth[@rb]; 		    END;		  11 => [] _ ParseDayOfWeek[s];		  12 => zoneIndex _ nextToken;  -- zone must be done after the time		  13 => amPm _ nextToken;  -- am/pm must be done after the hour		  ENDCASE => ERROR Unintelligible[s.offset];	      num =>	        SELECT f FROM		  1 => 		    BEGIN		    IF fieldsPresent[5] OR fieldsPresent[6] THEN 		      ERROR InvalidTemplate[t.offset];		    IF (t.length = 1) OR (s.length = 2) THEN month _ CollectMonth[s]		    ELSE ERROR Unintelligible[s.offset];		    END;		  2 => 		    IF (t.length = 1) OR (s.length = 2) THEN day _ CollectDay[s, month]		    ELSE ERROR Unintelligible[s.offset];		  3 => 		    IF ~ fieldsPresent[4] THEN year _ CollectYear[s, fourDigits]		    ELSE ERROR InvalidTemplate[t.offset];		  4 => 		    IF ~ fieldsPresent[3] THEN year _ CollectYear[s, twoDigits]		    ELSE ERROR InvalidTemplate[t.offset];		  7, 8 => 		    BEGIN		    hourPos _ s.offset;		    IF fieldsPresent[7] AND fieldsPresent[8] THEN 		      ERROR InvalidTemplate[t.offset];  		    IF (t.length = 1) OR (s.length = 2) THEN		      {hour _ CollectHour[s]; notes _ nozone}  		    ELSE ERROR Unintelligible[s.offset];		    END;		  9 => minute _ CollectMinute[s];		  10 => second _ CollectSecond[s];		  ENDCASE => ERROR Unintelligible[s.offset];	      ENDCASE => 	        IF f = 12 THEN -- absolute form for the zone		  {zoneIndex _ nextToken; nextToken _ nextToken + 1}	        ELSE ERROR Unintelligible[s.offset];	    END;	  alpha => 	    WITH s: stringTokens[nextToken] SELECT FROM	      alpha =>	        BEGIN		stringRb: XS.ReaderBody _ XS.Piece[r, s.offset, s.length].piece;		templateRb: XS.ReaderBody _ XS.Piece[template, t.offset, t.length].piece;		IF ~XString.Equal[@stringRb, @templateRb] THEN 		  ERROR Unintelligible[s.offset];	        END;	      ENDCASE => ERROR Unintelligible[s.offset];	  num => 	    WITH s: stringTokens[nextToken] SELECT FROM	      num =>	        BEGIN		stringRb: XS.ReaderBody _ XS.Piece[r, s.offset, s.length].piece;		templateRb: XS.ReaderBody _ XS.Piece[template, t.offset, t.length].piece;		IF ~XString.Equal[@stringRb, @templateRb] THEN 		  ERROR Unintelligible[s.offset];	        END;	      ENDCASE => ERROR Unintelligible[s.offset];	  ENDCASE;        nextToken _ nextToken + 1; 	nextTemplateToken _ nextTemplateToken + 1;        ENDLOOP;	      -- if day, month, or year defaults are needed, they are computed here      IF (~fieldsPresent[2] OR ~(fieldsPresent[3] OR fieldsPresent[4]) OR 	~(fieldsPresent[1] OR fieldsPresent[5] OR fieldsPresent[6])) THEN        BEGIN	currentDate: XTime.Unpacked _ XTime.Unpack[];	IF ~fieldsPresent[3] AND ~fieldsPresent[4] THEN year _ currentDate.year;	IF ~fieldsPresent[2] THEN day _ currentDate.day;	IF (~fieldsPresent[1] AND ~fieldsPresent[5] AND ~fieldsPresent[6]) THEN	  month _ currentDate.month + 1;	END;	      IF fieldsPresent[13] THEN        BEGIN         IF fieldsPresent[8] THEN ERROR InvalidTemplate[templateTokens[amPm].offset];	IF ~AMorPM[amPm] THEN ERROR Unintelligible[stringTokens[amPm].offset];	END      ELSE -- if no AM/PM field, assume AM for 12 hour clock.        IF fieldsPresent[7] AND hour > 12 THEN	  ERROR Unintelligible[hourPos];	      IF fieldsPresent[12] THEN {notes _ normal;  [] _ ParseZone[zoneIndex]};        [notes, time] _ AssembleGMT[notes];      length _ stringTokens[nextToken].offset;      END;  -- of ParseWithTemplate    -- *** Main Body of ParseReader ***    nextToken: TokenIndex _ SUCC[FIRST[TokenIndex]];       BEGIN    ENABLE       BEGIN      Unintelligible => NULL;      InvalidTemplate => NULL;      END;    IF XS.Empty[r] THEN ERROR Unintelligible[0];    notes _ normal;    length _ 0;    Tokenize[r, FALSE];    IF template # NIL THEN RETURN ParseWithTemplate[r, template];    -- Assert:  The input has been tokenized such that:    --   tokens[0].kind = tokens[nStringTokens-1].kind = sep[sentinel]]    --   for all i IN (0..nStringTokens-1):    --      if tokens[i].type = sep, then    --         tokens[i-1].type ~= sep and tokens[i+1].type ~= sep    nextToken _ ParseDate[nextToken ! Unintelligible => GO TO tryTimeFirst];    nextToken _ ConsumeSpace[stringTokens, nextToken];    nextToken _ ParseTime[nextToken];    nextToken _ ParseZone[nextToken];    EXITS      tryTimeFirst => {        nextToken _ ParseTime[nextToken];        nextToken _ ParseZone[nextToken];        nextToken _ ConsumeSpace[stringTokens, nextToken];        nextToken _ ParseDate[nextToken];        };    END;        [notes, time] _ AssembleGMT[notes];    length _ stringTokens[nextToken].offset;    END;  -- of ParseReader  END.  -- of XTimeImplB     
-- file: XFormatImpl.mesa; last edit:-- Last Edit :26-Jun-84 18:39:36, KNguyenDIRECTORY  Environment USING [bitsPerWord, Block],  Inline USING [BITOR, BITSHIFT, LowHalf, UDDivMod],  Heap USING [systemZone],  NSString USING [Character, String],  Stream USING [Handle, PutBlock, PutByte],  System USING [    broadcastHostNumber, GreenwichMeanTime, HostNumber, NetworkAddress,    NetworkNumber, SocketNumber],  TTY USING [Handle, PutBlock, PutChar],  XFormat USING [    DateFormat, ErrorCode, FormatProc, Handle, NetFormat,    NumberFormat, Object, OctalFormat],  XString USING [    AppendChar, AppendReader, Block, Character, CharacterLength, ComputeEndContext, Context,    FreeWriterBytes, FromChar, FromBlock, FromNSString, FromSTRING,    NewWriterBody, Piece, Reader, ReaderBody, ReaderFromWriter, ReaderInfo,    vanillaContext, Writer, WriterBody, WriterBodyFromSTRING, WriterInfo],  XTime USING [Append, dateAndTime, dateOnly, timeOnly];XFormatImpl: MONITOR  IMPORTS Heap, Inline, Stream, TTY, XString, XTime  EXPORTS XFormat =  BEGIN OPEN XFormat, XS: XString, nss: NSString;  defaultObject: Object _ [proc: NopProc, context:, data: NIL];  SetDefaultOutputSink: PUBLIC ENTRY PROC [new: Object] RETURNS [old: Object] = {    old _ defaultObject;    defaultObject _ new};  GetDefaults: ENTRY PROCEDURE RETURNS [Handle] = {RETURN[@defaultObject]};  NopProc: FormatProc = {};    -- Public procedures  Blanks: PUBLIC PROCEDURE [h: Handle, n: CARDINAL _ 1] = {    blank: STRING = "                "L;  -- 16 blanks    rb: XS.ReaderBody _ XS.FromSTRING[blank];    IF h = NIL THEN h _ GetDefaults[];    THROUGH [0..n/blank.length) DO h.proc[@rb, h] ENDLOOP;    rb _ XString.Piece[r: @rb, firstChar: 0, nChars: n MOD blank.length].piece;    h.proc[@rb, h]};  Block: PUBLIC PROCEDURE [h: Handle, block: Environment.Block] = {    rb: XS.ReaderBody _ XS.FromBlock[block];    IF h = NIL THEN h _ GetDefaults[];    h.proc[@rb, h]};  Char: PUBLIC PROCEDURE [h: Handle, char: XS.Character] = {    rb: XS.ReaderBody _ XS.FromChar[@char];    IF h = NIL THEN h _ GetDefaults[];    h.proc[@rb, h]};  CR: PUBLIC PROCEDURE [h: Handle, n: CARDINAL] = {    cr: XS.Character _ '\N.ORD;    rb: XS.ReaderBody _ XS.FromChar[@cr];    IF h = NIL THEN h _ GetDefaults[];    THROUGH [0..n) DO h.proc[@rb, h] ENDLOOP};  Date: PUBLIC PROCEDURE [    h: Handle, time: System.GreenwichMeanTime, format: DateFormat] = {    template: XS.Reader = SELECT format FROM      dateOnly => XTime.dateOnly,      timeOnly => XTime.timeOnly,      ENDCASE => XTime.dateAndTime;    wb: XS.WriterBody _ XS.NewWriterBody[maxLength: 100, z: Heap.systemZone];    IF h = NIL THEN h _ GetDefaults[];    XTime.Append[w: @wb, time: time, template: template !      UNWIND => XS.FreeWriterBytes[@wb]];    h.proc[XS.ReaderFromWriter[@wb], h ! UNWIND => XS.FreeWriterBytes[@wb]];    XS.FreeWriterBytes[@wb] };  Line: PUBLIC PROCEDURE [h: Handle, r: XS.Reader, n: CARDINAL] = {    Reader[h, r]; CR[h, n]};  maxDigitLength: CARDINAL = 34;    NSString: PUBLIC PROCEDURE [h: Handle, s: nss.String] = {    rb: XS.ReaderBody _ XS.FromNSString[s];    IF h = NIL THEN h _ GetDefaults[];    h.proc[@rb, h]};  NSChar: PUBLIC PROCEDURE [h: Handle, char: nss.Character] = {    rb: XS.ReaderBody _ XS.FromChar[@LOOPHOLE[char, XS.Character]];    IF h = NIL THEN h _ GetDefaults[];    h.proc[@rb, h]};  NSLine: PUBLIC PROCEDURE [h: Handle, s: nss.String, n: CARDINAL _ 1] = {    NSString[h, s]; CR[h, n]};  Number: PUBLIC PROCEDURE [    h: Handle, n: LONG UNSPECIFIED, format: NumberFormat] =    BEGIN    s: STRING _ [maxDigitLength];    w: XS.WriterBody _ XS.WriterBodyFromSTRING[s];    neg: BOOLEAN;    NextDigit: PROCEDURE [n: LONG CARDINAL] = {      lr: LONG CARDINAL;      r: CARDINAL;      [n, lr] _ Inline.UDDivMod[n, format.base];      IF n # 0 THEN NextDigit[n];      IF (r _ Inline.LowHalf[lr]) > 9 THEN r _ r + 'A - '0 - 10;      XS.AppendChar[@w, (r + '0).ORD]};    IF h = NIL THEN h _ GetDefaults[];    IF LOOPHOLE[n, LONG INTEGER] < 0 AND format.signed THEN {      n _ -LOOPHOLE[n, LONG INTEGER]; neg _ TRUE}    ELSE neg _ FALSE;    NextDigit[n];    FormatNumber[w: @w, format: format, neg: neg, h: h];    END;  Octal: PUBLIC PROCEDURE [h: Handle, n: LONG CARDINAL] = {    Number[h, n, XFormat.OctalFormat];    IF n > 7 THEN Char[h, 'B.ORD]};  Reader: PUBLIC PROC [h: Handle, r: XS.Reader] = {    IF h = NIL THEN h _ GetDefaults[];    h.proc[r, h]};  ReaderBody: PUBLIC PROC [h: Handle, rb: XS.ReaderBody] = {    IF h = NIL THEN h _ GetDefaults[];    h.proc[@rb, h]};  String: PUBLIC PROC [h: Handle, s: LONG STRING] = {    rb: XS.ReaderBody _ XS.FromSTRING[s];    IF h = NIL THEN h _ GetDefaults[];    h.proc[@rb, h]};  StreamProc: PUBLIC FormatProc = {    stream: Stream.Handle;    startsWith377B: BOOLEAN;    c: XString.Context;    IF (stream _ h.data) = NIL THEN ERROR Error[nilData];    [context: c, startsWith377B: startsWith377B] _ XString.ReaderInfo[r];    SELECT TRUE FROM      startsWith377B => NULL;      c.suffixSize = 2 =>        IF h.context.suffixSize = 1 THEN {	  stream.PutByte[377B];	  stream.PutByte[377B];	  stream.PutByte[0]};      c.prefix # h.context.prefix, h.context.suffixSize = 2 => {	stream.PutByte[377B];	stream.PutByte[c.prefix]};      ENDCASE;    stream.PutBlock[block: XString.Block[r].block];    h.context _ XString.ComputeEndContext[r]};      TTYProc: PUBLIC FormatProc = {    tty: TTY.Handle = LOOPHOLE[h.data];    startsWith377B: BOOLEAN;    c: XString.Context;    IF h.data = NIL THEN ERROR Error[nilData];    [context: c, startsWith377B: startsWith377B] _ XString.ReaderInfo[r];    SELECT TRUE FROM      startsWith377B => NULL;      c.suffixSize = 2 =>        IF h.context.suffixSize = 1 THEN {	  tty.PutChar[VAL[377B]];	  tty.PutChar[VAL[377B]];	  tty.PutChar[VAL[0]]};      c.prefix # h.context.prefix, h.context.suffixSize = 2 => {	tty.PutChar[VAL[377B]];	tty.PutChar[VAL[c.prefix]]};      ENDCASE;    tty.PutBlock[block: XString.Block[r].block];    h.context _ XString.ComputeEndContext[r]};      WriterProc: PUBLIC FormatProc = {    IF h.data = NIL THEN ERROR Error[nilData];    XS.AppendReader[to: h.data, from: r];    h.context _ XString.WriterInfo[h.data].endContext};      StreamObject: PUBLIC PROC [sH: Stream.Handle] RETURNS [Object] = {    IF sH = NIL THEN ERROR Error[nilData];    RETURN[[StreamProc, XString.vanillaContext, sH]]};  TTYObject: PUBLIC PROC [h: TTY.Handle] RETURNS [Object] = {    IF LOOPHOLE[h, LONG POINTER] = NIL THEN ERROR Error[nilData];    RETURN[[TTYProc, XString.vanillaContext, LOOPHOLE[h]]]};  WriterObject: PUBLIC PROC [w: XString.Writer] RETURNS [Object] = {    IF w = NIL THEN ERROR Error[nilData];    RETURN[[WriterProc, XString.vanillaContext, w]]};  -- Private procedures  FormatNumber: PROCEDURE [    w: XS.Writer, format: NumberFormat, neg: BOOLEAN, h: Handle] =    BEGIN    r: XS.Reader _ XS.ReaderFromWriter[w];    l: CARDINAL;    fill: STRING _ (IF format.zerofill THEN "00000000"L ELSE "        "L);    rb: XS.ReaderBody _ XS.FromSTRING[fill];    l _ XS.CharacterLength[r] + neg.ORD;    IF l < format.columns THEN      BEGIN      fillChars: CARDINAL _ format.columns - l;      IF neg AND format.zerofill THEN Char[h, '-.ORD];      THROUGH [0..fillChars/8) DO h.proc[@rb, h]; ENDLOOP;      THROUGH [0..fillChars MOD 8) DO Char[h, fill[0].ORD]; ENDLOOP;      IF neg AND ~format.zerofill THEN Char[h, '-.ORD];      END    ELSE IF neg THEN Char[h, '-.ORD];    h.proc[r, h];    END;  -- Network related things  Error: PUBLIC ERROR [code: ErrorCode] = CODE;  bitsPerPSCharacter: CARDINAL = 2;  -- I don't want to think about the dashes  bitsPerOctalCharacter: CARDINAL = 3;  bitsPerHexCharacter: CARDINAL = 4;  minBitsPerCharacter: CARDINAL = MIN[    bitsPerPSCharacter, bitsPerOctalCharacter, bitsPerHexCharacter];  maxCharsInHostNumber: CARDINAL =    SIZE[System.HostNumber]*Environment.bitsPerWord/minBitsPerCharacter + 1;  maxCharsInNetworkNumber: CARDINAL =    SIZE[System.NetworkNumber]*Environment.bitsPerWord/minBitsPerCharacter + 1;  maxCharsInSocketNumber: CARDINAL =    SIZE[System.SocketNumber]*Environment.bitsPerWord/minBitsPerCharacter + 1;  maxCharsInNetworkAddress: CARDINAL =    maxCharsInNetworkNumber + 1 + maxCharsInHostNumber + 1 +      maxCharsInSocketNumber;  maxDigits: CARDINAL = MAX[    maxCharsInHostNumber, maxCharsInNetworkNumber, maxCharsInSocketNumber];  Digits: TYPE = ARRAY [0..maxDigits) OF CARDINAL;  HostNumber: PUBLIC PROCEDURE [    h: Handle, hostNumber: System.HostNumber, format: NetFormat] =    BEGIN    temp: STRING = [maxCharsInHostNumber];    w: XS.WriterBody _ XS.WriterBodyFromSTRING[temp];    IF h = NIL THEN h _ GetDefaults[];    IF hostNumber = System.broadcastHostNumber THEN XS.AppendChar[@w, '*.ORD]    ELSE AppendField[@w, @hostNumber, SIZE[System.HostNumber], format];    h.proc[XS.ReaderFromWriter[@w], h];    END;  NetworkNumber: PUBLIC PROCEDURE [    h: Handle, networkNumber: System.NetworkNumber, format: NetFormat] =    BEGIN    temp: STRING = [maxCharsInHostNumber];    w: XS.WriterBody _ XS.WriterBodyFromSTRING[temp];    IF h = NIL THEN h _ GetDefaults[];    AppendField[@w, @networkNumber, SIZE[System.NetworkNumber], format];    h.proc[XS.ReaderFromWriter[@w], h];    END;  SocketNumber: PUBLIC PROCEDURE [    h: Handle, socketNumber: System.SocketNumber, format: NetFormat] =    BEGIN    temp: STRING = [maxCharsInHostNumber];    w: XS.WriterBody _ XS.WriterBodyFromSTRING[temp];    IF h = NIL THEN h _ GetDefaults[];    AppendField[@w, @socketNumber, SIZE[System.SocketNumber], format];    h.proc[XS.ReaderFromWriter[@w], h];    END;  NetworkAddress: PUBLIC PROCEDURE [    h: Handle, networkAddress: System.NetworkAddress, format: NetFormat] =    BEGIN    temp: STRING = [maxCharsInNetworkAddress];    w: XS.WriterBody _ XS.WriterBodyFromSTRING[temp];    IF h = NIL THEN h _ GetDefaults[];    AppendField[@w, @networkAddress.net, SIZE[System.NetworkNumber], format];    XS.AppendChar[@w, '..ORD];    IF networkAddress.host = System.broadcastHostNumber THEN      XS.AppendChar[@w, '*.ORD]    ELSE      AppendField[@w, @networkAddress.host, SIZE[System.HostNumber], format];    XS.AppendChar[@w, '..ORD];    AppendField[@w, @networkAddress.socket, SIZE[System.SocketNumber], format];    h.proc[XS.ReaderFromWriter[@w], h];    END;  AppendField: PROCEDURE [    w: XS.Writer, data: POINTER, words: CARDINAL, format: NetFormat] =    BEGIN    digits: Digits;    base: CARDINAL;    SELECT format FROM      octal => base _ 8;      hex => base _ 16;      productSoftware => base _ 10;      ENDCASE => ERROR Error[invalidFormat];    ConvertToDigits[data, words, base, @digits];    AppendDigits[w, @digits, base = 10];    IF base = 16 THEN XS.AppendChar[w, 'H.ORD];    END;  AppendDigits: PROCEDURE [    w: XS.Writer, digits: POINTER TO Digits, dashes: BOOLEAN] = {    rb: XS.ReaderBody _ XS.FromSTRING["0-00"L];    something: BOOLEAN _ FALSE;    FOR i: CARDINAL IN [0..maxDigits) DO      v: CARDINAL _ digits[i];      IF dashes AND something AND (maxDigits - i) MOD 3 = 0 THEN        XS.AppendChar[w, '-.ORD];      IF v # 0 AND ~something THEN {        IF dashes THEN {          SELECT maxDigits - i FROM            1 => XS.AppendReader[w, @rb];            2 => {	      rb _ XS.Piece[r: @rb, firstChar: 0, nChars: 3].piece;	      XS.AppendReader[w, @rb]};            3 => {	      rb _ XS.Piece[r: @rb, firstChar: 0, nChars: 2].piece;	      XS.AppendReader[w, @rb]};            ENDCASE => NULL};        IF v > 9 THEN XS.AppendChar[w, '0.ORD];  -- Leading digit for Hex case        something _ TRUE};      IF something THEN {        c: CHARACTER _ IF v > 9 THEN v - 10 + 'A ELSE v + '0;        XS.AppendChar[w, c.ORD]};      ENDLOOP;    IF ~something THEN {XS.AppendChar[w, '0.ORD]}};  ConvertToDigits: PROCEDURE [    field: POINTER, size, base: CARDINAL, digits: POINTER TO Digits] =    BEGIN    digits^ _ ALL[0];    THROUGH [0..size*Environment.bitsPerWord) DO      bit: CARDINAL _ ShiftFieldLeft[field, size, 1];      FOR i: CARDINAL DECREASING IN [0..maxDigits) DO        digits[i] _ digits[i]*2 + bit;        IF digits[i] >= base THEN {digits[i] _ digits[i] - base; bit _ 1}        ELSE bit _ 0;        ENDLOOP;      ENDLOOP;    END;  ShiftFieldLeft: PROCEDURE [data: POINTER, words: CARDINAL, shift: INTEGER]    RETURNS [left: CARDINAL] =    BEGIN    right: WORD _ 0;    data _ data + words;    THROUGH [0..words) DO      data _ data - 1;      left _ Inline.BITSHIFT[data^, shift - 16];      data^ _ Inline.BITOR[Inline.BITSHIFT[data^, shift], right];      right _ left;      ENDLOOP;    END;  -- Mainline Code  END.Log26-Jun-84 18:39:53 - KNguyen - Fix AR#8631, XFormat: Storage leak of 50 word nodes in XFormat.Date
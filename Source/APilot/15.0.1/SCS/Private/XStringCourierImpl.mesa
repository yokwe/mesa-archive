-- File: XStringCourierImpl.mesa - last edit:-- Ching.pa		15-Mar-84 10:59:31DIRECTORY  Courier USING [Description],  Environment USING [Block, Byte],  XString USING [ByteSequence, Context, Reader, ReaderBody, ReadOnlyBytes,    vanillaContext];  XStringCourierImpl: PROGRAM  EXPORTS XString  SHARES XString =  BEGIN    DescribeReaderBody: PUBLIC Courier.Description =    BEGIN          DescribeBytes: Courier.Description =        BEGIN	-- a PACKED ARRAY [0..1) won't work correctly.  See System Software AR #4434.	nullByte: PACKED ARRAY [0..2) OF Environment.Byte _ [0, 0];	lengthInWords: CARDINAL _ (lengthInBytes + 1)/2;        bs: LONG POINTER TO XString.ByteSequence _ notes.noteSize[lengthInWords];	  	IF notes.operation = fetch THEN	  BEGIN	  notes.noteDeadSpace[bs, lengthInWords];	  -- note the context information, if any	  IF contextLength # 0 THEN notes.noteBlock[[@contextBytes, 0, contextLength]];	  -- note the sequence	  notes.noteBlock[[LOOPHOLE[bs], rb.offset, rb.limit]];	  -- If there was an odd number of bytes add a null byte for an exact word count.          IF ((lengthInBytes MOD 2) = 1) THEN notes.noteBlock[[@nullByte, 0, 1]];	  END;  	          END; -- of DescribeBytes	    lengthInBytes, contextLength: CARDINAL;    -- x will be used for filler characters at the end of contextBytes.    x: Environment.Byte = 377B;    esc: Environment.Byte = 377B;      set0: Environment.Byte = 0B;    contextBytes: PACKED ARRAY [0..3) OF Environment.Byte _ [x, x, x];    rb: XString.Reader = notes.noteSize[SIZE[XString.ReaderBody]];        -- Do not generate courier data out of the first three fields.  Context can not be sent    -- because it does not have a corresponding Courier type.  Limit and offset can be     -- reconstructed.    notes.noteDeadSpace[@rb.context, (SIZE[XString.Context] + 2*SIZE[CARDINAL])];         -- Compute the total number of bytes to be sent, including context characters, if    -- necessary.     IF notes.operation # store THEN       BEGIN      -- We can't send the context directly.  Instead we have to append the information      -- to the beginning of the byte sequence.      IF (rb.context # XString.vanillaContext) AND (rb.bytes[rb.offset] # 377B) THEN        BEGIN         IF rb.context.suffixSize = 1 THEN 	  {contextLength _ 2; contextBytes _ [esc, rb.context.prefix, x]}        ELSE {contextLength _ 3; contextBytes _ [esc, esc, set0]};	END;      lengthInBytes _ rb.limit - rb.offset + contextLength;      END;        -- Move the local variable "lengthInBytes" to/from the serialized stream.    notes.noteSpace[@lengthInBytes, SIZE[CARDINAL]];            -- In noting bytes, we must use LOOPHOLE to get around the READONLY.    notes.noteDisjointData[LOOPHOLE[@rb.bytes], DescribeBytes];        IF notes.operation = store THEN      BEGIN  -- rebuild the fields that were not sent as courier data      rb.context _ XString.vanillaContext;      rb.limit _ lengthInBytes;      rb.offset _ 0;      END;    END;  -- of DescribeReaderBody    DescribeReader: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO XString.Reader = notes.noteSize[SIZE[LONG POINTER]];    notes.noteDisjointData[p, DescribeReaderBody];    END;  -- of DescribeReader      END.    
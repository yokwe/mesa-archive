-- NSStringConvertImpl.mesa  -- Last edited:  Alfvin  18-Apr-84 15:36:40DIRECTORY  NSString USING [Character, String],  NSStringConvert USING [Assignments, ErrorType],  NSStringConvertExtras USING [],  NSStringConvertInternal USING [ConvertInterimToXC82, ConvertStandardToXC82, ConvertXC82ToInterim, ConvertXC82ToStandard],  XString USING [AppendChar, ByteLength, Character, Empty, ExpandWriter, FromBlock, Map, NewWriterBody, Reader, ReaderBody, ReaderFromWriter, Writer, WriterBody];NSStringConvertImpl: PROGRAM  IMPORTS NSStringConvertInternal, XString  EXPORTS NSStringConvert, NSStringConvertExtras  SHARES XString = BEGIN OPEN NSString, NSStringConvert;-- Signals and Errors  Error: PUBLIC SIGNAL [type: ErrorType, char: Character] RETURNS [Character] = CODE;-- PUBLIC Procedures ----  The string result of ConvertString[z,s,interim,standard] is potentially much larger than s.length; thus 2*s.length is allocated and increased as necessary.  For instance, in converting Japanese chars the chset can vary for each char encountered even though the input string contains only one chset  (we're changing between usage frequency order to JIS order).  On the other hand, it could be the same lenght.  Sooo, the resultant length can be either just enough or much longer than actually needed.ConvertString: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, s: String, byteOffset: CARDINAL _ 0,  old, new: Assignments] RETURNS [String] =  BEGIN  writerBody: XString.WriterBody _ XString.NewWriterBody[0, z];  readerBody: XString.ReaderBody _    XString.FromBlock[[LOOPHOLE[s.bytes], byteOffset, s.length]];  ConvertReader[@writerBody, @readerBody, old, new];  RETURN[[bytes: LOOPHOLE[writerBody.bytes], length: writerBody.limit, maxlength: writerBody.maxLimit]];  END;    ConvertReader: PUBLIC PROCEDURE [    to: XString.Writer, from: XString.Reader, old, new: Assignments] =    BEGIN OPEN XString;    mapProc: PROC [c: Character] RETURNS [stop: BOOLEAN] = {      newChar: XString.Character _        IF CloseEnoughCharSet0Char[LOOPHOLE[c]] THEN c        ELSE LOOPHOLE[ConvertCharacter[LOOPHOLE[c], old, new]];      AppendChar[to, newChar, 3];      RETURN[FALSE]};    IF Empty[from] THEN RETURN;    IF ByteLength[ReaderFromWriter[to]]=0 THEN {      initialLength: CARDINAL = SELECT TRUE FROM        old=interim AND old#new => 2*ByteLength[from],	ENDCASE => ByteLength[from];      ExpandWriter[to, initialLength]};    [] _ Map[from, mapProc];    END; -- ConvertReader  ConvertCharacter: PUBLIC PROCEDURE [c: Character, old, new: Assignments]    RETURNS [newChar: Character] =    BEGIN    IF CloseEnoughCharSet0Char[c] THEN RETURN[c]    ELSE RETURN[ConvertCharacterPicky[c, old, new]]    END;      ConvertCharacterPicky: PUBLIC PROCEDURE [c: Character, old, new: Assignments]    RETURNS [newChar: Character] =    BEGIN OPEN ci: NSStringConvertInternal;    conv: RECORD [old, new: Assignments] = [old, new];    IF old=xc82 THEN SELECT c FROM	-- handle past conversion bugs      [41B, 2] => c _ [41B, 42B];      [41B, 3] => c _ [41B, 43B];      ENDCASE;    SELECT c.chset FROM      IN [1..40B], IN [177B..240B] =>        IF old#interim THEN RETURN[Error[illegalChar, c]];      377B => RETURN[Error[illegalChar, c]];      ENDCASE;    SELECT c.code FROM      IN [0..40B] => IF old=xc82 OR old=standard OR c.chset=0 THEN RETURN[c];      IN [177B..240B] => IF old=xc82 OR old=standard THEN RETURN[c];      377B => RETURN[Error[illegalChar, c]];      ENDCASE;    newChar _ SELECT conv FROM      [interim, xc82] => ci.ConvertInterimToXC82[c],      [interim, standard] => ci.ConvertXC82ToStandard[ci.ConvertInterimToXC82[c]],      [xc82, standard] => ci.ConvertXC82ToStandard[c],      [standard, xc82] => ci.ConvertStandardToXC82[c],      [standard, interim] => ci.ConvertXC82ToInterim[ci.ConvertStandardToXC82[c]],      [xc82, interim] => ci.ConvertXC82ToInterim[c],      ENDCASE => c;    END; -- ConvertCharacter    -- Those characters in chset 0 (all versions) which are "close enough" in semantics/appearance that is is deemed more important to retain the chset 0 numeric code than to translate to a new character   CloseEnoughCharSet0Char: PROCEDURE [c: Character] RETURNS [BOOLEAN] = INLINE     BEGIN     IF c.chset=0 THEN       RETURN[SELECT c.code FROM         IN [177B..240B], 44B, 244B, 250B => FALSE,	 ENDCASE => TRUE]     ELSE RETURN[FALSE]     END;END.Log when - who - what27-Nov-83 12:03:26 - Alfvin - Reworked for 8.0.18-Jan-84 14:21:47 - Mason - Corrected excluded chsets from [1..41B] to [1..40B]27-Jan-84 14:39:49 - Alfvin - Removed most chset 0 changes in ConvertCharacter29-Feb-84 11:22:02 - Alfvin - Special handling for bad Japanese comma/period chars generated in past releases.29-Feb-84 11:22:02 - Alfvin - Fix to handle byteOffset in ConvertString.18-Mar-84 12:45:14 - Alfvin - Allow control codes through for interim chset to handle old Kanji assignments.  Raise illegal char for 377B in all cases. 9-Apr-84 15:43:49 - Alfvin - Return same char for control codes in chset 0 in any event (fix to previous fix).18-Apr-84 11:25:27 - Alfvin - Let [177B..240B] through for translation in interim chset 0.18-Apr-84 15:36:49 - Alfvin - REALLY let [177B..240B] through for translation in interim chset 0.
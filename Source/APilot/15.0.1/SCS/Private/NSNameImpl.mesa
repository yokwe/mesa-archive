-- File: NSNameImpl.mesa - last edit:-- Holbrook            19-Jun-87 10:26:29-- Saund:  11-Apr-84 17:13:01-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY   Courier USING [      Description, DeserializeParameters, Parameters, SerializeParameters],   Environment USING [Block, Byte, bytesPerWord, Word],   Heap USING [FreeNode, MakeNode, systemZone],   Inline USING [LongCOPY, LowHalf],   MemoryStream USING [Create, Destroy],   NSName USING [maxOrgLength, maxDomainLength, maxLocalLength,     ErrorType, Name, NameRecord, NameStore, separatorCharacter, String],   NSString USING [AppendCharacter, AppendString, AppendSubString, Character,     CompareStrings, DescribeString, EqualStrings, FreeString, LogicalLength,     MakeString, nullString, Relation, ScanForCharacter, String,     StringBoundsFault, StringFromMesaString, SubString, SubStringDescriptor],   Stream USING [defaultInputOptions, Handle, Object, Position];NSNameImpl: PROGRAM   IMPORTS Courier, Heap, Inline, MemoryStream, NSString   EXPORTS NSName =   BEGIN   ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----   -- SIGNALS AND ERRORS:   ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----   Error: PUBLIC ERROR [type: NSName.ErrorType] = CODE;   NameTooSmall: PUBLIC SIGNAL [      oldName: NSName.Name,      orgLenNeeded, domainLenNeeded, localLenNeeded: CARDINAL]      RETURNS [newName: NSName.Name] = CODE;   ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----   -- PUBLIC VARIABLES   ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----   wildCardString: PUBLIC NSString.String _ NSString.StringFromMesaString["*"];      ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----   -- PUBLIC OPERATIONS   ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----   -- ALLOCATION AND DEALLOCATION.   CopyNameFields: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, source, destination: NSName.Name] =      -- Copies source to destination, allocates fields of destination from z.        -- The client may pre-allocate the fields of destination, in which case      -- no memory will be allocated and the signal NameTooSmall may be raised.       -- The user is responsible for freeing the allocated memory (FreeName).      -- this no longer calls MakeUpNameFromStrings 'cause that is so expensive.      BEGIN      orgOK, domOK, localOK: BOOLEAN _ TRUE;      DO		-- check that name is large enough:        IF destination.org.bytes # NIL THEN           IF destination.org.maxlength < source.org.length THEN orgOK _ FALSE;        IF destination.domain.bytes # NIL THEN           IF destination.domain.maxlength < source.domain.length THEN             domOK _ FALSE;        IF destination.local.bytes # NIL THEN           IF destination.local.maxlength < source.local.length THEN 	    localOK _ FALSE;        IF orgOK AND domOK AND localOK THEN EXIT         ELSE destination _ SIGNAL NameTooSmall[destination,          source.org.length, source.domain.length, source.local.length];        ENDLOOP;      CopyNameField[z, source.org, @destination.org];      CopyNameField[z, source.domain, @destination.domain];      CopyNameField[z, source.local, @destination.local];      END;         CopyNameField: PROCEDURE [z: UNCOUNTED ZONE,     source: NSString.String, destination: LONG POINTER TO NSString.String] =    BEGIN    IF source.maxlength # 0 AND source.bytes # NIL AND source.length # 0 THEN      -- This test is better than string # NSString.nullString?      BEGIN		-- (worry about odd length strings)      IF destination.bytes = NIL THEN        destination^ _ NSString.MakeString[z, source.length];      Inline.LongCOPY[	from: source.bytes, to: destination.bytes, nwords: source.length/2];      destination.bytes[source.length-1] _ source.bytes[source.length-1];      destination.length _ source.length;      END;    END;    CopyName: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, name: NSName.Name]      RETURNS [copy: NSName.Name] =      BEGIN      copy _ z.NEW[NSName.NameRecord];      CopyNameFields[z: z, source: name, destination: copy];      END;   MakeNameFields: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, destination: NSName.Name,      orgSize, domainSize, localSize: CARDINAL] =      -- allocates the three subfields of destination from z.  Their lengths      -- are set to zero.  The user is responsible for the allocated memory.      BEGIN      destination.org _ NSString.MakeString[z, orgSize];      destination.domain _ NSString.MakeString[z, domainSize];      destination.local _ NSString.MakeString[z, localSize];      END;   MakeName: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, orgSize, domainSize, localSize: CARDINAL]      RETURNS [n: NSName.Name] =      BEGIN      n _ z.NEW[NSName.NameRecord];      MakeNameFields[z, n, orgSize, domainSize, localSize];      END;   InitNameStore: PUBLIC PROC [store: LONG POINTER TO NSName.NameStore] = {    store.record _ [      org: [LOOPHOLE[@store.org], 0, NSName.maxOrgLength],      domain: [LOOPHOLE[@store.domain], 0, NSName.maxDomainLength],      local: [LOOPHOLE[@store.local], 0, NSName.maxLocalLength]]};               ClearName, FreeNameFields: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, name: NSName.Name] =      -- Frees the subfields of name and smashes a nullString in their places.      -- This is where the user gets rid of the memory he is responsible for.      BEGIN      NSString.FreeString[z, name.org];      NSString.FreeString[z, name.domain];      NSString.FreeString[z, name.local];      name^ _ [];      END;   FreeName: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, name: NSName.Name] =      BEGIN FreeNameFields[z, name]; z.FREE[@name]; END;   -- CONVERSIONS BETWEEN Strings AND NameRecords.   AppendNameToString: PUBLIC PROCEDURE [      s: NSName.String, name: NSName.Name, resetLengthFirst: BOOLEAN]      RETURNS [newS: NSName.String] =      BEGIN      nullOrg: BOOLEAN = NSString.EqualStrings[name.org, NSString.nullString];      newS _ s;      IF resetLengthFirst THEN newS.length _ 0;      newS _ NSString.AppendString[newS, name.local];      IF NSString.EqualStrings[name.domain, NSString.nullString] AND nullOrg THEN        RETURN[newS];      newS _ NSString.AppendCharacter[newS, NSName.separatorCharacter];      newS _ NSString.AppendString[newS, name.domain];      IF nullOrg THEN RETURN[newS];      newS _ NSString.AppendCharacter[newS, NSName.separatorCharacter];      newS _ NSString.AppendString[newS, name.org];      END;    -- BWS/WS AR 12604, SVS AR 10648: fold in Services 10.0 of NameFieldsFromString to eliminate support of '@ as delimiter    NameFieldsFromString: PUBLIC PROCEDURE [    z: UNCOUNTED ZONE, s: NSName.String, destination: NSName.Name,    clientDefaults: NSName.Name] =    -- This procedure divides the NSString containing a well-formed, fully-qualified name into a NameRecord. If the fields of destination are already allocated, their content will be replaced, otherwise new Strings will be allocated from the specified zone. Defaults may be specified to handle the case of a name that is not fully-qualified. If clientDefaults is NIL, then the defaults become zero-length NSStrings. The client is responsible for freeing memory which is allocated for the fields of destination; ClearName or FreeNameFields can be used for this purpose.  This operation may report tooManySeparators or tooManySeparators or signal NameTooSmall.    BEGIN    nullDefaultRecord: NSName.NameRecord ¬ [      NSString.nullString, NSString.nullString, NSString.nullString];    hasSeparator: BOOLEAN;    localSubString, domainSubString, orgSubString: NSString.SubStringDescriptor;    offset, start: CARDINAL ¬ 0;    totalLen: CARDINAL = NSString.LogicalLength[s];    hasSeparator ¬ NSString.ScanForCharacter[NSName.separatorCharacter, s, start]      # LAST[CARDINAL];    -- now set up the sub strings    IF clientDefaults = NIL THEN clientDefaults ¬ @nullDefaultRecord;    localSubString.base ¬ domainSubString.base ¬ orgSubString.base ¬ s;    localSubString.offset ¬ 0;    IF ~hasSeparator THEN      BEGIN  -- just a local string and no domain nor org.      localSubString.length ¬ totalLen;      domainSubString ¬ [        clientDefaults.domain, 0, NSString.LogicalLength[clientDefaults.domain]];      orgSubString ¬ [        clientDefaults.org, 0, NSString.LogicalLength[clientDefaults.org]];      MakeUpNameFromStrings[        z, destination, @orgSubString, @domainSubString, @localSubString];      RETURN;      END;    -- s string contains a separator    offset ¬ NSString.ScanForCharacter[NSName.separatorCharacter, s, start];    -- offset <= totalLen always.    localSubString.length ¬ offset - localSubString.offset;    domainSubString.offset ¬ start ¬ offset + 1;    offset ¬ NSString.ScanForCharacter[NSName.separatorCharacter, s, start];    SELECT TRUE FROM      offset # LAST[CARDINAL] =>  -- found another seperator        BEGIN        domainSubString.length ¬ offset - domainSubString.offset;        orgSubString.offset ¬ start ¬ offset + 1;        END;      start >= totalLen =>  -- didn't find another because the complete string has been consumed        BEGIN        domainSubString ¬ [          clientDefaults.domain, 0, NSString.LogicalLength[          clientDefaults.domain]];        END;      ENDCASE =>  -- didn't find another; the rest of the string is the domain        BEGIN        orgSubString.offset ¬ start ¬ offset ¬ totalLen;        domainSubString.length ¬ offset - domainSubString.offset;        END;    offset ¬ NSString.ScanForCharacter[NSName.separatorCharacter, s, start];    SELECT TRUE FROM      offset # LAST[CARDINAL] => ERROR Error[tooManySeparators];      start >= totalLen =>        orgSubString ¬ [          clientDefaults.org, 0, NSString.LogicalLength[clientDefaults.org]];      ENDCASE => orgSubString.length ¬ totalLen - start;    -- now move substring into user's destination    MakeUpNameFromStrings[      z, destination, @orgSubString, @domainSubString, @localSubString];    END;   NameFromString: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, s: NSName.String, clientDefaults: NSName.Name]      RETURNS [n: NSName.Name] =      BEGIN      n _ MakeName[z, 0, 0, 0];      NameFieldsFromString [z, s, n, clientDefaults];      END;   SubdivideName: PUBLIC PROCEDURE [      s: NSName.String, callBack: PROC [NSName.Name],      clientDefaults: NSName.Name] =      BEGIN      n: NSName.Name _ NameFromString[Heap.systemZone, s, clientDefaults];      callBack[n ! UNWIND => FreeName[Heap.systemZone, n]];      FreeName[Heap.systemZone, n];      END;   -- COMPARISON OF Names.   CompareNames: PUBLIC PROCEDURE [      n1, n2: NSName.Name, ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN]      RETURNS [r: NSString.Relation _ equal] =      -- The two names are compared, ignoring case.  The org is the most      -- significant subfield;  local is the least significant subfield.      -- so you must compare them in what seems to be the most ineffecient order.      BEGIN	      IF NOT ignoreOrg THEN         r _ NSString.CompareStrings[s1: n1.org, s2: n2.org, ignoreCase: TRUE];      IF r # equal THEN RETURN;      IF NOT ignoreDomain THEN         r _ NSString.CompareStrings[n1.domain, n2.domain, TRUE];      IF r # equal THEN RETURN;      IF NOT ignoreLocal THEN         r _ NSString.CompareStrings[n1.local, n2.local, TRUE];      END;   -- SERIALIZATION:  Operations that might logically belong in Courier.   DecodeParameters: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE,      encoding: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED,      parameters: Courier.Parameters] =      BEGIN      mstream: Stream.Handle;      size: CARDINAL = LENGTH[encoding];      mstream _ MemoryStream.Create[         b: [         blockPointer: LOOPHOLE[BASE[encoding]], startIndex: 0,         stopIndexPlusOne: 2*size]];      Courier.DeserializeParameters[parameters, mstream, z         ! UNWIND => MemoryStream.Destroy[mstream]];      MemoryStream.Destroy[mstream];      END;   EncodeParameters: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, parameters: Courier.Parameters]      RETURNS [encoding: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED] =      BEGIN      mstream: Stream.Handle _ NIL;      size: CARDINAL = SizeOfSerializedData[parameters];      encoding _ DESCRIPTOR[Heap.MakeNode[z, size], size];        BEGIN	ENABLE UNWIND =>	  {Heap.FreeNode[z, BASE[encoding]];	  IF mstream # NIL THEN MemoryStream.Destroy[mstream]};        mstream _ MemoryStream.Create[          b: [blockPointer: LOOPHOLE[BASE[encoding]],	  startIndex: 0,  stopIndexPlusOne: 2*size]];        Courier.SerializeParameters[parameters, mstream];	END;      MemoryStream.Destroy[mstream];      RETURN[encoding];      END;   FreeEncodedParameters: PUBLIC PROCEDURE [      z: UNCOUNTED ZONE, encoding: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED] =      BEGIN IF BASE[encoding] # NIL THEN Heap.FreeNode[z, BASE[encoding]]; END;   SizeOfSerializedData: PUBLIC PROCEDURE [parameters: Courier.Parameters]      RETURNS [sizeInWords: CARDINAL] =      BEGIN      position: Stream.Position _ 0;      streamObject: Stream.Object _ [         options: Stream.defaultInputOptions, getByte: NIL, putByte: PutByte,         getWord: NIL, putWord: PutWord, get: NIL, put: Put, setSST: NIL,         sendAttention: NIL, waitAttention: NIL, delete: NIL,         getPosition: GetPosition, setPosition: NIL, sendNow: SendNow, clientData: NIL];      stream: Stream.Handle = @streamObject;      PutByte: PROCEDURE [sH: Stream.Handle, byte: Environment.Byte] =         BEGIN position _ position + 1; END;      PutWord: PROCEDURE [sH: Stream.Handle, word: Environment.Word] =         BEGIN position _ position + Environment.bytesPerWord; END;      Put: PROCEDURE [         sH: Stream.Handle, block: Environment.Block, endRecord: BOOLEAN] =         BEGIN         position _ position + block.stopIndexPlusOne - block.startIndex;         END;      GetPosition: PROCEDURE [sH: Stream.Handle]         RETURNS [p: Stream.Position _ position] = BEGIN END;      SendNow: PROCEDURE [sH: Stream.Handle, endRecord: BOOLEAN] = BEGIN END;      -- mainline code for SizeOfSerializedData      Courier.SerializeParameters[parameters, stream];      sizeInWords _         (Inline.LowHalf[position] + Environment.bytesPerWord -             1)/Environment.bytesPerWord;      END;            DescribeNameRecord: PUBLIC Courier.Description =      BEGIN      name: NSName.Name _ notes.noteSize[SIZE[NSName.NameRecord]];      notes.noteParameters[@name.org, NSString.DescribeString];      notes.noteParameters[@name.domain, NSString.DescribeString];      notes.noteParameters[@name.local, NSString.DescribeString];      END;      -- PRIVATE OPERATIONS:      MakeUpNameFromStrings: PROCEDURE [      z: UNCOUNTED ZONE, destination: NSName.Name,      orgSubString, domainSubString, localSubString: NSString.SubString] =      BEGIN      orgLen, domainLen, localLen: CARDINAL;      setOrgLen, setDomainLen, setLocalLen: BOOLEAN;            DO      setOrgLen _ setDomainLen _ setLocalLen _ TRUE;      IF destination.org.bytes = NIL THEN         BEGIN	 destination.org _ NSString.MakeString[z, orgSubString.base.length];	 destination.org _ NSString.AppendSubString[	    destination.org, orgSubString];	 END      ELSE         BEGIN	 destination.org.length _ 0;	 destination.org _ NSString.AppendSubString[            destination.org, orgSubString !            NSString.StringBoundsFault =>               BEGIN               -- in new NSString package increaseBy is an argument to the signal.               -- increaseBy is not an argument in the old package.               orgLen _ destination.org.maxlength + increaseBy;	       setOrgLen _ FALSE;               CONTINUE;               END];	 END;      IF setOrgLen THEN orgLen _ destination.org.length;            IF destination.domain.bytes = NIL THEN         BEGIN	 destination.domain _ NSString.MakeString[z, domainSubString.base.length];	 destination.domain _ NSString.AppendSubString[	    destination.domain, domainSubString];	 END      ELSE         BEGIN         destination.domain.length _ 0;	 destination.domain _ NSString.AppendSubString[            destination.domain, domainSubString !            NSString.StringBoundsFault =>               BEGIN               -- in new NSString package increaseBy is an argument to the signal.               -- increaseBy is not an argument in the old package.               domainLen _ destination.domain.maxlength + increaseBy;	       setDomainLen _ FALSE;               CONTINUE;               END];	 END;      IF setDomainLen THEN domainLen _ destination.domain.length;            IF destination.local.bytes = NIL THEN         BEGIN	 destination.local _ NSString.MakeString[z, localSubString.base.length];	 destination.local _ NSString.AppendSubString[	    destination.local, localSubString];	 END      ELSE         BEGIN         destination.local.length _ 0;	 destination.local _ NSString.AppendSubString[            destination.local, localSubString !            NSString.StringBoundsFault =>               BEGIN               -- in new NSString package increaseBy is an argument to the signal.               -- increaseBy is not an argument in the old package.               localLen _ destination.local.maxlength + increaseBy;	       setLocalLen _ FALSE;               CONTINUE;               END];	 END;      IF setLocalLen THEN localLen _ destination.local.length;      IF setLocalLen AND setDomainLen AND setOrgLen THEN         BEGIN	 --fix last byte for odd length strings.	 IF (destination.local.length MOD 2) = 1 THEN	    destination.local.bytes[destination.local.length] _ 0;	 IF (destination.domain.length MOD 2) = 1 THEN	    destination.domain.bytes[destination.domain.length] _ 0;	 IF (destination.org.length MOD 2) = 1 THEN	    destination.org.bytes[destination.org.length] _ 0;	 RETURN	 END;            -- some part was too small - try again      destination _ SIGNAL NameTooSmall[         destination, orgLen, domainLen, localLen];      ENDLOOP;      END;   END.LOG  ( date - person - action )September 2, 1982 - Kiser & Liu - Renamed operations, variables, etc from old NSName; merged operations from NSFileCourierUtilityImpl, SimpleAuthenticatorImpl, NSSessionImpl, ExtendedAttributePack 8-Sep-82 - Kiser - Added loop in MakeUpNameFromStrings to retry when NameTooSmall is resumed.10-Sep-82 - Liu - fixed bugs in MakeUpNameFromStrings; added a case to handlenullCredentials in DecodeSimpleCredentials; removed NameTooSmall catch phrase fromNameFromString.13-Sep-82 - Liu - fixed a bug for a string scanning with no separator in NameFieldsFromString.27-Sep-82 - Liu - making noteSize[2] in DescribeVerifier. 8-Oct-82 - Liu - fix last byte of odd length string names in MakeUpNameFromStrings. 3-Nov-82 - Liu - fixed bug in CopyNameFields: using the logical length as the max length of the substrings; fixed a bug in MakeUpNameFromStrings: using the base length instead of the logical length of a substring to make a new string. 3-Dec-82 - Liu - fixed a bug in SubdivideName (UNWIND frees a Name, but normal operation does not).20-Dec-82 - Liu - put back lost fixed on 2-Dec-82: added UNWIND catch in DecodeParameters and EncodeParameters to get rid of the created memory stream.April 20, 83 - Liu - upgraded to Klamath courier interface.May 2, 1983 - Liu - set clientData: NIL in Stream.Object initialization in SizeOfSerializedData procedure.May 2, 1983 - Liu - remove mdsZone: MDSZone parameter from DecodeParameters.11-Nov-83  9:54:08 - Saund - Deleted Authentication Support 4-Jan-84  9:55:41 - Alfvin - Added export of InitNameStore and wildCardSeparatorString 11-Apr-84 17:13:13 - Saund - Fixed bug in AppendNameToString.  Ostensibly Brenda changed the code but was not setting nullOrg appropriately. 19-Jun-87 - Holbrook - WS AR 12604 Change for svs 8.0.13: fold in Services 10.0 of NameFieldsFromString to eliminate support of '@ as delimiter 
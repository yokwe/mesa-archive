-- NSStringImpl.mesa-- Last edited by Alfvin, 19-Apr-84 18:17:09<<  Overview:  Implementation of basic NSString (network string) operations.  Temporarily, this module rolls its own ordering algorithm; eventually, it should call upon the workstation CharDefs modules so that all treatment of characters/strings is standard. >>DIRECTORY  Courier USING [Description],  Environment USING [Byte],  Inline USING [DIVMOD, HighHalf, LongCOPY, LowHalf],  NSString USING [Character, Characters, MesaString, nullString, Relation, String, SubString],  NSStringPriv USING [Bytes, BytesPointer],  String USING [StringBoundsFault],  XChar USING [Character, LowerCase, Make, UpperCase, not],  XFormat USING [Decimal, Error, NSStringObject, Number, NumberFormat, Object, Octal],  XString USING [AppendChar, AppendReader, ByteLength, Character, CharacterLength, Compare, Error, First, FromNSString, InsufficientRoom, InvalidEncoding, InvalidNumber, Lop, Map, MapCharProc, NthCharacter, nullReaderBody, Overflow, Piece, ReaderBody, ReaderFromWriter, ReaderToNumber, Relation, ReplacePiece, ValidateReader, WriterBody, WriterBodyFromNSString, WriterBodyFromSTRING],  XStringExtra USING [CompareStringsAndStems];NSStringImpl: PROGRAM  IMPORTS Inline, MString: String, XFormat, XChar, XString, XStringExtra  EXPORTS NSString  SHARES XString =  BEGIN OPEN NSString, NSStringPriv;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ PRIVATE PACK DATA STRUCTURES :  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ Private Types :Byte: TYPE = Environment.Byte;CharacterSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Character];  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ Private Constants :  selectCode: Byte = 377B;  sp: WORD = 40B; -- Ascii.SP  defaultChset: Byte = 0;---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ SIGNALS AND ERRORS :---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  InvalidNumber: PUBLIC ERROR = CODE;  InvalidString: PUBLIC ERROR = CODE;  StringBoundsFault: PUBLIC SIGNAL [old: String, increaseBy: CARDINAL]    RETURNS [new: String] = CODE;---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ PUBLIC OPERATIONS :---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ Basic String Operations:-- APPEND operations.  If String ever becomes a pointer, then the RETURN values should go away.  AppendCharacter: PUBLIC PROC [to: String, from: Character]    RETURNS [String] =    -- Append the specified character to the end of the specified string.    BEGIN    writerBody: XString.WriterBody;    c: XString.Character _ LOOPHOLE[from];    DO  -- until we've successfully completed      IF to = nullString THEN ERROR InvalidString;      writerBody _ XString.WriterBodyFromNSString[to];      XString.AppendChar[@writerBody, c !	XString.InsufficientRoom => {	  UpdateString[@to, writerBody];	  to _ SIGNAL StringBoundsFault[to, amountNeeded];	  LOOP}];      UpdateString[@to, writerBody];      RETURN [to];      ENDLOOP;    END;  -- of AppendCharacter  AppendDecimal: PUBLIC PROC [s: String, n: INTEGER] RETURNS [String] =    -- Convert the value of n to radix 10 text and append it to s.    -- Supply a leading minus sign if n is negative.    BEGIN    nso: XFormat.Object _ XFormat.NSStringObject[@s];    ln: LONG INTEGER _ n;    XFormat.Decimal[@nso,  ln ! XFormat.Error => ERROR InvalidNumber];    RETURN [s];    END;  -- of AppendDecimal  AppendLongDecimal: PUBLIC PROC [s: String, n: LONG INTEGER] RETURNS [String] =    -- Analgous to AppendDecimal    BEGIN    nso: XFormat.Object _ XFormat.NSStringObject[@s];    XFormat.Decimal[@nso,  n ! XFormat.Error => ERROR InvalidNumber];    RETURN [s];    END;  -- of AppendLongDecimal  AppendLongNumber: PUBLIC PROC [      s: String, n: LONG UNSPECIFIED, radix: CARDINAL _ 10] RETURNS [String] =    -- Analgous to AppendNumber    BEGIN    nso: XFormat.Object _ XFormat.NSStringObject[@s];    NumberFormat: XFormat.NumberFormat = [      base: radix, zerofill: FALSE, signed: FALSE, columns: 0];    XFormat.Number[@nso, n, NumberFormat!      XFormat.Error => ERROR InvalidNumber];    RETURN [s];    END;  -- of AppendLongNumber  AppendNumber: PUBLIC PROC [s: String, n: UNSPECIFIED, radix: CARDINAL _ 10]    RETURNS [String] = { RETURN AppendLongNumber[s, LONG[n], radix] };    -- Convert the value of n to text using radix and append it to s.    -- radix sould be in the interval [2..36].    AppendOctal: PUBLIC PROC [s: String, n: UNSPECIFIED] RETURNS [String] =    -- Convert the value of n to radix 8 text and append it to s.    -- Append a "B".    BEGIN    nso: XFormat.Object _ XFormat.NSStringObject[@s];    XFormat.Octal[@nso,  LONG[n] ! XFormat.Error => ERROR InvalidNumber];    RETURN [s];    END;  -- of AppendOctal  AppendString: PUBLIC PROC [to: String, from: String] RETURNS [String] =    -- Append the specified string to the end of the specified string.    BEGIN    wBody: XString.WriterBody;    rBody: XString.ReaderBody _ XString.FromNSString[from];    DO      IF from.length = 0 THEN RETURN [to]      ELSE	BEGIN	wBody _ XString.WriterBodyFromNSString[to];	XString.AppendReader[@wBody, @rBody!	  XString.InsufficientRoom => {	    UpdateString[@to, wBody];	    to _ SIGNAL StringBoundsFault[to, amountNeeded]; LOOP}];	UpdateString[@to, wBody];	RETURN[to];	END;      ENDLOOP;    END;  -- of AppendString  AppendSubString: PUBLIC PROC [to: String, from: SubString]    RETURNS [String] =    --  Append the substring to the end of the specified string.    BEGIN    wBody: XString.WriterBody;    rBody: XString.ReaderBody _ XString.FromNSString[from.base];    fromBody: XString.ReaderBody _ XString.Piece[      @rBody, from.offset, from.length].piece;    DO      IF from.base.length = 0 THEN RETURN [to]      ELSE	BEGIN	wBody _ XString.WriterBodyFromNSString[to];	XString.AppendReader[@wBody, @fromBody!	  XString.InsufficientRoom => {	    UpdateString[@to, wBody];	    to _ SIGNAL StringBoundsFault[to, amountNeeded]; LOOP}];	UpdateString[@to, wBody];	RETURN[to];	END;      ENDLOOP    END;  -- of AppendSubString---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------Comparisons:  CompareStrings: PUBLIC PROC [s1, s2: String, ignoreCase: BOOLEAN]    RETURNS [Relation] =    -- Compare the strings, ignoring the case if specified.    BEGIN    x1: XString.ReaderBody _ XString.FromNSString[s1];    x2: XString.ReaderBody _ XString.FromNSString[s2];    RETURN LOOPHOLE[XString.Compare[@x1, @x2, ignoreCase]];    END;  -- of CompareStrings  CompareStringsAndStems: PUBLIC PROC [s1, s2: String, ignoreCase: BOOLEAN]    RETURNS [relation: Relation, equalStems: BOOLEAN] =    -- Compare the strings, ignoring the case if specified. "equalStems" is    -- TRUE if the strings are equal up to the length of the shortest String.    BEGIN    x1: XString.ReaderBody _ XString.FromNSString[s1];    x2: XString.ReaderBody _ XString.FromNSString[s2];    rel: XString.Relation;    [rel, equalStems] _       XStringExtra.CompareStringsAndStems[@x1, @x2, ignoreCase];    RETURN [VAL[rel], equalStems]    END;  -- of CompareStringsAndStems  CompareStringsTruncated: PUBLIC PROC [    s1, s2: String, trunc1, trunc2: BOOLEAN, ignoreCase: BOOLEAN]    RETURNS [Relation] =    -- Compare the strings, ignoring the case if specified, and doing    -- the right thing with truncated strings (they are treated as <string>*).    -- This should be replaced with right thing for fully international strings.    BEGIN    basicRelation: Relation;    equalStems: BOOLEAN;    [basicRelation, equalStems] _ CompareStringsAndStems[s1, s2, ignoreCase];    RETURN[SELECT basicRelation FROM      less => IF trunc1 AND equalStems THEN equal ELSE less,      greater => IF trunc2 AND equalStems THEN equal ELSE greater,      ENDCASE -- equal -- => SELECT TRUE FROM	trunc1 = trunc2 => equal,	trunc1 => greater,  -- first string is really longer	ENDCASE -- trunc2 -- => less];  -- second string is really longer    -- The full decision table for this is at the end of the module.    END;  -- of CompareStringsTruncated  CompareSubStrings: PUBLIC PROC [s1, s2: SubString, ignoreCase: BOOLEAN _ TRUE]    RETURNS [Relation] =    --  Compare the substrings, ignoring the case if specified.    BEGIN    x1: XString.ReaderBody _ XString.FromNSString[s1.base];    x2: XString.ReaderBody _ XString.FromNSString[s2.base];    pc1: XString.ReaderBody _ XString.Piece[@x1, s1.offset, s1.length].piece;    pc2: XString.ReaderBody _ XString.Piece[@x2, s2.offset, s2.length].piece;    RETURN LOOPHOLE[XString.Compare[@pc1, @pc2, ignoreCase]];    END;---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ Misc:  CopyString: PUBLIC PROC [z: UNCOUNTED ZONE, s: String] RETURNS [new: String] =    BEGIN    IF s = nullString THEN RETURN[nullString];    new _ MakeString[z, s.length];    Inline.LongCOPY[from: s.bytes, to: new.bytes, nwords: (s.length + 1)/2];    new.length _ s.length;    END;  -- of CopyString  DeleteSubString: PUBLIC PROC [s: SubString] RETURNS [String] =    -- Delete the specified SubString from its parent string    BEGIN    wb: XString.WriterBody _ XString.WriterBodyFromNSString[s.base];    localBody: XString.ReaderBody _ XString.nullReaderBody;    XString.ReplacePiece[@wb, s.offset, s.length, @localBody];    UpdateString[@s.base, wb];    RETURN [s.base];    END;  -- of DeleteSubString  EqualCharacter: PUBLIC PROC [c: Character, s: String, index: CARDINAL]    RETURNS [BOOLEAN] =    -- TRUE if the character indicated by the string index is equal to the    -- given character.  index is a logical character index, not a byte index.    BEGIN    rb: XString.ReaderBody _ XString.FromNSString[s];    RETURN[IF XString.NthCharacter[@rb, index] = FromNSSChar[c] THEN TRUE     ELSE FALSE];    END;  -- of EqualCharacter  ExpandString: PUBLIC PROC [z: UNCOUNTED ZONE, s: String]    RETURNS [Characters] =    -- this now allocates more space than nec. (up to twice the amount)    -- but in the normal case (homogenous char set), it will be the right amount    -- this reduces the execution time to 1/2 its former.    BEGIN    array: LONG POINTER TO CharacterSequence;    rb: XString.ReaderBody _ XString.FromNSString[s];    i: CARDINAL _ 0;    c: XString.Character;    array _ z.NEW [CharacterSequence [s.length]];  -- create the array    UNTIL (c _ QuickLop[@rb])=XChar.not DO 	-- fill the array      array[i] _ LOOPHOLE[c];      i _ i+1      ENDLOOP;    RETURN [DESCRIPTOR [array, i]];    END;  -- of ExpandString  -- Copied from XStringCompareImpl  QuickLop: PROCEDURE [r: POINTER TO XString.ReaderBody] RETURNS [XString.Character] = INLINE    BEGIN    SELECT TRUE FROM      (r.offset = r.limit) => RETURN[XChar.not];      (r.context.suffixSize) = 2 => RETURN[XString.Lop[r]];      ENDCASE =>        BEGIN        byte: Environment.Byte _ r.bytes[r.offset];        IF byte = selectCode THEN RETURN[XString.Lop[r]];        r.offset _ r.offset +1;        RETURN[XChar.Make[set: r.context.prefix, code: byte]];        END;    END;  -- of QuickLop  FreeCharacters: PUBLIC PROC [z: UNCOUNTED ZONE, c: Characters] =    BEGIN	-- Free a character array allocated by ExpandString.    array: LONG POINTER TO CharacterSequence _ LOOPHOLE [BASE [c]];    IF array # NIL THEN z.FREE[@array];    END;  -- of FreeCharacters  FreeString: PUBLIC PROC [z: UNCOUNTED ZONE, s: String] =    { IF s.bytes # NIL THEN z.FREE[@(LOOPHOLE[s.bytes, BytesPointer])] };  LogicalLength: PUBLIC PROC [s: String] RETURNS [total: CARDINAL] =    -- Returns the number of NS characters in the string.    BEGIN    rb: XString.ReaderBody _ XString.FromNSString[s];    RETURN XString.CharacterLength[@rb];    END;  -- of LogicalLength  MakeString: PUBLIC PROC [z: UNCOUNTED ZONE, bytes: CARDINAL]    RETURNS [new: String] =    { new _ IF bytes = 0 THEN nullString ELSE      [bytes: LOOPHOLE[z.NEW[Bytes [bytes]]], length: 0, maxlength: bytes] };  ScanForCharacter: PUBLIC PROC [c: Character, s: String, start: CARDINAL]    RETURNS [CARDINAL] =    -- Scan the string for the specified character from the given starting    -- point.  start and return value are logical character indices,    -- not byte indices.  Failure is indicated by returning LAST [CARDINAL].    -- provided my own implementation rather than use XString.Scan    -- because that is too general and 4 times as expensive    BEGIN OPEN char: c;    count: CARDINAL _ 0;    found: BOOLEAN _ FALSE;    rb: XString.ReaderBody _ XString.FromNSString[s];    FindChar: XString.MapCharProc --[c: Character] RETURNS [stop: BOOLEAN]-- =      BEGIN      IF count >= start AND FromNSSChar[char] = c THEN found _ TRUE      ELSE count _ count+1;      stop _ found;      END;    IF start > s.length THEN RETURN [LAST[CARDINAL]];    [] _ XString.Map[@rb, FindChar];    RETURN[IF found THEN count ELSE LAST[CARDINAL]];    END;	-- proc. ScanForCharacter  StringToLongNumber: PUBLIC PROC [s: String, radix: CARDINAL _ 10]    RETURNS [LONG UNSPECIFIED] =    -- Convert the specified string to a numeric value.    -- Raises InvalidNumber if s does not represent a valid number.    BEGIN    rb: XString.ReaderBody _ XString.FromNSString[s];    WHILE XString.First[@rb] = sp DO [] _ XString.Lop[@rb] ENDLOOP;    RETURN LOOPHOLE[XString.ReaderToNumber[@rb, radix, TRUE !      XString.InvalidNumber, XString.Overflow => ERROR InvalidNumber]]    END;  -- of StringToLongNumber  StringToNumber: PUBLIC PROC [s: String, radix: CARDINAL _ 10] RETURNS [UNSPECIFIED] =    -- Convert the specified string to a numeric value.    -- Raises InvalidNumber if s does not represent a valid number.    -- Call made to StringToLongNumber.    -- If HighHalf is LAST[CARDINAL] THEN we are treating a negative quantity.    BEGIN    lu: LONG UNSPECIFIED _ StringToLongNumber[s, radix];    InvalidHighWord: PROC RETURNS [BOOLEAN] = INLINE {      IF CARDINAL[Inline.HighHalf[lu]] = 0 OR	CARDINAL[Inline.HighHalf[lu]] = LAST[CARDINAL] THEN	RETURN [FALSE] ELSE RETURN [TRUE]};    IF InvalidHighWord[] THEN ERROR InvalidNumber    ELSE RETURN Inline.LowHalf[lu];    END;  -- of StringToNumber  TruncateString: PUBLIC PROC [s: String, bytes: CARDINAL] RETURNS [String] = {    IsSelect: PROC [i: CARDINAL] RETURNS [BOOLEAN] = INLINE {      RETURN[s.bytes[i]=selectCode]};    IF s.length > bytes THEN {      suffixSize: CARDINAL _ 1;      i: CARDINAL _ bytes;      UNTIL i=0 DO        i _ i-1;        SELECT TRUE FROM	  ~IsSelect[i] => LOOP;	  i=0 => NULL;	  IsSelect[i-1] => {suffixSize _ 2; i _ i-1};	  ENDCASE;	bytes _ SELECT bytes-i FROM	  < 2*suffixSize+1 => i,	-- formula for minimum run length	  ENDCASE => bytes-Inline.DIVMOD[bytes+1-i, suffixSize].remainder;	EXIT;	ENDLOOP;      s.length _ bytes};    RETURN[s]};  -- of TruncateString  -- Copied from XStringCompareImpl  LowerCase: PUBLIC PROC [c: Character] RETURNS [Character] =    {RETURN[LOOPHOLE[XChar.LowerCase[FromNSSChar[c]]]]};  UpperCase: PUBLIC PROC [c: Character] RETURNS [Character] =    {RETURN[LOOPHOLE[XChar.UpperCase[FromNSSChar[c]]]]};  WellFormed: PUBLIC PROC [s: String] RETURNS [BOOLEAN] =    -- TRUE if the string contains a valid sequence of bytes.    BEGIN    rb: XString.ReaderBody _ XString.FromNSString[s];    XString.ValidateReader[@rb !      XString.InvalidEncoding => GOTO false;      XString.Error => GOTO false];    RETURN[TRUE];    EXITS       false => RETURN [FALSE];    END;  -- of WellFormed  -- Returns the number of words needed.  WordsForString: PUBLIC PROC [bytes: CARDINAL] RETURNS [CARDINAL] =    { RETURN[(bytes + 1)/2] };---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ Routines for Interconverting NSStrings and MesaStrings:  StringFromMesaString: PUBLIC PROC [s: MesaString] RETURNS [String] =    -- Return a String which contains the same bytes as in the Mesa string.    { RETURN[IF s = NIL THEN nullString ELSE String[	bytes: LOOPHOLE[@s.text], length: s.length, maxlength: s.maxlength]] };  AppendToMesaString: PUBLIC PROC [to: MesaString, from: String] =    -- Append the bytes in the String to the end of the Mesa string.    BEGIN    wb: XString.WriterBody;    rb: XString.ReaderBody _ XString.FromNSString[from];    UpdateMesaString: PROC = {      to.length _ XString.ByteLength[XString.ReaderFromWriter[@wb]]};    DO      IF to = NIL THEN ERROR InvalidString;      wb _ XString.WriterBodyFromSTRING[to];      XString.AppendReader[@wb, @rb !	XString.InsufficientRoom => {	  UpdateMesaString[];	  to _ SIGNAL MString.StringBoundsFault[to]; LOOP}];      UpdateMesaString[];      RETURN;      ENDLOOP;    END;  -- of AppendToMesaString  ValidAsMesaString: PUBLIC PROC [s: String] RETURNS [BOOLEAN] =    -- TRUE if all characters in the string are valid Mesa characters.    BEGIN    i: CARDINAL _ 0;    WHILE i < s.length DO      SELECT s.bytes[i] FROM	selectCode => RETURN[FALSE];	ENDCASE;      i _ i + 1;      ENDLOOP;    RETURN[TRUE];    END;  -- of ValidAsMesaString---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ COURIER DESCRIPTIONS  DescribeString: PUBLIC Courier.Description =    BEGIN    DescribeStringBytes: Courier.Description =      { [] _ notes.noteSize[WordsForString[length]] };    s: LONG POINTER TO NSString.String = notes.noteSize[SIZE[NSString.String]];    length: CARDINAL;    SELECT notes.operation FROM      store =>         { notes.noteSpace[@length, SIZE[CARDINAL]]; -- get length from stream	  s.maxlength _ s.length _ length };      fetch => { length _ s.length; notes.noteSpace[@length, SIZE[CARDINAL]] };	 -- put length to stream      free => length _ s.maxlength;         -- makes noteDisjointData free a zero length string      ENDCASE;    notes.noteDisjointData[@s.bytes, DescribeStringBytes];    notes.noteDeadSpace[@s.length, 2*SIZE[CARDINAL]];   -- ignore rest of record    END; -- DescribeString---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ------ PRIVATE OPERATIONS   UpdateString: PROCEDURE [s: LONG POINTER TO String, wb: XString.WriterBody]=     { s.length _ XString.ByteLength[XString.ReaderFromWriter[@wb]] };    FromNSSChar: PROC [c: Character] RETURNS [XString.Character] = INLINE      { RETURN [LOOPHOLE[c]] };  END.  -- of NSStringImplUSE OF CompareStringsAndStems FOR TRUNCATED STRINGS:(actual relation when results are <[T,F], =[T,F], >[T,F])no truncation:  <[T: <,F: <], =[T: =,F: X], >[T: >,F: >]s1 truncated:  <[T: =,F: <], =[T: >,F: X], >[T: >,F: >]s2 truncated:  <[T: <,F: <], =[T: <,F: X], >[T: =,F: >]both truncated:  <[T: =,F: <], =[T: =,F: X], >[T: =,F: >]LOG  ( date - person - action )March 27, 1981 - Kabcenell - Creation.April 8, 1981 - Kabcenell - Added TruncateString; changed tags on some arguments.May 12, 1981 - Kabcenell - Added CompareStringsAndStems and CompareStringsTruncated.May 20, 1981 - Kabcenell - Corrected handling of StringBoundsFault.August 18, 1981 - Tripp - Add GetJStarCode.2-Sep-81 15:11:33 - Newman - CopyString [nullString] returns nullString instead of allocating a zero-length string.September 4, 1981 - Kabcenell - Changed CompareStringsAndStems to not call JStar code for non-JStar characters.September 15, 1981 - Kabcenell - In CompareStringsAndStems, "equalStems" was not initialized.September 18, 1981 - Kabcenell - Change FreeString to ignore nullString.15-Jan-82 - Buelow - Trinity conversion changes for 4.2 8-Feb-82 15:32:37 - Hamilton - Replace InitJSortTable with GetJStarTable (which export to JISCodes). 1-Mar-82 15:36:16 - Hamilton - For Services, add substring stuff, StringToDecimal, InvalidNumber.  Skip over accent character (in BumpContext) for EStar.15-Mar-82 17:32:29 - Hamilton - Add NSStrivPriv interface.18-Mar-82 21:03:03 - Hamilton - Fix AppendSubString. 3-May-82 11:47:24 - Hamilton - Fix InitContextBegin by adding ignoreAccents BOOLEAN.  Move all but exported TYPEs into NSStringPriv. 3-Jun-82 15:19:16 - Hamilton - Implement DeleteSubString and CompareSubstrings.  Create CompareInternal. 1-Aug-82 17:09:57 - Hamilton - Removed "string" arg from InitContextBegin & require its clients to pass that in by initializing context.string.  Required since SubString became a pointer. 5-Aug-82 18:06:02 - Kabcenell - Implemented "increaseBy" in StringBoundsFault; implemented ExpandString and FreeCharacters.23-Aug-82 11:49:15 - Kabcenell - Implemented forgotten operations UpperCase, LowerCase. 3-Sep-82 - Liu - replaced NSStringPriv.CharacterI by NSString.Character. 8-Sep-82 14:28:59 - Kiser - MakeString returns nullString if bytes = 0.September 27, 1982 - Hanzel - Correct AppendToMesaString so that StringBoundsFault is raised if 'to' is not long enough, not InvalidString; also changed StringToLongNumber and StringToNumber to agree with this change.September 29, 1982 - Hanzel - Add explicit return within AppendToMesaString to avoid looping.21-Oct-82 13:36:55 - Kiser - Change FreeString to check for bytes=NIL rather than nullString; changed DescribeString to set maxlength = 0 if bytes=NIL.Octbober 21, 1982 - Hanzel - Corrected FreeString to check for bytes # NIL.19-Nov-82 13:08:47 - Kiser - Changed checkForStarEscape to FALSE.April 20, 83 - Liu - upgraded to Klamath courier interface.19-Feb-84 13:24:28 - Saund - Layered NSString sorts over XString sorts.19-Feb-84 14:08:54 - Saund - Removed all references to JSort stuff20-Feb-84 22:02:23 - Saund - Layered NSString Append operations over XString.22-Feb-84 10:59:17 - Saund - Layered NSString ScanInternal over XString.27-Feb-84 14:06:45 - Saund - fixed CompareSubString bug27-Feb-84 14:49:44 - Saund - Revised and trimmed down the whole implementation28-Feb-84 11:50:20 - Saund - Put back LowerCase and UpperCase.4-Apr-84 14:48:33 - Brenda Hankins - removed Scan Internal, reimplemented ScanForCharacter and altered ExpandString.10-Apr-84 16:15:11 - Alfvin - Redefined case operations in term of XChar operations.16-Apr-84 15:22:01 - Alfvin - Added full XC support to Expand/Truncate string.19-Apr-84 18:17:27 - Alfvin - Add revised DescribeString.
-- NSSessionImpl.mesa-- Last revised by: Saund on:         31-May-84 10:29:18--To do:--    o Remove use of "localSEActual" when all clients use "localSystemElement"DIRECTORY  Courier USING [LocalSystemElement],  Heap USING [Create, FreeNode, systemZone],  Inline USING [LowHalf],  NSName USING [CopyName, FreeName, Name],  NSSession USING [    Attributes, AttributesRef, Context, ContextID, EnumerateProc,    ErrorType, localSystemElement, nullContextID, Reason, Restrictions,    RestrictionSelections, Session, SystemElement, TerminationHandler],  NSString USING [FreeString, nullString, String],  Process USING [Detach, InitializeMonitor, Seconds, SecondsToTicks, SetTimeout],  System USING [GetGreenwichMeanTime, GreenwichMeanTime,    NetworkAddress, SecondsSinceEpoch];NSSessionImpl: MONITOR LOCKS data[id] USING id: ClientID  IMPORTS Courier, Heap, Inline, NSName, NSString, Process, System EXPORTS NSSession =  BEGIN OPEN NSSession;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- TYPES  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [SEQUENCE COMPUTED ClientID OF DataObject];  DataObject: TYPE = MONITORED RECORD [    vector: SessionHandleVectorObject _ [], restrictList: RestrictList _ NIL];  SessionHandleVectorObject: TYPE = RECORD [    sHCount: CARDINAL _ 0,    maxSHCount: CARDINAL _ 0,    sessionHandleVectorDescriptor: SessionHandleVectorDescriptor _ NIL];  SessionHandleVector: TYPE = RECORD [    SEQUENCE COMPUTED CARDINAL OF SessionInternal];  SessionHandleVectorDescriptor: TYPE = LONG DESCRIPTOR FOR ARRAY [1..1] OF    SessionInternal;  SessionInternal: TYPE = LONG POINTER TO SessionObject;  SessionObject: TYPE = RECORD [    clientID: ClientID,    stamp: CARDINAL _ 0,  -- time stamp for validation    sessionInUse: BOOLEAN _ FALSE,    sessionAttributes: NSSession.Attributes,    enterSessionCount: CARDINAL _ 0,    lockClientIDRefCount: CARDINAL _ 0,    contextList: ContextList];  ContextInternal: TYPE = LONG POINTER TO ContextObject;  ContextList: TYPE = LONG POINTER TO ContextObject;  ContextObject: TYPE = RECORD [    contextID: NSSession.ContextID,    serviceDataInitialized: BOOLEAN,    context: NSSession.Context,    terminationHandler: NSSession.TerminationHandler,    next: ContextList];  RestrictList: TYPE = LONG POINTER TO RestrictObject;  RestrictObject: TYPE = RECORD [    restrictions: NSSession.Restrictions,    totalSessions: CARDINAL _ 0,    next: RestrictList _ NIL];  ClientID: PUBLIC TYPE = CARDINAL [0..20];  maxStringLength: CARDINAL = 100;  InternalHandle: TYPE = RECORD [timeStamp, index: CARDINAL];  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- SIGNALS AND ERRORS  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  InternalError: ERROR [internalErrorType: InternalErrorType];  InternalErrorType: TYPE = {    inconsistentCountsInAllocateSessionHandle, incorrectRefCount};  Error: PUBLIC ERROR [type: ErrorType] = CODE;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  -- CONSTANTS  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  maxSessions: CARDINAL = 8;  sizeSessionVector: CARDINAL = 8;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  -- Global variables in the Monitored frame  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  currentStamp: CARDINAL _ Inline.LowHalf[    System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]]];  globalClientID: CARDINAL _ 0;  globalNumberOfSessions: CARDINAL _ 0;  localSEActual: System.NetworkAddress;  -- see mainline  nullClientID: ClientID = 0;  nullSession: Session _ LOOPHOLE[InternalHandle[0, LAST[CARDINAL]]];  sessionZone: UNCOUNTED ZONE = Heap.Create[    initial: 2, increment: 4, ownerChecking: FALSE, checking: FALSE];  data: DataHandle = sessionZone.NEW[Data [20]];  sessionExit: CONDITION;  inactiveSessionCondition: CONDITION;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- OPERATIONS  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- Create creates a new session on the local machine.  Create: PUBLIC ENTRY PROCEDURE [    id: ClientID, name: NSName.Name _ NIL, isPrivileged: BOOLEAN _ FALSE,    timeOut: BOOLEAN _ FALSE, systemElement: SystemElement _ localSystemElement]    RETURNS [Session] =    BEGIN    ENABLE UNWIND => NULL;    sA: Attributes;    sI: SessionInternal;    time: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    IF isPrivileged AND timeOut THEN RETURN WITH ERROR Error[invalidSession];    IF ~isPrivileged AND (systemElement # localSystemElement) THEN      CheckRestrictions[id];    sA _ [NIL, time, time, systemElement, isPrivileged, timeOut];    IF name # NIL THEN sA.name _ NSName.CopyName[sessionZone, name];    sI _ sessionZone.NEW[      SessionObject _ [      clientID: id, stamp: NextStamp[], sessionAttributes: sA, contextList: NIL]];    RETURN[AssignSessionHandle[sI, id]];    END;  -- of Create  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- Destroy a session synchronously  Destroy: PUBLIC ENTRY PROCEDURE [session: Session, id: ClientID] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    DO      sessionInternal _ SessionInternalFromSessionHandle[session, id];      IF sessionInternal = NIL THEN ERROR Error[invalidSession];      IF sessionInternal.enterSessionCount = 0 THEN ERROR Error[notEntered];      IF sessionInternal.enterSessionCount > 1 THEN WAIT sessionExit ELSE EXIT;      ENDLOOP;    sessionInternal.enterSessionCount _ 0;    EndSessionInternal[session, id];    FreeSession[session, sessionInternal, id, terminate, TRUE];    END;  -- of Destroy  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- Destroys a session optionally asynch.  Terminate: PUBLIC ENTRY PROCEDURE [    session: Session, id: ClientID, wait: BOOLEAN _ TRUE]    RETURNS [terminated: BOOLEAN _ TRUE] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    DO      sessionInternal _ SessionInternalFromSessionHandle[session, id];      IF sessionInternal = NIL THEN ERROR Error[invalidSession];      IF sessionInternal.enterSessionCount # 0 THEN WAIT sessionExit ELSE EXIT;      ENDLOOP;    EndSessionInternal[session, id];    FreeSession[session, sessionInternal, id, terminate, wait];    END;  -- of Terminate  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   Enter: PUBLIC ENTRY PROCEDURE [session: Session, id: ClientID] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    DO      sessionInternal _ SessionInternalFromSessionHandle[session, id];      IF sessionInternal = NIL THEN RETURN WITH ERROR Error[invalidSession];      IF sessionInternal.sessionInUse THEN WAIT sessionExit      ELSE {sessionInternal.sessionInUse _ TRUE; EXIT};      ENDLOOP;    sessionInternal.enterSessionCount _ sessionInternal.enterSessionCount + 1;    sessionInternal.sessionAttributes.lastActiveTime _ System.GetGreenwichMeanTime[      ];    END;  -- of Enter  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  Exit: PUBLIC ENTRY PROCEDURE [session: Session, id: ClientID] =    BEGIN    ENABLE UNWIND => NULL;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    BEGIN    sI: SessionInternal = SessionInternalFromSessionHandle[session, id];    IF sI = NIL THEN RETURN WITH ERROR Error[invalidSession];    sI.sessionAttributes.lastActiveTime _ System.GetGreenwichMeanTime[];    IF sI.enterSessionCount = 0 OR NOT sI.sessionInUse THEN      RETURN WITH ERROR Error[notEntered]    ELSE sI.sessionInUse _ FALSE;    sI.enterSessionCount _ sI.enterSessionCount - 1;    BROADCAST sessionExit;    END;    END;  -- of Exit  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- Temporary Locking Interfaces Defined in NSSession Defs  Unlock: PUBLIC ENTRY PROCEDURE [session: Session, id: ClientID] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL THEN RETURN WITH ERROR Error[invalidSession];    IF sessionInternal.enterSessionCount = 0 OR sessionInternal.clientID # id      OR NOT sessionInternal.sessionInUse THEN RETURN WITH ERROR Error[notEntered]    ELSE sessionInternal.sessionInUse _ FALSE;    sessionInternal.lockClientIDRefCount _      sessionInternal.lockClientIDRefCount + 1;    BROADCAST sessionExit;    END;  -- of Unlock  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   Relock: PUBLIC ENTRY PROCEDURE [session: Session, id: ClientID] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL THEN RETURN WITH ERROR Error[invalidSession];    DO      IF sessionInternal.enterSessionCount = 0        OR sessionInternal.lockClientIDRefCount = 0 THEN        RETURN WITH ERROR Error[notEntered]      ELSE {        IF ~sessionInternal.sessionInUse THEN {          sessionInternal.sessionInUse _ TRUE; EXIT}        ELSE WAIT sessionExit};      ENDLOOP;    sessionInternal.lockClientIDRefCount _      sessionInternal.lockClientIDRefCount - 1;    END;  -- of Relock  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   GetContext: PUBLIC ENTRY PROCEDURE [    session: Session, id: ClientID, contextID: ContextID _ nullContextID]    RETURNS [Context] =    BEGIN    ENABLE UNWIND => NULL;    foundContextID: BOOLEAN;    sessionInternal: SessionInternal;    contextList: ContextList;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL OR sessionInternal.clientID # id THEN      RETURN WITH ERROR Error[invalidSession];    [foundContextID, contextList] _ FindContextID[sessionInternal, contextID];    IF ~foundContextID THEN RETURN WITH ERROR Error[notSet];    IF contextList.serviceDataInitialized THEN RETURN[contextList.context]    ELSE RETURN WITH ERROR Error[notSet];    END;  -- of GetContext  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   SetContext: PUBLIC ENTRY PROCEDURE [    session: Session, id: ClientID, context: Context,    handler: TerminationHandler _ NIL, contextID: ContextID _ nullContextID] =    BEGIN    ENABLE UNWIND => NULL;    foundContextID: BOOLEAN;    contextList, ptr: ContextList;    sessionInternal: SessionInternal;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL OR sessionInternal.clientID # id THEN      RETURN WITH ERROR Error[invalidSession];    [foundContextID, contextList] _ FindContextID[sessionInternal, contextID];    IF foundContextID THEN {      contextList.context _ context;      contextList.terminationHandler _ handler;      contextList.serviceDataInitialized _ TRUE}    ELSE      SELECT sessionInternal.contextList FROM        NIL =>          sessionInternal.contextList _ ptr _ sessionZone.NEW[            ContextObject _ [contextID, TRUE, context, handler, NIL]];        ENDCASE => {          ptr _ sessionZone.NEW[            ContextObject _ [            contextID, TRUE, context, handler, sessionInternal.contextList]];          sessionInternal.contextList _ ptr};    END;  -- of SetContext  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   DestroyContext: PUBLIC ENTRY PROCEDURE [    session: Session, id: ClientID, contextID: ContextID _ nullContextID] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    foundContextID: BOOLEAN;    contextList: ContextList;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL OR sessionInternal.clientID # id THEN      RETURN WITH ERROR Error[invalidSession];    [foundContextID, contextList] _ FindContextID[sessionInternal, contextID];    IF foundContextID THEN contextList.serviceDataInitialized _ FALSE    ELSE RETURN WITH ERROR Error[notSet];    END;  -- of DestroyContext  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- Session Attributes:  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   GetAttributes: PUBLIC ENTRY PROCEDURE [session: Session, id: ClientID]    RETURNS [AttributesRef] =    BEGIN    ENABLE UNWIND => NULL;    sessionInternal: SessionInternal;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL THEN RETURN WITH ERROR Error[invalidSession]    ELSE RETURN[@sessionInternal.sessionAttributes];    END;  -- of GetAttributes  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- Initialization Related Operations defined in NSSession Defs  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   AssignClientID: PUBLIC PROCEDURE RETURNS [ClientID] =    BEGIN    assignClientID: ENTRY PROC[id: ClientID _ nullClientID] = {      globalClientID _ globalClientID + 1};    assignClientID[]; -- internal call to make globalClientID monitored.    RETURN [globalClientID];    END;  -- of AssignClientID  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   GetRestrictions: PUBLIC ENTRY PROCEDURE [id: ClientID] RETURNS [Restrictions] =    BEGIN    ENABLE UNWIND => NULL;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    RETURN[GetClientRestrictions[id].restrictions];    END;  -- of GetRestrictions  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   SetRestrictions: PUBLIC ENTRY PROCEDURE [    id: ClientID, selections: RestrictionSelections, restrictions: Restrictions] =    BEGIN    ENABLE UNWIND => NULL;    p: RestrictList;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    p _ AllocateRestrictions[id];    IF selections[allowSessions] THEN       p.restrictions.allowSessions _ restrictions.allowSessions;    IF selections[maxSessionsAllowed] THEN        p.restrictions.maxSessionsAllowed _ restrictions.maxSessionsAllowed;    IF selections[inactivityTimeout] THEN       p.restrictions.inactivityTimeout _ restrictions.inactivityTimeout;    END;  -- of SetRestrictions  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   -- PRIVATE OR INTERNAL PROCEDURES  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   AllocateSessionHandleVector: PROCEDURE [newSize: CARDINAL]    RETURNS [sessionHandleVectorDescriptor: SessionHandleVectorDescriptor] = {    sessionHandleVectorDescriptor _ DESCRIPTOR[      sessionZone.NEW[SessionHandleVector [newSize]], newSize];    };  -- of AllocateSessionHandleVector  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   AssignSessionHandle: INTERNAL PROCEDURE [    sessionInternal: SessionInternal, id: ClientID] RETURNS [session: Session] =    BEGIN    index: CARDINAL _ 1;    IF data[id].vector.sHCount >= data[id].vector.maxSHCount THEN      GrowSessionHandleVector[id];    WHILE index <= data[id].vector.maxSHCount      AND data[id].vector.sessionHandleVectorDescriptor[index] # NIL DO      index _ index + 1; ENDLOOP;    IF index > data[id].vector.maxSHCount THEN      ERROR InternalError[inconsistentCountsInAllocateSessionHandle];    session _ LOOPHOLE[InternalHandle[sessionInternal.stamp, index]];    data[id].vector.sessionHandleVectorDescriptor[index] _ sessionInternal;    data[id].vector.sHCount _ data[id].vector.sHCount + 1;    END;  -- of AssignSessionHandle  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   CheckRestrictions: INTERNAL PROCEDURE [id: ClientID] =    BEGIN    r: RestrictList = AllocateRestrictions[id];    IF ~r.restrictions.allowSessions THEN      RETURN WITH ERROR Error[sessionsDisabled];    IF (r.totalSessions + 1) > r.restrictions.maxSessionsAllowed THEN      RETURN WITH ERROR Error[sessionsExceeded];    r.totalSessions _ r.totalSessions + 1;    END;  -- of CheckRestrictions  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  GetClientRestrictions: INTERNAL PROCEDURE [id: ClientID]    RETURNS [ptr: RestrictList _ NIL] = {    IF data[id].restrictList = NIL THEN RETURN[NIL]    ELSE RETURN [data[id].restrictList]};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  AllocateRestrictions: INTERNAL PROCEDURE [id: ClientID]    RETURNS [RestrictList _ NIL] =    BEGIN    p: RestrictList =      SELECT data[id].restrictList FROM        NIL => sessionZone.NEW[RestrictObject],        ENDCASE => GetClientRestrictions[id];    RETURN[p];    END;  -- of AllocateRestrictions  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  CopyAttributes: PUBLIC ENTRY PROCEDURE [    session: Session, id: ClientID, zone: UNCOUNTED ZONE] RETURNS [AttributesRef] =    BEGIN    sessionInternal: SessionInternal;    attributesRef: AttributesRef;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    sessionInternal _ SessionInternalFromSessionHandle[session, id];    IF sessionInternal = NIL THEN RETURN WITH ERROR Error[invalidSession];    attributesRef _ zone.NEW[Attributes];    attributesRef^ _ sessionInternal.sessionAttributes;    attributesRef.name _ NSName.CopyName[      zone, sessionInternal.sessionAttributes.name];    RETURN[attributesRef];    END;  -- of CopyAttributes  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  DeallocateAttributes: PROCEDURE [    sessionAttributes: Attributes, zone: UNCOUNTED ZONE] =    BEGIN NSName.FreeName[zone, sessionAttributes.name]; END;  -- of DeallocateAttributes  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  EndSessionInternal: INTERNAL PROCEDURE [sessionHandle: Session, id: ClientID] = {    index: CARDINAL;    data[id].vector.sHCount _ data[id].vector.sHCount - 1;    globalNumberOfSessions _ globalNumberOfSessions - 1;    index _ LOOPHOLE[sessionHandle, InternalHandle].index;    data[id].vector.sessionHandleVectorDescriptor[index] _ NIL};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        Enumerate: PUBLIC PROCEDURE [id: ClientID, enum: EnumerateProc] =    BEGIN    sessionInternal: SessionInternal _ NIL;    NextSession: ENTRY PROCEDURE [id: ClientID] RETURNS [Session _ nullSession] =      BEGIN      ENABLE UNWIND => NULL;      current: CARDINAL = LOOPHOLE[currentSession, InternalHandle].index;      last: CARDINAL = data[id].vector.maxSHCount;      FOR i: CARDINAL IN [current + 1..last] DO        sessionInternal _ data[id].vector.sessionHandleVectorDescriptor[i];        IF sessionInternal # NIL THEN          IF sessionInternal.clientID = id THEN            RETURN[LOOPHOLE[InternalHandle[sessionInternal.stamp, i]]];        ENDLOOP;      RETURN[nullSession];      END;  -- of NextSession    currentSession: Session _ LOOPHOLE[InternalHandle[timeStamp: 0, index: 0]];    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    WHILE (currentSession _ NextSession[id]) # nullSession DO      enum[currentSession, @sessionInternal.sessionAttributes]; ENDLOOP;    END;  -- of Enumerate  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  SessionCount: PUBLIC ENTRY PROCEDURE [id: ClientID] RETURNS [count: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    IF InvalidClientID[id] THEN RETURN WITH ERROR Error[invalidClientID];    count _ 0;    FOR i: CARDINAL IN [1..data[id].vector.sHCount] DO      IF ~(data[id].vector.sessionHandleVectorDescriptor[i] = NIL) THEN        IF id = data[id].vector.sessionHandleVectorDescriptor[i].clientID THEN          count _ count + 1;      ENDLOOP;    END;  -- of SessionCount  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --  FindContextID: INTERNAL PROCEDURE [    sessionInternal: SessionInternal, contextID: ContextID]    RETURNS [foundContextID: BOOLEAN, contextList: ContextList] =    BEGIN    ptr: ContextList;    FOR ptr _ sessionInternal.contextList, ptr.next UNTIL ptr = NIL DO      IF ptr.contextID = contextID THEN RETURN[(ptr # NIL), ptr]; ENDLOOP;    RETURN[FALSE, NIL];    END;  -- of FindContextID  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   FreeSession: INTERNAL PROCEDURE [    sessionHandle: Session, sessionInternal: SessionInternal, id: ClientID,    terminationReason: Reason, wait: BOOLEAN _ TRUE] =    BEGIN    contextListNext, contextListTemp: ContextList;    IF sessionInternal.lockClientIDRefCount > 0 THEN      ERROR InternalError[incorrectRefCount];    contextListNext _ sessionInternal.contextList;    IF ~sessionInternal.sessionAttributes.isPrivileged AND      sessionInternal.sessionAttributes.systemElement # localSystemElement AND      sessionInternal.sessionAttributes.systemElement.host # localSEActual.host      THEN         IF data[id].restrictList # NIL THEN data[id].restrictList.totalSessions _ 	  data[id].restrictList.totalSessions - 1;    IF contextListNext # NIL THEN {      SELECT wait FROM        TRUE =>          WHILE contextListNext # NIL DO            IF contextListNext.terminationHandler # NIL THEN {              contextListNext.terminationHandler[                sessionHandle, contextListNext.context, terminationReason,                contextListNext.contextID]};            -- Get the next linked node before deallocating            contextListTemp _ contextListNext;            contextListNext _ contextListTemp.next;            sessionZone.FREE[@contextListTemp];            ENDLOOP;        ENDCASE =>          WHILE contextListNext # NIL DO            IF contextListNext.terminationHandler # NIL THEN {              Process.Detach[                FORK contextListNext.terminationHandler[                sessionHandle, contextListNext.context, terminationReason,                contextListNext.contextID]]};            contextListTemp _ contextListNext;            contextListNext _ contextListTemp.next;            sessionZone.FREE[@contextListTemp];            ENDLOOP};  -- of IF THEN 	     IF sessionInternal.sessionAttributes.name # NIL THEN      NSName.FreeName[sessionZone, sessionInternal.sessionAttributes.name];    sessionZone.FREE[@sessionInternal];    END;  -- of FreeSession  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        FreeString: PROCEDURE [z: UNCOUNTED ZONE, s: NSString.String] = {    IF s # NSString.nullString THEN NSString.FreeString[z, s]};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        GrowSessionHandleVector: INTERNAL PROCEDURE [id: ClientID] =    BEGIN    new, old: SessionHandleVectorDescriptor;    old _ data[id].vector.sessionHandleVectorDescriptor;    new _ AllocateSessionHandleVector[LENGTH[old] + sizeSessionVector];    FOR i: CARDINAL IN [1..LENGTH[old]] DO new[i] _ old[i]; ENDLOOP;    FOR i: CARDINAL IN (LENGTH[old]..LENGTH[new]] DO new[i] _ NIL; ENDLOOP;    data[id].vector.sessionHandleVectorDescriptor _ new;    data[id].vector.sHCount _ LENGTH[old];    data[id].vector.maxSHCount _ LENGTH[new];    Heap.FreeNode[sessionZone, BASE[old]];    END;  -- of GrowSessionHandleVector  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        InvalidClientID: PROCEDURE [id: ClientID] RETURNS [BOOLEAN _ FALSE] = INLINE {    IF id > globalClientID THEN RETURN[TRUE]};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        InactiveSessionWatcher: PROCEDURE =    BEGIN    pause: Process.Seconds _ 10;  -- checks every 10 seconds (arbitrary)    CheckInactivity: INTERNAL PROCEDURE [session: Session, id: ClientID]      RETURNS [sessionInternal: SessionInternal] =      BEGIN      ENABLE UNWIND => NULL;      timeRemaining: Process.Seconds;      sessionInternal _ SessionInternalFromSessionHandle[session, id];      IF sessionInternal = NIL THEN RETURN[NIL];  --already gone         IF sessionInternal.sessionAttributes.isPrivileged        OR ~sessionInternal.sessionAttributes.timeOut THEN RETURN[NIL];      timeRemaining _ TimeRemaining[sessionInternal];      IF timeRemaining = 0 THEN {        EndSessionInternal[session, id]; RETURN[sessionInternal]}      ELSE RETURN[NIL];      END;  -- of CheckInactivity    WaitInactiveSessionCondition: ENTRY PROC [      seconds: Process.Seconds, id: ClientID] =       BEGIN      Process.SetTimeout[        @inactiveSessionCondition, Process.SecondsToTicks[seconds]];      WAIT inactiveSessionCondition      END;  -- of WaitInactiveSessionCondition    EnumerateWithId: PROC [id: ClientID] = {      FreeIfNecessary: EnumerateProc = {        freeIfNecessary: ENTRY PROC [id: ClientID] = {          sessionInternal: SessionInternal;          sessionInternal _ CheckInactivity[session, id];          IF sessionInternal # NIL THEN            FreeSession[session, sessionInternal, id, timeout, TRUE]};        freeIfNecessary[id]};  -- of FreeIfNecessary      Enumerate[id, FreeIfNecessary]};    DO      FOR id: ClientID IN [1..globalClientID] DO EnumerateWithId[id]; ENDLOOP;      WaitInactiveSessionCondition[pause, nullClientID];      ENDLOOP;    END;  -- of InactiveSessionWatcher  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        NextStamp: INTERNAL PROCEDURE RETURNS [CARDINAL] =    BEGIN currentStamp _ currentStamp + 1; RETURN[currentStamp]; END;  -- of NextStamp  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        NilSessionHandleVector: ENTRY PROCEDURE [session: Session, id: ClientID] =    BEGIN    ENABLE UNWIND => NULL;    index: CARDINAL;    data[id].vector.sHCount _ data[id].vector.sHCount - 1;    index _ LOOPHOLE[session, InternalHandle].index;    data[id].vector.sessionHandleVectorDescriptor[index] _ NIL;    END;  --of NilSessionHandleVector  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        SessionInternalFromSessionHandle: INTERNAL PROCEDURE [    sessionHandle: Session, id: ClientID] RETURNS [sI: SessionInternal] =    BEGIN    iH: InternalHandle _ LOOPHOLE[sessionHandle];    IF iH.index > 0 AND iH.index <= data[id].vector.maxSHCount THEN      sI _ data[id].vector.sessionHandleVectorDescriptor[iH.index]    ELSE RETURN[NIL];    IF sI # NIL AND sI.stamp # iH.timeStamp THEN sI _ NIL;    END;  -- of SessionInternalFromSessionHandle  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        TimeRemaining: INTERNAL PROCEDURE [sessionInternal: SessionInternal]    RETURNS [seconds: Process.Seconds] =    BEGIN    id: ClientID _ sessionInternal.clientID;    secondsSince: LONG CARDINAL _      System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]] -        System.SecondsSinceEpoch[sessionInternal.sessionAttributes.lastActiveTime];    seconds _      SELECT TRUE FROM        sessionInternal.enterSessionCount # 0 => GetClientRestrictions[          id].restrictions.inactivityTimeout,        secondsSince >= GetClientRestrictions[id].restrictions.inactivityTimeout =>          0,        ENDCASE =>          GetClientRestrictions[id].restrictions.inactivityTimeout -            Inline.LowHalf[secondsSince];    END;  -- of TimeRemaining  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        Initialization: PROCEDURE = {    FOR id: CARDINAL IN [0..LAST[ClientID]] DO      Process.InitializeMonitor[@data[id].LOCK];      data[id].vector _  [        0, sizeSessionVector, AllocateSessionHandleVector[sizeSessionVector]];      data[id].restrictList _ sessionZone.NEW[RestrictObject];      FOR i: CARDINAL IN [1..sizeSessionVector] DO        data[id].vector.sessionHandleVectorDescriptor[i] _ NIL; ENDLOOP;      ENDLOOP;      localSEActual _ Courier.LocalSystemElement[];};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --        -- MAINLINE CODE  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  --   Initialization[];  Process.Detach[FORK InactiveSessionWatcher[]];  END.  -- of NSSessionImplLOG [Time - Person - Action]25-Oct-83 21:31:19 - Saund - Redesign 5-Dec-83 11:16:34 - Saund - Fixed AR 5061, 5060. 6-Dec-83  9:54:46 - Saund - Fixed Enumerate to distinguish clientIDs. 8-Dec-83 13:53:23 - Saund - Fixed SetRestrictions to allocate restrictions in case of a new node. 4-Jan-84 18:40:35 - Saund - added ErrorTypes "invalidClientID" and replaced "restrictionFailure" with errortypes "sessionsExceeded" and "sessionsDisabled" 2-Mar-84 15:03:50 - Saund - Fixed AR 5903 Address fault in NSSessionImpl.FreeSession. 1-Apr-84 15:40:27 - Saund - fixed AR 6269. Address fault in SessionInternalFromSession.17-Apr-84 10:21:24 - Saund - Monitored on an ClientID basis25-Apr-84  8:50:20 - Alfvin - Renamed back to NSSessionImpl31-May-84 10:29:57 - Saund - Fix AR #: 8122: NSSession: SerRestrictions mishandles 'selections_ parameter.
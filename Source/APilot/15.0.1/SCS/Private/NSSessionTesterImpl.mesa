-- NSSessionTesterImpl.mesa-- Last revised by Saund:   17-Apr-84 16:28:47DIRECTORY  Heap,  NSSession,  NSString,  NSName,  Process,  StandardTest,  System,  TTY;  NSSessionTesterImpl: PROGRAM  IMPORTS Heap, NSSession, NSString, NSName, Process, StandardTest,System, TTY =  BEGIN     zone: UNCOUNTED ZONE _ Heap.Create[2, 4];  myClientID: NSSession.ClientID;  nsName: NSName.Name; <<Scene I: no timeOuts: 2) Enter session 3) Get Attributes 4) Set Multiple Context  5) Get Multiple Context 6) Exit 7) Enter session 8) Destroy session 9) Enter session expecting Error: invalidSession10) Verify termination proc called >> Test1: PROCEDURE [      arg: STRING, t: TTY.Handle, level: StandardTest.MessageLevel] =    BEGIN    session: NSSession.Session;    internalAttributeRef, realAttrRef: NSSession.AttributesRef;    contextData1: NSSession.Context _ 0;    contextData2: NSSession.Context _ 1;    isInvalidSession: BOOLEAN _ FALSE;    terminationHandlerCalled: BOOLEAN _ FALSE;        terminateProc: NSSession.TerminationHandler = {      TTY.PutString[t, "termination proc called"L];      TTY.PutCR[t];      terminationHandlerCalled _ TRUE}; -- of terminateProc          internalAttributeRef _ zone.NEW[NSSession.Attributes _      [name: nsName,      createTime: System.GetGreenwichMeanTime[],      lastActiveTime: System.GetGreenwichMeanTime[],      systemElement: NSSession.localSystemElement,      isPrivileged: FALSE,      timeOut: FALSE]];        session _ NSSession.Create[      myClientID, nsName, FALSE, FALSE, NSSession.localSystemElement];        NSSession.Enter[session, myClientID];    realAttrRef _ NSSession.GetAttributes[session, myClientID];    IF Compare[realAttrRef, internalAttributeRef] THEN      StandardTest.Signal["Error: Attribute set mismatch"L];          NSSession.SetContext[session, myClientID, contextData1, terminateProc, 1];    IF contextData1 # NSSession.GetContext[session, myClientID, 1] THEN       StandardTest.Signal["Error: Incorrect Get Context data"L];    NSSession.SetContext[session, myClientID, contextData2, NIL, 2];    IF contextData2 # NSSession.GetContext[session, myClientID, 2] THEN       StandardTest.Signal["Error: Incorrect Get Context data"L];          NSSession.Exit[session, myClientID];        NSSession.Enter[session, myClientID];    NSSession.Destroy[session, myClientID];        NSSession.Enter[session, myClientID!      NSSession.Error =>        SELECT type FROM	  invalidSession => {isInvalidSession _ TRUE;	  			CONTINUE};	  ENDCASE];	      IF ~isInvalidSession THEN         StandardTest.Signal["Error: invalid session expected"L];      IF ~terminationHandlerCalled THEN        StandardTest.Signal["Error: termination handler NOT called"L];          END; -- of Test1<<Set restrictions with timeout 2. Create session with timeout 3. Enter to validate session4. Exit 5. Start timing6. Enter -- must get session invalid signal>>    Test2: PROCEDURE [    arg: STRING, t: TTY.Handle, level: StandardTest.MessageLevel] =     BEGIN    ticks: Process.Ticks;    session: NSSession.Session;    selections: NSSession.RestrictionSelections;    restrictions: NSSession.Restrictions;        selections[inactivityTimeout] _ TRUE;    restrictions.inactivityTimeout _ 1; --seconds        NSSession.SetRestrictions[myClientID, selections, restrictions];    session _ NSSession.Create[myClientID, nsName, FALSE, TRUE];        NSSession.Enter[session, myClientID];    NSSession.Exit[session, myClientID];        ticks _ Process.MsecToTicks[60000];    Process.Pause[ticks];        NSSession.Enter[session, myClientID!      NSSession.Error =>         SELECT type FROM 	   invalidSession  => {	     TTY.PutString[t, "invalid session correctly flagged"L];	     TTY.PutCR[t];	     CONTINUE};	    ENDCASE => StandardTest.Signal["invalid session  not flagged"L]	    ];	        END; -- of Test2        Test3: PROCEDURE [    arg: STRING, t: TTY.Handle, level: StandardTest.MessageLevel] =     BEGIN    session: NSSession.Session;    	proc1: PROC = {	  NSSession.Enter[session, myClientID];	  TTY.PutString[t, "entered 1 ..."L];	  Process.Pause[Process.MsecToTicks[10000]];	  NSSession.Exit[session, myClientID]};	  	 proc2: PROC = {	  NSSession.Enter[session, myClientID];	  TTY.PutString[t, "entered 2 ..."L];	  Process.Pause[Process.MsecToTicks[10000]];	  NSSession.Exit[session, myClientID]};	  	proc3: PROC = {	  NSSession.Enter[session, myClientID];	  TTY.PutString[t, "entered 3 ..."L];	  Process.Pause[Process.MsecToTicks[10000]];	  	  NSSession.Exit[session, myClientID]};	  	 proc4: PROC = {	  NSSession.Enter[session, myClientID];	  TTY.PutString[t, "entered 4 ..."L];	  NSSession.Exit[session, myClientID]};	       session _  NSSession.Create[       myClientID, nsName, FALSE, FALSE, NSSession.localSystemElement];     Process.Detach[FORK proc1];     Process.Pause[Process.MsecToTicks[2000]];     Process.Detach[FORK proc2];     Process.Pause[Process.MsecToTicks[2000]];     Process.Detach[FORK proc3];     Process.Pause[Process.MsecToTicks[2000]];     Process.Detach[FORK proc4];           NSSession.Enter[session, myClientID];     NSSession.Destroy[session, myClientID]        END; -- of Test3      Test4: StandardTest.Test =     BEGIN     session1, session2, session3, session4: NSSession.Session;     nsName1, nsName2, nsName3, nsName4: NSName.Name;     stringName1,stringName2, stringName3, stringName4: NSString.String;          enumerateProc: NSSession.EnumerateProc =        BEGIN       s: NSString.String _ NSString.MakeString[zone, 200];       mesaString: LONG STRING _ [200];              TTY.PutCR[t];       s _ NSName.AppendNameToString[s, attributes.name];       mesaString.length _ 0;       NSString.AppendToMesaString[mesaString, s];       NSString.FreeString[zone, s];       TTY.PutString[t, mesaString];       TTY.PutCR[t];       NSSession.Enter[session, myClientID];       NSSession.Destroy[session, myClientID];       END; -- of enumerateProc                 stringName1 _ NSString.StringFromMesaString["Saund1 : OSBU South : Xerox"L];     stringName2 _ NSString.StringFromMesaString["Saund2 : OSBU South : Xerox"L];     stringName3 _ NSString.StringFromMesaString["Saund3 : OSBU South : Xerox"L];     stringName4 _ NSString.StringFromMesaString["Saund4 : OSBU South : Xerox"L];          nsName1 _ NSName.MakeName[zone]; nsName2 _ NSName.MakeName[zone];     nsName3 _ NSName.MakeName[zone]; nsName4 _ NSName.MakeName[zone];          NSName.NameFieldsFromString[zone, stringName1, nsName1];     NSName.NameFieldsFromString[zone, stringName2, nsName2];     NSName.NameFieldsFromString[zone, stringName3, nsName3];     NSName.NameFieldsFromString[zone, stringName3, nsName4];          session1 _  NSSession.Create[       myClientID, nsName1, FALSE, FALSE, NSSession.localSystemElement];     session2 _  NSSession.Create[       myClientID, nsName2, FALSE, FALSE, NSSession.localSystemElement];     session3 _  NSSession.Create[       myClientID, nsName3, FALSE, FALSE, NSSession.localSystemElement];     session4 _  NSSession.Create[       myClientID, nsName4, FALSE, FALSE, NSSession.localSystemElement];            IF NSSession.SessionCount[myClientID] # 4 THEN StandardTest.Signal["Error:  SessionCount Failure"L];          NSSession.Enumerate[myClientID, enumerateProc];          NSName.FreeName[zone, nsName1];     NSName.FreeName[zone, nsName2];     NSName.FreeName[zone, nsName3];     NSName.FreeName[zone, nsName4];          END; -- of Test4     Test5: StandardTest.Test =    BEGIN    clientID1, clientID2, clientID3: NSSession.ClientID;    selections: NSSession.RestrictionSelections _ ALL[TRUE];    restrictions, restrictionsRet: NSSession.Restrictions;    s1, s2, s3, s4: NSSession.Session;        clientID1 _ NSSession.AssignClientID[];    clientID2 _ NSSession.AssignClientID[];    clientID3 _ NSSession.AssignClientID[];        restrictions _ [TRUE, 2, LAST[CARDINAL]];    NSSession.SetRestrictions[clientID1, selections, restrictions];    NSSession.SetRestrictions[clientID2, selections, restrictions];    NSSession.SetRestrictions[clientID3, selections, restrictions];        restrictionsRet _ NSSession.GetRestrictions[clientID2];    IF restrictionsRet # restrictions THEN StandardTest.Signal[      "Restriction Test Failure"L];        s1 _ NSSession.Create[clientID1];    s2 _ NSSession.Create[clientID1];    s3 _ NSSession.Create[clientID1 !     NSSession.Error =>       SELECT type FROM         sessionsExceeded => {	   TTY.PutString[t, "Raised sessionsExceeded"L];	   TTY.PutCR[t]; CONTINUE};	 ENDCASE => {	   TTY.PutString[t, "Did not Raise sessionsExceeded"L];	   TTY.PutCR[t]; CONTINUE}];			         [] _ NSSession.Terminate[s2, clientID1];    s3 _ NSSession.Create[clientID1];        s4 _ NSSession.Create[clientID1, NIL, TRUE]; -- privileged    TTY.PutString[t, "Correctly allocated a new PRIVILIGED session"L];    TTY.PutCR[t];        [] _ NSSession.Terminate[s1, clientID1];    [] _ NSSession.Terminate[s3, clientID1];    [] _ NSSession.Terminate[s4, clientID1];        END; -- Of Test5      Test6: StandardTest.Test = -- Test Lock/UnLock    BEGIN    session: NSSession.Session;           proc1: PROC = {	  NSSession.Enter[session, myClientID];	  TTY.PutString[t, "entered 1 ..."L];	  NSSession.Unlock[session, myClientID];	  Process.Pause[Process.MsecToTicks[10000]];	  NSSession.Relock[session, myClientID];	  TTY.PutCR[t];	  TTY.PutString[t, "Relock in 1 successful"L];	  Process.Detach[FORK proc3];	  TTY.PutCR[t];	  TTY.PutString[t, "About to Exit 1"L];	  NSSession.Exit[session, myClientID]};	          proc2: PROC = {	  NSSession.Enter[session, myClientID];	  TTY.PutString[t, "entered 2 ..."L];	  NSSession.Exit[session, myClientID];	  TTY.PutCR[t];	  TTY.PutString[t, "Exited 2"L]};          proc3: PROC = {  	  TTY.PutCR[t];	  TTY.PutString[t, "Executing proc3 .. about to Enter"L];	  NSSession.Enter[session, myClientID];	  TTY.PutCR[t];	  TTY.PutString[t, "entered 3 ..."L];	  NSSession.Exit[session, myClientID];	  TTY.PutCR[t];	  TTY.PutString[t, "Exited 3"L]};        session _ NSSession.Create[myClientID];    Process.Detach[FORK proc1];    Process.Pause[Process.MsecToTicks[10]];    Process.Detach[FORK proc2];    Process.Pause[Process.MsecToTicks[30000]];      END; -- of Test6    Test7: StandardTest.Test =    BEGIN OPEN NSSession;    s: Session;    aRef: AttributesRef;    ms: LONG STRING _ [200];    newName: NSString.String _ NSString.MakeString[zone, 200];        s _ Create[myClientID,  nsName];    aRef _ CopyAttributes[s, myClientID, zone];    [] _  Terminate[s, myClientID];        ms.length _ 0;    newName _ NSName.AppendNameToString[newName, aRef.name, TRUE];    NSString.AppendToMesaString[ms, newName];    TTY.PutString[t, ms];    NSString.FreeString[zone, newName];        END; -- of Test7      Compare: PROCEDURE[ref1, ref2: NSSession.AttributesRef]     RETURNS [BOOLEAN _ TRUE] =    BEGIN     success: BOOLEAN _ TRUE;          SELECT FALSE FROM        ref1.name = ref2.name => RETURN[FALSE];       ref1.systemElement = ref2.systemElement => RETURN[FALSE];       ref1.isPrivileged = ref2.isPrivileged => RETURN[FALSE];       ref1.timeOut = ref2.timeOut => RETURN[FALSE];       ENDCASE;            END; -- of Compare     -- Test if I can enter the NSSession monitor with separate clientIDs      Test8: PROCEDURE [    arg: STRING, t: TTY.Handle, level: StandardTest.MessageLevel] =     BEGIN OPEN NSSession;    herID: ClientID = AssignClientID[];    herSession: Session = Create[herID];    hisID: ClientID = AssignClientID[];    hisSession: Session = Create[hisID];    mySession: Session = Create[myClientID];    tProc: TerminationHandler = {      Enter[hisSession, hisID];      Destroy[hisSession, hisID];      Enter[herSession, herID];      Destroy[herSession, herID];      TTY.PutLine[t, "Destroyed other clients session successfully"L]};        SetContext[mySession, myClientID, LOOPHOLE[LAST[LONG CARDINAL]], tProc];    Enter[mySession, myClientID];    Destroy[mySession, myClientID]    END;      Initialization: PROCEDURE =    BEGIN    stringName: NSString.String;        myClientID _ NSSession.AssignClientID[];    stringName _ NSString.StringFromMesaString["Saund : OSBU South : Xerox"L];    nsName _ NSName.MakeName[zone];    NSName.NameFieldsFromString[zone, stringName, nsName];        StandardTest.RegisterTest["Session.Test1"L, Test1];    StandardTest.RegisterTest["Session.Test2"L, Test2];    StandardTest.RegisterTest["Session.Test3"L, Test3];    StandardTest.RegisterTest["Session.Test4"L, Test4];    StandardTest.RegisterTest["Session.Test5"L, Test5];    StandardTest.RegisterTest["Session.Test6"L, Test6];    StandardTest.RegisterTest["Session.Test7"L, Test7];    StandardTest.RegisterTest["Session.Test8"L, Test8];        END; -- of Initialization    ----MAINLINE CODE--	Initialization[];	   END. -- of NSSessionTesterImpl   LOG27-Oct-83 15:24:12 - Saund - Genesis      
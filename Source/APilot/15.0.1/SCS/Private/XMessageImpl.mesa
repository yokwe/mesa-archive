--  XMessageImpl.mesa--  Smokey	21-Oct-83 15:39:19--  Ayers	 2-Jul-83 14:32:16 .. commented out use of CES.InvalidNumber--  JGS		 9-Dec-83 13:18:19--  Saund	30-May-84 16:24:31DIRECTORY  Environment USING [Byte],  Heap USING [Create, Delete, systemZone, unlimitedSize],  XMessage USING [    ClientData, DestroyMsgsProc, ErrorType, Messages, Msgkey,    MsgkeyList, StringArray],  XChar USING [Character],  XCharSet0 USING [Make],  XString USING [    AppendChar, AppendReader, Empty, First, InvalidNumber,     Lop, CopyToNewReaderBody, Reader, ReaderBody,    ScanForCharacter, ReaderToNumber, Writer];     XMessageImpl: PROGRAM  IMPORTS XCharSet0, XString, Heap  EXPORTS XMessage  SHARES XString =  BEGIN OPEN XMessage;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- TYPES, CONSTANTS :  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  Fmt: TYPE = {zeroFill, freeForm};  initialMsg: LONG STRING = "no msg set";  maxMsgLength: CARDINAL = 200;  initialHeapPages: CARDINAL = 4;  heapIncrement: CARDINAL = 4;  swapUnitSize: CARDINAL = 4;  sizeUtilityMsgArray: CARDINAL = 42;  leftAngleChar: XChar.Character = XCharSet0.Make[lessThan];  rightAngleChar: XChar.Character = XCharSet0.Make[greaterThan];  defaultChset: Environment.Byte = 0;  ESC: Environment.Byte = 377B;  systemZone: UNCOUNTED ZONE = Heap.systemZone;  MsgEntry: TYPE = XString.ReaderBody;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [    heap: UNCOUNTED ZONE,    proc: XMessage.DestroyMsgsProc,    clientData: XMessage.ClientData,    array: SEQUENCE maxMsgIndex: CARDINAL OF MsgEntry];      ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- SIGNALS, ERRORS :  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  Error: PUBLIC ERROR [type: ErrorType] = CODE;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- PUBLIC OPERATIONS :  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  AllocateMessages: PUBLIC PROCEDURE [   applicationName: LONG STRING, maxMessages: CARDINAL,   clientData: ClientData, proc: DestroyMsgsProc]   RETURNS [h: Handle] =   BEGIN   heap: UNCOUNTED ZONE _ Heap.Create[      initial: initialHeapPages,      maxSize: Heap.unlimitedSize,      increment: heapIncrement,      swapUnitSize: swapUnitSize];   h _ heap.NEW[Object[maxMessages] _ [     heap: heap, proc: proc, clientData: clientData, array: ]];   FOR i: CARDINAL IN [0..maxMessages) DO     h.array[i] _ [[1,TRUE, 0B], 0, 0, NIL];     ENDLOOP;   END;  DestroyMessages: PUBLIC PROCEDURE [h: Handle] =    BEGIN    h.proc[h.clientData];    Heap.Delete[h.heap];    END;      Decompose: PUBLIC PROCEDURE [source: XString.Reader]    RETURNS [args: StringArray] = {};  -- of Decompose  Compose: PUBLIC PROCEDURE [    source: XString.Reader, destination: XString.Writer, args: StringArray] = {    ComposeInternal[source, destination, args]};  -- of Compose  Get: PUBLIC PROCEDURE [h: Handle, msgkey: Msgkey]    RETURNS [msg: XString.Reader] = {msg _ GetInternal[h, msgkey]};  GetList: PUBLIC PROCEDURE [    h: Handle, msgkeys: MsgkeyList, msgs: StringArray] =    BEGIN    IF msgkeys = NIL THEN Error[invalidMsgkeyList];    IF msgs = NIL THEN Error[invalidStringArray];    IF LENGTH[msgkeys] # LENGTH[msgs] THEN Error[arrayMismatch];    FOR i: CARDINAL IN [0..LENGTH[msgkeys]) DO      msgs[i] _ GetInternal[h, msgkeys[i]]^ ENDLOOP    END;  -- of GetList  RegisterMessages: PUBLIC PROCEDURE [    h: Handle, messages: Messages, stringBodiesAreReal: BOOLEAN] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[messages]) DO      h.array[messages[i].msgkey] _ IF stringBodiesAreReal THEN messages[i].msg      ELSE XString.CopyToNewReaderBody[@messages[i].msg, h.heap];      ENDLOOP;    END;  -- of SetMessages  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- PRIVATE OPERATIONS :  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  AppendDecimal: PROCEDURE [s: LONG STRING, v: CARDINAL, fmt: Fmt] =    BEGIN    d1: CARDINAL _ v/10;    d2: CARDINAL _ v MOD 10;    IF d1 # 0 OR fmt = zeroFill THEN {      s[s.length] _ '0 + d1; s.length _ s.length + 1};    s[s.length] _ '0 + d2;    s.length _ s.length + 1;    END;  -- of AppendDecimal  ComposeInternal: PROCEDURE [    source: XString.Reader, destination: XString.Writer, args: StringArray] =    BEGIN    argIndex, index, length: CARDINAL _ 0;    noNumber: BOOLEAN;    front: XString.ReaderBody;    IF XString.Empty[source] THEN Error[invalidString];    IF args = NIL THEN Error[notEnoughArguments];    -- fill in the diamonds    UNTIL XString.Empty[source] DO      front _ XString.ScanForCharacter[source, leftAngleChar, ignore];      XString.AppendReader[destination, @front];      IF ~XString.Empty[source] THEN {        front _ XString.ScanForCharacter[source, rightAngleChar, leaveOnRest];	IF XString.First[source] = rightAngleChar THEN {	  noNumber _ FALSE;	  argIndex _ CARDINAL[XString.ReaderToNumber [@front 	    ! XString.InvalidNumber => {noNumber _ TRUE; CONTINUE} ]];	  IF noNumber THEN {	    XString.AppendChar[destination, leftAngleChar];            XString.AppendReader[destination, @front];	    XString.AppendChar[destination, rightAngleChar]}	  ELSE XString.AppendReader[destination, @args[argIndex]];	  [] _ XString.Lop[source]}        ELSE XString.AppendReader[destination, @front]}      ELSE XString.AppendReader[destination, @front];       ENDLOOP;    END;  -- of ComposeInternal  GetInternal: PROCEDURE [h: Handle, msgkey: Msgkey]    RETURNS [msg: XString.Reader] = BEGIN RETURN[@h.array[msgkey]]; END;    END.  -- of MessageImpl30-May-84 16:24:48 - Saund - Reduced initial Heap size from 64 to 4 pages.
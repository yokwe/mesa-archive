-- File: XStringImplB.mesa - last edit:-- Sandman.pa          24-Jan-84 10:22:15-- Ching.pa		 6-Apr-84 16:18:08-- Saund.es		28-Jun-84 22:54:33DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Byte],  Stream USING [GetBlock, GetByte, Handle],  XChar USING [Character, Code, LowerCase, not, Set, UpperCase],  XString USING [    BreakCharOption, BreakTable, BreakTableObject, Byte, ByteLength, Bytes,    ByteSequence, Character, ComputeEndContext, Context, Error, Empty, First,    FromSTRING, InvalidEncoding, Lop, NewWriterBody, nullReaderBody, Reader,    ReaderBody, ReaderFromWriter, StopOrNot, unknownContext, vanillaContext,    ValidateReader, Writer, WriterBody];XStringImplB: PROGRAM  IMPORTS ByteBlt, Stream, XChar, XString  EXPORTS XString  SHARES XString =  BEGIN OPEN XString;  selectCode: Byte = 377B;    Overflow: PUBLIC SIGNAL = CODE;  InvalidNumber: PUBLIC SIGNAL = CODE;  InsufficientRoom: PUBLIC SIGNAL [    needsMoreRoom: Writer, amountNeeded: CARDINAL] = CODE;  Length: PROC [r: Reader] RETURNS [CARDINAL] = INLINE {    RETURN[r.limit-r.offset]};  -- use only when know r # NIL  WLength: PROC [w: Writer] RETURNS [CARDINAL] = INLINE {    RETURN[w.limit-w.offset]};  -- use only when know r # NIL    ContextSwitch: PROC [r: Reader] RETURNS [BOOLEAN] = INLINE {    RETURN[r.bytes[r.offset] = selectCode]};    Normalize: PROC [r: Reader] = INLINE {    IF (r.context.prefix _ r.bytes[r.offset+1]) = selectCode THEN {      r.context.prefix _ 0; r.context.suffixSize _ 2; r.offset _ r.offset + 3}    ELSE {r.context.suffixSize _ 1; r.offset _ r.offset + 2}};  -- routines for converting between strings and numbers  DigitIndex: TYPE = NAT[0..16);  DigitBuffer: TYPE = ARRAY DigitIndex OF Character;  NumberParser: TYPE =    PROC [buffer: POINTER TO DigitBuffer] RETURNS [v: LONG CARDINAL];    ReaderToNumber: PUBLIC PROC [r: Reader, radix: CARDINAL, signed: BOOLEAN]    RETURNS [v: LONG INTEGER] = {    hexCount: CARDINAL _ 0;    hexSig: PACKED ARRAY ['a.ORD..'h.ORD] OF {F, T} _ ALL[F];    buffer: DigitBuffer;    index: DigitIndex _ 0;    parser: NumberParser;    neg: BOOLEAN _ FALSE;    char: Character;    rb: ReaderBody;    space: Character = ' .ORD;    IF r = NIL THEN {SIGNAL InvalidNumber; RETURN[0]};    rb _ r^;    SELECT radix FROM      8 => parser _ ParseOctal;      10 => parser _ ParseDecimal;      16 => parser _ ParseHex;      ENDCASE => ERROR Error[invalidOperation];    SELECT (char _ Lop[@rb]) FROM      XChar.not => {SIGNAL InvalidNumber; RETURN[0]};      '-.ORD =>         IF ~signed THEN {SIGNAL InvalidNumber; RETURN[0]}	ELSE {neg _ TRUE; char _ Lop[@rb]};      '+.ORD => char _ Lop[@rb];      IN ['0.ORD .. '9.ORD] => {};      IN ['a.ORD .. 'f.ORD], IN ['A.ORD .. 'A.ORD] =>        {IF radix # 16 THEN SIGNAL InvalidNumber; RETURN[0]};      ENDCASE => {SIGNAL InvalidNumber; RETURN[0]};    DO      SELECT char FROM        IN ['0.ORD .. '9.ORD] => {};	IN ['a.ORD..'f.ORD] => {	  hexSig[char] _ T; hexCount _ hexCount+1};	IN ['A.ORD..'F.ORD] => {	  hexSig[XChar.LowerCase[char]] _ T; hexCount _ hexCount+1};	'h.ORD, 'H.ORD => {hexSig['h.ORD] _ T; hexCount _ hexCount+1};        XChar.not => EXIT;	ENDCASE => {SIGNAL InvalidNumber; RETURN[0]};      buffer[index] _ char;      IF (index _ index.SUCC) >= DigitIndex.LAST THEN {        SIGNAL InvalidNumber; RETURN[0]};      char _ Lop[@rb];      ENDLOOP;    buffer[index] _ XChar.not;    SELECT TRUE FROM      (hexSig['h.ORD] = T) => parser _ ParseHex;      ENDCASE =>	SELECT hexCount FROM	  0 => {};  -- use default according to radix	  1 =>	    SELECT hexSig FROM	      [F,T,F,F,F,F,F,F] => parser _ ParseOctal;	      [F,F,F,T,F,F,F,F] => parser _ ParseDecimal;	    ENDCASE => parser _ ParseHex;	  ENDCASE => parser _ ParseHex;    v _ parser[@buffer !      InvalidNumber => GOTO invalid; Overflow => GOTO overflow];    RETURN[IF neg THEN -v ELSE v];    EXITS      invalid => {SIGNAL InvalidNumber; RETURN[0]};      overflow => {SIGNAL Overflow; RETURN[0]}};  Digit: ARRAY Character['0.ORD..'9.ORD] OF CARDINAL = [0,1,2,3,4,5,6,7,8,9];  HexDigit: ARRAY Character['A.ORD..'F.ORD] OF CARDINAL = [10,11,12,13,14,15];  DecimalDigit: TYPE = Character['0.ORD..'9.ORD];  OctalDigit: TYPE = Character['0.ORD..'9.ORD];    ParseDecimal: NumberParser = {    c: Character;    i: DigitIndex _ 0;    v _ 0;    IF buffer[i] NOT IN DecimalDigit THEN ERROR InvalidNumber;    WHILE (c _ buffer[i]) IN DecimalDigit DO      v _ AppendDecimal[v, c];      i _ i+1;      ENDLOOP;    IF XChar.UpperCase[c] = 'D.ORD THEN {      scale: CARDINAL _ 0;      WHILE (c _ buffer[i_i+1]) IN DecimalDigit DO	scale _ AppendToScale[scale, c];	ENDLOOP;      THROUGH [1 .. scale] DO v _ AppendDecimal[v, '0.ORD] ENDLOOP};     IF c # XChar.not THEN ERROR InvalidNumber;     RETURN};          AppendDecimal: PROC [v: LONG CARDINAL, digit: DecimalDigit]      RETURNS [newV: LONG CARDINAL] = {    maxV: LONG CARDINAL = 429496729;	-- (2**32-1)/10    maxD: CARDINAL = 5;			-- (2**32-1) MOD 10    d: [0..9] = Digit[digit];    IF v > maxV OR (v = maxV AND d > maxD) THEN ERROR Overflow;    newV _ 10*v + d;    RETURN};  ParseOctal: NumberParser = {    c: Character;    i: DigitIndex _ 0;    v _ 0;    IF buffer[i] NOT IN OctalDigit THEN ERROR InvalidNumber;    WHILE (c _ buffer[i]) IN OctalDigit DO      v _ AppendOctal[v, c]; i _ i+1;      ENDLOOP;    IF XChar.UpperCase[c] = 'B.ORD THEN {      scale: CARDINAL _ 0;      WHILE (c _ buffer[i_i+1]) IN DecimalDigit DO	scale _ AppendToScale[scale, c];	ENDLOOP;      THROUGH [1 .. scale] DO v _ AppendOctal[v, '0.ORD] ENDLOOP};     IF c # XChar.not THEN ERROR InvalidNumber;     RETURN};  AppendOctal: PROC [v: LONG CARDINAL, digit: OctalDigit]      RETURNS [newV: LONG CARDINAL] = {    maxV: LONG CARDINAL = 3777777777b;	-- (2**32-1)/8    d: [0..7] = Digit[digit];    IF v > maxV THEN ERROR Overflow;    newV _ 8*v + d;    RETURN};  ParseHex: NumberParser = {    c: Character;    i: DigitIndex _ 0;    v _ 0;    IF buffer[i] NOT IN DecimalDigit THEN ERROR InvalidNumber;    DO      SELECT (c _ XChar.UpperCase[buffer[i]]) FROM	IN DecimalDigit, IN ['A.ORD..'F.ORD] => v _ AppendHex[v, c];        ENDCASE => EXIT;      i _ i + 1;      ENDLOOP;    IF c = 'H.ORD THEN {      scale: CARDINAL _ 0;      WHILE (c _ buffer[i_i+1]) IN DecimalDigit DO        scale _ AppendToScale[scale, c];        ENDLOOP;      THROUGH [1 .. scale] DO v _ AppendHex[v, '0.ORD] ENDLOOP};    IF c # XChar.not THEN ERROR InvalidNumber;    RETURN};  AppendHex: PROC [v: LONG CARDINAL, digit: Character['0.ORD..'F.ORD]]      RETURNS [newV: LONG CARDINAL] = {    maxV: LONG CARDINAL = 1777777777b;	-- (2**32-1)/16    d: [0..15] = IF digit IN DecimalDigit THEN Digit[digit] ELSE HexDigit[digit];    IF v > maxV THEN ERROR Overflow;    newV _ 16*v + d;    RETURN};  AppendToScale: PROC [    v: CARDINAL, digit: DecimalDigit] RETURNS [newV: CARDINAL] = {    maxV: CARDINAL = 6553;		-- (2**16-1)/10    maxD: CARDINAL = 5;			-- (2**16-1) MOD 10    d: [0..9] = Digit[digit];    IF v > maxV OR (v = maxV AND d > maxD) THEN ERROR Overflow;    newV _ 10*v + d;    RETURN};    -- routines involving the allocation and deallocation of strings  CopyToNewWriterBody: PUBLIC PROC [    r: Reader, z: UNCOUNTED ZONE, endContext: Context, extra: CARDINAL]    RETURNS [w: WriterBody] = {    w _ NewWriterBody[maxLength: ByteLength[r]+extra, z: z];    AppendReader[to: @w, from: r, extra: extra, fromEndContext: endContext]};  ExpandWriter: PUBLIC PROC [w: Writer, extra: CARDINAL] = {    bytes: Bytes;    z: UNCOUNTED ZONE;    IF w = NIL OR (z _ w.zone) = NIL THEN RETURN;    bytes _ z.NEW[ByteSequence[w.maxLimit _ (w.maxLimit-w.offset) + extra]];    [] _ ByteBlt.ByteBlt[      from: [blockPointer: LOOPHOLE[w.bytes], startIndex: w.offset,        stopIndexPlusOne: w.limit],       to: [blockPointer: LOOPHOLE[bytes], startIndex: 0,        stopIndexPlusOne: w.maxLimit]];    z.FREE[@w.bytes];    w.bytes _ bytes;    w.offset _ 0};-- scanning functions  ScanForCharacter: PUBLIC PROC [    r: Reader, char: Character, option: BreakCharOption,    breakChar: LONG POINTER TO Character]    RETURNS [front: ReaderBody] = {    bto: BreakTableObject _ [otherSets: not, set: XChar.Set[char]];    bto.codes[XChar.Code[char]] _ stop;    RETURN Scan[r: r, break: @bto, option: option, breakChar: breakChar]};  Scan: PUBLIC PROC [    r: Reader, break: BreakTable, option: BreakCharOption,    breakChar: LONG POINTER TO Character]    RETURNS [front: ReaderBody] = {    c: Character;    IF r = NIL THEN {      front _ nullReaderBody;      IF breakChar # NIL THEN breakChar^ _ XChar.not; RETURN};    front _ r^;    DO      c _ First[r];      IF c = XChar.not THEN {        IF breakChar # NIL THEN breakChar^ _ XChar.not; RETURN};      IF XChar.Set[c] = break.set THEN {        IF break.codes[XChar.Code[c]] = stop THEN EXIT}      ELSE IF break.otherSets = stop THEN {c _ XChar.not; EXIT};      [] _ Lop[r];      ENDLOOP;    SELECT option FROM      leaveOnRest => front.limit _ r.offset;      appendToFront => {[] _ Lop[r]; front.limit _ r.offset};      ignore => {front.limit _ r.offset; [] _ Lop[r]};      ENDCASE;    IF breakChar # NIL THEN breakChar^ _ c}; <<  Start of inline expansion of scan   Scan: PUBLIC PROC [    r: Reader, break: BreakTable, option: BreakCharOption,    breakChar: LONG POINTER TO Character]    RETURNS [front: ReaderBody] = {    rb: ReaderBody;    c: Character;    state: State;    byte: Environment.Byte;    set: Environment.Byte;    IF r = NIL THEN {      IF breakChar # NIL THEN breakChar^ _ XChar.not; RETURN[nullReaderBody]};    front _ rb _ r^;    IF rb.context.suffixSize = 1 THEN {      set _ VAL[rb.context.prefix];      IF set # break.set AND break.otherSets = stop THEN {        IF breakChar # NIL THEN breakChar^ _ XChar.not;	RETURN[nullReaderBody];      state _ char8}    ELSE state _ char16High;    WHILE rb.offset # rb.limit DO      byte _ rb.bytes[rb.offset];      SELECT state FROM        char8 =>          DO            IF byte = selectCode THEN {state _ esc1; EXIT};            IF break.codes[byte] = stop THEN {c _ XChar.Make[set, byte]; GOTO found};            IF (rb.offset _ rb.offset + 1) = rb.limit THEN {c _ XChar.not; GOTO found};            byte _ rb.bytes[rb.offset];            ENDLOOP;        char16High =>          IF byte = selectCode THEN state _ esc1          ELSE {set _ VAL[byte]; state _ char16Low};        char16Low =>          IF byte = selectCode THEN GOTO invalidEncoding          ELSE {            state _ char16High;            c _ XChar.Make[set: set, code: byte];	    IF set # break.set AND break.otherSets = stop OR break.codes[byte] = stop THEN GOTO found};        esc1 =>          IF byte = selectCode THEN state _ esc2          ELSE {set _ VAL[byte]; state _ char8};        esc2 =>	  IF byte # 0 THEN GOTO invalidEncoding ELSE state _ char16High;        ENDCASE => ERROR;  -- EXHAUSTED      rb.offset _ rb.offset + 1;      REPEAT found => {}      ENDLOOP;    SELECT state FROM      char8 => rb.context _ [suffixSize: 1, homogeneous: FALSE, prefix: set.ORD];      char16High => rb.context _ [suffixSize: 2, homogeneous: FALSE, prefix: 0];      ENDCASE rb.context _ vanillaContext;    IF breakChar # NIL THEN breakChar^ _ c;    SELECT option FROM      leaveOnRest => r^ _ rb; front.limit _ xxx;      appendToFront => {[] _ Lop[r]; front.limit _ r.offset};      ignore => {front.limit _ r.offset; [] _ Lop[r]};      ENDCASE};  End of inline expansion of scan  >>    InitBreakTable: PUBLIC PROC [    r: Reader, stopOrNot: StopOrNot, otherSets: StopOrNot]    RETURNS [BreakTableObject] = {    c: XChar.Character;    rb: ReaderBody _ IF r = NIL THEN nullReaderBody ELSE r^;    break: BreakTableObject _ [      otherSets: otherSets, codes: ALL[IF stopOrNot = stop THEN not ELSE stop]];    IF (c _ Lop[@rb]) # XChar.not THEN break.set _ XChar.Set[c];    WHILE c # XChar.not DO      break.codes[XChar.Code[c]] _ stopOrNot;      IF XChar.Set[c] # break.set THEN ERROR Error[multipleCharSets];      c _ Lop[@rb];      ENDLOOP;    RETURN[break]};  -- appending to Writers  AppendChar: PUBLIC PROC [to: Writer, c: Character, extra: CARDINAL _ 0] = {    context: Context;    set: Environment.Byte = XChar.Set[c];    offset, spaceNeeded, available: CARDINAL;    bytes: Bytes;    IF to = NIL THEN RETURN;    context _ IF to.endContext = unknownContext THEN      ComputeEndContext[ReaderFromWriter[to]] ELSE to.endContext;    SELECT TRUE FROM      context.suffixSize = 2 => spaceNeeded _ 2;      context.prefix = set.ORD => spaceNeeded _ 1;      ENDCASE => spaceNeeded _ 3;    available _ to.maxLimit - to.limit;    IF available < spaceNeeded THEN {      IF to.zone = NIL THEN {	SIGNAL InsufficientRoom[to, spaceNeeded];	RETURN}      ELSE ExpandWriter[to, spaceNeeded + extra - available]};    IF to.context.homogeneous AND spaceNeeded = 3 THEN      to.endContext.homogeneous _ to.context.homogeneous _ FALSE;    to.endContext.prefix _ set.ORD;    bytes _ to.bytes;    offset _ to.limit;    to.limit _ to.limit + spaceNeeded;    SELECT spaceNeeded FROM      1 => bytes[offset] _ XChar.Code[c];      2 => {bytes[offset] _ set; bytes[offset.SUCC] _ XChar.Code[c]};      3 => {	bytes[offset] _ selectCode;	bytes[offset _ offset.SUCC] _ set;	bytes[offset.SUCC] _ XChar.Code[c]};      ENDCASE;    RETURN};  AppendExtensionIfNeeded: PUBLIC PROC [to: Writer, extension: Reader]    RETURNS [BOOLEAN] = {    rb: ReaderBody;    dot: Character = '..ORD;    c: Character;    IF to = NIL OR extension = NIL THEN RETURN[FALSE];    rb _ ReaderFromWriter[to]^;    [] _ ScanForCharacter[      r: @rb, char: dot, breakChar: @c, option: appendToFront];    IF c = dot THEN RETURN[FALSE];    IF First[extension] # dot THEN AppendChar[to, dot];    AppendReader[to, extension, unknownContext, 0];    RETURN[TRUE]};  AppendReader: PUBLIC PROC [    to: Writer, from: Reader, fromEndContext: Context, extra: CARDINAL] = {    spaceNeeded, oldLength, nTransitionBytes, available: CARDINAL;    tOffset: CARDINAL;    tBytes: Bytes;    partialAppend: BOOLEAN _ FALSE;    IF to = NIL OR Empty[from] THEN RETURN;    IF to.endContext = unknownContext THEN      to.endContext _ ComputeEndContext[ReaderFromWriter[to]];    oldLength _ WLength[to];    IF ContextSwitch[from] THEN Normalize[from];    SELECT TRUE FROM      to.endContext.suffixSize = 2 AND from.context.suffixSize = 2 =>        nTransitionBytes _ 0;      to.endContext.suffixSize = from.context.suffixSize AND        to.endContext.prefix = from.context.prefix => nTransitionBytes _ 0;      ENDCASE => nTransitionBytes _ 1 + from.context.suffixSize;    spaceNeeded _ nTransitionBytes + Length[from];    available _ to.maxLimit - to.limit;    IF available < spaceNeeded THEN {      IF to.zone = NIL THEN {	SIGNAL InsufficientRoom[to, spaceNeeded];	partialAppend _ TRUE;	IF nTransitionBytes >= to.maxLimit - to.limit THEN RETURN}      ELSE ExpandWriter[to, spaceNeeded + extra - available]};    to.endContext _ IF fromEndContext # unknownContext THEN fromEndContext      ELSE ComputeEndContext[from];    IF nTransitionBytes # 0 OR ~from.context.homogeneous THEN       to.endContext.homogeneous _ to.context.homogeneous _ FALSE;    tBytes _ to.bytes;    tOffset _ to.limit;    IF nTransitionBytes # 0 THEN {      tBytes[tOffset] _ selectCode; tOffset _ tOffset.SUCC;      IF nTransitionBytes = 3 THEN {        tBytes[tOffset] _ selectCode; tOffset _ tOffset.SUCC;	tBytes[tOffset] _ 0; tOffset _ tOffset.SUCC}      ELSE {tBytes[tOffset] _ from.context.prefix; tOffset _ tOffset.SUCC}};    to.limit _ to.limit + nTransitionBytes + ByteBlt.ByteBlt[      from: [blockPointer: LOOPHOLE[from.bytes], startIndex: from.offset,        stopIndexPlusOne: from.limit],       to: [blockPointer: LOOPHOLE[to.bytes], startIndex: tOffset,        stopIndexPlusOne: to.maxLimit]];    IF partialAppend THEN {      ValidateReader[ReaderFromWriter[to] ! InvalidEncoding => {        to.limit _ firstBadByteOffset+to.offset; CONTINUE}]};    RETURN};  AppendStream: PUBLIC PROC [    to: Writer, from: Stream.Handle, nBytes: CARDINAL,    fromContext: Context, extra: CARDINAL _ 0]    RETURNS [bytesTransferred: CARDINAL] = {    spaceNeeded, oldLength, nTransitionBytes, available: CARDINAL;    tOffset: CARDINAL;    firstByte: Environment.Byte;    tBytes: Bytes;    partialAppend: BOOLEAN _ FALSE;    IF to = NIL OR from = NIL OR nBytes = 0 THEN RETURN[0];    IF to.endContext = unknownContext THEN      to.endContext _ ComputeEndContext[ReaderFromWriter[to]];    oldLength _ WLength[to];    firstByte _ from.GetByte[];    SELECT TRUE FROM      firstByte = 377B => nTransitionBytes _ 0;      to.endContext.suffixSize = 2 AND fromContext.suffixSize = 2 =>        nTransitionBytes _ 0;      to.endContext.suffixSize = fromContext.suffixSize AND        to.endContext.prefix = fromContext.prefix => nTransitionBytes _ 0;      ENDCASE => nTransitionBytes _ 1 + fromContext.suffixSize;    spaceNeeded _ nTransitionBytes + nBytes;    available _ to.maxLimit - to.limit;    IF available < spaceNeeded THEN {      IF to.zone = NIL THEN {	SIGNAL InsufficientRoom[to, spaceNeeded];	partialAppend _ TRUE;	IF nTransitionBytes >= to.maxLimit - to.limit THEN RETURN}      ELSE ExpandWriter[to, spaceNeeded + extra - available]};    to.endContext _ unknownContext;    IF nTransitionBytes # 0 OR ~fromContext.homogeneous THEN       to.endContext.homogeneous _ to.context.homogeneous _ FALSE;    tBytes _ to.bytes;    tOffset _ to.limit;    IF nTransitionBytes # 0 THEN {      tBytes[tOffset] _ selectCode; tOffset _ tOffset.SUCC;      IF nTransitionBytes = 3 THEN {        tBytes[tOffset] _ selectCode; tOffset _ tOffset.SUCC;	tBytes[tOffset] _ 0; tOffset _ tOffset.SUCC}      ELSE {tBytes[tOffset] _ fromContext.prefix; tOffset _ tOffset.SUCC}};    tBytes[tOffset] _ firstByte; tOffset _ tOffset.SUCC; nBytes _ nBytes.PRED;    IF nBytes = 0 THEN RETURN[1];    bytesTransferred _ 1 + from.GetBlock[      block: [blockPointer: LOOPHOLE[to.bytes], startIndex: tOffset,        stopIndexPlusOne: MIN[tOffset+nBytes, to.maxLimit]]].bytesTransferred;    to.limit _ to.limit + nTransitionBytes + bytesTransferred;    IF partialAppend THEN {      ValidateReader[ReaderFromWriter[to] ! InvalidEncoding => {        to.limit _ firstBadByteOffset+to.offset; CONTINUE}]};    RETURN};  AppendSTRING: PUBLIC PROC [    to: Writer, from: LONG STRING, homogeneous: BOOLEAN _ FALSE, extra: CARDINAL _ 0] = {    rb: ReaderBody _ FromSTRING[from, homogeneous];    AppendReader[      to: to, from: @rb, extra: extra,      fromEndContext: IF homogeneous THEN vanillaContext ELSE unknownContext]};  Piece: PUBLIC PROC [r: Reader, firstChar, nChars: CARDINAL]    RETURNS [piece: ReaderBody, endContext: Context] = {    rb: ReaderBody;    context: Context;    offset: CARDINAL;    IF r = NIL THEN RETURN[nullReaderBody, vanillaContext];    rb _ r^;    IF rb.context.homogeneous THEN {      piece _ [        limit: firstChar + nChars, offset: firstChar, bytes: rb.bytes,        context: rb.context];      IF rb.context.suffixSize = 2 THEN {        piece.offset _ piece.offset * 2; piece.limit _ piece.limit * 2};      IF piece.limit > rb.limit THEN piece.limit _ rb.limit;      IF piece.offset > rb.offset THEN piece.offset _ rb.offset;      RETURN[piece, rb.context]};    THROUGH [0..firstChar) DO      IF Lop[@rb] = XChar.not THEN RETURN[rb, rb.context]; ENDLOOP;    offset _ rb.offset;    context _ rb.context;    THROUGH [0..nChars) DO IF Lop[@rb] = XChar.not THEN EXIT ENDLOOP;    RETURN[      piece: [        limit: rb.offset, context: context, bytes: rb.bytes, offset: offset],      endContext: rb.context]};  ReplacePiece: PUBLIC PROC [    w: Writer, firstChar, nChars: CARDINAL, r: Reader,    endContext: Context _ unknownContext] = {    firstPrefix: Byte _ selectCode;    nFirstSwitch, nLastSwitch: CARDINAL _ 0;    middle, last: ReaderBody;    partialAppend: BOOLEAN _ FALSE;    nDeleted: CARDINAL;    nInserted: CARDINAL _ ByteLength[r];    IF w = NIL THEN RETURN;    [piece: middle, endContext: last.context] _      Piece[ReaderFromWriter[w], firstChar, nChars];    last.limit _ w.limit;    last.offset _ middle.limit;    last.bytes _ w.bytes;    IF endContext = unknownContext THEN endContext _ ComputeEndContext[r];    nDeleted _ Length[@middle];    SELECT TRUE FROM      nInserted = 0 AND nDeleted = 0 => RETURN;      nInserted = 0 => {        IF last.limit = last.offset THEN {	  w.limit _ middle.offset; w.endContext _ middle.context; RETURN};	SELECT TRUE FROM	  ContextSwitch[@last] => nFirstSwitch _ 0;	  middle.context.suffixSize = 2 AND last.context.suffixSize = 2 =>	    nFirstSwitch _ 0;	  middle.context.suffixSize = last.context.suffixSize AND            middle.context.prefix = last.context.prefix => nFirstSwitch _ 0;	  ENDCASE => {            firstPrefix _ last.context.prefix;	    nFirstSwitch _ 1 + last.context.suffixSize}};      ENDCASE => {        SELECT TRUE FROM	  ContextSwitch[r] => {	    nFirstSwitch _ 0;	    w.context.homogeneous _ w.endContext.homogeneous _ FALSE};	  middle.context.suffixSize = 2 AND r.context.suffixSize = 2 =>	    nFirstSwitch _ 0;	  middle.context.suffixSize = r.context.suffixSize AND	    middle.context.prefix = r.context.prefix => nFirstSwitch _ 0;	  ENDCASE => {            firstPrefix _ r.context.prefix;	    nFirstSwitch _ 1 + r.context.suffixSize;	    w.context.homogeneous _ w.endContext.homogeneous _ FALSE};        SELECT TRUE FROM	  last.limit = last.offset OR ContextSwitch[@last] =>	    nLastSwitch _ 0;	  endContext.suffixSize = 2 AND last.context.suffixSize = 0 =>	    nLastSwitch _ 0;	  endContext.suffixSize = last.context.suffixSize AND	    endContext.prefix = last.context.prefix => nLastSwitch _ 0;	  ENDCASE => {	    nLastSwitch _ 1 + last.context.suffixSize;	    w.context.homogeneous _ w.endContext.homogeneous _ FALSE}};    nInserted _ nInserted + nFirstSwitch + nLastSwitch;    IF nInserted > nDeleted THEN { -- net add      delta: CARDINAL = nInserted - nDeleted;      available: CARDINAL = w.maxLimit - w.limit;      IF available < delta THEN	IF w.zone = NIL THEN {	  SIGNAL InsufficientRoom[w, delta];	  partialAppend _ TRUE;	  IF nFirstSwitch + nLastSwitch >= available THEN RETURN}	ELSE ExpandWriter[w, delta - available];      [] _ ByteBlt.ByteBlt[	from: [	  blockPointer: LOOPHOLE[last.bytes], startIndex: last.offset,	  stopIndexPlusOne: last.limit],	to: [	  blockPointer: LOOPHOLE[last.bytes], startIndex: last.offset+delta,	  stopIndexPlusOne: last.limit+delta],	overLap: move];      IF nFirstSwitch # 0 THEN {	w.bytes[middle.offset] _ selectCode; middle.offset _ middle.offset+1;	IF nFirstSwitch = 3 THEN {	  w.bytes[middle.offset] _ selectCode; middle.offset _ middle.offset+1;	  w.bytes[middle.offset] _ 0; middle.offset _ middle.offset+1}	ELSE {	  w.bytes[middle.offset] _ firstPrefix;	  middle.offset _ middle.offset+1}};      IF ~Empty[r] THEN {	[] _ ByteBlt.ByteBlt[	  from: [	    blockPointer: LOOPHOLE[r.bytes], startIndex: r.offset,	    stopIndexPlusOne: r.limit],	  to: [	    blockPointer: LOOPHOLE[w.bytes], startIndex: middle.offset,	    stopIndexPlusOne: w.limit],	  overLap: move];	IF nLastSwitch # 0 THEN {	  middle.limit _ last.offset+delta - nLastSwitch;	  w.bytes[middle.limit] _ selectCode; middle.limit _ middle.limit+1;	  IF nLastSwitch = 3 THEN {	    w.bytes[middle.limit] _ selectCode; middle.limit _ middle.limit+1;	    w.bytes[middle.limit] _ 0}	  ELSE w.bytes[middle.limit] _ last.context.prefix}};	w.limit _ w.limit + delta}      ELSE {	delta: CARDINAL = nDeleted - nInserted;	IF nFirstSwitch # 0 THEN {	  w.bytes[middle.offset] _ selectCode; middle.offset _ middle.offset+1;	  IF nFirstSwitch = 3 THEN {            w.bytes[middle.offset] _ selectCode; middle.offset _ middle.offset+1;	    w.bytes[middle.offset] _ 0; middle.offset _ middle.offset+1}          ELSE {w.bytes[middle.offset] _ firstPrefix; middle.offset _ middle.offset+1}};	IF ~Empty[r] THEN {	  [] _ ByteBlt.ByteBlt[	    from: [	      blockPointer: LOOPHOLE[r.bytes], startIndex: r.offset,	      stopIndexPlusOne: r.limit],	    to: [	      blockPointer: LOOPHOLE[w.bytes], startIndex: middle.offset,	      stopIndexPlusOne: w.limit],	    overLap: move]};	[] _ ByteBlt.ByteBlt[	  from: [	    blockPointer: LOOPHOLE[w.bytes], startIndex: last.offset,	    stopIndexPlusOne: last.limit],	  to: [	    blockPointer: LOOPHOLE[w.bytes], startIndex: last.offset-delta,	    stopIndexPlusOne: last.limit-delta],	  overLap: move];	IF nLastSwitch # 0 THEN {	  middle.limit _ last.offset+delta - nLastSwitch;	  w.bytes[middle.limit] _ selectCode; middle.limit _ middle.limit+1;	  IF nLastSwitch = 3 THEN {	    w.bytes[middle.limit] _ selectCode; middle.limit _ middle.limit+1;            w.bytes[middle.limit] _ 0}          ELSE w.bytes[middle.limit] _ last.context.prefix};	w.limit _ w.limit - delta}};      END.  LOG  date - person - comment 6-Apr-84 - Ching - Move Equivalent, UpperCase, LowerCase, Decase to XStringCompareImpl. 	Fix AR 6207 in ReaderToNumber.28-Jun-84 22:54:46 - Saund - fix AR 9278  :XComSoft: US Error[multipleCharSets] raised incorrectly  
-- File: NSFileCourierUtilityBImpl.mesa - last edit:-- Mita.ES             31-Mar-87 14:47:05-- Hanzel.ES           31-Mar-87 13:56:57-- Ciccone	        20-Dec-83 13:54:36-- Copyright (C) 1981, 1982, 1983, 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.-- Overview: Partial implementation of NSFileCourier: description routinesDIRECTORY  Auth USING [DescribeCredentials, DescribeVerifier],  Courier USING [Description, Notes],  Heap USING [FreeNode],  NSDataStream USING [DescribeTicket],  NSAssignedTypes USING [checksum, subtreeSizeLimit],  NSFile USING [    Access, AccessType, ControlType, Error, fullAccess,    Filter, FilterType, Handle, nullOrdering, Ordering, OrderingType, Scope, ScopeType],  NSFileCourier,  -- about everything  NSName USING [DescribeNameRecord],  NSString USING [FreeString, String];NSFileCourierUtilityBImpl: PROGRAM  IMPORTS Auth, Heap, NSDataStream, NSFile, NSFileCourier, NSName, NSString  EXPORTS NSFileCourier =  BEGIN OPEN NSFileCourier;    fullAccessProtocol: CARDINAL = 65535;  -- taken from 10.0 NSFileCourier  --Types  Filter: TYPE = NSFile.Filter;  -- Useful inlines  GetWord: PROC [notes: Courier.Notes] RETURNS [u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  PutWord: PROC [notes: Courier.Notes, u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  --Encoding/Decoding of Scope  DecodeProtocolScope: PUBLIC PROCEDURE [    scopeList: ScopeList, zone: UNCOUNTED ZONE] RETURNS [scope: NSFile.Scope] =    BEGIN    scopes: ARRAY NSFile.ScopeType OF BOOLEAN _ ALL[FALSE];    FOR i: CARDINAL IN [0..LENGTH[scopeList]) DO      lptScope: LONG POINTER TO Scope = @scopeList[i];      IF scopes[lptScope.type] THEN        NSFile.Error[[scopeValue[duplicated, lptScope.type]]];      scopes[lptScope.type] _ TRUE;      WITH s: lptScope SELECT FROM        count => scope.count _ s.value;        depth => scope.depth _ s.value;        direction => scope.direction _ s.value;        filter => scope.filter _ s.value;        ordering => scope.ordering _ s.value;        ENDCASE;      ENDLOOP;    END;  -- of DecodeProtocolScope  EncodeScope: PUBLIC PROC [    scope: LONG POINTER TO NSFile.Scope, zone: UNCOUNTED ZONE]    RETURNS [scopeList: ScopeList] =    BEGIN    ScopeSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Scope];    defaulted: ARRAY NSFile.ScopeType OF BOOLEAN = [      count: scope.count = LAST[CARDINAL], depth: scope.depth = 1,      direction: scope.direction = forward, filter: scope.filter = [all[]],      ordering: scope.ordering = NSFile.nullOrdering];    elements: CARDINAL _ 0;    FOR i: NSFile.ScopeType IN NSFile.ScopeType DO      IF NOT defaulted[i] THEN elements _ elements + 1; ENDLOOP;    IF elements = 0 THEN RETURN[NIL];    scopeList _ DESCRIPTOR[zone.NEW[ScopeSequence [elements]], elements];    elements _ 0;    FOR i: NSFile.ScopeType IN NSFile.ScopeType DO      IF defaulted[i] THEN LOOP;      SELECT i FROM        count => scopeList[elements] _ [count[scope.count]];        depth => scopeList[elements] _ [depth[scope.depth]];        direction => scopeList[elements] _ [direction[scope.direction]];        filter => scopeList[elements] _ [filter[scope.filter]];        ordering => scopeList[elements] _ [ordering[scope.ordering]];        ENDCASE;      elements _ elements + 1;      ENDLOOP;    END;  -- of EncodeScope  FreeProtocolScope: PUBLIC PROC [scopeList: ScopeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[scopeList] = NIL THEN RETURN;    Heap.FreeNode[zone, BASE[scopeList]];    --Attached Filters belong to client and must not be freed    END;  -- of FreeProtocolScope  --  Interface To Descriptions  GetRemoteProcedureDescriptions: PUBLIC PROCEDURE    RETURNS [procedures: RemoteProcedureDescriptionsHandle] = {    RETURN[@procedureDescriptions]};  GetRemoteErrorDescriptions: PUBLIC PROCEDURE    RETURNS [errors: RemoteErrorDescriptionsHandle] = {    RETURN[@errorDescriptions]};  procedureDescriptions: RemoteProcedureDescriptions _ [    Logon: [LogonArgumentsDescription, SessionDescription],    Logoff: [SessionDescription, NIL],    Open: [OpenArgumentsDescription, FileHandleDescription],    Close: [CloseArgumentsDescription, NIL],    Create: [CreateArgumentsDescription, FileHandleDescription],    Delete: [DeleteArgumentsDescription, NIL],    GetControls: [GetControlsArgumentsDescription, ControlsListDescription],    ChangeControls: [ChangeControlsArgumentsDescription, NIL],    GetAttributes: [GetAttributesArgumentsDescription, DescribeAttributes],    ChangeAttributes: [ChangeAttributesArgumentsDescription, NIL],    Copy: [CopyArgumentsDescription, FileHandleDescription],    Move: [MoveArgumentsDescription, NIL],    Store: [StoreArgumentsDescription, FileHandleDescription],    Retrieve: [RetrieveArgumentsDescription, NIL],    Replace: [ReplaceArgumentsDescription, NIL],    Serialize: [SerializeArgumentsDescription, NIL],    Deserialize: [DeserializeArgumentsDescription, FileHandleDescription],    Find: [FindArgumentsDescription, FileHandleDescription],    List: [ListArgumentsDescription, NIL],    Probe: [SessionDescription, ProbeResultsDescription],    UnifyAccessLists: [UnifyAccessListsArgumentsDescription, NIL]];  errorDescriptions: RemoteErrorDescriptions _ [    AttributeTypeError: [AttributeTypeErrorArgumentsDescription],    AttributeValueError: [AttributeValueErrorArgumentsDescription],    ControlTypeError: [ControlTypeErrorArgumentsDescription],    ControlValueError: [ControlValueErrorArgumentsDescription],    ScopeTypeError: [ScopeTypeErrorArgumentsDescription],    ScopeValueError: [ScopeValueErrorArgumentsDescription],    AccessError: [AccessErrorArgumentsDescription],    AuthenticationError: [AuthenticationErrorArgumentsDescription],    ConnectionError: [ConnectionErrorArgumentsDescription],    HandleError: [HandleErrorArgumentsDescription],    InsertionError: [InsertionErrorArgumentsDescription],    ServiceError: [ServiceErrorArgumentsDescription],    SessionError: [SessionErrorArgumentsDescription],    SpaceError: [SpaceErrorArgumentsDescription],    TransferError: [TransferErrorArgumentsDescription],    UndefinedError: [UndefinedErrorArgumentsDescription]];  controlVariantSizes: ARRAY [0..maxControlItems) OF CARDINAL _ [    -- lock: 0 -- SIZE[lock NSFileCourier.Control],    -- timeout: 1 -- SIZE[timeout NSFileCourier.Control],    -- access: 2 -- SIZE[access NSFileCourier.Control]];  maxControlItems: CARDINAL = 3;  -- ordinality of NSFile.ControlType  filterVariantSizes: ARRAY [0..12) OF CARDINAL _ [    -- less: 0 -- SIZE[less Filter],    -- lessOrEqual: 1 -- SIZE[lessOrEqual Filter],    -- equal: 2 -- SIZE[equal Filter],    -- notEqual: 3 -- SIZE[notEqual Filter],    -- greaterOrEqual: 4 -- SIZE[greaterOrEqual Filter],    -- greater: 5 -- SIZE[greater Filter],    -- and: 6 -- SIZE[and Filter],    -- or: 7 -- SIZE[or Filter],    -- not: 8 -- SIZE[not Filter],    -- none: 9 -- SIZE[none Filter],    -- all: 10 -- SIZE[all Filter],    -- matches: 11 -- SIZE[matches Filter]];  -- see ScopeDescription  scopeVariantSizes: ARRAY [0..maxScopeItems) OF CARDINAL _ [    -- count: 0 -- SIZE[count Scope],    -- direction: 1 -- SIZE[direction Scope],    -- filter: 2 -- SIZE[filter Scope],    -- ordering: 3 -- SIZE[depth Scope],  -- following are reversed intentionally!    -- depth 4 -- SIZE[ordering Scope]];    maxScopeItems: CARDINAL = 5;  -- ordinality of NSFile.ScopeType  -- Description Procedures  AttributeTypeListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO AttributeTypeList = noteSize[      size: SIZE[AttributeTypeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[AttributeType],      upperBound: LAST[CARDINAL]];    IF BASE[parameters^] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters^]) DO        noteLongCardinal[@parameters^[element2]]; ENDLOOP;    END;  ControlDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Control = noteSize[size: SIZE[Control]];    notes.noteDeadSpace[parameters, SIZE[Control]]; -- consume it all at start        --handle the type    SELECT notes.operation FROM      fetch => PutWord[notes, parameters.type];      store => LOOPHOLE[        parameters, LONG POINTER TO NSFile.ControlType]­ _ GetWord[notes];      ENDCASE;    -- ...then the value    WITH variant: parameters^ SELECT FROM      access => {        SELECT notes.operation FROM	  fetch => {	    access: NSFile.Access _ variant.value;            IF access = NSFile.fullAccess THEN {              PutWord[notes, 1];              PutWord[notes, fullAccessProtocol]}            ELSE {	      elements: CARDINAL _ 0;              FOR i: NSFile.AccessType IN NSFile.AccessType DO                IF access[i] THEN elements _ elements + 1; ENDLOOP;                PutWord[notes, elements];              IF elements # 0 THEN                FOR i: NSFile.AccessType IN NSFile.AccessType DO	          IF access[i] THEN PutWord[notes, ORD[i]]; ENDLOOP}	     };  -- of fetch	  store => {	    accessType: NSFile.AccessType;            accessTypeListLength: CARDINAL ¬ GetWord[notes];	    FOR i: CARDINAL IN [0..accessTypeListLength) DO	      SELECT accessType ¬ GetWord[notes] FROM	        fullAccessProtocol => 	          IF accessTypeListLength = 1 THEN		    variant.value _ NSFile.fullAccess		  ELSE NSFile.Error[[attributeValue[illegal, accessList]]];		ENDCASE => variant.value[accessType] _ TRUE;	      ENDLOOP;            }; -- of store	  ENDCASE;	};  -- of access      timeout =>        SELECT notes.operation FROM	  fetch => PutWord[notes, variant.value];	  store => variant.value _ GetWord[notes];	  ENDCASE;      lock =>        SELECT notes.operation FROM	  fetch => PutWord[notes, variant.value];	  store => variant.value _ GetWord[notes];	  ENDCASE;      ENDCASE;    END;  ControlsListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlsList = noteSize[size: SIZE[ControlsList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Control], upperBound: maxControlItems];    IF BASE[parameters^] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters^]) DO        noteParameters[@parameters^[element2], ControlDescription]; ENDLOOP;    END;  ControlTypeListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlTypeList = noteSize[      size: SIZE[ControlTypeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[NSFile.ControlType],      upperBound: maxControlItems];    END;  FileHandleDescription: Courier.Description = {    [] _ notes.noteSize[SIZE[NSFile.Handle]]};  FilterDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Filter = noteSize[size: SIZE[Filter]];    noteChoice[parameters, SIZE[Filter], DESCRIPTOR[filterVariantSizes]];    WITH variant: parameters^ SELECT FROM      less, lessOrEqual, equal, notEqual, greaterOrEqual, greater =>        noteParameters[@variant.attribute, DescribeAttribute];      matches => noteParameters[@variant.attribute, DescribeAttribute];      and, or =>        BEGIN        noteArrayDescriptor[          site: @variant.list, elementSize: SIZE[Filter],          upperBound: LAST[CARDINAL]];        IF BASE[variant.list] # NIL THEN          FOR i: CARDINAL IN [0..LENGTH[variant.list]) DO            noteParameters[@variant.list[i], FilterDescription]; ENDLOOP;        END;      not => noteDisjointData[@variant.filter, FilterDescription];      none, all => NULL;      ENDCASE;    END;  -- of FilterDescription  NSStringDescription: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSString.String = notes.noteSize[SIZE[NSString.String]];    notes.noteDeadSpace[site, SIZE[NSString.String]];    SELECT notes.operation FROM      store => site^ _ GetNSString[notes];      fetch => PutNSString[notes, site^];      free => NSString.FreeString[zone, site^];      ENDCASE;    END;  -- of NSStringDescription  -- NOTE: Here we must reverse the 'ordering' and 'depth' scope type encodings since these changed from Filing 4 to Filing 5    ScopeDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO Scope;    scopeType: LONG POINTER TO NSFile.ScopeType;        -- the following is nested here so as not to disturb packaging    DescribeOrdering: Courier.Description = {      ordering: LONG POINTER TO extended NSFile.Ordering = notes.noteSize[        SIZE[NSFile.Ordering]];      notes.noteDeadSpace [LOOPHOLE[@ordering.type], SIZE[NSFile.OrderingType]];      notes.noteLongCardinal [@ordering.key];      -- other fields are implicitly passed because they are unnoted      IF notes.operation = store THEN {        IF ordering.key IN          [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] THEN            LOOPHOLE[@ordering.type, LONG POINTER TO NSFile.OrderingType]­ ¬ key        ELSE LOOPHOLE[          @ordering.type, LONG POINTER TO NSFile.OrderingType]­ ¬ extended}     };        parameters _ noteSize[size: SIZE[Scope]];    scopeType _ LOOPHOLE[parameters];    SELECT scopeType^ FROM      depth => scopeType^ _ ordering;  -- reverse for Filing 5 compatibility      ordering => scopeType^ _ depth;      ENDCASE;    noteChoice[      site: parameters, size: SIZE[Scope],      variant: DESCRIPTOR[scopeVariantSizes]];    SELECT scopeType^ FROM      depth => scopeType^ _ ordering;  -- undo reversal for proper serialization      ordering => scopeType^ _ depth;      ENDCASE;    WITH s: parameters^ SELECT FROM      filter => noteParameters[@s.value, FilterDescription];      ordering => noteParameters[@s.value, DescribeOrdering];      ENDCASE;    END;  -- of ScopeDescription  ScopeListDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeList = noteSize[size: SIZE[ScopeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Scope], upperBound: maxScopeItems];    IF BASE[parameters^] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters^]) DO        noteParameters[@parameters^[element2], ScopeDescription]; ENDLOOP;    END;  SessionDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFileCourier.Session = noteSize[      size: SIZE[NSFileCourier.Session]];    noteParameters[@parameters.verifier, Auth.DescribeVerifier];    END;  LogonArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO LogonArguments = noteSize[SIZE[LogonArguments]];    BEGIN OPEN rec: parameters;    noteParameters[@rec.service, NSName.DescribeNameRecord];    noteParameters[@rec.credentials, Auth.DescribeCredentials];    noteParameters[@parameters.verifier, Auth.DescribeVerifier];    END;  --OPEN parameters--    END;  ProbeResultsDescription: Courier.Description --[notes: Notes]--  = {    [] _ notes.noteSize[size: SIZE[ProbeResults]]};  CreateArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CreateArguments = noteSize[SIZE[CreateArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  CopyArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CopyArguments = noteSize[SIZE[CopyArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  MoveArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO MoveArguments = noteSize[SIZE[MoveArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.session, SessionDescription];    END;  DeleteArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO DeleteArguments = noteSize[      size: SIZE[DeleteArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  ListArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ListArguments = noteSize[SIZE[ListArguments]];    noteParameters[@rec.selections, AttributeTypeListDescription];    noteParameters[@rec.scope, ScopeListDescription];    noteParameters[@rec.listing, NSDataStream.DescribeTicket];    noteParameters[@rec.session, SessionDescription];    END;  GetAttributesArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO GetAttributesArguments = noteSize[      size: SIZE[GetAttributesArguments]];    noteParameters[@parameters.selections, AttributeTypeListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  ChangeAttributesArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ChangeAttributesArguments = noteSize[      SIZE[ChangeAttributesArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.session, SessionDescription];    END;  UnifyAccessListsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO UnifyAccessListsArguments = noteSize[      size: SIZE[UnifyAccessListsArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  OpenArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO OpenArguments = noteSize[SIZE[OpenArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  CloseArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO CloseArguments = noteSize[      size: SIZE[CloseArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  ChangeControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ChangeControlsArguments = noteSize[      size: SIZE[ChangeControlsArguments]];    noteParameters[@parameters.controls, ControlsListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  GetControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO GetControlsArguments = noteSize[      size: SIZE[GetControlsArguments]];    noteParameters[@parameters.controlSelections, ControlTypeListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  RetrieveArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO RetrieveArguments = noteSize[      size: SIZE[RetrieveArguments]];    noteParameters[@parameters.content, NSDataStream.DescribeTicket];    noteParameters[@parameters.session, SessionDescription];    END;  ReplaceArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ReplaceArguments = noteSize[SIZE[ReplaceArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.content, NSDataStream.DescribeTicket];    noteParameters[@rec.session, SessionDescription];    END;  SerializeArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SerializeArguments = noteSize[      size: SIZE[SerializeArguments]];    BEGIN OPEN rec: parameters;    noteParameters[@rec.serializedFile, NSDataStream.DescribeTicket];    noteParameters[@parameters.session, SessionDescription];    END;  --OPEN parameters--    END;  StoreArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO StoreArguments = noteSize[SIZE[StoreArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.content, NSDataStream.DescribeTicket];    noteParameters[@rec.session, SessionDescription];    END;  DeserializeArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO DeserializeArguments = noteSize[      SIZE[DeserializeArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.serializedFile, NSDataStream.DescribeTicket];    noteParameters[@rec.session, SessionDescription];    END;  FindArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO FindArguments = noteSize[SIZE[FindArguments]];    noteParameters[@rec.scope, ScopeListDescription];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  AttributeTypeErrorArgumentsDescription, AttributeValueErrorArgumentsDescription:    Courier.Description  --[notes: Notes]--     =    BEGIN OPEN notes;    parameters: LONG POINTER TO AttributeTypeErrorArguments = noteSize[      size: SIZE[AttributeTypeErrorArguments]];    noteLongCardinal[@parameters.type];    END;  ControlTypeErrorArgumentsDescription, ControlValueErrorArgumentsDescription:    Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlTypeErrorArguments = noteSize[      size: SIZE[ControlTypeErrorArguments]];    END;  ScopeTypeErrorArgumentsDescription, ScopeValueErrorArgumentsDescription:    Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeTypeErrorArguments = noteSize[      size: SIZE[ScopeTypeErrorArguments]];    END;  AccessErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO AccessErrorArguments = noteSize[      size: SIZE[AccessErrorArguments]];    END;  AuthenticationErrorArgumentsDescription: Courier.Description  --[notes: Notes]--     =    BEGIN OPEN notes;    parameters: LONG POINTER TO AuthenticationErrorArguments = noteSize[      size: SIZE[AuthenticationErrorArguments]];    END;  ConnectionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ConnectionErrorArguments = noteSize[      size: SIZE[ConnectionErrorArguments]];    END;  HandleErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO HandleErrorArguments = noteSize[      size: SIZE[HandleErrorArguments]];    END;  InsertionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO InsertionErrorArguments = noteSize[      size: SIZE[InsertionErrorArguments]];    END;  ServiceErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ServiceErrorArguments = noteSize[      size: SIZE[ServiceErrorArguments]];    END;  SessionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SessionErrorArguments = noteSize[      size: SIZE[SessionErrorArguments]];    END;  SpaceErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SpaceErrorArguments = noteSize[      size: SIZE[SpaceErrorArguments]];    END;  TransferErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO TransferErrorArguments = noteSize[      size: SIZE[TransferErrorArguments]];    END;  UndefinedErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO UndefinedErrorArguments = noteSize[      size: SIZE[UndefinedErrorArguments]];    END;  --  No Module Initialization   END.    LOG (date - person - action)- - - - SERVICES 8.0 - - - -November 16, 1983 - Hanzel - Initial conversion to Services 8.0 and Klamath Courier.December 4, 1983 - Hanzel - Correctly handle new 'depth' ScopeType in Encode/DecodeScopeList.December 5, 1983 - Hanzel - Correct use of notes.operation in ScopeDescription for proper handling of 'ordering'.20-Dec-83 13:55:01 - Ciccone - Removed zone parameter from GetNSString.- - - - SERVICES 8.0.12 - - - -March 3, 1987 - Hanzel - Rework ScopeDescription routine to reverse sense of 'ordering' and 'depth' ScopeType encodings (change between Filing 4 and Filing 5 implementations).March 31, 1987 - Hanzel - Note dead space appropriately for ordering scope type in ScopeDescription.
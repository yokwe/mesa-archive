-- File: NSFileCourier.mesa - last edit:-- AOF                  8-Jan-87 17:00:00-- Hanzel              18-Aug-84 21:06:06 -- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [AuthenticationProblem, Credentials, Verifier],  Courier USING [Description, Dispatcher, Handle, Notes],  NSDataStream USING [Ticket],  NSFile USING [    Access, AccessProblem, ArgumentProblem,    Attribute, AttributeList, Attributes,    BooleanFalseDefault, ConnectionProblem,    Controls, ControlSelections, ControlType, Direction, Filter,    Handle, HandleProblem, InsertionProblem, Interpretation, Lock,    Ordering, Scope, ScopeType, Selections,    ServiceProblem, Session, SessionProblem, SpaceProblem,    SystemElement, Timeout, TransferProblem, UndefinedProblem],  NSName USING [NameRecord],  NSString USING [String],  NetworkStream USING [ClassOfService],  Stream USING [Handle];NSFileCourier: DEFINITIONS =   BEGIN    -- Constants    zone: UNCOUNTED ZONE;  -- Binding Data  programNumber: LONG CARDINAL = 10;  versionNumber: CARDINAL = 4;  classOfService: NetworkStream.ClassOfService;    -- Protocol session  Session: TYPE = RECORD [    token: NSFile.Session,  -- session on remote system element    verifier: Auth.Verifier];      --  Stream usage stuff.  dataStreamUsed: PACKED ARRAY RemoteProcedureIndex OF NSFile.BooleanFalseDefault =    [List: TRUE, Retrieve: TRUE, Replace: TRUE, Serialize: TRUE, Store: TRUE,    Deserialize: TRUE];    --   --   --   --   --   --   --   --  -- REMOTE PROCEDURES :  --   --   --   --   --   --   --   --  -- Procedure numbers  RemoteProcedureIndex: TYPE = MACHINE DEPENDENT {    -- standard    Logon(0), Logoff(1), Open(2), Close(3), Create(4), Delete(5), GetControls(6),    ChangeControls(7), GetAttributes(8), ChangeAttributes(9), Copy(10),    Move(11), Store(12), Retrieve(13), Replace(14), Serialize(15),    Deserialize(16), Find(17), List(18), --Continue-- Probe (19),    -- extended    UnifyAccessLists(20)};    -- Arguments and results:    LogonArguments: TYPE = RECORD [    service: NSName.NameRecord,    credentials: Auth.Credentials,    verifier: Auth.Verifier];  LogonResults: TYPE = RECORD [session: Session];    LogoffArguments: TYPE = RECORD [session: Session];  LogoffResults: TYPE = RECORD [];    OpenArguments: TYPE = RECORD [    attributes: NSFile.AttributeList,    directory: NSFile.Handle,    controls: ControlsList,    session: Session];  OpenResults: TYPE = RECORD [file: NSFile.Handle];    CloseArguments: TYPE = RECORD [file: NSFile.Handle, session: Session];  CloseResults: TYPE = RECORD [];    CreateArguments: TYPE = RECORD [    directory: NSFile.Handle,    attributes: NSFile.AttributeList,    controls: ControlsList,    session: Session];  CreateResults: TYPE = RECORD [file: NSFile.Handle];    DeleteArguments: TYPE = RECORD [file: NSFile.Handle, session: Session];  DeleteResults: TYPE = RECORD [];    GetControlsArguments: TYPE = RECORD [    file: NSFile.Handle,    controlSelections: ControlTypeList,    session: Session];  GetControlsResults: TYPE = RECORD [controls: ControlsList];    ChangeControlsArguments: TYPE = RECORD [    file: NSFile.Handle,    controls: ControlsList,    session: Session];  ChangeControlsResults: TYPE = RECORD [];    GetAttributesArguments: TYPE = RECORD [    file: NSFile.Handle, selections: AttributeTypeList, session: Session];  GetAttributesResults: TYPE = RECORD [attributes: NSFile.AttributeList];    ChangeAttributesArguments: TYPE = RECORD [    file: NSFile.Handle,    attributes: NSFile.AttributeList,    session: Session];  ChangeAttributesResults: TYPE = RECORD [];    CopyArguments: TYPE = RECORD [    file: NSFile.Handle,    destination: NSFile.Handle,    attributes: NSFile.AttributeList,    controls: ControlsList,    session: Session];  CopyResults: TYPE = RECORD [newFile: NSFile.Handle];    MoveArguments: TYPE = RECORD [    file: NSFile.Handle,    destination: NSFile.Handle,    attributes: NSFile.AttributeList,    session: Session];  MoveResults: TYPE = RECORD [];    StoreArguments: TYPE = RECORD [    directory: NSFile.Handle,    attributes: NSFile.AttributeList,    controls: ControlsList,    content: NSDataStream.Ticket,    session: Session];  StoreResults: TYPE = RECORD [file: NSFile.Handle];    RetrieveArguments: TYPE = RECORD [    file: NSFile.Handle,    content: NSDataStream.Ticket,    session: Session];  RetrieveResults: TYPE = RECORD [];    ReplaceArguments: TYPE = RECORD [    file: NSFile.Handle,    attributes: NSFile.AttributeList,    content: NSDataStream.Ticket,    session: Session];  ReplaceResults: TYPE = RECORD [];    SerializeArguments: TYPE = RECORD [    file: NSFile.Handle,    serializedFile: NSDataStream.Ticket,    session: Session];  SerializeResults: TYPE = RECORD [];    DeserializeArguments: TYPE = RECORD [    directory: NSFile.Handle,    attributes: NSFile.AttributeList,    controls: ControlsList,    serializedFile: NSDataStream.Ticket,    session: Session];  DeserializeResults: TYPE = RECORD [file: NSFile.Handle];    FindArguments: TYPE = MACHINE DEPENDENT RECORD [    directory(0): NSFile.Handle,    scope(2): ScopeList,    controls(5): ControlsList,    session(8): Session];  FindResults: TYPE = RECORD [fileHandle: NSFile.Handle];    ListArguments: TYPE = MACHINE DEPENDENT RECORD [    directory(0): NSFile.Handle,    selections(2): AttributeTypeList,    scope(5): ScopeList,    listing(8): NSDataStream.Ticket,    session(19): Session];  ListResults: TYPE = RECORD [];    ProbeArguments: TYPE = RECORD [session: Session];  ProbeResults: TYPE = RECORD [probeWithin: CARDINAL];    UnifyAccessListsArguments: TYPE = RECORD [    directory: NSFile.Handle, session: Session];  UnifyAccessListsResults: TYPE = RECORD [];    --   --   --   --   --   --   --   --  -- REMOTE ERRORS :  --   --   --   --   --   --   --   --    -- Error numbers      RemoteErrorIndex: TYPE = MACHINE DEPENDENT {    AttributeTypeError(0), AttributeValueError(1),    ControlTypeError(2), ControlValueError(3),    ScopeTypeError(4), ScopeValueError(5),    AccessError(6), AuthenticationError(7), ConnectionError(8),    HandleError(9), InsertionError(10), ServiceError(11), SessionError(12),    SpaceError(13), TransferError(14), UndefinedError(15)};    -- Arguments  AttributeTypeErrorArguments,  AttributeValueErrorArguments: TYPE = MACHINE DEPENDENT RECORD [    problem(0): NSFile.ArgumentProblem,    type(1): LONG CARDINAL];      ControlTypeErrorArguments,  ControlValueErrorArguments: TYPE = MACHINE DEPENDENT RECORD [    problem(0): NSFile.ArgumentProblem,    type(1): NSFile.ControlType];      ScopeTypeErrorArguments,  ScopeValueErrorArguments: TYPE = MACHINE DEPENDENT RECORD [    problem(0): NSFile.ArgumentProblem,    type(1): NSFile.ScopeType];	  AccessErrorArguments: TYPE = RECORD [problem: NSFile.AccessProblem];    AuthenticationErrorArguments: TYPE = RECORD [    problem: Auth.AuthenticationProblem];      ConnectionErrorArguments: TYPE = RECORD [problem: NSFile.ConnectionProblem];    HandleErrorArguments: TYPE = RECORD [problem: NSFile.HandleProblem];    InsertionErrorArguments: TYPE = RECORD [problem: NSFile.InsertionProblem];    ServiceErrorArguments: TYPE = RECORD [problem: NSFile.ServiceProblem];    SessionErrorArguments: TYPE = RECORD [problem: NSFile.SessionProblem];    SpaceErrorArguments: TYPE = RECORD [problem: NSFile.SpaceProblem];    TransferErrorArguments: TYPE = RECORD [problem: NSFile.TransferProblem];    UndefinedErrorArguments: TYPE = RECORD [problem: CARDINAL];    --   --   --   --   --   --   --   --  -- PARAMETER ENCODING :  --   --   --   --   --   --   --   --  -- These operations perform conversions necessary to produce the right type of object for conforming to the network protocol.  AttributeSequences, but not AttributeLists or AttributesRecords, are part of the protocol.  -- EncodeAttributes converts an attributes record into an attribute list.  -- DecodeAttributes converts an attriubute list into an attributes record.    -- Types    AttributeListProc: TYPE =    PROCEDURE [list: NSFile.AttributeList] RETURNS [continue: BOOLEAN _ TRUE];    AttributeSequenceType: TYPE = MACHINE DEPENDENT {nextSegment(0), lastSegment(1)};    AttributeSequenceHeader: TYPE = MACHINE DEPENDENT RECORD [    type(0): AttributeSequenceType,    lists(1): CARDINAL];  -- number of lists in this (sub) sequence    AttributeType: PUBLIC TYPE = LONG CARDINAL;    AttributeTypeList: PUBLIC TYPE = LONG DESCRIPTOR FOR ARRAY OF AttributeType;   Control: TYPE = MACHINE DEPENDENT RECORD [    var(0): SELECT type(0): NSFile.ControlType FROM      lock => [value(1): NSFile.Lock],      timeout => [value(1): NSFile.Timeout],      access => [value(1): NSFile.Access],      ENDCASE];    ControlsList: TYPE = LONG DESCRIPTOR FOR ARRAY OF Control;    ControlTypeList: TYPE = LONG DESCRIPTOR FOR ARRAY OF NSFile.ControlType;    Ordering: TYPE = MACHINE DEPENDENT RECORD [    key(0): AttributeType,    ascending(2): BOOLEAN,    interpretation(3): NSFile.Interpretation _ none];    Scope: TYPE = MACHINE DEPENDENT RECORD [    var(0): SELECT type(0): NSFile.ScopeType FROM      count => [value(1): CARDINAL],      depth => [value(1): CARDINAL],      direction => [value(1): NSFile.Direction],      filter => [value(1): NSFile.Filter],      ordering => [value(1): NSFile.Ordering],      ENDCASE];    ScopeList: TYPE = LONG DESCRIPTOR FOR ARRAY OF Scope;    -- Constants  allSelectionsProtocol: PUBLIC AttributeType = LAST[LONG CARDINAL];  -- allAttributeTypes of protocol definition    -- Procedures    EncodeAttributes: PUBLIC PROCEDURE [    from: NSFile.Attributes, selections: AttributeTypeList, zone: UNCOUNTED ZONE]    RETURNS [list: NSFile.AttributeList];  -- Return a list of attribute values for selected attributes of an attribute record. Secondary data structures are NOT copied (strings and words), although the returned list structure itself must be deallocated by the caller. If from.isDirectory is FALSE, directory attributes are included as extended[*, NIL] values with the appropriate type; if from.isTemporary is FALSE, parent attributes are included as extended[*, NIL] values with the appropriate type.  THe client must guarantee the validity of from.isDirectory and from.isTemporary.  The order of attributes within the result is the same as that within selections.      DecodeAttributes: PUBLIC PROCEDURE [    from: NSFile.AttributeList, to: NSFile.Attributes, zone: UNCOUNTED ZONE];  -- Copy attribute values within an attribute list to corresponding locations of an attribute record.  Secondary data structures are NOT copied (strings and words), althougth the list structure allocated for extended attributes must be deallocated by the caller.    EncodeControls: PUBLIC PROCEDURE [    controls: NSFile.Controls, controlSelections: NSFile.ControlSelections,    zone: UNCOUNTED ZONE] RETURNS [controlsList: ControlsList];    DecodeControls: PUBLIC PROCEDURE [controlsList: ControlsList]    RETURNS [      controls: NSFile.Controls, controlSelections: NSFile.ControlSelections];      FreeControls: PUBLIC PROCEDURE [    controlsList: ControlsList, zone: UNCOUNTED ZONE];        EncodeControlSelections: PUBLIC PROCEDURE [    controlSelections: NSFile.ControlSelections, zone: UNCOUNTED ZONE]    RETURNS[controlTypeList: ControlTypeList];    DecodeControlSelections: PUBLIC PROCEDURE [controlTypeList: ControlTypeList]    RETURNS [controlSelections: NSFile.ControlSelections];    FreeControlSelections: PUBLIC PROCEDURE [    controlTypeList: ControlTypeList, zone: UNCOUNTED ZONE];    EncodeScope: PUBLIC PROCEDURE [    scope: LONG POINTER TO NSFile.Scope, zone: UNCOUNTED ZONE]    RETURNS [scopeList: ScopeList];  -- Client must invoke FreeProtocolScope when finished with the result of this operation.    DecodeProtocolScope: PUBLIC PROCEDURE [    scopeList: ScopeList, zone: UNCOUNTED ZONE] RETURNS [scope: NSFile.Scope];    FreeProtocolScope: PUBLIC PROCEDURE [    scopeList: ScopeList, zone: UNCOUNTED ZONE];    EncodeSelections: PUBLIC PROCEDURE [    selections: NSFile.Selections, zone: UNCOUNTED ZONE]    RETURNS [attributeTypeList: AttributeTypeList];    DecodeSelections: PUBLIC PROCEDURE [    attributeTypeList: AttributeTypeList, zone: UNCOUNTED ZONE]    RETURNS [selections: NSFile.Selections];    FreeAttributeTypeList: PUBLIC PROCEDURE [    attributeTypeList: AttributeTypeList, zone: UNCOUNTED ZONE];    FreeSelections: PUBLIC PROCEDURE [    selections: NSFile.Selections, zone: UNCOUNTED ZONE];  -- Free extended portion of a selections.  -- Serialization  -- SerializeMumble routines take a filing data structure, converts it to an internal form (suitable for Courier management) and places that reformatted data onto the stream. DeserializeMumble takes the encrypted information from the stream and converts it back into the normal form.  SerializeAttributes: PUBLIC PROCEDURE [    attributes: NSFile.AttributeList, sH: Stream.Handle];      DeserializeAttributes: PUBLIC PROCEDURE [    sH: Stream.Handle, zone: UNCOUNTED ZONE]    RETURNS [attributes: NSFile.AttributeList];    FreeAttributes: PUBLIC PROCEDURE [    attributes: NSFile.AttributeList, zone: UNCOUNTED ZONE];    SerializeAttributeSequenceHeader: PUBLIC PROCEDURE [    header: AttributeSequenceHeader, sH: Stream.Handle];    DeserializeStreamOfAttributeSequence: PUBLIC PROCEDURE [    proc: AttributeListProc, sH: Stream.Handle];  -- Invoke the client-supplied proc once for each attribute list deserialized from the stream of attribute sequences on the given stream. This operation is required because Courier does not support sequences of sequences directly. It is the caller's responsibility to abort and delete the stream if deserialization is to be terminated prematurely.      --   --   --   --   --   --   --   --  -- PARAMETER DESCRIPTIONS :  --   --   --   --   --   --   --   --    DescribeAttribute: Courier.Description;  -- describe NSFile.Attribute    DescribeAttributes: Courier.Description;  -- describe NSFile.AttributeList  NSStringDescription: Courier.Description;    GetRemoteProcedureDescriptions: PROCEDURE    RETURNS [procedures: RemoteProcedureDescriptionsHandle];  GetRemoteErrorDescriptions: PROCEDURE    RETURNS [errors: RemoteErrorDescriptionsHandle];  RemoteProcedureDescriptionsHandle: TYPE = LONG POINTER TO READONLY    RemoteProcedureDescriptions;  RemoteErrorDescriptionsHandle: TYPE = LONG POINTER TO READONLY    RemoteErrorDescriptions;  RemoteProcedureDescriptions: TYPE = ARRAY RemoteProcedureIndex OF RECORD [    arguments, results: Courier.Description];  RemoteErrorDescriptions: TYPE = ARRAY RemoteErrorIndex OF RECORD [    arguments: Courier.Description];  --  Generic arguments and results (procedures and errors)  MaxArgumentRecordSize: CARDINAL = MAX [1,     SIZE[LogonArguments], SIZE[LogoffArguments], SIZE[OpenArguments],    SIZE[CloseArguments], SIZE[CreateArguments], SIZE[DeleteArguments],    SIZE[GetControlsArguments], SIZE[ChangeControlsArguments],    SIZE[GetAttributesArguments], SIZE[ChangeAttributesArguments],    SIZE[CopyArguments], SIZE[MoveArguments], SIZE[StoreArguments],    SIZE[RetrieveArguments], SIZE[ReplaceArguments],    SIZE[SerializeArguments], SIZE[DeserializeArguments],    SIZE[FindArguments], SIZE[ListArguments], SIZE[ProbeArguments],    SIZE[UnifyAccessListsArguments],        SIZE[AttributeTypeErrorArguments], SIZE[ControlTypeErrorArguments],    SIZE[ScopeTypeErrorArguments], SIZE[AccessErrorArguments],    SIZE[AuthenticationErrorArguments], SIZE[ConnectionErrorArguments],    SIZE[HandleErrorArguments], SIZE[InsertionErrorArguments],    SIZE[ServiceErrorArguments], SIZE[SessionErrorArguments],    SIZE[SpaceErrorArguments], SIZE[TransferErrorArguments],    SIZE[UndefinedErrorArguments]];    MaxResultRecordSize: CARDINAL = 5;  -- MAX [1,  -- SIZE[LogonResults], SIZE[LogoffResults], SIZE[OpenResults],  -- SIZE[CloseResults], SIZE[CreateResults], SIZE[DeleteResults],  -- SIZE[GetControlsResults], SIZE[ChangeControlsResults],  -- SIZE[GetAttributesResults], SIZE[ChangeAttributesResults],  -- SIZE[CopyResults], SIZE[MoveResults], SIZE[StoreResults],  -- SIZE[RetrieveResults], SIZE[ReplaceResults], SIZE[SerializeResults],  -- SIZE[DeserializeResults], SIZE[FindResults], SIZE[ListResults],  -- SIZE[ProbeResults], SIZE[UnifyAccessListsResults]];    GenericArgumentRecord: TYPE = ARRAY [0..MaxArgumentRecordSize) OF CARDINAL;    GenericResultRecord: TYPE = ARRAY [0..MaxResultRecordSize) OF CARDINAL;    -- Miscellaneous    CreateCourierHandle: PUBLIC PROCEDURE [systemElement: NSFile.SystemElement]    RETURNS [courierHandle: Courier.Handle];  -- Return a handle for a connection to the specified system element.  The resulting handle may only be used to speak to a server stub implementing the protocol defined herein (see programNumber and versionNumber above).    RegisterDispatcher: PUBLIC PROCEDURE [    version: CARDINAL, dispatcher: Courier.Dispatcher];  -- Register the appropriate dispatcher to be used for the given version of the protocol (necessary for export); intended to support previous protocol versions dynamically.    DeleteCourierHandle: PUBLIC PROCEDURE [courierHandle: Courier.Handle];  -- Terminate a connection such as returned by CreateCourierHandle.    GetNSString: PROCEDURE [notes: Courier.Notes]    RETURNS [string: NSString.String];      PutNSString: PROCEDURE [notes: Courier.Notes, string: NSString.String];  GetOrdering: PROCEDURE [    notes: Courier.Notes, site: LONG POINTER TO NSFile.Ordering];    PutOrdering: PROCEDURE [    notes: Courier.Notes, site: LONG POINTER TO NSFile.Ordering];  -- The following constants enumerate known error conditions which cannot be communicated by the protocol; in that sense they are undefined.   internalProblem: NSFile.UndefinedProblem = 0;  unimplemented: NSFile.UndefinedProblem = 1;  courierProblem: NSFile.UndefinedProblem = 2;  END.LOG  ( date - person - action )- - - - SERVICES 8.0 - - - - November 16, 1983 - Hanzel - Initial conversion to Services 8.0; versionNumber = 3.December 13, 1983 - Hanzel - Bump versionNumber to 4 since version 3 is needed for 860-SetVolume (and backward compatibility).December 19, 1983 - Hanzel - Elminate zone parameter to GetNSString (use that supplied in notes); define RegisterDispatcher.August 18, 1984 - Hanzel - Make all multi-word error argument definitions MACHINE DEPENDENT for correct Courier representation (AR 10816). 8-Jan-87 16:59:14 - AOF - Added LONG to POINTERs for MDS Relief
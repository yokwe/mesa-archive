--NSFileNameImpl.mesa-- Last edited by Gleason: 17-May-84 11:41:56-- Overview:  This interface provides routines for conversion between strings and full pathnames, i.e., pathnames that include a network location.  It also defines the standard separators used in string pathnames.DIRECTORY  Heap USING [systemZone],  NSFile USING [defaultService, nullService, Service, ServiceRecord],  NSFileName,  NSFilingGlobal USING [CacheService],  NSName USING [AppendNameToString, characterSetChangeOverhead, Error, FreeNameFields, MakeNameFields, NameFieldsFromString, NameRecord, NameTooSmall, separatorCharacter],   NSString USING [AppendCharacter, AppendString, AppendSubString, CopyString, EqualCharacter, FreeString, LogicalLength, MakeString, ScanForCharacter, StringBoundsFault, SubStringDescriptor];NSFileNameImpl: PROGRAM  IMPORTS Heap, NSFile, NSFilingGlobal, NSName, NSString   EXPORTS NSFileName =    BEGIN OPEN NSFileName;  --   --   --   --   --   --   --   --  -- EXPORTED VARIABLES  --   --   --   --   --   --   --   --  defaultDomain: PUBLIC String _ nullString;  defaultOrg: PUBLIC String _ nullString;    --   --   --   --   --   --   --   --  -- CONSTANTS AND VARIABLES  --   --   --   --   --   --   --   --    heap: UNCOUNTED ZONE = Heap.systemZone;  separatorOverhead: CARDINAL =  NSName.characterSetChangeOverhead + 1;    nullName: NSName.NameRecord _ [nullString, nullString, nullString];  defaultName: NSName.NameRecord _ [nullString, nullString, nullString];    --   --   --   --   --   --   --   --  -- SIGNALS AND ERRORS  --   --   --   --   --   --   --   --    Error: PUBLIC ERROR [type: ErrorType] = CODE;  --   --   --   --   --   --   --   --  -- PUBLIC OPERATIONS  --   --   --   --   --   --   --   -- --CONVERSIONS BETWEEN Strings AND VPNRecords  VPNFieldsFromString: PUBLIC PROCEDURE [    z: UNCOUNTED ZONE, s: String, destination: VPN] =  -- Divides a string containing a fully-qualified pathname into a VPNRecord (specified by destination). Conversion of the service name contained in s into an NSName.Name is done using NSName routines which are based on the separator character defined in NSName (:).   When s contains a service name which is missing domain and/or organization parts, these are filled in with the domain and org set using SetDefaultDomainAndOrg.  (If no defaults were set, then nullStrings are used.) This operation allocates space for the pathname portion of destination from z and the client is responsible for freeing it.  The service portion of destination becomes the property of the file system and the client should NOT try to free it.  The operations ClearVPN or FreeVPNFields can be used to free the pathname portion and nullify the service portion of destination.  This operation may report invalidSyntax.    BEGIN  serviceRec: NSFile.ServiceRecord;  serviceName: String _ nullString;  substr: NSString.SubStringDescriptor _ [s, 0, 0];  rightServicePosition, firstColonPosition: CARDINAL _ 0;    IF s.bytes = NIL OR s.length = 0 THEN ERROR Error [invalidSyntax];    BEGIN ENABLE UNWIND => {NSString.FreeString[heap, serviceName];      NSName.FreeNameFields[heap, @serviceRec.name]};        --split off service name  IF NOT NSString.EqualCharacter[leftServiceSeparator, s, 0] THEN {    destination.service _ NSFile.nullService;    destination.pathname _ NSString.CopyString[z, s];    RETURN};  substr.offset _ 1;  rightServicePosition _ NSString.ScanForCharacter[rightServiceSeparator, s, 1];  IF rightServicePosition = LAST[CARDINAL] THEN ERROR Error[invalidSyntax];    IF rightServicePosition = 1     THEN destination.service _ NSFile.defaultService    ELSE {    firstColonPosition _ NSString.ScanForCharacter[NSName.separatorCharacter, s, 1];    substr.length _ rightServicePosition - 1;    serviceName _ NSString.MakeString[heap, substr.length];    serviceName _ NSString.AppendSubString[to: serviceName, from: @substr !       NSString.StringBoundsFault => {         new _ GrowString[old, heap, increaseBy];         RESUME[new]}];    --convert service name to name record    NSName.MakeNameFields[z: heap, destination: @serviceRec.name];    NSName.NameFieldsFromString[      z: heap, s: serviceName,      destination: @serviceRec.name,       clientDefaults: IF firstColonPosition < rightServicePosition         THEN @defaultName ELSE @nullName         !  NSName.Error => ERROR Error [invalidSyntax];	    NSName.NameTooSmall => ERROR Error [invalidSyntax]];     --enter into service cache    destination.service _ NSFilingGlobal.CacheService[@serviceRec]};        --copy remaining string into pathname portion of vpn    substr.offset _ rightServicePosition + 1;    IF substr.offset > NSString.LogicalLength[s]       THEN destination.pathname _ nullString      ELSE {    substr.length _ NSString.LogicalLength[s] - NSString.LogicalLength[serviceName] - 2;    destination.pathname _ NSString.MakeString[z, substr.length];    {ENABLE UNWIND => NSString.FreeString[z, destination.pathname];    destination.pathname _ NSString.AppendSubString[to: destination.pathname, from: @substr !       NSString.StringBoundsFault => {--in case logical length is less than byte length        new _ GrowString[old, z, increaseBy];        RESUME[new]}]}};    END; --BEGIN ENABLE  NSString.FreeString[heap, serviceName];  NSName.FreeNameFields[heap, @serviceRec.name];  END; --VPNFieldsFromString  VPNFromString: PUBLIC PROCEDURE [    z: UNCOUNTED ZONE, s: String] RETURNS [vpn: VPN] =   -- Like VPNFieldsFromString except the VPNRecord is also allocated from the zone.  The client is responsible for freeing the allocated memory using FreeVPN (Again, the client should NOT try to free the service portion of vpn).    BEGIN    vpn _ z.NEW[VPNRecord];    {ENABLE UNWIND => z.FREE[@vpn];    VPNFieldsFromString[z, s, vpn];    RETURN [vpn]};  END; --VPNFromString  CopyVPNToString: PUBLIC PROCEDURE [    z: UNCOUNTED ZONE, vpn: VPN, extra: CARDINAL _ 0]  RETURNS [s: String] =     -- Copies the fields of vpn to the string s which it allocates from z. The separator defined in NSName (:) is used between fields of the service name. extra specifies the number of characters to be allocated beyond those needed to convert vpn to a string. If vpn is NIL THEN nullString is returned.     BEGIN    stringLength: CARDINAL;    IF vpn = NIL THEN RETURN [nullString];    stringLength _ vpn.pathname.length + extra;    IF vpn.service # NIL THEN {     stringLength _ stringLength + vpn.service.name.org.length + 2*separatorOverhead;     IF vpn.service.name.domain.length > 0 THEN stringLength _ stringLength + vpn.service.name.domain.length + separatorOverhead;     IF vpn.service.name.local.length > 0 THEN stringLength _ stringLength + vpn.service.name.local.length + separatorOverhead};    s _ NSString.MakeString[z, stringLength];    {ENABLE UNWIND => NSString.FreeString[z, s];    s _ AppendVPNToString[s, vpn, TRUE !       NSString.StringBoundsFault => {         new _ GrowString[old, z, increaseBy];         RESUME[new]}];     RETURN[s]};   END; --CopyVPNToString       AppendVPNToString: PUBLIC PROCEDURE [    s: String, vpn: VPN, resetLengthFirst: BOOLEAN _ FALSE]   RETURNS [newS: String] =  -- Like CopyVPNToString, except that it appends the fields of vpn to s which has been preallocated.  If resetLengthFirst is TRUE, then s.length is set to zero before the appends take place.  This operation may signal NSString.StringBoundsFault.    BEGIN  IF vpn = NIL THEN RETURN [nullString];  IF resetLengthFirst THEN s.length _ 0;    IF vpn.service # NIL THEN {    s _ NSString.AppendCharacter[to: s, from: leftServiceSeparator];    s _ NSName.AppendNameToString[s, @vpn.service.name, FALSE];    s _ NSString.AppendCharacter[to: s, from: rightServiceSeparator]};      s _ NSString.AppendString[to: s, from: vpn.pathname];  RETURN[s];  END; --AppendVPNToString   --ALLOCATING AND DEALLOCATING  CopyVPNFields: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, source, destination: VPN] =  -- Copies source to destination, allocating the fields of destination from the zone. The client is responsible for freeing the allocated memory; ClearVPN can be used for this purpose.    BEGIN  destination.service _ source.service; --services are managed by the service cache, so just copy the pointer  destination.pathname _ NSString.CopyString[z, source.pathname];  END; --CopyVPNFields  CopyVPN: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, vpn: VPN] RETURNS [VPN] =  -- Like CopyVPNFields except the copied VPNRecord is also allocated from the zone.  FreeVPN can be used to deallocate the VPNRecord and its fields.    BEGIN  destination: VPN _ z.NEW[VPNRecord];  CopyVPNFields[z, vpn, destination ! UNWIND => z.FREE[@destination]];  RETURN[destination]  END; --CopyVPN  ClearVPN, FreeVPNFields: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, vpn: VPN] =  -- Frees the pathname portion of vpn and sets VPNRecord of vpn to [nullString, NSFile.nullService]    BEGIN    NSString.FreeString[z, vpn.pathname];    vpn.pathname _ nullString;    vpn.service _ NSFile.nullService;  END; --ClearVPN, FreeVPNFields  FreeVPN: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, vpn: VPN] =  -- Like ClearVPN and FreeVPNFields except the VPNRecord is also freed.    BEGIN    ClearVPN[z, vpn];    z.FREE[@vpn];  END; --FreeVPN    --SETTING THE DEFAULT DOMAIN AND ORGANIZATION    SetDefaultDomainAndOrg: PUBLIC PROCEDURE [domain, org: String] =  --sets the default domain and organization fields to fill in when they are missing in a the service name portion of a fully-qualified pathname string.    BEGIN    NSString.FreeString[heap, defaultDomain];    defaultDomain _ NSString.CopyString[heap, domain];    NSString.FreeString[heap, defaultOrg];    defaultOrg _ NSString.CopyString[heap, org];    defaultName.domain _ defaultDomain;    defaultName.org _ defaultOrg;  END; --SetDefaultDomainAndOrg    --   --   --   --   --   --   --   --  -- PRIVATE OPERATIONS  --   --   --   --   --   --   --   --    GrowString: PROCEDURE [s: String, z: UNCOUNTED ZONE, increaseBy: CARDINAL] RETURNS [newS: String] =    BEGIN    newS _ NSString.MakeString[z, s.maxlength + increaseBy];    newS.length _ 0;    newS _ NSString.AppendString[to: newS, from: s];    NSString.FreeString[z, s];  END; --GrowString    END.LOG (Date - Person - Action)27-Oct-83 14:02:02 - Gleason - Creation. 5-Dec-83 10:40:38 - Gleason - Replaced references to ServiceCache with reference to NSFilingGlobal.January 5, 1984 - Hanzel - Update for 8.0d changes (separator constant definitions).18-Jan-84  9:28:02 - Gleason - Take into account character set change overhead incurred by insertion of separator characters when allocating space in CopyVPNToString.16-May-84  8:49:49 - Gleason - In proc VPNFieldsFromString, if service name contains no colon, then it is local, so fill in NSFile.localSystemElement as the systemElement portion of the service record. (Fixes AR # 7755).17-May-84 11:41:16 - Gleason - Take out above mentioned fix, since it doesn't really solve the problem (and besides, I did it wrong!)
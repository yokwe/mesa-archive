-- NSFilingControlAImpl.mesa-- Overview:  Implementation of commonly-used procedures defined in NSFilingGlobal and NSFile.<< To do:  o enhance CreateSpaceCache to permit client to create a set of pre-allocated spaces (which are never freed).>>-- Last revised by Mita: 17-Mar-87 13:11:38DIRECTORY  Courier USING [DeserializeParameters, Description, Error, SerializeParameters],  Environment USING [Block, Byte, bytesPerWord],  File USING [nullID],  Heap USING [FreeNode, MakeNode, systemZone],  Inline USING [BytePair, DBITOR, LongCOPY],  MemoryStream USING [Create],  Mopcodes USING [zEXCH],  NSFile USING [    AccessEntry, AccessList, allExtendedSelectionsRepresentation,    allInterpretedSelections, Attribute, AttributeList,    AttributesRecord, AttributeType, Attributes, ErrorRecord,    ExtendedAttributeList, ExtendedAttributeType, ExtendedSelections,    firstPositionRepresentation, InterpretedSelections,    lastPositionRepresentation, noExtendedSelections,    noInterpretedSelections, Position, Reference, Selections, Service,    ServiceRecord, String, Words],  NSFilingDebug USING [debugEnabled],  NSFilingGlobal,  NSName USING [DescribeNameRecord, FreeNameFields, SizeOfSerializedData],  NSString USING [CopyString, FreeString, nullString, WellFormed],  Space USING [    Interval, Kill, Map, PageFromLongPointer, PageCount, PageNumber,    Unmap, wordsPerPage],  Stream USING [Delete, Handle],  System USING [IsUtilityPilot];NSFilingControlAImpl: MONITOR LOCKS cache USING cache: SpaceCache  IMPORTS Courier, Heap, Inline, MemoryStream, NSFilingGlobal, NSName, NSString, Space, Stream, System   EXPORTS NSFile, NSFilingGlobal =  BEGIN    -- Private constants  systemZone: UNCOUNTED ZONE = Heap.systemZone;  Bug: SIGNAL [bugType: BugType] = CODE;  BugType: TYPE = {duplicateNotFound};  --   --   --   --   --   --   --   --  -- EXPORTED SIGNALS AND CONSTANTS (NSFile)  --   --   --   --   --   --   --   --  Error: PUBLIC ERROR [error: NSFile.ErrorRecord] = CODE;    --Important: To avoid forward reference problems, the next two declarations MUST be in this order!    allExtendedSelections: PUBLIC NSFile.ExtendedSelections =    DESCRIPTOR[allExtended];  allSelections: PUBLIC NSFile.Selections = [    NSFile.allInterpretedSelections, allExtendedSelections];    noSelections: PUBLIC NSFile.Selections _ [];  firstPosition: PUBLIC NSFile.Position = DESCRIPTOR[first];  lastPosition: PUBLIC NSFile.Position = DESCRIPTOR[last];  allExtended: ARRAY [0..0] OF NSFile.ExtendedAttributeType _    NSFile.allExtendedSelectionsRepresentation;  first: ARRAY [0..0] OF UNSPECIFIED _ NSFile.firstPositionRepresentation;  last: ARRAY [0..0] OF UNSPECIFIED _ NSFile.lastPositionRepresentation;  --   --   --   --   --   --   --   --  -- PUBLIC OPERATIONS (NSFile)  --   --   --   --   --   --   --   --  CopyWords: PUBLIC PROC [words: NSFile.Words] RETURNS [NSFile.Words] =    BEGIN    length: CARDINAL;    copyData: LONG POINTER TO ARRAY OF UNSPECIFIED;    length _ LENGTH[words];    IF length = 0 THEN RETURN[DESCRIPTOR[NIL, 0]]    ELSE      BEGIN      copyData _ Heap.MakeNode[systemZone, length];      Inline.LongCOPY[from: BASE[words], to: copyData, nwords: length];      RETURN[DESCRIPTOR[copyData, length]];      END;    END;  -- of CopyWords  --   --   --   --   --   --   --   --  FreeWords: PUBLIC PROC [words: NSFile.Words] =    BEGIN    length: CARDINAL _ LENGTH[words];    IF length = 0 THEN RETURN ELSE Heap.FreeNode[systemZone, BASE[words]];    END;  -- of FreeWords  --   --   --   --   --   --   --   --  CopyAccessList: PUBLIC PROC [accessList: NSFile.AccessList]    RETURNS [accessListCopy: NSFile.AccessList] =    BEGIN    IF accessList.entries = NIL THEN RETURN[accessList];    accessListCopy.defaulted _ accessList.defaulted;    accessListCopy.entries _ DESCRIPTOR[      --base:--      Heap.MakeNode[        systemZone, SIZE[NSFile.AccessEntry, LENGTH[accessList.entries]]],        --length:-- LENGTH[accessList.entries]];    FOR i: CARDINAL IN [0..LENGTH[accessList.entries]) DO      entry: LONG POINTER TO NSFile.AccessEntry = @accessList.entries[i];      accessListCopy.entries[i] _ [        key: NSString.CopyString[systemZone, entry.key], type: entry.type,        access: entry.access];      ENDLOOP;    END;  -- of CopyAccessList  --   --   --   --   --   --   --   --  FreeAccessList: PUBLIC PROC [accessList: NSFile.AccessList] =    BEGIN    IF accessList.entries = NIL THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[accessList.entries]) DO      NSString.FreeString[systemZone, accessList.entries[i].key]; ENDLOOP;    Heap.FreeNode[systemZone, BASE[accessList.entries]];    END;  -- of FreeAccessList  --   --   --   --   --   --   --   --  CopyAttributes: PUBLIC PROC [attributes: NSFile.Attributes]    RETURNS [attributesCopy: NSFile.Attributes] =    BEGIN    IF attributes = NIL THEN RETURN[NIL];    attributesCopy _ systemZone.NEW[NSFile.AttributesRecord _ attributes^];    attributesCopy.createdBy _ NSString.CopyString[      systemZone, attributes.createdBy];    attributesCopy.filedBy _ NSString.CopyString[systemZone, attributes.filedBy];    attributesCopy.modifiedBy _ NSString.CopyString[      systemZone, attributes.modifiedBy];    attributesCopy.readBy _ NSString.CopyString[systemZone, attributes.readBy];    attributesCopy.name _ NSString.CopyString[systemZone, attributes.name];    attributesCopy.pathname _ NSString.CopyString[      systemZone, attributes.pathname];    attributesCopy.position _ CopyWords[attributes.position];    attributesCopy.accessList _ CopyAccessList[attributes.accessList];    attributesCopy.defaultAccessList _ CopyAccessList[      attributes.defaultAccessList];    attributesCopy.extended _ CopyExtendedAttributes[attributes.extended];    END;  -- of CopyAttributes  --   --   --   --   --   --   --   --  ClearAttributes: PUBLIC PROC [attributes: NSFile.Attributes] =    BEGIN    IF attributes = NIL THEN RETURN;    ReleaseAttributes[attributes];    NullifyAttributes[attributes];    END;  -- of ClearAttributes  --   --   --   --   --   --   --   --  FreeAttributes: PUBLIC PROC [attributes: NSFile.Attributes] =    BEGIN    IF attributes = NIL THEN RETURN;    ReleaseAttributes[attributes];    systemZone.FREE[@attributes];    END;  -- of FreeAttributes  --   --   --   --   --   --   --   --  ClearAttributeList: PUBLIC PROC [attributeList: NSFile.AttributeList] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH [attributeList]) DO      WITH z: attributeList[i] SELECT FROM        extended => FreeWords [z.value];	ENDCASE;      ENDLOOP;    END;  -- of ClearAttributeList      --   --   --   --   --   --   --   --  MergeAttributeLists: PUBLIC PROCEDURE [listA,listB: NSFile.AttributeList, suppressDuplicates: BOOLEAN] RETURNS [NSFile.AttributeList] =    BEGIN    indexA, indexB, indexMerged: NSFilingGlobal.AttributeListIndexRecord;    AttributeListIndexFromAttributeList [listA, @indexA];    AttributeListIndexFromAttributeList [listB, @indexB];    MergeAttributeListIndexes [@indexA, @indexB, @indexMerged];    IF (NOT suppressDuplicates)      AND LENGTH [indexMerged.list] # LENGTH [listA] + LENGTH [listB]      THEN ReportDuplicates [listA, listB ! UNWIND => Heap.FreeNode [systemZone, BASE [indexMerged.list]]];    RETURN [indexMerged.list];    END;  -- of MergeAttributeLists  --   --   --   --   --   --   --   --  FreeAttributeList: PUBLIC PROC [list: NSFile.AttributeList] =     {Heap.FreeNode [systemZone, BASE [list]]};      --   --   --   --   --   --   --   --  CopyExtendedAttributes: PUBLIC PROC [    extendedAttributes: NSFile.ExtendedAttributeList]    RETURNS [NSFile.ExtendedAttributeList] =    BEGIN    copy: NSFile.ExtendedAttributeList;    length: CARDINAL = LENGTH[extendedAttributes];    IF extendedAttributes = NIL THEN RETURN[extendedAttributes];    copy _ DESCRIPTOR[      -- base: --      Heap.MakeNode[systemZone, SIZE[extended NSFile.Attribute, length]],        -- length: -- length];    FOR i: CARDINAL IN [0..length) DO      copy[i] _ NSFile.Attribute[extended [        type: extendedAttributes[i].type,        value: CopyWords[extendedAttributes[i].value]]];      ENDLOOP;    RETURN[copy];    END;  -- of CopyExtendedAttributes  --   --   --   --   --   --   --   --  FreeExtendedAttributes: PUBLIC PROC [    extendedAttributes: NSFile.ExtendedAttributeList] =    BEGIN    IF extendedAttributes = NIL THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[extendedAttributes]) DO      FreeWords[extendedAttributes[i].value]; ENDLOOP;    Heap.FreeNode[systemZone, BASE[extendedAttributes]];    END;  -- of FreeExtendedAttributes  --   --   --   --   --   --   --   --  -- ATTRIBUTE ENCODING/DECODING (NSFile)  --   --   --   --   --   --   --   --    CBoolean: TYPE = MACHINE DEPENDENT RECORD [    zero(0: 0..14): [0..77777B] _ 0, value (0: 15..15): BOOLEAN];  CString: TYPE = RECORD [PACKED SEQUENCE length: CARDINAL OF Byte];  Byte: TYPE = Environment.Byte;    SwapWords: PROC [LONG UNSPECIFIED] RETURNS [LONG UNSPECIFIED] = MACHINE CODE {Mopcodes.zEXCH};    EncodeBoolean: PUBLIC PROCEDURE [b: BOOLEAN] RETURNS [NSFile.Words] =    BEGIN    cb: LONG POINTER TO CBoolean = systemZone.NEW [CBoolean _ [value: b]];    RETURN [DESCRIPTOR [cb, 1]];    END;  -- of EncodeBoolean    EncodeCardinal, EncodeInteger: PUBLIC PROCEDURE [u: UNSPECIFIED]    RETURNS [NSFile.Words] =    {RETURN [DESCRIPTOR [systemZone.NEW [UNSPECIFIED _ u], 1]]};    EncodeLongCardinal, EncodeLongInteger: PUBLIC PROCEDURE [lu: LONG UNSPECIFIED]    RETURNS [NSFile.Words] =    {lu _ SwapWords [lu];    RETURN [DESCRIPTOR [systemZone.NEW [LONG UNSPECIFIED _ lu], 2]]};    EncodeReference: PUBLIC PROCEDURE [r: NSFile.Reference]    RETURNS [w: NSFile.Words] =    BEGIN    WordSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];      length: CARDINAL = NSName.SizeOfSerializedData[[@r, DescribeReference]];    sH: Stream.Handle;    buffer: Environment.Block _ [LOOPHOLE [      systemZone.NEW [WordSequence [length]]], 0,      length*Environment.bytesPerWord];    sH _ MemoryStream.Create[buffer];    Courier.SerializeParameters [[@r, DescribeReference], sH];    Stream.Delete [sH];    RETURN[DESCRIPTOR[buffer.blockPointer, length]];    END;  -- of EncodeReference    EncodeString: PUBLIC PROCEDURE [s: NSFile.String] RETURNS [words: NSFile.Words] =    BEGIN    cs: LONG POINTER TO CString = systemZone.NEW [CString [s.length]];    Inline.LongCOPY [from: s.bytes, to: BASE [DESCRIPTOR [cs^]], nwords: SIZE [Byte, s.length]];    words _ DESCRIPTOR [cs, SIZE [CString [s.length]]];    IF s.length MOD 2 = 1 THEN      LOOPHOLE [words [LENGTH [words] - 1], Inline.BytePair].low _ 0;    END;  -- of EncodeString          DecodeBoolean: PUBLIC PROCEDURE [words: NSFile.Words] RETURNS [BOOLEAN] =     BEGIN    IF LENGTH [words] # 1 THEN ERROR Courier.Error [parameterInconsistency];    RETURN [LOOPHOLE [words [0], CBoolean].value];    END;    DecodeCardinal, DecodeInteger: PUBLIC PROCEDURE [words: NSFile.Words]    RETURNS [UNSPECIFIED] =     BEGIN    IF LENGTH [words] # 1 THEN ERROR Courier.Error [parameterInconsistency];    RETURN [words [0]];    END;    DecodeLongCardinal, DecodeLongInteger: PUBLIC PROCEDURE [words: NSFile.Words]    RETURNS [lu: LONG UNSPECIFIED] =     BEGIN    IF LENGTH [words] # 2 THEN ERROR Courier.Error [parameterInconsistency];    lu _ SwapWords [LOOPHOLE [BASE [words], LONG POINTER TO LONG UNSPECIFIED]^];    END;    DecodeReference: PUBLIC PROCEDURE [w: NSFile.Words]    RETURNS [r: NSFile.Reference] =    BEGIN    sH: Stream.Handle;      IF w = NIL THEN Courier.Error [parameterInconsistency];    sH _ MemoryStream.Create[      [LOOPHOLE[BASE[w]], 0, LENGTH[w]*Environment.bytesPerWord]];    Courier.DeserializeParameters [      [@r, DescribeReference], sH, systemZone ! UNWIND => Stream.Delete[sH]];    Stream.Delete[sH];    IF r.service # NIL THEN {      temp: NSFile.Service _ r.service;      r.service _ NSFilingGlobal.CacheService[temp];      NSName.FreeNameFields[systemZone, @temp.name];      systemZone.FREE[@temp]};    END;  -- of DecodeReference    DecodeString: PUBLIC PROCEDURE [words: NSFile.Words] RETURNS [s: NSFile.String] =    BEGIN    cs: LONG POINTER TO CString = LOOPHOLE [BASE [words]];    IF LENGTH [words] = 0 OR LENGTH [words] # SIZE [CString [cs.length]] THEN ERROR Courier.Error [parameterInconsistency];    s _ [BASE [DESCRIPTOR [cs^]], cs.length, cs.length];    IF NOT NSString.WellFormed [s] THEN ERROR Courier.Error [parameterInconsistency];    END;      --   --   --   --   --   --   --   --  -- SPACE CACHING (NSFilingGlobal)  --   --   --   --   --   --   --   --  SpaceCache: PUBLIC TYPE = LONG POINTER TO SpaceCacheRecord;  SpaceCacheRecord: TYPE = MONITORED RECORD [    fixedPageLow, fixedPageHigh: Space.PageNumber _ 0,    freelist: CARDINAL _ 0,    ctFreeList: CARDINAL,     inuse: CARDINAL _ empty,    spaceSize: Space.PageCount,    seq: SEQUENCE countKeep: CARDINAL OF Node _ NULL];  Node: TYPE = RECORD [next: CARDINAL, spacePointer: LONG POINTER];  empty: CARDINAL = LAST[CARDINAL];  singlePageCache: PUBLIC SpaceCache _ CreateSpaceCache[    spaceSize: 1, ctSpaces: 100];  --   --   --   --   --   --   --   --  CreateSpaceCache: PUBLIC PROC [spaceSize: Space.PageCount, ctSpaces: CARDINAL]    RETURNS [cache: SpaceCache] =    BEGIN    cache _ systemZone.NEW[      SpaceCacheRecord [ctSpaces] _ [ctFreeList: ctSpaces, spaceSize: spaceSize]];    FOR i: CARDINAL IN [0..ctSpaces - 1) DO cache[i].next _ i + 1; ENDLOOP;    cache[ctSpaces - 1].next _ empty;    END;  -- of CreateSpaceCache  --   --   --   --   --   --   --   --  GetSpace: PUBLIC ENTRY PROC [cache: SpaceCache] RETURNS [space: Space.Interval] =    BEGIN    ENABLE UNWIND => NULL;    this: CARDINAL = cache.inuse;    IF this = empty THEN      RETURN[Space.Map[window: [file: [fileID: File.nullID, volumeID: TRASH],         base: TRASH, count: cache.spaceSize], life: dead]]    ELSE      BEGIN      thisPtr: LONG POINTER TO Node = @cache[this];      space _ [pointer: thisPtr.spacePointer, count: cache.spaceSize];      cache.inuse _ thisPtr.next;      thisPtr.next _ cache.freelist;      cache.freelist _ this;      -- if allocating non-permanent space,      -- permit a non-perm space to be cached later      IF ~IsPermanentSpace[cache, space.pointer] THEN        cache.ctFreeList _ cache.ctFreeList + 1;      --no need to Kill, since space was Killed when ReleaseSpace put it in cache      END    END;  -- of GetSpace  --   --   --   --   --   --   --   --  ReleaseSpace: PUBLIC ENTRY PROC [cache: SpaceCache, space: Space.Interval] =    BEGIN    ENABLE UNWIND => NULL;    fixedSpace: BOOLEAN = IsPermanentSpace[cache, space.pointer];    this: CARDINAL = cache.freelist;    IF this = empty OR (~fixedSpace AND cache.ctFreeList = 0) THEN      --no need to Kill, since Pilot doesn't force out data space      space.pointer _ Space.Unmap[space.pointer]  -- unmap & delete. space _ NIL.    ELSE      BEGIN      thisPtr: LONG POINTER TO Node = @cache[this];      cache.freelist _ thisPtr.next;      thisPtr^ _ [next: cache.inuse, spacePointer: space.pointer];      cache.inuse _ this;      Space.Kill[space];  --don't write out to disk when space is swapped out      IF ~fixedSpace THEN {        IF cache.ctFreeList = 0 THEN ERROR;	cache.ctFreeList _ cache.ctFreeList - 1};      END;    END;  -- of ReleaseSpace    IsPermanentSpace: PROC [cache: SpaceCache, space: LONG POINTER]    RETURNS [BOOLEAN] = INLINE {    page: Space.PageNumber = Space.PageFromLongPointer[space];    RETURN[IF page >= cache.fixedPageLow AND page < cache.fixedPageHigh THEN TRUE      ELSE FALSE]};  --   --   --   --   --   --   --   --  -- NSFilingGlobal OPERATIONS  --   --   --   --   --   --   --   --  AttributeListIndexFromAttributeList: PUBLIC PROCEDURE [    list: NSFile.AttributeList, index: NSFilingGlobal.AttributeListIndex] =    -- The supplied "index" is used to record various characteristics describing "list".  Each entry of list is required to have a unique attribute type, otherwise NSFile.AttributeValueError[duplicated, "attributeType"] is raised.    BEGIN    ctAttributes: CARDINAL _ LENGTH[list];    extTypes: NSFile.ExtendedSelections _ DESCRIPTOR [Heap.MakeNode [systemZone, SIZE [NSFile.ExtendedAttributeType, ctAttributes]], ctAttributes];      index^ _ [list: list, selections: [], index: ALL[NSFilingGlobal.notInList]];        BEGIN ENABLE UNWIND => Heap.FreeNode [systemZone, BASE [extTypes]];    ctExtended: CARDINAL _ 0;    FOR i: CARDINAL IN [0..ctAttributes) DO      WITH a: list[i] SELECT FROM        extended => {	  FOR j: CARDINAL IN [0..ctExtended) DO	    IF a.type = extTypes[j] THEN	      Error[[attributeType[duplicated, extended, a.type]]];	    ENDLOOP;	  extTypes[ctExtended] _ a.type;	  ctExtended _ ctExtended + 1};	ENDCASE => {	  IF index.selections.interpreted[list[i].type] THEN	    Error[[attributeType[duplicated, list[i].type]]];	  index.selections.interpreted[list[i].type] _ TRUE;	  index.index[list[i].type] _ i};      ENDLOOP;    IF ctExtended > 0 THEN index.selections.interpreted[extended] _ TRUE;    END;        Heap.FreeNode [systemZone, BASE [extTypes]];    END;  -- of AttributeListIndexFromAttributeList	  --   --   --   --   --   --   --   --  --  Physically copy "nwords" words from "from" to "to".  This routine works properly for overlapping or zero-length operands, unlike a blind use of Inline.LongCopy.  CopyData: PUBLIC PROCEDURE [from, to: LONG POINTER, nwords: CARDINAL] =    BEGIN    index: CARDINAL;    IF LOOPHOLE[to, LONG CARDINAL] < LOOPHOLE[from, LONG CARDINAL]  --backwards      OR to - from >= LONG[nwords]  --forwards but no overlap       THEN Inline.LongCOPY[from: from, nwords: nwords, to: to]    ELSE      FOR index DECREASING IN [0..nwords) DO        (to + index)^ _ (from + index)^; ENDLOOP;    END;  -- of CopyData      --   --   --   --   --   --   --   --  MergeAttributeListIndexes: PUBLIC PROCEDURE [indexA: NSFilingGlobal.AttributeListIndex, indexB: NSFilingGlobal.AttributeListIndex, indexMerged: NSFilingGlobal.AttributeListIndex] =    BEGIN    ExtendedSubscriptList: TYPE = LONG POINTER TO ARRAY OF CARDINAL;      --each element of the ExtendedSubscriptList is a subscript of an AttributeList element whose type is "extended"    extA: ExtendedSubscriptList _ IF indexA.selections.interpreted [extended] THEN Heap.MakeNode [systemZone, SIZE[CARDINAL, LENGTH [indexA.list]]] ELSE NIL;    extB: ExtendedSubscriptList _ IF indexB.selections.interpreted [extended] THEN Heap.MakeNode [systemZone, SIZE[CARDINAL, LENGTH [indexB.list]]] ELSE NIL;    lengthResult, ctExtA, ctExtB: CARDINAL _ 0;        FOR i: CARDINAL IN [0..LENGTH [indexA.list]) DO      IF NOT indexA.selections.interpreted [indexA.list [i].type] THEN LOOP;      WITH a: indexA.list [i] SELECT FROM        extended => 	  {extA [ctExtA] _ i;	  ctExtA _ ctExtA + 1};	ENDCASE;      lengthResult _ lengthResult + 1;      ENDLOOP;          FOR i: CARDINAL IN [0..LENGTH [indexB.list]) DO      IF NOT indexB.selections.interpreted [indexB.list [i].type] THEN LOOP;      WITH a: indexB.list [i] SELECT FROM        extended => 	  FOR j: CARDINAL IN [0..ctExtA) DO	    IF LOOPHOLE [@indexA.list [extA [j]], LONG POINTER TO extended NSFile.Attribute].type = a.type THEN EXIT;	     REPEAT FINISHED =>	       {extB [ctExtB] _ i;	       ctExtB _ ctExtB + 1;	       lengthResult _ lengthResult + 1};	     ENDLOOP;	ENDCASE =>	  IF NOT indexA.selections.interpreted [a.type]	    THEN lengthResult _ lengthResult + 1;      ENDLOOP;          indexMerged^ _ [      list: DESCRIPTOR [Heap.MakeNode [systemZone, SIZE [NSFile.Attribute, lengthResult]], lengthResult],      selections: [interpreted: OrSelections [indexA.selections.interpreted, indexB.selections.interpreted]],      index: ALL [NSFilingGlobal.notInList]];        BEGIN    j: CARDINAL _ 0;    AddToMergedList: PROC [attr: LONG POINTER TO NSFile.Attribute] =      {indexMerged.list [j] _  attr^;      indexMerged.index [attr.type] _ j;      j _ j + 1};          FOR i: CARDINAL IN [0..LENGTH [indexA.list]) DO      IF indexA.selections.interpreted [indexA.list[i].type]        THEN AddToMergedList [@indexA.list[i]];      ENDLOOP;        FOR i: CARDINAL IN [0..LENGTH [indexB.list]) DO      attributeType: NSFile.AttributeType = indexB.list[i].type;      IF attributeType = extended THEN LOOP;  --get these later      IF indexA.selections.interpreted [attributeType] THEN LOOP;  --duplicates      IF indexB.selections.interpreted [attributeType]        THEN AddToMergedList [@indexB.list [i]];      ENDLOOP;          FOR i: CARDINAL IN [0..ctExtB) DO      AddToMergedList [@indexB.list [extB [i]]];      ENDLOOP;          END;    IF extA # NIL THEN Heap.FreeNode [systemZone, extA];    IF extB # NIL THEN Heap.FreeNode [systemZone, extB];    END;  -- of MergeAttributeListsInternal      --   --   --   --   --   --   --   --  NullifyAttributes: PUBLIC PROC [attributes: NSFile.Attributes] =    BEGIN    attributes.createdBy _ attributes.filedBy _ attributes.modifiedBy _      attributes.readBy _ attributes.name _ attributes.pathname _      NSString.nullString;    attributes.position _ NIL;    attributes.accessList _ attributes.defaultAccessList _ [entries: NIL, defaulted: FALSE];    attributes.extended _ NIL;    END;  -- of NullifyAttributes  --   --   --   --   --   --   --   --  -- PRIVATE OPERATIONS  --   --   --   --   --   --   --   --  DescribeReference: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFile.Reference _      noteSize[SIZE[NSFile.Reference]];    noteDisjointData[@parameters.service, DescribeServiceRecord];    END;  -- of DescribeReference    DescribeServiceRecord: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFile.ServiceRecord _      noteSize[SIZE[NSFile.ServiceRecord]];    noteParameters[@parameters.name, NSName.DescribeNameRecord];    END;  -- of DescribeServiceRecord    OrSelections: PROC [NSFile.InterpretedSelections, NSFile.InterpretedSelections] RETURNS [NSFile.InterpretedSelections] = LOOPHOLE [Inline.DBITOR];  ReleaseAttributes: PROCEDURE [attributes: NSFile.Attributes] =    -- Release storage allocated to attributes as obtained from GetAttributes or List. Touched entries are dangling references upon return.    BEGIN OPEN attributes;    NSString.FreeString[systemZone, createdBy];    NSString.FreeString[systemZone, filedBy];    NSString.FreeString[systemZone, modifiedBy];    NSString.FreeString[systemZone, readBy];    NSString.FreeString[systemZone, name];    NSString.FreeString[systemZone, pathname];    FreeWords[position];    FreeAccessList[accessList];    FreeAccessList[defaultAccessList];    FreeExtendedAttributes[extended];    END;  -- of ReleaseAttributes      --Used for MergeAttributeLists's error cases only  ReportDuplicates: PROC [listA, listB: NSFile.AttributeList] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH [listA]) DO      FOR j: CARDINAL IN [0..LENGTH [listB]) DO        IF listA [i].type = listB [i].type THEN WITH a: listA [i] SELECT FROM	  extended => IF a.type = LOOPHOLE [@listB [i], LONG POINTER TO extended NSFile.Attribute].type THEN ERROR Error [[attributeType [duplicated, extended, a.type]]];	  ENDCASE => ERROR Error [[attributeType [duplicated, a.type]]]; 	ENDLOOP;      ENDLOOP;    IF NSFilingDebug.debugEnabled THEN SIGNAL Bug [duplicateNotFound];    END;  -- of ReportDuplicates  -- MAINLINE    -- Pre-allocate spaces to cluster them in VM  BEGIN  ctInitialSpaces: CARDINAL ¬ IF System.IsUtilityPilot[] THEN 2 ELSE 50;  initialSpace: Space.Interval _ Space.Map[    window: [file: [fileID: File.nullID, volumeID: TRASH],      base: TRASH, count: ctInitialSpaces],    life: dead, swapUnits: [uniform[1]]];  singlePageCache.fixedPageLow _ Space.PageFromLongPointer[initialSpace.pointer];  singlePageCache.fixedPageHigh _    singlePageCache.fixedPageLow + ctInitialSpaces;  singlePageCache.ctFreeList _ 100 - ctInitialSpaces;  FOR i: CARDINAL IN [0..ctInitialSpaces) DO    ReleaseSpace[singlePageCache,      [pointer: initialSpace.pointer + i * Space.wordsPerPage, count: 1]];    ENDLOOP;  END;	  END.  -- of NSFilingControlImplLOG [Time - Person - Action]March 25, 1981  6:29 PM - W. E. Fisher - Created.- - - - File Service 8.0 - - - -10-Aug-83 13:51:05 - Buelow - convert to Klamath Space 3-Nov-83  7:36:38 - Buelow - Changed to NSFilingControlAImpl.December 6, 1983 - Hanzel - Implement Encode/DecodeReference.April 26, 1984 - Hanzel - Allocate VM for single page cache in single block to reduce number of spaces created.May 25, 1984 - Hanzel - Enhance cache mechanism so that spaces created at beginning of world (contiguously) never get freed.  Fixes AR 7788 for 8.0m.17-Mar-87 13:11:50 - Mita - For UtilityPilot initilize ctInitialSpaces 2 instead of 50.(Ask Installer(Dave) about the details)
-- File: NSFileCourierUtilityAImpl.mesa - last edit:-- Hanzel.ES            4-Mar-87 11:22:04-- Copyright (C) 1981, 1982, 1983, 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.-- Overview: Partial implementation of NSFileCourier: utility operations<<  To do:>>DIRECTORY  Courier USING [    Create, Delete, Description, DeserializeParameters, Error, Handle, Notes,    SerializeParameters],  Environment USING [Block, Byte, bytesPerPage, bytesPerWord],  Heap USING [FreeNode, MakeNode, systemZone],  Inline USING [LongCOPY, LowHalf],  MemoryStream USING [Create],  Mopcodes USING [zEXCH],  NSAssignedTypes,  -- USING many  NSFile USING [    Access, AccessEntry, AccessEntryType, AccessList, AccessType,    allExtendedSelections, allExtendedSelectionsRepresentation, allSelections,    Attribute, AttributeList, Attributes, AttributesRecord, AttributeType,    Controls, ControlSelections, ControlType, defaultOrdering, defaultTimeout,    Error, ExtendedAttributeType, fullAccess, InterpretedSelections,    noExtendedSelections, noInterpretedSelections, noSelections, nullID,    nullSubtreeSizeLimit, Ordering, OrderingType, Selections, String,    SystemElement, Words],  NSFileCourier USING [    allSelectionsProtocol, AttributeListProc, AttributeSequenceHeader,    AttributeType, AttributeTypeList, classOfService, Control, ControlsList,    ControlTypeList, Ordering, programNumber --, versionNumber--],  NSName USING [    AppendNameToString, characterSetChangeOverhead,    FreeNameFields, hierarchicalLevels, maxDomainLength, maxLocalLength,    maxOrgLength, Name, NameFieldsFromString, NameRecord],  NSString USING [    FreeString, MakeString, nullString, String, StringFromMesaString],  Stream USING [Delete, EndOfStream, GetByte, GetPosition, Handle, PutWord];NSFileCourierUtilityAImpl: PROGRAM  IMPORTS    Courier, Heap, Inline, MemoryStream, NSFile, NSFileCourier, NSName, NSString,    Stream  EXPORTS NSFileCourier =  BEGIN OPEN NSFileCourier;  -- Exported variables  zone: PUBLIC UNCOUNTED ZONE _ Heap.systemZone;  -- CONSTANTS  bytesPerWord: CARDINAL = Environment.bytesPerWord;    defaultNamePart: NSFile.String = NSString.StringFromMesaString["Unknown"L];    fullAccessProtocol: CARDINAL = 65535;  -- taken from 10.0 NSFileCourier  ctStandardAttributeTypes: CARDINAL = 28;  -- The number of standard attribute types defined by NSAssignedTypes (neglecting 'service' type)  directoryAttributeSelections: NSFile.InterpretedSelections = [    childrenUniquelyNamed: TRUE, defaultAccessList: TRUE, numberOfChildren: TRUE,    ordering: TRUE, subtreeSizeLimit: TRUE];  ctDirectoryAttributes: CARDINAL = 5;  -- ordinality of directoryAttributeSelections  parentAttributeSelections: NSFile.InterpretedSelections = [    parentID: TRUE, position: TRUE];  ctParentAttributes: CARDINAL = 2;  -- ordinality of parentAttributeSelections    versionNumber: CARDINAL = 5;  -- for Filing 5 compatibility  -- would normally be equal to NSFileCourier.versionNumber  Bug: ERROR [type: BugType] = CODE;  BugType: TYPE = {parameterAttributeInconsistency};  -- Courier handle management  CreateCourierHandle: PUBLIC PROCEDURE [systemElement: NSFile.SystemElement]    RETURNS [courierHandle: Courier.Handle] = {    RETURN[      Courier.Create[        systemElement, programNumber, versionNumber, zone, classOfService]]};  DeleteCourierHandle: PUBLIC PROCEDURE [courierHandle: Courier.Handle] = {    Courier.Delete[courierHandle]};  -- Description of NSFile.Attribute  AttributeFormat: TYPE = {word, doubleWord, fiveWord, string, cHName, other};  format: ARRAY NSFile.AttributeType OF AttributeFormat = [    checksum: word, childrenUniquelyNamed: word, isDirectory: word,    isTemporary: word, version: word, numberOfChildren: word,    type: doubleWord, backedUpOn: doubleWord, createdOn: doubleWord,    filedOn: doubleWord, modifiedOn: doubleWord, readOn: doubleWord,    sizeInBytes: doubleWord, sizeInPages: doubleWord, subtreeSize: doubleWord,    subtreeSizeLimit: doubleWord,    fileID: fiveWord, parentID: fiveWord,    name: string, pathname: string,    service: other,    createdBy: cHName, filedBy: cHName, modifiedBy: cHName, readBy: cHName,    ordering: other, position: other, accessList: other, defaultAccessList: other,    extended: other];  nil: POINTER TO NSFile.AttributesRecord = NIL;  offset: ARRAY NSFile.AttributeType OF UNSPECIFIED = [    checksum: @nil.checksum, childrenUniquelyNamed: @nil.childrenUniquelyNamed,    createdBy: @nil.createdBy, createdOn: @nil.createdOn, fileID: @nil.fileID,    service: @nil.service, isDirectory: -1 --@nil.isDirectory-- , isTemporary: -1    --@nil.isTemporary-- , modifiedBy: @nil.modifiedBy,    modifiedOn: @nil.modifiedOn, name: @nil.name,    numberOfChildren: @nil.numberOfChildren, ordering: @nil.ordering,    parentID: @nil.parentID, position: @nil.position, readBy: @nil.readBy,    readOn: @nil.readOn, sizeInBytes: @nil.sizeInBytes, type: @nil.type,    version: @nil.version, accessList: @nil.accessList,    defaultAccessList: @nil.defaultAccessList, pathname: @nil.pathname,    backedUpOn: @nil.backedUpOn, filedBy: @nil.filedBy, filedOn: @nil.filedOn,    sizeInPages: @nil.sizeInPages, subtreeSize: @nil.subtreeSize,    subtreeSizeLimit: @nil.subtreeSizeLimit, extended: @nil.extended];  attributeLength: ARRAY NSFile.AttributeType OF CARDINAL = [    checksum: 1, childrenUniquelyNamed: 1, isDirectory: 1, isTemporary: 1,    version: 1, numberOfChildren: 1,    type: 2, backedUpOn: 2, createdOn: 2, filedOn: 2, modifiedOn: 2, readOn: 2,    sizeInBytes: 2, sizeInPages: 2, subtreeSize: 2, subtreeSizeLimit: 2,    fileID: 5, parentID: 5,    name: SIZE[NSString.String], pathname: SIZE[NSString.String],    service: 0,  -- should never be used    createdBy: SIZE[NSString.String], filedBy: SIZE[NSString.String],    modifiedBy: SIZE[NSString.String], readBy: SIZE[NSString.String],    ordering: SIZE[NSFile.Ordering], position: SIZE[NSFile.Words],    accessList: SIZE[NSFile.AccessList],    defaultAccessList: SIZE[NSFile.AccessList], extended: 0];  -- Useful inlines  SwapWords: PROC [LONG CARDINAL] RETURNS [LONG CARDINAL] = MACHINE CODE {    Mopcodes.zEXCH};  GetWord: PROC [notes: Courier.Notes] RETURNS [u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  PutWord: PROC [notes: Courier.Notes, u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  DescribeAttribute: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSFile.Attribute = notes.noteSize[      SIZE[NSFile.Attribute]];    notes.noteDeadSpace[site, SIZE[NSFile.Attribute]];    SELECT notes.operation FROM      fetch => PutAttribute[notes, site];      store => GetAttribute[notes, site];      free => FreeAttribute[site, notes.zone];      ENDCASE => ERROR;    END;  -- of DescribeAttribute  DescribeAttributes: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSFile.AttributeList = notes.noteSize[      SIZE[NSFile.AttributeList]];    -- no limit on the length of the list for now    notes.noteArrayDescriptor[      site: site, elementSize: SIZE[NSFile.Attribute],      upperBound: LAST[CARDINAL]];    FOR i: CARDINAL IN [0..LENGTH[site^]) DO      notes.noteParameters[@site[i], DescribeAttribute]; ENDLOOP;    END;  -- of DescribeAttributes  SerializeAttributes: PUBLIC PROCEDURE [    attributes: NSFile.AttributeList, sH: Stream.Handle] =    BEGIN    DescribeAttributesTemporary: Courier.Description =  -- to add zone as necessary      BEGIN      site: LONG POINTER TO NSFile.AttributeList = notes.noteSize[        SIZE[NSFile.AttributeList]];      notes.noteArrayDescriptor[        site: site, elementSize: SIZE[NSFile.Attribute],        upperBound: LAST[CARDINAL]];      FOR i: CARDINAL IN [0..LENGTH[site^]) DO        notes.noteParameters[@site[i], DescribeAttribute]; ENDLOOP;      END;    Courier.SerializeParameters[[@attributes, DescribeAttributesTemporary], sH];    -- Courier.SerializeParameters [[@attributes, DescribeAttributes], sH];    END;  -- of SerializeAttributes  DeserializeAttributes: PUBLIC PROC [sH: Stream.Handle, zone: UNCOUNTED ZONE]    RETURNS [attributes: NSFile.AttributeList] =    BEGIN    Courier.DeserializeParameters[[@attributes, DescribeAttributes], sH, zone];    END;  -- of DeserializeAttributes  FreeAttributes: PUBLIC PROC [    attributes: NSFile.AttributeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[attributes] = NIL THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[attributes]) DO      FreeAttribute[@attributes[i], zone]; ENDLOOP;    Heap.FreeNode[zone, BASE[attributes]];    END;  -- of FreeAttributes  FreeAttribute: PROC [    attr: LONG POINTER TO NSFile.Attribute, zone: UNCOUNTED ZONE] =    BEGIN    WITH a: attr SELECT FROM      createdBy, filedBy, modifiedBy, readBy =>        NSString.FreeString[zone, a.value];      name, pathname => NSString.FreeString[zone, a.value];      position => IF BASE[a.value] # NIL THEN Heap.FreeNode[zone, BASE[a.value]];      extended => IF BASE[a.value] # NIL THEN Heap.FreeNode[zone, BASE[a.value]];      accessList, defaultAccessList => {        FOR j: CARDINAL IN [0..LENGTH[a.value.entries]) DO          NSString.FreeString[zone, a.value.entries[j].key]; ENDLOOP;        IF BASE[a.value.entries] # NIL THEN          Heap.FreeNode[zone, BASE[a.value.entries]]};      ENDCASE;    END;  -- of FreeAttribute  GetAttribute: PROC [    notes: Courier.Notes, attr: LONG POINTER TO NSFile.Attribute] =    BEGIN    valuePtr: LONG POINTER = attr + 1;    attrType: LONG CARDINAL = GetDoubleWord[notes];    length: CARDINAL _ GetWord[notes];    SELECT attrType FROM      IN [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] =>        LOOPHOLE[attr, LONG POINTER TO NSFile.AttributeType]^ _ Inline.LowHalf[          attrType];      ENDCASE => {        attr^ _ [extended[type: attrType, value: GetWordSequence[notes, length]]];        RETURN};    IF length = 0 THEN {GetDefaultAttribute[attr]; RETURN};    SELECT format[attr.type] FROM      word => valuePtr^ _ GetWord[notes];      doubleWord => {        v: LONG POINTER TO LONG CARDINAL _ LOOPHOLE[valuePtr];        LOOPHOLE[valuePtr, LONG POINTER TO LONG CARDINAL]^ _ GetDoubleWord[notes];	-- convert to pages for Filing 5 compatibility	SELECT attr.type FROM	  sizeInPages, subtreeSize =>	    v^ _ (v^ + Environment.bytesPerPage - 1) / Environment.bytesPerPage;	  subtreeSizeLimit => 	    IF v^ # NSFile.nullSubtreeSizeLimit THEN  -- allow default	      v^ _ (v^ + Environment.bytesPerPage - 1)/Environment.bytesPerPage;	  ENDCASE => NULL};  -- no conversion necessary      fiveWord => GetBlock[notes, valuePtr, 5];      string =>        LOOPHOLE[valuePtr, LONG POINTER TO NSString.String]^ _ GetNSString[notes];      cHName =>        LOOPHOLE[valuePtr, LONG POINTER TO NSString.String]^ _ GetCHName[notes];      other =>        WITH a: attr SELECT FROM          ordering => GetOrdering[notes, @a.value];          position => {            realLength: CARDINAL _ GetWord[notes];            a.value _ GetWordSequence[notes, realLength]};          accessList => a.value _ GetAccessList[notes, FALSE];          defaultAccessList => a.value _ GetAccessList[notes, TRUE];	  service => NSFile.Error[[attributeType[illegal, service]]];          ENDCASE => ERROR Courier.Error[parameterInconsistency];      ENDCASE => ERROR Courier.Error[parameterInconsistency];    END;  -- of GetAttribute  GetDefaultAttribute: PROC [attr: LONG POINTER TO NSFile.Attribute] =    BEGIN    WITH attr SELECT FROM      childrenUniquelyNamed => value _ FALSE;      defaultAccessList => value _ [NIL, FALSE];      numberOfChildren => value _ 0;      ordering => value _ NSFile.defaultOrdering;      subtreeSizeLimit => value _ 0;      parentID => value _ NSFile.nullID;      position => value _ NIL;      ENDCASE;  --no default    END;  -- of GetDefaultAttribute  GetAccessList: PROC [notes: Courier.Notes, default: BOOLEAN]    RETURNS [acl: NSFile.AccessList] =    BEGIN    AccessEntrySequence: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF NSFile.AccessEntry];    length: CARDINAL;    DecodeAccessFromStream: PROC RETURNS [access: NSFile.Access] =      BEGIN      accessType: NSFile.AccessType;      accessTypeListLength: CARDINAL ¬ GetWord[notes];      FOR i: CARDINAL IN [0..accessTypeListLength) DO        SELECT accessType ¬ GetWord[notes] FROM          fullAccessProtocol => 	    IF accessTypeListLength = 1 THEN RETURN [NSFile.fullAccess]	    ELSE GOTO error;          ENDCASE => 	    IF access[accessType] THEN GOTO error -- duplicate            ELSE access[accessType] _ TRUE;        ENDLOOP;      EXITS        error => ERROR NSFile.Error[[attributeValue[illegal,	  IF default THEN defaultAccessList ELSE accessList]]];      END;  -- of DecodeAccessFromStream    length _ GetWord[notes];    IF length = 0 THEN acl.entries _ NIL    ELSE {      acl.entries _ DESCRIPTOR[        notes.zone.NEW[AccessEntrySequence [length]], length];      FOR i: CARDINAL IN [0..LENGTH[acl.entries]) DO        ptEntry: LONG POINTER TO NSFile.AccessEntry = @acl.entries[i];        ptEntry.key _ GetCHName[notes];        ptEntry.type _ other;  -- always for Filing 5 compatibility        ptEntry.access _ DecodeAccessFromStream [];        ENDLOOP};    acl.defaulted _ LOOPHOLE[GetWord[notes]];    END;  -- of GetAccessList  GetBlock: PROC [notes: Courier.Notes, site: LONG POINTER, size: CARDINAL] =    INLINE {notes.noteSpace[site, size]};  GetCHName: PROC [notes: Courier.Notes] RETURNS [string: NSString.String] =    BEGIN    name: NSName.NameRecord;    name.org _ GetNSString[notes];    name.domain _ GetNSString[notes];    name.local _ GetNSString[notes];    IF name = [NSString.nullString, NSString.nullString, NSString.nullString] THEN      RETURN[NSString.nullString];    string _ NSString.MakeString[      notes.zone,      name.org.length + name.domain.length + name.local.length +        (NSName.hierarchicalLevels - 1) *          (NSName.characterSetChangeOverhead + 2)];    string _ NSName.AppendNameToString[string, @name];    NSName.FreeNameFields[notes.zone, @name];    END;  -- of GetCHName  GetDoubleWord: PROC [notes: Courier.Notes] RETURNS [value: LONG CARDINAL] = {    notes.noteSpace[@value, 2]; value _ SwapWords[value]};  GetOrdering: PUBLIC PROC [    notes: Courier.Notes, site: LONG POINTER TO NSFile.Ordering] =    BEGIN OPEN o: LOOPHOLE[site, LONG POINTER TO extended NSFile.Ordering];    o.key _ GetDoubleWord[notes];    o.ascending _ GetWord[notes];    o.interpretation _ GetWord[notes];    LOOPHOLE[site, LONG POINTER TO NSFile.OrderingType]^ _      IF o.key IN [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit]      THEN key ELSE extended;    END;  -- of GetOrdering  GetNSString: PUBLIC PROC [notes: Courier.Notes]    RETURNS [string: NSString.String] =    BEGIN    ByteSequence: TYPE = RECORD [      PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];    string.length _ string.maxlength _ GetWord[notes];    IF string.length = 0 THEN RETURN[NSString.nullString];    string.bytes _ LOOPHOLE[notes.zone.NEW[ByteSequence [string.length]]];    GetBlock[notes, string.bytes, (string.length + 1) / 2];    END;  -- of GetNSString  GetWordSequence: PROC [notes: Courier.Notes, length: CARDINAL]    RETURNS [NSFile.Words] =    BEGIN    WordSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    base: LONG POINTER TO WordSequence;    IF length = 0 THEN RETURN[NIL];    base _ notes.zone.NEW[WordSequence [length]];    GetBlock[notes, base, length];    RETURN[DESCRIPTOR[base, length]];    END;  -- of GetWordSequence  PutAttribute: PROC [    notes: Courier.Notes, attr: LONG POINTER TO NSFile.Attribute] =    BEGIN    valuePtr: LONG POINTER = attr + 1;    WITH a: attr SELECT FROM      extended => {        PutDoubleWord[notes, a.type]; PutWordSequence[notes, a.value]; RETURN};      ENDCASE => {PutWord[notes, 0]; PutWord[notes, attr.type]};    SELECT format[attr.type] FROM      word => {PutWord[notes, 1]; PutWord[notes, valuePtr^]};      doubleWord => {	v: LONG POINTER TO LONG CARDINAL _ LOOPHOLE[valuePtr];        PutWord[notes, 2];	-- convert to bytes for Filing 5 compatibility	SELECT attr.type FROM	  sizeInPages, subtreeSize => v^ _ v^ * Environment.bytesPerPage;	  subtreeSizeLimit => IF v^ # NSFile.nullSubtreeSizeLimit THEN	    v^ _ v^ * Environment.bytesPerPage;	  ENDCASE => NULL;  -- no conversion necessary        PutDoubleWord[notes, LOOPHOLE[valuePtr, LONG POINTER TO LONG CARDINAL]^]};      fiveWord => {PutWord[notes, 5]; PutBlock[notes, valuePtr, 5]};      string => {        ptString: LONG POINTER TO NSString.String _ LOOPHOLE[valuePtr];        PutWord[notes, StringSize[ptString^]];        PutNSString[notes, ptString^]};      cHName =>        PutCHName[          notes, LOOPHOLE[valuePtr, LONG POINTER TO NSString.String]^, TRUE];      other =>        WITH a: attr SELECT FROM          ordering => {            PutWord[notes, SIZE[NSFileCourier.Ordering]];            PutOrdering[notes, @a.value]};          position => {  -- embedded sequence            PutWord[notes, LENGTH[a.value] + 1]; PutWordSequence[notes, a.value]};          accessList, defaultAccessList =>            PutAccessListWithLength[notes, a.value];	  service => NSFile.Error[[attributeType[illegal, service]]];          ENDCASE => ERROR Courier.Error[parameterInconsistency];      ENDCASE => ERROR Courier.Error[parameterInconsistency];    END;  -- of PutAttribute  PutAccessListWithLength: PROC [notes: Courier.Notes, acl: NSFile.AccessList] =    BEGIN    WordSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    --Use MemoryStream to buffer data, since we must send length before data    bufferMaxLength: CARDINAL =      LENGTH[acl.entries] *        (NSName.maxOrgLength + NSName.maxDomainLength + NSName.maxLocalLength + 4)        + 2;    -- Exclude 'type' field for Filing 5 compatibility    -- +4 per entry (was 5) = three string lengths [+ "type"] + "access"    -- +2 per list = length of list + "defaulted"    buffer: Environment.Block _ [      LOOPHOLE[notes.zone.NEW[WordSequence [bufferMaxLength]]], 0,      bufferMaxLength * bytesPerWord];    memStream: Stream.Handle = MemoryStream.Create[buffer];    Stream.PutWord[memStream, LENGTH[acl.entries]];    FOR i: CARDINAL IN [0..LENGTH[acl.entries]) DO      ptEntry: LONG POINTER TO NSFile.AccessEntry = @acl.entries[i];      description: Courier.Description = {        site: LONG POINTER TO NSString.String = notes.noteSize[0];        PutCHName[notes, site^, FALSE]};      Courier.SerializeParameters[[@ptEntry.key, description], memStream];      <<  remove 'type',handle access as array for Filing 5 compatibility        Stream.PutWord[memStream, LOOPHOLE[ptEntry.type]];        Stream.PutWord[memStream, LOOPHOLE[ptEntry.access]];      >>      IF ptEntry.access = NSFile.fullAccess THEN {        Stream.PutWord[memStream, 1];        Stream.PutWord[memStream, fullAccessProtocol]}      ELSE {        elements: CARDINAL _ 0;        FOR i: NSFile.AccessType IN NSFile.AccessType DO          IF ptEntry.access[i] THEN elements _ elements + 1; ENDLOOP;        Stream.PutWord[memStream, elements];        IF elements # 0 THEN          FOR i: NSFile.AccessType IN NSFile.AccessType DO	    IF ptEntry.access[i] THEN Stream.PutWord[memStream, ORD[i]]; ENDLOOP       };    ENDLOOP;    Stream.PutWord[memStream, LOOPHOLE[acl.defaulted]];    buffer.stopIndexPlusOne _ Inline.LowHalf[Stream.GetPosition[memStream]];    Stream.Delete[memStream];    --send length of attribute, then contents of buffer    PutWord[notes, buffer.stopIndexPlusOne / 2];  --stopIndexPlusOne should never be odd    PutBlock[notes, buffer.blockPointer, buffer.stopIndexPlusOne / 2];    notes.zone.FREE[@buffer.blockPointer];    END;  -- of PutAccessListWithLength  PutBlock: PROC [notes: Courier.Notes, site: LONG POINTER, size: CARDINAL] =    INLINE {notes.noteSpace[site, size]};  PutCHName: PROC [    notes: Courier.Notes, string: NSString.String, withLength: BOOLEAN] =    BEGIN    local, domain, org: BOOLEAN _ FALSE;    name: NSName.NameRecord;    NSName.NameFieldsFromString[notes.zone, string, @name];    IF name.local.length = 0 OR name.domain.length = 0 OR name.org.length = 0 THEN      {  -- ensure non-null strings in each field        IF name.local.length = 0 THEN {	  local _ TRUE; name.local _ defaultNamePart};        IF name.domain.length = 0 THEN {	  domain _ TRUE; name.domain _ defaultNamePart};        IF name.org.length = 0 THEN {org _ TRUE; name.org _ defaultNamePart}};    IF withLength THEN PutWord[notes, CHNameSize[@name]];    PutNSString[notes, name.org];    PutNSString[notes, name.domain];    PutNSString[notes, name.local];    IF local THEN name.local _ NSString.nullString;    IF domain THEN name.domain _ NSString.nullString;    IF org THEN name.org _ NSString.nullString;    NSName.FreeNameFields[notes.zone, @name];    END;  -- of PutCHName  PutDoubleWord: PROC [notes: Courier.Notes, value: LONG CARDINAL] = {    value _ SwapWords[value]; notes.noteSpace[@value, 2]};  PutOrdering: PUBLIC PROC [    notes: Courier.Notes, site: LONG POINTER TO NSFile.Ordering] =    BEGIN OPEN o: LOOPHOLE[site, LONG POINTER TO extended NSFile.Ordering];    PutDoubleWord[notes, o.key];    PutWord[notes, o.ascending];    PutWord[notes, o.interpretation];    END;  -- of PutOrdering  PutNSString: PUBLIC PROC [notes: Courier.Notes, string: NSString.String] =    BEGIN    PutWord[notes, string.length];    IF string.length MOD 2 = 1 THEN string.bytes[string.length] _ 0;    PutBlock[notes, string.bytes, (string.length + 1) / 2];    END;  -- of PutNSString   PutWordSequence: PROC [notes: Courier.Notes, words: NSFile.Words] =    BEGIN    PutWord[notes, LENGTH[words]];    notes.noteSpace[BASE[words], LENGTH[words]];    END;  -- of PutWordSequence  CHNameSize: PROC [name: NSName.Name] RETURNS [CARDINAL] =    BEGIN    RETURN[      StringSize[name.org] + StringSize[name.domain] + StringSize[name.local]];    END;  -- of CHNameSize  StringSize: PROC [string: NSString.String] RETURNS [CARDINAL] = INLINE {    RETURN[((string.length + 1) / 2) + 1]};  -- Serialization/Deserialization procedures  AttributeSequenceHeaderDescription: Courier.Description = {    [] _ notes.noteSize[SIZE[AttributeSequenceHeader]]};  DeserializeStreamOfAttributeSequence: PUBLIC PROCEDURE [    proc: AttributeListProc, sH: Stream.Handle] =    BEGIN    attributes: NSFile.AttributeList;    header: AttributeSequenceHeader;  -- stolen for convenience from StreamOpsAImpl  -- REMOVE THIS CHECK WHEN Courier/NSDataStream solve their problem with respect  --   to end of data received as a separate packet.  CheckForEndOfStream: PROCEDURE [stream: Stream.Handle] = {    DO      [] _ Stream.GetByte[stream ! Stream.EndOfStream => EXIT];      ERROR Courier.Error[parameterInconsistency];  -- too much data in stream      ENDLOOP};  -- of CheckForEndOfStream    DO      Courier.DeserializeParameters[        [@header, AttributeSequenceHeaderDescription], sH, zone];      FOR i: CARDINAL IN [0..header.lists) DO        continue: BOOLEAN;        attributes _ DeserializeAttributes[sH, zone];        continue _ proc[attributes ! UNWIND => FreeAttributes[attributes, zone]];        FreeAttributes[attributes, zone];        IF NOT continue THEN RETURN;        ENDLOOP;      SELECT header.type FROM        nextSegment => NULL;        lastSegment => EXIT;        ENDCASE => ERROR Courier.Error[parameterInconsistency];      ENDLOOP;    CheckForEndOfStream[sH];    END;  -- of DeserializeStreamOfAttributeSequence  SerializeAttributeSequenceHeader: PUBLIC PROCEDURE [    header: NSFileCourier.AttributeSequenceHeader, sH: Stream.Handle] = {    Courier.SerializeParameters[      [@header, AttributeSequenceHeaderDescription], sH]};  -- Client must ensure that from.isDirectory and from.isTemporary are set correctly.  EncodeAttributes: PUBLIC PROCEDURE [    from: NSFile.Attributes, selections: NSFileCourier.AttributeTypeList,    zone: UNCOUNTED ZONE] RETURNS [list: NSFile.AttributeList] =    BEGIN    ctExtended, ctListElements, ctSelections: CARDINAL;    IncludeAttribute: PROCEDURE [aType: NSFile.AttributeType] =      BEGIN      lptAttr: LONG POINTER TO NSFile.Attribute = @list[ctListElements];      SELECT TRUE FROM        aType = isDirectory => lptAttr^ _ [isDirectory[from.isDirectory]];        aType = isTemporary => lptAttr^ _ [isTemporary[from.isTemporary]];        ~from.isDirectory AND directoryAttributeSelections[aType],          from.isTemporary AND parentAttributeSelections[aType] =>          lptAttr^ _ [extended[type: LOOPHOLE[aType, CARDINAL], value: NIL]]        ENDCASE => {          LOOPHOLE[lptAttr, LONG POINTER TO NSFile.AttributeType]^ _ aType;          Inline.LongCOPY[            from: from + offset[aType], nwords: attributeLength[aType],            to: lptAttr + 1]};      ctListElements _ ctListElements + 1;      END;  -- of IncludeAttribute    IncludeExtendedAttribute: PROCEDURE [aType: AttributeType] =      BEGIN      FOR j: CARDINAL IN [0..ctExtended) DO        IF aType = from.extended[j].type THEN {          list[ctListElements] _ from.extended[j];          ctListElements _ ctListElements + 1;          EXIT};        REPEAT FINISHED => ERROR Bug[parameterAttributeInconsistency];        ENDLOOP;      END;  -- of IncludeExtendedAttribute    IF from = NIL THEN RETURN[NIL];    ctSelections _ LENGTH[selections];    IF ctSelections = 0 THEN RETURN[NIL];    ctExtended _ LENGTH[from.extended];    ctListElements _ 0;    IF selections[0] = allSelectionsProtocol THEN  -- include everything      {      ctSelections _ ctStandardAttributeTypes + ctExtended;      -- omit parent/directory attributes appropriately      IF ~from.isDirectory THEN        ctSelections _ ctSelections - ctDirectoryAttributes;      IF from.isTemporary THEN ctSelections _ ctSelections - ctParentAttributes;      list _ DESCRIPTOR[        Heap.MakeNode[zone, SIZE[NSFile.Attribute] * ctSelections], ctSelections];      FOR i: AttributeType IN        [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] DO        IF ~from.isDirectory AND directoryAttributeSelections[Inline.LowHalf[i]]          THEN LOOP;  --exclude        IF from.isTemporary AND parentAttributeSelections[Inline.LowHalf[i]] THEN          LOOP;  --exclude        IF i = NSAssignedTypes.service THEN LOOP;  -- never included!        IncludeAttribute[Inline.LowHalf[i]];        ENDLOOP;      -- all extended as well      FOR i: CARDINAL IN [0..ctExtended) DO        list[ctListElements] _ from.extended[i];        ctListElements _ ctListElements + 1;        ENDLOOP}    ELSE {  -- exactly what was requested      list _ DESCRIPTOR[        Heap.MakeNode[zone, SIZE[NSFile.Attribute] * ctSelections], ctSelections];      FOR i: CARDINAL IN [0..ctSelections) DO        IF selections[i] = NSAssignedTypes.service THEN	  NSFile.Error[[attributeType[disallowed, service]]];        IF selections[i] IN          [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] THEN          IncludeAttribute[Inline.LowHalf[selections[i]]]        ELSE IncludeExtendedAttribute[selections[i]];        ENDLOOP};    END;  -- of EncodeAttributes  DecodeAttributes: PUBLIC PROCEDURE [    from: NSFile.AttributeList, to: NSFile.Attributes, zone: UNCOUNTED ZONE] =    BEGIN    ctExtended: CARDINAL _ 0;    elements: CARDINAL _ LENGTH[from];    set: NSFile.Selections;    -- Ensure that parent/directory attributes have well-formed values, even when not selected (or not present in from).    to.parentID _ NSFile.nullID;    to.position _ NIL;    to.defaultAccessList _ [entries: NIL, defaulted: FALSE];    to.subtreeSizeLimit _ NSFile.nullSubtreeSizeLimit;    to.numberOfChildren _ 0;    to.ordering _ NSFile.defaultOrdering;    to.childrenUniquelyNamed _ FALSE;    FOR i: CARDINAL IN [0..elements) DO      lptAttr: LONG POINTER TO NSFile.Attribute = @from[i];      IF lptAttr.type # extended AND set.interpreted[lptAttr.type] THEN        ERROR NSFile.Error[[attributeValue[duplicated, lptAttr.type]]];      set.interpreted[lptAttr.type] _ TRUE;      WITH a: lptAttr SELECT FROM        isDirectory => to.isDirectory _ a.value;        isTemporary => to.isTemporary _ a.value;        extended => ctExtended _ ctExtended + 1;        ENDCASE =>          Inline.LongCOPY[            from: lptAttr + 1, nwords: attributeLength[lptAttr.type],            to: to + offset[lptAttr.type]];      ENDLOOP;    IF ctExtended > 0 THEN {      DuplicateAttribute: PROC [eType: NSFile.ExtendedAttributeType] = {        Heap.FreeNode[zone, BASE[to.extended]];        to.extended _ NIL;        ERROR NSFile.Error[[attributeValue[duplicated, extended, eType]]];        };      to.extended _ DESCRIPTOR[        Heap.MakeNode[zone, SIZE[extended NSFile.Attribute] * ctExtended],          ctExtended];      ctExtended _ 0;      FOR i: CARDINAL IN [0..elements) DO        lptAttr: LONG POINTER TO NSFile.Attribute = @from[i];        WITH a: lptAttr SELECT FROM          extended => {            FOR j: CARDINAL IN [0..ctExtended) DO              IF a.type = to.extended[j].type THEN DuplicateAttribute[a.type];              ENDLOOP;            to.extended[ctExtended] _ a;            ctExtended _ ctExtended + 1};          ENDCASE;        ENDLOOP;      };    END;  -- of EncodeAttributes  EncodeControls: PUBLIC PROCEDURE [    controls: NSFile.Controls, controlSelections: NSFile.ControlSelections,    zone: UNCOUNTED ZONE] RETURNS [controlsList: ControlsList] =    BEGIN    defaulted: NSFile.ControlSelections = [      lock: controls.lock = none,      timeout: controls.timeout = NSFile.defaultTimeout,      access: controls.access = NSFile.fullAccess];    elements: CARDINAL _ 0;    FOR i: NSFile.ControlType IN NSFile.ControlType DO      IF defaulted[i] AND ~controlSelections[i] THEN LOOP;      elements _ elements + 1;      ENDLOOP;    IF elements = 0 THEN RETURN[NIL];    controlsList _ DESCRIPTOR[      Heap.MakeNode[zone, SIZE[Control] * elements], elements];    elements _ 0;    FOR i: NSFile.ControlType IN NSFile.ControlType DO      IF defaulted[i] AND ~controlSelections[i] THEN LOOP;      SELECT i FROM        lock => controlsList[elements] _ [lock[value: controls.lock]];        timeout => controlsList[elements] _ [timeout[value: controls.timeout]];        access => controlsList[elements] _ [access[value: controls.access]];        ENDCASE;      elements _ elements + 1;      ENDLOOP;    END;  DecodeControls: PUBLIC PROCEDURE [controlsList: ControlsList]    RETURNS [      controls: NSFile.Controls, controlSelections: NSFile.ControlSelections] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[controlsList]) DO      lptControl: LONG POINTER TO Control = @controlsList[i];      IF controlSelections[lptControl.type] THEN        NSFile.Error[[controlValue[duplicated, lptControl.type]]];      controlSelections[lptControl.type] _ TRUE;      WITH c: lptControl SELECT FROM        lock => controls.lock _ c.value;        timeout => controls.timeout _ c.value;        access => controls.access _ c.value;        ENDCASE;      ENDLOOP;    END;  FreeControls: PUBLIC PROCEDURE [    controlsList: ControlsList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[controlsList] # NIL THEN Heap.FreeNode[zone, BASE[controlsList]];    END;  EncodeControlSelections: PUBLIC PROCEDURE [    controlSelections: NSFile.ControlSelections, zone: UNCOUNTED ZONE]    RETURNS [controlTypeList: ControlTypeList] =    BEGIN    elements: CARDINAL _ 0;    FOR i: NSFile.ControlType IN NSFile.ControlType DO      IF controlSelections[i] THEN elements _ elements + 1; ENDLOOP;    IF elements = 0 THEN RETURN[NIL];    controlTypeList _ DESCRIPTOR[      Heap.MakeNode[zone, SIZE[NSFile.ControlType] * elements], elements];    elements _ 0;    FOR i: NSFile.ControlType IN NSFile.ControlType DO      IF controlSelections[i] THEN {        controlTypeList[elements] _ i; elements _ elements + 1};      ENDLOOP;    END;  DecodeControlSelections: PUBLIC PROCEDURE [controlTypeList: ControlTypeList]    RETURNS [controlSelections: NSFile.ControlSelections] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[controlTypeList]) DO      IF controlSelections[controlTypeList[i]] THEN  -- duplicate        ERROR NSFile.Error[[controlType[duplicated, controlTypeList[i]]]];      controlSelections[controlTypeList[i]] _ TRUE;      ENDLOOP;    END;  FreeControlSelections: PUBLIC PROCEDURE [    controlTypeList: ControlTypeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[controlTypeList] # NIL THEN      Heap.FreeNode[zone, BASE[controlTypeList]];    END;  EncodeSelections: PUBLIC PROCEDURE [    selections: NSFile.Selections, zone: UNCOUNTED ZONE]    RETURNS [attributeTypeList: AttributeTypeList] =    BEGIN    ctExtended: CARDINAL;    ctInterpreted, ct: CARDINAL _ 0;    interpSelections: NSFile.InterpretedSelections _ selections.interpreted;    IF selections = NSFile.noSelections THEN RETURN[NIL];    SELECT (ctExtended _ LENGTH[selections.extended]) FROM      1 =>        IF selections.extended[0] = NSFile.allExtendedSelectionsRepresentation[0]          THEN {          attributeTypeList _ DESCRIPTOR[            Heap.MakeNode[zone, SIZE[AttributeType]], 1];          attributeTypeList[0] _ allSelectionsProtocol;          RETURN};      ENDCASE;    interpSelections[extended] _ FALSE;  -- doesn't count as interpreted    interpSelections[service] _ FALSE;  -- never requested remotely    -- NOTE THAT ALMOST ALL TYPES ARE INCLUDED (I.E. SOME NON-STANDARD TYPES)    IF interpSelections # NSFile.noInterpretedSelections THEN      FOR i: NSFile.AttributeType IN NSFile.AttributeType DO        IF interpSelections[i] THEN ctInterpreted _ ctInterpreted + 1; ENDLOOP;    ct _ ctInterpreted + ctExtended;    attributeTypeList _ DESCRIPTOR[      Heap.MakeNode[zone, SIZE[AttributeType] * ct], ct];    ct _ 0;    IF interpSelections # NSFile.noInterpretedSelections THEN      FOR i: NSFile.AttributeType IN NSFile.AttributeType DO        IF interpSelections[i] THEN {          attributeTypeList[ct] _ LONG[LOOPHOLE[i, CARDINAL]]; ct _ ct + 1};        ENDLOOP;    SELECT selections.extended FROM      NSFile.noExtendedSelections => NULL;      ENDCASE =>        FOR i: CARDINAL IN [0..LENGTH[selections.extended]) DO          attributeTypeList[ct] _ selections.extended[i]; ct _ ct + 1 ENDLOOP;    END;  DecodeSelections: PUBLIC PROCEDURE [    attributeTypeList: AttributeTypeList, zone: UNCOUNTED ZONE]    RETURNS [selections: NSFile.Selections] =    BEGIN OPEN NSAssignedTypes;    ctExtended: CARDINAL _ 0;    ctSelections: CARDINAL = LENGTH[attributeTypeList];    SetSelection: PROC [attributeType: NSFile.AttributeType] = {      IF selections.interpreted[attributeType] THEN  -- duplicate        ERROR NSFile.Error[[attributeType[duplicated, attributeType]]];      selections.interpreted[attributeType] _ TRUE};    IF ctSelections = 1 AND attributeTypeList[0] = LAST[LONG CARDINAL] THEN      RETURN[NSFile.allSelections];    FOR i: CARDINAL IN [0..ctSelections) DO      IF attributeTypeList[i] IN [checksum..subtreeSizeLimit] THEN        SetSelection[Inline.LowHalf[attributeTypeList[i]]]      ELSE ctExtended _ ctExtended + 1;      ENDLOOP;    IF ctExtended > 0 THEN {      selections.extended _ DESCRIPTOR[        Heap.MakeNode[zone, SIZE[NSFile.ExtendedAttributeType] * ctExtended],          ctExtended];      ctExtended _ 0;      FOR i: CARDINAL IN [0..ctSelections) DO        IF attributeTypeList[i] ~IN [checksum..subtreeSizeLimit] THEN {          IF attributeTypeList[i] = LAST[LONG CARDINAL] THEN            ERROR NSFile.Error[[attributeType[unreasonable, extended]]];          selections.extended[ctExtended] _ attributeTypeList[i];          ctExtended _ ctExtended + 1};        ENDLOOP;      }    END;  FreeAttributeTypeList: PUBLIC PROCEDURE [    attributeTypeList: AttributeTypeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[attributeTypeList] # NIL THEN      Heap.FreeNode[zone, BASE[attributeTypeList]];    END;  FreeSelections: PUBLIC PROCEDURE [    selections: NSFile.Selections, zone: UNCOUNTED ZONE] =    BEGIN    SELECT BASE[selections.extended] FROM      NIL => NULL;      BASE[NSFile.allExtendedSelections] => NULL;      ENDCASE => Heap.FreeNode[zone, BASE[selections.extended]];    END;  END.    LOG (date - person - action) - - - - SERVICES 8.0 - - - -November 15, 1983 - Hanzel - Initial conversion to Services 8.0 and Klamath Courier.December 2, 1983 - Hanzel - Never include 'service' in EncodeAttributes and EncodeSelections.December 16, 1983 - Hanzel - Clean up act w.r.t. node allocation; rely on zone within notes object throughout (eliminated zone argument to few procedures).20-Dec-83 13:52:59 - Ciccone - Removed zone parameter from GetNSString.December 28, 1983 - Hanzel - Work around fact that Courier fails to supply any zone during SerializeParameters in SerializeAttributes and PutAccessList (AR 5273).December 30, 1983 - Hanzel - Make check for service in EncodeAttributes (with non-all selections) report error instead of skipping selection.January 25, 1984 - Hanzel - Remove workarounds for lack of Courier-supplied zone (11.0f) in DescribeAttribute, PutAccessList and SerializeAttributes.February 2, 1984 - Hanzel - Report NSFile.Error[[attributeType[illegal, service]]] instead of Courier.Error[parameterInconsistency] if "service" attribute is passed in protocol attribute lists (GetAttribute and PutAttribute).April 26, 1984 - Hanzel - Work around Courier/NSDataStream deficiency with respect to end of data in DeserializeStreamOfAttributeSequence.- - - - SERVICES 8.0.12 - - - -March 2, 1987 - Hanzel - Changes for Filing 5 support for BWS 4.3 Filing. Convert from bytes to pages and pages to bytes in GetAttribute and PutAttribute; exclude 'type' field from access lists in GetAccessList and PutAccessListWithLength.  Defined 'versionNumber' independent of NSFileCourier.versionNumber.March 3, 1987 - Hanzel - Handle null subtree size limits, three-part names with null parts.
-- NSFilingControlBImpl.mesa-- Mita.ES                 16-Mar-87 18:52:04-- Last revised by Hanzel: 14-Jun-84 14:52:20-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- Overview:  Implementation of commonly-used procedures defined in NSFilingGlobal and NSFile.DIRECTORY  Auth USING [CallProblem],  CH USING [    ConversationHandle, FreeConversationHandle,     LookupDistinguishedName, MakeConversationHandle, ReturnCode],  CHCommonLookups USING [LookupAddress],  Environment USING [Byte],  Heap USING [Create, systemZone],  Inline USING [LongCOPY],  NSFile USING [    Error, ErrorRecord, Identity, localSystemElement, nullService,    nullSystemElement, Service, ServiceRecord],  NSFileControlInternal,  NSFilingGlobal,  NSFilingGlobalExtra,  NSName USING [FreeNameFields, MakeNameFields, Name],  NSSession USING [AssignClientID, ClientID],   NSString USING [EquivalentStrings, nullString, String],  NSStringExtras USING [EquivalentNames],  NSVolumeControl USING [Error, GetID],  Runtime USING [IsBound],  System USING [NetworkAddress, nullID];NSFilingControlBImpl: MONITOR   IMPORTS CH, CHCommonLookups, Heap, Inline, commonNSFile: NSFile,    -- localNSFile: -- NSFile, NSName, NSSession, NSString, NSStringExtras, NSVolumeControl, Runtime  EXPORTS NSFileControlInternal, NSFilingGlobal, NSFilingGlobalExtra =  BEGIN    -- Types  Character: TYPE = Environment.Byte;  Service: TYPE = NSFile.Service;  String: TYPE = NSString.String;  ServiceCacheRecord: TYPE = RECORD [    service: NSFile.ServiceRecord,    next: ServiceReference];  ServiceReference: TYPE = LONG POINTER TO ServiceCacheRecord;    StringCache: PUBLIC TYPE = LONG POINTER TO StringCacheObject;  StringCacheObject: TYPE = RECORD [    seal: CARDINAL _ stringCacheSeal,    z: UNCOUNTED ZONE,    vector: LONG POINTER TO Vector,    initialSize, growBy: [0..256) _ 5];  StringRecord: TYPE = RECORD [PACKED SEQUENCE count: CARDINAL OF Character];  StringReference: TYPE = LONG POINTER TO StringRecord;  Vector: TYPE = RECORD [SEQUENCE count: CARDINAL OF StringReference];  -- Exported constants  clientID: PUBLIC NSSession.ClientID;  -- Private constants  stringCacheSeal: CARDINAL = 010883;  defaultCache: StringCache = LOOPHOLE[LONG[NIL]];  -- Caches    defaultStringCacheReal: StringCache;  -- see mainline  serviceCache: ServiceReference _ NIL;  ---- ---- ---- ---- ---- ----  -- SERVICE CACHING AND LOOKUP (NSFilingGlobal)  ---- ---- ---- ---- ---- ----  CacheService: PUBLIC ENTRY PROC [s: Service, add: BOOLEAN]    RETURNS [cacheS: Service] =    BEGIN    NullDomainAndOrg: PROC [svc: Service] RETURNS [BOOLEAN] = INLINE {      RETURN[svc.name.domain.length = 0 AND svc.name.org.length = 0]};    NullOrLocalSystem: PROC [svc: Service] RETURNS [BOOLEAN] = INLINE {      RETURN[        svc.systemElement = NSFile.nullSystemElement          OR svc.systemElement = NSFile.localSystemElement]};    cacheS ¬ FindInServiceCache[s];    IF cacheS # NIL THEN RETURN;    -- special cases for local service entries    IF NullDomainAndOrg[s] THEN {      cacheS ¬ FindInServiceCache[s, TRUE];      IF cacheS # NIL AND cacheS.systemElement = NSFile.localSystemElement THEN        RETURN[cacheS]}    ELSE      IF s.systemElement = NSFile.localSystemElement THEN {        cacheS ¬ FindInServiceCache[s, TRUE];        IF cacheS # NIL AND NullDomainAndOrg[cacheS] THEN {          cacheS.name.domain ¬ CacheString[s.name.domain];          cacheS.name.org ¬ CacheString[s.name.org];          RETURN[cacheS]}};    IF add THEN cacheS ¬ AddToServiceCache[s];    END;  -- of CacheService  FlushServiceCache: PUBLIC ENTRY PROC =    -- Invalidate 'cache', releasing all its resources.    BEGIN    temp: ServiceReference;    WHILE serviceCache # NIL DO      temp _ serviceCache.next;      z.FREE[@serviceCache];      serviceCache _ temp;      ENDLOOP;    END;  -- of FlushServiceCache    RenameCachedService: PUBLIC ENTRY PROC [oldName, newName: NSName.Name] =    BEGIN    svcRecord: NSFile.ServiceRecord _ [name: oldName^];    svcInCache: Service _ FindInServiceCache[@svcRecord];        IF svcInCache # NIL THEN {  -- update only if present      svcInCache.name.local _ CacheString[newName.local];      svcInCache.name.domain _ CacheString[newName.domain];      svcInCache.name.org _ CacheString[newName.org]};    END;  -- RenameCachedService-- Stolen from Service10.0(ResolveAndCacheService)  ResolveServiceAddress: PUBLIC PROC [    service: NSFile.Service, identity: NSFile.Identity]    -- RETURNS [cachedService: NSFile.Service]    =    BEGIN    cachedService: NSFile.Service;    nullDomainAndOrg: BOOLEAN;    found: BOOLEAN ¬ FALSE;    IF service = NSFile.nullService THEN      commonNSFile.Error[[attributeValue[unreasonable, service]]];    nullDomainAndOrg ¬      service.name.domain.length = 0 AND service.name.org.length = 0;    IF nullDomainAndOrg THEN service.systemElement ¬ NSFile.localSystemElement;    cachedService ¬ CacheService[service, FALSE];    IF cachedService # NSFile.nullService THEN {      found ¬ TRUE;      IF cachedService.systemElement # NSFile.nullSystemElement THEN RETURN};    -- try local first    IF Runtime.IsBound[LOOPHOLE[NSVolumeControl.GetID]]      AND System.nullID # NSVolumeControl.GetID[        volumeName: @service.name, ignoreOrgAndDomain: nullDomainAndOrg !        NSVolumeControl.Error => IF type = volumeNotFound THEN CONTINUE] THEN      service.systemElement ¬ NSFile.localSystemElement;    -- service not in cache already or has null systemElement    IF service.systemElement = NSFile.localSystemElement THEN      RETURN;    -- service was not a local (open) volume    BEGIN  -- must be remote    callProblem: Auth.CallProblem;    conversation: CH.ConversationHandle;    ok: BOOLEAN;    rc: CH.ReturnCode;    serviceRec: NSFile.ServiceRecord;    ReportError: PROC = {      e: NSFile.ErrorRecord;      CH.FreeConversationHandle[@conversation, Heap.systemZone];      NSName.FreeNameFields[Heap.systemZone, @serviceRec.name];      SELECT rc.code FROM        notAllowed => e ¬ [clearingHouse[notAllowed]];        rejectedTooBusy => e ¬ [clearingHouse[rejectedTooBusy]];        allDown => e ¬ [clearingHouse[allDown]];        illegalOrgName => e ¬ [clearingHouse[illegalOrgName]];        illegalDomainName => e ¬ [clearingHouse[illegalDomainName]];        illegalLocalName => e ¬ [clearingHouse[illegalLocalName]];        noSuchOrg => e ¬ [clearingHouse[noSuchOrg]];        noSuchDomain => e ¬ [clearingHouse[noSuchDomain]];        noSuchLocal => e ¬ [clearingHouse[noSuchLocal]];        wasUpNowDown => e ¬ [clearingHouse[wasUpNowDown]];        ENDCASE => e ¬ [attributeValue[unreasonable, service]];      commonNSFile.Error[e]};    [conversation, ok, callProblem] ¬ CH.MakeConversationHandle[identity, Heap.systemZone];    IF ~ok THEN  -- problem speaking to Auth Service      commonNSFile.Error[        [        authentication[        SELECT callProblem FROM          badKey => credentialsInvalid,          tooBusy => tooBusy,          cannotReachAS => cannotReachAS,          keysUnavailable => keysUnavailable,          strongKeyDoesNotExist => strongKeyDoesNotExist,          simpleKeyDoesNotExist => simpleKeyDoesNotExist,          ENDCASE => -- all other -- other]]];    -- get full name in case it's an alias    NSName.MakeNameFields[Heap.systemZone, @serviceRec.name];    rc ¬ CH.LookupDistinguishedName[      conversation, @service.name, @serviceRec.name];    IF rc.code # done THEN ReportError[];    [rc, serviceRec.systemElement] ¬ CHCommonLookups.LookupAddress[      conversation, @serviceRec.name];    -- @serviceRec.name should be used instead of @service.name    IF rc.code # done THEN ReportError[];    CH.FreeConversationHandle[@conversation, Heap.systemZone];    IF found THEN cachedService.systemElement ¬ serviceRec.systemElement    ELSE cachedService ¬ CacheService[@serviceRec, TRUE];    NSName.FreeNameFields[Heap.systemZone, @serviceRec.name];    END;    END;  -- of ResolveServiceAddress  ---- ---- ---- ---- ---- ----  -- PRIVATE OPERATIONS  ---- ---- ---- ---- ---- ----  AddToServiceCache: PROC [s: Service] RETURNS [cacheS: Service] =    BEGIN    sR: ServiceReference _ z.NEW[ServiceCacheRecord _ [next: serviceCache]];    sR.service.name.local _ CacheString[s.name.local];    sR.service.name.domain _ CacheString[s.name.domain];    sR.service.name.org _ CacheString[s.name.org];    sR.service.systemElement _ s.systemElement;    serviceCache _ sR;    RETURN[@serviceCache.service];    END;  -- of AddToServiceCache  AddToStringCache: PROC [s: String, cache: StringCache]   RETURNS [cacheS: String] =    BEGIN  -- may grow cache    sR: StringReference _ CreateStringReference[cache.z, s];    index: CARDINAL _ FindEmptyIndex[cache];  -- may cause growth    cache.vector[index] _ sR;    RETURN[StringFromStringReference[sR]];    END;  -- of AddToStringCache  CacheString: PROC [    s: String, cache: StringCache _ defaultCache, add: BOOLEAN _ TRUE]    RETURNS [cacheS: String] =    -- Cache 's' and return a pointer to an equivalent string body.  If 's' is not already in the cache and 'add' is TRUE, 's' is added; otherwise, if 'add' is FALSE, NIL is returned.    BEGIN    IF cache = NIL THEN cache _ defaultStringCacheReal;    cacheS _ FindInStringCache[s, cache];    IF cacheS.bytes # NIL THEN RETURN;    IF add THEN cacheS _ AddToStringCache[s, cache];    END;  -- of CacheString  CreateStringCache: PROC [z: UNCOUNTED ZONE] RETURNS [cache: StringCache] =    -- Define a new cache using storage from the given zone for internal structures.  The default cache uses the system zone.    BEGIN    cache _ z.NEW[StringCacheObject _ [z: z, vector: NIL]];    GrowStringCache[cache];    END;  -- of CreateStringCache  CreateStringReference: PROC [z: UNCOUNTED ZONE, s: String]    RETURNS [stringRef: StringReference] =    BEGIN    stringRef _ z.NEW[StringRecord [s.length]];    Inline.LongCOPY[      from: s.bytes, to: BASE[DESCRIPTOR[stringRef^]],      nwords: SIZE[Character, s.length]];    END;  -- of CreateStringReference  DestroyStringCache: PROC [cache: StringCache] =    -- Invalidate 'cache', releasing all its resources.    BEGIN    default: BOOLEAN _ FALSE;    z: UNCOUNTED ZONE;        IF cache = NIL THEN {cache _ defaultStringCacheReal; default _ TRUE};    z _ cache.z;    -- first the vector and its attached structures    FOR i: CARDINAL IN [0..cache.vector.count) DO      IF cache.vector[i] # NIL THEN DestroyStringReference[z, cache.vector[i]];      ENDLOOP;         IF ~default THEN {      z.FREE[@cache.vector];      z.FREE[@cache]  -- finally, the cache object itself      };          END;  -- of DestroyStringCache  DestroyStringReference: PROC [z: UNCOUNTED ZONE, stringRef: StringReference] =    BEGIN z.FREE[@stringRef]; END;  -- of DestroyStringReference  FindEmptyIndex: PROC [cache: StringCache] RETURNS [index: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..cache.vector.count) DO      IF cache.vector[i] = NIL THEN RETURN[i]; ENDLOOP;    -- must grow    index _ cache.vector.count;    GrowStringCache[cache];    END;  -- of FindEmptyIndex  FindInServiceCache: PROC [    s: Service, ignoreDomainOrg, matchOnLocalSystem: BOOLEAN _ FALSE]    RETURNS [str: Service] =    BEGIN    temp: ServiceReference;        CompareSvcNames: PROC [cachedService: Service] RETURNS [BOOLEAN] = INLINE {      RETURN[        IF ignoreDomainOrg THEN NSString.EquivalentStrings[        s.name.local, cachedService.name.local]        ELSE NSStringExtras.EquivalentNames[@s.name, @cachedService.name]]}; --Get from 10.0    temp ¬ serviceCache; -- AR4547 Fix    --try to match on pointer values first. AR:4547    WHILE temp # NIL DO    IF s = @temp.service THEN RETURN[s];      temp ¬ temp.next;    ENDLOOP;    -- Then compare if not found.    temp _ serviceCache;    WHILE temp # NIL DO      IF CompareSvcNames[@temp.service] THEN RETURN[@temp.service];      temp ¬ temp.next;      ENDLOOP;    RETURN[NIL];    END;  -- of FindInServiceCache  FindInStringCache: PROC [s: String, cache: StringCache] RETURNS [str: String] =    BEGIN    sR: StringReference;    FOR i: CARDINAL IN [0..cache.vector.count) DO      sR _ cache.vector[i];      IF sR = NIL THEN LOOP;      str _ StringFromStringReference[sR];      IF NSString.EquivalentStrings[s, str] THEN RETURN[str]      ENDLOOP;    RETURN[NSString.nullString];    END;  -- of FindInStringCache  GrowStringCache: PROC [cache: StringCache] =    BEGIN    oldSize: CARDINAL = IF cache.vector = NIL THEN 0 ELSE cache.vector.count;    newSize: CARDINAL =      IF oldSize = 0 THEN cache.initialSize ELSE oldSize + cache.growBy;    newVector: LONG POINTER TO Vector _ cache.z.NEW[Vector [newSize]];    -- copy old entries    IF cache.vector # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..oldSize) DO newVector[i] _ cache.vector[i]; ENDLOOP;      cache.z.FREE[@cache.vector];      END;    -- clear other entries    FOR i: CARDINAL IN [oldSize..newSize) DO newVector[i] _ NIL; ENDLOOP;    cache.vector _ newVector;    END;  -- of GrowStringCache  StringFromStringReference: PROC [sR: StringReference] RETURNS [s: String] =    BEGIN    s _ [bytes: BASE[DESCRIPTOR[sR^]], length: sR.count, maxlength: sR.count];    END;  -- of StringFromStringReference  -- MAINLINE  z: UNCOUNTED ZONE _ Heap.Create[initial: 1, increment: 1];  serviceCache _ NIL;  defaultStringCacheReal _ CreateStringCache[Heap.systemZone];  clientID _ NSSession.AssignClientID[];  -- start-traps Session mechanism  END.LOG  ( date - person - action ) 2-Nov-83 16:26:48 - Buelow - Created from Frank's String and Service caching.10-Nov-83 13:34:00 - Buelow - Set the systemElement also in AddToServiceCache.20-Dec-83 15:20:44 - Ciccone - Added initialization and export of clientID; included NSFileControlInternal in EXPORTS; merged in implementation of ResolveServiceAddress from NSFilingGlobalExtraImpl.January 5, 1984 - Hanzel - Fix for 8.0c changes (CH error reporting).February 23, 1984 - Gleason - Replace alias name for service with distinghuished name in ResolveServiceAddress.April 27, 1984 - Hanzel - Raise appropriate Auth errors in ResolveServiceAddress.May 17, 1984 - Hanzel - Attempt to resolve pathname issues relating to service caching in CacheService.May 24, 1984 - Hanzel - Implement RenameCachedService to fix AR 8120.June 14, 1984 - Hanzel - Rework ResolveServiceAddress to fix AR's 5731 and 8582 (error reporting and alias resolution). 3-Mar-87  - Mita - AR4547:FindInServiceCache: avoid expensive string comparisons 6-Mar-87 - Mita - Pick up service10.0 CacheService,ResolveAndCacheService,FindInServiceCache  [duplicate the perf fix here]In order to include the 10.0 ResolveAndCacheService routine you should:  - rename it "ResolveServiceAddress" in the 8.0 module, and  - comment out the return parameter (make it a local variable) 
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- RandomProg.mesa   25-Jan-83 15:46:46 by RXJ     DIRECTORY  Inline USING [LongNumber, LongMult, HighHalf, BITOR, BITAND, BITSHIFT],  Heap USING [systemZone],  Time USING [Current],  RandomDefs USING [GeneratorState, SimpleGeneratorState];RandomProg: PROGRAM  IMPORTS Heap, Time, Inline EXPORTS RandomDefs SHARES RandomDefs =  BEGIN OPEN RandomDefs;    initA: Inline.LongNumber = [num[lowbits: 28293, highbits: 10371]];  initC: Inline.LongNumber = [num[lowbits: 25321, highbits: 13849]];  Randomize: PUBLIC PROCEDURE [seed: LONG CARDINAL]    RETURNS [pgen: LONG POINTER TO RandomDefs.GeneratorState] =    BEGIN    pgen ¬ Heap.systemZone.NEW[RandomDefs.GeneratorState];    pgen­.seed ¬ RandomSeed[seed];    InitializeRandom[pgen];    END;  InitializeRandom: PUBLIC PROCEDURE [    pgen: LONG POINTER TO RandomDefs.GeneratorState] =    BEGIN OPEN pgen­;    i: CARDINAL;    psubgen: LONG POINTER TO RandomDefs.SimpleGeneratorState;    --InitializeRandom uses the seed within pgen­ as the seed in a reasonably good, but simple, random number generator to create two reasonably good, but simple, random number generators from random numbers.    --The techniques used to make each simple random number generator reasonably good are described in Knuth, vol. 2 and the technique of combining the two random number generators into a single high quality random number generator is advocated by Knuth.    --The use of different seeds to Randomize effectively creates different random number generators.    subgen1.x ¬ seed;  --see SimpleRandom.    subgen1.a ¬ initA.lc;  --initially, subgen1 is a standard, simple random number generator.    subgen1.c ¬ initC.lc;    psubgen ¬ @subgen1;    FOR i IN [0..6) DO      table[i] ¬ RawSimpleRandom[psubgen];  --this is the only use of the simple, standard random number generator.      ENDLOOP;    --This next loop uses the random numbers in table[0..6) to create two simple random number generators in subgen1 and subgen2. The full generator uses subgen2 to fill the table and then uses subgen1 to choose which element of the table will be given out. When an entry of the table is given out, it is replaced with the next value of subgen2.    FOR i IN [0..1] DO      psubgen.x ¬ table[i];      psubgen.a ¬ table[i + 2];      psubgen.c ¬ table[i + 4];      InitializeSimpleRandom[psubgen];      psubgen ¬ @subgen2;      ENDLOOP;    FOR i IN [0..31] DO table[i] ¬ RawSimpleRandom[psubgen]; ENDLOOP;    END;  InitializeSimpleRandom: PUBLIC PROCEDURE [    psimpgen: LONG POINTER TO RandomDefs.SimpleGeneratorState] =    BEGIN    OPEN a: LOOPHOLE[psimpgen.a, Inline.LongNumber],      c: LOOPHOLE[psimpgen.c, Inline.LongNumber];    --Knuth suggests that random number generators of this type have a reasonably large a and that (a)mod 8 = 5. He also suggests that c/232 be approximately equal to (1/2 - 1/6 sqrt[3]) and odd.    a.lowbits ¬ Inline.BITOR[Inline.BITAND[a.lowbits, 177770B], 5B];  --force to 5 mod 8.    IF a.highbits NOT IN [10000B..170000B) THEN a.highbits ¬ a.highbits + 50000B;    --force high bits into [10000B..170000B).    c.lowbits ¬ Inline.BITOR[c.highbits, 1];    --make c odd and assume that the high order bits of c are more random than the low bits.    c.highbits ¬ initC.highbits;  -- c is about 232*(1/2 - 1/6 sqrt[3]).    END;  RawSimpleRandom: PUBLIC PROCEDURE [    psimpgen: LONG POINTER TO RandomDefs.SimpleGeneratorState]    RETURNS [r: LONG CARDINAL] =    --This generator operates by computing x ¬ (a*x + c) mod 232.    --The theory behind this kind of generator is discussed in Knuth, Vol. 1.    --The high order bits of x are much more random than the low order bits.    BEGIN OPEN psimpgen­;    x ¬ r ¬ (a*x + c);  --arithmetic mod 232.    END;  SimpleRandom: PUBLIC PROCEDURE [    psimpgen: LONG POINTER TO RandomDefs.SimpleGeneratorState, key: CARDINAL]    RETURNS [r: CARDINAL] =    BEGIN    temp: Inline.LongNumber;    prod: Inline.LongNumber;    temp.lc ¬ RawSimpleRandom[psimpgen];    prod.lc ¬ Inline.LongMult[temp.highbits, key];    IF      (prod.lowbits > prod.lowbits + key        AND prod.lowbits >          prod.lowbits + Inline.HighHalf[Inline.LongMult[temp.lowbits, key]]) THEN      r ¬ prod.highbits + 1    ELSE r ¬ prod.highbits;    END;  RawRandom: PUBLIC PROCEDURE [pgen: LONG POINTER TO RandomDefs.GeneratorState]    RETURNS [r: LONG CARDINAL] =    BEGIN OPEN pgen­;    i: [0..31];    i ¬ Inline.BITSHIFT[Inline.HighHalf[RawSimpleRandom[@subgen1]], -11];    r ¬ table[i];    table[i] ¬ RawSimpleRandom[@subgen2];    END;  Random: PUBLIC PROCEDURE    [pgen: LONG POINTER TO RandomDefs.GeneratorState, key: CARDINAL]    RETURNS [r: CARDINAL] =    BEGIN OPEN pgen­;    i: [0..31];    temp, temp2: Inline.LongNumber;    i ¬ Inline.BITSHIFT[Inline.HighHalf[RawSimpleRandom[@subgen1]], -11];    temp2.lc ¬ table[i];    temp.lc ¬ Inline.LongMult[temp2.highbits, key];    IF      (temp.lowbits > temp.lowbits + key        AND temp.lowbits >          temp.lowbits + Inline.HighHalf[Inline.LongMult[temp2.lowbits, key]])      THEN r ¬ temp.highbits + 1    ELSE r ¬ temp.highbits;  --this is a full, accurate multiplication by key.    table[i] ¬ RawSimpleRandom[@subgen2];    END;  RandomSeed: PUBLIC PROCEDURE [seed: LONG CARDINAL]    RETURNS [val: LONG CARDINAL] =    BEGIN val ¬ IF seed = 0 THEN Time.Current[] ELSE seed; END;  END.LOGMarch 29, 1979  3:24 PM   HXL     Converted to Mesa 5.0April 27, 1979  3:17 PM   HXL     Checked into Pilot LibraryJuly 17, 1979  1:53 PM   PXM       TimeDefs => Time, InlineDefs => InlineJanuary 15, 1980  8:27 PM   RXG      SystemDefs => Storage.25-Jan-83 15:46:34   RXJ        Storage => Heap.
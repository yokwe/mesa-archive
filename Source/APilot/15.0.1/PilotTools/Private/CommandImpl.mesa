-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CommandImpl.mesa     26-Dec-84 15:56:31 by AWL      DIRECTORY  Ascii USING [CR, DEL, SP],  Command USING [    Action, Catch, Context, Entry, nullContext, Options, VariableDescriptor],  Heap USING [systemMDSZone],  ProcessOperations USING [Enter, Exit],  Runtime USING [CallDebugger],  String USING [AppendLongDecimal, InvalidNumber],  TTY USING [    GetChar, GetLine, Handle, LineOverflow, NewLine, ResetUserAbort, Rubout,    PutChar, PutLine, PutString];CommandImpl: MONITOR LOCKS lockPtr USING lockPtr: LONG POINTER TO MONITORLOCK   IMPORTS Heap, ProcessOperations, Runtime, String, TTY   EXPORTS Command =  BEGIN  Entries: TYPE = ARRAY [0..maxEntriesPerTopLevel) OF Command.Entry;  TopLevelHandle: TYPE = LONG POINTER TO TopLevel;  TopLevel: TYPE = RECORD [    h: TTY.Handle,    used: CARDINAL,  --number of entries used up of options    unwindLevel: CARDINAL,    next: TopLevelHandle,    recordLock: MONITORLOCK,    options: Command.Options,    optionsLock: MONITORLOCK];  maxEntriesPerTopLevel: CARDINAL = 25;  mz: MDSZone = Heap.systemMDSZone;  topLevels: TopLevelHandle ¬ NIL;  topLevelsLock: MONITORLOCK;  Aborted: PUBLIC ERROR = CODE;  Quit: PUBLIC ERROR = CODE;  Unwind: ERROR [levelDest: CARDINAL] = CODE;    AssignUnwindLevel: ENTRY PROCEDURE [      lockPtr: LONG POINTER TO MONITORLOCK,  top: TopLevelHandle]      RETURNS [CARDINAL] = {RETURN[top.unwindLevel]};  Break: PUBLIC PROCEDURE [h: TTY.Handle, why: LONG STRING] =    BEGIN    CoPilotCmd: Command.Action = {      Confirm[h]; Runtime.CallDebugger["Proceed to return to break"L]};    RunTopLevelCmd: Command.Action = {Confirm[h]; RunTopLevel[h]};    entries: ARRAY [0..4) OF Command.Entry ¬ [      ["copilot", CoPilotCmd],      ["proceed", QuitLevel],      ["run top level", RunTopLevelCmd],      ["unwind", UnwindCmd]];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "break: "L];    TTY.PutLine[h, why];    Loop[h, DESCRIPTOR[BASE[entries], LENGTH[entries]], NullCatch, "break "L];    END;  Comment: PUBLIC Command.Action =    BEGIN s: STRING = [80]; TTY.GetLine[h, s] END;  Confirm: PUBLIC PROCEDURE [h: TTY.Handle] =    BEGIN    c: CHARACTER;    TTY.PutString[h, " [confirm] "L];    c ¬ ReadChar[h];    IF c = Ascii.SP OR c = Ascii.CR THEN      BEGIN TTY.PutChar[h, Ascii.CR]; RETURN END;    DO TTY.PutChar[h, '?]; c ¬ ReadChar[h] ENDLOOP    END;  FindTopLevel: PROCEDURE [h: TTY.Handle] RETURNS [TopLevelHandle] =    BEGIN    found: BOOLEAN;    top: TopLevelHandle;    [found, top] ¬ FindTopLevelEntry[@topLevelsLock, h];    IF found THEN RETURN[top];    DO Break[h, "Unknown TTY.Handle"L]; ENDLOOP;    END;          FindTopLevelEntry: ENTRY PROCEDURE[      lockPtr: LONG POINTER TO MONITORLOCK, h: TTY.Handle]      RETURNS [found: BOOLEAN, top: TopLevelHandle] =    BEGIN ENABLE UNWIND => NULL;  --releases monitorLock        HandlesMatch: ENTRY PROCEDURE[lockPtr: LONG POINTER TO MONITORLOCK]        RETURNS [BOOLEAN] = {RETURN[h = top.h]};	    MoveTopToNextLink: ENTRY PROCEDURE[lockPtr: LONG POINTER TO MONITORLOCK] =      {top ¬ top.next};          found ¬ FALSE;     top ¬ topLevels;    WHILE top # NIL DO      IF found ¬ HandlesMatch[@top.recordLock] THEN EXIT;      MoveTopToNextLink[@top.recordLock];      ENDLOOP;    END;      InstallTopLevel: PUBLIC PROCEDURE [h: TTY.Handle, entry: Command.Entry] =    BEGIN    found: BOOLEAN;    theOne: TopLevelHandle;        AddEntryIfRoom: ENTRY PROCEDURE[lockPtr: LONG POINTER TO MONITORLOCK]        RETURNS[BOOLEAN] =      BEGIN  ENABLE UNWIND => NULL; --releases monitorLock              AddEntryIfRoomWithLocks: ENTRY PROCEDURE [lockPtr: LONG POINTER TO MONITORLOCK]          RETURNS [BOOLEAN] =        BEGIN  ENABLE UNWIND => NULL;        IF theOne.used < LENGTH[theOne.options] THEN {	  theOne.options[theOne.used] ¬ entry;	  theOne.used ¬ theOne.used + 1; 	  RETURN[TRUE] }        ELSE RETURN[FALSE];	END;      RETURN[AddEntryIfRoomWithLocks[@theOne.optionsLock]];      END;                AddNewNodeToList: ENTRY PROCEDURE [lockPtr: LONG POINTER TO MONITORLOCK]  =      BEGIN ENABLE UNWIND => NULL; --releases monitorLock      theOne ¬ mz.NEW[        TopLevel ¬ [          h: h, options: DESCRIPTOR[mz.NEW[Entries], maxEntriesPerTopLevel],          used: 0, unwindLevel: 0, next: topLevels]];      topLevels ¬ theOne;      END;          [found, theOne] ¬ FindTopLevelEntry[@topLevelsLock, h];    IF ~found THEN AddNewNodeToList[@topLevelsLock];    IF ~AddEntryIfRoom[@theOne.recordLock] THEN {      TTY.PutString[h, "No room at top level to install "L];      TTY.PutString[h, entry.command] };    END;      Loop: PUBLIC PROCEDURE [    h: TTY.Handle, options: Command.Options, catch: Command.Catch,    prompt: LONG STRING] =    BEGIN    action: Command.Action;    context: Command.Context;    top: TopLevelHandle ¬ FindTopLevel[h];    unwindLevel: CARDINAL ¬ AssignUnwindLevel[@top.recordLock, top];        IncrementUnwindLevel: ENTRY PROCEDURE[lockPtr: LONG POINTER TO MONITORLOCK] =      {top.unwindLevel ¬ unwindLevel + 1};          DO      ENABLE        BEGIN        String.InvalidNumber =>          BEGIN WriteError[h, "String.InvalidNumber"L]; CONTINUE END;        TTY.LineOverflow =>          BEGIN WriteError[h, "TTY.LineOverflow"L]; CONTINUE END;        TTY.Rubout => BEGIN TTY.PutLine[h, " XXX"L]; CONTINUE END;        Aborted => BEGIN TTY.PutLine[h, " ...aborted"L]; CONTINUE END;        Quit => EXIT;        Unwind --[levelDest]-- => IF levelDest = unwindLevel THEN CONTINUE        END;      TTY.ResetUserAbort[h];      IncrementUnwindLevel[@top.recordLock];      IF ~TTY.NewLine[h] THEN TTY.PutChar[h, Ascii.CR];      TTY.PutChar[h, '>];      TTY.PutString[h, prompt];      [action, context] ¬ ScanWithOptionsLock[@top.optionsLock, h, options];      IF action # NIL THEN catch[h, action, context];      ENDLOOP    END;  LowerCase: PUBLIC PROCEDURE [char: CHARACTER] RETURNS [CHARACTER] =    BEGIN RETURN[IF char IN ['A..'Z] THEN char - 'A + 'a ELSE char] END;  NullCatch: PUBLIC Command.Catch = BEGIN action[h, context] END;  QuitLevel: PUBLIC Command.Action =    BEGIN Confirm[h]; TTY.PutChar[h, Ascii.CR]; ERROR Quit END;  ReadChar: PUBLIC PROCEDURE [h: TTY.Handle] RETURNS [c: CHARACTER] =    BEGIN IF (c ¬ TTY.GetChar[h]) = Ascii.DEL THEN ERROR TTY.Rubout END;  RemoveTopLevel: PUBLIC PROCEDURE [    h: TTY.Handle, p: PROCEDURE[Command.Entry] RETURNS [remove: BOOLEAN]] =    BEGIN    FindTopLevelAndReport: ENTRY PROCEDURE [      lockPtr: LONG POINTER TO MONITORLOCK] =      BEGIN      last: TopLevelHandle ¬ NIL;      top: TopLevelHandle ¬ topLevels;      UNTIL top = NIL DO	IF top.h = h THEN {LockThisTopLevelAndReport[top, @top.recordLock]; EXIT};	last ¬ top;	top ¬ top.next;	ENDLOOP;      END;    LockThisTopLevelAndReport: ENTRY PROCEDURE [      top: TopLevelHandle, lockPtr: LONG POINTER TO MONITORLOCK] =      BEGIN      RemoveEntries[top, @top.optionsLock];      END;    RemoveEntries: ENTRY PROCEDURE [      top: TopLevelHandle, lockPtr: LONG POINTER TO MONITORLOCK] =      BEGIN      i: CARDINAL ¬ 0;      WHILE i < top.used DO        IF p[top.options[i]].remove THEN	  BEGIN	  FOR j: CARDINAL IN [i+1..top.used) DO	    top.options[j-1] ¬ top.options[j];	    ENDLOOP;	  top.used ¬ top.used-1;	  END	ELSE i ¬ i+1;	ENDLOOP;      END;    FindTopLevelAndReport[@topLevelsLock];    END;    RunTopLevel: PUBLIC PROCEDURE [h: TTY.Handle] =    BEGIN    found: BOOLEAN;    top: TopLevelHandle;        MakeRemainingOptionsArrayNil: ENTRY PROCEDURE[        lockPtr: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;            MakeRemainingOptionsArrayNilWithLocks: ENTRY PROCEDURE           [lockPtr: LONG POINTER TO MONITORLOCK] =        BEGIN ENABLE UNWIND => NULL;	i: CARDINAL;	FOR i IN [top.used..LENGTH[top.options]) DO 	  top.options[i].command ¬ NIL;	  ENDLOOP;	END;            MakeRemainingOptionsArrayNilWithLocks[@top.optionsLock];      END;          [found, top] ¬ FindTopLevelEntry[@topLevelsLock, h];    IF ~found THEN       TTY.PutLine[h, "No such TTY.Handle is installed at top level"L]    ELSE {      MakeRemainingOptionsArrayNil[@top.recordLock];      Loop[h, top.options, NullCatch, ""]; };    END;  Scan: PUBLIC PROCEDURE [    h: TTY.Handle, options: Command.Options, catch: Command.Catch] =    BEGIN    found: BOOLEAN;    top: TopLevelHandle;    [found, top] ¬ FindTopLevelEntry[@topLevelsLock, h];    IF ~found THEN       TTY.PutLine[h, "No such TTY.Handle is installed at top level"L]    ELSE {      action: Command.Action;      context: Command.Context;      [action, context] ¬         ScanWithOptionsLock[@top.optionsLock, h, options];      IF action # NIL THEN catch[h, action, context] };    END;     ScanWithOptionsLock: ENTRY PROCEDURE [      lockPtr: LONG POINTER TO MONITORLOCK, h: TTY.Handle, options:       Command.Options]     RETURNS [Command.Action, Command.Context] =         BEGIN ENABLE UNWIND => NULL;    inline: STRING ¬ [256];    inchar: CHARACTER;    nMatches, prevMatch, maxPrefixLength, commonPrefixLength: CARDINAL;    Match: PROCEDURE [i: CARDINAL] RETURNS [BOOLEAN] =      --compares commands      BEGIN      j: CARDINAL;      FOR j IN [0..inline.length) DO        IF LowerCase[options[i].command[j]] ~= inline[j] THEN RETURN[FALSE]        ENDLOOP;      RETURN[TRUE]      END;    GetCharWithoutLock: PROCEDURE [] RETURNS [char: CHARACTER] =      BEGIN      inMonitor: BOOLEAN ¬ TRASH;      ProcessOperations.Exit[lockPtr];      inMonitor ¬ FALSE;      char ¬ ReadChar[h !        ANY =>	  BEGIN	  UNTIL inMonitor OR ProcessOperations.Enter[lockPtr] DO	    ENDLOOP;	  inMonitor ¬ TRUE;	  END];      UNTIL ProcessOperations.Enter[lockPtr] DO        ENDLOOP      END;    inline.length ¬ 0;    DO      nMatches ¬ 0;      SELECT inchar ¬ LowerCase[GetCharWithoutLock[]] FROM        '? =>          BEGIN          i, ich: CARDINAL;          firstTime: BOOLEAN ¬ TRUE;          TTY.PutString[h, "? Your options were: "L];          FOR i IN [0..LENGTH[options]) DO	    IF options[i].command = NIL THEN EXIT;            IF Match[i] THEN              BEGIN              IF ~firstTime THEN TTY.PutChar[h, '/];              FOR ich IN [inline.length..options[i].command.length) DO                TTY.PutChar[h, LowerCase[options[i].command[ich]]] ENDLOOP;              firstTime ¬ FALSE              END            ENDLOOP;          RETURN[NIL, Command.nullContext];          END;        ENDCASE =>          BEGIN          i: CARDINAL;          TTY.PutChar[h, inchar];          inline[inline.length] ¬ inchar;          inline.length ¬ inline.length + 1;          FOR i IN [0..LENGTH[options]) DO	    IF options[i].command = NIL THEN EXIT;            IF Match[i] THEN              BEGIN              IF nMatches > 0 THEN                BEGIN                maxPrefixLength ¬ MIN[                  options[i].command.length, commonPrefixLength];                FOR commonPrefixLength ¬ inline.length, commonPrefixLength + 1 DO                  IF options[i].command[commonPrefixLength] ~= options[                    prevMatch].command[commonPrefixLength]                    OR commonPrefixLength = maxPrefixLength THEN EXIT                  ENDLOOP                END              ELSE commonPrefixLength ¬ options[i].command.length;              nMatches ¬ nMatches + 1;              prevMatch ¬ i              END            ENDLOOP;          IF nMatches = 0 THEN	    {TTY.PutString[h, " ?"L]; RETURN[NIL, Command.nullContext]}          ELSE            BEGIN            ic: CARDINAL;            FOR ic IN [inline.length..commonPrefixLength) DO              TTY.PutChar[                h, inline[ic] ¬ LowerCase[options[prevMatch].command[ic]]]              ENDLOOP;            inline.length ¬ commonPrefixLength            END          END;      IF nMatches = 1 THEN EXIT      ENDLOOP;      RETURN[options[prevMatch].action, options[prevMatch].context]    END;  SetVariable: PUBLIC PROCEDURE [    h: TTY.Handle, options: LONG DESCRIPTOR FOR ARRAY OF Command.VariableDescriptor] =    BEGIN WriteError[h, " SetVariable is unimplemented"L] END;  UnwindCmd: PUBLIC Command.Action =    BEGIN    top: TopLevelHandle ¬ FindTopLevel[h];    unwindLevel: CARDINAL ¬ AssignUnwindLevel[@top.recordLock, top];    Confirm[h];    IF unwindLevel < 2 THEN WriteError[h, "at top level"L]    ELSE ERROR Unwind[unwindLevel - 2]    END;  UpperCase: PUBLIC PROC [char: CHARACTER] RETURNS [CHARACTER] =    BEGIN RETURN[IF char IN ['a..'z] THEN char - 'a + 'A ELSE char] END;  WriteBoolean: PUBLIC PROCEDURE [h: TTY.Handle, b: BOOLEAN] =    BEGIN TTY.PutString[h, IF b THEN "TRUE"L ELSE "FALSE"L] END;  WriteError: PUBLIC PROCEDURE [h: TTY.Handle, text: LONG STRING] =    BEGIN    IF ~TTY.NewLine[h] THEN TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "! "L];    TTY.PutString[h, text]    END;  WriteLongDecimal: PUBLIC PROC [h: TTY.Handle, n: LONG UNSPECIFIED] =    BEGIN    s: STRING = [40];    String.AppendLongDecimal[s, n];    TTY.PutString[h, s]    END;  END. LOGSeptember 8, 1980  11:47 AM	SXY   	Created based on TTYCommandImpl. Modified according to the change of Action and Catch defined in Command (mainly Break, InstallTopLevel and RunTopLevel).September 12, 1980  10:42 AM	SXY   	UserInput=>TTY.ResetUserAbortOctober 1, 1980  11:15 AM	PXM    	Give Break its own commands2-Sep-81 17:47:59		WDK    	Converted to Tajo 8.0a.18-Feb-83 10:43:40		EKN   	Changed so another process can install itself after RunTopLevel is already running. Procedures changed: FindTopLevel, InstallTopLevel, RunTopLevel, Scan, UnwindCmd.  Three monitors were needed to do accomplish this 1-Mar-83 18:07:59		EKN   	Added ENABLE UNWIND => NULL to ENTRY procedures so they release the lock26-Dec-84 15:56:28	AWL        	Created from version on <P> and updated to new Command interface
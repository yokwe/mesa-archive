-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- LogTestImpl.mesa   21-Apr-83 15:11:37 by JXG    DIRECTORY  Ascii USING [SP, CR],  Command,  File,  FileTypes,  Log USING [    Index, Level, nullIndex, Overflow, State, Close, Disable, GetCount, GetIndex,    GetLost, GetState, GetUpdate, Install, Open, PutBlock, PutString, PutWord,    Reset, SetState, SetOverflow, SetRestart],  LogFile,  LogInternal USING [Restart, Type],  Process USING [Detach],  Runtime USING [CallDebugger],  String USING [AppendLongNumber],  System,  TTY,  Volume;LogTestImpl: PROGRAM  IMPORTS    Command, File, LogFile, Log, Process, Runtime, String, TTY, Volume =  BEGIN  curFirstPage: File.PageNumber ¬ 1;  entrySize: CARDINAL;  file: File.File ¬ File.nullFile;  h: TTY.Handle;  logIn: BOOLEAN ¬ TRUE;  entriesLogIn: ARRAY [0..19) OF Command.Entry ¬ [    ["commands", LoopInCmd], ["changefirstpage", ChangeFirstPageCmd], [    "close", CloseCmd], ["disable", DisableCmd], ["getcount", GetCountCmd], [    "getIndex", GetIndexCmd], ["getlost", GetLostCmd], ["getstate", GetStateCmd],    ["getupdate", GetUpdateCmd], ["install", InstallCmd], ["open", OpenCmd], [    "putblock", PutBlockCmd], ["putstring", PutStringCmd], [    "putword", PutWordCmd], ["reset", ResetCmd], ["setoverflow", SetOverflowCmd],    ["setrestart", SetRestartCmd], ["setstate", SetStateCmd], [    "quit", Command.QuitLevel]];  entriesLogOut: ARRAY [0..10) OF Command.Entry ¬ [    ["commands", LoopOutCmd],    ["changefirstpage", ChangeFirstPageCmd],    ["getblock", GetBlockCmd],    ["getcount", GetCountCmd],    ["getlost", GetLostCmd],    ["getnextandattributes", GetNextandAttributesCmd],    ["getrestart", GetRestartCmd],    ["getstring", GetStringCmd],    ["reset", ResetCmd],    ["quit", Command.QuitLevel]];  -- PUBLIC PROCEDUREs  ChangeFirstPageCmd: Command.Action =    BEGIN    TTY.PutString[h, " First Page:  "];    curFirstPage ¬ TTY.GetDecimal[h];    TTY.PutCR[h];    END;  CloseCmd: Command.Action = BEGIN Command.Confirm[h]; Log.Close[]; END;  CoPilotCmd: Command.Action =    BEGIN    Command.Confirm[h];    Runtime.CallDebugger["Proceed to return to test package."L];    END;  DisableCmd: Command.Action =    BEGIN    state: Log.State;    Command.Confirm[h];    state ¬ Log.Disable[];    TTY.PutString[h, "  Logger state was "];    SELECT state FROM      = error => TTY.PutString[h, "error"];      = warning => TTY.PutString[h, "warning"];      = remark => TTY.PutString[h, "remark"];      = off => TTY.PutString[h, "off"];      ENDCASE => NULL;    TTY.PutCR[h];    END;  GetBlockCmd: Command.Action =    BEGIN    rep: CARDINAL;    current: Log.Index;    work: ARRAY [0..256) OF CARDINAL;    pWork: POINTER TO CARDINAL ¬ @work[0];    TTY.PutString[h, "  Current Index: "];    current ¬ TTY.GetDecimal[h];    LogFile.GetBlock[file, current, pWork, curFirstPage];    TTY.PutCR[h];    FOR rep IN [0..entrySize) DO      TTY.PutDecimal[h, work[rep]]; TTY.PutString[h, "  "]; ENDLOOP;    TTY.PutCR[h];    END;  GetCountCmd: Command.Action =    BEGIN    count: CARDINAL;    IF logIn THEN count ¬ Log.GetCount[]    ELSE count ¬ LogFile.GetCount[file, curFirstPage];    TTY.PutString[h, " Number of Entries is "];    TTY.PutDecimal[h, count];    TTY.PutCR[h];    END;  -- GetErrorCountsCmd: Command.Action =  -- BEGIN  -- errorCounts: Backstop.ErrorCounts;  -- counts: POINTER TO Backstop.ErrorCounts ¬ @errorCounts;  -- Log.GetErrorCounts[counts];  -- TTY.PutString[h, " Error Counts are"]; TTY.PutCR[h];  -- TTY.PutString[h, "entry:  "];  -- FOR i: Backstop.ErrorType IN Backstop.ErrorType DO  -- TTY.PutDecimal[h, counts[i].count]; TTY.PutString[h, ",  "];  -- ENDLOOP;  -- TTY.PutCR[h]; TTY.PutString[h, "lost:  "];  -- FOR i: Backstop.ErrorType IN Backstop.ErrorType DO  -- TTY.PutDecimal[h, counts[i].lost]; TTY.PutString[h, ",  "];  -- ENDLOOP;  -- TTY.PutCR[h];  -- END;  GetIndexCmd: Command.Action =    BEGIN    index: Log.Index ¬ Log.GetIndex[];    TTY.PutString[h, " index:  "];    TTY.PutDecimal[h, index];    TTY.PutCR[h];    END;  GetLostCmd: Command.Action =    BEGIN    lost: CARDINAL;    IF logIn THEN lost ¬ Log.GetLost[]    ELSE lost ¬ LogFile.GetLost[file, curFirstPage];    TTY.PutString[h, " Number of Lost Entries is "];    TTY.PutDecimal[h, lost];    TTY.PutCR[h];    END;  GetNextandAttributesCmd: Command.Action =    BEGIN    current, next: Log.Index;    type: LogInternal.Type;    level: Log.Level;    time: System.GreenwichMeanTime;    TTY.PutString[h, "  Current Index: "];    current ¬ TTY.GetDecimal[h];    next ¬ LogFile.GetNext[file, current, curFirstPage];    TTY.PutCR[h];    IF next = Log.nullIndex THEN {      TTY.PutString[h, "No next entry"]; TTY.PutCR[h]; RETURN; };    [time, type, level, entrySize] ¬ LogFile.GetAttributes[      file, next, curFirstPage];    TTY.PutString[h, "next index: "];    TTY.PutDecimal[h, next];    TTY.PutString[h, "  Greenwich Mean Time: "];    WriteGMeanTime[time];    TTY.PutString[h, "  type: "];    SELECT type FROM      = block => TTY.PutString[h, "block"];      = string => TTY.PutString[h, "string"];      ENDCASE => NULL;    TTY.PutString[h, "  entry level: "];    SELECT level FROM      = error => TTY.PutString[h, "error"];      = warning => TTY.PutString[h, "warning"];      = remark => TTY.PutString[h, "remark"];      ENDCASE => NULL;    TTY.PutString[h, "  size: "];    TTY.PutDecimal[h, entrySize];    END;  GetRestartCmd: Command.Action =    BEGIN    restart: LogInternal.Restart;    restart ¬ LogFile.GetRestart[file, curFirstPage];    TTY.PutCR[h];    TTY.PutString[h, "Restart Message: "];    TTY.PutDecimal[h, restart.message];    TTY.PutString[h, "  Greenwich Mean Time: "];    WriteGMeanTime[restart.time];    END;  GetStateCmd: Command.Action =    BEGIN    state: Log.State;    state ¬ Log.GetState[];    TTY.PutString[h, "  Logger state is "];    SELECT state FROM      = error => TTY.PutString[h, "error"];      = warning => TTY.PutString[h, "warning"];      = remark => TTY.PutString[h, "remark"];      = off => TTY.PutString[h, "off"];      ENDCASE => NULL;    END;  GetStringCmd: Command.Action =    BEGIN    rep: CARDINAL;    current: Log.Index;    work: STRING = [256];    TTY.PutString[h, "  Current Index: "];    current ¬ TTY.GetDecimal[h];    LogFile.GetString[file, current, work, curFirstPage];    TTY.PutCR[h];    FOR rep IN [0..entrySize) DO TTY.PutChar[h, work[rep]]; ENDLOOP;    TTY.PutCR[h];    END;  GetUpdateCmd: Command.Action =    BEGIN    TTY.PutString[h, "  Time of Last Update is "];    WriteGMeanTime[Log.GetUpdate[]];    END;  InstallCmd: Command.Action =    BEGIN    fileSize: File.PageCount;    type: File.Type = FileTypes.tUnassigned;    vid: Volume.ID = Volume.systemID;    Command.Confirm[h];    TTY.PutString[h, "Log File Size: "];    fileSize ¬ TTY.GetDecimal[h];    file ¬ File.Create[vid, fileSize, type];    TTY.PutString[h, "  "];    WriteFile[file];    Log.Install[file, curFirstPage];    END;  LogInTestCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    logIn ¬ TRUE;    Command.Scan[      h, DESCRIPTOR[BASE[entriesLogIn], LENGTH[entriesLogIn] - 1],      Command.NullCatch];    END;  LogOutTestCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    logIn ¬ FALSE;    Command.Scan[      h, DESCRIPTOR[BASE[entriesLogOut], LENGTH[entriesLogOut] - 1],      Command.NullCatch];    END;  LoopInCmd: Command.Action =    BEGIN    logIn ¬ TRUE;    Command.Loop[      h, DESCRIPTOR[@entriesLogIn[1], LENGTH[entriesLogIn] - 1],      Command.NullCatch, "log in test "L];    END;  LoopOutCmd: Command.Action =    BEGIN    logIn ¬ FALSE;    Command.Loop[      h, DESCRIPTOR[@entriesLogOut[1], LENGTH[entriesLogOut] - 1],      Command.NullCatch, "log enumerate test "L];    END;  OpenCmd: Command.Action =    BEGIN    Command.Confirm[h];    file ¬ ReadFile[];    Log.Open[file, curFirstPage];    END;  PutBlockCmd: Command.Action =    BEGIN    initValue, size, rep: CARDINAL;    level: Log.Level;    blockPointer: LONG POINTER TO CARDINAL ¬ @blockData[0];    blockData: ARRAY [0..512) OF CARDINAL;    TTY.PutString[h, "  Block Size: "];    size ¬ TTY.GetDecimal[h];    TTY.PutString[h, "  Initial Value: "];    initValue ¬ TTY.GetDecimal[h];    level ¬ EntryLevel[];    FOR rep IN [0..size) DO      blockData[rep] ¬ initValue; initValue ¬ initValue + 1; ENDLOOP;    Log.PutBlock[level, blockPointer, size];    END;  PutStringCmd: Command.Action =    BEGIN    level: Log.Level;    entryString: STRING = [256];    TTY.PutString[h, "  Entry String: "];    TTY.GetLine[h, entryString];    level ¬ EntryLevel[];    Log.PutString[level, entryString];    END;  PutWordCmd: Command.Action =    BEGIN    entryData: CARDINAL;    level: Log.Level;    TTY.PutString[h, "  Entry Data: "];    entryData ¬ TTY.GetDecimal[h];    level ¬ EntryLevel[];    Log.PutWord[level, entryData];    END;  ResetCmd: Command.Action =    BEGIN    Command.Confirm[h];    IF logIn THEN Log.Reset ELSE LogFile.Reset[file, curFirstPage];    END;  SetOverflowCmd: Command.Action =    BEGIN    char: CHARACTER;    option: Log.Overflow;    Command.Confirm[h];    DO      TTY.PutString[h, "Overflow State: "];      char ¬ TTY.GetChar[h];      char ¬ Command.LowerCase[char];      TTY.PutChar[h, char];      IF char # 'r AND char # 'd AND char # 'w THEN {        TTY.PutString[h, " ?"]; TTY.PutCR[h]; }      ELSE        BEGIN        SELECT char FROM          = 'r => {TTY.PutString[h, "eset"]; option ¬ reset; };          = 'd => {TTY.PutString[h, "isable"]; option ¬ disable; };          = 'w => {TTY.PutString[h, "rap"]; option ¬ wrap; };          ENDCASE => NULL;        EXIT;        END;      ENDLOOP;    Log.SetOverflow[option];    END;  SetRestartCmd: Command.Action =    BEGIN    -- char: CHARACTER;    -- restartmessage: Log.RestartMessage;    -- Command.Confirm[h];    -- DO    -- TTY.PutString[h, "Restart Message: "]; TTY.PutChar[h, 't];    -- char ¬ TTY.GetChar[h]; char ¬ Command.UpperCase[char];    -- TTY.PutChar[h, char];    -- IF char='N OR char='I OR char='Q THEN GO TO found1;    -- IF char='E THEN    -- BEGIN    -- char ¬ TTY.GetChar[h]; char ¬ Command.LowerCase[char]; TTY.PutChar[h, char];    -- IF char='m OR char='r THEN GO TO found2;    -- END;    -- TTY.PutString[h, " ?"]; TTY.PutCR[h];    -- REPEAT    -- found1 => BEGIN    -- SELECT char FROM    -- = 'N => { TTY.PutString[h, "ull"]; restartmessage ¬ RestartTypes.tNull; };    -- = 'I => { TTY.PutString[h, "nstall"]; restartmessage ¬ RestartTypes.tInstall; };    -- = 'Q => { TTY.PutString[h, "uit"]; restartmessage ¬ RestartTypes.tQuit; };    -- ENDCASE => NULL;    -- END;    -- found2 => BEGIN    -- SELECT char FROM    -- = 'm => { TTY.PutString[h, "pty"]; restartmessage ¬ RestartTypes.tEmpty; };    -- = 'r => { TTY.PutString[h, "ror"]; restartmessage ¬ RestartTypes.tError; };    -- ENDCASE => NULL;    -- END;    -- ENDLOOP;    TTY.PutString[h, " Restart Message:  "];    Log.SetRestart[TTY.GetDecimal[h]];    END;  SetStateCmd: Command.Action =    BEGIN    char: CHARACTER;    logState: Log.State;    Command.Confirm[h];    DO      TTY.PutString[h, "Logger State: "];      char ¬ TTY.GetChar[h];      char ¬ Command.LowerCase[char];      TTY.PutChar[h, char];      IF char # 'o AND char # 'e AND char # 'w AND char # 'r THEN {        TTY.PutString[h, " ?"]; TTY.PutCR[h]}      ELSE        BEGIN        SELECT char FROM          = 'o => {TTY.PutString[h, "ff"]; logState ¬ off; };          = 'e => {TTY.PutString[h, "rror"]; logState ¬ error; };          = 'w => {TTY.PutString[h, "arning"]; logState ¬ warning; };          = 'r => {TTY.PutString[h, "emark"]; logState ¬ remark; };          ENDCASE => NULL;        EXIT;        END;      ENDLOOP;    Log.SetState[logState];    END;  -- PRIVATE PROCEDUREs  EntryLevel: PROCEDURE RETURNS [level: Log.Level] =    BEGIN    levelChar: CHARACTER;    DO      TTY.PutString[h, "  Logging Level: "];      levelChar ¬ TTY.GetChar[h];      levelChar ¬ Command.LowerCase[levelChar];      TTY.PutChar[h, levelChar];      IF levelChar # 'e AND levelChar # 'w AND levelChar # 'r THEN {        TTY.PutString[h, " ?"]; TTY.PutCR[h]; }      ELSE        BEGIN        SELECT levelChar FROM          = 'e => {TTY.PutString[h, "rror"]; level ¬ error; };          = 'w => {TTY.PutString[h, "arning"]; level ¬ warning; };          = 'r => {TTY.PutString[h, "emark"]; level ¬ remark; };          ENDCASE => NULL;        EXIT;        END;      ENDLOOP;    END;  sizeFile: CARDINAL = SIZE[File.File];  RepFile: TYPE = RECORD [ARRAY [0..sizeFile) OF CARDINAL];  ReadFile: PROCEDURE RETURNS [newfile: File.File] =    BEGIN    rep: RepFile;    i: CARDINAL;    rep ¬ LOOPHOLE[file];    TTY.PutString[h, "File and volume ID: "L];    TTY.PutChar[h, '[];    FOR i IN [0..sizeFile) DO      rep[i] ¬ TTY.GetNumber[h: h, default: rep[i], radix: 8];      IF i # sizeFile - 1 THEN TTY.PutChar[h, ',]      ENDLOOP;    TTY.PutChar[h, ']];    newfile ¬ LOOPHOLE[rep];    END;  WriteFile: PROCEDURE [file: File.File] =    BEGIN    rep: RepFile ¬ LOOPHOLE[file];    TTY.PutString[h, "File ["];    FOR i: [0..sizeFile) IN [0..sizeFile) DO      TTY.PutOctal[h, rep[i]];      IF i # sizeFile - 1 THEN TTY.PutChar[h, ',];      ENDLOOP;    TTY.PutChar[h, ']];    END;  WriteGMeanTime: PROCEDURE [time: System.GreenwichMeanTime] =    BEGIN    stime: STRING = [20];    String.AppendLongNumber[s: stime, n: time, radix: 8];    TTY.PutString[h, stime];    END;  RunTopLevel: PROCEDURE =    BEGIN    Command.RunTopLevel[      h !      ABORTED => {        Command.WriteError[h, "Process Aborted"L]; ERROR Command.Aborted}];    TTY.Destroy[h];    END;  -- MAINLINE PROGRAM  h ¬ TTY.Create[name: "LogTests"L];  TTY.PutString[h, "Logger Tests of October 17, 1980"L];  Command.InstallTopLevel[h, ["log in test", LogInTestCmd]];  Command.InstallTopLevel[h, ["log enumerate test", LogOutTestCmd]];  Command.InstallTopLevel[h, ["copilot", CoPilotCmd]];  Command.InstallTopLevel[h, ["--", Command.Comment]];  Command.InstallTopLevel[h, ["quit", Command.QuitLevel]];  Command.InstallTopLevel[h, ["unwind", Command.UnwindCmd]];  Process.Detach[FORK RunTopLevel];  END.LOGOctober 17, 1980  12:25 PM   SXY      Created fileNovember 10, 1980  4:41 PM   SXY      Added GetErrorCountsCmd and ChangeErrorTypeCmdNovember 11, 1980  9:39 AM   SXY      Added a returned value ErrorType to GetNextCmdNovember 18, 1980  3:39 PM   SXY      Removed GetErrorCountsCmd, ChangeErrorTypeCmd & GetRestartCmd from log in commands, removed SetRestartCmd from & added GetBackstopVolumeCmd to log enumerate commandsNovember 26, 1980  3:17 PM   SXY      Added GetIndexCmd and ChangeFirstPageCmd, modification according to Restart changeNovember 26, 1980  5:34 PM   SXY      GetNextCmd is changed to GetNextandAttributesCmd calling GetyNext and GetAttributes4-Sep-81 11:20:08   SXY      GetBackstopVolumeCmd => GetBackstopFileCmd.10-Sep-81 14:51:52   WDK       GetBackstopLogFile is obsolete.21-Apr-83 15:21:43  JXG        upgraded to Klamath - removed references to capabilities
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- BcdOpsImpl.mesa      23-Aug-83 10:50:34 by WDK     DIRECTORY  BcdDefs USING [    Base, CTIndex, CTNull, CTRecord, EXPIndex,    EXPNull, EXPRecord, FPIndex, FPNull, FPRecord, FTIndex, FTNull,    FTRecord, IMPIndex, IMPNull, IMPRecord, Link, MTIndex, MTNull, MTRecord,    Namee, NameRecord, NTIndex, NTNull, NTRecord, NullName, SGIndex,    SGNull, SGRecord, SpaceID, SPIndex, SPNull, SPRecord, TMIndex,    TMNull, TMRecord],  BcdOps USING [    BcdBase, CTHandle, EXPHandle, FPHandle, FTHandle, IMPHandle,    MTHandle, NTHandle, SGHandle, SPHandle, TMHandle],  BcdOpsExtras USING [SGBaseFromBcd, SPBaseFromBcd],  Table USING [Base];BcdOpsImpl: PROGRAM IMPORTS BcdOpsExtras EXPORTS BcdOps, BcdOpsExtras =  BEGIN OPEN BcdOps, BcdDefs;  FindName: PUBLIC PROC [bcd: BcdBase, owner: Namee] RETURNS [name: NameRecord] =    BEGIN    FindOwner: PROC [nth: NTHandle, nti: NTIndex] RETURNS [BOOLEAN] = {      RETURN[owner = nth.item]};    n: NTHandle ¬ ProcessNames[bcd, FindOwner].nth;    RETURN[IF n = NIL THEN NullName ELSE n.name];    END;  ProcessConfigs: PUBLIC PROC [      bcd: BcdBase, proc: PROC [CTHandle, CTIndex] RETURNS [BOOLEAN]]      RETURNS [cth: CTHandle, cti: CTIndex] = {    ctb: Base = LOOPHOLE[bcd + bcd.ctOffset];    cti ¬ FIRST[CTIndex];    FOR i: CARDINAL IN [0..bcd.nConfigs) DO      cth ¬ @ctb[cti];      IF proc[cth, cti] THEN RETURN;      cti ¬ cti + SIZE[CTRecord] + cth.nControls*SIZE[Namee];      ENDLOOP;    RETURN[NIL, CTNull]};  ProcessExports: PUBLIC PROC [      bcd: BcdBase, proc: PROC [EXPHandle, EXPIndex] RETURNS [BOOLEAN]]      RETURNS [eth: EXPHandle, eti: EXPIndex] = {    etb: Base = LOOPHOLE[bcd + bcd.expOffset];    eti ¬ FIRST[EXPIndex];    FOR i: CARDINAL IN [0..bcd.nExports) DO      eth ¬ @etb[eti];      IF proc[eth, eti] THEN RETURN;      eti ¬ eti + SIZE[EXPRecord] + eth.size*SIZE[BcdDefs.Link];      ENDLOOP;    RETURN[NIL, EXPNull]};  ProcessFiles: PUBLIC PROC [      bcd: BcdBase, proc: PROC [FTHandle, FTIndex] RETURNS [BOOLEAN]]      RETURNS [fth: FTHandle, fti: FTIndex] = {    ftb: Base = LOOPHOLE[bcd + bcd.ftOffset];    FOR fti ¬ FIRST[FTIndex], fti + SIZE[FTRecord] UNTIL fti = bcd.ftLimit DO      fth ¬ @ftb[fti]; IF proc[fth, fti] THEN RETURN; ENDLOOP;    RETURN[NIL, FTNull]};  ProcessFrames: PUBLIC PROC [      bcd: BcdBase, proc: PROC [FPHandle, FPIndex] RETURNS [BOOLEAN]]      RETURNS [fph: FPHandle, fpi: FPIndex] = {    fpb: Base = LOOPHOLE[bcd + bcd.fpOffset];    FOR fpi ¬ FIRST[FPIndex], fpi + SIZE[FPRecord] + fph.length*SIZE[MTIndex]    UNTIL fpi = bcd.fpLimit DO      fph ¬ @fpb[fpi]; IF proc[fph, fpi] THEN RETURN; ENDLOOP;    RETURN[NIL, FPNull]};  ProcessImports: PUBLIC PROC [      bcd: BcdBase, proc: PROC [IMPHandle, IMPIndex] RETURNS [BOOLEAN]]      RETURNS [ith: IMPHandle, iti: IMPIndex] = {    itb: Base = LOOPHOLE[bcd + bcd.impOffset];    iti ¬ FIRST[IMPIndex];    FOR i: CARDINAL IN [0..bcd.nImports) DO      ith ¬ @itb[iti];      IF proc[ith, iti] THEN RETURN;      iti ¬ iti + SIZE[IMPRecord];      ENDLOOP;    RETURN[NIL, IMPNull]};  ProcessModules: PUBLIC PROC [      bcd: BcdBase, proc: PROC [MTHandle, MTIndex] RETURNS [BOOLEAN]]      RETURNS [mth: MTHandle, mti: MTIndex] = {    mtb: Base = LOOPHOLE[bcd + bcd.mtOffset];    FOR mti ¬ FIRST[MTIndex], mti + SIZE[MTRecord] UNTIL mti = bcd.mtLimit DO      mth ¬ @mtb[mti]; IF proc[mth, mti] THEN RETURN; ENDLOOP;    RETURN[NIL, MTNull]};  ProcessNames: PUBLIC PROC [      bcd: BcdBase, proc: PROC [NTHandle, NTIndex] RETURNS [BOOLEAN]]      RETURNS [nth: NTHandle, nti: NTIndex] = {    ntb: Base = LOOPHOLE[bcd + bcd.ntOffset];    FOR nti ¬ FIRST[NTIndex], nti + SIZE[NTRecord] UNTIL nti = bcd.ntLimit DO      nth ¬ @ntb[nti]; IF proc[nth, nti] THEN RETURN; ENDLOOP;    RETURN[NIL, NTNull]};  ProcessSegs: PUBLIC PROC [      bcd: BcdBase, proc: PROC [SGHandle, SGIndex] RETURNS [BOOLEAN]]      RETURNS [sgh: SGHandle, sgi: SGIndex] = {    sgb: Base = LOOPHOLE[bcd + bcd.sgOffset];    FOR sgi ¬ FIRST[SGIndex], sgi + SIZE[SGRecord] UNTIL sgi = bcd.sgLimit DO      sgh ¬ @sgb[sgi]; IF proc[sgh, sgi] THEN RETURN; ENDLOOP;    RETURN[NIL, SGNull]};  ProcessSpaces: PUBLIC PROC [      bcd: BcdBase, proc: PROC [SPHandle, SPIndex] RETURNS [BOOLEAN]]      RETURNS [sph: SPHandle, spi: SPIndex] = {    spb: Base = LOOPHOLE[bcd + bcd.spOffset];    FOR spi ¬ FIRST[SPIndex], spi + SIZE[SPRecord] + sph.length*SIZE[SpaceID]      UNTIL spi = bcd.spLimit DO      sph ¬ @spb[spi]; IF proc[sph, spi] THEN RETURN; ENDLOOP;    RETURN[NIL, SPNull]};  ProcessTypeMap: PUBLIC PROC [      bcd: BcdBase, proc: PROC [TMHandle, TMIndex] RETURNS [BOOLEAN]]      RETURNS [tmh: TMHandle, tmi: TMIndex] = {    tymb: Base = LOOPHOLE[bcd + bcd.tmOffset];    FOR tmi ¬ FIRST[TMIndex], tmi + SIZE[TMRecord] UNTIL tmi = bcd.tmLimit DO      tmh ¬ @tymb[tmi]; IF proc[tmh, tmi] THEN RETURN; ENDLOOP;    RETURN[NIL, TMNull]};  SPHandleFromSGHandle: PUBLIC --BddOpsExtras.-- PROCEDURE [    bcd: BcdOps.BcdBase, sgh: BcdOps.SGHandle]    RETURNS [sph: BcdOps.SPHandle] =    BEGIN    sgb: Table.Base = BcdOpsExtras.SGBaseFromBcd[bcd];    spb: Table.Base = BcdOpsExtras.SPBaseFromBcd[bcd];    FOR spi: BcdDefs.SPIndex ¬ FIRST[BcdDefs.SPIndex],      spi + SIZE[BcdDefs.SPRecord] + sph.length*SIZE[BcdDefs.SpaceID]      UNTIL spi = bcd.spLimit DO      sph ¬ @spb[spi];      IF @sgb[sph.seg] = sgh THEN RETURN[sph];      ENDLOOP;    RETURN[NIL];    END;  END.LOGJul 17, 80 11:55 AM  JGS    	?16-Oct-81 15:34:35   BTL  	? 8-Jul-83 12:17:47   BJD    	?23-Aug-83 10:51:05   WDK        Added (BcdOpsExtras.)SPHandleFromSGHandle. Alphabetized.
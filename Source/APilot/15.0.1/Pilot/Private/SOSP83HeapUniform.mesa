-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- SOSP83HeapUniform.mesa    17-Jul-87 17:33:24 by RSV    DIRECTORY  Environment USING [PageCount, wordsPerPage],  File USING [Delete, File, Unknown],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Error, ErrorType, NWords],  HeapExtras USING [],  PrincOpsExtras2 USING [GFTHandle],  Runtime USING [GetCaller],  SOSP83HeapInternal USING [    Block, BlockObject, Data, Handle, OwnerObject, maxSegmentPages, Procs,    UncountedZoneObject, UncountedZoneRep, UniformHandle, UniformNode,    UniformNodeObject],  SOSP83HeapOps USING [Bug, MakeSpace],  Space USING [    defaultSwapUnitSize, Error, GetMapUnitAttributes, InsufficientSpace,    Interval, PageCount, PagesFromWords, SwapUnitSize, Unmap, virtualMemory],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  System USING [VolumeID],  Volume USING [systemID];SOSP83HeapUniform: MONITOR LOCKS h.lock USING h: SOSP83HeapInternal.Handle  IMPORTS     File, FrameExtras, Heap, SOSP83HeapOps, Runtime, Space,    SpecialRuntimeExtras, Volume  EXPORTS Heap, HeapExtras, SOSP83HeapOps =  BEGIN OPEN SOSP83HeapInternal;  --  -- Types  NWords: TYPE = Heap.NWords;  --  -- Constants  wpp: CARDINAL = Environment.wordsPerPage;  defaultSwapUnit: Space.SwapUnitSize = Space.defaultSwapUnitSize;  uniformProcs: Procs ¬ [Make: MakeUniformNode, Free: FreeUniformNode];  ownerNameSize: CARDINAL = SIZE[PrincOpsExtras2.GFTHandle];  -- Uniform Heap implementation    CreateUniform: PUBLIC --Heap-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, objectSize: NWords,    ownerChecking, checking: BOOLEAN] RETURNS [UNCOUNTED ZONE] =    BEGIN    RETURN[NewCreateUniform[initial: initial, maxSize: maxSize,       increment: increment, swapUnitSize: swapUnitSize, objectSize: objectSize,      ownerChecking: ownerChecking, checking: checking,      volumeID: Volume.systemID]];    END;  NewCreateUniform: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, objectSize: NWords,    ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID]    RETURNS [UNCOUNTED ZONE] =    BEGIN    MyMake: PROCEDURE [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] = {      RETURN[seg]};    uzo: UncountedZoneObject ¬ [@myProcs, NIL];    myProcs: Procs ¬ [Make: MyMake, Free: NULL];    myZone: UNCOUNTED ZONE ¬ LOOPHOLE[LONG[@uzo]];    h: UniformHandle;    seg: LONG ORDERED POINTER;    length: CARDINAL;    block: Block;    extra: Space.PageCount;    IF initial = 0 THEN initial ¬ 1;  -- since not yet ready to extend    IF maxSize < initial THEN ERROR Heap.Error[maxSizeExceeded];    IF initial > maxSegmentPages THEN       {extra ¬ initial - maxSegmentPages; initial ¬ maxSegmentPages}    ELSE extra ¬ 0;    increment ¬ MIN[increment, maxSegmentPages];    seg ¬ SOSP83HeapOps.MakeSpace[      parent: Space.virtualMemory, pages: initial, swapUnitSize: swapUnitSize,      resident: FALSE, volumeID: volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    length ¬ CARDINAL[initial*wpp] - SIZE[uniform Data] - SIZE[BlockObject];    block ¬ seg + SIZE[uniform Data];    block^ ¬ [next: NIL, length: length, initial: TRUE];    h ¬ myZone.NEW[uniform Data ¬ [      ownerChecking: ownerChecking, checking: checking, maxSize: maxSize,      currentSize: initial, increment: increment, swapUnit: swapUnitSize,      volumeID: volumeID,      v1: uniform[blocks: block, free: NIL, objectSize: objectSize,        uzo: [procs: @uniformProcs, data: NULL]]]];    h.uzo.data ¬ h;     InitializeUniformBlock[h, block];    WHILE extra # 0 DO      pages: Space.PageCount;      IF extra > maxSegmentPages THEN         {extra ¬ extra - maxSegmentPages; pages ¬ maxSegmentPages}      ELSE {pages ¬ extra; extra ¬ 0};      ExpandUniformHeapInternal[h, pages, TRUE];      ENDLOOP;    RETURN[LOOPHOLE[@h.uzo]]    EXITS InsufficientSpace => ERROR Heap.Error[insufficientSpace]    END;  MakeUniformNode: PUBLIC --SOSP83HeapOps-- PROCEDURE [    z: UNCOUNTED ZONE, n: NWords] RETURNS [p: LONG POINTER] =    BEGIN OPEN uzr: LOOPHOLE[z, UncountedZoneRep];    p ¬ MakeUniformNodeEntry[LOOPHOLE[uzr.data], n];    IF uzr.data.ownerChecking THEN      BEGIN      p^ ¬ FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]];      p ¬ p + ownerNameSize;      END;    END;  FreeUniformNode: PUBLIC --SOSP83HeapOps-- PROCEDURE [    z: UNCOUNTED ZONE, p: LONG POINTER] =    BEGIN OPEN uzr: LOOPHOLE[z, UncountedZoneRep];    IF p = NIL THEN RETURN;    FreeUniformNodeEntry[LOOPHOLE[uzr.data], LOOPHOLE[p]];    END;  MakeUniformNodeEntry: ENTRY PROCEDURE [h: UniformHandle, n: NWords]    RETURNS [p: UniformNode] =    BEGIN    savedType: Heap.ErrorType;      BEGIN ENABLE        BEGIN        Heap.Error => {savedType ¬ type; GOTO Error};        UNWIND => NULL;	END;      IF h.objectSize < n THEN RETURN WITH ERROR Heap.Error[invalidParameters];      IF h.free = NIL THEN ExpandUniformHeapInternal[h, h.increment, FALSE];      p ¬ h.free;      h.free ¬ p.next;      EXITS        Error => RETURN WITH ERROR Heap.Error[savedType];      END;    END;  FreeUniformNodeEntry: ENTRY PROCEDURE [h: UniformHandle, p: UniformNode] =    BEGIN    ENABLE UNWIND => NULL;    IF h.ownerChecking THEN p ¬ p - ownerNameSize;    IF h.checking THEN {      objectSize: CARDINAL ¬ AllocatedObjectSize[h];      base: UniformNode;      FOR block: Block ¬ h.blocks, block.next DO        IF block = NIL THEN RETURN WITH ERROR Heap.Error[invalidNode];	base ¬ LOOPHOLE[block, UniformNode] + SIZE[BlockObject];	IF p IN [base..base + block.length) THEN	  IF (p-base) MOD objectSize # 0 THEN RETURN WITH ERROR Heap.Error[invalidNode]          ELSE EXIT;	ENDLOOP};    p.next ¬ h.free;    h.free ¬ p;    END;  AllocatedObjectSize: PROCEDURE [h: UniformHandle]     RETURNS [objectSize: CARDINAL] = {    objectSize ¬ h.objectSize;    IF h.ownerChecking THEN objectSize ¬ objectSize + OwnerObject.SIZE;    objectSize ¬ MAX[SIZE[UniformNodeObject], objectSize]};  ExpandUniformHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    h: UniformHandle, pages: Space.PageCount] =    BEGIN    savedType: Heap.ErrorType;    WHILE pages # 0 DO ENABLE        BEGIN        Heap.Error => {savedType ¬ type; GOTO Error};	UNWIND => NULL;	END;      n: CARDINAL ¬ CARDINAL[MIN[pages, maxSegmentPages]];      ExpandUniformHeapInternal[h, n, FALSE];      pages ¬ pages - n;      REPEAT        Error => RETURN WITH ERROR Heap.Error[savedType];      ENDLOOP;    END;  ExpandUniformHeapInternal: PROCEDURE [    h: UniformHandle, pages: Space.PageCount, initial: BOOLEAN] =    BEGIN    block: Block;    oldSize: Space.PageCount = h.currentSize;    objectSize: CARDINAL ¬ AllocatedObjectSize[h];    IF ~initial THEN pages ¬ MAX[pages, h.increment];    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Heap.Error[maxSizeExceeded];      END;    block ¬ SOSP83HeapOps.MakeSpace[      parent: Space.virtualMemory, pages: pages,      swapUnitSize: Space.SwapUnitSize[h.swapUnit],      resident: h.resident, volumeID: h.volumeID !         Space.InsufficientSpace => GOTO InsufficientSpace];    block^ ¬ [      next: h.blocks.next, length: CARDINAL[pages*wpp]-SIZE[BlockObject],      initial: initial];    h.blocks.next ¬ block;    InitializeUniformBlock[h, block];    EXITS InsufficientSpace => RETURN WITH ERROR Heap.Error[insufficientSpace];    END;  FlushUniformHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [h: UniformHandle] =     BEGIN ENABLE UNWIND => NULL;    hasSwapUnits: BOOLEAN = h.swapUnit ~= defaultSwapUnit;    block, next, prev: Block;    prev ¬ NIL;    h.currentSize ¬ 0;    h.free ¬ NIL;    FOR block ¬ h.blocks, next UNTIL block = NIL DO      next ¬ block.next;      IF block.initial THEN        BEGIN        InitializeUniformBlock[h, block];	h.currentSize ¬ h.currentSize + Space.PagesFromWords[block.length];	prev ¬ block	END      ELSE        BEGIN        IF prev = NIL THEN h.blocks ¬ next ELSE prev.next ¬ next;	IF h.volumeID # Volume.systemID THEN	  BEGIN	  tempFileID: File.File = Space.GetMapUnitAttributes[block].window.file;	  [] ¬ Space.Unmap[block !	    Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	  File.Delete[tempFileID ! 	    File.Unknown => SOSP83HeapOps.Bug[fileWeCreatedWentAway]];	  END	ELSE	  [] ¬ Space.Unmap[block !	    Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	END;      ENDLOOP;    END;  InitializeUniformBlock: PROCEDURE [h: UniformHandle, block: Block] = {    lastNode, p, last: UniformNode;    objectSize: CARDINAL ¬ AllocatedObjectSize[h];    p ¬ LOOPHOLE[block, UniformNode] + SIZE[BlockObject];    lastNode ¬ p + block.length - objectSize;    p.next ¬ h.free;    DO      p ¬ (last ¬ p) + objectSize;      IF p > lastNode THEN EXIT;      p.next ¬ last;      ENDLOOP;    h.free ¬ last};      IsUniformEmpty: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [h: UniformHandle]    RETURNS [BOOLEAN] =    BEGIN    freePtr: UniformNode;    segmentPtr: Block;    objectSize: CARDINAL = AllocatedObjectSize[h];    availableNodes: LONG CARDINAL ¬ h.blocks.length/objectSize;  -- # nodes in initial segment.    freeNodes: LONG CARDINAL ¬ 0;        -- How many free nodes are there?    FOR freePtr ¬ h.free, freePtr.next UNTIL freePtr = NIL DO      freeNodes ¬ freeNodes + 1;      ENDLOOP;    -- How many nodes total are available?    FOR segmentPtr ¬ h.blocks.next, segmentPtr.next UNTIL segmentPtr = NIL DO      availableNodes ¬ availableNodes + segmentPtr.length/objectSize;      ENDLOOP;    -- Are all available nodes on the free list??!    IF freeNodes # availableNodes THEN RETURN[FALSE]    ELSE RETURN[TRUE];    END;      END...LOG31-Jan-84  9:00:27 XXJ Created file.27-Jun-86 18:18:44 RSV Added log, changed _ to ¬, fixed CreateUniform to set increment properly, fixed ExpandUniform to loop when pages requested > maxSegmentPages, changed names to SOSP83*, added IsUniformEmpty procedure, and changed ExpandUniformHeapInternal to reset currentSize to oldSize when maxSizeExceeded is raised.18-Mar-87 14:44:29 RSV Can't just use PrincOps.GlobalFrameHandle.  Must use PrincOpsExtras2.GFTHandle.30-Jun-87 11:36:25 RSV Modified to allow specifying volume from which backing store is allocated.17-Jul-87 17:33:24 RSV Fix AR 10856 on oldSize being set wrong in ExpandUniformHeapInternal.
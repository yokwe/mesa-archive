-- Copyright (C) 1984, 1986, 1987, 1989  by Xerox Corporation. All rights reserved. -- VMMgr>MapLogImpl.mesa   17-Jan-89 17:59:39 by RSV      -- THINGS TO DO--  We currently only support maplogging to the DiskBackingStore. We need to be--    able to extend this. Probably each BackingStore, Foo, should provide a--    procedure called MakeFooBackingStoreMapLogEntry which can be called from--    here to make an entry for the log.DIRECTORY  BackingStore USING [Data, TransferProc],  CPSwapDefs USING [PESV],  DiskBackingStore USING [    Data, GetDiskChannel, PDiskDataFromPBSData, Transfer],  DiskChannel USING [GetDrive, GetDriveTag],  Environment USING [    Base, first64K, PageCount,    PageFromLongPointer, PageNumber, PageOffset, wordsPerPage],  Inline USING [LongCOPY, LongCOPYReverse],  MapLog USING [],  Pinning USING [CreatePinHandle, Pin, PinHandle, Unpin],  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  ResidentHeap USING [MakeNode],  Space USING [Access, Interval, Kill],  SpacePerfExtras USING [],  SpecialSpace USING [    MakeGlobalFrameResident, MakeGlobalFrameSwappable, SpecialError],  VM USING [    Activate, BackingStoreRuns, Deactivate, Interval, PageCount, PageOffset],  VMMapLog USING [currentVersion, Descriptor, Entry, EntryBasePointer,    EntryPointer, Log, LogDesc],  VMMapLogInternal USING [Entry, PageCount],  VMMPrograms USING [],  Zone USING [Status];MapLogImpl: MONITOR  IMPORTS    CPSwapDefs, DiskBackingStore, DiskChannel, Environment, Inline, Pinning,    ProcessOperations, ResidentHeap, SpecialSpace, Space, VM  EXPORTS MapLog, SpacePerfExtras, VMMPrograms =  BEGIN  -- PARAMETERS:    threshold: CARDINAL = wordsPerPage - 2*SIZE[Entry];  -- TYPEs and Constants:    Entry: PUBLIC --VMMapLog-- TYPE = VMMapLogInternal.Entry;  mySizeIsSeven: BOOLEAN[TRUE..TRUE] = (Entry.SIZE = 7);  hisSizeIsSeven: BOOLEAN[TRUE..TRUE] = (VMMapLog.Entry.SIZE = 7);  EntryBasePointer: TYPE = LONG BASE POINTER TO ARRAY [0..0) OF Entry;  EntryPointer: TYPE = EntryBasePointer RELATIVE POINTER [0..177777B] TO Entry;  EntryCount: TYPE = VMMapLogInternal.PageCount;  wordsPerPage: CARDINAL = Environment.wordsPerPage;    PEntries: TYPE =  -- for debugger    LONG POINTER TO ARRAY [0..2000--say--) OF VMMapLogInternal.Entry;  StatePointer: TYPE = LONG POINTER TO LogState;      LogState: TYPE = RECORD[    mapLogCount: Environment.PageCount,  -- code ASSUMES both logs EQUAL!    mapLogDesc: LONG POINTER TO VMMapLog.Descriptor,    base: EntryBasePointer,    emptySpots: CARDINAL ¬ 0,  -- # of deleted spots in current log page    pageLog: Environment.PageNumber -- page that base points to.    ];  -- GLOBAL VARs:  howManyMLs: CARDINAL ¬ 0;  mapLogSize: PUBLIC --SpacePerfExtras-- CARDINAL ¬ 0;  -- interesting statistic  mapLogging: PUBLIC BOOLEAN ¬ TRUE;  infoOneLog, infoAnotherLog: StatePointer;  oneIsCurrent: BOOLEAN;  -- used to synchronize access to two MapLogs.  mLPin: Pinning.PinHandle; -- UpdateESV procedure handle      -- ERRORs:    Bug: PRIVATE --PROGRAMMING-- ERROR [type: BugType] = CODE;  BugType: TYPE = {duplicateOrOverlappingMapEntry, mapLogFull,    mapLogItselfTooLong, notInRuns, troubleAllocating, unknownBackingStorage};  -- PROCEDUREs:    ConcreteLPEntry: PROC [e: LONG POINTER TO VMMapLog.Entry]    RETURNS [LONG POINTER TO VMMapLogInternal.Entry] =    INLINE {RETURN[LOOPHOLE[e]]};  ConcreteRPEntry: PROC [e: VMMapLog.EntryPointer]    RETURNS [EntryPointer] =    INLINE {RETURN[LOOPHOLE[e]]};  InitializeMapLog: PUBLIC --VMMPrograms-- PROCEDURE [    mapLog: Space.Interval, runs: VM.BackingStoreRuns] =    BEGIN    OPEN logState: IF oneIsCurrent THEN infoOneLog ELSE infoAnotherLog;    countDone: Environment.PageCount;    IF mapLog.count = 0 THEN mapLogging ¬ FALSE;    IF NOT mapLogging THEN RETURN;        -- Copy parms to LogState:    logState.base ¬ mapLog.pointer;    logState.pageLog ¬ Environment.PageFromLongPointer[logState.base];    logState.mapLogCount ¬ mapLog.count;        IF mapLog.count*wordsPerPage > LOOPHOLE[EntryPointer.LAST, CARDINAL] THEN      ERROR Bug[mapLogItselfTooLong];    logState.mapLogDesc.limit ¬      LOOPHOLE[(CARDINAL[mapLog.count*wordsPerPage]/SIZE[Entry])*SIZE[Entry]];    -- We don't care if the entry we construct in mapLogDesc.self does    -- not cover the whole maplog. It only has to be enough to locate    -- the first page of the maplog. In the first page of the maplog,    -- we log the info about the rest of the maplog (see below).    countDone ¬ MakeDiskBackingStoreEntryENTRY[      pEntry: ConcreteLPEntry[@logState.mapLogDesc.self], interval: [logState.pageLog, mapLog.count],      access: readWrite, runs: runs, runsBasePage: logState.pageLog];        IF countDone < mapLog.count THEN      WriteLog1[  -- log the remainder of the log        interval: [logState.pageLog+countDone, mapLog.count-countDone], access: readWrite,        transferProc: DiskBackingStore.Transfer,	runs: DESCRIPTOR[@runs[1], LENGTH[runs]-1]];	    IF oneIsCurrent THEN     CPSwapDefs.PESV[].mapLog ¬ logState.mapLogDesc;   -- tell debugger where it is.    oneIsCurrent ¬ ~oneIsCurrent;  -- after both logs are initialized oneIsCurrent=TRUE.    END;  --InitializeMapLog--  MakeDiskBackingStoreEntryENTRY: ENTRY PROCEDURE [    pEntry: LONG POINTER TO Entry, interval: VM.Interval, access: Space.Access,    runs: VM.BackingStoreRuns, runsBasePage: Environment.PageNumber]    RETURNS [countDone: Environment.PageCount] = INLINE {    -- Used by InitializeMapLog only.    ENABLE UNWIND => NULL;    RETURN MakeDiskBackingStoreEntry[      pEntry, interval, access, runs, runsBasePage]};  MakeDiskBackingStoreEntry: INTERNAL PROCEDURE [    pEntry: LONG POINTER TO Entry, interval: VM.Interval, access: Space.Access,    runs: VM.BackingStoreRuns, runsBasePage: Environment.PageNumber]    RETURNS [countDone: Environment.PageCount] =    -- Fills pEntry­ with info about as much of the interval as possible,    -- and returns the number of pages that were handled.    -- interval can occur anywhere within runs.    BEGIN    runPage: Environment.PageNumber;  -- start page of relevant BackingStore.Data.    offsetInCurrRun: VM.PageOffset;    ri: CARDINAL;  -- index of run used.    runCount: Environment.PageCount;    entryCount: EntryCount;    dbsData: LONG POINTER TO DiskBackingStore.Data;        runPage ¬ runsBasePage;    offsetInCurrRun ¬ interval.page - runsBasePage; -- usually = 0    FOR ri IN [0..runs.LENGTH) DO      runCount ¬ runs[ri].count;      IF--UNTIL-- runCount > offsetInCurrRun THEN EXIT;      offsetInCurrRun ¬ offsetInCurrRun - runCount;      runPage ¬ runPage + runCount;      REPEAT        FINISHED => ERROR Bug[notInRuns];      ENDLOOP;    entryCount ¬ EntryCount[MIN[      EntryCount.LAST.LONG, interval.count, runCount - offsetInCurrRun]];    -- [MIN[maximum log size, actual mapLog.count passed to Initialize, number of pages in first run OR ]    dbsData ¬ DiskBackingStore.PDiskDataFromPBSData[@runs[ri].data];    pEntry­ ¬ [      page: interval.page, count: entryCount, writeProtected: (access = readOnly),      fill: TRASH,      backingStorage: disk[      driveTag: DiskChannel.GetDriveTag[        DiskChannel.GetDrive[          DiskBackingStore.GetDiskChannel[dbsData.channelHandle]]],      diskPage: dbsData.volumePage + offsetInCurrRun]];    RETURN[countDone: entryCount];    END;  --MakeDiskBackingStoreEntry--  WriteLog1: PUBLIC ENTRY PROCEDURE [    interval: VM.Interval, access: Space.Access,    transferProc: BackingStore.TransferProc, runs: VM.BackingStoreRuns] =    -- If transferProc=NIL then interval is being unmapped.    -- Writes one or more log entries.    -- Optimizes use of the the current page of the log by trying to match unmaps    --   with corresponding maps creating unused entries, and by filling    --   these holes with new map entries.    BEGIN ENABLE UNWIND => NULL;    logState: StatePointer ¬ IF oneIsCurrent THEN infoOneLog ELSE infoAnotherLog;     intervalRemaining: VM.Interval ¬ interval;  -- yet to be processed    entryWasAppended: BOOLEAN ¬ FALSE;      offsetWriter: VM.PageOffset ¬ -- offset in the log      LOOPHOLE[logState.mapLogDesc.writer, CARDINAL]/wordsPerPage;    offsetWriterNext: VM.PageOffset; -- offset in the log    pEntry: LONG POINTER TO Entry;  -- entry being examined    ptr: EntryPointer ¬ ConcreteRPEntry[logState.mapLogDesc.writer];    writerNext: VMMapLog.EntryPointer;  -- next place to write (writer is current place)    IF NOT mapLogging THEN RETURN;        -- Search backwards through the current page, processing empty spots:    -- (A map operation will reuse empty spots;    --  an unmap operation will recycle matching map entries into empty spots.)    WHILE intervalRemaining.count > 0      AND LOOPHOLE[ptr, CARDINAL] MOD wordsPerPage >= SIZE[Entry]      -- only check current page of MapLog --      AND ptr # FIRST[EntryPointer] --ConcreteRPEntry[logState.mapLogDesc.reader]-- DO      ptr ¬ ptr - SIZE[Entry];  -- move to the previous log entry      pEntry ¬ @logState.base[ptr];      IF transferProc = NIL THEN	BEGIN  --we are unmapping--	IF pEntry.count > 0  -- not an empty entry already	  AND pEntry.page >= interval.page AND	  pEntry.page + pEntry.count <= interval.page + interval.count THEN	  -- 'pEntry' run is wholly contained within 'interval' run --	  BEGIN  -- turn map entry into unused entry	  intervalRemaining.count ¬  -- assumes no duplicate map entries.	    intervalRemaining.count - pEntry.count;  -- 1 of 2	  pEntry.count ¬ 0;  -- 2 of 2	  logState.emptySpots ¬ logState.emptySpots.SUCC;	  IF intervalRemaining.count = 0 THEN RETURN;	  END;	END  --we are unmapping--      ELSE	BEGIN  --we are mapping--	-- We are looking for an empty spot to use..	IF logState.emptySpots = 0 THEN EXIT;  -- no point in searching.	IF pEntry.count = 0 THEN	  BEGIN  --Log entry is unused; fill it--	  SELECT transferProc FROM	    DiskBackingStore.Transfer =>	      BEGIN  --mapped to disk--	      countDone: Environment.PageCount =		MakeDiskBackingStoreEntry[		  pEntry: pEntry, interval: intervalRemaining,		  access: access, runs: runs, runsBasePage: interval.page];	      logState.emptySpots ¬ logState.emptySpots - 1;	      intervalRemaining.page ¬ intervalRemaining.page + countDone;	      intervalRemaining.count ¬ intervalRemaining.count - countDone;	      IF intervalRemaining.count = 0 THEN RETURN;	      END;  --mapped to disk--	    -- Arms for other backing stores go here.	    ENDCASE => ERROR Bug[unknownBackingStorage];	  END  --Log entry is empty; fill it--	ELSE  --pEntry.count > 0--	  BEGIN  --meaningful log entry--	  -- If the entry is an unmap of an overlapping interval, we must leave	  -- it and all previous ones alone, and just add a new entry at the end.	  -- If we replaced an unmap with the map we'de generate an overlappingOrDuplicateEntry ?	  IF pEntry.kind = nil AND  -- nil implies an unmap entry	    MIN[  -- the end of the interval that ends first.	      pEntry.page + pEntry.count, interval.page + interval.count]	    > MAX[  -- the first page of the interval that starts last.	      pEntry.page, interval.page] THEN EXIT;	  END;  --meaningful log entry--	END;  --we are mapping--      ENDLOOP;  --processing empty spots in last page--    IF transferProc = NIL  -- we are unmapping      AND intervalRemaining.count > 0  -- and not all done      -- We must put in an unmap entry for the whole interval. Because we didn't      -- update intervalRemaining to truely reflect any map entries that we nuked      -- that were wholly contained within interval. Note: This could have      -- involved making multiple intervalRemaining(s) to cover mapped runs      -- that were not represented by entries in the single MapLog page that we      -- looked at.      THEN intervalRemaining ¬ interval;    -- Append any remaining entries to the end of the log:    WHILE intervalRemaining.count > 0 DO      countDone: Environment.PageCount;  -- count processed this time through loop.      -- Before we put an entry in the log we check to see if it's full.      -- If it is, we generate a 'clean' new one, with the intent, of switching to      -- the new log and continuing to insert entries.      writerNext ¬ logState.mapLogDesc.writer + SIZE[Entry];      -- If the map log is full, clean it:      IF writerNext = logState.mapLogDesc.limit THEN BEGIN  -- client-side map log.      	CleanMapLog[];	-- On return, current log is not obsolete, just unsorted.	-- The writer/reader/descriptor for new log have been set APPROPRIATELY.	-- (1)logState pointer and (2)ESV must be switched to the 'new' log.	-- 'Current' log should be killed.	-- writerNext, and offsetWriter should apply to the new log.	Pinning.Pin[mLPin];  -- need UpdateESV resident cause it DisablesInterrupts.	SpecialSpace.MakeGlobalFrameResident[MapLogImpl	  ! SpecialSpace.SpecialError =>	    IF error = alreadyResident THEN CONTINUE];	UpdateESV[logState];	BEGIN	  oldLog: StatePointer;  -- used for cleaning up old log.	  howManyMLs ¬ howManyMLs+1;	  oldLog ¬ logState;	  oldLog.mapLogDesc.writer ¬ oldLog.mapLogDesc.reader ¬ VMMapLog.EntryPointer.FIRST;	  Space.Kill[ -- and we don't need the old log.            [pointer: oldLog.base, count: oldLog.mapLogCount]];	  logState ¬ IF oneIsCurrent THEN infoOneLog ELSE infoAnotherLog;	  -- re-set offsetWriter, writerNext.	  offsetWriter ¬ LOOPHOLE[	    logState.mapLogDesc.writer, CARDINAL]/wordsPerPage;	  writerNext ¬ logState.mapLogDesc.writer + SIZE[Entry];	  IF writerNext = logState.mapLogDesc.limit THEN	    -- Error VMMapLog.LogFull	    mapLogging ¬ FALSE;    	  END;	Pinning.Unpin[mLPin];	SpecialSpace.MakeGlobalFrameSwappable[MapLogImpl];	IF ~mapLogging THEN RETURN;	END;  -- of client-side map log.      offsetWriterNext ¬	LOOPHOLE[writerNext, CARDINAL]/wordsPerPage;      pEntry ¬ @logState.base[ConcreteRPEntry[logState.mapLogDesc.writer]];      IF transferProc = NIL THEN	BEGIN  --we are unmapping--	entryCount: EntryCount = EntryCount[MIN[	  EntryCount.LAST.LONG, intervalRemaining.count]];	pEntry­ ¬ [	  page: intervalRemaining.page, count: entryCount, writeProtected: TRASH,	  fill: TRASH, backingStorage: nil[ALL[0]]];	entryWasAppended ¬ TRUE;	countDone ¬ entryCount;	END  --we are unmapping--      ELSE	BEGIN  --we are mapping--	SELECT transferProc FROM	  DiskBackingStore.Transfer =>	    BEGIN	    countDone ¬ MakeDiskBackingStoreEntry[	      pEntry: pEntry, interval: intervalRemaining,	      access: access, runs: runs, runsBasePage: interval.page];	    entryWasAppended ¬ TRUE;	    END;	  -- Arms for other backing stores go here.	  ENDCASE => ERROR Bug[unknownBackingStorage];	END;  --we are mapping--      IF offsetWriterNext # offsetWriter THEN  -- next write on next page of MapLog.	VM.Deactivate[  -- start old page on the way out	  [page: logState.pageLog + offsetWriter, count: 1], return];      logState.mapLogDesc.writer ¬ writerNext;      offsetWriter ¬ offsetWriterNext;      intervalRemaining ¬ [	intervalRemaining.page + countDone, intervalRemaining.count - countDone];      IF LOOPHOLE[logState.mapLogDesc.writer, CARDINAL] MOD wordsPerPage < SIZE[Entry]	THEN logState.emptySpots ¬ 0;  -- crossed to a new page      ENDLOOP;  -- Append any remaining entries to the end of the log    IF entryWasAppended      AND LOOPHOLE[logState.mapLogDesc.writer, CARDINAL] MOD wordsPerPage > threshold      THEN  -- start the next needed page coming in...      VM.Activate[	[page: logState.pageLog + (offsetWriter + 1) MOD logState.mapLogCount, count:  1],	return];    END;  --WriteLog1--  CleanMapLog: PROC [] = BEGIN    toLogFunkyFormat: VMMapLog.LogDesc; -- needed for VMMapLog.InsertEntry    reader: VMMapLog.EntryPointer;    entry: LONG POINTER TO Entry;    destinationLog: LONG POINTER TO VMMapLog.Descriptor;    fromBase: VMMapLog.EntryBasePointer;    writersPage: VM.PageOffset; -- offset in the log    totalEntryCount: CARDINAL;    fromLogState, toLogState: StatePointer;    IF oneIsCurrent THEN      {fromLogState ¬ infoOneLog; toLogState ¬ infoAnotherLog;}    ELSE      {fromLogState ¬ infoAnotherLog; toLogState ¬ infoOneLog;};    reader ¬ FIRST[VMMapLog.EntryPointer];    destinationLog ¬ toLogState.mapLogDesc;    -- get self Entry of fromLog Descriptor.    entry ¬ ConcreteLPEntry[@fromLogState.mapLogDesc.self];    << The destinationLog has the fromLog .self entry; any additional entries     needed to describe fromLog are contained in fromLog. So, the new log being     built here contains entries to cover all of fromLog, as well as     itself.  fromLog will have reader¬writer¬FIRST, effectively clearing all info,     including entries for itself which it will get from this new log when it is time to switch. >>    fromBase ¬ LOOPHOLE[fromLogState.base];    totalEntryCount ¬ CARDINAL[ (toLogState.mapLogCount*wordsPerPage)]/SIZE[VMMapLog.Entry];    toLogFunkyFormat ¬ [count: 0, limit: totalEntryCount,      entries: LOOPHOLE[toLogState.base]];    UNTIL reader = fromLogState.mapLogDesc.writer DO      entry ¬ ConcreteLPEntry[@fromBase[reader]];       InsertEntry[entry, @toLogFunkyFormat];      reader ¬ reader + SIZE[VMMapLog.Entry];      IF reader = fromLogState.mapLogDesc.limit THEN reader ¬ FIRST[VMMapLog.EntryPointer];      ENDLOOP;    -- InsertEntry doesn't update writer (does do count) so we gots to do it.    destinationLog.writer ¬ LOOPHOLE[FIRST[VMMapLog.EntryPointer] + toLogFunkyFormat.count*SIZE[VMMapLog.Entry], VMMapLog.EntryPointer];    destinationLog.reader ¬ FIRST[VMMapLog.EntryPointer];    writersPage ¬ LOOPHOLE[destinationLog.writer, CARDINAL]/wordsPerPage;    VM.Deactivate[ -- lets put this new log on disk.      [page: toLogState.pageLog, count: writersPage], wait];    mapLogSize ¬ CARDINAL[writersPage];  -- an interesting number only      toLogState.emptySpots ¬ 0;  -- 'cause the log is brand new perfect.    END;  --CleanMapLog--  UpdateESV: PROC[oldLog: StatePointer] = BEGIN    newLog: StatePointer;    ProcessOperations.DisableInterrupts;    oneIsCurrent ¬ ~oneIsCurrent;  -- 'cause we just built a new one.    newLog ¬ IF oneIsCurrent THEN infoOneLog ELSE infoAnotherLog;    CPSwapDefs.PESV[].mapLog ¬ newLog.mapLogDesc; -- update for debugger.    ProcessOperations.EnableInterrupts;    END;   InsertEntry: PROCEDURE [    entry: LONG POINTER TO Entry, log: VMMapLog.Log] =    BEGIN    entryEnd: Environment.PageNumber ¬ entry.page + entry.count;    hi: CARDINAL;    lo: CARDINAL ¬ 0;    IF entry.count = 0 THEN RETURN;  -- a vacuous entry    IF log.count > 0 THEN      BEGIN      mid: CARDINAL;      IF LOOPHOLE[log.entries[hi ¬ log.count-1], Entry].page < entry.page      THEN {lo ¬ log.count; GOTO done};      -- Find the spot to insert into --      WHILE hi >= lo DO        mid ¬ (hi + lo)/2;        SELECT LOOPHOLE[log.entries[mid], Entry].page FROM	-- !! was ConcreteLPEntry[@log.entries[mid]].page          > entry.page => IF mid = 0 THEN EXIT ELSE hi ¬ mid - 1;          < entry.page => lo ¬ mid + 1;          ENDCASE => {lo ¬ mid; EXIT};        ENDLOOP;      EXITS done => NULL;      END    ELSE lo ¬ 0;  -- this is the first entry    --ASSERT: entry.page <= log.entries[lo].page    -- or alternatively: log.entries[lo].page >= entry.page.        IF entry.kind = nil THEN      BEGIN  -- it's an unmap      -- Accumulate the entries that are covered by this unmap:      -- Note that any of the matching map entries may be absent due to       --   their cancellation and re-use in the debugee world.      maxDeletableEntries: CARDINAL = log.count - lo;      entriesToDelete: CARDINAL;      FOR entriesToDelete ¬ 0, entriesToDelete.SUCC        WHILE entriesToDelete < maxDeletableEntries	AND LOOPHOLE[	      log.entries[lo + entriesToDelete], Entry].page < entryEnd DO	--ASSERT: entries[lo + entriesToDelete].page >= entry.page.        ENDLOOP;      -- Delete the map entries:      Inline.LongCOPY[        from: @log.entries[lo + entriesToDelete], to: @log.entries[lo],	nwords: (log.count-(lo + entriesToDelete))*VMMapLog.Entry.SIZE];      log.count ¬ log.count - entriesToDelete;      END    ELSE      BEGIN  -- it's a map      IF log.count >= log.limit THEN Bug[mapLogFull];  -- NEVER raised here.      IF lo < log.count THEN        BEGIN  -- there is a following entry.        IF entry.page = LOOPHOLE[log.entries[lo], Entry].page	OR entryEnd > LOOPHOLE[log.entries[lo], Entry].page THEN	  ERROR Bug[duplicateOrOverlappingMapEntry];	END;      -- Make room in table:      Inline.LongCOPYReverse[        from: @log.entries[lo], to: @log.entries[lo + 1],	nwords: (log.count-lo)*VMMapLog.Entry.SIZE];      log.entries[lo] ¬ LOOPHOLE[entry­, VMMapLog.Entry];  -- insert the new map entry      log.count ¬ log.count + 1;      END;    END;  --InsertEntry--    SetUpDualLogAccounting: PROC =    BEGIN    shortPDesc: Environment.Base RELATIVE POINTER TO VMMapLog.Descriptor;    shortStateObj: Environment.Base RELATIVE POINTER TO LogState;    status: Zone.Status;    [shortStateObj, status] ¬ ResidentHeap.MakeNode[SIZE[LogState]];    IF status # okay THEN ERROR Bug[troubleAllocating];    infoOneLog ¬ @Environment.first64K[shortStateObj];    [shortStateObj, status] ¬ ResidentHeap.MakeNode[SIZE[LogState]];    IF status # okay THEN ERROR Bug[troubleAllocating];    infoAnotherLog ¬ @Environment.first64K[shortStateObj];    [shortPDesc, status] ¬  -- must be resident.      ResidentHeap.MakeNode[n: VMMapLog.Descriptor.SIZE];    IF status # okay THEN ERROR Bug[troubleAllocating];    infoOneLog.mapLogDesc ¬ @Environment.first64K[shortPDesc];        [shortPDesc, status] ¬  -- must be resident.      ResidentHeap.MakeNode[n: VMMapLog.Descriptor.SIZE];    IF status # okay THEN ERROR Bug[troubleAllocating];    infoAnotherLog.mapLogDesc ¬ @Environment.first64K[shortPDesc];        infoOneLog.mapLogDesc.version ¬     infoAnotherLog.mapLogDesc.version ¬ VMMapLog.currentVersion;    infoOneLog.mapLogDesc.reader ¬ infoOneLog.mapLogDesc.writer ¬ VMMapLog.EntryPointer.FIRST;    oneIsCurrent ¬ TRUE;    mLPin ¬ Pinning.CreatePinHandle[LOOPHOLE[UpdateESV], 1];    END;    -- Main body --    SetUpDualLogAccounting[];        END.LOG  (for earlier entries see 8.0 archive version)15 Oct 81 11:30   JXP      Modified WriteLog1 to save log space by matching corresponding   maps and unmaps and using the free space generated for new entries18-Dec-81 14:29:53   JXP      Fix the loop (writelog1) which backs up thru the log so   that parts of map entries don't get put in front of match31-Dec-81 10:52:54   JXP      Implement new levels off Maplogging. No absolute off setting supported.   Maplogging occurs at least until the table fills. 8-Feb-82 19:37:01   AWL         If System.switches[PilotSwitches.fillMapLog] = down then we map log until   the log is filled and then we quit.16-Aug-82 11:35:34   By: JXP      Track changes to the MapLog interface brought on by Klamath. Use    BackingStore.Data's for run information24-Aug-82 12:58:18   AWL         Environment.page*'s are LONG but map log entries only support   short PageNumber's: only maplog pages that can be represented. 6-Oct-82  9:46:34   AWL         Doesn't need Space.PageCount 3-Jan-83 15:06:32   JXP      Program parms are supplied when init proc is called, remove them from   program statement and copy them into global vars at init time. 1-Apr-83 11:15:03   JXP      PROGRAM => MONITOR, since not protected from Space. Appropriate procs   become ENTRY PROCEDUREs.25-Apr-83 13:39:14   JXP      Remember to put an entry for the MapLog itself in the descriptor during   initialization. Replace Inline.LowHalf's with CARDINAL. 7-Jul-83 14:29:01   WDK        Make compatible with new VMMapLog, VMMapLogInternal, VMMPrograms. Remove references to patch table. Delete private copy of Descriptor. Get types from VMMapLog. Export Entry. Eliminate duplicate and unused variables. Eliminate loopholes. count = 0 means unused entry. Failed to handle run count > 4096. Failed on noncontiguous maplog backing file. Use meaningful error codes. Improve documentation. If have to append unmap entry, entry now says whole interval. Decreased threshold. Allocate Desc and set up esv ourselves.12-Jul-83 14:37:17   JXP   	Twiddles to make compile.18-Aug-83 19:30:20   WDK        InitializeMapLog must not be ENTRY. Add MakeDiskBackingStoreEntryENTRY.22-Aug-83 14:37:17   WDK        WriteLog1's empty spot code must use count before zeroing it.25-Aug-83 11:03:59   WDK     	Don't maplog the maplog itself twice.25-Aug-83 15:05:08   WDK     	Add pEntries for debugger.26-Aug-83 18:28:32   JXP   	When unmapping, we don't always decrement count.27-Jan-84 15:16:40   AWL        Maplogs that were not contiguous on teh disk were not map logged correctly. 1-Feb-86 10:52:43   CJS  Implement client side maplogging.  Add CleanMapLog, UpdateESV, hack InsertEntry from VMMapLogImpl, etc.. Put global vars. in LogState record, use global oneIsCurrent BOOLEAN to synchronize access to two MapLog Descriptors. Removed (\375 "map until full") switch support. 2-Jul-86 15:58:32   CJS  Checking if writer=reader has become writer=FIRST[EntryPointer]. Debugger may use/set reader but reader is reset to FIRST after client side maplog. Added AHL's performance perk to InsertEntry. 3-Jul-86 16:30:40   RSV  Fixed up procedures MakeDiskBackingStoreEntry, for labeless operation. 4-Sep-86 10:21:12   CJS Condition for client side MapLog is now: writerNext = logState.mapLogDesc.limit. Debugger may use/set reader but reader is reset to FIRST[EntryPointer] after client side maplog. Added AHL's performance perk to InsertEntry. When LogFull don't raise Error just make mapLogging ¬ FALSE. 8-Feb-87 15:39:18   RSV Export mapLogSize to SpacePerf.17-Jul-87  8:42:01   CAJ Add ENABLE UNWINDs to the entry procs; continue an alreadyResident error from MakeGlobalFrameResident.17-Jan-89 17:59:53   RSV Export to SpacePerfExtras, not SpacePerf.
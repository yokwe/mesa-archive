-- Copyright (C) 1984, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- BootChannelDisk.mesa   4-Feb-88 16:34:44   by CAJ      -- Implementation of BootChannel for Pilot Disk.-- A single, serially reusable, channel is supported.DIRECTORY  Boot USING [    BootFileDescriptorPageHandle, BootFileDescriptorPageSeal,    BootFileDescriptorPageVersion, eofDescriptorLink, Location, PageRun],  BootChannel USING [    Create, Handle, Operation, Result, transferCleanup, transferWait],  Device USING [PilotDisk, Type],  Environment USING [    first64K, LongNumber, LongPointerFromPage, PageFromLongPointer, PageNumber],  Inline USING [LongDivMod, LongMult, LowHalf],  GermOps USING [GermWorldError],  PageMap USING [Flags, flagsClean, ExchangeFlags],  PilotDiskFace USING [    Command, ControllerHandle, DeviceHandle, DetermineDiskShape, DiskAddress,    GetControllerAttributes, GetDeviceAttributes, GetNextController,    GetNextDevice, GlobalStatePtr, InitializeController, Initiate,    nullControllerHandle, nullDeviceHandle, OperationPtr, operationAlignment,    operationSize, Poll, Status, Tries],  PilotMP USING [    cGermDescriptorError, cGermDeviceError, cGermERROR, cGermShortBootFile],  ResidentHeap USING [FreeNode, MakeNode];BootChannelDisk: PROGRAM  IMPORTS    RemainingChannels: BootChannel, Environment, GermOps, Inline,      PageMap, PilotDiskFace, ResidentHeap  EXPORTS BootChannel  SHARES Device, GermOps, PageMap =  BEGIN  triesMax: PilotDiskFace.Tries = 200;  -- try real hard  -- Cache for page group entries from bootfile descriptor  -- Keeping this small cache allows us to avoid keeping the whole descriptor  -- page around in a permanently allocated real page.  The cache size is  -- believed to cover the large majority of bootfiles without refills.  -- When the page groups in the cache are exhausted without filling the  -- requested count, the descriptor page is reread and the cache refilled.  -- There is no separate buffer for descriptor reads, so when the cache is  -- empty, the descriptor is read and the cache filled using the buffer passed  -- to the transfer.  For reading, this occurs before the actual read.  For  -- writing, the cache is filled at Create time and after the transfer  -- which emptied it.  CacheRange: TYPE = [0..maxCacheGroups);  maxCacheGroups: CARDINAL = 6;  cache: ARRAY CacheRange OF Boot.PageRun;  currentGroup: CARDINAL;  daCurrentDescriptor: PilotDiskFace.DiskAddress;  lastGroup: CacheRange;  nextDescGroup: CARDINAL;  Ops: TYPE = [0..maxOps);  maxOps: CARDINAL = 2;  -- GermOpsImpl has a copy of this  ops: ARRAY Ops OF OperationDescriptor; -- older operations have lower indices  OperationDescriptor: TYPE = RECORD [    op: PilotDiskFace.OperationPtr,    state: {idle, busy},    opState: {running, completed},    status: PilotDiskFace.Status];  pLoc: LONG POINTER TO Boot.Location;    -- global state of all disk requests.  Normally these track processing the  -- bootfile.  However, they may be given other values when appropriate.  command: PilotDiskFace.Command;  address: PilotDiskFace.DiskAddress;  channelOperation: BootChannel.Operation;  -- shape of the current drive  sectorsPerTrack: CARDINAL;  movingHeads: CARDINAL;  Controllers: TYPE = [0..maxControllers);  maxControllers: CARDINAL = 7;  -- we just know this; GermOpsImpl has a copy  controllersPresent: CARDINAL;  controllerState: ARRAY Controllers OF PilotDiskFace.GlobalStatePtr;  Create: PUBLIC --BootChannel.-- PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation,    buffer: LONG POINTER]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    IF (pLoc ¬ pLocation).deviceType IN      [Device.Type[FIRST[Device.PilotDisk]]..Device.Type[LAST[Device.PilotDisk]]]      THEN      BEGIN      controller: PilotDiskFace.ControllerHandle ¬        PilotDiskFace.nullControllerHandle;      device: PilotDiskFace.DeviceHandle ¬ PilotDiskFace.nullDeviceHandle;            FOR controllersPresent IN Controllers DO        IF (controller ¬ PilotDiskFace.GetNextController[controller]) =	  PilotDiskFace.nullControllerHandle THEN EXIT;        PilotDiskFace.InitializeController[          controller: controller,          globalState: controllerState[controllersPresent] ¬	    ResidentHeap.MakeNode[              PilotDiskFace.GetControllerAttributes[controller],	        PilotDiskFace.operationAlignment].node,	   mask: 0];	ENDLOOP;      THROUGH [0..pLocation.deviceOrdinal] DO        device ¬ PilotDiskFace.GetNextDevice[device];	ENDLOOP;      FOR i: Ops IN Ops DO	ops[i].op ¬ @Environment.first64K[          ResidentHeap.MakeNode[	    PilotDiskFace.operationSize, PilotDiskFace.operationAlignment].node];	ENDLOOP;      IF ~PilotDiskFace.DetermineDiskShape[        device, ops[0].op, quickReadOnly, buffer]          THEN GermOps.GermWorldError[PilotMP.cGermDeviceError];      FOR i: Ops IN Ops DO        opn: LONG POINTER TO PilotDiskFace.OperationPtr = @ops[i].op;	-- Initialize the important parts of the OperationDescriptor	ops[i].state ¬ idle;	-- Initialize operation fields that are constant:	opn.reserved1 ¬ NIL;	opn.incrementDataPtr ¬ TRUE;	opn.tries ¬ triesMax;	opn.device ¬ device;	ENDLOOP;      [movingHeads: movingHeads, sectorsPerTrack: sectorsPerTrack] ¬         PilotDiskFace.GetDeviceAttributes[device];      address ¬ pLocation.diskFileID.da;      -- Get bootfile descriptor cache ready to go      cache ¬ ALL[[[0,0,0], 0]];      currentGroup ¬ LAST[CARDINAL];      lastGroup ¬ 0;      nextDescGroup ¬ 0;      daCurrentDescriptor ¬ pLocation.diskFileID.da;      channelOperation ¬ operation;  -- save it for transfer time      SELECT operation FROM        read => command ¬ read;        write =>	  {command ¬ write; [] ¬ FillCache[	     page: Environment.PageFromLongPointer[buffer], restore: FALSE]};        rawRead => command ¬ read;        ENDCASE => GermOps.GermWorldError[PilotMP.cGermERROR];      RETURN[[ok[]], Transfer];      END;    -- Not anything I implement.  Pass it on.    RETURN RemainingChannels.Create[pLocation, operation];    END;  Transfer: BootChannel.Handle  --    --PROC [page, count] RETURNS [result: BootChannel.Result]--  =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    SELECT count FROM      = BootChannel.transferCleanup =>        BEGIN	FOR i: Controllers IN [0..controllersPresent) DO	  [] ¬ ResidentHeap.FreeNode[controllerState[i]];	  ENDLOOP;        FOR i: Ops IN Ops DO	  [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[ops[i].op]];	  ENDLOOP;	END;      = BootChannel.transferWait =>	THROUGH Ops DO	  FinishRequest[];	  RotateOpns[];	  ENDLOOP;      NOT IN CARDINAL => GermOps.GermWorldError[PilotMP.cGermERROR];      ENDCASE =>        BEGIN	-- Get all of the count submitted before letting go.	-- Assumes serial calling of Transfer.	countLeft: CARDINAL ¬ CARDINAL[count];	countSubmitted: CARDINAL;	WHILE countLeft > 0 DO	  IF ops[0].state = busy THEN FinishRequest[];	  -- rawRead is defined as 1 page, no label checking.  In the labelless	  -- world, this means "read what they said, no descriptor intelligence".	  IF channelOperation = rawRead THEN countSubmitted ¬ countLeft	  ELSE	    BEGIN	    IF currentGroup > lastGroup THEN	      BEGIN	      IF channelOperation = read THEN	        IF FillCache[page: page, restore: FALSE] THEN GOTO gotIt;	      GermOps.GermWorldError[PilotMP.cGermShortBootFile];	      EXITS gotIt => NULL;	      END;	    address ¬ cache[currentGroup].da;	    IF countLeft >= cache[currentGroup].count	      THEN  -- use all of current run	        {countSubmitted ¬ cache[currentGroup].count;		 currentGroup ¬ currentGroup + 1}	      ELSE  -- more left in the run than required now	        {countSubmitted ¬ countLeft;		 cache[currentGroup] ¬  -- update current group with remainder	           [da: NewAddress[countSubmitted],		    count: cache[currentGroup].count - countSubmitted]};	    END;	  SubmitRequest[page, countSubmitted];	  RotateOpns[];	  IF channelOperation = write THEN	    IF currentGroup > lastGroup THEN	      [] ¬ FillCache[page: page, restore: TRUE];	  page ¬ page + countSubmitted; 	  countLeft ¬ countLeft - countSubmitted;	  ENDLOOP;	END;    RETURN[[ok[]]];    END;  FillCache: PROCEDURE [page: Environment.PageNumber, restore: BOOLEAN]    RETURNS [ok: BOOLEAN] =    BEGIN    desc: Boot.BootFileDescriptorPageHandle;    descOK: BOOLEAN;    oldflags: PageMap.Flags;    savedAddr: PilotDiskFace.DiskAddress ¬ address;    savedCommand: PilotDiskFace.Command ¬ command;    start: CARDINAL ¬ nextDescGroup;    -- If this is a refill, the page being used for the descriptor buffer is    -- the memory page passed into the transfer.  For a transfer read, the    -- descriptor is read and processed first, then the requested read is done.    -- For a transfer write, the page is written, then the descriptor page is    -- read into that page and processed, then the original contents are    -- restored by rereading.  In the write case, the page may need to be    -- made readable by temporarily clearing the readonly page flag.    IF daCurrentDescriptor ~= Boot.eofDescriptorLink      THEN address ¬ daCurrentDescriptor      ELSE RETURN [ok: FALSE];    command ¬ read;    IF ops[0].state = busy THEN FinishRequest[];    [oldState: [flags: oldflags]] ¬       PageMap.ExchangeFlags[virtual: page, newFlags: PageMap.flagsClean];    SubmitRequest[page: page, count: 1, opn: 0];    FinishRequest[];    desc ¬ Environment.LongPointerFromPage[page];    descOK ¬ desc.header.seal = Boot.BootFileDescriptorPageSeal AND      desc.header.version = Boot.BootFileDescriptorPageVersion;    nextDescGroup ¬ MIN[start + maxCacheGroups, desc.header.pageRunsCount];    FOR i: CARDINAL IN [start..nextDescGroup) DO      cache[i - start] ¬ desc.pageRuns[i];      ENDLOOP;    currentGroup ¬ 0;    lastGroup ¬ nextDescGroup - start - 1;    IF nextDescGroup = desc.header.pageRunsCount THEN      {daCurrentDescriptor ¬ desc.header.nextPage; nextDescGroup ¬ 0};    address ¬ savedAddr;    -- Restore before error so as not to leave page smashed and/or flags wrong    IF restore THEN      BEGIN      IF ops[0].state = busy THEN FinishRequest[];      SubmitRequest[page: page, count: 1, opn: 0];      FinishRequest[];      END;    [] ¬ PageMap.ExchangeFlags[virtual: page, newFlags: oldflags];    IF ~descOK THEN GermOps.GermWorldError[PilotMP.cGermDescriptorError];    command ¬ savedCommand;    RETURN [ok: TRUE];    END;  -- FillCache  FinishRequest: PROCEDURE =    -- Forces ops[0] to the idle state    -- Completion status other than goodCompletion just bombs into MP code.    BEGIN    IF ops[0].state = idle THEN RETURN;    WHILE ops[0].opState = running DO      completedOpn: PilotDiskFace.OperationPtr ¬ NIL;      controller: PilotDiskFace.ControllerHandle ¬        PilotDiskFace.nullControllerHandle;      status: PilotDiskFace.Status ¬ inProgress; -- must be inProgress      WHILE (controller ¬ PilotDiskFace.GetNextController[controller])          ~= PilotDiskFace.nullControllerHandle DO        [status, completedOpn] ¬ PilotDiskFace.Poll[controller];	IF completedOpn ~= NIL THEN EXIT;	REPEAT FINISHED => GermOps.GermWorldError[PilotMP.cGermERROR];        ENDLOOP;      WHILE status = inProgress DO        [status, completedOpn] ¬ PilotDiskFace.Poll[controller];        ENDLOOP;      FOR i: Ops IN Ops DO        IF ops[i].op = completedOpn THEN	  BEGIN	  ops[i].opState ¬ completed;	  ops[i].status ¬ status;	  EXIT;	  END;	REPEAT FINISHED => GermOps.GermWorldError[PilotMP.cGermERROR];	ENDLOOP;      ENDLOOP;    IF ops[0].status = goodCompletion      THEN ops[0].state ¬ idle      ELSE GermOps.GermWorldError[PilotMP.cGermDeviceError];    END;  --FinishRequest    NewAddress: PROCEDURE [count: CARDINAL]    RETURNS [da: PilotDiskFace.DiskAddress] =    BEGIN    GetPageNumber: PROCEDURE [page: PilotDiskFace.DiskAddress]      RETURNS [LONG CARDINAL] = INLINE      BEGIN      DMUL: PROCEDURE [arg1, arg2: LONG CARDINAL]        RETURNS [result: LONG CARDINAL] =        BEGIN	OPEN	  a: LOOPHOLE[arg1, Environment.LongNumber],	  b: LOOPHOLE[arg2, Environment.LongNumber],	  product: LOOPHOLE[result, Environment.LongNumber];	product.lc ¬ Inline.LongMult[a.lowbits, b.lowbits];        product.highbits ¬          product.highbits + a.lowbits*b.highbits + a.highbits*b.lowbits;	END;      RETURN[        page.sector +	  DMUL[ -- we do this explicitly since the obvious code traps on the DLion	    sectorsPerTrack,	    (page.head + Inline.LongMult[movingHeads, page.cylinder])]];      END;    GetPageAddress: PROCEDURE [page: LONG CARDINAL]      RETURNS [PilotDiskFace.DiskAddress] = INLINE      BEGIN      addr: PilotDiskFace.DiskAddress;      temp: CARDINAL;      [quotient: addr.cylinder, remainder: temp] ¬        Inline.LongDivMod[num: page, den: sectorsPerTrack * movingHeads];      addr.sector ¬ temp MOD sectorsPerTrack;      addr.head ¬ temp / sectorsPerTrack;      RETURN[addr];      END;    da ¬ GetPageAddress[GetPageNumber[address]+count];    END;    SubmitRequest: PROCEDURE [    page: Environment.PageNumber, count: CARDINAL, opn: Ops ¬ 0] =    BEGIN    operation: PilotDiskFace.OperationPtr = ops[opn].op;    ops[opn].state ¬ busy;    ops[opn].opState ¬ running;    operation.clientHeader ¬ address;    operation.pageCount ¬ count;    operation.dataPtr ¬ Environment.LongPointerFromPage[page];    operation.command ¬ command;    PilotDiskFace.Initiate[operation];    END;    RotateOpns: PROCEDURE =    BEGIN    t: OperationDescriptor = ops[0];    FOR i: Ops IN [1..LAST[Ops]] DO      ops[i-1] ¬ ops[i];      ENDLOOP;    ops[LAST[Ops]] ¬ t;    RETURN;    END;  END.LOG(For earlier log entries, see Pilot 10.0 archive version.)August 13, 1980  6:02 PM   PXM       Read first label to determine attributesAugust 23, 1980  1:21 PM   PXM       Don't report labelCheck at end of runJanuary 28, 1981  12:02 PM   PXM       Respond to sa1000 device typeMarch 20, 1981  9:12 AM   PXM       Reset tries after labelCheck; assign status to variable for debugging22-Jun-81 12:31:56   SXY      SA4000Face => PilotDiskFace, labelCheck => labelVerifyError caused by PilotDiskFace change 1-Sep-81 14:21:59   FXH       Call DetermineDiskShape[quickreadOnly] 3-Nov-81  9:09:33   WDK        Use Utilities.LongPointerFromPage instead of Boot.LP.  Use ResidentHeap to alloc storage.  Use GermWorldError.26-May-83 11:27:02   WDK        Convert to Klamath. Fixed retry logic to not retry on boot-chain-link-caused label verify errors. Shoot them loopholes. Use Environment.LongPointerFromPage. Make compatible with new BootChannel. Allow booting from temp file.14-Jun-84 13:31:03   AWL         Upgrade to new BootChannel (multiple buffering).26-Feb-86 11:00:56   CAJ         Init controller before getting device in Create. 6-Aug-86 21:25:46   CAJ         Rewrite to use descriptors rather than label bootchain links to find page runs.  Remove retry logic since it is no longer necessary to get label right and retry.22-Aug-86 23:18:02   RSV   Increment page pointer in Transfer when going through loop more than once.  Added NILing out reserved1 field in OperationPtr. 4-Nov-86  7:17:17   CAJ         Add transferPrimer and related.  Reduce #disk ops from 2 to 1 until we can allocate a bigger heap without overflowing germ VM.  Miscellaneous cleanup.11-May-87 17:05:14   CAJ         Create now supplies a page buffer, used for DetermineDiskShape and descriptor cache init for write channel.  Delete transferPrimer.  Make channel initialization explicit. 2-Jul-87 13:41:23   CAJ         Init operation fields after DetermineDiskShape. 5-Aug-87 16:19:09   CAJ         Handle multiple controllers. Align controller globalState on operationAlignment.  Return controller globalState(s) at transferCleanup.24-Aug-87 17:58:52   CAJ         Poll controllers correction.19-Nov-87 20:41:16   CAJ         Give back only controller storage actually allocated.  Correct some erroneous comments. 4-Feb-88 16:34:39   CAJ         Reset and restore page flags when rereading descriptor page during a write.
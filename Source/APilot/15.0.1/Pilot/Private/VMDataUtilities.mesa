-- Copyright (C) 1984, 1986, 1988, 1989  by Xerox Corporation. All rights reserved. -- ResMemMgr>VMDataUtilities.mesa      12-Oct-89 11:39:22 by TXT   -- Implements the driver routines and utility procedures for use by other VMDataImpl modules.-- Order of procedures in this Module:----   1. ProcessSwapUnits--   2. Utility swap unit processors, ordered alphabetically.-- WARNING: The procedures implemented in this module all run inside the VMData monitor lock. They are implemented as coroutines because it is critical that we never take a frame fault while holding the monitor lock, since it is the VMData implementation itself that is invoked to satisfy a frame fault. Thus these coroutines themselves must also never call procedures which are not INLINEs or coroutines.  BECAUSE these are coroutines, it is further critical that the monitor lock NEVER be released from inside this module, or it may result that more than one process may be "executing within" the same coroutine.DIRECTORY  BackingStore USING [TransferProc],  Environment USING [Base, first64K, PageCount, PageNumber, wordsPerPage],  Frame USING [GetReturnFrame, SetReturnFrame],  Inline USING [LongCOPYReverse],  KernelSpaceUsage USING [swapUnitTable],  MStore USING [Allocate],  PageMap USING [IsMapped],  PrincOps USING [ControlLink, Port],  Space USING [LongPointerFromPage, PagesFromWords, SwapUnitSize, SwapUnitType],  ResidentHeap USING [MakeNode],  ResMemPerf USING [],  RuntimeInternal USING [Bug],  StoragePrograms USING [AllocateVM, countVM],  VM USING [Interval, PageCount, PageNumber],  VMData USING [AllocateReservedMStoreInternal],  VMDataInternal,  Zone USING [Status];VMDataUtilities: PROGRAM  IMPORTS    Frame, Inline, MStore, PageMap, ResidentHeap, RuntimeInternal,    Space, StoragePrograms, VMData, VMDataInternal  EXPORTS ResMemPerf, VMDataInternal  SHARES VMData =  BEGIN  OPEN VMDataInternal;  DEBUG: BOOLEAN ¬ FALSE;  -- for initial debugging    swapUnitRunsProcessed: PUBLIC --ResMemPerf.-- LONG CARDINAL ¬ 0;  vmDatabaseFullSearches: PUBLIC --ResMemPerf.-- LONG CARDINAL ¬ 0;  vmDatabaseFastSearches: PUBLIC --ResMemPerf.-- LONG CARDINAL ¬ 0;  runBeingProcessed: PUBLIC LONG POINTER TO Run;  -- "argument" to SwapUnitProcessor.  transferProcTable: PTransferProcDesc ¬ nilPTransferProcDesc;  transferProcDescBase: Environment.Base = Environment.first64K;  pageTop: VM.PageNumber = FIRST[VM.PageNumber] + StoragePrograms.countVM;  --end of VM  rBase: RunBase = VMDataInternal.runBase;  -- name not "runbase" since matches export.  RunTable: TYPE = VMDataInternal.RunTable;  -- for debugger  Bug: PROCEDURE [bugType: BugType] = INLINE {RuntimeInternal.Bug[bugType]};  BugType: TYPE = {    beyondVM, freeMeFull, intervalSpansRuns, noSuchCase, noTransferProcDesc,    outOfVMForSwapUnitTable, processSwapUnitsError, pRunMruOffLowEnd,    runTableSmashed, swapUnitsUnmapped, tooManyTransferProcDescs,    transferProcTableTrashed, unableToAllocateResidentHeapNode};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- SwapUnit Data   (exported to VMDataInternal)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  swapUnitBase: PUBLIC SwapUnitBase;  pageSwapUnitTable: PUBLIC VM.PageNumber;  countSwapUnitTablePagesMapped: PUBLIC VM.PageCount ¬ 1;  pSwapUnitNextFree: PUBLIC PSwapUnit;  pSwapUnitMaxInRealMem: PUBLIC PSwapUnit;  pSwapUnitMaxInVM: PUBLIC PSwapUnit;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeVMDataUtilitiesA: PUBLIC PROCEDURE =    BEGIN    -- initialization for swap unit table    -- get VM; back part of it with real memory; get pointer to table; set limit pointers    pageSwapUnitTable ¬ StoragePrograms.AllocateVM[      countSwapUnitTablePages, hyperspace, KernelSpaceUsage.swapUnitTable,      partiallyOrSometimesMapped];    MStore.Allocate[      interval: [page: pageSwapUnitTable, count: countSwapUnitTablePagesMapped],      resident: TRUE];    swapUnitBase ¬ Space.LongPointerFromPage[pageSwapUnitTable];  --pointer to base of table    pSwapUnitNextFree ¬ FIRST[PSwapUnit];    pSwapUnitMaxInRealMem ¬      FIRST[PSwapUnit] +        CARDINAL[countSwapUnitTablePagesMapped]*Environment.wordsPerPage;    pSwapUnitMaxInVM ¬      FIRST[PSwapUnit] + countSwapUnitTablePages*Environment.wordsPerPage;    -- Initialization of coroutines:    [] ¬ InitializeAbortIfUnavailable[];    [] ¬ InitializeAdjustSwapUnitTablePointers[];--  [] ¬ InitializeFind[];    [] ¬ InitializeGetMapUnitBounds[];    [] ¬ InitializeGetSwapUnitTablePointers[];    [] ¬ InitializeGetTransferProc[];    [] ¬ InitializeCreateTransferProcID[];    [] ¬ InitializeMakeRoomInSwapUnitTable[];    [] ¬ InitializeProcessSwapUnits[];    END;  InitializeVMDataUtilitiesB: PUBLIC PROCEDURE =    BEGIN    status: Zone.Status;    --first entry is a dummy entry: just contains pointer to actual list    [node: LOOPHOLE[transferProcTable, Environment.Base RELATIVE POINTER],      s: status] ¬ ResidentHeap.MakeNode[SIZE[TransferProcDesc]];    IF status # okay THEN Bug[unableToAllocateResidentHeapNode];    transferProcDescBase[transferProcTable] ¬ [      transferProcID: FIRST[TransferProcID],  -- (which is not used by any real TransferProc)      referenceCount: 0,  --makes debugging easier      transferProc: LOOPHOLE[LONG[0], BackingStore.TransferProc],  --makes debugging easier      nextTransferProcDesc: nilPTransferProcDesc];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- ProcessSwapUnits:  Driver routine for swap unit processing  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ProcessSwapUnits: PUBLIC PROCEDURE [    interval: VM.Interval, unmappedProcessing: UnmappedProcessing,    runProcessing: RunProcessing, swapUnitProcessor: SwapUnitProcessor,    vacantProcessing: VacantProcessing ¬ processVacant]    RETURNS [nextPage: VM.PageNumber, aborted: BOOLEAN];    -- set indirect control link to PORT in InitializeProcessSwapUnits  InitializeProcessSwapUnits: PROCEDURE    RETURNS [nextPage: VM.PageNumber, aborted: BOOLEAN] =    BEGIN        AwaitProcessSwapUnitsRequest: --RESPONDING-- PORT [      nextPage: VM.PageNumber, aborted: BOOLEAN]      RETURNS [	interval: VM.Interval, unmappedProcessing: UnmappedProcessing,	runProcessing: RunProcessing, swapUnitProcessor: SwapUnitProcessor, 	vacantProcessing: VacantProcessing];  --    --args/results match ProcessSwapUnits, but reversed.        -- "arguments":    interval: VM.Interval;    unmappedProcessing: UnmappedProcessing;    runProcessing: RunProcessing;    swapUnitProcessor: SwapUnitProcessor;    vacantProcessing: VacantProcessing;    -- Local variables:    lpRun: LONG POINTER TO Run;    pageBeingProcessed: VM.PageNumber;    pageAfterInterval: VM.PageNumber;    pageAfterRun: VM.PageNumber;    pageRunStop: VM.PageNumber;  -- page at which we stop processing this run.    countSwapUnitPages: Space.SwapUnitSize;    newState: SwapUnitState;  -- from the swap unit processor    continuation: Continuation;  -- from the swap unit processor    statesPerWord: CARDINAL = 4;    FourStates: TYPE =       PACKED ARRAY [0..statesPerWord) OF VMDataInternal.SwapUnitState;    assertSize: BOOLEAN [TRUE..(SIZE[FourStates] = 1)] = TRUE;    speedUniformPtr: LONG POINTER TO FourStates;        ProcessSwapUnits ¬ LOOPHOLE[LONG[@AwaitProcessSwapUnitsRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitProcessSwapUnitsRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return result; Await new request; Process it;      [interval, unmappedProcessing, runProcessing, swapUnitProcessor, vacantProcessing] ¬        AwaitProcessSwapUnitsRequest[nextPage, aborted];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitProcessSwapUnitsRequest, PrincOps.Port].dest.frame];      aborted ¬ FALSE;  -- assume.      BEGIN  --scope of Return      BEGIN  --scope of ReturnAborted      pageBeingProcessed ¬ interval.page;      IF interval.count = 0 THEN GOTO Return;      pageAfterInterval ¬ interval.page + interval.count;      IF pageAfterInterval > pageTop THEN Bug[beyondVM];      {      pRun: PRun = Find[pageBeingProcessed, rBase, pRunTop].pRun; lpRun ¬ @rBase[pRun]};      DO  --process runs until all swap units in interval have been processed or we are aborted        -- We either find some pages not requiring action and advance past them, or find some requiring action and take that action.        pageAfterRun ¬ lpRun.interval.page + lpRun.interval.count;        pageRunStop ¬ MIN[pageAfterInterval, pageAfterRun];        IF pageBeingProcessed < lpRun.interval.page THEN          BEGIN  --pageBeingProcessed is unmapped          IF unmappedProcessing = errorIfUnmapped THEN Bug[swapUnitsUnmapped]          ELSE            BEGIN  --lpRun points to the first run after pageBeingProcessed            IF lpRun.interval.page >= pageAfterInterval THEN  --(remainder of) interval is unmapped              {pageBeingProcessed ¬ pageAfterInterval; GO TO Return}            ELSE pageBeingProcessed ¬ lpRun.interval.page;  --skip over unmapped VM            END;          END;		BEGIN		--ASSERT: pageBeingProcessed is the first interesting mapped page of this run.        runBeingProcessed ¬ lpRun;  -- in case swapUnitProcessor needs it. 	--Skip all mapped pages that are out.         --If entire interval is out, need to skip past some extra processing in this block	SELECT vacantProcessing FROM 	  processVacant => NULL;	  skipVacant => BEGIN	    wholeRun: BOOLEAN =	      (pageBeingProcessed = lpRun.interval.page) AND	      (pageRunStop >= pageAfterRun);	    IF lpRun.maybePartlyIn THEN 	      WHILE pageBeingProcessed < pageRunStop DO	        IF PageMap.IsMapped[pageBeingProcessed] THEN EXIT	        ELSE pageBeingProcessed ¬ pageBeingProcessed + 1;	        REPEAT	        FINISHED =>		  BEGIN		  IF wholeRun THEN lpRun.maybePartlyIn ¬ FALSE;		  GOTO SkipProcessing;		  END;	        ENDLOOP	    ELSE GOTO SkipProcessing; -- the run was known all-vacant	    END;	  ENDCASE => Bug[noSuchCase];	            -- The body of the select below processes the swap units wholly or        -- partially contained in [pageBeingProcessed..pageRunStop),        -- advancing pageBeingProcessed past swap units as they are sucessfully processed.	 	          WITH run: lpRun SELECT FROM          unitary =>            BEGIN            --swap unit is coextensive with run            [newState, continuation] ¬ swapUnitProcessor[              pageSwapUnit: run.interval.page,              pageAfterSwapUnit: run.interval.page + run.interval.count,              state: run.swapUnitState];            IF continuation = abortIgnoreNewState THEN GO TO ReturnAborted;            run.swapUnitState ¬ newState;            pageBeingProcessed ¬ run.interval.page + run.interval.count;            IF continuation = abortUseNewState THEN GO TO ReturnAborted;            END;  --unitary case          uniform =>            BEGIN            uniformSUData: LONG POINTER TO UniformSwapUnitData = @swapUnitBase[              run.uniformSwapUnitData];            uniformSUSize: Space.SwapUnitSize = uniformSUData.swapUnitSize;            curSUSize: Space.SwapUnitSize;  -- size of current swap unit.            pageEndFirstSU: VM.PageNumber =              run.interval.page + uniformSUData.firstSwapUnitSize;            swapUnitIndex, lastInRun, j: CARDINAL;            -- Adjust pageBeingProcessed to beginning of containing swap unit:            IF pageBeingProcessed < pageEndFirstSU THEN              BEGIN  -- first (funny-sized) swap unit.              swapUnitIndex ¬ 0;              pageBeingProcessed ¬ run.interval.page;              curSUSize ¬ uniformSUData.firstSwapUnitSize;              END            ELSE              BEGIN  -- later (uniform-sized) swap unit              swapUnitIndex ¬                CARDINAL[pageBeingProcessed - pageEndFirstSU]/uniformSUSize + 1;              pageBeingProcessed ¬                pageEndFirstSU + (swapUnitIndex - 1)*uniformSUSize;              curSUSize ¬ uniformSUSize;              END;            -- ASSUMES that there is at least one swap unit to process.            -- The execution speed of the code in the following loop is important.	    	    speedUniformPtr ¬ LOOPHOLE[@uniformSUData.state + 	        SIZE[VMDataInternal.NSwapUnits] + swapUnitIndex/statesPerWord];	    lastInRun ¬ uniformSUData.nSwapUnits-1;            DO	      pageAfterSU: VM.PageNumber =                IF swapUnitIndex = lastInRun THEN pageAfterRun		ELSE pageBeingProcessed + curSUSize;	      j ¬ swapUnitIndex MOD statesPerWord;              [newState, continuation] ¬ swapUnitProcessor[                pageSwapUnit: pageBeingProcessed, pageAfterSwapUnit: pageAfterSU,                state: speedUniformPtr[j]];              IF continuation = abortIgnoreNewState THEN GO TO ReturnAborted;              speedUniformPtr[j] ¬ newState;              pageBeingProcessed ¬ pageAfterSU;              IF continuation = abortUseNewState THEN GO TO ReturnAborted;              IF --UNTIL-- pageBeingProcessed >= pageRunStop THEN EXIT;              curSUSize ¬ uniformSUSize;  -- (uniform size after first one)              swapUnitIndex ¬ swapUnitIndex + 1;	      IF j = 3 THEN speedUniformPtr ¬ speedUniformPtr + 1;              ENDLOOP;            END;  --uniform--          irregular =>            BEGIN            irregularSUData: LONG POINTER TO IrregularSwapUnitData =              @swapUnitBase[run.irregularSwapUnitData];            swapUnitIndex: CARDINAL ¬ 0;            -- Find the index of the swapUnit containing pageBeingProcessed:            currentPage: VM.PageNumber ¬ run.interval.page;            DO	      --extracting just the swapUnit vs. swapUnit.size 	      --produces better code from the compiler	      swapUnit: SwapUnitSizeAndState ¬ irregularSUData[swapUnitIndex];              currentPage ¬ currentPage + swapUnit.size;              IF currentPage > pageBeingProcessed THEN {                pageBeingProcessed ¬  -- back up to beginning of desired swap unit                  currentPage - swapUnit.size;                EXIT};              swapUnitIndex ¬ swapUnitIndex + 1;              ENDLOOP;            WHILE pageBeingProcessed < pageRunStop DO	      swapUnit: SwapUnitSizeAndState ¬ irregularSUData[swapUnitIndex];              countSwapUnitPages ¬ swapUnit.size;              [newState, continuation] ¬ swapUnitProcessor[                pageSwapUnit: pageBeingProcessed,                pageAfterSwapUnit: pageBeingProcessed + countSwapUnitPages,                state: swapUnit.state];              IF continuation = abortIgnoreNewState THEN GO TO ReturnAborted;	      --compiler generates better code if assign the whole swapUnit vs 	      --irregularSUData[swapUnitIndex].state ¬ newstate	      swapUnit.state ¬ newState;  	      irregularSUData[swapUnitIndex] ¬ swapUnit;              pageBeingProcessed ¬ pageBeingProcessed + countSwapUnitPages;              IF continuation = abortUseNewState THEN GOTO ReturnAborted;              swapUnitIndex ¬ swapUnitIndex + 1;              ENDLOOP;            END;  --irregular case          ENDCASE => Bug[noSuchCase];		  	--end of internal block needed to skip over some time-consuming processing	--when a mapped, but out specified interval is found   	EXITS	  SkipProcessing => NULL;	END;          IF pageBeingProcessed >= pageAfterInterval THEN GOTO Return;        --ASSERT: interval says to process next run.        SELECT runProcessing FROM          abortWhenSpansRuns => GO TO ReturnAborted;          errorIfSpansRuns => Bug[intervalSpansRuns];          spanRuns => NULL;          ENDCASE => Bug[noSuchCase];        lpRun ¬ lpRun + SIZE[Run];        ENDLOOP;  --processing runs      EXITS ReturnAborted => {aborted ¬ TRUE; GOTO Return};      END;  --scope of AbortAndReturn      EXITS        Return =>  -- "argument" is pageBeingProcessed.          nextPage ¬ MAX[            interval.page,  -- not before start of interval.            MIN[            pageAfterInterval,  -- not exceeding end of interval.            pageBeingProcessed]];      END;  --scope of Return--      swapUnitRunsProcessed ¬ swapUnitRunsProcessed.SUCC;      ENDLOOP;  --FOREVER--    END;  --ProcessSwapUnits--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --Utility Procedures:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- AbortIfUnavailable: SwapUnitProcessor  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --AbortIfUnavailable: Aborts if the swap unit is checked out.  AbortIfUnavailable: PUBLIC SwapUnitProcessor;  --an indirect control link to the port is set in InitializeAbortIfUnavailable    InitializeAbortIfUnavailable: PROCEDURE    RETURNS --must match port args-- [      state: SwapUnitState, continuation: Continuation] =    BEGIN        AwaitAbortIfUnavailableRequest: --RESPONDING-- PORT [      newState: SwapUnitState, continuation: Continuation]      RETURNS [	pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];    --args/results must match SwapUnitProcessor (but swapped)        AbortIfUnavailable ¬ LOOPHOLE[LONG[@AwaitAbortIfUnavailableRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitAbortIfUnavailableRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return; Await new request; Process it:      [state: state] ¬ AwaitAbortIfUnavailableRequest[state, continuation];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitAbortIfUnavailableRequest, PrincOps.Port].dest.frame];      continuation ¬        IF state.availability = busy THEN abortIgnoreNewState ELSE continue;      ENDLOOP;  --FOREVER--    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --AdjustSwapUnitTablePointers  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AdjustSwapUnitTablePointers: PUBLIC PROCEDURE [    pRun: PRun, pRunFollowing: PRun, nSwapUnitWords: INTEGER];    --indirect control link to the PORT is set in InitializeAdjustSwapUnitTablePointers  InitializeAdjustSwapUnitTablePointers: PROCEDURE =    BEGIN    --"arguments":    pRun: PRun;  --pointer to first run entry with swap unit table pointers    pRunFollowing: PRun;  --pointer to first entry beyond the scope of the adjustment    nSwapUnitWords: INTEGER;  --size of adjustment        AwaitAdjustSwapUnitTablePointersRequest: --RESPONDING-- PORT      RETURNS [pRun: PRun, pRunFollowing: PRun, nSwapUnitWords: INTEGER];      --args/results match AdjustSwapUnitTablePointers (but swapped).         AdjustSwapUnitTablePointers ¬       LOOPHOLE[LONG[@AwaitAdjustSwapUnitTablePointersRequest]];    LOOPHOLE[AwaitAdjustSwapUnitTablePointersRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    -- set my PORT call to return to my caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [pRun, pRunFollowing, nSwapUnitWords] ¬        AwaitAdjustSwapUnitTablePointersRequest[];      Frame.SetReturnFrame[        LOOPHOLE[AwaitAdjustSwapUnitTablePointersRequest, PrincOps.Port].dest.frame];      WHILE pRun < pRunFollowing DO        WITH run: rBase[pRun] SELECT FROM          unitary => NULL;          uniform =>            run.uniformSwapUnitData ¬ run.uniformSwapUnitData + nSwapUnitWords;          irregular =>            run.irregularSwapUnitData ¬              run.irregularSwapUnitData + nSwapUnitWords;          ENDCASE => Bug[noSuchCase];        pRun ¬ pRun + SIZE[Run];        ENDLOOP;      ENDLOOP;  --DO FOREVER--    END;  --AdjustSwapUnitTablePointers--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --Find  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<<  Find: PUBLIC PROCEDURE [page: VM.PageNumber]    RETURNS [found: BOOLEAN, pRun: PRun];    -- an indirect control link to the PORT is set in InitializeFind  InitializeFind: PROCEDURE RETURNS [found: BOOLEAN, pRun: PRun] =    BEGIN    --"arguments":    page: VM.PageNumber;    --local variables:    indexRunFirst: CARDINAL = (pRunFirst - FIRST[PRun])/SIZE[Run];    indexRun, indexRunLow, indexRunHigh: CARDINAL;    pRunMru: PRun ¬ pRunFirst;  -- The most recently found run.     pageComp: VM.PageNumber;        AwaitFindRequest: --RESPONDING-- PORT [found: BOOLEAN, pRun: PRun]      RETURNS [page: VM.PageNumber];  -- args/results match Find (but swapped).          Find ¬ LOOPHOLE[LONG[@AwaitFindRequest]];    LOOPHOLE[AwaitFindRequest, PrincOps.Port].dest ¬ PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    -- set my PORT call to return to my caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      page ¬ AwaitFindRequest[found, pRun];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitFindRequest, PrincOps.Port].dest.frame];      IF pRunMru < pRunFirst THEN Bug[pRunMruOffLowEnd];      IF pRunMru > pRunTop THEN  --        pRunMru ¬ pRunFirst;  -- assures pRunMru is still reasonable.      IF page >= pageTop THEN Bug[beyondVM];      BEGIN  --scope of SameAsLastTime--      IF page IN        [rBase[           pRunMru].interval.page..rBase[pRunMru].interval.page + rBase[                                     pRunMru].interval.count) THEN        GO TO SameAsLastTime;      vmDatabaseFullSearches ¬ vmDatabaseFullSearches.SUCC;      indexRunLow ¬ indexRunFirst;      indexRunHigh ¬ (pRunTop - FIRST[PRun])/SIZE[Run];      DO  --UNTIL search terminates--        indexRun ¬ (indexRunLow + indexRunHigh)/2;	IF (pageComp ¬ rBase[FIRST[PRun] + indexRun*SIZE[Run]].interval.page) > page        THEN indexRunHigh ¬ indexRun - 1          -- note that indexRunHigh, a CARDINAL, might be indexDescLow-1 here.         ELSE IF page > pageComp THEN indexRunLow ¬ indexRun + 1 ELSE GO TO Exact;        IF indexRunHigh < indexRunLow THEN GO TO NotExact;        ENDLOOP;  --DO UNTIL search terminates--      EXITS        Exact => {pRun ¬ FIRST[PRun] + indexRun*SIZE[Run]; found ¬ TRUE};        NotExact =>          -- Assert: page>"indexRunHigh".page AND page<"indexRunHigh+1".page AND indexRunHigh+1 = indexRunLow.          IF indexRunLow = indexRunFirst THEN {pRun ¬ pRunFirst; found ¬ FALSE}          ELSE            BEGIN            pRun ¬ FIRST[PRun] + indexRunHigh*SIZE[Run];            IF page < rBase[pRun].interval.page + rBase[pRun].interval.count THEN              found ¬ TRUE            ELSE {pRun ¬ pRun + SIZE[Run]; found ¬ FALSE};            END;        SameAsLastTime => {	  pRun ¬ pRunMru;	  found ¬ TRUE;	  vmDatabaseFastSearches ¬ vmDatabaseFastSearches.SUCC};      END;  --scope of SameAsLastTime--      pRunMru ¬ pRun;  -- remember for next time.      ENDLOOP;  --DO FOREVER--    END;>>  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --GetMapUnitBounds  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetMapUnitBounds: PUBLIC PROCEDURE [pRun: PRun]    RETURNS [pRunFirstInMapUnit: PRun, pRunLastInMapUnit: PRun];    --indirect control link to the PORT is set in InitializeGetMapUnitBounds  InitializeGetMapUnitBounds: PROCEDURE    RETURNS [pRunFirstInMapUnit: PRun, pRunLastInMapUnit: PRun] =    BEGIN    -- "argument":    pRun: PRun;        AwaitGetMapUnitBoundsRequest: --RESPONDING-- PORT [      pRunFirstInMapUnit: PRun, pRunLastInMapUnit: PRun] RETURNS [pRun: PRun];      --args/results match GetMapUnitBounds (but swapped).          GetMapUnitBounds ¬ LOOPHOLE[LONG[@AwaitGetMapUnitBoundsRequest]];    LOOPHOLE[AwaitGetMapUnitBoundsRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    -- set my PORT call to return to my caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      pRunFirstInMapUnit ¬ pRunLastInMapUnit ¬ pRun ¬        AwaitGetMapUnitBoundsRequest[pRunFirstInMapUnit, pRunLastInMapUnit];      Frame.SetReturnFrame[        LOOPHOLE[AwaitGetMapUnitBoundsRequest, PrincOps.Port].dest.frame];      --search backwards for start of map unit:      UNTIL rBase[pRunFirstInMapUnit].startOfMapUnit DO        pRunFirstInMapUnit ¬ pRunFirstInMapUnit - SIZE[Run]; ENDLOOP;      --search forwards for end of map unit:      UNTIL rBase[pRunLastInMapUnit].endOfMapUnit DO        pRunLastInMapUnit ¬ pRunLastInMapUnit + SIZE[Run]; ENDLOOP;      IF DEBUG        AND (pRunLastInMapUnit >= pRunTop OR pRunFirstInMapUnit < pRunFirst) THEN        Bug[runTableSmashed];  --error checking      ENDLOOP;  --FOREVER    END;  --GetMapUnitBounds  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --GetSwapUnitTablePointers  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetSwapUnitTablePointers: PUBLIC PROCEDURE [    pRunFirst: PRun, pRunFollowing: PRun]    RETURNS [pSwapUnitFirst: PSwapUnit, pSwapUnitFollowing: PSwapUnit];    --indirect control link to the PORT is set in InitializeGetSwapUnitTablePointers  InitializeGetSwapUnitTablePointers: PROCEDURE    RETURNS [pSwapUnitFirst: PSwapUnit, pSwapUnitFollowing: PSwapUnit] =    BEGIN    --"arguments":    pRunFirst: PRun;    pRunFollowing: PRun;    pRun: PRun;        AwaitGetSwapUnitTablePointersRequest: --RESPONDING-- PORT [      pSwapUnitFirst: PSwapUnit, pSwapUnitFollowing: PSwapUnit]      RETURNS [pRunFirst: PRun, pRunFollowing: PRun];      -- args/results match GetSwapUnitTablePointers (but swapped).          GetSwapUnitTablePointers ¬ LOOPHOLE[LONG[@AwaitGetSwapUnitTablePointersRequest]];          LOOPHOLE[AwaitGetSwapUnitTablePointersRequest, PrincOps.Port].dest ¬  --      -- set my PORT call to return to my caller on call below.      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [pRunFirst, pRunFollowing] ¬ AwaitGetSwapUnitTablePointersRequest[        pSwapUnitFirst, pSwapUnitFollowing];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitGetSwapUnitTablePointersRequest, PrincOps.Port].dest.frame];      pSwapUnitFirst ¬ pSwapUnitFollowing ¬  --        nilPSwapUnit;  -- assume no data.      -- Look for Runs with swap unit data:      FOR pRun ¬ pRunFirst, pRun + SIZE[Run] WHILE pRun < pRunFollowing DO        WITH run: rBase[pRun] SELECT FROM          unitary => NULL;  -- continue around loop.          uniform => {            IF pSwapUnitFirst = nilPSwapUnit THEN              pSwapUnitFirst ¬ pSwapUnitFollowing ¬                LOOPHOLE[run.uniformSwapUnitData];            pSwapUnitFollowing ¬              pSwapUnitFollowing + SIZE[                UniformSwapUnitData [swapUnitBase[                  run.uniformSwapUnitData].nSwapUnits]]};          irregular => {            IF pSwapUnitFirst = nilPSwapUnit THEN              pSwapUnitFirst ¬ pSwapUnitFollowing ¬                LOOPHOLE[run.irregularSwapUnitData];            pSwapUnitFollowing ¬              pSwapUnitFollowing + SIZE[                IrregularSwapUnitData [swapUnitBase[                  run.irregularSwapUnitData].nSwapUnits]]};          ENDCASE => Bug[noSuchCase];        ENDLOOP;      ENDLOOP;  --FOREVER--    END;  --GetSwapUnitTablePointers  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --GetTransferProc  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetTransferProc: PUBLIC PROCEDURE [    transferProcID: TransferProcID, deleteOrRetain: DeleteOrRetain ¬ retainID]    RETURNS [transferProc: BackingStore.TransferProc];    --indirect control link to PORT is set in InitializeGetTransferProc  InitializeGetTransferProc: PROCEDURE    RETURNS [transferProc: BackingStore.TransferProc] =    BEGIN    --"arguments":    transferProcID: TransferProcID;    deleteOrRetain: DeleteOrRetain;        AwaitGetTransferProcRequest: --RESPONDING-- PORT [      transferProc: BackingStore.TransferProc]      RETURNS [transferProcID: TransferProcID, deleteOrRetain: DeleteOrRetain];      -- args/results match GetTransferProc (but swapped).        --local variables:    precedingNode: PTransferProcDesc;    targetNode: PTransferProcDesc;        GetTransferProc ¬ LOOPHOLE[LONG[@AwaitGetTransferProcRequest]];    LOOPHOLE[AwaitGetTransferProcRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    -- set my PORT call to return to my caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [transferProcID, deleteOrRetain] ¬ AwaitGetTransferProcRequest[        transferProc];      Frame.SetReturnFrame[        LOOPHOLE[AwaitGetTransferProcRequest, PrincOps.Port].dest.frame];      precedingNode ¬ transferProcTable;      DO  --UNTIL precedingNode is predecessor of desired node        targetNode ¬ transferProcDescBase[precedingNode].nextTransferProcDesc;        IF DEBUG          AND            ((targetNode = nilPTransferProcDesc)              OR                (transferProcDescBase[targetNode].transferProcID >                  transferProcID)) THEN Bug[transferProcTableTrashed];        IF transferProcDescBase[targetNode].transferProcID = transferProcID THEN          EXIT;  --found it        precedingNode ¬ targetNode;        ENDLOOP;      transferProc ¬ transferProcDescBase[targetNode].transferProc;      IF deleteOrRetain = deleteID THEN        BEGIN        IF transferProcDescBase[targetNode].referenceCount > 1 THEN          transferProcDescBase[targetNode].referenceCount ¬            transferProcDescBase[targetNode].referenceCount - 1;<<This ELSE clause is removed pending resolution of what makes the referenceCount increment more than it decrements until it overflows.  This results in a bogus referenceCount = 0 which causes the entry to be taken off the list, then resulting in Bug[transferProcTableTrashed] on next reference. (SS AR 13155)  This solution depends on observed behavior of current Pilot clients, that the transferProc list is stable, thus limiting the impact of never removing an entry.        ELSE          BEGIN          transferProcDescBase[precedingNode].nextTransferProcDesc ¬            transferProcDescBase[targetNode].nextTransferProcDesc;          IF freeMeTransferProcDesc # nilPTransferProcDesc THEN Bug[freeMeFull];          freeMeTransferProcDesc ¬ targetNode;          END;>>        END;      ENDLOOP;  --DO FOREVER--    END;  --GetTransferProc  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --CreateTransferProcID  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --Implementation note: the list is kept sorted according to ID and a sequential scan in performed.  The assumptions here are that the list will be short (on the order of a half-dozen entries) and that this is a cheap way to keep track of IDs available for assignment.  If the list were of significant size, the search could be improved relatively cheaply by the use of a mru-pointer.  CreateTransferProcID: PUBLIC PROCEDURE [transferProc: BackingStore.TransferProc]    RETURNS [transferProcID: TransferProcID];    -- an indirect control link to the PORT is set in InitializeCreateTransferProcID  InitializeCreateTransferProcID: PROCEDURE    RETURNS [transferProcID: TransferProcID] =    BEGIN    -- "arguments":    transferProc: BackingStore.TransferProc;        AwaitCreateTransferProcIDRequest: --RESPONDING-- PORT [      transferProcID: TransferProcID]      RETURNS [transferProc: BackingStore.TransferProc];      --args/results match CreateTransferProcID (but swapped).        -- local variables:    precedingNode: PTransferProcDesc;  -- node ahead of currentNode    currentNode: PTransferProcDesc;        CreateTransferProcID ¬ LOOPHOLE[LONG[@AwaitCreateTransferProcIDRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitCreateTransferProcIDRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return result;  Await new request;  Process it      [transferProc] ¬ AwaitCreateTransferProcIDRequest[transferProcID];      Frame.SetReturnFrame[        LOOPHOLE[AwaitCreateTransferProcIDRequest, PrincOps.Port].dest.frame];      BEGIN  --scope of Return--      currentNode ¬ transferProcTable;      DO  -- search for transferProc:        currentNode ¬ transferProcDescBase[currentNode].nextTransferProcDesc;        IF --UNTIL-- currentNode = nilPTransferProcDesc THEN EXIT;        IF transferProcDescBase[currentNode].transferProc = transferProc THEN          BEGIN  -- found transferProc          transferProcDescBase[currentNode].referenceCount ¬            transferProcDescBase[currentNode].referenceCount + 1;          transferProcID ¬ transferProcDescBase[currentNode].transferProcID;          GOTO Return;          END;        ENDLOOP;      --ASSERT: transferProc is not in the list.      -- Find an ID-gap in which to create it: (goes at end if none)      precedingNode ¬ transferProcTable;      DO        currentNode ¬ transferProcDescBase[precedingNode].nextTransferProcDesc;        IF --UNTIL-- currentNode = nilPTransferProcDesc  -- end of list          OR transferProcDescBase[currentNode].transferProcID >            transferProcDescBase[precedingNode].transferProcID + 1 THEN  -- gap in ID's          BEGIN  -- create transferProcDesc following precedingNode:          transferProcID ¬ SUCC[            transferProcDescBase[precedingNode].transferProcID];          IF transferProcID > LAST[TransferProcID] THEN            Bug[tooManyTransferProcDescs];          IF useMeTransferProcDesc = nilPTransferProcDesc THEN            Bug[noTransferProcDesc];          transferProcDescBase[useMeTransferProcDesc] ¬ [            transferProcID: transferProcID, referenceCount: 1,            transferProc: transferProc,            nextTransferProcDesc: transferProcDescBase[            precedingNode].nextTransferProcDesc];          transferProcDescBase[precedingNode].nextTransferProcDesc ¬            useMeTransferProcDesc;          useMeTransferProcDesc ¬ nilPTransferProcDesc;          GOTO Return;          END;        precedingNode ¬ currentNode;        ENDLOOP;      --ASSERT: Can't get here.      EXITS Return => NULL;      END;  --scope of Return--      ENDLOOP;  --FOREVER--    END;  --  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --MakeRoomInSwapUnitTable  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  MakeRoomInSwapUnitTable: PUBLIC PROCEDURE [    pSwapUnit: PSwapUnit, nSwapUnitWords: CARDINAL, okayToAllocateRealMem: BOOLEAN]    RETURNS [okay: BOOLEAN];    --an indirect control link to the port is set in InitializeMakeRoomInSwapUnitTable          InitializeMakeRoomInSwapUnitTable: PROCEDURE    RETURNS --must match port args-- [okay: BOOLEAN] =    BEGIN        AwaitMakeRoomInSwapUnitTableRequest: --RESPONDING-- PORT [okay: BOOLEAN]      RETURNS [pSwapUnit: PSwapUnit, nSwapUnitWords: CARDINAL,        okayToAllocateRealMem: BOOLEAN];      --args/results match MakeRoomInSwapUnitTable (but reversed)        --"arguments":    pSwapUnit: PSwapUnit;    nSwapUnitWords: CARDINAL;    okayToAllocateRealMem: BOOLEAN;    --local variables:    pagesNeeded: VM.PageCount;  -- additional pages of real memory needed    MakeRoomInSwapUnitTable ¬ LOOPHOLE[LONG[@AwaitMakeRoomInSwapUnitTableRequest]];    LOOPHOLE[AwaitMakeRoomInSwapUnitTableRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    --set my PORT call to return to my caller on call below    DO  --FOREVER--      --return; await new request; process it      [pSwapUnit, nSwapUnitWords, okayToAllocateRealMem] ¬        AwaitMakeRoomInSwapUnitTableRequest[okay];      Frame.SetReturnFrame[        LOOPHOLE[AwaitMakeRoomInSwapUnitTableRequest, PrincOps.Port].dest.frame];      okay ¬ TRUE;      SELECT (pSwapUnitNextFree + nSwapUnitWords) FROM  --check if more real memory is needed:        <= pSwapUnitMaxInRealMem => NULL;  -- no allocation needed        IN (pSwapUnitMaxInRealMem..pSwapUnitMaxInVM] =>  --within VM but real memory allocation needed          IF okayToAllocateRealMem THEN	    BEGIN  --figure out the number of pages real memory to allocate            pagesNeeded ¬ Space.PagesFromWords[              pSwapUnitNextFree + nSwapUnitWords - pSwapUnitMaxInRealMem];            VMData.AllocateReservedMStoreInternal[interval: [              page: pageSwapUnitTable + countSwapUnitTablePagesMapped,              count: pagesNeeded],	      resident: TRUE];            countSwapUnitTablePagesMapped ¬              countSwapUnitTablePagesMapped + CARDINAL[pagesNeeded];            pSwapUnitMaxInRealMem ¬              pSwapUnitMaxInRealMem +                Environment.wordsPerPage*CARDINAL[pagesNeeded];            END	  ELSE okay ¬ FALSE;        ENDCASE => Bug[outOfVMForSwapUnitTable];      -- open up table at insertion point by moving data:      IF okay THEN        BEGIN	pSwapUnitNextFree ¬ pSwapUnitNextFree + nSwapUnitWords;        Inline.LongCOPYReverse[          from: @swapUnitBase[pSwapUnit],          to: @swapUnitBase[pSwapUnit + nSwapUnitWords],          nwords: pSwapUnitNextFree - pSwapUnit - nSwapUnitWords];	END;      ENDLOOP;  --FOREVER--    END;  END.LOG26-Oct-82 17:41:26   LXD      	Created file.29-Nov-82 14:34:51   WDK        ProcessSwapUnits[unitary] failed to advance pageBeingProcessed. Move ProcessSwapUnits's Find out of loop. Loop end logic. Name changes. Redo GetSwapUnitTablePointers. Minor reworks. AbortIfCheckedOut moved here from VMDataImpl and renamed to AbortIfUnavailable. Simplified/shortened CreateTransferProcID. GetSwapUnitTablePointers was wrong for irreg s.u. ProcessSwapUnits handled first uniform swap unit size wrong. 3-Dec-82 11:02:07   WDK     	Made compatible with new VMDataInternal.23-Dec-82  9:35:28   AWL         NewSpace => Space, KernelSpaceUsage => KernelSpaceUsage.  Long page numbers.18-Feb-83 16:50:40   WDK     	Torpedo usage of Inline.LowHalf.25-Mar-83 18:32:32   WDK        Add abortUseNewState option to SwapUnitProcessor. ProcessSwapUnits confused about size of last fragment of uniform swap unit when interval spans runs. 4-Apr-83  9:12:20   WDK     	Added perf counters.28-Apr-83 13:45:57   WDK     	Export perf counters to ResMemPerf, not VMPerf.12-Jul-83 17:40:44   JXP   	Fix up port stuff. 4-Aug-83 11:39:27   WDK     	Get LongCOPYReverse from Inline. 8-Feb-84 16:15:30   EKN        Rearranged InitializeProcessSwapUnits to accommodate for non- vacantProcessing.13-Feb-84 15:48:32   CAJ        Add arg okayToAllocateRealMem and return value okay to MakeRoomInSwapUnitTable.16-Feb-84  9:05:49   EKN  	Performance fixes in InitializeProcessSwapUnits16-Feb-84 16:00:22   RES  /AXD    	Speed up uniform inner loop of ProcessSwapUnits.15-Mar-84 17:13:51   EKN  	Add RETURNS clause to InitializeMakeRoomInSwapUnitTable so it matches its port's arguments.18-Jun-84 13:33:53   KEK    	utilize "maybePartlyIn" field of Run to skip the loop in the skipVacant SELECT inside ProcessSwapUnits (performance fix). 9-Jul-84 13:40:52   KEK    	twiddle the PORT interfaces to use the VARs in the definition. 2-Aug-84 18:07:51   EKN  Add back lost edit made on:   14-Jun-84 16:51:07  A twiddle to inner loop of initializeFind to save one tiny    instruction.17-Aug-84 11:11:45   KEK    	add "resident" argument to MStore.Allocate and AllocateReservedMStoreInternal (for PC emulation).27-Nov-84 11:44:51   KEK    	simplifying InitializeGetTransferProc code... (ar6032)10-Jul-86 17:24:28   ET		Put PORTS in local frames.21-Sep-88 12:04:36   TxH	made changes for microcoded Find17-Jan-89 19:43:25   RSV        Turn DEBUG boolean off.12-Oct-89 11:39:34   TXT	get workaround for SSAR 13155. The following description come from the one in Pilot13.0/14.0  [Commented out removal of a transferProcTable entry once its reference count had gone to 0 (workaround for referenceCount overflow problem).]
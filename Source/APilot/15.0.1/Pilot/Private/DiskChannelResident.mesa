-- Copyright (C) 1984, 1985, 1986, 1988, 1989  by Xerox Corporation. All rights reserved. -- DiskChannelResident.mesa     17-Jan-89 16:13:15 by RSV  <<This monitor contains all of the procedures that ARE on thepage fault path. Its code and data must be resident.The procedures implemented here are:    DeviceError.AwaitPilotDiskError    DiskChannel.DoDirectIO		    DiskChannel.DoIO    DiskChannel.GetDrive    DiskChannel.GetDriveAttributes    DiskChannelInternal.CalculatePageAddress    DiskChannelInternal.ChangeDriveChangeCount    DiskChannelInternal.ChangeDriveState    DiskChannelInternal.ChangeDriveType    DiskChannelInternal.ChangeScheduler    StoreDriverStartChain.StartPossible Future Improvements:The procedures that are exported to DiskChannelInternal (CalculatePageAddress,ChangeDriveChangeCount, ChangeDriveState, ChangeDriveType andChangeScheduler) are only called by DiskChannelSwappable. Exceptfor CalculatePageAddress, they are called infrequently.It might be agood idea to  have these procedures "swap" by having DiskChannelSwappableexplicitly pin the procedure before calling it. >>DIRECTORY  Device USING [nullType, Type],  DeviceError USING [],  DeviceTypes USING [anyPilotDisk],  DiskChannel USING [    DiskPageCount, DirectOperation, DiskPageNumber, DriveState, IORequestHandle,    IOStatus, InspectDiskShape, Mode, Tries],  DiskChannelInternal USING [    DiskChannelPrivate, DriveDataArray, DriveObject, Handle, Operation,    OperationPtr],  DiskDriversPerf USING [],  DiskScheduler USING [    DriveData, DriveProc, GetNextRequestProc, RequestHandle, RequestObject,    ScheduleProc, Scheduler, TransitionProc],  Environment USING [Base, first64K, LongPointerFromPage, PageNumber],  Inline USING [LongDivMod, LowHalf],  PilotDisk USING [Handle],  PilotDiskFace USING [    Command, ControllerHandle, DeviceHandle, DiskAddress, GetControllerAttributes,    GetNextController, GetNextDevice, GlobalStatePtr, InitializeController,    InitializeCleanup, InitializeTrackBuffer, Initiate, nullControllerHandle,    nullDeviceHandle, Operation, operationAlignment, OperationPtr, operationSize,    PagesForTrackBuffering, Poll, Status, unknownAttribute],  PilotSwitchesExtra9 USING [    disableTrackCaching, trackCachingSwitch1, trackCachingSwitch2],  Process USING [Detach, DisableAborts, MsecToTicks, Priority, SetTimeout],  ProcessInternal USING [GetPriority, SetPriority],  ProcessOperations USING [Enter, Exit, Notify, ReEnter, Wait],  ProcessPriorities USING [diskInterruptPriority],  PSB USING [NoTimeout],  ResidentHeap USING [MakeNode],  RuntimeInternal USING [Bug],  SpecialRuntime USING [AllocateNakedCondition],  StoreDriverStartChain USING [Start],  System USING [GetClockPulses, Pulses, switches],  TrackBufferMemory USING [Allocate],  VM USING [DoneWithStateVector, GuardStateVector],  Zone USING [Status];DiskChannelResident: MONITOR  IMPORTS    DiskChannel, Inline, Environment, PilotDiskFace, Process, ProcessInternal,    ProcessOperations, ResidentHeap, RuntimeInternal, SpecialRuntime,    remainingDrivers: StoreDriverStartChain, System, TrackBufferMemory, VM  EXPORTS    DeviceError, DiskChannel, DiskChannelInternal, DiskDriversPerf, DiskScheduler,    StoreDriverStartChain =  BEGIN  -- Number of Operations allocated to each drive. If a request is made to a  -- drive that has all of its Operations in use, that request wll be scheduled.  -- A value of two is basically double-buffering.  defaultCountOperationsPerDrive: CARDINAL = 2;  enoughDefaultOps: BOOLEAN [TRUE..TRUE] = (defaultCountOperationsPerDrive >= 1);  -- The "drive default retry algorithm" is to try the operation with defaultTries.  defaultTries: PUBLIC DiskChannel.Tries ¬ 24;  -- numbers of buffers for various track buffering switch combinations.  largeTrackBuffer:   CARDINAL = 32;  mediumTrackBuffer:  CARDINAL = 16;  smallTrackBuffer:   CARDINAL = 8;  defaultTrackBuffer: CARDINAL = 12;  -- Channel TYPEs and Variables:  Handle: PUBLIC TYPE = DiskChannelInternal.Handle;  ChannelOperationPtr: TYPE = LONG POINTER TO DiskChannelInternal.Operation;  ChannelOperation: TYPE = DiskChannelInternal.Operation;  DiskOperation: TYPE = PilotDiskFace.Operation;  DiskOperationPtr: TYPE = LONG POINTER TO PilotDiskFace.Operation;  DiskChannelPrivate: PUBLIC TYPE = DiskChannelInternal.DiskChannelPrivate;  -- Device error information:  errorData: RECORD [    totalGoodCompletions: LONG CARDINAL ¬ 0,    totalRetries: LONG CARDINAL ¬ 0,    errorsSinceLastReport: CARDINAL ¬ 0,    logAllOpsIfNotZero: CARDINAL ¬ 0,    last: RECORD [      retries: CARDINAL,      status: PilotDiskFace.Status,      diskOperation: PilotDiskFace.Operation,      deviceOrdinal: CARDINAL,      deviceType: Device.Type] ¬ NULL,    error: CONDITION];  -- Performance data exported to DiskDriversPerf:  numberRequests: PUBLIC LONG CARDINAL ¬ 0;  numberScheduled: PUBLIC LONG CARDINAL ¬ 0;  numberInScheduler: PUBLIC CARDINAL ¬ 0;  waitPulses: PUBLIC System.Pulses ¬ [0];  -- Performance data not exported anywhere at the moment:  bufferPages: CARDINAL ¬ 0;  -- Debugging information  trackBufferPage: Environment.PageNumber;  -- Drive types and variables:  Drive: TYPE = LONG POINTER TO DriveObject;  nullDrive: Drive = NIL;  DriveObject: PUBLIC TYPE = DiskChannelInternal.DriveObject;  firstDrive: PUBLIC Drive ¬ NIL;  countDrives: PUBLIC CARDINAL ¬ 0;  operationSize: PUBLIC CARDINAL ¬    -- (accounts for extension hung on PilotDiskFace.Operation.)    SIZE[ChannelOperation] + PilotDiskFace.operationSize - SIZE[      PilotDiskFace.Operation];  diskOpWordAlignment: PUBLIC CARDINAL ¬    SELECT PilotDiskFace.operationAlignment FROM      a1 => 1, a2 => 2, a4 => 4, a8 => 8, ENDCASE => 16;  -- Scheduling types and variables  CompletionStatus: TYPE = {scheduled, submitted, completed, direct};  -- Meaningful if you find DoIO or DoDirectIO waiting on ioComplete:  --   scheduled => the request is in the scheduler  --   submitted => the request is in the disk face, operation was DoIO  --   completed => the request has been completed and ioComplete notified  --   direct => the request is in the disk face, operation was DoDirectIO  Prefix: PUBLIC TYPE = POINTER TO RequestState;  RequestState: TYPE = MACHINE DEPENDENT RECORD [    completionStatus(0:0..7): CompletionStatus,  -- what progress has the I/O request made?    retryIO(0:8..15): BOOLEAN,  -- DOIO: retry operation if error; DoDirectIO: TRASH    status(1): DiskChannel.IOStatus,  -- value returned by ControllerProcess    countDone(2):  --      -- DoIO: zeroed by DoIO, updated by ControllerProcess;      -- DoDirectIO: set by ControllerProcess      DiskChannel.DiskPageCount,    channel(4): POINTER TO Handle,  -- DoIO: the channel; DoDirectIO: NIL    ioComplete(5): CONDITION];  -- the CONDITION the request waits on  ioCompletePrototype: CONDITION;  CVar: TYPE = POINTER TO ARRAY [0..SIZE[CONDITION]) OF WORD;  scheduler: PUBLIC DiskScheduler.Scheduler ¬ [    DefaultTransition, DefaultDrive, DefaultSchedule, DefaultGetNextRequest];  -- Other types and variables  countSubmitted: CARDINAL ¬ 0;  -- The number of requests which have been submitted  --    to the DiskFace but are not yet completed.  PilotDiskTries: TYPE = (0..400B];  maxTries: PilotDiskTries = LAST[PilotDiskTries];  noTries: PilotDiskTries = FIRST[PilotDiskTries];  -- TEMP until AR12076 fixed.  Value: PROCEDURE [pulses: System.Pulses] RETURNS [LONG CARDINAL] = INLINE {    RETURN[LOOPHOLE[pulses]]};  offsetDiskOp: CARDINAL;  -- offset of PilotDiskFace.Operation in channel Operation.  BugType: TYPE = {    invalidDrive, noTransfer, overflow, programmingError, residentHeapError,    tooFewOps};  --~~~~~~~~~~~~~~~ Initialization procedures:  RegisterControllers: PROCEDURE =    BEGIN    gsp: PilotDiskFace.GlobalStatePtr;    status: Zone.Status;    controller: PilotDiskFace.ControllerHandle ¬      PilotDiskFace.nullControllerHandle;    nakedNotify: LONG POINTER TO CONDITION;    wakeupMask: WORD;    priorityPrev: Process.Priority;    WHILE (controller ¬ PilotDiskFace.GetNextController[controller]) ~=      PilotDiskFace.nullControllerHandle DO      [gsp, status] ¬ ResidentHeap.MakeNode[        n: PilotDiskFace.GetControllerAttributes[controller], alignment: a16];      IF status # okay THEN Bug[residentHeapError];      [cv: nakedNotify, mask: wakeupMask] ¬ SpecialRuntime.AllocateNakedCondition[        ];      Process.SetTimeout[nakedNotify, Process.MsecToTicks[1000]];      Process.DisableAborts[nakedNotify];      PilotDiskFace.InitializeController[        controller: controller, globalState: gsp, mask: wakeupMask,	nakedCondition:	  IF System.switches[PilotSwitchesExtra9.disableTrackCaching] = down THEN NIL	  ELSE nakedNotify];      PilotDiskFace.InitializeCleanup[controller];      priorityPrev ¬ ProcessInternal.GetPriority[];      ProcessInternal.SetPriority[ProcessPriorities.diskInterruptPriority];      Process.Detach[FORK ControllerProcess[controller, nakedNotify]];      ProcessInternal.SetPriority[priorityPrev];      ENDLOOP;    END;  RegisterDrives: PROCEDURE =    BEGIN    alignMod: CARDINAL =      SELECT PilotDiskFace.operationAlignment FROM        a1 => 1, a2 => 2, a4 => 4, a8 => 8, ENDCASE => 16;    driveOrdinal: CARDINAL;  -- Starts at 0    opsPerDrive: CARDINAL ¬  -- (variable allows experimentation via debugger.)      defaultCountOperationsPerDrive;    device: PilotDiskFace.DeviceHandle;    drive: LONG POINTER TO DriveObject;    rpStorage: Environment.Base RELATIVE POINTER;    status: Zone.Status;    maxNumberBuffers, buffersRequested: CARDINAL;    pagesPerBuffer: CARDINAL;    IF opsPerDrive < 1 THEN Bug[tooFewOps];    driveOrdinal ¬ 0;  -- driveOrdinal have origin at 0.    FOR device ¬ PilotDiskFace.GetNextDevice[PilotDiskFace.nullDeviceHandle],      PilotDiskFace.GetNextDevice[device] UNTIL device =      PilotDiskFace.nullDeviceHandle DO      -- Allocate and init DriveObject:      [rpStorage, status] ¬ ResidentHeap.MakeNode[SIZE[DriveObject], a1];      IF status # okay THEN Bug[residentHeapError];      drive ¬ @Environment.first64K[rpStorage];      drive­ ¬ [        type: DeviceTypes.anyPilotDisk, handle: device,        cylinders: PilotDiskFace.unknownAttribute,        movingHeads: PilotDiskFace.unknownAttribute,        fixedHeads: PilotDiskFace.unknownAttribute,        sectorsPerTrack: PilotDiskFace.unknownAttribute,        driveOrdinal: driveOrdinal, state: inactive, changeCount: 0,        diskTypeKnown: FALSE, nPages: 0, tag: 0, next: firstDrive,        schedulerWord: 0, firstFreeOperation: NIL];      IF ~DiskChannel.InspectDiskShape[drive, longReadOnly].knownType THEN        Bug[programmingError];      [pagesPerBuffer, maxNumberBuffers] ¬        PilotDiskFace.PagesForTrackBuffering[device];      buffersRequested ¬ MIN[maxNumberBuffers,	SELECT TRUE FROM	  System.switches[PilotSwitchesExtra9.disableTrackCaching] = down   => 0,	  System.switches[PilotSwitchesExtra9.trackCachingSwitch1] = down AND	    System.switches[PilotSwitchesExtra9.trackCachingSwitch2] = down => largeTrackBuffer,	  System.switches[PilotSwitchesExtra9.trackCachingSwitch1] = down   => mediumTrackBuffer,	  System.switches[PilotSwitchesExtra9.trackCachingSwitch2] = down   => smallTrackBuffer,          ENDCASE => defaultTrackBuffer];      bufferPages ¬ buffersRequested * pagesPerBuffer;      IF bufferPages # 0 THEN         BEGIN	trackBufferPage ¬ TrackBufferMemory.Allocate[bufferPages];	PilotDiskFace.InitializeTrackBuffer[	  device, Environment.LongPointerFromPage[trackBufferPage],	  buffersRequested];	END;      firstDrive ¬ drive;      driveOrdinal ¬ driveOrdinal + 1;      -- Allocate Operations and chain to drive's free list:      THROUGH [1..opsPerDrive] DO        pChanOps: ChannelOperationPtr;        [rpStorage, status] ¬	  ResidentHeap.MakeNode[operationSize + alignMod - 1, a1];	IF status # okay THEN Bug[residentHeapError];	pChanOps ¬ @Environment.first64K[rpStorage];	pChanOps ¬	  LOOPHOLE[(((	    LOOPHOLE[pChanOps, LONG CARDINAL] + offsetDiskOp + alignMod-1) /	      alignMod) * alignMod) - offsetDiskOp]; --  align pChanOps.diskOp        pChanOps.nextFree ¬ drive.firstFreeOperation;        drive.firstFreeOperation ¬ pChanOps;        ENDLOOP;      countDrives ¬ SUCC[countDrives];      ENDLOOP;    END;  --RegisterDrives--  Start: PUBLIC --StoreDriverStartChain.-- PROCEDURE = {remainingDrivers.Start[]};  --~~~~~~~~~~~~~~~ PUBLIC procedures:  AwaitPilotDiskError: PUBLIC --DeviceError. ENTRY-- PROC [    logAllOperations: BOOLEAN]    RETURNS [      operation: PilotDiskFace.Operation, deviceType: Device.Type,      deviceOrdinal: CARDINAL, status: PilotDiskFace.Status,      retriesThisOperation: CARDINAL, errorsSinceLastReport: CARDINAL,      totalCompletions: LONG CARDINAL, totalRetries: LONG CARDINAL] =    BEGIN    priorityPrev: Process.Priority ¬ VM.GuardStateVector[      ProcessPriorities.diskInterruptPriority];    copyErrorsSinceLastReport: CARDINAL;    initialTotalCompletions: LONG CARDINAL;    WHILE ~ProcessOperations.Enter[@LOCK] DO NULL ENDLOOP;  -- must follow GuardStateVector    initialTotalCompletions ¬ errorData.totalGoodCompletions;  -- (uninit ok)    IF logAllOperations THEN      errorData.logAllOpsIfNotZero ¬ errorData.logAllOpsIfNotZero + 1;    DO      copyErrorsSinceLastReport ¬ errorData.errorsSinceLastReport;      IF copyErrorsSinceLastReport # 0 THEN EXIT;      IF (errorData.logAllOpsIfNotZero # 0)        AND (initialTotalCompletions # errorData.totalGoodCompletions) THEN EXIT;      ProcessOperations.Wait[@LOCK, @errorData.error, PSB.NoTimeout];      WHILE ~ProcessOperations.ReEnter[@LOCK, @errorData.error] DO NULL ENDLOOP;      ENDLOOP;    IF logAllOperations THEN      errorData.logAllOpsIfNotZero ¬ errorData.logAllOpsIfNotZero - 1;    errorData.errorsSinceLastReport ¬ 0;    -- (Must get return values before exiting monitor.)    operation ¬ errorData.last.diskOperation;    deviceType ¬ errorData.last.deviceType;    deviceOrdinal ¬ errorData.last.deviceOrdinal;    status ¬ errorData.last.status;    retriesThisOperation ¬ errorData.last.retries;    errorsSinceLastReport ¬ copyErrorsSinceLastReport;    totalCompletions ¬ errorData.totalGoodCompletions;    totalRetries ¬ errorData.totalRetries;    ProcessOperations.Exit[@LOCK];  -- must preceed DoneWithStateVector    VM.DoneWithStateVector[priorityPrev];    END;  --AwaitPilotDiskError--  CalculatePageAddress: PUBLIC --DiskChannelInternal. EXTERNAL-- PROCEDURE [    drive: Drive, page: DiskChannel.DiskPageNumber]    RETURNS [PilotDiskFace.DiskAddress] =    BEGIN    addr: PilotDiskFace.DiskAddress;    temp: CARDINAL;    [quotient: addr.cylinder, remainder: temp] ¬ Inline.LongDivMod[      num: page, den: drive.sectorsPerTrack * drive.movingHeads];    addr.sector ¬ temp MOD drive.sectorsPerTrack;    addr.head ¬ temp / drive.sectorsPerTrack;    RETURN[addr];    END;  ChangeDriveChangeCount: PUBLIC --DiskChannelInternal.-- ENTRY PROCEDURE [    drive: Drive, changeCount: CARDINAL] =    -- No need to guard state vector since doesn't WAIT.    {drive.changeCount ¬ changeCount};  ChangeDriveState: PUBLIC --DiskChannelInternal.-- ENTRY PROCEDURE [    drive: Drive, state: DiskChannel.DriveState] =    -- No need to guard state vector since doesn't WAIT.    {drive.state ¬ state};  ChangeDriveType: PUBLIC --DiskChannelInternal.-- ENTRY PROCEDURE [    drive: Drive, type: Device.Type,    cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL] =    -- No need to guard state vector since doesn't WAIT.    BEGIN    drive.type ¬ type;    drive.cylinders ¬ cylinders;    drive.movingHeads ¬ movingHeads;    drive.fixedHeads ¬ fixedHeads;    drive.sectorsPerTrack ¬ sectorsPerTrack;    drive.nPages ¬      (LONG[drive.cylinders] * drive.movingHeads) * drive.sectorsPerTrack;    drive.diskTypeKnown ¬ TRUE;    END;  ChangeScheduler: PUBLIC --DiskChannelInternal. ENTRY-- PROCEDURE [    new: DiskScheduler.Scheduler,    driveData: LONG POINTER TO DiskChannelInternal.DriveDataArray] =    BEGIN    priorityPrev: Process.Priority ¬ VM.GuardStateVector[      ProcessPriorities.diskInterruptPriority];    req: DiskScheduler.RequestHandle;    tempDD: DiskScheduler.DriveData;    i: CARDINAL ¬ 0;    d: Drive;    WHILE ~ProcessOperations.Enter[@LOCK] DO NULL ENDLOOP;  -- must follow GuardStateVector    IF new.scheduleProc = NIL THEN new.scheduleProc ¬ DefaultSchedule;    FOR d ¬ firstDrive, d.next UNTIL d = nullDrive DO      UNTIL (req ¬ scheduler.getNextRequestProc[@d.schedulerWord]) = NIL DO        req.next ¬ NIL; new.scheduleProc[@driveData[i], req] ENDLOOP;      tempDD ¬ d.schedulerWord;  -- SWAP d.schedulerWord and driveData[i]      d.schedulerWord ¬ driveData[i];      driveData[i] ¬ tempDD;      i ¬ SUCC[i];      ENDLOOP;    scheduler.transitionProc ¬      IF new.transitionProc = NIL THEN DefaultTransition ELSE new.transitionProc;    scheduler.driveProc ¬      IF new.driveProc = NIL THEN DefaultDrive ELSE new.driveProc;    scheduler.scheduleProc ¬ new.scheduleProc;    scheduler.getNextRequestProc ¬      IF new.getNextRequestProc = NIL THEN DefaultGetNextRequest      ELSE new.getNextRequestProc;    ProcessOperations.Exit[@LOCK];  -- must preceed DoneWithStateVector    VM.DoneWithStateVector[priorityPrev];    END;  --ChangeScheduler--  DoDirectIO: PUBLIC --DiskChannel. ENTRY-- PROCEDURE [    operation: LONG POINTER TO DiskChannel.DirectOperation,    mode: DiskChannel.Mode]    RETURNS [status: DiskChannel.IOStatus, retryCount: CARDINAL] =    BEGIN    priorityPrev: Process.Priority ¬ VM.GuardStateVector[      ProcessPriorities.diskInterruptPriority];    driveState: DiskChannel.DriveState;    schedulerRequestObject: DiskScheduler.RequestObject ¬ [      prefix: @state, iorh: NIL, next: NIL, client: 0];    state: RequestState;    waitStart, waitEnd: System.Pulses;    WHILE ~ProcessOperations.Enter[@LOCK] DO NULL ENDLOOP;      -- must follow GuardStateVector    numberRequests ¬ SUCC[numberRequests];    -- Find the drive:    FOR drive: Drive ¬ firstDrive, drive.next UNTIL drive = NIL DO      IF drive.handle = operation.diskOp.device THEN {        driveState ¬ drive.state; EXIT}      REPEAT FINISHED => Bug[invalidDrive];      ENDLOOP;    IF ~CheckOperationValidity[IF mode = normal THEN direct ELSE channel,      driveState, operation.diskOp.command]        THEN status ¬ [invalidDriveState[]]  -- (retryCount = garbage)    ELSE      BEGIN      pDO: LONG POINTER TO DiskChannelPrivate ¬ NARROW[        @operation.diskChannelPrivate];      pDO­ ¬ [@schedulerRequestObject, operation.diskOp.pageCount, NIL];      state.completionStatus ¬ direct;      -- state.countDone ¬ TRASH;      state.channel ¬ NIL;      -- state.ioComplete ¬ ioCompletePrototype  ++ (compiler disallows)      LOOPHOLE[@state.ioComplete, CVar]­ ¬  -- (uninit ok)        LOOPHOLE[ioCompletePrototype];      Submit[@operation.diskOp];      waitStart ¬ System.GetClockPulses[];      WHILE state.completionStatus # completed DO        ProcessOperations.Wait[@LOCK, @state.ioComplete, PSB.NoTimeout];        WHILE ~ProcessOperations.ReEnter[@LOCK, @state.ioComplete] DO          NULL ENDLOOP;        ENDLOOP;      waitEnd ¬ System.GetClockPulses[];      waitPulses ¬ [(Value[waitEnd] - Value[waitStart]) + Value[waitPulses]];      status ¬ state.status;      IF state.countDone NOT IN CARDINAL THEN Bug[overflow]      ELSE retryCount ¬ CARDINAL[state.countDone];      END;    ProcessOperations.Exit[@LOCK];  -- must preceed DoneWithStateVector    VM.DoneWithStateVector[priorityPrev];    END;  --DoDirectIO--  DoIO: PUBLIC --DiskChannel. ENTRY-- PROCEDURE [    channel: Handle, req: DiskChannel.IORequestHandle]    RETURNS [status: DiskChannel.IOStatus, countDone: DiskChannel.DiskPageCount] =    BEGIN    priorityPrev: Process.Priority ¬ VM.GuardStateVector[      ProcessPriorities.diskInterruptPriority];    schedulerRequestObject: DiskScheduler.RequestObject ¬ [      prefix: @state, iorh: req, next: NIL, client: 0];    state: RequestState;    op: ChannelOperationPtr;    waitStart, waitEnd: System.Pulses;    WHILE ~ProcessOperations.Enter[@LOCK] DO NULL ENDLOOP;  -- must follow GuardStateVector    numberRequests ¬ SUCC[numberRequests];    IF ~CheckOperationValidity[channel, channel.drive.state, req.command] THEN      status ¬ [invalidDriveState[]]  -- (countDone = garbage)    ELSE      BEGIN      state.retryIO ¬ req.tries # noTries;      state.countDone ¬ 0;      state.channel ¬ @channel;      -- state.ioComplete ¬ ioCompletePrototype  ++ (compiler disallows)      LOOPHOLE[@state.ioComplete, CVar]­ ¬ LOOPHOLE[ioCompletePrototype];      IF (op ¬ GetFreeOperation[channel.drive]) = NIL THEN        Schedule[@schedulerRequestObject]      ELSE FillInOperationAndSubmit[op, @schedulerRequestObject];  -- (sets state.completionStatus)      waitStart ¬ System.GetClockPulses[];      WHILE state.completionStatus # completed DO        ProcessOperations.Wait[@LOCK, @state.ioComplete, PSB.NoTimeout];        WHILE ~ProcessOperations.ReEnter[@LOCK, @state.ioComplete] DO          NULL ENDLOOP;        ENDLOOP;      waitEnd ¬ System.GetClockPulses[];      waitPulses ¬ [(Value[waitEnd] - Value[waitStart]) + Value[waitPulses]];      status ¬ state.status;      countDone ¬ state.countDone;      END;    ProcessOperations.Exit[@LOCK];  -- must preceed DoneWithStateVector    VM.DoneWithStateVector[priorityPrev];    END;  --DoIO--  GetDrive: PUBLIC ENTRY PROCEDURE [channel: Handle] RETURNS [drive: Drive] = {    RETURN[channel.drive]};  GetDriveAttributes: PUBLIC ENTRY PROCEDURE [drive: Drive]    RETURNS [      deviceType: Device.Type, deviceHandle: PilotDisk.Handle,      deviceOrdinal: CARDINAL, nPages: DiskChannel.DiskPageCount, ready: BOOLEAN,      state: DiskChannel.DriveState, changeCount: CARDINAL] =    BEGIN    RETURN[      -- note that ready is wired to TRUE.  This is a workaround for      -- unformatted disks (see PhysicalVolumeImpl for dependencies)      drive.type, drive.handle, drive.driveOrdinal, drive.nPages, TRUE,        drive.state, drive.changeCount];    END;  --GetDriveAttributes--  --~~~~~~~~~~~~~~~ PRIVATE procedures  Bug: PROCEDURE [type: BugType] = {RuntimeInternal.Bug[type]};  CheckOperationValidity: --INTERNAL-- PROCEDURE [    command, state: DiskChannel.DriveState, cmd: PilotDiskFace.Command]    RETURNS [BOOLEAN] = INLINE    BEGIN    --  Checks to see if the procedure implementing "command" access can use    --  the volume with "state" access. Non-write ok even if command # state.    RETURN[(state = command) OR           (cmd = noOp OR cmd = read OR cmd = verify OR cmd = readHeader OR 	    cmd = readHeaderAndData)]    END;  -- Default Scheduler  -- The default scheduler is a simple FIFO queue for each drive.  -- The implementation is simple-minded (a singly-linked list), since  -- this scheduler is expected to be used only when the queue remains short.  -- Note that DoIO was kind enough to set req.next to NIL for us.  QueueHead: TYPE = MACHINE DEPENDENT RECORD [    first(0), last(1): DiskScheduler.RequestHandle];  -- initialQueueHead: QueueHead = [NIL, NIL];  -- The body of the drive proc is commented out, since it really is a no-op: the  -- representation of initialQueueHead is a long zero, which is the initial value  -- of the DriveData.   DefaultDrive: INTERNAL DiskScheduler.DriveProc =    -- PROCEDURE [    --   drive: LONG POINTER TO DriveData, channelDrive: DiskChannel.Drive]    BEGIN    -- IF drive­ = 0 THEN LOOPHOLE[drive­, QueueHead] ¬ initialQueueHead;    END;  DefaultGetNextRequest: INTERNAL DiskScheduler.GetNextRequestProc =    -- PROCEDURE [drive: LONG POINTER TO DriveData] RETURNS [req: RequestHandle]    BEGIN    q: LONG POINTER TO QueueHead ¬ LOOPHOLE[drive];    req ¬ q.first;    IF req # NIL THEN {q.first ¬ req.next; IF q.first = NIL THEN q.last ¬ NIL};    RETURN[req];    END;  DefaultSchedule: INTERNAL DiskScheduler.ScheduleProc =    -- PROCEDURE [drive: LONG POINTER TO DriveData, req: RequestHandle]    BEGIN    q: LONG POINTER TO QueueHead ¬ LOOPHOLE[drive];    IF q.first = NIL THEN q.first ¬ req ELSE q.last.next ¬ req;    q.last ¬ req;    END;  DefaultTransition: INTERNAL DiskScheduler.TransitionProc = {};  FeedDisk: INTERNAL PROCEDURE =    BEGIN    -- This procedure will continue to submit requests until we run out    -- of requests or operations for all the drives.    noneScheduledThisPass: BOOLEAN ¬ FALSE;    req: DiskScheduler.RequestHandle;    op: ChannelOperationPtr;    UNTIL noneScheduledThisPass DO      noneScheduledThisPass ¬ TRUE;  -- assume..      FOR d: Drive ¬ firstDrive, d.next UNTIL d = nullDrive DO        UNTIL d.firstFreeOperation = NIL          OR (req ¬ scheduler.getNextRequestProc[@d.schedulerWord]) = NIL DO          numberInScheduler ¬ PRED[numberInScheduler];          op ¬ GetFreeOperation[d];          noneScheduledThisPass ¬ FALSE;          FillInOperationAndSubmit[op, req];          ENDLOOP;        ENDLOOP;      ENDLOOP;    END;  FreeOperation: --INTERNAL-- PROCEDURE [drive: Drive, op: ChannelOperationPtr] =    INLINE {    -- Put op back on the drive's queue of free operations.    op.nextFree ¬ drive.firstFreeOperation; drive.firstFreeOperation ¬ op};  FillInOperationAndSubmit: --INTERNAL-- PROCEDURE [    op: ChannelOperationPtr, req: DiskScheduler.RequestHandle] =    BEGIN    -- Fills in the Operation with the info. from the I/O request and submits.    -- Note that DoIO was kind enough to set state.countDone to zero and    -- state.retryIO to the right value for us.    -- If the change count of the channel and the change count of the drive do not agree,    -- returns status = [invalidChannel[]] immediately.    iorh: DiskChannel.IORequestHandle = req.iorh;    prefix: Prefix = req.prefix;    IF prefix.channel.changeCount # prefix.channel.drive.changeCount THEN      BEGIN      FreeOperation[prefix.channel.drive, op];      prefix.completionStatus ¬ completed;      prefix.status ¬ [invalidChannel[]];      ProcessOperations.Notify[@prefix.ioComplete];      END    ELSE      BEGIN      op.diskOp ¬ PilotDiskFace.Operation[        clientHeader: CalculatePageAddress[prefix.channel.drive, iorh.diskPage],        diskHeader: PilotDiskFace.DiskAddress[0, 0, 0],        incrementDataPtr: ~iorh.useSamePage, command: iorh.command,        enableTrackBuffer: TRUE, tries: noTries,        pageCount: Inline.LowHalf[MIN[LONG[LAST[CARDINAL]], iorh.count]],        device: prefix.channel.drive.handle, deviceStatus:,        dataPtr: Environment.LongPointerFromPage[iorh.memoryPage]];      prefix.completionStatus ¬ submitted;      op.req ¬ req;      op.countSubmitted ¬ op.diskOp.pageCount;      Submit[@op.diskOp];      END;    END;  --FillInOperationAndSubmit--  GetFreeOperation: --INTERNAL-- PROCEDURE [drive: Drive]    RETURNS [op: ChannelOperationPtr] = INLINE    -- Gets an Operation off the drive's queue; returns NIL if none.    BEGIN    IF (op ¬ drive.firstFreeOperation) # NIL THEN      drive.firstFreeOperation ¬ op.nextFree;    END;  Schedule: --INTERNAL-- PROCEDURE [req: DiskScheduler.RequestHandle] =    BEGIN    -- Give this request to the scheduler and update counters    prefix: Prefix ¬ req.prefix;    drive: Drive ¬ prefix.channel.drive;    prefix.completionStatus ¬ scheduled;    numberScheduled ¬ SUCC[numberScheduled];    numberInScheduler ¬ SUCC[numberInScheduler];    scheduler.scheduleProc[@drive.schedulerWord, req];    END;  Submit: --INTERNAL-- PROCEDURE [diskOp: DiskOperationPtr] = INLINE {    countSubmitted ¬ SUCC[countSubmitted]; PilotDiskFace.Initiate[diskOp]};  Tries: INTERNAL PROCEDURE [r: DiskChannel.Tries] RETURNS [PilotDiskTries] =    INLINE {RETURN[MIN[maxTries, r]]};  -- Controller process:  ControllerProcess: ENTRY PROCEDURE [    controller: PilotDiskFace.ControllerHandle,    interrupt: LONG POINTER TO CONDITION] =    BEGIN    status: PilotDiskFace.Status;    diskOp: PilotDiskFace.OperationPtr;    retryCount: CARDINAL;    DO  --FOREVER--      WHILE countSubmitted > 0 DO        [status, diskOp, retryCount] ¬ PilotDiskFace.Poll[controller];        IF status = inProgress OR diskOp = NIL THEN {FeedDisk[]; EXIT}        ELSE          BEGIN  --operation finished, possibly in error--          channelOp: ChannelOperationPtr = LOOPHOLE[diskOp - offsetDiskOp,            ChannelOperationPtr];          iorh: DiskChannel.IORequestHandle =  -- is NIL if DoDirectIO.            channelOp.req.iorh;          requestState: Prefix = channelOp.req.prefix;          requestState.countDone ¬            requestState.countDone + channelOp.countSubmitted -              channelOp.diskOp.pageCount;          errorData.totalRetries ¬ errorData.totalRetries + retryCount;          IF status # goodCompletion OR errorData.logAllOpsIfNotZero # 0 THEN            BEGIN            errorData.last ¬ [              retries: retryCount, status: status,              diskOperation: channelOp.diskOp, deviceOrdinal: TRASH,              deviceType: TRASH];            IF requestState.channel = NIL THEN {  -- (device not readily available)              errorData.last.deviceType ¬ Device.nullType;              errorData.last.deviceOrdinal ¬ 0}            ELSE {              errorData.last.deviceType ¬ requestState.channel.drive.type;              errorData.last.deviceOrdinal ¬                requestState.channel.drive.driveOrdinal};            BROADCAST errorData.error;            END;          SELECT TRUE FROM            requestState.completionStatus = direct =>              BEGIN              requestState.countDone ¬ retryCount;              -- Code order below matches status = goodCompletion for good cross-jumping.              countSubmitted ¬ countSubmitted.PRED;              requestState.status ¬ [disk[status]];              requestState.completionStatus ¬ completed;              NOTIFY requestState.ioComplete;              END;            status = goodCompletion =>              BEGIN              errorData.totalGoodCompletions ¬ errorData.totalGoodCompletions + 1;              IF channelOp.diskOp.pageCount # 0 THEN Bug[noTransfer];              IF requestState.countDone # iorh.count THEN                BEGIN  -- did LAST[CARDINAL] pages ok. Do up to LAST[CARDINAL] more..                channelOp.diskOp.tries ¬ noTries;  -- no retries the first time..                channelOp.diskOp.pageCount ¬ Inline.LowHalf[                  MIN[LONG[LAST[CARDINAL]], iorh.count - requestState.countDone]];                requestState.retryIO ¬ iorh.tries # noTries;                channelOp.countSubmitted ¬ channelOp.diskOp.pageCount;                PilotDiskFace.Initiate[diskOp];                END              ELSE                BEGIN                FreeOperation[requestState.channel.drive, channelOp];                -- Code order below matches completionStatus = direct for good cross-jumping.                countSubmitted ¬ countSubmitted.PRED;                requestState.status ¬ [disk[status]];                requestState.completionStatus ¬ completed;                NOTIFY requestState.ioComplete;                END;              END;            requestState.retryIO =>              BEGIN              errorData.errorsSinceLastReport ¬                errorData.errorsSinceLastReport + 1;              channelOp.diskOp.pageCount ¬ 1;              channelOp.diskOp.tries ¬ Tries[iorh.tries];              requestState.retryIO ¬ FALSE;              channelOp.countSubmitted ¬ channelOp.diskOp.pageCount;              PilotDiskFace.Initiate[diskOp];              END;            ENDCASE =>  -- NOT requestState.retryIO              BEGIN              errorData.errorsSinceLastReport ¬                errorData.errorsSinceLastReport + 1;              FreeOperation[requestState.channel.drive, channelOp];              -- Code order below matches status = goodCompletion for good cross-jumping.              countSubmitted ¬ countSubmitted.PRED;              requestState.status ¬ [disk[status]];              requestState.completionStatus ¬ completed;              NOTIFY requestState.ioComplete;              END;          FeedDisk[];          END  --operation finished, possibly in error--        ENDLOOP;  --countSubmitted > 0--      WAIT interrupt;      ENDLOOP;  --FOREVER--    END;  --ControllerProcess--  -- Initialization:  BEGIN  dummyChanOpPtr: POINTER TO ChannelOperation = LOOPHOLE[0];  offsetDiskOp ¬    LOOPHOLE[@dummyChanOpPtr.diskOp, POINTER] - LOOPHOLE[dummyChanOpPtr, POINTER];  RegisterControllers[];  RegisterDrives[];  END;  END.LOG19-Jun-82 17:33:05   KAM     Major rewrite for Klamath.  Roughly supplies function of Trinity   DiskDriverShared and PilotDiskImpl.19-Jun-82 17:33:05   KAM     Added implementation comments.13-Sep-82 18:40:25   WDK        Make it compile. Move priority setting from ControllerProcess to initialization.22-Nov-82 16:50:19   WDK        Implemented DiskDriversPerf.waitPulses. Rearranged Operation so as to allow it to be actually declared as a record(!) and be almost entirely type-safe. Simplified initial storage allocation. Entry procs now guard state vector.22-Dec-82 10:04:52   AWL         New PilotDisk & PilotDiskFace.11-Jan-83 15:26:57   KAM     Fixed bug in DoDirectIO. Made compatable with DiskScheduler changes.26-Mar-83 17:38:31   JXP      Remember to set the driveOrdinal when Registering Drives.31-Mar-83 10:25:43   WDK        State vector guard must be outside monitor.11-Apr-83 10:29:11   WDK        Get LongPointerFromPage from Environment.10-May-83 12:31:59   WDK        ControllerProcess must detect TRASH channel for error logging. DoDirectIO now sets it to NIL. Name changes for clarity.20-May-83 15:45:44   WDK        Must do monitor reenter after wait.27-May-83 17:18:57   JXG        Must give correct condition variable when doing monitor reenter after wait.16-Nov-83 14:15:40   WDK        DoDirectIO returned retryCount = TRASH. ControllerProcess failed to decrement countSubmittedfor direct and NOT requestState.retryIO cases.12-Apr-84  9:54:59   KAM        AR 5898: Operations (IOCBs) could cross VM page boundaries if there were enough drives (> 3). Operations are now allocated one at a time. AR 5902: Value of countDrives was 2*number drives. 16-Apr-84 17:56:13   KAM        AR 5898: Operations were alocated misaligned. 22-May-85 10:53:26   CJS   Relax constraints in CheckOperationValidity. May now perform a non-write cmd on drive regardless of DriveState incompatibilities.  Inspired by DiskChannelSwappable.GetDriveAttributes [v,v,v] of direct drive. AR 741527-Aug-85 10:10:16   RSV   Moved GetDrive and GetDriveAttributes from DiskChannelSwappable.mesa to this module. 9-Jul-86 10:18:57   RSV   Deleted references to labels and converted to new PilotDiskFace.Command version. 5-Aug-86 14:30:15   CAJ   Use face operation alignment for operations; remove redundant a16 alignment on allocation of operation later adjusted to align diskOp.  Let bootfile ops through CheckOperationValidity.12-Sep-86 12:34:23   CAJ   Add mode arg to DoDirectIO to allow its use in driveState=channel under appropriate conditions.  Remove bootfile ops from CheckOperationValidity exceptions (because they are one of the appropriate conditions).27-Sep-88 16:24:52   RSV   Added track buffering code to RegisterControllers and RegisterDrives.  Also fix AR 12633 (If error allocating controller storage then unpredictable operation).18-Oct-88 13:45:35   RSV   Changed from calling VM.Map (and StoragePrograms) to calling TrackBufferMemory from RegisterDrives.21-Oct-88 11:20:52   RSV   In FillInOperationAndSubmit, always turn track buffering on (the heads just won't do it if it is not initialized).17-Jan-89 16:13:15   RSV   Final version of track buffering switches for 15.0, meeting FX requirements.
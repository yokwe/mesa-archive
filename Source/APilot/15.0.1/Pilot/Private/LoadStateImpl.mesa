-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- MesaRuntime>LoadStateImpl.mesa      27-Oct-87 19:25:40 by ET    <<This module implements: 1. Management of global frames 2. Utilities dealing with local and global frames, control links, etc.INVARIANTS:  The Module Info Table is kept compacted and   sorted by increasing gFrame address. The debugger expects it to be sorted, too.Meaning of GlobalWord/ExtraGlobalWord of a global frame:  unused:	not used at present    started:      tablecompiled?    copy:		gFrame is a dynamically-made copy of another.    copied:	This is a MakeBoot-created gFrame from which a dynamically-made  		copy was made. Not used any more. TEMPORARILY used by the Loader		to indicate a dynamically loaded (original) global frame,		and thus that the control module lists are not to be		Frame.Freed, but Freed from the loader's heap.    alloced:	storage for gFrame was allocated from the frame heap (by MakeBoot).		Obsolete as soon as MakeBoot quits doing that.    shared:	several gFrames have the same codebase as this gFrame.  		Relic of the Alto. Not used any more.		  trapxfer,   codelinks:    Chapter 9 of "Mesa Processor Principles of Operation".    gfi:          Index into global frame table for this frame.    spare:	not used at present>>DIRECTORY  BcdDefs USING [Link],  CPSwapDefs USING [ExternalStateVector, PESV],  Environment USING [Base, maxPagesInMDS, PageCount, wordsPerPage],  File USING [File, nullFile],  Frame USING [    Free, GetReturnFrame, GetReturnLink, ReadPC, ReadReturnLink, SetReturnLink],  FrameExtras USING [    GFTHandleToLongGF, GlobalOverhead, LongGFToGFTHandle, ReadGlobalLink,    WriteCodebase],  Heap USING [    Create, CreateMDS, FreeNode, FreeMDSNode, MakeNode, MakeMDSNode,    minimumNodeSize, unlimitedSize],  Inline USING [    HighHalf, LongCOPY, LongCOPYReverse, LongMult, LongNumber, LowByte, LowHalf],  KernelSpaceUsage USING [workingLoadState],  LoadState USING [    BcdInfoIndex, LPBcdInfoTable, LPModuleInfoTable, ModuleInfoIndex,    ModuleInfoSequence, ModuleInfoSequenceHandle, RuntimeGlobalOverhead,    RuntimeOverheadHandle],  LoadStateFormat USING [    BcdInfo, BcdInfoIndex, Handle, ModuleInfo, ModuleInfoIndex, Object,    VersionID],  PilotMP USING [cBadLoadStateVersion],  PrincOps USING [    BytePC, CodeSegment, ControlLink, GlobalCodebase, LocalFrameHandle,    PrefixHandle, ShortControlLink],  PrincOpsExtras2 USING [    ControlLink, EmptyGFTItem, GFT, GFTHandle, GFTHandleToIndex, GlobalOverhead,    LongGlobalFrameHandle, nullGFH, ShortGlobalFrameHandle, ControlLinkTag],  ProcessOperations USING [Enter, Exit],  ProcessorFace USING [SetMP],  ResidentHeap USING [first64K, FreeNode, MakeNode],  Runtime USING [ControlLink, UnboundProcedure],  RuntimeInternal USING [FrameSize],  RuntimePrograms USING [],  SDDefs USING [sCopy, SD],  SDDefsExtras USING [sEmptyGFTHandle],  Space USING [defaultSwapUnitSize, Map, PagesFromWords, Unmap],  SpecialRuntime,  SpecialRuntimeExtras USING [    Codebase, GlobalFrameFromProgram, ProgramFromGlobalFrame],  StoragePrograms USING [PMDS, startList],  System USING [GreenwichMeanTime],  Zone USING [Status];LoadStateImpl: MONITOR LOCKS moduleInfoLock  IMPORTS    CPSwapDefs, Frame, FrameExtras, Heap, Inline, PrincOpsExtras2,    ProcessOperations, ProcessorFace, ResidentHeap, Runtime, RuntimeInternal,    Space, SpecialRuntimeExtras, StoragePrograms  EXPORTS LoadState, Runtime, SpecialRuntime, RuntimePrograms =  BEGIN  -- PARAMETERS:  -- The following three parameters determine the number of free entries in  -- the Bcd Info Table and the Module Info Table when the load state is grown,  -- and the relative proportions of spare entries in each table.  extraLoadStatePages: CARDINAL = 1;  -- (Thus on average there will be 1.5 extra pages worth of spare entries).  extraBcdProportion: CARDINAL = 1;  extraModuleProportion: CARDINAL = 7;  -- Note that a bcd entry is 4 words, a module entry 3.  -- If there are 1.5 extra pages worth of spare space, the ratio of  -- [bcd: 1, module: 7] will produce about 15 and 105 spare entries.  maxTypicalNumberOfUnresolvedModulesOfBcd: CARDINAL = 20;  maxTypicalCopies: CARDINAL = 20;  -- Public Items:  buildTime: PUBLIC --Runtime.-- System.GreenwichMeanTime ¬    LOOPHOLE[StoragePrograms.startList.buildDate];  -- Must copy this early before UtilityPilot ditches the start list.  InvalidFrame: PUBLIC --Runtime.-- ERROR [frame: LocalFrameHandle] = CODE;  InvalidGlobalFrame: PUBLIC --Runtime.-- ERROR [    frame: PrincOpsExtras2.LongGlobalFrameHandle] = CODE;  NotANewedProgram: PUBLIC --Runtime.-- ERROR [    frame: PrincOpsExtras2.LongGlobalFrameHandle] = CODE;  -- Performance data:  news: PUBLIC --RuntimePerf?-- CARDINAL ¬ 0;  loadStateGrows: PUBLIC --RuntimePerf?-- CARDINAL ¬ 0;  moduleTableFullSearches: PUBLIC --RuntimePerf?-- CARDINAL ¬ 0;  moduleTableFastSearches: PUBLIC --RuntimePerf?-- CARDINAL ¬ 0;  frameAllocFailure: CARDINAL ¬ 0;  -- REMOVE THIS SOON  -- Copied Types and Constants:  alignmentModulus: CARDINAL = 4;  -- local, global frames aligned 0 mod 4.  esv: LONG POINTER TO CPSwapDefs.ExternalStateVector = CPSwapDefs.PESV[];  globalExtraOffset: CARDINAL = 4;  LinkSize: CARDINAL = BcdDefs.Link.SIZE;  wordsPerPage: CARDINAL = Environment.wordsPerPage;  GFTHandle: TYPE = PrincOpsExtras2.GFTHandle;  LongGlobalFrameHandle: TYPE = PrincOpsExtras2.LongGlobalFrameHandle;  GlobalOverhead: TYPE = PrincOpsExtras2.GlobalOverhead;  LocalFrameHandle: TYPE = PrincOps.LocalFrameHandle;  ControlLink: TYPE = PrincOpsExtras2.ControlLink;  --========== Load State Monitor Data:  -- These data are readOnly if you hold EITHER monitor lock,  -- writable if you hold BOTH.  loadState: LoadStateFormat.Handle;  LoadStateStorage: TYPE = {initial, dynamicCopy};  loadStateStorage: LoadStateStorage;  moduleInfo: LoadState.LPModuleInfoTable;  --========== Bcd Info Table Monitor Data:  bcdInfoLock: MONITORLOCK;  -- Protects Bcd Info Table, load state ID, and associated global variables.  -- This lock is acquired only by the Loader, and by New when it  -- expands the module table.  bcdInfo: LoadState.LPBcdInfoTable;  --========== Module Info Table Monitor Data:  moduleInfoLock: MONITORLOCK;  -- Protects Module Info Table and associated  -- global variables. If bcdInfoLock is required for an operation,  -- it must be acquired before moduleInfoLock.  -- Copied frame table:  OriginalOfCopyEntry: TYPE = RECORD [copy, original: PrincOpsExtras2.GFTHandle];  OriginalOfCopy: TYPE = RECORD [    nCopies: CARDINAL, seq: SEQUENCE maxCopies: CARDINAL OF OriginalOfCopyEntry];  originalOfCopy: LONG POINTER TO OriginalOfCopy ¬ NIL;  -- Module search routine data:  countModuleInfoPad: CARDINAL = 1;  -- For the convenience of the Find routine, a "top" entry  -- is appended to the table. The "top" entry has gf = gfTop.  -- The table layout is as follows:  -- index: |  0   |     |      | nModules | (offsetFree)  --    gf: | gf A | ... | gf Z | gf=gfTop | <free>  gfiTop: GFTHandle = LOOPHOLE[CARDINAL.LAST];  miiMru: LoadState.ModuleInfoIndex ¬ --TRASH-- 0;  -- the most recently found gFrame.  DebuggerModuleInfoTable: TYPE = LONG POINTER TO ARRAY [0.. --say-- 3000] OF    LoadStateFormat.ModuleInfo;  --for debugger  gFrameMDSZone: MDSZone ¬ NIL;  gFrameZone: UNCOUNTED ZONE ¬ NIL;  TablesFull: PUBLIC --LoadState.-- ERROR [    totalBcdsNeeded, totalModulesNeeded: CARDINAL] = CODE;  DuplicateGFrame: PRIVATE ERROR = CODE;  -- (client error)  GFrameNotFound: PRIVATE ERROR = CODE;  -- (client error)  Bug: PRIVATE --PROGRAMMING-- ERROR [type: BugType] = CODE;  BugType: TYPE = {    cantFindGFrame, errorOnFree, mdsNodeCrosses64KBoundary, noExtraSlot,    noHeapSpace, notInCopyTable};  --================== Type Converters and Inlines: ==================  Align: PROCEDURE [p: LONG POINTER] RETURNS [LONG POINTER] = INLINE {    -- Aligns to 0 mod 4 boundary,    RETURN[      LOOPHOLE[((LOOPHOLE[p, LONG CARDINAL] + alignmentModulus - 1) /                  alignmentModulus) * alignmentModulus]]};  CodebaseFromProgram: PROCEDURE [program: PROGRAM]    RETURNS [codebase: LONG BASE POINTER TO PrincOps.CodeSegment] = INLINE {    RETURN SpecialRuntimeExtras.Codebase[program]};  GFrameFromProgram: PROCEDURE [program: PROGRAM]    RETURNS [frame: LongGlobalFrameHandle] = INLINE {    -- Performs no checking.    RETURN SpecialRuntimeExtras.GlobalFrameFromProgram[program]};  ProgFromGlobalFrame: PROCEDURE [frame: LongGlobalFrameHandle]    RETURNS [program: PROGRAM] = INLINE {    -- Performs no checking.    RETURN SpecialRuntimeExtras.ProgramFromGlobalFrame[frame]};  ProgFromGFI: PROCEDURE [gfi: GFTHandle] RETURNS [program: PROGRAM] = INLINE {    -- Performs no checking.    RETURN SpecialRuntimeExtras.ProgramFromGlobalFrame[      FrameExtras.GFTHandleToLongGF[gfi]]};  GFIFromProg: PROCEDURE [program: PROGRAM] RETURNS [gfi: GFTHandle] = INLINE {    -- Performs no checking.    RETURN FrameExtras.LongGFToGFTHandle[      SpecialRuntimeExtras.GlobalFrameFromProgram[program]]};  ToMDSFrame: PROCEDURE [longGF: LongGlobalFrameHandle]    RETURNS [shortGF: PrincOpsExtras2.ShortGlobalFrameHandle] = INLINE {    RETURN[Inline.LowHalf[longGF]]};  --================== Initialization: ==================  InitializeLoadStateA: PUBLIC --RuntimePrograms.-- PROC =    BEGIN    SDDefs.SD[SDDefs.sCopy] ¬ LOOPHOLE[New];    loadState ¬ CPSwapDefs.PESV[].loadState;    IF loadState.versionident # LoadStateFormat.VersionID THEN      DO ProcessorFace.SetMP[PilotMP.cBadLoadStateVersion] ENDLOOP;    loadStateStorage ¬ initial;    moduleInfo ¬ @loadState[loadState.moduleInfo];    bcdInfo ¬ LOOPHOLE[@loadState[loadState.bcdInfo]];  -- LOOPHOLE: See AR 4290    IF loadState.nModules >= loadState.maxModules THEN  --      ERROR;  -- I need at least one free slot.    moduleInfo[loadState.nModules].gfi ¬ gfiTop;  -- "top" entry for binary search.    END;  --InitializeLoadStateA--  InitializeLoadStateB: PUBLIC --RuntimePrograms.-- PROC =    BEGIN    node: Environment.Base RELATIVE POINTER TO OriginalOfCopy;    status: Zone.Status;    [node, status] ¬ ResidentHeap.MakeNode[      n: SIZE[OriginalOfCopy [maxTypicalCopies]], location: first64K];    IF status # okay THEN ERROR Bug[noHeapSpace];    originalOfCopy ¬ @ResidentHeap.first64K[node];    LOOPHOLE[@originalOfCopy.seq, LONG POINTER TO CARDINAL]­ ¬ maxTypicalCopies;    originalOfCopy.nCopies ¬ 0;    gFrameMDSZone ¬ Heap.CreateMDS[      initial: 1, maxSize: Heap.unlimitedSize, increment: 1,      swapUnitSize: Space.defaultSwapUnitSize, threshold: Heap.minimumNodeSize,      largeNodeThreshold: Environment.wordsPerPage / 2, ownerChecking: FALSE,      checking: FALSE];    gFrameZone ¬ Heap.Create[      initial: 1, maxSize: Heap.unlimitedSize, increment: 1,      swapUnitSize: Space.defaultSwapUnitSize, threshold: Heap.minimumNodeSize,      largeNodeThreshold: Environment.wordsPerPage / 2, ownerChecking: FALSE,      checking: FALSE];    END;  --================== Procedures: ==================  -- (ordered by kind {external, entry, internal};  within a kind, alphabetically)  --===== External Procedures (public and private): =====  Catch: PUBLIC --SpecialRuntime. EXTERNAL-- PROC [frame: --GENERIC-- PROGRAM]    RETURNS [catch: LONG POINTER] = {    codebase: PrincOps.PrefixHandle = CodebaseFromProgram[frame];    catchBytePC: PrincOps.BytePC = codebase.header.catchCode;    RETURN[codebase + CARDINAL[catchBytePC / 2]]};  Code: PUBLIC --SpecialRuntime. EXTERNAL-- PROC [link: PrincOps.ControlLink]    RETURNS [code: LONG POINTER] = {    gFrame: LongGlobalFrameHandle;    pc: PrincOps.BytePC;    [gFrame: gFrame, pc: pc] ¬ StuffFromLink[LOOPHOLE[link]];    RETURN[CodebaseFromProgram[ProgFromGlobalFrame[gFrame]] + CARDINAL[pc / 2]]};  EntryVector: PUBLIC --SpecialRuntime. EXTERNAL-- PROC [    link: PrincOps.ControlLink] RETURNS [entryVector: LONG POINTER] = {    RETURN CodebaseFromProgram[ProgFromGlobalFrame[StuffFromLink[LOOPHOLE[link]].gFrame]]};  GetBuildTime: PUBLIC --Runtime. EXTERNAL-- PROC    RETURNS [System.GreenwichMeanTime] = {RETURN[buildTime]};  GetCaller: PUBLIC --Runtime. EXTERNAL-- PROC RETURNS [PROGRAM] = {    RETURN[      ProgFromGFI[        FrameExtras.ReadGlobalLink[        Frame.ReadReturnLink[Frame.GetReturnFrame[]].frame]]]};  GetTableBase: PUBLIC --Runtime. EXTERNAL-- PROC [frame: PROGRAM]    RETURNS [l: LONG POINTER] = {    ValidateGlobalFrame[LOOPHOLE[frame]]; RETURN CodebaseFromProgram[frame]};  GlobalFrame: PUBLIC --Runtime. EXTERNAL-- PROC [link: LONG UNSPECIFIED]    RETURNS [program: PROGRAM] =    BEGIN    -- Note that "link" is allowed to be either a PROGRAM or a control link;    IF link = NIL THEN ERROR Runtime.UnboundProcedure[LOOPHOLE[link]];     -- Could be a PROGRAM.. ( and checking is a bit expensive.)    IF ValidGlobalFrame[LOOPHOLE[link]] THEN RETURN[LOOPHOLE[link]];    -- Nope, arg must be a control link.c    RETURN ProgFromGlobalFrame[StuffFromLink[LOOPHOLE[link, ControlLink]].gFrame];    END;  IsBound: PUBLIC --Runtime. EXTERNAL-- PROC [link: LONG UNSPECIFIED]    RETURNS [BOOLEAN] = {    << Note that "link" is allowed to be either a PROGRAM, an imported PROC,    or a pointer to an imported variable; rather bizarre, eh what?    Note that LONG POINTER # NIL is actually the same test    as PROGRAM # NIL, and so is omitted.    AT PRESENT, the compiler generates PrincOps.nullLink (=0) for PROC.NIL.    Probably the loader generates unboundLink, which is a procedure control link    with gf=pc=0). Thus we must test for both values even if we knew    that our argument was a PROC. Additionally, at present the compiler generates    a proc link of [gf, 0] for local discarded procs. Thus a third case to test.>>    RETURN[      LOOPHOLE[link, PROC] # NIL        AND LOOPHOLE[link, longProc ControlLink].pc # PrincOps.BytePC[0]        AND LOOPHOLE[link, PROGRAM] # NIL]};  New: --PUBLIC EXTERNAL-- PROC [oldProg: PROGRAM] RETURNS [PROGRAM] =    -- Invoked by Mesa construct  NEW <program>  via SD[sCopy].    BEGIN    -- We allocate the storage from systemMDSHeap or systemHeap,    -- thus making them swappable and conveniently freeable.     oldGFrame: LongGlobalFrameHandle =  --      GFrameFromProgram[oldProg];  -- (We'll validate the frame later.)    codebase: PrincOps.PrefixHandle =  -- AR 4283 requests that we      CodebaseFromProgram[oldProg];  -- get a SIZE, not an fsi.    linkWords: CARDINAL =      (IF FrameExtras.GlobalOverhead[oldGFrame].word.codelinks THEN 0       ELSE --frame links-- codebase.header.nlinks * LinkSize);    gFrameOffset: CARDINAL =  -- offset of global frame from overhead      LoadState.RuntimeGlobalOverhead.SIZE + linkWords + GlobalOverhead.SIZE;    size: CARDINAL =  -- minimum size of allocated storage      LoadState.RuntimeGlobalOverhead.SIZE + linkWords  -- overhead        + RuntimeInternal.FrameSize[  -- fsi for SIZE[global overhead+glob vars]	    codebase.header.globalFsi]        + alignmentModulus - 1;    inMDS: BOOLEAN =      (Inline.HighHalf[oldGFrame] = Inline.HighHalf[StoragePrograms.PMDS[]]);    AllocAligned: PROCEDURE [words, extra: CARDINAL]      RETURNS [raw: LONG POINTER, gFrame: LongGlobalFrameHandle] =      -- Implicit arguments: inMDS, gFrameOffset      -- Allocates a block of size words+extra      --   (1) which does not cross a 64K word boundary, and      --   (2) whose global zero is not on a page boundary.      -- 'words' must include alignmentModulus - 1 extra words      --    for quadword alignment.      -- 'raw' is the actual storage allocated, 'gFrame' is within it.      BEGIN      trialBlock: LONG POINTER =        IF inMDS THEN Heap.MakeMDSNode[gFrameMDSZone, words + extra].LONG        ELSE Heap.MakeNode[gFrameZone, words + extra];      -- Check 64K boundary:      IF Inline.HighHalf[trialBlock] # Inline.HighHalf[        trialBlock + words + extra - 1] THEN        BEGIN  -- trialBlock crosses 64K boundary        frameAllocFailure ¬ frameAllocFailure.SUCC;  -- REMOVE THIS SOON        -- In order to assure termination, we hang onto this block so that         -- the next AllocAligned will get a different one.        [raw: raw, gFrame: gFrame] ¬ AllocAligned[words: words, extra: 0];        IF inMDS THEN Bug[mdsNodeCrosses64KBoundary]        ELSE Heap.FreeNode[gFrameZone, trialBlock];        RETURN;        END;      -- 64K boundary OK, check page boundary:      FOR trialOffset: CARDINAL ¬ 0, trialOffset + alignmentModulus UNTIL        trialOffset > extra DO        gFrame ¬ Align[trialBlock + gFrameOffset + trialOffset];        IF Inline.LowByte[Inline.LowHalf[gFrame]] # 0 THEN  --          -- Not on page boundary; gFrame satisfies all constraints.          RETURN[raw: trialBlock, gFrame: gFrame];        ENDLOOP;      --ASSERT: trialBlock fails page boundary test.      frameAllocFailure ¬ frameAllocFailure.SUCC;  -- REMOVE THIS SOON      IF inMDS THEN Heap.FreeMDSNode[gFrameMDSZone, Inline.LowHalf[trialBlock]]      ELSE Heap.FreeNode[gFrameZone, trialBlock];      -- Trying again while getting four extra words guarantees that we will       -- be able to find a satisfactory page alignment within that new block.      RETURN AllocAligned[words: words, extra: alignmentModulus];      END;  --AllocAligned    -- Begin main body of New:    storage: LONG POINTER;    newGFrame: LongGlobalFrameHandle;    newRGO: LoadState.RuntimeOverheadHandle;    [storage, newGFrame] ¬ AllocAligned[words: size, extra: 0];    newRGO ¬ LOOPHOLE[newGFrame - gFrameOffset];    newRGO­ ¬ [storage: storage, frameLinks: NULL];    RETURN NewInternal[      oldProg, newGFrame, linkWords !      TablesFull --[totalBcdsNeeded, totalModulesNeeded]-- => {        ExpandTables[          totalBcdsNeeded: totalBcdsNeeded,          totalModulesNeeded: totalModulesNeeded];        RETRY};      UNWIND => {        IF inMDS THEN Heap.FreeMDSNode[gFrameMDSZone, Inline.LowHalf[storage]]        ELSE Heap.FreeNode[gFrameZone, storage]}];    END;  --New--  SelfDestruct: PUBLIC --Runtime. EXTERNAL-- PROC [] =    BEGIN    caller: PrincOps.ShortControlLink ¬ Frame.GetReturnLink[];    gfi: GFTHandle = FrameExtras.ReadGlobalLink[caller.frame];    UnNew[ProgFromGFI[gfi]];  -- may raise InvalidGlobalFrame    -- Free all contiguous lFrames up the stack running in gFrame:    WHILE NOT caller.indirect AND FrameExtras.ReadGlobalLink[caller.frame] = gfi      DO      callersCaller: PrincOps.ShortControlLink = Frame.ReadReturnLink[        caller.frame];      Frame.SetReturnLink[callersCaller];  -- set me to return skipping caller frame       Frame.Free[caller.frame];      caller ¬ callersCaller;      ENDLOOP;    END;  --SelfDestruct--  StuffFromLink: PRIVATE --EXTERNAL-- PROCEDURE [link: ControlLink]    RETURNS [gFrame: LongGlobalFrameHandle, lFrame: LocalFrameHandle,      pc: PrincOps.BytePC] =    -- Returns lFrame=NIL if proc link.    -- Returns pc of entry point if proc link, current pc if frame link.    -- NOTE: Does NOT accept a PROGRAM as an argument!    BEGIN    gfi: GFTHandle;    curLink: ControlLink ¬ link;    DO  -- (Using a normal loop formulation here cause compiler griping.)      WITH l: curLink SELECT curLink.tag FROM        shortProc =>          BEGIN          lFrame ¬ NIL;          pc ¬ l.pc;          curLink.tag ¬ VAL[0];  --clear low bits of curLink.gf (gFrame address).	  IF curLink.gf = NIL THEN	    ERROR Runtime.UnboundProcedure[LOOPHOLE[link]];          gfi ¬ FrameExtras.LongGFToGFTHandle[LONG[curLink.gf]];          EXIT;          END;        longProc =>          BEGIN          lFrame ¬ NIL;          pc ¬ l.pc;          curLink.tag ¬ VAL[0];  -- clear low bits of curLink.gf (gFrame address).          gfi ¬ l.gfi;          EXIT;          END;        indirect => NULL;  -- will walk to next in chain and loop.        ENDCASE --frame-- =>          BEGIN          lFrame ¬ curLink.frame;          IF lFrame = NIL THEN ERROR Runtime.UnboundProcedure[LOOPHOLE[link]];          pc ¬ Frame.ReadPC[lFrame];          gfi ¬ FrameExtras.ReadGlobalLink[lFrame];          EXIT;          END;      curLink ¬ curLink.link­;      ENDLOOP;    IF gfi = PrincOpsExtras2.nullGFH THEN      ERROR Runtime.UnboundProcedure[LOOPHOLE[link]];    gFrame ¬ FrameExtras.GFTHandleToLongGF[gfi];    IF NOT ValidGlobalFrame[ProgFromGlobalFrame[gFrame]] THEN      ERROR InvalidGlobalFrame[LOOPHOLE[ProgFromGlobalFrame[gFrame]]];    END;  --StuffFromLink--  --========== Global Frame Table Public Entry Procedures:   -- makeboot better have set the last entry in GFT to nullGFH.  allGone: GFTHandle = PrincOpsExtras2.nullGFH;  gftLock: MONITORLOCK;  -- This lock protects the GlobalFrameTable.  gftFreeList: GFTHandle ¬ Inline.LowHalf[    SDDefs.SD[SDDefsExtras.sEmptyGFTHandle]];  -- first gf entry available.   NoGlobalFrameSlots: PUBLIC ERROR = CODE;  -- 16k maximum entries in GFT  EnterGlobalFrame: PUBLIC --ENTRY-- PROCEDURE [    frame: LongGlobalFrameHandle, codebase: PrincOps.GlobalCodebase]    RETURNS [gfi: GFTHandle] =    BEGIN    UNTIL ProcessOperations.Enter[@gftLock] DO ENDLOOP;    IF gftFreeList = allGone THEN RETURN WITH ERROR NoGlobalFrameSlots    ELSE      BEGIN      gfi ¬ gftFreeList;      gftFreeList ¬ PrincOpsExtras2.GFT[gftFreeList].next;      PrincOpsExtras2.GFT[gfi].globalFrame ¬ frame;      PrincOpsExtras2.GFT[gfi].codebase ¬ codebase;      END;    ProcessOperations.Exit[@gftLock];    END;  RemoveGlobalFrame: PUBLIC --ENTRY-- PROCEDURE [frame: LongGlobalFrameHandle] =    BEGIN    gfi: GFTHandle ¬ FrameExtras.LongGFToGFTHandle[frame];    UNTIL ProcessOperations.Enter[@gftLock] DO ENDLOOP;    PrincOpsExtras2.GFT[gfi] ¬ PrincOpsExtras2.EmptyGFTItem;    PrincOpsExtras2.GFT[gfi].next ¬ gftFreeList;    gftFreeList ¬ gfi;    ProcessOperations.Exit[@gftLock];    END;  --========== Bcd Info Table Monitor Entry Procedures:  -- NOTE: bcdInfoLock is manipulated by manual monitor operations.  ExpandTables: PRIVATE --ENTRY-- PROC --LOCKS bcdInfoLock-- [    totalBcdsNeeded, totalModulesNeeded: CARDINAL] =    BEGIN    ENABLE UNWIND => ProcessOperations.Exit[@bcdInfoLock];    UNTIL ProcessOperations.Enter[@bcdInfoLock] DO ENDLOOP;    [] ¬ ExpandTablesInternal[      totalBcdsNeeded: totalBcdsNeeded, totalModulesNeeded: totalModulesNeeded];    ProcessOperations.Exit[@bcdInfoLock];    END;  ExpandTablesInternal: PUBLIC --LoadState. INTERNAL-- PROC  --LOCKS bcdInfoLock--    [totalBcdsNeeded, totalModulesNeeded: CARDINAL]    RETURNS [LoadStateFormat.Handle, LoadState.LPBcdInfoTable] =    BEGIN    fullGroupSize: CARDINAL =      extraBcdProportion * LoadStateFormat.BcdInfo.SIZE +        extraModuleProportion * LoadStateFormat.ModuleInfo.SIZE;    newMaxBcds, newMaxModules: CARDINAL;    minLoadStateSize, extraWords, extraFullGroups: CARDINAL;    pages: Environment.PageCount;    IF loadState.maxBcds >= totalBcdsNeeded      AND loadState.maxModules >= totalModulesNeeded + countModuleInfoPad THEN      RETURN[loadState, bcdInfo];    minLoadStateSize ¬      LoadStateFormat.Object.SIZE + totalBcdsNeeded * LoadStateFormat.BcdInfo.SIZE        + totalModulesNeeded * LoadStateFormat.ModuleInfo.SIZE;    pages ¬ Space.PagesFromWords[minLoadStateSize] + extraLoadStatePages;    extraWords ¬ CARDINAL[pages * wordsPerPage - minLoadStateSize];    extraFullGroups ¬ extraWords / fullGroupSize;    newMaxBcds ¬ totalBcdsNeeded + (extraFullGroups * extraBcdProportion);    newMaxModules ¬      totalModulesNeeded + (extraFullGroups * extraModuleProportion);    newMaxModules ¬      newMaxModules +  -- Put final bit of space into modules.        (extraWords - extraFullGroups * fullGroupSize) /          LoadStateFormat.ModuleInfo.SIZE;    BEGIN    -- Since the bcd table is referenced much less often than the module table,    -- we could put it in a separate swap unit; but since the bcd table    -- is so small, why bother?    oldLoadState: LoadStateFormat.Handle = loadState;    oldLoadStateStorage: LoadStateStorage = loadStateStorage;    newLoadState: LoadStateFormat.Handle = Space.Map[      window: [file: File.nullFile, base: TRASH, count: pages],      usage: KernelSpaceUsage.workingLoadState, class: data, access: readWrite,      life: dead, swapUnits: [unitary[]]].mapUnit.pointer;    NewLoadState[      newLoadState: newLoadState, newMaxBcds: newMaxBcds,      newMaxModules: newMaxModules];    SELECT oldLoadStateStorage FROM      dynamicCopy => [] ¬ Space.Unmap[oldLoadState];      initial =>  --        -- We are not sure that MakeBoot allocated the initial load state        -- in its own space, and thus do not unmap it. It will just swap out.        NULL;      ENDCASE;    loadStateStorage ¬ dynamicCopy;    END;    loadStateGrows ¬ loadStateGrows.SUCC;    RETURN[loadState, bcdInfo];    END;  --ExpandTablesInternal--  GetBcdTime: PUBLIC --Runtime. ENTRY-- PROC  --LOCKS bcdInfoLock--    RETURNS [bcdTime: System.GreenwichMeanTime] =    BEGIN    callerLFrame: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];    callerGFI: GFTHandle = FrameExtras.ReadGlobalLink[callerLFrame];    bii: LoadState.BcdInfoIndex;    UNTIL ProcessOperations.Enter[@bcdInfoLock] DO ENDLOOP;    bii ¬ GetModuleInfo[LOOPHOLE[callerGFI]].index;    bcdTime ¬ [bcdInfo[bii].base.version.time];    ProcessOperations.Exit[@bcdInfoLock];    END;  --GetBcdTime--  LockBcdInfo: PUBLIC --LoadState.-- --ENTRY-- PROC --LOCKS bcdInfoLock-- []    RETURNS [LoadStateFormat.Handle, LoadState.LPBcdInfoTable] = {    -- NOTE: DO NOT name the return parameters. Their names collide    --  with the globals of the same name.    UNTIL ProcessOperations.Enter[@bcdInfoLock] DO ENDLOOP;    RETURN[loadState, bcdInfo]};  -- returns with monitor locked.  <<GetUnaliasedPointers: PRIVATE --INTERNAL-- PROC --LOCKS bcdInfoLock-- []    RETURNS [LoadStateFormat.Handle, LPBcdInfoTable] =    -- This proc is necessary to avoid the aliasing    -- caused by the arg names of LockBcdInfo.    INLINE {RETURN[loadState, bcdInfo]};>>  UnlockBcdInfo: PUBLIC --LoadState.-- --INTERNAL-- PROC  --LOCKS bcdInfoLock--    [] = {ProcessOperations.Exit[@bcdInfoLock]};  --========== Module Info Table Monitor Entry Procedures:  EnterModuleInfos: PUBLIC --LoadState.-- ENTRY PROCEDURE [    moduleInfoSeq: LoadState.ModuleInfoSequenceHandle] =    BEGIN    -- Allocate module table slots:    IF loadState.nModules + moduleInfoSeq.length + countModuleInfoPad >      loadState.maxModules THEN      RETURN WITH ERROR TablesFull[  -- must end with >= one free slot.        totalBcdsNeeded: loadState.nBcds,        totalModulesNeeded: loadState.nModules + moduleInfoSeq.length];    FOR mi: CARDINAL IN [0..moduleInfoSeq.length) DO      found: BOOLEAN;      newMii: LoadState.ModuleInfoIndex;      [found: found, mii: newMii] ¬ FindModule[moduleInfoSeq[mi].gfi];      IF found THEN RETURN WITH ERROR DuplicateGFrame;  -- client error.      InsertNewModule[@moduleInfoSeq[mi], newMii];      ENDLOOP;    END;  --EnterModuleInfos--  GetModuleInfo: PUBLIC --LoadState.-- ENTRY PROC [gfi: GFTHandle]    RETURNS [info: LoadStateFormat.ModuleInfo] =    BEGIN    found: BOOLEAN;    mii: LoadState.ModuleInfoIndex;    [found: found, mii: mii] ¬ FindModule[gfi];    IF NOT found THEN RETURN WITH ERROR GFrameNotFound;  -- client error.    RETURN[moduleInfo[mii]];    END;  --GetModuleInfo--  GFFromBcdInfo: PUBLIC --LoadState.-- ENTRY PROCEDURE [    cgfi: NATURAL, bcdIndex: LoadState.BcdInfoIndex] RETURNS [gfi: GFTHandle] =    BEGIN    FOR m: LoadState.ModuleInfoIndex IN [0..loadState.nModules) DO      IF moduleInfo[m].index = bcdIndex AND moduleInfo[m].cgfi = cgfi THEN        RETURN OriginalModuleInternal[moduleInfo[m].gfi];      ENDLOOP;    ERROR GFrameNotFound;  -- client error.    END;  --GFFromBcdInfo--  MarkModuleResolved: PUBLIC --LoadState.-- ENTRY PROCEDURE [    gfi: GFTHandle, value: BOOLEAN] =    BEGIN    found: BOOLEAN;    mii: LoadState.ModuleInfoIndex;    [found: found, mii: mii] ¬ FindModule[gfi];    IF NOT found THEN RETURN WITH ERROR GFrameNotFound;  -- client error.    moduleInfo[mii].resolved ¬ value;    END;  --MarkModuleResolved--  ModuleInfosOfBcd: PUBLIC --LoadState.-- ENTRY PROC [    bcdIndex: LoadState.BcdInfoIndex, zone: UNCOUNTED ZONE]    RETURNS [moduleInfoSeq: LoadState.ModuleInfoSequenceHandle] =    BEGIN    nBcdModules: CARDINAL ¬ 0;    FOR m: LoadState.ModuleInfoIndex IN [0..loadState.nModules) DO      IF moduleInfo[m].index = bcdIndex THEN nBcdModules ¬ nBcdModules + 1;      ENDLOOP;    IF nBcdModules = 0 THEN RETURN[NIL];  -- wierd, probably impossible    moduleInfoSeq ¬ zone.NEW[LoadState .ModuleInfoSequence[nBcdModules]];    moduleInfoSeq.length ¬ 0;    FOR m: LoadState.ModuleInfoIndex IN [0..loadState.nModules) DO      IF moduleInfo[m].index = bcdIndex THEN {        moduleInfoSeq[moduleInfoSeq.length] ¬ moduleInfo[m];        moduleInfoSeq.length ¬ moduleInfoSeq.length.SUCC};      ENDLOOP;    END;  --ModuleInfosOfBcd--  NewInternal: PRIVATE ENTRY PROC [    oldProg: PROGRAM, newGFrame: LongGlobalFrameHandle, linkWords: CARDINAL]    RETURNS [newProg: PROGRAM] =    -- Validates oldProg, initializes new gFrame, enters in module info table.    -- newGFrame­ is sufficient storage for the frame.    -- Caller MUST catch TablesFull.    BEGIN    -- Be careful what you do before oldProg is validated!    oldGFrame: LongGlobalFrameHandle = GFrameFromProgram[oldProg];    found: BOOLEAN;    oldMii, newMii: LoadState.ModuleInfoIndex;    newModuleInfo: LoadStateFormat.ModuleInfo;    newGfi: GFTHandle;    oldGfi: GFTHandle ¬ GFIFromProg[oldProg];    -- Validate, locate:    [found: found, mii: oldMii] ¬ FindModule[oldGfi];    IF NOT found THEN RETURN WITH ERROR InvalidGlobalFrame[LOOPHOLE[oldProg]];    --ASSERT: oldGFrame is a valid global frame.    newProg ¬ ProgFromGlobalFrame[newGFrame];    -- Allocate module table slot:    IF loadState.nModules.SUCC >= loadState.maxModules THEN  --      RETURN WITH ERROR TablesFull[  -- must end with >= one free slot.        totalBcdsNeeded: loadState.nBcds,        totalModulesNeeded: loadState.nModules.SUCC];    -- Initialize new gFrame:    BEGIN    codebase: PrincOps.GlobalCodebase ¬ LOOPHOLE[CodebaseFromProgram[oldProg]];    oldGlobalOverhead: LONG POINTER TO GlobalOverhead ¬      FrameExtras.GlobalOverhead[oldGFrame];    newGlobalOverhead: LONG POINTER TO GlobalOverhead =      LOOPHOLE[newGFrame - GlobalOverhead.SIZE];    codebase.out ¬ TRUE;  -- causes start trap    newGfi ¬ EnterGlobalFrame[newGFrame, codebase];    newGlobalOverhead­ ¬ [  -- (ok to write directly since not a gframe yet)      extra: [      unused: TRASH, started: FALSE, copy: TRUE, copied: FALSE, alloced: FALSE,      shared: TRASH],      word: [      gfi: PrincOpsExtras2.GFTHandleToIndex[newGfi],      trapxfers: oldGlobalOverhead.word.trapxfers,      codelinks: oldGlobalOverhead.word.codelinks], global: NULL];    newGFrame[0] ¬ NIL;  -- no control modules.    IF linkWords > 0 THEN      Inline.LongCOPY[        from: oldGFrame - GlobalOverhead.SIZE - linkWords,        to: newGFrame - GlobalOverhead.SIZE - linkWords, nwords: linkWords];    END;    -- Begin irrevocable changes:  (NO ERRORs past here, please)    -- Insert into module table:    newMii ¬ FindModule[newGfi].mii;    newModuleInfo ¬ moduleInfo[oldMii];  -- (grab before we move it)    newModuleInfo.gfi ¬ newGfi;    InsertNewModule[@newModuleInfo, newMii];    -- Insert into copy table:    BEGIN    IF originalOfCopy.nCopies >= originalOfCopy.maxCopies THEN GrowCopyTable[];    originalOfCopy[originalOfCopy.nCopies] ¬ [      copy: newGfi, original: OriginalModuleInternal[oldGfi]];    originalOfCopy.nCopies ¬ originalOfCopy.nCopies.SUCC;    END;    news ¬ news.SUCC;    END;  --NewInternal--  NewLoadState: PRIVATE ENTRY PROC [    newLoadState: LoadStateFormat.Handle, newMaxBcds, newMaxModules: CARDINAL] =    BEGIN    -- Storage layout order is: Header, module table, bcd table.    newLoadState­ ¬ [      versionident: LoadStateFormat.VersionID, nModules: loadState.nModules,      maxModules: newMaxModules, nBcds: loadState.nBcds, maxBcds: newMaxBcds,      nextID: loadState.nextID, moduleInfo: LOOPHOLE[LoadStateFormat.Object.SIZE],      bcdInfo:      LOOPHOLE[LoadStateFormat.Object.SIZE +                 newMaxModules * LoadStateFormat.ModuleInfo.SIZE]];    Inline.LongCOPY[      from: @loadState[loadState.moduleInfo],      to: @newLoadState[newLoadState.moduleInfo],      nwords:      (loadState.nModules + countModuleInfoPad) *        LoadStateFormat.ModuleInfo.SIZE];    Inline.LongCOPY[      from: @loadState[loadState.bcdInfo],      to: @newLoadState[newLoadState.bcdInfo],      nwords: loadState.nBcds * LoadStateFormat.BcdInfo.SIZE];    esv.loadStateChanging ¬ TRUE;    loadState ¬ CPSwapDefs.PESV[].loadState ¬ newLoadState;    bcdInfo ¬ LOOPHOLE[@loadState[loadState.bcdInfo]];    moduleInfo ¬ @loadState[loadState.moduleInfo];    esv.loadStateDirty ¬ TRUE;    esv.loadStateChanging ¬ FALSE;    END;  --NewLoadState--  NextMultipleOfSixtyFourK: PROC [n: LONG UNSPECIFIED]    RETURNS [LONG UNSPECIFIED] = INLINE {    OPEN num: LOOPHOLE[n, Inline.LongNumber];    num.lowbits ¬ 0;    num.highbits ¬ num.highbits + 1;    RETURN[n]};  RemoveModuleInfos: PUBLIC --LoadState.-- ENTRY PROCEDURE [    bcdIndex: LoadState.BcdInfoIndex] =    BEGIN    mii: LoadState.ModuleInfoIndex ¬ 0;    WHILE mii < loadState.nModules DO  -- (Note: nModules may decrease during loop.)      SELECT moduleInfo[mii].index FROM        bcdIndex => {RemoveOldModule[mii]};  -- (and don't increment mii)        > bcdIndex => {          moduleInfo[mii].index ¬ moduleInfo[mii].index - 1; mii ¬ mii.SUCC};        ENDCASE => mii ¬ mii.SUCC;      ENDLOOP;    -- now remove from bcdInfo    FOR bii: LoadState.BcdInfoIndex IN (bcdIndex..loadState.nBcds) DO      bcdInfo[bii - 1] ¬ bcdInfo[bii]; ENDLOOP;    loadState.nBcds ¬ loadState.nBcds - 1;    END;  --RemoveModuleInfos--  UnNew: PUBLIC --Runtime.-- ENTRY PROC [frame: PROGRAM] =    BEGIN    -- Be careful what you do before frame is validated!    gFrame: LongGlobalFrameHandle = GFrameFromProgram[frame];    gfi: GFTHandle ¬ GFIFromProg[frame];    found: BOOLEAN;    mii: LoadState.ModuleInfoIndex;    -- Validate, locate:    [found: found, mii: mii] ¬ FindModule[gfi];    IF NOT found THEN RETURN WITH ERROR InvalidGlobalFrame[LOOPHOLE[frame]];    --ASSERT: gFrame is a valid global frame.    IF NOT FrameExtras.GlobalOverhead[gFrame].extra.copy THEN      RETURN WITH ERROR NotANewedProgram[LOOPHOLE[frame]];    FOR k: CARDINAL IN [0..originalOfCopy.nCopies) DO      IF originalOfCopy[k].copy = gfi THEN        BEGIN  -- squish out old entry        Inline.LongCOPY[          from: @originalOfCopy[k.SUCC], to: @originalOfCopy[k],          nwords: (originalOfCopy.nCopies - k.SUCC) * OriginalOfCopyEntry.SIZE];        originalOfCopy.nCopies ¬ originalOfCopy.nCopies.PRED;        EXIT;        END;      REPEAT FINISHED => ERROR Bug[notInCopyTable];      ENDLOOP;    -- Delete from Module Table and Free the gFrame storage:    BEGIN    mds: LONG ORDERED POINTER ¬ LOOPHOLE[StoragePrograms.PMDS[]];    mdsCount: LONG CARDINAL ¬ Inline.LongMult[      Environment.maxPagesInMDS, Environment.wordsPerPage];    codebase: PrincOps.PrefixHandle = CodebaseFromProgram[frame];    linkWords: CARDINAL =      (IF FrameExtras.GlobalOverhead[gFrame].word.codelinks THEN 0       ELSE --frame links-- codebase.header.nlinks * LinkSize);    gFrameOffset: CARDINAL =      LoadState.RuntimeOverheadHandle.SIZE + linkWords + GlobalOverhead.SIZE;    rgo: LoadState.RuntimeOverheadHandle = LOOPHOLE[gFrame - gFrameOffset];    RemoveOldModule[mii];  -- delete from module table (zaps codebase)    RemoveGlobalFrame[gFrame];  -- delete from global frame table    IF LOOPHOLE[rgo.storage, LONG ORDERED POINTER] IN [mds..mds + mdsCount) THEN      Heap.FreeMDSNode[gFrameMDSZone, ToMDSFrame[LOOPHOLE[rgo.storage]]]    ELSE Heap.FreeNode[gFrameZone, rgo.storage];    END;    END;  --UnNew--  OriginalModule: PUBLIC --LoadState.-- ENTRY PROC [gfi: GFTHandle]    RETURNS [originalGFI: GFTHandle] = {RETURN OriginalModuleInternal[gfi]};  UnresolvedModuleInfosOfBcd: PUBLIC --LoadState.-- ENTRY PROCEDURE [    bcdIndex: LoadState.BcdInfoIndex, zone: UNCOUNTED ZONE]    RETURNS [moduleInfoSeq: LoadState.ModuleInfoSequenceHandle] =    BEGIN    maxUnresolvedModules: CARDINAL ¬ maxTypicalNumberOfUnresolvedModulesOfBcd;    Overflow: ERROR = CODE;    BEGIN    ENABLE Overflow => {maxUnresolvedModules ¬ maxUnresolvedModules * 2; RETRY};    moduleInfoSeq ¬ NIL;    FOR m: LoadState.ModuleInfoIndex IN [0..loadState.nModules) DO      IF moduleInfo[m].index = bcdIndex AND NOT moduleInfo[m].resolved THEN        BEGIN        IF moduleInfoSeq = NIL THEN {          moduleInfoSeq ¬ zone.NEW[            LoadState .ModuleInfoSequence[maxUnresolvedModules]];          moduleInfoSeq.length ¬ 0};        IF moduleInfoSeq.length = moduleInfoSeq.maxLength THEN {          zone.FREE[@moduleInfoSeq]; ERROR Overflow};        moduleInfoSeq[moduleInfoSeq.length] ¬ moduleInfo[m];        moduleInfoSeq.length ¬ moduleInfoSeq.length.SUCC;        END;      ENDLOOP;    END;  --ENABLE Overflow--    END;  --UnresolvedModuleInfosOfBcd--  ValidateFrame: PUBLIC --Runtime.-- ENTRY PROC [frame: LocalFrameHandle] =    BEGIN    IF LOOPHOLE[frame, CARDINAL] MOD 4 = 0 AND frame # NIL THEN {      gfi: GFTHandle = FrameExtras.ReadGlobalLink[frame];      IF ValGlobalFrame[ProgFromGFI[gfi]].valid THEN RETURN};    RETURN WITH ERROR InvalidFrame[LOOPHOLE[frame]];    END;  ValidateGlobalFrame: PUBLIC --Runtime.-- ENTRY PROC [frame: LONG UNSPECIFIED] =    {    IF NOT ValGlobalFrame[LOOPHOLE[frame]].valid THEN      RETURN WITH ERROR InvalidGlobalFrame[LOOPHOLE[frame]]};  ValidGlobalFrame: PRIVATE ENTRY PROC [prog: PROGRAM] RETURNS [BOOLEAN] = INLINE    {RETURN[ValGlobalFrame[prog].valid]};  --===== Module Info Table Monitor Internal Procedures: =====  FindModule: INTERNAL PROCEDURE [gfi: GFTHandle]    RETURNS [found: BOOLEAN, mii: LoadState.ModuleInfoIndex] =    -- Searches the Module Info Table for gFrame.    -- If found, returns found=TRUE and its index.    -- If not found, returns found=FALSE and the index of the first entry    -- whose global frame handle > gFrame. This may be the index of    -- the "top" entry in the table.    BEGIN    indexFirst: LoadState.ModuleInfoIndex = LoadState.ModuleInfoIndex.FIRST;    index, indexLow, indexHigh: INTEGER;  -- (indexHigh can be -1)    gfiComp: GFTHandle;    BEGIN  --scope of SameAsLastTime--    IF miiMru >= loadState.nModules THEN miiMru ¬ 0;  -- assure still reasonable.    IF gfi = gfiTop THEN RETURN[found: FALSE, mii: loadState.nBcds];    IF gfi = moduleInfo[miiMru].gfi THEN GOTO SameAsLastTime;    moduleTableFullSearches ¬ moduleTableFullSearches.SUCC;    indexLow ¬ LoadState.ModuleInfoIndex.FIRST;    indexHigh ¬ loadState.nModules;    DO  --UNTIL search terminates--      index ¬ (indexLow + indexHigh) / 2;      gfiComp ¬ moduleInfo[index].gfi;      IF gfi < gfiComp THEN indexHigh ¬ index - 1        -- Note that indexHigh might be indexDescLow-1 here. Must use integers.      ELSE IF gfi > gfiComp THEN indexLow ¬ index + 1 ELSE GOTO Exact;      IF indexHigh < indexLow THEN GOTO NotExact;      ENDLOOP;  --DO UNTIL search terminates--    EXITS      Exact => {found ¬ TRUE; mii ¬ index};      NotExact => {        -- Assert: gfi > moduleInfo[indexHigh].gfi AND        -- gfi < moduleInfo[indexLow].gfi AND indexLow = indexHigh+1.        found ¬ FALSE; mii ¬ indexLow};      SameAsLastTime => {        moduleTableFastSearches ¬ moduleTableFastSearches.SUCC;        found ¬ TRUE;        mii ¬ miiMru};    END;  --scope of SameAsLastTime--    miiMru ¬ mii;  -- remember for next time.    END;  --FindModule--  GrowCopyTable: INTERNAL PROCEDURE [] =    -- A separate proc to get this seldom-used code out of a hot code pack.    BEGIN    newMaxCopies: CARDINAL = originalOfCopy.maxCopies * 4;    node: Environment.Base RELATIVE POINTER TO OriginalOfCopy;    status: Zone.Status;    [node, status] ¬ ResidentHeap.MakeNode[      n: SIZE[OriginalOfCopy [newMaxCopies]], location: first64K];    IF status # okay THEN ERROR Bug[noHeapSpace];    Inline.LongCOPY[      from: originalOfCopy, to: @ResidentHeap.first64K[node],      nwords: SIZE[OriginalOfCopy [originalOfCopy.nCopies]]];    status ¬ ResidentHeap.FreeNode[      p: Inline.LowHalf[originalOfCopy - ResidentHeap.first64K],      location: first64K];    IF status # okay THEN ERROR Bug[errorOnFree];    originalOfCopy ¬ @ResidentHeap.first64K[node];    LOOPHOLE[@originalOfCopy.seq, LONG POINTER TO CARDINAL]­ ¬ newMaxCopies;    END;  --GrowCopyTable--  InsertNewModule: INTERNAL PROCEDURE [    info: LONG POINTER TO LoadStateFormat.ModuleInfo,    newMii: LoadState.ModuleInfoIndex] =    BEGIN    -- We try to manipulate the table so that the debugger    -- will see a sensible state almost all of the time.    esv.loadStateChanging ¬ TRUE;    Inline.LongCOPYReverse[  -- open up slot      from: @moduleInfo[newMii], to: @moduleInfo[newMii + 1],      nwords:      (loadState.nModules + countModuleInfoPad - newMii) *        LoadStateFormat.ModuleInfo.SIZE];    loadState.nModules ¬ loadState.nModules.SUCC;    moduleInfo[newMii] ¬ info­;    esv.loadStateDirty ¬ TRUE;    esv.loadStateChanging ¬ FALSE;    IF loadState.nModules >= loadState.maxModules THEN  --      ERROR Bug[noExtraSlot];  -- must have one free slot.    END;  InvalidateCodebase: PROC [gfi: GFTHandle] = INLINE {  -- (only called once)    globalCodeBase: PrincOps.GlobalCodebase ¬ [code[NIL]];    globalCodeBase.out ¬ TRUE;  -- causes start trap if gFrame is erroneously used.    FrameExtras.WriteCodebase[gfi: gfi, cb: globalCodeBase]};  OriginalModuleInternal: INTERNAL PROCEDURE [gfi: GFTHandle]    RETURNS [originalGFI: GFTHandle] =    BEGIN    FOR k: CARDINAL IN [0..originalOfCopy.nCopies) DO      IF originalOfCopy[k].copy = gfi THEN RETURN[originalOfCopy[k].original];      ENDLOOP;    RETURN[gfi];  -- not a copy.    END;  --OriginalModuleInternal--  RemoveOldModule: INTERNAL PROCEDURE [oldMii: LoadState.ModuleInfoIndex] =    BEGIN    InvalidateCodebase[moduleInfo[oldMii].gfi];  -- try to catch accidental use.    esv.loadStateChanging ¬ TRUE;    -- We try to manipulate the table so that the debugger    -- will see a sensible state almost all of the time.    Inline.LongCOPY[  -- squeeze out slot      from: @moduleInfo[oldMii + 1], to: @moduleInfo[oldMii],      nwords:      (loadState.nModules + countModuleInfoPad - oldMii) *        LoadStateFormat.ModuleInfo.SIZE];    loadState.nModules ¬ loadState.nModules.PRED;    esv.loadStateDirty ¬ TRUE;    esv.loadStateChanging ¬ FALSE;    END;  --RemoveOldModule--  ValGlobalFrame: INTERNAL PROC [prog: PROGRAM] RETURNS [valid: BOOLEAN] = {    -- since PROGRAMS and Global frames are the same, test page boundary and tag.    IF (Inline.LowByte[Inline.LowHalf[LOOPHOLE[prog, LONG CARDINAL]]] = 0) OR       (LOOPHOLE[prog, PrincOpsExtras2.ControlLink].tag #         FIRST[PrincOpsExtras2.ControlLinkTag])     THEN RETURN[valid: FALSE]     ELSE RETURN[valid: FindModule[GFIFromProg[prog]].found]};  END.LOG   (For earlier log entries, please see Mesa 10.0 archive version.)22-Dec-81 14:44:39   BTL     Fix AllocGlobalFrame to deal properly with frame links.28-Dec-81 11:13:09   BTL     Removed GlobalOverhead.SIZE additions in AllocGlobalFrame   and UnNew calculations for frame links.25-Jan-82 18:55:30   CRF   Changed InGFT to dereference g only when it's in the GFT.16-Sep-82  9:29:22   WDK        AR 12283: Keep track of large dynamically-allocated frames. Use ops from   ProcessInternal. AR 7431: Frame creator is not using storage optimally.28-Oct-82 10:36:34   WDK     	Added perf counters.21-Dec-82 15:26:26   AWL      	NewSpace => Space. 8-Feb-83 10:40:55   WDK         FrameSize did not account for frame overhead. MakeFsi failed to detect overflow. Frame segment list maintenance was wrong. 2-Mar-83 16:06:44   WDK     	DisableAborts on cond vars.30-Jun-83 16:44:21   WDK     	Get load state from esv.14-Jul-83 17:42:45   AXD    	The demise of the global frame table.20-Jul-83 13:41:09   JXP   	Add the EntryVector PROCEDURE. 8-Aug-83 15:32:58   WDK        Major Changes:  Split LoadStateImpl off from FrameImpl. Restructure into two monitors. Use new types in LoadState interface. Use binary search for module table. New and UnNew were rewritten. Use heap for NEWed frames instead of local frame heap. Delete ERROR NoGlobalFrameSlots, added NotANewedProgram. Ditch use of copied and shared flags. Add code to manage module table. Add facilities to expand load state tables. Added InitializeFrameImplB.   Bug Fixes and Small Improvements:  GlobalFrame[proc] was wrong. EntryVector, Code, and GetTableBase didn't validate frame. Code failed on proc link. GetBuildTime was wrong. Grab build time early before UtilityPilot ditches it. GlobalFrame did not validate gFrame if arg was proc link, failed to signal if given NIL gFrame or invalid indirect link (just returned NIL). IsBound now uses NIL. ValidateFrame did not check for NIL. GetBcdTime failed on NEWed frames and did not validata frame. SelfDestruct will now handle caller not being top frame in module. Proc type of New (formerly Copy) was wrong. Documented meaning of fields of GlobalWord. Better implementation of Codebase. Refactor code that looks at links. UnboundProcedure raised as ERROR. Add type converters. Add perf counters. Invalidate codebase of UnNewed frames. Additional check in IsBound to handle discarded local procs.24-Aug-83 14:56:35   JXP   	Assign to return parm. in NewInternal.24-Aug-83 16:14:44   RXJ     	globalWord tested before set in UnNew.26-Aug-83 10:35:11   WDK        Unnew didn't decrement nModules. Avoid address fault in opening up module table.28-Aug-83 14:49:13   JXP      Explicitly add glob. overhead when calculating the frame size in New. 7-Sep-83  9:40:32   WDK        Add new procs for loader. Make compatible with new LoadState. Didn't check load state version. Temp use .copied to indicate dynamicaly loaded gFrame.26-Sep-83 14:30:36   JXP      Uninitialized variable in ModuleInfosOfBcd.26-Sep-83 10:50:50   RES  	?28-Sep-83  9:37:56   WDK        Added copy table, implement OriginalModule. Merged InvalidateCodebase and RemoveOldModule. Must use countModuleInfoPad in growing load state.28-Sep-83 15:11:56   WDK     	Can't use ResidentHeap until InitializeLoadStateB.28-Sep-83 15:11:56   WDK     	Must update ESV when load state grows.20-Oct-83  9:41:44   WDK        UnNew[module with frame links] died. New registered source frame, not original. GFFromBcdInfo did not return info about ORIGINAL instance. 9-Nov-83 14:42:31   WDK     	ExpandTablesInternal now returns new pointers.30-Jun-86 20:15:13   MEW	Rolled forward to new Princops. added EnterGlobalFrame, RemoveGlobalFrame.15-Jan-87  0:50:12   ET		Moved Rons edits of next line:15-Oct-86 10:58:56   RSV        Move definition of cBadLoadStateVersion into PilotMP.14-Feb-87 17:26:15   ET         Changed RemoveGlobalFrame to work right for unloading (took out a few lines for linking up free list). 4-Mar-87 12:07:13   ET		Fixed New/UnNew to take global frames of out of hyperspace if their parent global frame came from there (parent was mds-reliefed). Changed allGone for entering more global frames into GFT to nullGFH, just in case makeboot does something different.28-May-87 11:47:13   ET		UnNewing needed to call RemoveGlobalFrame. 5-Aug-87 14:56:24   WDK	New must check page and 64K alignment.27-Oct-87 19:25:36   ET         Added NIL check in GlobalFrame proc(AR11298). Added more checking to ValGlobalFrame and to StuffFromLink shortProc arm.(AR11476). Make GlobalFrame handle frame and indirect links as in 12.3 (AR12104).
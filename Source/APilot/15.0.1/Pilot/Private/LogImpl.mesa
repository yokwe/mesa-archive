-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- LogImpl.mesa (last edited by: ET    on: 29-Jan-87 21:18:37)DIRECTORY  File USING [File, nullFile, GetSize, PageNumber],  Inline USING [LongCOPY],  Log,  LogInternal USING [commonLength, Entry, Header, startIndex, Type, versionNo],  System USING [GetGreenwichMeanTime, gmtEpoch, GreenwichMeanTime],  Space USING [Access, ForceOut, Interval, MakeWritable, Map, PageCount,    SwapUnitOption, Unmap, Window, wordsPerPage];LogImpl: MONITOR  IMPORTS File, Inline, Log, Space, System  EXPORTS Log =  BEGIN  logCap:    PUBLIC File.File ¬ File.nullFile;  available: CARDINAL;  entryFlag: BOOLEAN;  entrySize: CARDINAL;  blocks: ARRAY [0..LogInternal.commonLength + maxEntrySize) OF UNSPECIFIED;  maxEntrySize: CARDINAL = Space.wordsPerPage - 1;  startMinusOne: Log.Index = LogInternal.startIndex - 1;  logIndex:    Log.Index;  logLevel:    Log.Level;  logOpened:   BOOLEAN ¬ FALSE;  logOverflow: Log.Overflow ¬ wrap;  logSpace:    Space.Interval;  logState:    Log.State;  logWindow:   Space.Window;  pHeader:   LONG POINTER TO LogInternal.Header;  pEntry:    LONG POINTER TO LogInternal.Entry;  tempEntry: LONG POINTER TO LogInternal.Entry;  tempFirst: Log.Index;  logSize:    Space.PageCount;  maxLogSize: Space.PageCount = 256;  minLogSize: Space.PageCount = 4;  swapUnit:   Space.SwapUnitOption = [uniform[1]];  -- ERRORs  Error: PUBLIC ERROR [reason: Log.ErrorType] = CODE;  -- PUBLIC PROCEDUREs  Close: PUBLIC ENTRY PROCEDURE =    BEGIN    ENABLE UNWIND => NULL;    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    Space.MakeWritable[logSpace];    pHeader.curIndex ¬ logIndex;    pHeader.overflowAction ¬ logOverflow;    pHeader.state ¬ logState;    logSpace.pointer ¬ Space.Unmap[logSpace.pointer];    logOpened ¬ FALSE;    logCap ¬ File.nullFile;    END;  Disable: PUBLIC ENTRY PROCEDURE RETURNS [state: Log.State] =    BEGIN    ENABLE UNWIND => NULL;    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    state ¬ logState;    logState ¬ off;    Space.MakeWritable[logSpace];    Space.ForceOut[logSpace];    END;  GetCount: PUBLIC ENTRY PROCEDURE RETURNS [count: CARDINAL] =    BEGIN    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    count ¬ pHeader.count    END;  GetIndex: PUBLIC ENTRY PROCEDURE RETURNS [index: Log.Index] =    BEGIN IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened]; index ¬ logIndex; END;  GetLost: PUBLIC ENTRY PROCEDURE RETURNS [lost: CARDINAL] =    BEGIN    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    lost ¬ pHeader.lost    END;  -- GetRestart: PUBLIC ENTRY PROCEDURE RETURNS[restart: Log.Restart] =  -- BEGIN  -- IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];  -- restart ¬ pHeader.restart;  -- END;  GetState: PUBLIC ENTRY PROCEDURE RETURNS [state: Log.State] =    BEGIN IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened]; RETURN[logState]; END;  GetUpdate: PUBLIC ENTRY PROCEDURE RETURNS [time: System.GreenwichMeanTime] =    BEGIN    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    pEntry ¬ LOOPHOLE[pHeader + pHeader.last];    IF pHeader.count = 0 THEN RETURN WITH ERROR Log.Error[logNoEntry];    time ¬ pEntry.time;    END;  Install: PUBLIC ENTRY PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber] =    BEGIN    ENABLE UNWIND => NULL;    IF logCap = File.nullFile THEN logCap ¬ file    ELSE RETURN WITH ERROR Log.Error[illegalLog];    IF File.GetSize[file] < minLogSize THEN RETURN WITH ERROR Log.Error[tooSmallFile];    IF File.GetSize[file] > maxLogSize THEN logSize ¬ maxLogSize    ELSE logSize ¬ File.GetSize[file];    logWindow ¬ [file: logCap, base: firstPageNumber, count: logSize - firstPageNumber];    logSpace ¬ Space.Map[window: logWindow, swapUnits: swapUnit];    pHeader ¬ logSpace.pointer;    pHeader­ ¬ [      version: LogInternal.versionNo,      restart: [message: Log.nullIndex, time: System.gmtEpoch], count: 0, lost: 0,      curIndex: LogInternal.startIndex, start: LogInternal.startIndex,      next: LogInternal.startIndex, first: Log.nullIndex, last: Log.nullIndex,      end: Space.wordsPerPage*CARDINAL[logSize - firstPageNumber] - 1,      state: error, overflowAction: wrap, overflowed: FALSE];    Space.ForceOut[logSpace];    logOpened ¬ TRUE;  -- log file Open action    logState ¬ error;    logOverflow ¬ wrap;    logIndex ¬ LogInternal.startIndex;    END;  Open: PUBLIC ENTRY PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber] =    BEGIN    ENABLE UNWIND => NULL;    access: Space.Access ¬ readOnly;    IF logOpened THEN      BEGIN IF logCap = file THEN RETURN ELSE RETURN WITH ERROR Log.Error[invalidFile]; END;    IF File.GetSize[file] > maxLogSize THEN logSize ¬ maxLogSize    ELSE logSize ¬ File.GetSize[file];    logWindow ¬ [file: file, base: firstPageNumber, count: logSize - firstPageNumber];    logSpace ¬ Space.Map[window: logWindow, access: access, swapUnits: swapUnit];    pHeader ¬ logSpace.pointer;    IF pHeader.version # LogInternal.versionNo THEN {      logSpace.pointer ¬ Space.Unmap[logSpace.pointer];      RETURN WITH ERROR Log.Error[invalidFile]};    logCap ¬ file;    logOpened ¬ TRUE;    logOverflow ¬ pHeader.overflowAction;    logState ¬ pHeader.state;    logIndex ¬ pHeader.curIndex;    END;  PutBlock: PUBLIC ENTRY PROCEDURE [    level: Log.Level, pointer: LONG POINTER, size: CARDINAL,    forceOut: BOOLEAN ¬ FALSE] =    BEGIN    ENABLE UNWIND => NULL;    rep: CARDINAL;    tempEntry ¬ LOOPHOLE[@blocks];    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    Space.MakeWritable[logSpace];    IF pHeader.overflowed THEN {pHeader.lost ¬ pHeader.lost + 1; RETURN};    IF level > logState THEN RETURN;    tempEntry.time  ¬ System.GetGreenwichMeanTime[];    tempEntry.type  ¬ block;    tempEntry.level ¬ level;    tempEntry.index ¬ logIndex;    entrySize ¬ IF size > maxEntrySize THEN maxEntrySize ELSE size;    tempEntry.length ¬ entrySize;    FOR rep IN [0..entrySize) DO      tempEntry.body[rep] ¬ pointer­; pointer ¬ pointer + 1; ENDLOOP;    CommonProcess[entrySize, forceOut];    END;  PutString: PUBLIC ENTRY PROCEDURE [level: Log.Level, string: LONG STRING,    forceOut: BOOLEAN ¬ FALSE] =    BEGIN    ENABLE UNWIND => NULL;    rep: CARDINAL;    tempEntry ¬ LOOPHOLE[@blocks];    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    Space.MakeWritable[logSpace];    IF pHeader.overflowed THEN {pHeader.lost ¬ pHeader.lost + 1; RETURN};    IF level > logState THEN RETURN;    tempEntry.time ¬ System.GetGreenwichMeanTime[];    tempEntry.type ¬ string;    tempEntry.level ¬ level;    tempEntry.index ¬ logIndex;    entrySize ¬      IF string.length > maxEntrySize THEN maxEntrySize ELSE string.length;    tempEntry.length ¬ entrySize;    FOR rep IN [0..entrySize) DO tempEntry.body[rep] ¬ string[rep]; ENDLOOP;    CommonProcess[entrySize, forceOut];    END;  PutWord: PUBLIC ENTRY PROCEDURE [level: Log.Level, data: UNSPECIFIED,    forceOut: BOOLEAN ¬ FALSE] =    BEGIN    ENABLE UNWIND => NULL;    tempEntry ¬ LOOPHOLE[@blocks];    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    Space.MakeWritable[logSpace];    IF pHeader.overflowed THEN {pHeader.lost ¬ pHeader.lost + 1; RETURN};    IF level > logLevel THEN RETURN;    tempEntry.time ¬ System.GetGreenwichMeanTime[];    tempEntry.type ¬ block;    tempEntry.level ¬ level;    tempEntry.length ¬ 1;    tempEntry.body[0] ¬ data;    tempEntry.index ¬ logIndex;    CommonProcess[SIZE[UNSPECIFIED], forceOut];    END;  Reset: PUBLIC ENTRY PROCEDURE =    BEGIN    ENABLE UNWIND => NULL;    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    Space.MakeWritable[logSpace];    Space.ForceOut[logSpace];    pHeader.count ¬ pHeader.lost ¬ 0;    pHeader.next ¬ logIndex ¬ LogInternal.startIndex;    pHeader.first ¬ pHeader.last ¬ Log.nullIndex;    logState ¬ error;    logOverflow ¬ wrap;    pHeader.overflowed ¬ FALSE;    END;  SetOverflow: PUBLIC ENTRY PROCEDURE [option: Log.Overflow] =    BEGIN    ENABLE UNWIND => NULL;    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    logOverflow ¬ option;    IF option # disable THEN {Space.MakeWritable[logSpace]; pHeader.overflowed ¬ FALSE};    END;  SetRestart: PUBLIC ENTRY PROCEDURE [message: UNSPECIFIED] =    BEGIN    ENABLE UNWIND => NULL;    IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened];    Space.MakeWritable[logSpace];    pHeader.restart ¬ [message: message, time: System.GetGreenwichMeanTime[]]    END;  SetState: PUBLIC ENTRY PROCEDURE [state: Log.State] =    BEGIN IF ~logOpened THEN RETURN WITH ERROR Log.Error[logNotOpened]; logState ¬ state END;  -- PRIVATE PROCEDUREs  CommonProcess: INTERNAL PROCEDURE [length: CARDINAL, forceOut: BOOLEAN] =    BEGIN    remaining: CARDINAL ¬ pHeader.end - pHeader.next + 1;    IF pHeader.first = Log.nullIndex THEN pHeader.first ¬ LogInternal.startIndex    ELSE {      available ¬        IF pHeader.first < pHeader.next THEN          remaining + (pHeader.first - pHeader.start)        ELSE pHeader.first - pHeader.next;      IF length + LogInternal.commonLength > available THEN        entryFlag ¬ ProcessOverflow[block, length]      ELSE entryFlag ¬ TRUE;      IF ~entryFlag THEN RETURN};    pEntry ¬ LOOPHOLE[pHeader.next + pHeader];    remaining ¬ pHeader.end - pHeader.next + 1;    tempEntry.index ¬ logIndex;    IF remaining >= LogInternal.commonLength + length THEN      Inline.LongCOPY[        from: tempEntry, to: pEntry,	nwords: LogInternal.commonLength + tempEntry.length]    ELSE {      Inline.LongCOPY[from: tempEntry, nwords: remaining, to: pEntry];      pEntry ¬ LOOPHOLE[pHeader + LogInternal.startIndex];      tempEntry ¬ LOOPHOLE[@blocks + remaining];      Inline.LongCOPY[        from: tempEntry, nwords: length + LogInternal.commonLength - remaining,        to: pEntry]};    pHeader.count ¬ pHeader.count + 1;    pHeader.last  ¬ pHeader.next;    pHeader.next  ¬ pHeader.next + length + LogInternal.commonLength;    IF pHeader.next > pHeader.end THEN      pHeader.next ¬ pHeader.next - pHeader.end + startMinusOne    ELSE IF pHeader.end - pHeader.next + 1 < LogInternal.commonLength THEN      pHeader.next ¬ LogInternal.startIndex;    logIndex ¬ logIndex + length + LogInternal.commonLength;    IF logIndex > pHeader.end THEN      logIndex ¬ logIndex - pHeader.end + startMinusOne    ELSE IF pHeader.end - logIndex + 1 < LogInternal.commonLength THEN      logIndex ¬ LogInternal.startIndex;    IF forceOut THEN Space.ForceOut[logSpace];    END;  ProcessOverflow: INTERNAL PROCEDURE [type: LogInternal.Type, length: CARDINAL]    RETURNS [return: BOOLEAN] =    BEGIN    SELECT logOverflow FROM      = reset =>        BEGIN        Space.ForceOut[logSpace];        pHeader.count ¬ pHeader.lost ¬ 0;        pHeader.next ¬ logIndex ¬ pHeader.first ¬ LogInternal.startIndex;        pHeader.last ¬ Log.nullIndex;        logState ¬ error;        logOverflow ¬ wrap;        pHeader.overflowed ¬ FALSE;        return ¬ TRUE;        END;      = disable =>        BEGIN        pHeader.lost ¬ pHeader.lost + 1;        Space.ForceOut[logSpace];        pHeader.overflowed ¬ TRUE;        return ¬ FALSE;        END;      = wrap =>        BEGIN        IF pHeader.end - pHeader.next + 1 < LogInternal.commonLength THEN          BEGIN          available ¬ available - (pHeader.end - pHeader.next + 1);          pHeader.next ¬ logIndex ¬ LogInternal.startIndex;          END;        WHILE length + LogInternal.commonLength > available DO          pEntry ¬ LOOPHOLE[pHeader.first + pHeader];          tempFirst ¬ pHeader.first + pEntry.length + LogInternal.commonLength;          available ¬ available + pEntry.length + LogInternal.commonLength;          pHeader.count ¬ pHeader.count - 1;          IF tempFirst > pHeader.end THEN            pHeader.first ¬ tempFirst - pHeader.end + startMinusOne          ELSE            IF pHeader.end - tempFirst + 1 < LogInternal.commonLength THEN {              pHeader.first ¬ LogInternal.startIndex;              available ¬ available + (pHeader.end - tempFirst + 1)}            ELSE pHeader.first ¬ tempFirst;          ENDLOOP;        return ¬ TRUE;        END;      ENDCASE => NULL;    END;  END....LOGTime: October 8, 1980  5:22 PM	By: SXY   	Action: Created fileTime: November 10, 1980  4:36 PM	By: SXY     Action: Added GetErrorCounts and added a parameter ErrorType to Put proceduresTime: November 17, 1980  11:45 AM	By: SXY     Action: Removed again the Backstop features, added Entry & HeaderTime: November 18, 1980  3:25 PM	By: SXY     Action: Entry & Header are moved to LogInternal, the first page of a log file is not used anymoreTime: November 26, 1980  10:52 AM	By: SXY     Action: Added GetIndex proc and first page parameter to Install and Open, message in SetRestart is replaced by UNSPECIFIEDTime: 14-Nov-81  9:11:31	By: FXH      Action: reflected "forceOut" change to interface fro 8.0e buildTime:  5-Feb-82 10:33:04	By: LXR      Action: made PutString take LONG STRINGTime: 15-Apr-83 15:04:46	By: EKN      Action: Update To KlamathTime: 21-Sep-83 10:30:03	By: EKN      Action: Monitorize the module. Fix Open procedure so it doesn't raise Space.ReadOnly when doing a Space.Map.Time: 29-Jan-87 21:18:52	By: ET	     Action: MDS relief it.
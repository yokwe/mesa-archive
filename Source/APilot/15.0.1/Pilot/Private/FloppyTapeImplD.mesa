-- Copyright (C) 1987, 1988  by Xerox Corporation.  All rights reserved. -- FloppyTapeImplD.mesa          22-Sep-88  9:25:11 by RSVDIRECTORY  Environment USING [bytesPerPage, PageFromLongPointer, wordsPerPage],  File USING [Type],  FileTypes USING [tUntypedFile],  FloppyChannel USING [    Attributes, DiskAddress, Error, GetDeviceAttributes, GetHandle,    Handle, Nop, nullHandle, SetContext, Status],  FloppyDiskFace USING [OperationPtr],  -- temporary hack for Daybreak Tape  FloppyIOFaceDove USING [IOCBPtr, maxTracksPerStream],    -- temporary hack for Daybreak Tape  FloppyTape USING [    ByteCount, ByteOffset, ChangeTapeNow, Drive, Error, ErrorType,    FileHandle, FileID, IOError, localDrive, maxBytesInName, nullFileID,    nullSectorNumber, SectorNumber, VolumeHandle],  FloppyTapeExtras USING [nullDrive],  FloppyTapeFormat USING [    badSectorListSize, BadSectorType, DiskAddressToSector, eraseWord,    firstDataAddress, firstDiagnosticCylinder, firstSector, floppyTapeContext,    FloppyTapeSeal, FloppyTapeVersion, formatWord, InitialMicrocodeDiskAddress,    MarkerPage, MarkerSeal, MarkerPageVersion, maxNumberBadSectors,    PackBadSectorNumber, RootPage, UnpackBadSectorNumber],  FloppyTapeInternal USING [    buffer, bufferLock, BytesToPages, CheckBadSectorList, CheckMarkerPage,    CheckRootPage, ConvertDiskAddressToFileID, ConvertFileIDToSector,    ConvertSectorToFileID, CreateBuffer, DiskChanged,    ForceOutBuffers, InitBadSectors, InternalIOError, IsPageBadAndType,    MarkBadSectorEntryInternal, OperationProc, OperationType, ReadMarkerPage,    ReadRootAndBadSectorList, RealFileIDLoc, ReportErrorToClient,    residentBufferSize, ValidateHandle, ValidDrive, verifyBufferSize,     volumeDesc, volumeDescLock, WordsToPages, WriteBadSectorList,     WriteMarkerPage, WriteRootPage],  Inline USING [LongMult],  PilotFileTypes USING [tAnonymousFile],  Process USING [Pause, Ticks],  ProcessOperations USING [Enter, Exit],  RuntimeInternal USING [Bug],  Space USING [Deallocate, Error, Interval, nullInterval, PageCount, Unmap],  SpecialFloppyTape USING [BootFilePointer, nullBootFilePointer],  SpecialFloppyTapeFace USING [GetTapeParameters],  SpecialFloppyChannelExtras USING [GetDeviceHandle, Retention],  System USING [GreenwichMeanTime],  VM USING [Unmap];    FloppyTapeImplD: MONITOR LOCKS ml USING ml: LONG POINTER TO MONITORLOCK  IMPORTS    Environment, FloppyChannel, FloppyTape, FloppyTapeFormat,    FloppyTapeInternal, Inline, Process, ProcessOperations, RuntimeInternal,    Space, SpecialFloppyChannelExtras, SpecialFloppyTape, SpecialFloppyTapeFace,    VM  EXPORTS FloppyTape, FloppyTapeExtras, FloppyTapeInternal =  BEGIN  operationLock: PUBLIC --FloppyTapeInternal-- MONITORLOCK;  inUse: FloppyTapeInternal.OperationType ¬ none;  nullDiskAddress: FloppyChannel.DiskAddress = [0,0,0];  VolumeHandleInternal: TYPE = RECORD [    deviceIndex: FloppyTape.Drive, changeCount: CARDINAL];    -- must be the same as FloppyTapeImplA$VolumeHandle.      PageBuffer: TYPE = ARRAY [0..Environment.wordsPerPage) OF CARDINAL;    timeToPause: Process.Ticks = 2;  BugType: TYPE = {impossibleEndcase, impossibleError, insufficientVM};  Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};  -- procedures --  AreWeOkay: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =    BEGIN    IF ~FloppyTapeInternal.volumeDesc.open THEN       RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];    IF FloppyTapeInternal.volumeDesc.writeProtected THEN      RETURN WITH ERROR FloppyTape.Error[writeInhibited];    END;  --AreWeOkay--  ChangeVolume: PUBLIC --FloppyTape-- PROCEDURE [volume: FloppyTape.VolumeHandle]    RETURNS [newVolume: FloppyTape.VolumeHandle] =    BEGIN    drive: FloppyTape.Drive = LOOPHOLE[volume, VolumeHandleInternal].deviceIndex;    readOnly: BOOLEAN = FloppyTapeInternal.volumeDesc.writeProtected;    volumeWasOpen: BOOLEAN ¬ FALSE;    CleanUp: PROCEDURE [] =       BEGIN      VM.Unmap[Environment.PageFromLongPointer[	FloppyTapeInternal.volumeDesc.residentBuffer1] !	Space.Error => CONTINUE];      VM.Unmap[Environment.PageFromLongPointer[	FloppyTapeInternal.volumeDesc.residentBuffer2] !	Space.Error => CONTINUE];      VM.Unmap[Environment.PageFromLongPointer[	FloppyTapeInternal.volumeDesc.verifyBuffer] !	Space.Error => CONTINUE];      Space.Deallocate[[FloppyTapeInternal.volumeDesc.residentBuffer1,	FloppyTapeInternal.residentBufferSize] !	  Space.Error => CONTINUE];      Space.Deallocate[[FloppyTapeInternal.volumeDesc.residentBuffer2,	FloppyTapeInternal.residentBufferSize] !	  Space.Error => CONTINUE];      Space.Deallocate[[FloppyTapeInternal.volumeDesc.verifyBuffer,        FloppyTapeInternal.verifyBufferSize] !	  Space.Error => CONTINUE];      END;  --CleanUp--    IsVolumeOpenAndCloseIt: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]      RETURNS [isOpen: BOOLEAN] =       BEGIN      isOpen ¬ FloppyTapeInternal.volumeDesc.open;      FloppyTapeInternal.volumeDesc.open ¬ FALSE;      END;  --IsVolumeOpenAndCloseIt--    CloseVolumeEntry: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE        FloppyTapeInternal.InternalIOError => 	  {savedError ¬ badTape; GO TO otherError};      -- volumeDesc.open is already FALSE by here      FloppyTapeInternal.volumeDesc.rootPage.changing ¬ FALSE;        IF ~FloppyTapeInternal.volumeDesc.writeProtected THEN        BEGIN        FloppyTapeInternal.WriteBadSectorList[ !	  FloppyTape.Error => {savedError ¬ error; GO TO otherError}];        FloppyTapeInternal.WriteRootPage[ !	  FloppyTape.Error => {savedError ¬ error; GO TO otherError}];	END;      FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;      EXITS        otherError => RETURN WITH ERROR FloppyTape.Error[savedError];      END;      END;  --CloseVolumeEntry--    OpenVolumeInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK]       RETURNS [volume: VolumeHandleInternal] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      attributes: FloppyChannel.Attributes;      status: FloppyChannel.Status;      BEGIN      ENABLE        BEGIN	FloppyChannel.Error => 	  IF type = invalidHandle THEN            {savedError ¬ notReady; GO TO otherError};	FloppyTapeInternal.InternalIOError => 	  {savedError ¬ needsScavenging; GO TO otherError};	END;  --ENABLE--      -- know that volumeDesc.open = FALSE!      FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];        attributes ¬ FloppyChannel.GetDeviceAttributes[	FloppyTapeInternal.volumeDesc.fcHandle].attributes;      FOR i: CARDINAL IN [0..2) DO  --if readOnly and requires retention, do twice	status ¬ FloppyChannel.Nop[FloppyTapeInternal.volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR FloppyTape.Error[notReady];	  writeFault     => EXIT;  -- just writeProtected, not an error	  otherError     => 	    IF readOnly AND (i = 0) THEN        	      BEGIN	      IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN 		FloppyTapeInternal.volumeDesc.notifyClientOnRetention[		  drive, start];	      status ¬ SpecialFloppyChannelExtras.Retention[		FloppyTapeInternal.volumeDesc.fcHandle];	      IF status # goodCompletion THEN		RETURN WITH ERROR FloppyTape.Error[hardwareError];	      IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN 		FloppyTapeInternal.volumeDesc.notifyClientOnRetention[		  drive, stop];	      END  --IF readOnly--	    ELSE RETURN WITH ERROR FloppyTape.Error[hardwareError];	  ENDCASE        => RETURN WITH ERROR FloppyTape.Error[hardwareError];	ENDLOOP;      FloppyTapeInternal.volumeDesc.writeProtected ¬         (status = writeFault) OR readOnly;	      IF ~FloppyTapeInternal.volumeDesc.writeProtected THEN        BEGIN	IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	  FloppyTapeInternal.volumeDesc.notifyClientOnRetention[drive, start];	status ¬ SpecialFloppyChannelExtras.Retention[          FloppyTapeInternal.volumeDesc.fcHandle];	IF status # goodCompletion THEN 	  ERROR FloppyTape.Error[hardwareError];	IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	  FloppyTapeInternal.volumeDesc.notifyClientOnRetention[drive, stop];	END;      IF ~FloppyChannel.SetContext[FloppyTapeInternal.volumeDesc.fcHandle,        FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR FloppyTape.Error[badTape];      FloppyTapeInternal.ReadRootAndBadSectorList[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];        -- may raise Error[notReady]      FloppyTapeInternal.CheckRootPage[FloppyTapeInternal.volumeDesc.rootPage !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.volumeDesc.size ¬        Environment.bytesPerPage * 	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks * 	Inline.LongMult[	  FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];      FloppyTapeInternal.CheckBadSectorList[        FloppyTapeInternal.volumeDesc.badSectorList,        FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages,        Inline.LongMult[attributes.numberOfCylinders, 	  attributes.maxSectorsPerTrack] * attributes.numberOfHeads !          FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      -- If writeable now, previous volume must have been writable, so buffers      -- are still here.  Therefore, set changing flag and write out root page      -- only.      IF ~FloppyTapeInternal.volumeDesc.writeProtected THEN        BEGIN	FloppyTapeInternal.buffer ¬	  FloppyTapeInternal.volumeDesc.residentBuffer1;	FloppyTapeInternal.volumeDesc.rootPage.changing ¬ TRUE;        FloppyTapeInternal.WriteRootPage[ !	  FloppyTape.Error => {savedError ¬ error; GO TO otherError}];	END;  --IF ~FloppyTapeInternal.volumeDesc.writeProtected--      FloppyTapeInternal.volumeDesc.currentPosition ¬         FloppyTapeInternal.volumeDesc.rootPage.currentEOT;      FloppyTapeInternal.volumeDesc.lastEOTonTape ¬         FloppyTapeInternal.volumeDesc.rootPage.currentEOT;      FloppyTapeInternal.volumeDesc.cachedFile ¬         [id: FloppyTape.nullFileID, da: nullDiskAddress, size: 0, 	type: PilotFileTypes.tAnonymousFile];      FloppyTapeInternal.volumeDesc.sectorsPerStream ¬        SpecialFloppyTapeFace.GetTapeParameters[	  SpecialFloppyChannelExtras.GetDeviceHandle[	  FloppyTapeInternal.volumeDesc.fcHandle]].parameters.maxTracksPerStream *	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack;	-- usually 245 * 12 which is < LAST[CARDINAL]      FloppyTapeInternal.volumeDesc.verifyAfterWrite ¬ TRUE;      FloppyTapeInternal.volumeDesc.changeCount ¬        FloppyTapeInternal.volumeDesc.changeCount + 1;      FloppyTapeInternal.volumeDesc.open ¬ TRUE;      -- must deallocate buffers if was readWrite but now only readOnly so we      -- don't have a space leak.      IF FloppyTapeInternal.volumeDesc.writeProtected AND ~readOnly THEN        CleanUp[];      RETURN[[drive, FloppyTapeInternal.volumeDesc.changeCount]];      EXITS	otherError => RETURN WITH ERROR FloppyTape.Error[savedError];      END;  --ENABLE--      END;  --OpenVolumeInternal--    ChangeVolumeMain: FloppyTapeInternal.OperationProc =      BEGIN ENABLE        FloppyTapeInternal.DiskChanged => GO TO diskChanged;      FloppyTapeInternal.ValidateHandle[volume];      IF ~(volumeWasOpen ¬ IsVolumeOpenAndCloseIt[        @FloppyTapeInternal.volumeDescLock]) THEN        ERROR FloppyTape.Error[invalidVolumeHandle];      FloppyTapeInternal.ForceOutBuffers[@FloppyTapeInternal.bufferLock];      CloseVolumeEntry[@FloppyTapeInternal.volumeDescLock];      SIGNAL FloppyTape.ChangeTapeNow[drive];      newVolume ¬ LOOPHOLE[OpenVolumeInternal[        @FloppyTapeInternal.volumeDescLock],	FloppyTape.VolumeHandle];      EXITS        diskChanged => ERROR FloppyTape.Error[notReady]      END;  --ChangeVolumeMain--    DoOperation[@operationLock, ChangeVolumeMain, changeVolume !      UNWIND => IF volumeWasOpen AND FloppyTapeInternal.volumeDesc.writeProtected                  AND ~readOnly THEN CleanUp[]];    END;  --ChangeVolume--  DoOperation: PUBLIC --FloppyTapeInternal-- --ENTRY-- PROCEDURE [    ml: LONG POINTER TO MONITORLOCK,    mainLineProc: FloppyTapeInternal.OperationProc,    operation: FloppyTapeInternal.OperationType] =    BEGIN    savedError: FloppyTape.ErrorType;    fileError: FloppyTape.FileHandle;    byteError: FloppyTape.ByteOffset;    firstHoleError: FloppyTape.SectorNumber;    howManyHolesError: CARDINAL;    DO      WHILE ~ProcessOperations.Enter[ml] DO NULL ENDLOOP;      IF inUse IN [changeVolume..retention] THEN 	BEGIN	ProcessOperations.Exit[ml];	ERROR FloppyTape.Error[inUse];	END      ELSE IF (inUse # none) THEN 	BEGIN	ProcessOperations.Exit[ml];	Process.Pause[ticks: timeToPause];	LOOP;	END      ELSE        BEGIN	inUse ¬ operation;	ProcessOperations.Exit[ml];	EXIT;	END;      ENDLOOP;    BEGIN ENABLE      BEGIN      FloppyTape.IOError => {        fileError ¬ file;	byteError ¬ byte;	firstHoleError ¬ firstHole;	howManyHolesError ¬ howManyHoles;	GO TO ioErrorExit};      FloppyTape.Error => {        savedError ¬ error;	GO TO errorExit};      UNWIND => {        WHILE ~ProcessOperations.Enter[ml] DO NULL ENDLOOP;	inUse ¬ none;	ProcessOperations.Exit[ml]};      END;    mainLineProc[];    EXITS      ioErrorExit => {        WHILE ~ProcessOperations.Enter[ml] DO NULL ENDLOOP;	inUse ¬ none;	ProcessOperations.Exit[ml];	RETURN WITH ERROR FloppyTape.IOError[	  fileError, byteError, firstHoleError, howManyHolesError]};      errorExit => {        WHILE ~ProcessOperations.Enter[ml] DO NULL ENDLOOP;	inUse ¬ none;	ProcessOperations.Exit[ml];	RETURN WITH ERROR FloppyTape.Error[savedError]};    END; --ENABLE--    WHILE ~ProcessOperations.Enter[ml] DO NULL ENDLOOP;    inUse ¬ none;    ProcessOperations.Exit[ml];    END;  --DoOperation--  ForceOut: PUBLIC --FloppyTape-- PROCEDURE [volume: FloppyTape.VolumeHandle] =    BEGIN        ForceOutInternal: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE         BEGIN	FloppyTapeInternal.InternalIOError =>          {savedError ¬ badTape; GO TO otherError};	FloppyTapeInternal.DiskChanged =>	  {savedError ¬ invalidVolumeHandle; GO TO otherError};	END;      FloppyTapeInternal.WriteRootPage[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError};	FloppyTapeInternal.InternalIOError => 	  {savedError ¬ badTape; GO TO otherError}];        --Do we want to force out the root page?      EXITS        otherError => RETURN WITH ERROR FloppyTape.Error[savedError];      END;      END;  --ForceOutInternal--    ForceOutMain: FloppyTapeInternal.OperationProc =      BEGIN      FloppyTapeInternal.ValidateHandle[volume];      AreWeOkay[@FloppyTapeInternal.volumeDescLock];      FloppyTapeInternal.ForceOutBuffers[@FloppyTapeInternal.bufferLock];      ForceOutInternal[@FloppyTapeInternal.volumeDescLock];      END;  --ForceOutMain--    DoOperation[@operationLock, ForceOutMain, forceOut];    END;  --ForceOut--  ForceOutBuffersOnly: PUBLIC --FloppyTapeExtras-- PROCEDURE [    volume: FloppyTape.VolumeHandle] =    BEGIN        ForceOutBuffersOnlyMain: FloppyTapeInternal.OperationProc =      BEGIN      FloppyTapeInternal.ValidateHandle[volume];      AreWeOkay[@FloppyTapeInternal.volumeDescLock];      FloppyTapeInternal.ForceOutBuffers[@FloppyTapeInternal.bufferLock];      END;  --ForceOutBuffersOnlyMain--    DoOperation[@operationLock, ForceOutBuffersOnlyMain, forceOutBuffersOnly];    END;  --ForceOutBuffersOnly--  -- temporary hack for Daybreak Tapes  -- only to be called on Daybreaks when the status returned is not goodCompletion  GetCountDone: PUBLIC --FloppyTapeInternal-- PROCEDURE [    previousSector: FloppyTape.SectorNumber, iocb: FloppyDiskFace.OperationPtr]    RETURNS [LONG CARDINAL] =    BEGIN    machineIOCB: FloppyIOFaceDove.IOCBPtr ¬      LOOPHOLE[iocb, FloppyIOFaceDove.IOCBPtr];    currentStream: CARDINAL;    cylinder, head, sector: CARDINAL;    -- order IS important below since machineIOCB.CurrentFDCCommand can be equal    -- to 0 when a timeOut or something similar occurs.    IF (machineIOCB.CurrentFDCCommand > 0) AND      ((machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].fdcCode = ReadData)      OR (machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].fdcCode = WriteData)) THEN      BEGIN      IF (machineIOCB.fdcCommands[            machineIOCB.CurrentFDCCommand].NumberOfResultBytes #	  machineIOCB.fdcCommands[	    machineIOCB.CurrentFDCCommand].NumberOfResultBytesRead) OR	 machineIOCB.FDCHung OR machineIOCB.TimeoutOccurred THEN	 -- either NumberOfResultBytes # NumberOfResultBytesRead or 	 -- fdcHung = TRUE or timeoutOccured = TRUE        RETURN[	  FloppyTapeFormat.DiskAddressToSector[	    [iocb.address.cylinder, iocb.address.head, iocb.address.sector],	    FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	    FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	    FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] -	  previousSector];      currentStream ¬ (machineIOCB.operation.address.cylinder /        FloppyIOFaceDove.maxTracksPerStream) + 1;	-- yes, we want to know what currentStream we ENDED on      cylinder ¬ machineIOCB.fdcCommands[        machineIOCB.CurrentFDCCommand].ResultBytes[4] +         ((currentStream - 1) * FloppyIOFaceDove.maxTracksPerStream);      head ¬        machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].ResultBytes[5];      sector ¬        machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].ResultBytes[6];      RETURN[        FloppyTapeFormat.DiskAddressToSector[	  [cylinder, head, sector],	  FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] -	previousSector];      END    ELSE RETURN[      FloppyTapeFormat.DiskAddressToSector[        [iocb.address.cylinder, iocb.address.head, iocb.address.sector],	FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] - previousSector];    END;  --GetCountDone--  GetNextBadSector: PUBLIC --FloppyTape-- PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive,    sector: FloppyTape.SectorNumber]    RETURNS [nextBadSector: FloppyTape.SectorNumber] =    BEGIN    GetNextBadSectorInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE	BEGIN	FloppyChannel.Error => IF type = invalidHandle THEN	                         {savedError ¬ notReady; GO TO otherError};	FloppyTapeInternal.InternalIOError =>	                       {savedError ¬ badTape; GO TO otherError};	FloppyTapeInternal.DiskChanged =>	                       {savedError ¬ notReady; GO TO otherError};	UNWIND => FloppyTapeInternal.volumeDesc.fcHandle ¬	            FloppyChannel.nullHandle;	END;      buffer: Space.Interval ¬ Space.nullInterval;      status: FloppyChannel.Status;      attributes: FloppyChannel.Attributes;      tempFCHandle: FloppyChannel.Handle;            IF FloppyTapeInternal.volumeDesc.open THEN        RETURN WITH ERROR FloppyTape.Error[volumeOpen];            IF (FloppyTapeInternal.volumeDesc.fcHandle #         (tempFCHandle ¬ FloppyChannel.GetHandle[drive])) OR	(sector = FloppyTape.nullSectorNumber) THEN	-- Cache bad pages if Floppy Channel Handle doesn't change	-- However, due to Mirror not detecting diskChange, need to also read if	-- just starting an enumeration.        BEGIN  	FloppyTapeInternal.volumeDesc.fcHandle ¬ tempFCHandle;	attributes ¬ FloppyChannel.GetDeviceAttributes[tempFCHandle].attributes;	FOR i: CARDINAL IN [0..2) DO -- must try again if retention required	  status ¬ FloppyChannel.Nop[tempFCHandle];	  SELECT status FROM	    goodCompletion => EXIT;	    notReady       => {savedError ¬ notReady; GO TO otherError};	    writeFault     => EXIT;	    otherError     =>	      BEGIN	      IF i = 0 THEN 		status ¬ SpecialFloppyChannelExtras.Retention[tempFCHandle];	      IF status # goodCompletion THEN 	        {savedError ¬ hardwareError; GO TO otherError};		-- either second time through loop or retention failed	      END;	    ENDCASE        => {savedError ¬ hardwareError; GO TO otherError}	  ENDLOOP;  --FOR i: CARDINAL--	IF ~FloppyChannel.SetContext[	  tempFCHandle,FloppyTapeFormat.floppyTapeContext] THEN	  {savedError ¬ hardwareError; GO TO otherError};	FloppyTapeInternal.ReadRootAndBadSectorList[ !	  FloppyTape.Error => {savedError ¬ error; GO TO otherError}];	END;      attributes ¬ FloppyChannel.GetDeviceAttributes[tempFCHandle].attributes;      FloppyTapeInternal.CheckRootPage[FloppyTapeInternal.volumeDesc.rootPage !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.CheckBadSectorList[        FloppyTapeInternal.volumeDesc.badSectorList,        FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages, 	Inline.LongMult[attributes.numberOfCylinders, 	  attributes.maxSectorsPerTrack] * attributes.numberOfHeads !          FloppyTape.Error => {savedError ¬ error; GO TO otherError}];	-- use rootPage since volumeDesc.size may won't be set here.      nextBadSector ¬ FloppyTape.nullSectorNumber;      FOR i: CARDINAL IN        [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages) DO BEGIN        badSector: FloppyTape.SectorNumber ¬ 	  FloppyTapeFormat.PackBadSectorNumber[	    FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	    FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];        IF badSector > sector THEN 	  BEGIN	  nextBadSector ¬ badSector;	  EXIT;	  END;	END ENDLOOP;      EXITS        otherError =>	  BEGIN	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  RETURN WITH ERROR FloppyTape.Error[savedError];	  END;      END;  --ENABLE--      END;  --GetNextBadSectorInternal--    GetNextBadSectorMain: PROCEDURE =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN         ERROR FloppyTape.Error[noSuchDrive];      GetNextBadSectorInternal[@FloppyTapeInternal.volumeDescLock];      END;  --GetNextBadSector--    DoOperation[@operationLock, GetNextBadSectorMain, getNextBadSector];    END;  --GetNextBadSector--  GetNextFloppyTapeDrive: PUBLIC --FloppyTapeExtras-- PROCEDURE [    drive: FloppyTape.Drive] RETURNS [nextDrive: FloppyTape.Drive] =    BEGIN    IF (drive = FloppyTapeExtras.nullDrive) THEN      IF (FloppyTapeInternal.volumeDesc # NIL) THEN        RETURN[FloppyTapeInternal.volumeDesc.drive]      ELSE RETURN[FloppyTapeExtras.nullDrive]    ELSE IF (FloppyTapeInternal.volumeDesc = NIL) OR      (FloppyTapeInternal.volumeDesc.drive # drive) THEN        ERROR FloppyTape.Error[noSuchDrive]    ELSE RETURN[FloppyTapeExtras.nullDrive];    END;  --GetNextFloppyTapeDrive--        MarkSectorBad: PUBLIC --FloppyTape-- PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive,    sector: FloppyTape.SectorNumber] =    BEGIN    MarkSectorBadInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE        BEGIN	FloppyChannel.Error => IF type = invalidHandle THEN	                         {savedError ¬ notReady; GO TO otherError};	FloppyTapeInternal.InternalIOError => 	                       {savedError ¬ badTape; GO TO otherError};	FloppyTapeInternal.DiskChanged =>	                       {savedError ¬ notReady; GO TO otherError};	UNWIND => FloppyTapeInternal.volumeDesc.fcHandle ¬	            FloppyChannel.nullHandle;	END;	      badSector, temp, lastSector: FloppyTape.SectorNumber;      status: FloppyChannel.Status;      tempType, type: FloppyTapeFormat.BadSectorType;      attributes: FloppyChannel.Attributes;            IF FloppyTapeInternal.volumeDesc.open THEN        RETURN WITH ERROR FloppyTape.Error[volumeOpen];            FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];      attributes ¬ FloppyChannel.GetDeviceAttributes[	FloppyTapeInternal.volumeDesc.fcHandle].attributes;      FOR i: CARDINAL IN [0..2) DO -- must try again if retention required	status ¬ FloppyChannel.Nop[FloppyTapeInternal.volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR FloppyTape.Error[notReady];	  writeFault     => RETURN WITH ERROR FloppyTape.Error[writeInhibited];	  otherError     =>	    BEGIN	    IF i = 0 THEN 	      status ¬ SpecialFloppyChannelExtras.Retention[	        FloppyTapeInternal.volumeDesc.fcHandle];	    IF status # goodCompletion THEN 	      RETURN WITH ERROR FloppyTape.Error[hardwareError];	      -- either second time through loop or retention failed	    END;	  ENDCASE        => RETURN WITH ERROR FloppyTape.Error[hardwareError];	ENDLOOP;  --FOR i: CARDINAL--      IF ~FloppyChannel.SetContext[FloppyTapeInternal.volumeDesc.fcHandle,        FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR FloppyTape.Error[badTape];      FloppyTapeInternal.ReadRootAndBadSectorList[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.CheckRootPage[FloppyTapeInternal.volumeDesc.rootPage !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      lastSector ¬ Inline.LongMult[attributes.numberOfCylinders,        attributes.maxSectorsPerTrack] * attributes.numberOfHeads;      FloppyTapeInternal.CheckBadSectorList[        FloppyTapeInternal.volumeDesc.badSectorList,        FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages, lastSector !          FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      IF sector > lastSector THEN         {savedError ¬ invalidByteOffset; GO TO otherError};      type ¬         IF (sector <= FloppyTapeInternal.RealFileIDLoc[            FloppyTapeInternal.ConvertSectorToFileID[	      FloppyTapeInternal.volumeDesc.rootPage.currentEOT - 1]].sector) THEN        afterFileWritten ELSE beforeFileWritten;      FOR i: CARDINAL IN        [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages) DO        badSector ¬	  FloppyTapeFormat.PackBadSectorNumber[	    FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	    FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];        IF badSector = sector THEN RETURN;	IF badSector < sector THEN LOOP;	temp ¬ badSector;        tempType ¬ FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage;	[FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh] ¬ 	  FloppyTapeFormat.UnpackBadSectorNumber[sector];	FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage ¬ type;	sector ¬ temp;	type ¬ tempType;	ENDLOOP;      IF FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages >=         FloppyTapeFormat.maxNumberBadSectors THEN        RETURN WITH ERROR FloppyTape.Error[badTape];      [FloppyTapeInternal.volumeDesc.badSectorList[          FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages].badSectorLow,        FloppyTapeInternal.volumeDesc.badSectorList[	  FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages].badSectorHigh]        ¬ FloppyTapeFormat.UnpackBadSectorNumber[sector];      FloppyTapeInternal.volumeDesc.badSectorList[	FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages].typeOfBadPage ¬	type;      FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages ¬        FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages + 1;      FloppyTapeInternal.WriteBadSectorList[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.WriteRootPage[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      EXITS        otherError =>	  BEGIN	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  RETURN WITH ERROR FloppyTape.Error[savedError];	  END;      END;  --ENABLE--      END;  --MarkSectorBadInternal--    MarkSectorBadMain: PROCEDURE =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN         ERROR FloppyTape.Error[noSuchDrive];      MarkSectorBadInternal[@FloppyTapeInternal.volumeDescLock];      END;  --MarkSectorBadMain--    DoOperation[@operationLock, MarkSectorBadMain, markSectorBad];    END;  --MarkSectorBad--  Retention: PUBLIC --FloppyTape-- PROCEDURE [drive: FloppyTape.Drive] =    BEGIN    status: FloppyChannel.Status;    RetentionInternal: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE        FloppyChannel.Error => IF type = invalidHandle THEN GO TO otherError;      IF FloppyTapeInternal.volumeDesc.open THEN        RETURN WITH ERROR FloppyTape.Error[volumeOpen];      FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];      status ¬ SpecialFloppyChannelExtras.Retention[        FloppyTapeInternal.volumeDesc.fcHandle];      EXITS        otherError => status ¬ diskChange;      END;      RetentionMain: FloppyTapeInternal.OperationProc =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN FloppyTape.Error[noSuchDrive];      RetentionInternal[@FloppyTapeInternal.volumeDescLock];      IF status # goodCompletion THEN        FloppyTapeInternal.ReportErrorToClient[status];      END;  --RetentionMain--    DoOperation[@operationLock, RetentionMain, retention];    END;  --Retention--  Scavenge: PUBLIC --FloppyTape-- PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive]    RETURNS [okay: BOOLEAN] =    BEGIN    -- Recovers eot by starting from eot in root page and moving along    -- detects inconsistent sizes of files.  Currently will truncate tape    -- (make the last no problem file found the last file on the tape) when    -- a problem file is found.  Also, of course, resets the changing flag.        ScavengeInternal: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]      RETURNS [okay: BOOLEAN] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      buffer: Space.Interval ¬ Space.nullInterval;            CleanUp: PROCEDURE =        BEGIN	buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	END;  --CleanUp--      FixBootPointer: PROCEDURE [        bootPointer: SpecialFloppyTape.BootFilePointer, buffer: LONG POINTER] 	RETURNS [returnBootPointer: SpecialFloppyTape.BootFilePointer] =	BEGIN	IF FloppyTapeInternal.ConvertFileIDToSector[bootPointer.file] >=	  FloppyTapeInternal.volumeDesc.rootPage.currentEOT THEN	  RETURN[SpecialFloppyTape.nullBootFilePointer];	FloppyTapeInternal.ReadMarkerPage[buffer, bootPointer.file !	  FloppyTape.Error =>	    IF (error = needsScavenging) OR (error = notFormatted) THEN	      GO TO nullBootPointer;	  FloppyTapeInternal.InternalIOError => GO TO nullBootPointer];	FloppyTapeInternal.CheckMarkerPage[buffer, bootPointer.file !	  FloppyTape.Error => IF error = fileNotFound THEN GO TO nullBootPointer	                      ELSE REJECT];	IF bootPointer.offset > LOOPHOLE[buffer,	  LONG POINTER TO FloppyTapeFormat.MarkerPage].logicalSize THEN	  GO TO nullBootPointer;	RETURN[bootPointer];	EXITS	  nullBootPointer => RETURN[SpecialFloppyTape.nullBootFilePointer];	END;  --FixBootPointer--      IsEOT: PROCEDURE [buffer: LONG POINTER TO PageBuffer] RETURNS [BOOLEAN] = {        isItFormatCode, isItEraseCode: BOOLEAN ¬ TRUE;	FOR i: CARDINAL IN [0..Environment.wordsPerPage) DO	  IF buffer[i] # FloppyTapeFormat.formatWord THEN {	    isItFormatCode ¬ FALSE;	    EXIT};	  ENDLOOP;	FOR i: CARDINAL IN [0..Environment.wordsPerPage) DO	  IF buffer[i] # FloppyTapeFormat.eraseWord THEN {	    isItEraseCode ¬ FALSE;	    EXIT};	  ENDLOOP;        RETURN[isItFormatCode OR isItEraseCode]};	      FillInMarkerPage: PROCEDURE [        marker: LONG POINTER TO FloppyTapeFormat.MarkerPage,        fileID: FloppyTape.FileID, size: FloppyTape.ByteCount,	type: File.Type, timeStamp: System.GreenwichMeanTime] = {	marker­ ¬ [	  seal: FloppyTapeFormat.MarkerSeal,	  version: FloppyTapeFormat.MarkerPageVersion,	  file: fileID, type: type, logicalSize: size,	  timeStamp: timeStamp, markerPageType: file, pad: ALL[0]]};      FindNextMarker: PROCEDURE [	file: FloppyTape.FileID, timeStamp: System.GreenwichMeanTime,	buffer: LONG POINTER TO FloppyTapeFormat.MarkerPage] RETURNS [        size: FloppyTape.ByteCount, date: System.GreenwichMeanTime,        isMarker: BOOLEAN] =	BEGIN	found, badPage: BOOLEAN ¬ FALSE;	sector: FloppyTape.SectorNumber ¬	  FloppyTapeInternal.RealFileIDLoc[file].sector;	typeOfBadPage: FloppyTapeFormat.BadSectorType;	offsetSector: FloppyTape.SectorNumber =	  FloppyTapeInternal.RealFileIDLoc[file].sector - 	  FloppyTapeInternal.ConvertFileIDToSector[file];	size ¬ 0;	date ¬ timeStamp;	WHILE ~found DO	  DO	    [badPage, typeOfBadPage] ¬	      FloppyTapeInternal.IsPageBadAndType[sector];	    IF badPage THEN	      BEGIN	      sector ¬ sector + 1;	      IF typeOfBadPage = afterFileWritten THEN	        size ¬ size + Environment.bytesPerPage;	      END	    ELSE EXIT;	    ENDLOOP;	  FloppyTapeInternal.ReadMarkerPage[buffer, 	    FloppyTapeInternal.ConvertSectorToFileID[sector - offsetSector] !	      FloppyTape.Error => BEGIN	                          FloppyTapeInternal.MarkBadSectorEntryInternal[				    afterFileWritten, sector];				  sector ¬ sector + 1;				  size ¬ size + Environment.bytesPerPage;				  LOOP;				  END];	  IF IsEOT[LOOPHOLE[buffer, LONG POINTER TO PageBuffer]] THEN 	    {isMarker ¬ FALSE; RETURN};	  FloppyTapeInternal.CheckMarkerPage[buffer,	    FloppyTapeInternal.ConvertSectorToFileID[sector - offsetSector] !	      FloppyTape.Error => IF error = fileNotFound THEN 	                          BEGIN				  sector ¬ sector + 1;				  size ¬ size + Environment.bytesPerPage;				  LOOP;				  END	                        ELSE Bug[impossibleError]];	  IF timeStamp > buffer.timeStamp THEN {isMarker ¬ FALSE; RETURN};	  found ¬ TRUE;	  isMarker ¬ TRUE;	  date ¬ buffer.timeStamp	  ENDLOOP;	END;  --FindNextMarker--	          BEGIN ENABLE        BEGIN	FloppyChannel.Error =>	  IF type = invalidHandle THEN {savedError ¬ notReady; GO TO otherError};        FloppyTapeInternal.InternalIOError =>	  {savedError ¬ badTape; GO TO otherError};	FloppyTapeInternal.DiskChanged =>	  {savedError ¬ notReady; GO TO otherError};	UNWIND => CleanUp[];	END;      status: FloppyChannel.Status;      attributes: FloppyChannel.Attributes;      requestedSize: Space.PageCount;      file, lastFileID: FloppyTape.FileID ¬ FloppyTape.nullFileID;      lastFileDate: System.GreenwichMeanTime ¬ [LONG[0]];      tapeSize, size: FloppyTape.ByteCount;      okay, isMarker: BOOLEAN ¬ TRUE;      bootPointer: SpecialFloppyTape.BootFilePointer;      rootFile: FloppyTape.FileID;      fileProblem, cantReadMarkerPage, wasChangingFlagOn: BOOLEAN;            IF FloppyTapeInternal.volumeDesc.open THEN         RETURN WITH ERROR FloppyTape.Error[volumeOpen];            FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];      attributes ¬ FloppyChannel.GetDeviceAttributes[        FloppyTapeInternal.volumeDesc.fcHandle].attributes;      FOR i: CARDINAL IN [0..2) DO  -- if retention required, just try once	status ¬ FloppyChannel.Nop[FloppyTapeInternal.volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR FloppyTape.Error[notReady];	  writeFault     => RETURN WITH ERROR FloppyTape.Error[writeInhibited];	  otherError     => 	    BEGIN	    IF i = 0 THEN	      status ¬ SpecialFloppyChannelExtras.Retention[	        FloppyTapeInternal.volumeDesc.fcHandle];	    IF status # goodCompletion THEN	      RETURN WITH ERROR FloppyTape.Error[hardwareError];	      -- will do this if i # 0 or retention returns bad status	    END;	  ENDCASE        => RETURN WITH ERROR FloppyTape.Error[hardwareError];	ENDLOOP;  --FOR i: CARDINAL--      IF ~FloppyChannel.SetContext[          FloppyTapeInternal.volumeDesc.fcHandle,           FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR FloppyTape.Error[badTape];            FloppyTapeInternal.ReadRootAndBadSectorList[ !	FloppyTape.Error => {savedError ¬ error; GO TO otherError}];	-- If we can't read them in, we're done!      -- if seal or version isn't right, don't continue since we may be       -- getting in deeper than we care to handle!      IF (FloppyTapeInternal.volumeDesc.rootPage.seal #           FloppyTapeFormat.FloppyTapeSeal) OR	 (FloppyTapeInternal.volumeDesc.rootPage.version #	   FloppyTapeFormat.FloppyTapeVersion) THEN	 GO TO emergencyExit;            IF FloppyTapeInternal.volumeDesc.rootPage.labelSize >          FloppyTape.maxBytesInName THEN	FloppyTapeInternal.volumeDesc.rootPage.labelSize ¬ 0;      IF ~(FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams =              attributes.numberOfCylinders OR           FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams = 	      FloppyTapeFormat.firstDiagnosticCylinder.cylinder - 1) THEN	 FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams ¬	   attributes.numberOfCylinders;	 -- this will automatically unreserve diagnostic cylinders if there	 -- is a problem.      IF (FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks #           attributes.numberOfHeads) THEN	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks ¬	  attributes.numberOfHeads;      IF (FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack #	  attributes.maxSectorsPerTrack) THEN	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack ¬	  attributes.maxSectorsPerTrack;      tapeSize ¬ Inline.LongMult[        FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,        FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] *         FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks;      IF FloppyTapeInternal.volumeDesc.rootPage.pad # 0 THEN         FloppyTapeInternal.volumeDesc.rootPage.pad ¬ 0;      FloppyTapeInternal.volumeDesc.rootPage.spare ¬ ALL[0];      -- next check out BadSectorList, but if there is a problem      FloppyTapeInternal.CheckBadSectorList[        FloppyTapeInternal.volumeDesc.badSectorList,        FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages,	attributes.numberOfHeads * Inline.LongMult[	  attributes.numberOfCylinders, attributes.maxSectorsPerTrack] !	FloppyTape.Error => {GO TO emergencyExit}];      wasChangingFlagOn ¬ FloppyTapeInternal.volumeDesc.rootPage.changing;      FloppyTapeInternal.volumeDesc.rootPage.changing ¬ TRUE;      FloppyTapeInternal.WriteRootPage[];      -- By now, everything on rootPage except currentEOT, lastFileID,      -- nextUnusedFileID, and changing should be OK.  Also, badSectorList      -- should be OK.  Therefore, start with files themselves.      requestedSize ¬        FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.MarkerPage]];      buffer ¬ FloppyTapeInternal.CreateBuffer[requestedSize];      IF requestedSize # buffer.count THEN Bug[insufficientVM];      file ¬ FloppyTapeInternal.ConvertDiskAddressToFileID[        FloppyTapeFormat.firstDataAddress];      DO        fileProblem ¬ cantReadMarkerPage ¬ FALSE;        FloppyTapeInternal.ReadMarkerPage[buffer.pointer, file !	  FloppyTape.Error => 	    IF (error = needsScavenging) OR (error = notFormatted) THEN {	      FloppyTapeInternal.MarkBadSectorEntryInternal[	        afterFileWritten, FloppyTapeInternal.RealFileIDLoc[file].sector];	      fileProblem ¬ cantReadMarkerPage ¬ TRUE;	      CONTINUE};	  FloppyTapeInternal.InternalIOError => {	    FloppyTapeInternal.MarkBadSectorEntryInternal[	      afterFileWritten, FloppyTapeInternal.RealFileIDLoc[file].sector];	    fileProblem ¬ cantReadMarkerPage ¬ TRUE;	    CONTINUE}]; 	IF ~fileProblem THEN	  FloppyTapeInternal.CheckMarkerPage[buffer.pointer, file !	    FloppyTape.Error => IF error = fileNotFound THEN 	                          {fileProblem ¬ TRUE; CONTINUE}];        SELECT TRUE FROM	  ~fileProblem =>	    BEGIN  -- absolutely no problems	    size ¬ LOOPHOLE[buffer.pointer,	      LONG POINTER TO FloppyTapeFormat.MarkerPage].logicalSize;	    lastFileDate ¬ LOOPHOLE[buffer.pointer,	      LONG POINTER TO  FloppyTapeFormat.MarkerPage].timeStamp;	    END;	  cantReadMarkerPage =>	    BEGIN  -- can't read its marker	    nextSector: FloppyTape.SectorNumber =	      FloppyTapeInternal.ConvertFileIDToSector[file] + 1;	    [size, lastFileDate, isMarker] ¬ FindNextMarker[	      FloppyTapeInternal.ConvertSectorToFileID[nextSector], lastFileDate,	      buffer.pointer];	    IF size = 0 AND ~isMarker THEN  -- EOT	      NULL	    ELSE IF size = 0 THEN  -- next page is also a marker page	      NULL	    ELSE	      BEGIN	      FillInMarkerPage[		buffer.pointer, file, size, FileTypes.tUntypedFile,		lastFileDate];	      FloppyTapeInternal.WriteMarkerPage[		buffer.pointer, file !		  FloppyTape.Error => GO TO emergencyExit];		  -- note that the fileID (in marker) won't be correct if we		  -- just move the marker page	      END;	    END;	  fileProblem =>	    BEGIN  -- its marker is broken	    [size, lastFileDate, isMarker] ¬ FindNextMarker[	      file, lastFileDate, buffer.pointer];	    IF size = 0 AND ~isMarker THEN  -- EOT	      NULL	    ELSE IF size = 0 THEN  -- wasn't a marker but now it is?	      Bug[impossibleError]	    ELSE	      BEGIN	      FillInMarkerPage[		buffer.pointer, file, size, FileTypes.tUntypedFile,		lastFileDate];	      FloppyTapeInternal.WriteMarkerPage[		buffer.pointer, file !		  FloppyTape.Error => GO TO emergencyExit];		  -- note that the fileID (in marker) won't be correct if we		  -- just move the marker page	      END;	    END;	  ENDCASE => Bug[impossibleEndcase];	IF size # 0 THEN {  -- don't want lastFileID = file through this loop!	  lastFileID ¬ file;	  file ¬ FloppyTapeInternal.ConvertSectorToFileID[	    FloppyTapeInternal.ConvertFileIDToSector[file] +	    FloppyTapeInternal.BytesToPages[size]]};	IF ~isMarker THEN EXIT;	ENDLOOP;      FloppyTapeInternal.volumeDesc.rootPage.lastFileID ¬ lastFileID;      FloppyTapeInternal.volumeDesc.rootPage.nextUnusedFileID ¬ file;      FloppyTapeInternal.volumeDesc.rootPage.currentEOT ¬        FloppyTapeInternal.ConvertFileIDToSector[file];	-- currentEOT isn't "really" the current EOT (ie isn't RealFileIDLoc)      FloppyTapeInternal.InitBadSectors[        FloppyTapeInternal.RealFileIDLoc[file].sector, beforeFileWritten];        -- here you really want to only change bad sectors beyond where you are      -- by now, all files should be in order, and rootPage and badSector list      -- are both OK (except for rootPage.changing)      IF (bootPointer ¬ FloppyTapeInternal.volumeDesc.rootPage.initialMicrocode) #        SpecialFloppyTape.nullBootFilePointer THEN	BEGIN	FloppyTapeInternal.volumeDesc.rootPage.initialMicrocode ¬	  FixBootPointer[bootPointer, buffer.pointer];	IF bootPointer.offset >	  ((FloppyTapeFormat.DiskAddressToSector[	    FloppyTapeFormat.InitialMicrocodeDiskAddress,	    FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	    FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	    FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] -	  FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.RootPage]] -	  FloppyTapeFormat.badSectorListSize -	  FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.MarkerPage]] -	  FloppyTapeFormat.firstSector) * Environment.wordsPerPage)	  THEN	  FloppyTapeInternal.volumeDesc.rootPage.initialMicrocode ¬ 	    SpecialFloppyTape.nullBootFilePointer;	END;      IF (bootPointer ¬ FloppyTapeInternal.volumeDesc.rootPage.pilotMicrocode) #          SpecialFloppyTape.nullBootFilePointer THEN	FloppyTapeInternal.volumeDesc.rootPage.pilotMicrocode ¬ 	  FixBootPointer[bootPointer, buffer.pointer];      IF (bootPointer ¬            FloppyTapeInternal.volumeDesc.rootPage.diagnosticMicrocode) #          SpecialFloppyTape.nullBootFilePointer THEN	FloppyTapeInternal.volumeDesc.rootPage.diagnosticMicrocode ¬ 	  FixBootPointer[bootPointer, buffer.pointer];      IF (bootPointer ¬ FloppyTapeInternal.volumeDesc.rootPage.germ) #          SpecialFloppyTape.nullBootFilePointer THEN	FloppyTapeInternal.volumeDesc.rootPage.germ ¬ 	  FixBootPointer[bootPointer, buffer.pointer];      IF (bootPointer ¬ FloppyTapeInternal.volumeDesc.rootPage.pilotBootFile) #          SpecialFloppyTape.nullBootFilePointer THEN	FloppyTapeInternal.volumeDesc.rootPage.pilotBootFile ¬ 	  FixBootPointer[bootPointer, buffer.pointer];      IF (rootFile ¬ FloppyTapeInternal.volumeDesc.rootPage.rootFile) #        FloppyTape.nullFileID THEN	BEGIN	IF FloppyTapeInternal.ConvertFileIDToSector[rootFile] >=	  FloppyTapeInternal.volumeDesc.rootPage.currentEOT THEN	  FloppyTapeInternal.volumeDesc.rootPage.rootFile ¬ FloppyTape.nullFileID	ELSE	  BEGIN	  fileProblem ¬ FALSE;	  FloppyTapeInternal.ReadMarkerPage[buffer.pointer, rootFile !	    FloppyTape.Error => 	      IF (error = needsScavenging) OR (error = notFormatted) THEN {		fileProblem ¬ TRUE;		FloppyTapeInternal.volumeDesc.rootPage.rootFile ¬		  FloppyTape.nullFileID;		CONTINUE};	    FloppyTapeInternal.InternalIOError => {	      fileProblem ¬ TRUE;	      FloppyTapeInternal.volumeDesc.rootPage.rootFile ¬		FloppyTape.nullFileID;	      CONTINUE}];	  IF ~fileProblem THEN	    FloppyTapeInternal.CheckMarkerPage[buffer.pointer, rootFile !	      FloppyTape.Error =>		IF error = fileNotFound THEN {		  FloppyTapeInternal.volumeDesc.rootPage.rootFile ¬		    FloppyTape.nullFileID;		  CONTINUE}		ELSE REJECT];	  END;	END;      -- all done, so write stuff out      FloppyTapeInternal.volumeDesc.rootPage.changing ¬ FALSE;      FloppyTapeInternal.WriteBadSectorList[ !	FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.WriteRootPage[ !	FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      CleanUp[];      RETURN[TRUE];      EXITS        otherError => {	  CleanUp[];	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  RETURN WITH ERROR FloppyTape.Error[savedError]};	emergencyExit => {	  CleanUp[];	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  RETURN[FALSE]};      END;      END;  --ScavengeInternal--    ScavengeMain: FloppyTapeInternal.OperationProc =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN	 ERROR FloppyTape.Error[noSuchDrive];      okay ¬ ScavengeInternal[@FloppyTapeInternal.volumeDescLock];      END;  --ScavengeMain--    DoOperation[@operationLock, ScavengeMain, scavenge];    END;  --Scavenge--          END.LOG17-Jul-87 11:32:16  RSV  Created File20-Jul-87 13:50:05  RSV  Added stuff to prevent monitor-type locks in DoOperation.21-Jul-87 11:47:37  RSV  Moved in ChangeVolume from FloppyTapeImplA and implemented it.23-Jul-87 11:53:57  RSV  Implemented volumeDesc.verifyAfterWrite.27-Jul-87 17:07:24  RSV  Catch DiskChanged where needed.13-Aug-87 11:03:29  RSV  First real implementation for Scavenge.20-Aug-87 23:10:31  RSV  Fix Scavenge up a bit.  Add commented out stuff for later addition.16-Sep-87 10:10:17  RSV  Uncommented out Scavenger stuff to do more complete Scavenge, plus add some more to it.22-Sep-87 19:51:01  RSV  Just making things pretty.25-Sep-87 12:34:42  RSV  GetNextBadSector shouldn't cache on new enumeration (due to Mirror).  Also, checked so as not to use localDrive instead of volumeDesc.drive. 7-Oct-87 16:36:28  RSV  Added GetNextFloppyTapeDrive.  EXIT, instead of NULL, from loops if goodCompletion.  Fixed AR 12018 about hardwareError on write protected tapes and then giving wrong information (info from previous tape).18-Oct-87 18:34:57  RSV  Moved ForceOut from FloppyTapeImplC to here.15-Nov-87 17:31:41  RSV  Added ForceOutBuffersOnly procedure.19-Nov-87  0:05:46  RSV  Set volumeDesc.sectorsPerStream in ChangeVolume. 1-Dec-87 14:04:00  RSV  CleanUp needs to deallocate verifyBuffer27-Jan-88 14:38:48  RSV  Fix AR 12622 by having DoOperation do a Pause when inUse is taken with something we don't want to return Error[inUse] for. 5-Feb-88 10:17:02  RSV  Fix AR 12754 in MarkSectorBad. 7-Jun-88 15:40:53  RSV  Added procedure GetCountDone for temporary hack for Daybreak Tape problems resulting from AR 13249 against the Daybreak heads.14-Jun-88 13:43:14  RSV  Fix to the above work around.....since machineIOCB.CurrentFDCCommand can be 0 when calling in here.22-Sep-88  9:25:11  RSV  Fix ChangeVolume to only call CleanUp if the drive was previously open.
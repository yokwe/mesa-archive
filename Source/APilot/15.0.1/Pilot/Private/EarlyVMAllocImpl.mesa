-- Copyright (C) 1983 , 1985 by Xerox Corporation. All rights reserved. -- ResMemMgr>EarlyVMAllocImpl.mesa   10-Apr-85 15:08:22 by ET     -- This module implements allocation of virtual memory for use before the normal Space allocator has been initialized. Its facilities may only be used during PilotKernel initialization.-- The global frame of this module contains descriptors of "outlaw interval", intervals which are not managed by VM. At present, all resident mapped intervals allocated by MakeBoot are considered outlaws. The outlaw interval info is for debugging tools only, hence the global frame is swappable (as soon as initialization completes).DIRECTORY  Environment USING [maxPagesInMDS, PageCount, PageNumber],  PSB USING [PDA],  ResidentMemory USING [Location],  RuntimeInternal USING [Bug],  Space USING [PageFromLongPointer, unknownUsage, Usage],  StartList USING [Entry],  StoragePrograms USING [    countHyperspace, EnumerateStartList, OutlawMapping, pageHyperspace,    PageMDS, startList, StartListProc, UnusedVMProc],  VM USING [Interval, nullInterval];EarlyVMAllocImpl: MONITOR  IMPORTS RuntimeInternal, Space, StoragePrograms  EXPORTS StoragePrograms =  BEGIN    -- PARAMETERS:  maxOutlaws: CARDINAL = 40;  -- TYPES and VARIABLES:  LocationData: TYPE = RECORD [    total: VM.Interval,  -- all of vm for this Location.    allocatingFrom: VM.Interval,  -- original empty interval we allocate from.    remainsUnallocated: VM.Interval];  -- vm of allocatingFrom not yet allocated.  locData: ARRAY ResidentMemory.Location OF LocationData;  allocationsAllowed: BOOLEAN ¬ TRUE;    theOnlyUnusedVMNotInStartList: VM.Interval ¬ VM.nullInterval;    OutlawCount: TYPE = [0..maxOutlaws];  OutlawIndex: TYPE = [0..maxOutlaws);    outlaw: ARRAY OutlawIndex OF RECORD [    interval: VM.Interval, mapping: StoragePrograms.OutlawMapping,    usage: Space.Usage];    countOutlaws: OutlawCount ¬ 0;    overflowOutlaws: CARDINAL ¬ 0;  -- to see how many we wished we had allocated space for.    BugType: TYPE = {    allocationsNotAllowed, funnySpaceType, funnyStartListEntry,    mixedResidenciesNotImplemented, noFreeVM,    residentButNotBootloaded};  --~~~~~~~~~~ Initialization:    InitializeEarlyVMAlloc: PUBLIC --StoragePrograms.-- PROCEDURE    [unusedVMNotInStartList: VM.Interval] =    BEGIN    entryForUnusedVMNotInStartList: space StartList.Entry ¬ [space[      readOnly: TRASH,      bootLoaded: TRASH,      backingStore: TRASH,      type: [empty[]],      pages: unusedVMNotInStartList.count,      vmpage: unusedVMNotInStartList.page,      backingPage: TRASH,      reserved: TRASH]];    FOR ou: OutlawIndex IN OutlawIndex DO  --      outlaw[ou].interval.count ¬ 0; ENDLOOP;  -- just to aid debugging.    FOR loc: ResidentMemory.Location IN ResidentMemory.Location DO      locData[loc].allocatingFrom.count ¬ 0;      -- locData[loc].largestHole.page ¬ NULL;      -- loc.remainsUnallocated ¬ NULL;      ENDLOOP;    locData[first64K].total ¬      [Environment.PageNumber[0], Environment.maxPagesInMDS];    locData[mds].total ¬      [StoragePrograms.PageMDS[], Environment.maxPagesInMDS];    locData[pda].total ¬      [Space.PageFromLongPointer[PSB.PDA], Environment.maxPagesInMDS];    locData[hyperspace].total ¬      [StoragePrograms.pageHyperspace, StoragePrograms.countHyperspace];          StoragePrograms.EnumerateStartList[FindFreeVMAndResidentMappedIntervals];        theOnlyUnusedVMNotInStartList ¬ unusedVMNotInStartList;  -- save in global.        [] ¬ FindFreeVMAndResidentMappedIntervals[@entryForUnusedVMNotInStartList];    END;  FindFreeVMAndResidentMappedIntervals:  --    StoragePrograms.StartListProc --[pEntry]-- =    -- Initializes locData.allocatingFrom and .remainsUnallocated    --    from empty spaces in MakeBoot-allocated memory.    -- Also copies info on MakeBoot-allocated resident mapped    --    intervals into outlaw table.    BEGIN OPEN S: StoragePrograms;    -- NOTE: We assume that MakeBoot does not create any Empty intervals    --    which cross the boundaries of first64K, pda, or mds.    WITH e: pEntry SELECT FROM      space =>        BEGIN	-- Look for resident spaces:        WITH t: e.type SELECT FROM          empty =>	    FOR locat: ResidentMemory.Location IN ResidentMemory.Location DO              OPEN loc: locData[locat];              IF e.pages > loc.allocatingFrom.count AND e.vmpage >= loc.total.page                AND e.vmpage + e.pages <= loc.total.page + loc.total.count THEN	        BEGIN                loc.allocatingFrom ¬ loc.remainsUnallocated ¬ [	          page: e.vmpage, count: e.pages];	        EXIT;	        END;            ENDLOOP;           unitary =>            IF S.startList[t.swapUnit].info.state = resident THEN	      BEGIN	      IF NOT e.bootLoaded THEN Bug[residentButNotBootloaded];	      OutlawInterval[	        [e.vmpage, e.pages], Space.unknownUsage, alwaysWhollyMapped];	      END;          family =>  -- handle resident families here.	    IF t.anyResidentChildren THEN	      BEGIN	      IF NOT e.bootLoaded THEN Bug[residentButNotBootloaded];	      IF NOT t.allResidentChildren THEN	        Bug[mixedResidenciesNotImplemented];	      OutlawInterval[		[e.vmpage, e.pages], Space.unknownUsage, alwaysWhollyMapped];	      END;          ENDCASE => Bug[funnySpaceType];	END;      swapUnit => NULL;      ENDCASE => Bug[funnyStartListEntry];    END;  --~~~~~~~~~~ Implementation:    AllocateVM: PUBLIC ENTRY PROCEDURE [    count: Environment.PageCount, location: ResidentMemory.Location,    usage: Space.Usage, mapping: StoragePrograms.OutlawMapping]    RETURNS [page: Environment.PageNumber] =    BEGIN OPEN loc: locData[location];    IF NOT allocationsAllowed THEN Bug[allocationsNotAllowed];    IF count > loc.remainsUnallocated.count THEN Bug[noFreeVM];    page ¬ loc.remainsUnallocated.page;    loc.remainsUnallocated.page ¬ loc.remainsUnallocated.page + count;    loc.remainsUnallocated.count ¬ loc.remainsUnallocated.count - count;    OutlawIntervalInternal[[page, count], usage, mapping];    END;        EnumerateUnusedVM: PUBLIC ENTRY PROCEDURE [     unusedProc: StoragePrograms.UnusedVMProc] =    BEGIN    EnumerateVMHoles: StoragePrograms.StartListProc --[pEntry]--  =      -- Other parameters: unusedProc of parent frame.      BEGIN      WITH e: pEntry SELECT FROM        space =>          IF e.type.class = empty THEN	    -- We have to carefully handle the Empty intervals	    --    which we have been allocating from.            FOR loc: ResidentMemory.Location IN ResidentMemory.Location DO              IF locData[loc].allocatingFrom = [e.vmpage, e.pages] THEN {                unusedProc[locData[loc].remainsUnallocated];                RETURN};              REPEAT                FINISHED => {                 unusedProc[[e.vmpage, e.pages]];                 RETURN};              ENDLOOP;        ENDCASE => NULL;      END;                  -- Begin main text of EnumerateUnusedVM:    allocationsAllowed ¬ FALSE;    StoragePrograms.EnumerateStartList[EnumerateVMHoles];    -- Finally, tell unusedProc about theOnlyUnusedVMNotInStartList,    --   If we have been allocating out of it then tell about part of it    --   else tell about all of it.    FOR loc: ResidentMemory.Location IN ResidentMemory.Location DO      IF locData[loc].allocatingFrom = theOnlyUnusedVMNotInStartList THEN {        unusedProc[locData[loc].remainsUnallocated];        EXIT};      REPEAT        FINISHED => unusedProc[theOnlyUnusedVMNotInStartList];      ENDLOOP;    END;  --EnumerateUnusedVM--  OutlawInterval: PUBLIC ENTRY PROCEDURE [    interval: VM.Interval, usage: Space.Usage,    mapping: StoragePrograms.OutlawMapping] = {      OutlawIntervalInternal[interval, usage, mapping]};  OutlawIntervalInternal: INTERNAL PROCEDURE [    interval: VM.Interval, usage: Space.Usage,    mapping: StoragePrograms.OutlawMapping] =    BEGIN    IF countOutlaws >= maxOutlaws THEN      -- We just throw away the data that won't fit.      overflowOutlaws ¬ SUCC[overflowOutlaws]      ELSE {      outlaw[countOutlaws] ¬ [interval, mapping, usage];      countOutlaws ¬ SUCC[countOutlaws]};    END;  Bug: PROC [type: BugType] = {RuntimeInternal.Bug[type]};  -- (Not INLINE)  END. LOG28-Sep-82 15:48:48   WDK       Created file, partly from pieces of SimpleSpaceImpl.21-Dec-82 15:22:28   AWL      	NewSpace => Space.24-Feb-83 14:12:06   WDK     	Handle truncation warning.17-May-83 11:32:28   JXG       Throw away result from explicit call to FindFreeVMAndResidentMappedIntervals.26-Aug-83 12:46:02   WDK        Didn't initialize entryForUnusedVMNotInStartList.type. Removed obsolete range checks.10-Apr-85 15:08:04   ET   change maxOutlaws to 40.
-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- ResMemMgr>ResidentHeapImpl.mesa     29-Aug-85  9:33:04 by RSV     -- Implementation Notes:---- This module is now a monitor once again.  It no longer uses the zone package-- and instead has its own implementation for its heap which for small nodes is -- a linked list of pages in resident memory with a header to indicate bytes -- allocated while large nodes are implemented by allocating resident memory-- directly.DIRECTORY  Environment USING [Base, PageNumber, PageFromLongPointer, PageCount, wordsPerPage],  Process USING [Priority],  ProcessPriorities USING [priorityIOHigh],  PSB USING [PDA],  ResidentHeap USING [base, HeapLocation, Location],  ResidentMemory USING [Allocate, Free],  ResMemPerf USING [],  Space USING [PagesFromWords],  StoragePrograms USING [],  VM USING [DoneWithStateVector, GuardStateVector],  Zone USING [BlockSize, Status, Alignment, nil];ResidentHeapImpl: MONITOR  IMPORTS ResidentMemory, Space --for inlines-- , VM, Environment  EXPORTS ResidentHeap, ResMemPerf, StoragePrograms =  BEGIN  --~~~~~ PARAMETERS:  -- WARNING: THE NEXT TWO PARAMETERS (initialHeapSize, heapSizeIncrement) must be 1 as some of the clients of the first64K heap on some processors can not have an object crossing a page boundary. (For instance, IOCB's can not cross a page boundary on the Dandelion.)  initialHeapSize: CARDINAL = 1;  -- (see note above)  heapSizeIncrement: CARDINAL = 1;  -- (see note above)  nodeSize: CARDINAL = 8;  maxSegments: CARDINAL = 50 - 1;  -- SHOULD be less than ResidentMemoryImpl.countMax.  -- The only reason we have a limit on segments at all is to allow our client to get an error return (thus allowing him to abandon the higher-level operation), rather than ResidentMemory.Allocate just going to the debugger.  largeNodeThreshold: Zone.BlockSize = (Environment.wordsPerPage / 2) - nodeSize;  -- Objects > this size are allocated as separate pages, not in the linked heap.  --~~~~~ Types and Constants:    SaltAndPepperCode: CARDINAL = 52525B; -- validity check for large nodes  HeapLocation: TYPE = ResidentHeap.HeapLocation;  -- This implementation assumes that the two areas in HeapLocation  -- are contiguous in Location:  assertFirst64KIncluded: BOOLEAN [TRUE..TRUE] =    (ResidentHeap.Location[first64K] IN HeapLocation);  assertPdaIncluded: BOOLEAN [TRUE..TRUE] =    (ResidentHeap.Location[pda] IN HeapLocation);  assertMdsExcluded: BOOLEAN [TRUE..TRUE] =    (ResidentHeap.Location[mds] NOT IN HeapLocation);  assertHyperspaceExcluded: BOOLEAN [TRUE..TRUE] =    (ResidentHeap.Location[hyperspace] NOT IN HeapLocation);  base: ARRAY HeapLocation OF Environment.Base = ResidentHeap.base;  residentHeap: PUBLIC ARRAY HeapLocation OF LONG POINTER TO HeapSegment ¬ ALL[nullHeapHandle];  nullHeapHandle: LONG POINTER TO HeapSegment = NIL;  -- small nodes are allocated from this structure.  HeapSegment: TYPE = MACHINE DEPENDENT RECORD [    header: HeapHeader,     nodes: ARRAY [0..0) OF HeapNode];  HeapNode: TYPE = ARRAY [0..nodeSize) OF WORD;  HeapHeader: TYPE = MACHINE DEPENDENT RECORD [    next(0): LONG POINTER TO HeapSegment,    allocArray(2): PACKED ARRAY [0..maxNodesPerPage) OF AllocFree,    sizes(4): PACKED ARRAY [0..maxNodesPerPage) OF NodeSize,    padding(12): ARRAY [0..4) OF WORD];  AllocFree: TYPE = {alloc, free};  NodeSize: TYPE = CARDINAL [0..maxSmallNodeSize);  maxSmallNodeSize: CARDINAL = (largeNodeThreshold + nodeSize) / nodeSize;  maxNodesPerPage: CARDINAL = Environment.wordsPerPage / nodeSize;  actualNodesPerPage: CARDINAL = maxNodesPerPage - (SIZE[HeapHeader] / nodeSize);  -- large nodes are different than small nodes and are allocated directly.  LargeNodeStart: TYPE = LONG POINTER TO LargeNode;  LargeNode: TYPE = MACHINE DEPENDENT RECORD [    header: LargeNodeHeader,    nodes: ARRAY [0..0) OF HeapLargeNode];  HeapLargeNode: TYPE = ARRAY [0..SIZE[LargeNodeHeader]) OF WORD;  LargeNodeHeader: TYPE = MACHINE DEPENDENT RECORD [    size (0): Environment.PageCount ¬,  -- in pages including header page    checkCode (2): CARDINAL ¬ SaltAndPepperCode,    padding (3): ARRAY [0..13) OF WORD ¬ TRASH];  -- checking for proper alignment of headers and node size.  nodeSizeOkay: BOOLEAN [TRUE..TRUE] = (nodeSize MOD 2) = 0;  headerSizeOkay: BOOLEAN [TRUE..TRUE] = (SIZE[HeapHeader] MOD 16) = 0;  largeNodeHeaderSizeOkay: BOOLEAN [TRUE..TRUE] = (SIZE[LargeNodeHeader] MOD 16) = 0;  --~~~~~ counter data:  resHeapAllocates, resHeapFrees, resHeapSplits: PUBLIC  --ResMemPerf.--    CARDINAL ¬ 0;  -- counters.  resHeapSegments: PUBLIC ARRAY HeapLocation OF CARDINAL ¬ ALL[0];  InitializeResidentHeap: PUBLIC --StoragePrograms.-- PROCEDURE [] = {  --    -- We don't create any of the initial heaps here because the    -- pda heap is expected to be only rarely used. By deferring    -- creation (of it and incidentally all heaps) until it is actually    -- requested, we expect to save a page of resident memory.    --    -- NOTE: There is a kind of cross-dependency in the intialization of VMData    -- and ResidentHeap, in that VMData's initialization would like    -- to allocate some nodes, but ResidentHeap calls VMData to get memory.    -- If we ever start creating heaps in this proc, VMData initialization    -- will have to be split into two stages - with the latter stage    -- doing the node alocations.    };  --~~~~~~~~~~~~~~~ Implementation:      FreeNode: PUBLIC ENTRY PROCEDURE [    p: Environment.Base RELATIVE POINTER, location: ResidentHeap.HeapLocation]    RETURNS [s: Zone.Status] =    BEGIN    segment: LONG POINTER TO HeapSegment;    nodePointer: LONG POINTER ¬ @base[location][p];    nodePage: Environment.PageNumber ¬ Environment.PageFromLongPointer[      nodePointer];    resHeapFrees ¬ SUCC[resHeapFrees]; -- count all frees        -- nodes of zero length are represented by pointing to Zone.nil    IF p = Zone.nil THEN RETURN[okay];          -- sanity check for all nodes    IF (LOOPHOLE[nodePointer, LONG CARDINAL] MOD LONG[nodeSize]) # LONG[0] THEN      RETURN[invalidNode];        -- try to find page node is residing on (small nodes succeed, large fail)    FOR segment ¬ residentHeap[location], segment.header.next WHILE segment ~= NIL DO      IF nodePage = Environment.PageFromLongPointer[segment] THEN        BEGIN        index: CARDINAL = (CARDINAL[nodePointer - segment] - SIZE[HeapHeader]) /	  nodeSize;        count: CARDINAL = segment.header.sizes[index];	IF segment.header.sizes[index] = 0 THEN  -- sanity check for small nodes          RETURN[invalidNode];        FOR i: CARDINAL IN [index..index + count) DO          segment.header.allocArray[i] ¬ free;	  segment.header.sizes[i] ¬ 0;        ENDLOOP;        RETURN[okay];        END;      ENDLOOP;          BEGIN    -- It is known to be a large node if it falls through to here    pagePointer: LONG POINTER TO LargeNode ¬       LOOPHOLE[nodePointer - SIZE[LargeNodeHeader]];    size: Environment.PageCount = pagePointer.header.size;    IF pagePointer.header.checkCode # SaltAndPepperCode THEN -- sanity check for large nodes      RETURN[invalidNode]    ELSE      BEGIN      priorityPrev: Process.Priority = VM.GuardStateVector[  -- guard for Resident Memory.        ProcessPriorities.priorityIOHigh];      ResidentMemory.Free[        location, size, pagePointer];      VM.DoneWithStateVector[priorityPrev];      resHeapSegments[location] ¬ resHeapSegments[location] - CARDINAL[size];      RETURN[okay];      END; -- sanity check if-then    END;    END;  MakeNode: PUBLIC ENTRY PROCEDURE [    n: Zone.BlockSize, alignment: Zone.Alignment,    location: ResidentHeap.HeapLocation]    RETURNS [node: Environment.Base RELATIVE POINTER, s: Zone.Status] =    BEGIN    resHeapAllocates ¬ SUCC[resHeapAllocates];  -- Note that we also count MakeNodes that fail.    [node,s] ¬ MakeNodeInternal[n, alignment, location];  -- do the makenode    RETURN;    END;          MakeNodeInternal: INTERNAL PROCEDURE [    n: Zone.BlockSize, alignment: Zone.Alignment,    location: ResidentHeap.HeapLocation]    RETURNS [node: Environment.Base RELATIVE POINTER, s: Zone.Status] =    BEGIN    segment: LONG POINTER TO HeapSegment;    priorityPrev: Process.Priority = VM.GuardStateVector[  -- guard for Resident Memory.      ProcessPriorities.priorityIOHigh];    IF n > largeNodeThreshold THEN  -- large nodes      BEGIN      newNode: LargeNodeStart;      size: Environment.PageCount;            -- count pages needed and return code if too many       size ¬ Space.PagesFromWords[n + SIZE[LargeNodeHeader]];      IF (size + resHeapSegments[location]) > maxSegments THEN        BEGIN	VM.DoneWithStateVector[priorityPrev];	RETURN[node: NULL, s: noRoomInZone];	END;      newNode ¬ ResidentMemory.Allocate[location, size];      VM.DoneWithStateVector[priorityPrev];      resHeapSegments[location] ¬ resHeapSegments[location] + CARDINAL[size];      newNode.header ¬ [size:size];      RETURN[node: LOOPHOLE[CARDINAL[newNode + SIZE[LargeNodeHeader] - base[location]]], s: okay];      END  -- large nodes          ELSE      BEGIN      -- small nodes      nodesRequired: CARDINAL = (n + nodeSize - 1) / nodeSize;      increment: CARDINAL = SELECT alignment FROM        a1, a2, a4, a8  => 1,	ENDCASE --a16-- => 2;	      -- for zero length nodes return Zone.nil      IF (nodesRequired = 0) THEN        BEGIN        VM.DoneWithStateVector[priorityPrev];        RETURN[node: Zone.nil, s: okay];        END;      -- run through all existing segments to find room       FOR segment ¬ residentHeap[location], segment.header.next WHILE segment ~= NIL DO        BEGIN	start: CARDINAL ¬ 0;	WHILE (start + nodesRequired) <= actualNodesPerPage DO	  i: CARDINAL;	  okayToUse: BOOLEAN ¬ TRUE;	  FOR i ¬ 0, i + 1 WHILE i < nodesRequired DO	    IF segment.header.allocArray[start + i] = alloc THEN	      BEGIN	      start ¬ start + i + increment;	      okayToUse ¬ FALSE;	      -- special for 16 word alignments	      IF (alignment = a16) AND ((start MOD 2) ~= 0) THEN 	        start ¬ PRED[start];	      END;	  ENDLOOP;	  -- found a bunch of words of proper length so allocate it	  IF okayToUse THEN	    BEGIN	    segment.header.sizes[start] ¬ nodesRequired;	    FOR j: CARDINAL IN [start..start + nodesRequired) DO	      segment.header.allocArray[j] ¬ alloc;	    ENDLOOP;	    VM.DoneWithStateVector[priorityPrev];	    RETURN[node: LOOPHOLE[CARDINAL[@segment.nodes[start] - base[location]]], s: okay];	    END;	ENDLOOP; -- while --	END;      ENDLOOP; -- for --	      -- must allocate a new page for the node.      IF resHeapSegments[location] >= maxSegments THEN        BEGIN	VM.DoneWithStateVector[priorityPrev];	RETURN[node: NULL, s: noRoomInZone];	END      ELSE        BEGIN	newSegment: LONG POINTER TO HeapSegment ¬	  ResidentMemory.Allocate[location, heapSizeIncrement];	resHeapSegments[location] ¬ SUCC[resHeapSegments[location]];        newSegment.header.next ¬ residentHeap[location];	residentHeap[location] ¬ newSegment;	residentHeap[location].header.allocArray ¬ ALL[free];	residentHeap[location].header.sizes ¬ ALL[0];	VM.DoneWithStateVector[priorityPrev];	RETURN MakeNodeInternal[n, alignment, location];	END;      END;    END;  SplitNode: PUBLIC ENTRY PROCEDURE [    p: Environment.Base RELATIVE POINTER, n: Zone.BlockSize,    location: ResidentHeap.HeapLocation] RETURNS [s: Zone.Status] =    BEGIN    resHeapSplits ¬ SUCC[resHeapSplits];  -- Note that we count splitting when none happens.    -- Splitting  nodes is not supported due to perceived client needs.    RETURN[okay]    END;  END.LOG   (For earlier entries, please see Mesa 8.0 archive version.)Nov 16, 1979  9:56 AM	FXH       Fixed max number of increment's logic.  Made MakeNode an entry procedure,   since the test for extending the node has to be "atomic".Nov 20, 1979  6:54 PM	FXH       Raised number of increments to 5, since this is what TestPackage>Exercise   RS232C needs to run.  Also incresed initial allocation to 3.Apr 10, 1980  2:55 PM	AWL         Allocate large objects in the first 64K but not in the actual resident zone in   order to avoid fragmentation problems in the zone.   Also, modify so that small objects do not cross page boundaries.Apr 14, 1980  9:12 AM	WDK       Now STARTed by InitializeResidentHeap.Jan 13, 1981  1:47 PM	CAJ    Eliminated conversions of relative pointers to short pointers; deleted RelativePointerToPointer, NodeSize, LargeNode.15-Sep-82 10:27:41	WDK        AR 11311: guard state vector. Removed node size and alignment histograms. Increment merged into SplitNode. Use Space.PagesFromWords. Removed MONITOR and use DisableInterrupts. Added pda heap (not exported yet). Export to VMPerf. Twiddles.28-Oct-82 10:20:23	WDK        Use new items in ResidentHeap; export to new ResMemPerf.21-Dec-82 16:12:40	AWL         NewSpace => Space. 8-Apr-83 13:56:17	WDK        Handle truncation warnings.13-Aug-85 12:44:18	RSV        New Implementation independent of Zone Package.29-Aug-85  9:32:35      RSV        Minor style changes only.
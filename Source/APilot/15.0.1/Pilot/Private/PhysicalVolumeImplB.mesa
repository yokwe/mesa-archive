-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FileMgr>PhysicalVolumeImplB.mesa    16-Dec-87 12:36:20 by RSV    DIRECTORY  DiskChannel USING [    defaultTries, DoIO, Drive, GetDriveAttributes, GetNextDrive, Handle,    InspectDiskShape, IORequest, IOStatus, nullDrive],  Environment USING [PageNumber],  File USING [PageCount],  PhysicalVolume USING [Error, Handle, ID, nullDeviceIndex, nullID],  PhysicalVolumeFormat USING [    currentVersion, duplicateRootPageSize, PageNumber, physicalVolumeLabelLength,    rootPageNumber, rootPageSize, seal],  PhysicalVolumeInternal USING [    dataTable, DriveDataHandle, DuplicatePVHandle, numberOfDrives, PVHandle],  RuntimeInternal USING [Bug],  VolTable USING [GetDrive, GetNextPV, PVAccess, PVAccessProc];PhysicalVolumeImplB: PROGRAM  IMPORTS    DiskChannel, PhysicalVolume, PhysicalVolumeInternal, RuntimeInternal,    VolTable  EXPORTS PhysicalVolumeInternal =  BEGIN  OPEN PVF: PhysicalVolumeFormat;  -- Types  Handle: TYPE = PhysicalVolume.Handle;  PVHandle: TYPE = PhysicalVolumeInternal.PVHandle;  DuplicatePVHandle: TYPE = PhysicalVolumeInternal.DuplicatePVHandle;  BugType: TYPE = {unexpectedVolTableError};  -- Constants  duplicateRootPageSize: File.PageCount = LOOPHOLE[    PVF.duplicateRootPageSize];  rootPage: PVF.PageNumber = PVF.rootPageNumber;  rootPageSize: File.PageCount = LOOPHOLE[PVF.rootPageSize];  nullDrive: DiskChannel.Drive = DiskChannel.nullDrive;  nullPVID: PhysicalVolume.ID = PhysicalVolume.nullID;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Private PhysicalVolumeImpl procedures.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  DriveFromIndex: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    index: CARDINAL] RETURNS [drive: DiskChannel.Drive] =    -- Returns drive associated with index. If index is null, returns nullDrive.    BEGIN    driveIndex: CARDINAL;    IF index = PhysicalVolume.nullDeviceIndex THEN RETURN[nullDrive];    FOR drive ¬ DiskChannel.GetNextDrive[nullDrive], DiskChannel.GetNextDrive[      drive] UNTIL drive = nullDrive DO      driveIndex ¬ DiskChannel.GetDriveAttributes[drive].deviceOrdinal;      IF driveIndex = index THEN RETURN;      ENDLOOP;    RETURN[nullDrive];    END;  GetDriveData: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    drive: DiskChannel.Drive]    RETURNS [h: PhysicalVolumeInternal.DriveDataHandle] =    BEGIN    FOR i: CARDINAL IN [0..PhysicalVolumeInternal.numberOfDrives) DO      IF PhysicalVolumeInternal.dataTable[i].drive = drive THEN        RETURN[@PhysicalVolumeInternal.dataTable[i]] ENDLOOP;    ERROR PhysicalVolume.Error[invalidHandle];    END;  PVIDFromDrive: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    drive: DiskChannel.Drive] RETURNS [found: BOOLEAN, pvID: PhysicalVolume.ID] =    BEGIN    thisDrive: DiskChannel.Drive ¬ DiskChannel.nullDrive;    GetDrive: VolTable.PVAccessProc --[tok, rootPageLoc]--  = {      thisDrive ¬ VolTable.GetDrive[tok]};    WHILE TRUE      DO      BEGIN      ENABLE {        -- catch problems in offlining a physical volume while you have the handle	PhysicalVolume.Error =>	  SELECT error FROM	    physicalVolumeUnknown => LOOP;	    ENDCASE               => Bug[unexpectedVolTableError];};      FOR pvID ¬ VolTable.GetNextPV[nullPVID], VolTable.GetNextPV[pvID]        UNTIL pvID = nullPVID DO        VolTable.PVAccess[pvID, GetDrive, read];        IF thisDrive = drive THEN RETURN[TRUE, pvID];        ENDLOOP;      RETURN[FALSE, nullPVID];      END;      ENDLOOP;    END;  PhysicalRootPageCheck: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    pv: PVHandle, id: PhysicalVolume.ID] RETURNS [ok: BOOLEAN] =    BEGIN    RETURN[      pv.seal = PVF.seal        AND pv.version = PVF.currentVersion AND pv.pvID = id];    END;    CompareDuplicateAndMainPVRootPages: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    dup: DuplicatePVHandle, main: PVHandle] RETURNS [ok: BOOLEAN] =    BEGIN    i: CARDINAL ¬ 0;    ok ¬ main.seal = dup.seal AND main.version = dup.version      AND main.labelLength = dup.labelLength AND main.pvID = dup.pvID      AND main.bootingInfo = dup.bootingInfo       AND main.subVolumeCount = dup.subVolumeCount       AND main.subVolumeMarkerID = dup.subVolumeMarkerID      AND main.badPageCount = dup.badPageCount      AND main.maxBadPages = dup.maxBadPages       --AND main.dataLostPageCount = dup.dataLostPageCount      --AND main.maxDataLostPages = dup.maxDataLostPages      AND main.onLineCount = dup.onLineCount AND main.fill1 = dup.fill1      AND main.localTimeParametersValid = dup.localTimeParametersValid       AND main.localTimeParameters = dup.localTimeParameters      AND main.checksum = dup.checksum;    FOR i: CARDINAL IN [0..MIN[      main.labelLength, PVF.physicalVolumeLabelLength]) WHILE ok DO        ok ¬ (main.label[i] = dup.label[i]);      ENDLOOP;    END;  ValidateDrive: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    drive: DiskChannel.Drive] RETURNS [found: BOOLEAN] =    BEGIN    FOR existingDrive: DiskChannel.Drive ¬ DiskChannel.GetNextDrive[nullDrive],      DiskChannel.GetNextDrive[existingDrive] UNTIL existingDrive = nullDrive DO      IF existingDrive = drive THEN        BEGIN        [] ¬ DiskChannel.InspectDiskShape[drive, quickReadOnly];        RETURN[TRUE];        END;      ENDLOOP;    RETURN[FALSE];    END;  WritePVRootPage: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    page: Environment.PageNumber, channel: DiskChannel.Handle]    RETURNS [status: DiskChannel.IOStatus] =    BEGIN    request: DiskChannel.IORequest ¬ [      diskPage: rootPage, memoryPage: page, tries: DiskChannel.defaultTries,      count: rootPageSize, useSamePage: FALSE, command: write];    status ¬ DiskChannel.DoIO[channel, @request].status;    END;  WriteDuplicatePVRootPage: PUBLIC --PhysicalVolumeInternal-- PROCEDURE [    page: Environment.PageNumber, channel: DiskChannel.Handle,    duplicateRootPage: PVF.PageNumber]    RETURNS [status: DiskChannel.IOStatus] =    BEGIN    request: DiskChannel.IORequest ¬ [      diskPage: duplicateRootPage, memoryPage: page,      tries: DiskChannel.defaultTries,      count: duplicateRootPageSize, useSamePage: FALSE, command: write];    status ¬ DiskChannel.DoIO[channel, @request].status;    END;  END.LOG16-Dec-87 12:36:20   RSV  Created File   
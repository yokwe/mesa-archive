-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- SupervisorImpl.mesa   15-Apr-83 16:26:55 by EKN   -- In light of the expected extremely infrequent use of the facilities provided by this module, the algorithms and data structures in this module were designed to be simple, reliable, compact, and slow.-- Packaging considerations:-- The following procedures must be packaged into the same swap unit: EnumerateSubsystems, AssignAllDependencies, AssignDependency, CallAgentProcedure, ForAllSubsys, MarkDependencyUnknown, SupervisorAgent, LockDatabase, UnlockDatabase.  (See InitializationImpl.mesa.) -- Initialization issues:-- InitializationImpl assumes that SupervisorImpl is swappable in the packaged and unpackaged versons of Pilot, and that its swap unit includes SupervisorAgent.-- InitializationImpl assumes that the global frame of SupervisorImpl is pinned in Pilot.DIRECTORY  Environment USING [wordsPerPage],  File USING [nullFile],  Space USING [Interval, Map, PageCount, SwapUnitOption],  Supervisor USING [AgentProcedure, Event, ClientsImpls],  Zone USING [Base, Create, FreeNode, MakeNode, Handle, Status];SupervisorImpl: MONITOR  IMPORTS Space, Zone EXPORTS Supervisor =  BEGIN OPEN Supervisor;  Dependency: TYPE = CARDINAL;  dependencyUnknown: Dependency = LAST[Dependency];  DependencyKnown: TYPE =  -- increasing value means increasing dependency.  Dependency [FIRST[Dependency]..dependencyUnknown - 1];      SubsysEntry: TYPE = RECORD [    supporterChainHead: PtrSupporterChainEntry,    dependentChainHead: PtrDependentChainEntry,    dependency: Dependency,    agent: AgentProcedure,    instanceData: LONG POINTER TO UNSPECIFIED,    nextSubsys: PtrSubsysEntry];  -- chain of all existing SubsysEntry's.  PtrSubsysEntry: TYPE = BaseType RELATIVE ORDERED POINTER [0..LAST[CARDINAL]]    TO SubsysEntry;  SubsystemHandle: PUBLIC TYPE = PtrSubsysEntry;    DependentChainEntry: TYPE = RECORD [     nextDependent: PtrDependentChainEntry, dependent: PtrSubsysEntry];   PtrDependentChainEntry: TYPE = BaseType RELATIVE ORDERED POINTER    [0..LAST[CARDINAL]] TO DependentChainEntry;   nilDependent: PtrDependentChainEntry = LAST[PtrDependentChainEntry];  SupporterChainEntry: TYPE = RECORD [    nextSupporter: PtrSupporterChainEntry, supporter: PtrSubsysEntry];  PtrSupporterChainEntry: TYPE = BaseType RELATIVE ORDERED POINTER    [0..LAST[CARDINAL]] TO SupporterChainEntry;  nilSupporter: PtrSupporterChainEntry = LAST[PtrSupporterChainEntry];  BaseType: TYPE = LONG BASE POINTER TO --UNIQUE TYPE-- RECORD [UNSPECIFIED];  -- Public data:  InvalidSubsystem: PUBLIC ERROR = CODE;  CyclicDependency: PUBLIC ERROR = CODE;  NoSuchDependency: PUBLIC ERROR = CODE;     EnumerationAborted: PUBLIC ERROR = CODE;   nullSubsystem: PUBLIC SubsystemHandle ¬ LAST[PtrSubsysEntry];    -- Monitor data:  Bug: PRIVATE --PROGRAMMING-- ERROR [BugType] = CODE;  BugType: TYPE = {bug0, bug1, bug2, bug3, bug4, bug5, bug6, bug7, bug8, bug9, bug10, bug11, bug12, lockUnlockMismatch};  countWorkSpace: Space.PageCount =    (1000*(SIZE[SubsysEntry] +            10*SIZE[SupporterChainEntry]))/Environment.wordsPerPage;  --  should be a generous maximum.  workSpace: Space.Interval;  zone: Zone.Handle;  base: BaseType;  -- base pointer to the work area.  subsysChainHead: PtrSubsysEntry;  -- chained through SubsyEntry.nextEntry.    dependenciesKnown : BOOLEAN;  -- are the dependencies of the current structure known?  limitDependency: DependencyKnown;  -- the maximum dependency (over all subsystems) + 1.  readers: CARDINAL ¬ 0;  -- the supervisor's database is locked and thereby    -- protected from writers whenever readers # 0; multiple readers are allowed.  unlocked: CONDITION;  -- gets notified every time readers is decremented to zero  InitializeSupervisor: PROCEDURE =    BEGIN    Checking: BOOLEAN ¬ FALSE;     swapUnits: Space.SwapUnitOption ¬ [uniform[1]];    status: Zone.Status;    workSpace ¬ Space.Map[window: [File.nullFile, 0, countWorkSpace], swapUnits: swapUnits];    base ¬ workSpace.pointer;    [zone, status] ¬ Zone.Create[      storage: base, length: CARDINAL[countWorkSpace*Environment.wordsPerPage],      zoneBase: base, threshold: SIZE[SupporterChainEntry]+1, checking: Checking];    IF status ~= okay THEN ERROR Bug[bug0];    subsysChainHead ¬ nullSubsystem;     dependenciesKnown ¬ FALSE;    readers ¬ 0;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Monitor external procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  NotifyAllSubsystems : PUBLIC --EXTERNAL-- PROCEDURE [     event: Event, eventData: LONG POINTER TO UNSPECIFIED, whichFirst: ClientsImpls] =    BEGIN ENABLE UNWIND => UnlockDatabase[];    actionDependency: DependencyKnown;    CallAgentProcedure: SubsysProc --[subsys: PtrSubsysEntry]--  = {      IF base[subsys].dependency = actionDependency THEN        base[subsys].agent[event, eventData, base[subsys].instanceData] };            LockDatabase[];    IF NOT dependenciesKnown THEN      AssignAllDependencies[];  -- also sets limitDependency.    SELECT whichFirst FROM      implementors =>        FOR actionDependency --INCREASING-- IN DependencyKnown          [FIRST[DependencyKnown]..limitDependency) DO          ForAllSubsys[CallAgentProcedure --[actionDependency]-- ] ENDLOOP;      clients =>        FOR actionDependency DECREASING IN DependencyKnown          [FIRST[DependencyKnown]..limitDependency) DO          ForAllSubsys[CallAgentProcedure --[actionDependency]-- ] ENDLOOP;      ENDCASE;    UnlockDatabase[];    END;    NotifyDirectSubsystems: PUBLIC --EXTERNAL-- PROCEDURE [     event: Event, eventData: LONG POINTER TO UNSPECIFIED, which: ClientsImpls,    subsystem: SubsystemHandle ] =     BEGIN ENABLE UNWIND => UnlockDatabase[];          dep: PtrDependentChainEntry;    supp: PtrSupporterChainEntry;    subsys: PtrSubsysEntry;            LockDatabase[];    SELECT which FROM       clients =>        FOR dep ¬ base[subsystem].dependentChainHead, base[dep].nextDependent 	   WHILE dep ~= nilDependent DO         	    subsys ¬ base[dep].dependent;	    base[subsys].agent[event, eventData, base[subsys].instanceData];   	 ENDLOOP;      implementors =>        FOR supp ¬ base[subsystem].supporterChainHead, base[supp].nextSupporter  	  WHILE supp ~= nilSupporter DO 	    subsys ¬ base[supp].supporter;	    base[subsys].agent[event, eventData, base[subsys].instanceData];	  ENDLOOP;      ENDCASE;    UnlockDatabase[];          END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Monitor entry procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AddDependency: PUBLIC ENTRY PROCEDURE [client, implementor: SubsystemHandle] =    BEGIN    status: Zone.Status;    supp: PtrSupporterChainEntry;    dep: PtrDependentChainEntry;    WHILE readers # 0 DO WAIT unlocked ENDLOOP;    IF InvalidHandle[client] OR InvalidHandle[implementor] THEN      RETURN WITH ERROR InvalidSubsystem;    IF DependsOnInternal[implementor, client] THEN      RETURN WITH ERROR CyclicDependency;     dependenciesKnown ¬ FALSE;    FOR supp ¬ base[client].supporterChainHead, base[supp].nextSupporter WHILE      supp ~= nilSupporter DO      IF base[supp].supporter = implementor THEN RETURN;  -- ignore duplicate.      ENDLOOP;    [LOOPHOLE[supp, Zone.Base RELATIVE POINTER], status] ¬ Zone.MakeNode[      zone, SIZE[SupporterChainEntry]];    IF status ~= okay THEN ERROR Bug[bug4];    base[supp].supporter ¬ implementor;    base[supp].nextSupporter ¬ base[client].supporterChainHead;    base[client].supporterChainHead ¬ supp;    [LOOPHOLE[dep, Zone.Base RELATIVE POINTER], status] ¬ Zone.MakeNode[      zone, SIZE[DependentChainEntry]];    IF status ~= okay THEN ERROR Bug[bug9];    base[dep].dependent ¬ client;    base[dep].nextDependent ¬ base[implementor].dependentChainHead;    base[implementor].dependentChainHead ¬ dep;    END;  CreateSubsystem: PUBLIC ENTRY PROCEDURE    [agent: AgentProcedure, instanceData: LONG POINTER TO UNSPECIFIED]    RETURNS [handle: SubsystemHandle] =    BEGIN    status: Zone.Status;    WHILE readers # 0 DO WAIT unlocked ENDLOOP;    [LOOPHOLE[handle, Zone.Base RELATIVE POINTER], status] ¬ Zone.MakeNode[      zone, SIZE[SubsysEntry]];    IF status ~= okay THEN ERROR Bug[bug1];    base[handle].supporterChainHead ¬ nilSupporter;     base[handle].dependentChainHead ¬ nilDependent;    -- dependency not set here.    base[handle].agent ¬ agent;    base[handle].instanceData ¬ instanceData;    base[handle].nextSubsys ¬ subsysChainHead;    subsysChainHead ¬ handle;    dependenciesKnown ¬ FALSE;    END;  DeleteSubsystem: PUBLIC ENTRY PROCEDURE [handle: SubsystemHandle] =    BEGIN    status: Zone.Status;    subsys, prevSubsys: PtrSubsysEntry;    supp, nextSupp: PtrSupporterChainEntry;    dep, nextDep: PtrDependentChainEntry;    WHILE readers # 0 DO WAIT unlocked ENDLOOP;    IF InvalidHandle[handle] THEN RETURN WITH ERROR InvalidSubsystem;    prevSubsys ¬ nullSubsystem;    FOR subsys ¬ subsysChainHead, base[subsys].nextSubsys DO      IF subsys = nullSubsystem THEN        RETURN WITH ERROR InvalidSubsystem;      IF subsys = handle THEN        BEGIN        IF prevSubsys = nullSubsystem THEN          subsysChainHead ¬ base[handle].nextSubsys        ELSE base[prevSubsys].nextSubsys ¬ base[handle].nextSubsys;        FOR supp ¬ base[handle].supporterChainHead, nextSupp WHILE supp ~=          nilSupporter DO          nextSupp ¬ base[supp].nextSupporter;          [status] ¬ Zone.FreeNode[zone, @base[supp]];          IF status ~= okay THEN ERROR Bug[bug2];          ENDLOOP; 	FOR dep ¬ base[handle].dependentChainHead, nextDep WHILE dep ~=          nilDependent DO          nextDep ¬ base[dep].nextDependent;          [status] ¬ Zone.FreeNode[zone, @base[dep]];          IF status ~= okay THEN ERROR Bug[bug8];          ENDLOOP;        [status] ¬ Zone.FreeNode[zone, @base[handle]];        IF status ~= okay THEN ERROR Bug[bug3];        RETURN;        END;      prevSubsys ¬ subsys;      ENDLOOP;    END;  DependsOn: PUBLIC ENTRY PROCEDURE [client, implementor: SubsystemHandle]    RETURNS [BOOLEAN] = {    -- DependsOn is a reader, not a writer.  The monitor insures that there is no    -- concurrent writing process running, so we don't need to fool with the    -- readers variable here.    IF InvalidHandle[client] OR InvalidHandle[implementor] THEN      RETURN WITH ERROR InvalidSubsystem;    RETURN[DependsOnInternal[client, implementor]] };  LockDatabase: ENTRY PROCEDURE =    BEGIN    readers ¬ readers + 1;    END;  RemoveDependency: PUBLIC ENTRY PROCEDURE [client, implementor: SubsystemHandle] =    BEGIN    supp, prevSupp: PtrSupporterChainEntry;    dep, prevdep: PtrDependentChainEntry;    status: Zone.Status;    WHILE readers # 0 DO WAIT unlocked ENDLOOP;    IF InvalidHandle[client] OR InvalidHandle[implementor] THEN      RETURN WITH ERROR InvalidSubsystem;    -- Find entry in supporterChain:    prevSupp ¬ nilSupporter;     FOR supp ¬ base[client].supporterChainHead, base[supp].nextSupporter DO      IF supp = nilSupporter THEN RETURN WITH ERROR NoSuchDependency;      IF base[supp].supporter = implementor THEN        BEGIN		-- Remove entry from supporterChain and free supporterChain node:        IF prevSupp = nilSupporter THEN          base[client].supporterChainHead ¬ base[supp].nextSupporter        ELSE base[prevSupp].nextSupporter ¬ base[supp].nextSupporter;        [status] ¬ Zone.FreeNode[zone, @base[supp]];        IF status ~= okay THEN ERROR Bug[bug5];		-- Find entry in dependentChain:	dep ¬ base[implementor].dependentChainHead;	prevdep ¬ nilDependent;	IF dep = nilDependent THEN ERROR Bug[bug11];	WHILE base[dep].dependent ~= client DO 	  prevdep ¬ dep;	  dep ¬ base[dep].nextDependent;	  IF dep = nilDependent THEN ERROR Bug[bug12];	  ENDLOOP;	  	-- Remove entry from dependentChain and free dependentChain node:	IF prevdep = nilDependent THEN 	  base[implementor].dependentChainHead ¬ base[dep].nextDependent	ELSE base[prevdep].nextDependent ¬ base[dep].nextDependent;	[status] ¬ Zone.FreeNode[zone, @base[dep]];        IF status ~= okay THEN ERROR Bug[bug10];        RETURN;        END;      prevSupp ¬ supp;      ENDLOOP;    END;  UnlockDatabase: ENTRY PROCEDURE =    BEGIN    IF readers = 0 THEN ERROR Bug[lockUnlockMismatch];    IF (readers ¬ readers - 1) = 0 THEN BROADCAST unlocked;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Monitor internal procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    AssignAllDependencies: --logically INTERNAL-- PROCEDURE =    -- also sets limitDependency as a side effect.    BEGIN    makingProgress, unknownsRemain: BOOLEAN;    AssignDependency: INTERNAL SubsysProc --[subsys: PtrSubsysEntry]--  =      -- assigns dependency if possible on this pass.      -- sets makingProgress, unknownsRemain.      BEGIN      supp: PtrSupporterChainEntry;      suppDep, maxSuppDep: Dependency;      IF base[subsys].dependency ~= dependencyUnknown THEN RETURN;  -- job done.      maxSuppDep ¬ dependencyUnknown;      FOR supp ¬ base[subsys].supporterChainHead, base[supp].nextSupporter WHILE        supp ~= nilSupporter DO        suppDep ¬ base[base[supp].supporter].dependency;        IF suppDep = dependencyUnknown THEN          BEGIN unknownsRemain ¬ TRUE; RETURN END        ELSE          maxSuppDep ¬            IF maxSuppDep = dependencyUnknown THEN suppDep            ELSE MAX[maxSuppDep, suppDep];        ENDLOOP;      limitDependency ¬ MAX[limitDependency,        1 + (base[subsys].dependency ¬               IF maxSuppDep = dependencyUnknown THEN FIRST[DependencyKnown]               ELSE DependencyKnown[maxSuppDep] + 1 )];      makingProgress ¬ TRUE;      END;    limitDependency ¬ FIRST[DependencyKnown];    ForAllSubsys[MarkDependencyUnknown];    DO  --repeated passes until all dependencies resolved--      makingProgress ¬ unknownsRemain ¬ FALSE;      -- makingProgress, unknownsRemain ¬ -- ForAllSubsys[AssignDependency];      IF ~makingProgress THEN EXIT;      ENDLOOP;    IF unknownsRemain THEN ERROR Bug[bug6];  -- cyclic dependency in subsystems.    END;  DependsOnInternal: INTERNAL PROCEDURE [dependent, supporter: PtrSubsysEntry]    RETURNS [depends: BOOLEAN] =    BEGIN    supp: PtrSupporterChainEntry;    FOR supp ¬ base[dependent].supporterChainHead, base[supp].nextSupporter      WHILE supp ~= nilSupporter DO      IF base[supp].supporter = supporter        OR DependsOnInternal[base[supp].supporter, supporter] THEN        RETURN[depends: TRUE];      ENDLOOP;    RETURN[depends: FALSE];    END;      InvalidHandle: INTERNAL PROCEDURE [h: PtrSubsysEntry]    RETURNS [invalid: BOOLEAN] =    BEGIN    lastUseableWorkSpace: PtrSubsysEntry =      LOOPHOLE[CARDINAL[countWorkSpace*Environment.wordsPerPage] - MAX[                 SIZE[SubsysEntry], SIZE[SupporterChainEntry]]];  -- We assume that the zone starts at base.    IF h > lastUseableWorkSpace      OR        (base[h].supporterChainHead ~= nilSupporter          AND base[h].supporterChainHead > LOOPHOLE[lastUseableWorkSpace,            PtrSupporterChainEntry])      OR        (base[h].nextSubsys ~= nullSubsystem          AND base[h].nextSubsys > lastUseableWorkSpace) THEN      RETURN[invalid: TRUE]    ELSE RETURN[invalid: FALSE];    END;  MarkDependencyUnknown: INTERNAL SubsysProc --[subsys: PtrSubsysEntry]--  = {    base[subsys].dependency ¬ dependencyUnknown };  SubsysProc: TYPE = PROCEDURE [subsys: PtrSubsysEntry];  ForAllSubsys: --logically INTERNAL-- PROCEDURE [proc: SubsysProc] = {    subsys: PtrSubsysEntry;    FOR subsys ¬ subsysChainHead, base[subsys].nextSubsys WHILE subsys ~=      nullSubsystem DO proc[subsys]; ENDLOOP };  -- (Module is initialized by a start trap.)  InitializeSupervisor[];  END.LOGMay 27, 1980  9:30 AM   WDK       Created file.April 21, 1981  12:11 PM   WDK       Converted to Mesa7.  Removed Initialization-related code. September 22, 1981  9:13 AM  Lui   Created codes for NotifyDirectSubsystem, Created DependentChainEntry.26-Sep-81 18:15:17   WDK       AssignAllDependencies now calculates limitDependency.  EnumerateDirect had clients and implementors swapped.2-Dec-81 18:46:26   WDK       RemoveDependency[client, firstImplementorOfClient] failed to retain any remaining chain of implementors.16-Feb-82 11:16:42   CRF   Modified Notify* to allow nested notifications, which required adding LockDatabase and UnlockDatabase.   15-Apr-83 16:27:03   EKN      Update to Klamath  
-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- VolTable.mesa    18-Sep-86 13:29:08 by RSV    -- This PRIVATE interface provides a facility for managing-- physical volumes ("PV"), logical volumes ("LV"),-- and subvolumes ("SV") on the system element. This interface-- should only be used within the FileBasics and FileMgr configs.-- (A subvolume is a contiguous portion of a physical volume-- and comprises part or all of a logical volume.)-- VolTable records information about each type of volume.-- Along with explicit data about each volume,-- VolTable also maintains information relating the objects (such as-- which subvolumes comprise a particular logical volume). VolTable provides-- operations for locking individual volumes, as well as a mechanism-- to lock all volumes. Additionally, VolTable provides several utility-- operations for each type of volume.-- NOTES:-- * Routines which require a token parameter imply that the entity to be--   manipulated must have previously been locked. Locking is the only way to--   acquire a token. Clients must not store tokens for future use or in any--   other way try to interpret them.-- ORGANIZATION: The interface is divided into several sections each of which is-- internally alphabetically ordered. The sections are:--  * Various TYPEs and constants are defined.--  * Procedures for Enumeration and State Transitions.--  * Utility Procedures for LV's, PV's and SV's in that order.--  * Locking Procedures for LV's, PV's, SV's, and the Table (in that order).--  * Special procedures of interest to only special clients, like the Scavenger.DIRECTORY  DiskBackingStore USING [ChannelHandle],  DiskChannel USING [Drive, Handle],  LogicalVolumeFormat USING [Handle, nullVolumePage],  PhysicalVolume USING [ID, nullID, PageNumber],  PhysicalVolumeFormat USING [DuplicateHandle, Handle, MarkerHandle, MarkerID],  Volume USING [ID, nullID, PageCount, PageNumber];VolTable: DEFINITIONS =  BEGIN  -- Volume States and Entry States:  LVEntryState: TYPE = {    offline, partiallyOnline, allSVsOnline, online, open};  -- LVEntryState specifies the client's MINIMUM requirements for the  -- state of a logical volume.  -- The states of a logical voume are:  -- * offline:  All of the subvolumes of the logical volume are offline.  --   VolTable has no knowledge of the logical volume.  -- * partiallyOnline:  Some of the subvolumes of the logical volume  --     are online.  -- * allSVsOnline:  All subvolumes are online.  -- * online:  All subvolumes are online, the root page is readable and  --     mapped.  -- * open: All subvolumes are online, the root page is readable and  --     mapped, and the volume has been marked open by a call to SetOpen.  PVEntryState: TYPE = {offline, online};  -- PVEntryState specifies the client's requirement for the state of a  -- physical volume root page. The states of a physical voume are:  -- * offline: The PV root page is not available for use via MapPVRootPage.  --     Due to the required style of client usage, this also implies that  --     no SVs of the PV are online.  -- * online:  The PV root page is available for use via MapPVRootPage.  SVEntryState: TYPE = {offline, online};  -- SVEntryState specifies the client's requirement for the state of a  -- subvolume. The states of a subvolume are:  -- * offline: The subvolume is unknown to VolTable.  -- * online:  The SV is present on the system element and fully usable.  -- Lock Types:  LockState: TYPE = {  -- order of items is important.    read, write, maybeWrite, writeWithChangingFlag, unlocked};  readWriteAreContiguous: PRIVATE BOOLEAN[TRUE..TRUE] =    (LockState[write] = LockState[read].SUCC);  -- * read: Client will neither alter the VolTable-maintained  --   state of the volume nor write on the disk.  --   This LockState allows shared access to the volume by other processes.  --  -- * write: Client may alter the VolTable-maintained state  --   of the volume and WILL write on the disk;  --   Furthermore, a crash part way through the operation  --   WILL NOT require the volume to be scavenged.  --   This LockState guarantees exclusive access for the client.  --  -- * maybeWrite: Client may alter the VolTable-maintained  --   state of the volume and may or may not write on the disk.  --   With this LockState, the client is responsible for  --   interrogating the readOnly status of the volume and  --   doing the right thing. Furthermore, a crash part way through  --   the operation WILL NOT require the volume to be scavenged.  --   This LockState guarantees exclusive access for the client.  --  -- * writeWithChangingFlag: Client may alter the VolTable-maintained  --   state of the volume and WILL write on the disk;  --   Furthermore, a crash part way through the operation WILL  --   require the volume to be scavenged.  --   This LockState guarantees exclusive access for the client.  LVLockType: TYPE = LockState [read..writeWithChangingFlag];  unlockedExcluded: PRIVATE BOOLEAN[TRUE..TRUE] =    (LockState[unlocked] NOT IN LVLockType);  PVLockType: TYPE = LockState [read..write];  SVLockType: TYPE = LockState [read..write];  -- Other Types:  RootPageReadability: TYPE = {rootPageReadable, rootPageUnreadable};  ClientData: TYPE [4];  -- LV client data.  Context: TYPE [1];  -- LV ETable context.  LVToken: TYPE [1];  -- generated when access to a LV has been granted.  PVToken: TYPE [1];  -- generated when access to a PV has been granted.  SVToken: TYPE [1];  -- generated when access to a SV has been granted.  SVDesc: TYPE = RECORD [  -- describes a subvolume.    lvID: LVID,    pvID: PVID,    lvPageOfSV: Volume.PageNumber,    pvPageOfSV: PhysicalVolume.PageNumber,    svLength: Volume.PageCount];    SVDescPtr: TYPE = LONG POINTER TO SVDesc;  -- Abbreviations used in this interface:  LVID: TYPE = Volume.ID;  PVID: TYPE = PhysicalVolume.ID;  LVPage: TYPE = Volume.PageNumber;  PVPage: TYPE = PhysicalVolume.PageNumber;  -- Constants:  nullLVPage: Volume.PageNumber = LogicalVolumeFormat.nullVolumePage;  nullPVPage: PhysicalVolume.PageNumber = 0;  nullSVDesc: SVDesc = [    Volume.nullID, PhysicalVolume.nullID, nullLVPage, nullPVPage, 0];  -- Stateless Enumeration of Physical, Logical, and SubVolumes.  --  -- All enumerations start and end with an appropriate null value.  -- Since these are stateless enumerators, the caller  -- must either have some lock that assures the continued validity  -- of the results, or must treat the results as a hint.  GetNextLV: PROCEDURE [lvID: LVID] RETURNS [LVID];  -- Starts and ends with Volume.nullID.  -- If lvID is offline, Volume.Unknown is raised.  GetNextPV: PROCEDURE [pvID: PVID] RETURNS [PVID];  -- Starts and ends with PhysicalVolume.nullID. If pvID is offline,  -- PhysicalVolume.Error[physicalVolumeUnknown] is raised.  GetNextSV: PROCEDURE [key: SVEnumKey, svdPtr: SVDescPtr];  -- When enumerating SV's, one may enumerate the SV's of a PV, or the  -- the SV's of an LV. key identifies which path and which SV you want.  -- Subvolumes of an LV are ordered by their  -- starting lv page number. Similarly for PV's.  -- If key = [by?V[first[]]], the first online SV is returned.  -- If key = [by?V[next[pageNum]]], the first subvolume after the one which  -- contains pageNum is returned.  -- The enumeration ends with nullSVDesc.  -- If key.lvID is offline, the debugger is called.  -- If the root page of key.pvID is offline and is not being brought online  -- by an enclosing invocation of PVAccess, and all subvolumes of key.pvID  -- are offline, the debugger is called.  SVEnumKey: TYPE = RECORD [    SELECT enumPath: * FROM    byLV => [lvToEnum: LVID, sv: SVPosInLV],    byPV => [pvToEnum: PVID, sv: SVPosInPV],    ENDCASE];  SVPosInLV: TYPE = RECORD [    SELECT type: * FROM    first => NULL, next => [lvPage: Volume.PageNumber], ENDCASE];  SVPosInPV: TYPE = RECORD [    SELECT type: * FROM    first => NULL, next => [pvPage: PhysicalVolume.PageNumber], ENDCASE];  -- Onlining Volumes:  SetLVOnline: PROCEDURE [    tok: LVToken, rootPage: LogicalVolumeFormat.Handle,    readability: RootPageReadability];  -- rootPage­ is an unmapped buffer which will hold the LV Root Page.  -- If readability = rootPageReadable, makes the volume state be  -- online. On return, rootPage­ will be mapped to the LV root page.  -- If readability = rootPageUnreadable, makes the volume state be  -- allsSVsOnline. On return, rootPage­ will be unmapped.  -- The caller relinquishes ownership of rootPage­ until  -- a SetLVOffline is performed.  -- If the LV is not in the partiallyOnline state, the debugger is called.  SetPVOnline: PROCEDURE [    tok: PVToken, bsChannel: DiskBackingStore.ChannelHandle];  -- Makes the PV online by declaring the ChannelHandle  -- of the PV, enabling the root page to later be mapped via MapPVRootPage.  -- After calling this proc, the client will typically obtain the MarkerID  -- from the PV root page and then call RegisterPVMarkerID,   -- enabling marker pages to later be mapped via MapMarkerPage.  -- If the PV is already online, the debugger is called.  RegisterPVMarkerID: PROCEDURE [    tok: PVToken, markerID: PhysicalVolumeFormat.MarkerID];  -- Declares the MarkerID of a PV.  -- If the PV is offline, the debugger is called.  SetSVOnline: PROCEDURE [    tok: SVToken, pvPageOfSV: PVPage, lvPageOfSV: LVPage,    svLength: Volume.PageCount];  -- Makes the SV online by declaring the subvolume info of the SV.  -- If the SV is already online, the debugger is called.  -- Offlining Volumes:  SetLVOffline: PROCEDURE [tok: LVToken];  -- Makes the volume state be partiallyOnline or offline, depending  -- on what subvolumes are currently online.  -- If the volume was online, the root page buffer which was given to  -- SetLVOnline (and is an argument to the current LVAccess proc)  -- will be unmapped.  -- If the volume was online or allSVsOnline, the ownership  -- of the root page buffer returns to the caller.  -- If the LV is in the open state or if tok is  -- a read lock, the debugger is called.  SetPVOffline: PROCEDURE [tok: PVToken];  -- Makes the PV state be offline.  -- If the PV is already offline or tok is not a write lock  -- or the root page is currently mapped, the debugger is called.  -- If the PV has any online SV's, the debugger is called. This  -- indicates a logic error in PhysicalVolume.Offline.  SetSVOffline: PROCEDURE [tok: SVToken];  -- Makes the SV state be offline.  -- If the SV is already offline or tok is not a write lock or  -- the marker page is currently mapped, the debugger is called.  -- LV Utilities:  AssertRootPageReadability: PROCEDURE [tok: LVToken, readability: RootPageReadability];  -- Sets the readability of an LV root page.  -- If the volume state is allSVsOnline and readability = rootPageReadable,  -- the root page will be mapped (to the buffer passed to SetLVOnline)  -- and the state changed to online.  -- If the volume state is online and the readability = rootPageUnreadable,  -- the root page will be unmapped and the state changed to allSVsOnline.  -- The remaining possibilities are no-ops.  -- If the volume is not online or allSVsOnline, the debugger is called.  GetClientData: PROCEDURE [tok: LVToken, data: LONG POINTER TO ClientData];  -- Returns a copy of the LV's ClientData in data­.  GetLVStatus: PROCEDURE [lv: LVID]    RETURNS [entryState: LVEntryState, readOnly: BOOLEAN];  -- NOTE: No lock is required for this operation. It returns results  -- which are correct at the time of invocation.  -- If SetReadOnlyStatus has never been called for this volume,  -- returns readOnly = FALSE.  GetETableContext: PROCEDURE [tok: LVToken, context: LONG POINTER TO Context];  -- Returns a copy of the LV's Context.  SetClientData: PROCEDURE [tok: LVToken, data: ClientData];  -- Sets the volume's ClientData.  SetClosed: PROCEDURE [tok: LVToken];  -- Makes the LV state be online. If the volume is not  -- in the online or open state, the debugger is called.  SetOpen: PROCEDURE [tok: LVToken];  -- Makes the LV state be open. If the volume is not  -- in the online or open state, the debugger is called.  SetReadOnlyStatus: PROCEDURE [tok: LVToken, readOnly: BOOLEAN];  -- Sets the readOnly attribute of the volume. (See LVAccess)  SetETableContext: PROCEDURE [tok: LVToken, context: Context];  -- Sets the volume's Context.    GetLVHandle: PROCEDURE [tok: LVToken] RETURNS [LogicalVolumeFormat.Handle];  -- ETable shares root page with token.    GetLVID: PROCEDURE [tok: LVToken] RETURNS [Volume.ID];  -- also needed by ETable.  -- PV Utilities:  GetBSChannel: PROCEDURE [tok: PVToken]    RETURNS [channel: DiskBackingStore.ChannelHandle];  -- Returns the ChannelHandle of the PV.  -- If the PV is offline, the debugger is called.  GetDiskChannel: PROCEDURE [tok: PVToken] RETURNS [channel: DiskChannel.Handle];  -- Returns the DiskChannel.Handle of the PV.  -- If the PV is offline, the debugger is called.  GetDrive: PROCEDURE [tok: PVToken] RETURNS [drive: DiskChannel.Drive];  -- Returns the Drive of the PV.  -- If the PV is offline, the debugger is called.  MapPVRootPage: PROCEDURE [tok: PVToken, rootPage: PhysicalVolumeFormat.Handle];  -- Maps the PV root page to rootPage­.  -- If the PV is offline, the debugger is called.  UnmapPVRootPage: PROCEDURE [    tok: PVToken, rootPage: PhysicalVolumeFormat.Handle];  -- Unmaps rootPage­. If the PV is offline, the debugger is called.  MapDuplicatePVRootPage: PROCEDURE [    tok: PVToken, rootPage: PhysicalVolumeFormat.DuplicateHandle];  -- Maps the duplicate PV root page to rootPage­.  -- If the PV is offline, the debugger is called.  UnmapDuplicatePVRootPage: PROCEDURE [    tok: PVToken, rootPage: PhysicalVolumeFormat.DuplicateHandle];  -- Unmaps rootPage­. If the PV is offline, the debugger is called.  -- SV Utilities:  FindSV: PROCEDURE [lvID: Volume.ID, page: LVPage, svdPtr: SVDescPtr]    RETURNS [found: BOOLEAN, channel: DiskBackingStore.ChannelHandle];  -- Searches for the SV containing "page" of lvID.  -- If the SV is offline, returns found = FALSE, sv = channel = TRASH.  -- Otherwise returns found = TRUE and information about the SV.  -- Since this operation does not require a lock, the caller  -- must either have some lock that assures the continued validity  -- of the results, or must treat the results as a hint.  MapMarkerPage: PROCEDURE [    tok: SVToken, markerPage: PhysicalVolumeFormat.MarkerHandle];  -- Maps the marker page of the SV to markerPage­.  -- If the SV is offline, the debugger is called.  -- If the containing PV is offline or RegisterPVMarkerID has  -- not been called, the debugger is called.   UnmapMarkerPage: PROCEDURE [    tok: SVToken, markerPage: PhysicalVolumeFormat.MarkerHandle];  -- Unmaps markerPage­. If the SV is offline, the debugger is called.  -- Volume Locking:  -- These procedures provide locked access to volumes.  -- A client wishing access an LV (say) does so by  -- calling LVAccess[...proc: MyProc...]. MyProc is called  -- from within LVAccess, and while MyProc operates, the requested lock  -- is held on the logical volume. When an client proc is called,  -- it is passed a lock token. The token is used with most  -- of the utility procedures in this interface,  -- and is only valid until LAccess returns. The analagous protocol  -- is used with PVAccess for PV's and SVAccess for SV's.  -- NOTES ON CORRECT USAGE:  -- * There is a locking hierarchy convention which models  --   the abstraction hierarchy within Pilot. LV locks are  --   "higher" than PV locks which are above SV locks.  --   To prevent deadlocks, the holder of an LV lock should not  --   get other LV locks, the holder of a PV lock should not  --   get other LV or PV locks, and the holder of an SV lock  --   should not get any other locks.  --   A process holding the Table Lock can get any locks in any order.   LVAccess: PROCEDURE [    lvID: LVID, proc: LVAccessProc, lock: LVLockType,    entryState: LVEntryState ¬ open];  -- Acquires the requested lock on the LV, then calls proc.  -- EntryState specifies the client's MINIMUM requirements for the  -- state of a logical volume. For example, if entryState = online, the  -- access will succeed if the volume state is online or open.  -- If lock = writeWithChangingFlag, the modifications to disk data  -- which are required to be mutually consistent will be done  -- under to protection of the LV root page's "needs scavenging" flag.  -- If lock = write or writeWithChangingFlag and the volume  -- is readOnly, Volume.ReadOnly is raised. Note that  -- it is NOT raised for lock = maybeWrite.  -- If the volume state does not satify the requirement of  -- entryState, the following error actions will be taken..  -- Note: the conditions are checked in the following order:  -- EntryState   		LV State	Error Action  -- ==========  		============	============  -- partiallyOnline..open	offline		Volume.Unknown  -- allSVsOnline..open		partiallyOnline	Volume.NotOnline  -- online			allSVsOnline	Volume.NeedsScavenging  -- open			allSVsOnline	Volume.NotOpen  -- open			online		Volume.NotOpen  LVAccessProc: TYPE = PROCEDURE [    tok: LVToken, lvHandle: LogicalVolumeFormat.Handle];  -- If the actual state of the LV was in [online..open] when LVAcccess  -- was called, then lvHandle­ is mapped to the LV root page (and that  -- page is readable); otherwise, lvHandle­ will be unmapped.  -- If the actual state of the LV was in [allSVsOnline..open]  -- when LVAcccess was called, then lvHandle­ is the buffer  -- that was declared to SetLVOnline; otherwise it is NIL.  PVAccess: PROCEDURE [    pvID: PVID, proc: PVAccessProc, lock: PVLockType,    entryState: PVEntryState ¬ online];  -- Acquires the requested lock on the PV root page, then calls proc.  -- If entryState = offline, "proc" typically calls SetPVOnline  -- and RegisterPVMarkerID to make the PV online.  -- If entryState = online, "proc" may call SetPVOffline  -- before returning to make the PV offline.  -- If entryState = online but the PV root page and all of its SVs are offline,   -- PhysicalVolume.Error[physicalVolumeUnknown] is raised.  -- If entryState = offline but the PV is online, the debugger is called.  -- Regardless of entryState, if the PV root page is offline but some   -- of its SVs are online, the debugger is called. This situation  -- indicates a logic error in PhysicalVolume.AssertPilotVolume.  PVAccessProc: TYPE = PROCEDURE [    tok: PVToken, rootPageLoc: PhysicalVolume.PageNumber];  -- When PVAccessProc returns, if the PV is offline  -- but has any online SV's, the debugger is called (by PVAccess).  SVAccess: PROCEDURE [    pvID: PVID, lvID: LVID, lvPage: Volume.PageNumber, proc: SVAccessProc,    lock: SVLockType, entryState: SVEntryState ¬ online];  -- Acquires the requested lock on the SV, then calls proc.  -- lvPage can be any page of the SV.  -- If entryState = offline, "proc" typically calls SetSVOnline before  -- returning to make the SV online.  -- If entryState = online, "proc" may call SetSVOffline before  -- returning to make the SV offline.  -- If entryState = online but the SV is offline,  -- the debugger is called.  -- If entryState = offline but either (1) the SV is online  -- or (2) the containing pv is offline and no enclosing call  -- to PVAccess is in progress, the debugger is called.  SVAccessProc: TYPE = PROCEDURE [tok: SVToken];  -- Locking All Volumes:  TableAccess: PROCEDURE [proc: TableAccessProc];  -- Acquires exclusive access locks on every LV, PV, and SV  -- known to VolTable and calls proc. (The lock is actually granted  -- to the PROCESS calling TableAccess.) While proc is operating,  -- no other process will be granted a lock.  -- This operation creates a large bottleneck within the File System,  -- and should only be done in cases where the standard locking hierarchy  -- must be violated.  TableAccessProc: TYPE = PROCEDURE;  -- The PROCESS executing TableAccessProc get ANY LV, PV, or SV locks  -- in any order.  -- Special Operations:  --  -- These procedures are provided primarily for the Scavenger.  -- Normal VolTable clients should never have need of them.  ChangeSubVolume: PROCEDURE [    tok: SVToken, lvPage: Volume.PageNumber, pvPage: PVPage,    svLength: Volume.PageCount];  -- Changes the the LV Page, the PV Page and the SV length of a subvolume.  GetSVToken: PROCEDURE [token: LVToken, lvPage: Volume.PageNumber]    RETURNS [svTok: SVToken];  -- Returns a token for the specified SV.  -- The client MUST have the subvolume locked, either by the  -- LockEntireLV or LockTable operations.  -- If the SV is offline, the debugger is called.    GetVolumeIndex: PROCEDURE [lvID: LVID] RETURNS [volumeIndex: CARDINAL];  -- Returns a compacted unique runtime representation of the volume ID or  -- returns zero if LV is not found.  LockEntireLV: PROCEDURE [    lvID: LVID, proc: LVAccessProc, lock: LVLockType,    entryState: LVEntryState ¬ online];  -- Locks the LV and all of its SV's and calls proc.  -- EntryState has the same meaning as in LVAccess and applies only to the LV. The same error conditions also apply.  -- proc can determine the SV's present by enumeration. It can  -- acquire lock tokens for the SV's using GetSVToken.  END.LOG.Time:	11-Oct-82 11:58:09	By: JXP   Action:	Created file for Klamath.Time:	18-Oct-82 16:12:53	By: JXP   Action:	Added constant nullSVDesc, LockEntireLV[], GetSVToken[]. Removed the	bsChannel and markerPageLoc parameters from MapMarkerPage. Removed	the markerPageLoc parameter from the SVAccessProc TYPE. Added the	opaque type Context (moved from VolFileMap).Time:	10-Nov-82 17:13:12	By: JXP   Action:	Added GetID[]. Removed all ErrorTypes except unknownSV. Add change to	LockState enumerated. Add LVLockState, use this type as parm. to LVAccess.	Remove markerID from RegisterSV. Document Errors raised.Time:	30-Nov-82 10:01:02	By: JXP   Action:	Make the lock states and entry states more accurately reflect what is	wanted. Make GetStatus work without a lock on an entry of any state.	Update Comments. AddSet and Get- ClientData and ClientData TYPE.Time:	11-Dec-82 16:40:57	By: JXP   Action:	Add lvPage argument to RegisterSV. Add entryState argument to	LockEntireLV. Add comment about DeregistrLV. Make MapPVRootPage take a	token and no funny args. FindSV returns a BOOLEAN telling if it was found	or not. Remove Inc and Dec PieceCount. Added tok parms to UnmapPVRoot and	UnmapMarkerPage.Time:	11-Jan-83 13:48:04	By: JXP   Action:	Add RegisterPVMarkerID. Modify the LVEntryStates and the names of the	utility procedures. Change the Register/Deregister procedures to 	Online/Offline procs. Update comments.Time:	12-Jan-83 18:12:21	By: WDK     Action:	Improved documentation.Time:	24-Jan-83 10:12:02	By: WDK     Action:	Improved documentation. Changed Readability to RootPageReadability. Deleted ErrorTime:	22-Feb-83 11:03:37	By: WDK     Action:	Added LockState[maybeWrite], LVEntryState[offline]. Improved documentation of LockState. Readonly now raised less often.Time:	23-Feb-83  9:49:50	By: WDK     Action:	LVAccessProc now does not hide buffer. GetStatus renamed to GetLVStatus to solve export conflict in VolImpl.Time:	16-Jun-83 10:43:33	By: JXP   Action:	Context changes size.Time:	29-Jan-85 11:49:20	By: CJS    Action: Add SVDescPtr TYPE and make GetNextSV and FindSV use it, reduces size of return frame.Time:	12-Jun-86 11:48:54	By: CJSAction: Added GetLVHandle and GetLVID for ETable implementation. Context[72] ¬ [34].Time:    3-Jul-86 14:37:37      By: RSVAction: Added MapDuplicatePVRootPage and UnmapDuplicatePVRootPage procedures.Time:   18-Sep-86 13:29:08      By: RSVAction: Added GetVolumeIndex
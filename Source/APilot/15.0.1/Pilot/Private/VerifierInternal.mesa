-- Copyright (C) 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- VerifierInternal.mesa    30-Jun-88 11:04:35 by RSV  <<   This interface defines types and procedures that are used internally to the   implementation of the logical volume verifier. It exists only   because the verifier is too large to compile as a single module.>>DIRECTORY  DiskBackingStore USING [ChannelHandle],   DiskChannel USING [Handle, IOStatus],  Environment USING [PageNumber],  ETable,  File USING [File, ID, nullFile,PageCount, PageNumber, Type],  LogicalVolumeFormat USING [Handle],   PhysicalVolume USING [PageNumber],   PhysicalVolumeFormat USING [MarkerHandle],   Scavenger USING [Header],  Space USING [Interval],  VolTable USING [LVToken, SVDesc,  SVToken],  Volume USING [ID, PageCount, PageNumber];VerifierInternal: DEFINITIONS IMPORTS VolTable =  BEGIN  OPEN PVF: PhysicalVolumeFormat;  -- TYPES    SVInfo: TYPE = RECORD [    valid: BOOLEAN,    svTok: VolTable.SVToken,    svDesc: VolTable.SVDesc,    marker: PVF.MarkerHandle];  TryMode: TYPE = {normalRetry, tryRealHard};  -- normalRetry => use retry algorithms used in  normal operation  -- tryRealHard => go to extroidinary effort to perform the operation  PageInterval: TYPE = RECORD [firstMissing, nextPresent: File.PageNumber];  FileInfo: TYPE = RECORD [    file: File.ID, type: File.Type, volPage: Volume.PageNumber];  FileList: TYPE = RECORD [    maxFiles: CARDINAL,    -- maximum number of files that can be remembered in the file list    fileListOverflowed: BOOLEAN,    -- set to TRUE whenever an attempt to insert something in the file list fails    fileList: LONG DESCRIPTOR FOR ARRAY OF FileInfo];  -- List of files to be used to construct the log  FileProblem: TYPE = RECORD [file: File.ID, problem: File.PageNumber];  FreeMode: TYPE = {none, all, normal, pilotFiles, bootFiles};  -- normal => known temporary files, old VFM pages, generally pages that are  --  known not to be needed.  -- none => delete nothing.  -- pilotFiles => delete all expendable Pilot files.  -- bootFiles => delete all boot files on the volume; they've been added to  --   the temp file list  -- all => free all page groups as they are encountered.  LogInfo: TYPE = RECORD [    logHeader: Scavenger.Header,    -- Header to be placed in log file when we are done    logFile: File.ID,    -- ID of the log file that we are writing    logVolume: Volume.ID,    -- volume that the log file is being written to    canUseFileOps: BOOLEAN,    -- TRUE only if the log implementation can use File.* to do its thing,    -- otherwise it will use FileBasics facilities directly    firstLogPage: File.PageNumber,    -- page of log file that contains "root" of the scavenger log.    -- this is included to permit the log file to begin on other than page zero    -- of a file (e.g., to skip over space for a leader page).    logType: File.Type,    -- actual type of the log file    nextWord: CARDINAL,    -- Next word to be written on current page of log.    currentLogPage: File.PageNumber,    -- page number of the log file that is currently being written    logFilePages: File.PageCount,    -- length of the log    logDone: BOOLEAN,    -- TRUE when the entire log file has been constructed.  Note that if this is    -- TRUE, the log file may be incomplete (i.e., we ran out of space for it).    logBuffer: Space.Interval,    -- buffer to be used to build the log file in.    logPage: Environment.PageNumber];  -- = Space.PageFromLongPointer[logBuffer.pointer]    IOType: TYPE = {read, write};  Operation: TYPE = {erasing, makingFileList, scavenging};  PageGroupList: TYPE = LONG POINTER TO ARRAY [0..0) OF PageGroupInfo;  PageGroupInfo: TYPE = RECORD [    file: File.ID,    filePage: File.PageNumber,    volPage: Volume.PageNumber,    count: File.PageCount,    type: File.Type,    temporary: BOOLEAN];  -- TRUE only if filePage = 0 and file is temp.  ProblemInfo: TYPE = RECORD [    maxProblems: CARDINAL,    -- maximum number of problems that can be remembered    problemsMonitor: MONITORLOCK,    -- protects access to the following two fields.  This is needed since both    -- the mainline scavenger and the page gatherer modify these variables.    problemsOverFlowed: BOOLEAN,    -- TRUE if and only if there some problems do not appear in the ProblemList    problems: LONG DESCRIPTOR FOR ARRAY OF FileProblem];  -- List of problems encountered on this volume    -- VARIABLES    badPageListSize: Volume.PageCount;  localScavengerLogFileExists:  BOOLEAN;  minimalScavenge: BOOLEAN;  skipClientPageCorrections: BOOLEAN;  numberOfBadPages:  CARDINAL;  badPageList: LONG POINTER TO ARRAY [0..0) OF Volume.PageNumber;   badDataPageListSize: Volume.PageCount;  numberOfBadDataPages: CARDINAL;  badDataPageList: LONG POINTER TO ARRAY [0..0) OF BadDataPageEntry;   BadDataPageEntry: TYPE = RECORD [    page: Volume.PageNumber,    processed: BOOLEAN];    BucketOverflowInfo: TYPE = RECORD [     oldCount: CARDINAL, newCount: CARDINAL];  bucketOverflowList: LONG POINTER TO ARRAY [0..0) OF BucketOverflowInfo;  numberOfFilesInFileList: CARDINAL;  firstPVPageOfLV: PhysicalVolume.PageNumber;  lastPVPageOfLV: PhysicalVolume.PageNumber;  diskChannel: DiskChannel.Handle;  maximumNumberOfErrorsInErrorList: CARDINAL;  errorListSize:  Volume.PageCount;  numberOfErrorsInErrorList: CARDINAL;  ETableErrorType: TYPE = {none, badClientPage, badClientData,  badHeaderPage,     badFirstPageOfPrimaryETFET, badETFETPrimaryPage, badFirstPageOfCopyETFET,      badETFETCopyPage, badFirstPageOfPreimageLog, badPreimagePage,     badBucketPage, badBucketData, badLogPage, badFirstPageOfOverflow,     badOverflowPage, badPilotData, badPilotPage, badETableInBucket};  ErrorListInfo: TYPE = RECORD [file: File.ID, which: ETable.WhichETableFile,      problem: ETableErrorType, filePage: File.PageNumber];  errorList: LONG POINTER TO ARRAY [0..0) OF ErrorListInfo;  errorListOverflowed:  BOOLEAN;    largestAllocatedFileID:  LONG CARDINAL;    numberOfFiles: LONG CARDINAL;    -- PROCEDURES  <<     ANY DOCUMENTATION ON THE OPERATION OF A PROCEDURE IS FOUND     AT THE HEAD OF THE PROCEDURE IMPLEMENTATION.  >>    AddToErrorList: PROCEDURE [     file: File.ID, which: ETable.WhichETableFile,      problem: ETableErrorType,      filePage: File.PageNumber];       AddFileToFileList: PROCEDURE [fileID: File.ID]     RETURNS [BOOLEAN];       ClearDataLostPageList: PROCEDURE [volume: Volume.ID];    CompactFilesInOverflow: PROCEDURE [     lvbi: LONG POINTER TO ETable.LVBucketInfo,      lvHandle: LogicalVolumeFormat.Handle,      token: VolTable.LVToken];       CompactOverflow: PROCEDURE [      lvbi: LONG POINTER TO ETable.LVBucketInfo, firstFree: LONG CARDINAL];    CreateBadDataPageList: PROCEDURE [     tok: VolTable.LVToken, volume: Volume.ID];       CreateBadPageList: PROCEDURE [     tok: VolTable.LVToken, volume: Volume.ID];       DoIOForOneRun: PROCEDURE [    memBuffer: LONG POINTER, volumePage: Volume.PageNumber,     diskChannel: DiskChannel.Handle, firstPVPageOfLV: PhysicalVolume.PageNumber,     countRequested: CARDINAL, io: IOType]    RETURNS [upDatedBuffer: LONG POINTER, dataError: BOOLEAN ¬ FALSE];      FastVerify: PROCEDURE [lvbi: ETable.LVBucketInfo];    GatherRunsAndDoIO: PROCEDURE [    eTable: ETable.ETableHandle, memBuffer: LONG POINTER,     bucketPage: File.PageNumber, countLeft: CARDINAL, io: IOType]     RETURNS [dataError: BOOLEAN ¬ FALSE];   GetDiskIOInfo: PROCEDURE [    volume: Volume.ID, firstPage: Volume.PageNumber, count: Volume.PageCount]    RETURNS [      channel: DiskBackingStore.ChannelHandle,      diskPage: PhysicalVolume.PageNumber, countValid: Volume.PageCount,      pvPageNumberOfLVRootPage: PhysicalVolume.PageNumber,       lvPageNumberOfLVRootPage: Volume.PageNumber];  IsPageBad: PROCEDURE [firstPage: LONG POINTER TO Volume.PageNumber,      count: LONG POINTER TO Volume.PageCount] RETURNS [BOOLEAN];       IsDataOnPageBad: PROCEDURE [firstPage: LONG POINTER TO Volume.PageNumber,      count: LONG POINTER TO Volume.PageCount] RETURNS [BOOLEAN];       MapMarkerPage: PROCEDURE [volume: Volume.ID, tok: VolTable.LVToken]     RETURNS [svTok: VolTable.SVToken, markerSpace: Space.Interval];       MarkVAMPagesAsBusy: PROCEDURE [     lvHandle: LogicalVolumeFormat.Handle, lvToken: VolTable.LVToken,      volumePage: LONG POINTER TO Volume.PageNumber,      count: LONG POINTER TO LONG CARDINAL]  RETURNS[busyPage: BOOLEAN];    MinimalReadAndCorrect: PROCEDURE [    pageCount: CARDINAL, filePage: File.PageNumber,     copyETFET, primaryETFET: ETable.ETableHandle,     problem: ETableErrorType, memBuffer: LONG POINTER]     RETURNS [    countToWrite: CARDINAL ¬ 0, firstOneToWrite: CARDINAL,    dataLost: BOOLEAN ¬ FALSE, copyUsed: BOOLEAN ¬ TRUE];       ProduceScavengerLog: PROCEDURE  [     lvHandle: LogicalVolumeFormat.Handle,      lvToken: VolTable.LVToken,      globalForLogFile: File.File,      lvbi: ETable.LVBucketInfo]  RETURNS[File.File];       ReadPage: PROCEDURE [volumePage: Volume.PageNumber,      memPage: Environment.PageNumber, diskChannel: DiskChannel.Handle,     firstPVPageOfLV: PhysicalVolume.PageNumber]  RETURNS [status: disk DiskChannel.IOStatus];    ReadParallelAndCorrect: PROCEDURE [     memPage: Environment.PageNumber, pageCount: LONG CARDINAL,     primaryFilePage:File.PageNumber,      primaryETFET: ETable.ETableHandle,      copyFilePage: File.PageNumber,      copyETFET: ETable.ETableHandle,      problem: ETableErrorType]     RETURNS[dataLost: BOOLEAN];       UnmapMarkerPage: PROCEDURE [     svTok: VolTable.SVToken, markerSpace: Space.Interval];       ValidateETable: PROCEDURE [     lvHandle: LogicalVolumeFormat.Handle, lvToken: VolTable.LVToken,     currentETable: ETable.ETableHandle]     RETURNS[BOOLEAN];         WriteOutPageRun: PROCEDURE [    count: CARDINAL, filePageNumber: File.PageNumber, eTable: ETable.ETableHandle,    memPageNumber: Environment.PageNumber];    WritePage: PROCEDURE [volumePage: Volume.PageNumber,        memPage: Environment.PageNumber, diskChannel: DiskChannel.Handle,       firstPVPageOfLV: PhysicalVolume.PageNumber]    RETURNS [status:disk DiskChannel.IOStatus];      ValidPage: PROCEDURE [    problem: ETableErrorType, currentMemPage: Environment.PageNumber]     RETURNS [BOOLEAN];       ValidateAndRepairRootDirectory: PROCEDURE [    lvbi: LONG POINTER TO ETable.LVBucketInfo, vol: LogicalVolumeFormat.Handle,    token: VolTable.LVToken];  VamInit: PROCEDURE [      vol: LogicalVolumeFormat.Handle,       badPages: LONG DESCRIPTOR FOR ARRAY OF Volume.PageNumber,       lvToken: VolTable.LVToken];       VerifyAndCorrectLVRootAndMarkerPages: PROCEDURE [tok: VolTable.LVToken,      lvBucketInfo: LONG POINTER TO ETable.LVBucketInfo, volume: Volume.ID];       VerifierWithLock: PROCEDURE [    tok: VolTable.LVToken, lvHandle: LogicalVolumeFormat.Handle,     volume: Volume.ID, checkOnly: BOOLEAN,    optionalLogFile: File.File ¬ File.nullFile]  RETURNS[logFile: File.File];  END.LOG29-Sep-86 16:46:16  RRR  Created file.12-Mar-87 10:55:59  RRR  No more PV marker pages.19-Mar-87 19:38:04  RRR  More changes.29-Sep-87 12:34:38  RSV  Added ValidateAndRepairRootDirectory.18-Nov-87  7:22:56  ET   Added ValidPage, IOType, DoIOForOneRun, GatherRunsAndDoIO, MinimalReadAndCorrect, FastVerify. 9-Dec-87 20:38:40  ET   Added badPilotData and badPilotPage to ETableErrorType. 9-Jan-88 15:44:44  ET	 Added badETableInBucket to ETableErrorType. Added BadDataPageEntry.12-Jan-88  0:08:48  ET   Added MapMarkerPage, UnmapMarkerPage.30-Jun-88 11:04:31  RSV  LONG POINTER's are now RETURNed values.  ReadParallelAndCorrect now only returns dataLost, not copyUsed.
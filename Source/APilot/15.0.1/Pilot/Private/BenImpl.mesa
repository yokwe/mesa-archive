-- Copyright (C) 1984, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- BenImpl.mesa,  Last edited on 25-Jan-88 15:06:51 by RSV-- This program monitors page faults as they happen.  A Ben.Event is written into a pinned buffer describing each page fault by the PageFaultRecorder procedure.  These data are then spooled to the disk by the Spooler process.-- This program creates a sizeable file and a vm buffer of corresponding size.  The size of the file (and the space) may be set from the debugger (the size is nBuffers*bufferPages pages).  In any case, they will be trimmed as necessary to fit the available space on the system volume.-- Log file format:  The log file is a sequence of Ben.Event's.  The first of the sequence does not actually describe a page fault, but is a dummy Event whose first word contains the version number of the format of Event.  The file is padded with zeros following the last valid Event.-- Process interaction:  The processes spawned by this program run asynchronously, the Spooler at priorityForeground.  The data of the module is NOT covered by the module monitor lock.  Each process may have its own token monitor lock just so it can use the Mesa construct WAIT.  The processes synchronize with each other by having a set of shared variables, each of which is only written by one process.  That is, there are one-way communication streams between the processes.  Simultaneous access conflicts are resolved by the fact that one-word memory fetches and stores are atomic.  If a multiword variable is used in one of these shared communication paths, it may only be accessed (by the lower priority Spooler) when interrupts are disabled.-- The PageFaultRecorder is a VMPerf.TransferWatcher.  It is called by Pilot for each I/O.-- RESTRICTIONS:  Guesses frame to use if transData.process = self.  Only recognizes disk backing store because it's the only TransferProc exported by Pilot.DIRECTORY  BenDefs: TYPE USING [Event, Header, versionID],  DiskBackingStore: TYPE USING [ChannelHandle, Data],  DiskBackingStoreImpl: TYPE,  DiskChannel: TYPE,  Environment: TYPE,  File: TYPE USING [    Create, Delete, File, MakePermanent, nullID, PageCount, PageNumber, SetSize,    Unknown],  Frame: TYPE USING [GetReturnFrame, ReadPC],  FrameExtras: TYPE USING [GFTHandleToLongGF, ReadGlobalLink],  Inline: TYPE USING [LongCOPY, LongMult],  PerformanceToolFileTypes: TYPE USING [tBen],  PhysicalVolume: TYPE,  PrincOps: TYPE,  Process: TYPE USING [    Detach, Priority, priorityForeground, priorityNormal, SetPriority],  ProcessOperations: TYPE USING [HandleFromProcess, ProcessFromHandle, ReadPSB],  PSB: TYPE USING [PDA, PDABase, ProcessStateBlock, PsbIndex, PsbNull],  ResidentHeap: TYPE,  Runtime: TYPE USING [CallDebugger, ControlLink, GlobalFrame],  Space: TYPE,  SpecialFile: TYPE USING [Transfer],  SpecialSpace: TYPE USING [    MakeGlobalFrameResident, MakeProcedureResident, MakeEntryVectorResident,    SpecialError, SpecialErrorType],  SpecialVolume: TYPE,  System: TYPE USING [GetClockPulses, nullID, VolumeID],  VM: TYPE USING [Deactivate, Interval, MakeResident, MakeSwappable, PageCount,    ReturnWait],  VMPerf: TYPE USING [InstallTransferWatcher, TransferWatcher],  VolBackingStore: TYPE USING [Data, Transfer],  Volume: TYPE,  Zone: TYPE;BenImpl: MONITOR  IMPORTS    antiAlias: DiskBackingStoreImpl, DiskChannel, Environment, File, Frame,    Inline, PhysicalVolume, Process, ProcessOperations, ResidentHeap, Runtime,    Space, SpecialFile, SpecialSpace, SpecialVolume, System, VolBackingStore,    Volume, VM, VMPerf, FrameExtras  SHARES DiskBackingStoreImpl =  BEGIN  -- Data types and constants for the log analysis routines:  versionID: CARDINAL = BenDefs.versionID;  Event: TYPE = BenDefs.Event;    -- Private types and data:  Mode: TYPE = MACHINE DEPENDENT{  -- Tracing modes are NOT IMPLEMENTED.    all,  -- trace all page faults.    process,  -- trace page faults only from specified process.    priority,  -- trace page faults only from processes running at specified priority.    other};  -- not used at present.  -- parameters:  nBuffers: CARDINAL ¬ 10; -- may be trimmed by InitTrace to fit volume available space.  bufferPages: CARDINAL ¬ 20; -- (two buffers are pinned at one time).  -- process control variables not covered by any monitor lock(!):  buffersReadyForFilling: CARDINAL ¬ 0;  -- written by Spooler.  buffersFilled: CARDINAL ¬ 0;  buffersEmptied: CARDINAL ¬ 0;  -- written by Spooler.  bufferFull: CONDITION;  recorderState: {running, done} ¬ done;  -- has the PageFaultRecorder finished?  pleaseQuit: BOOLEAN ¬ FALSE;  -- written by StopTracing.  -- This is the ONLY data covered by the module monitor lock:  spoolerState: {running, done} ¬ done;  -- has the Spooler finished?  spoolerReady: CONDITION;  -- notified when the Spooler has initialized.  outputComplete: CONDITION;  -- notified when the Spooler finishes.  tracingBen: BOOLEAN ¬ FALSE; --   -- Misc variables:  logFile: File.File;  logSpace: Space.Interval;  spooler: PROCESS;  prioritySpooler: Process.Priority ¬ Process.priorityForeground;  -- must be some normal client priority.  StartTracing: PUBLIC --EXTERNAL-- PROC = {    -- Typically called from debugger.    IF spoolerState = done THEN      {InitTrace[all, PSB.PsbNull, Process.priorityNormal]};    tracingBen ¬ TRUE};  StopTracing: PUBLIC ENTRY PROC RETURNS [logFileLength: Environment.PageCount] = {    -- Typically called from debugger.    pleaseQuit ¬ TRUE;    tracingBen ¬ FALSE;    NOTIFY bufferFull;    UNTIL spoolerState = done DO WAIT outputComplete ENDLOOP;    RETURN[MAX[1, Inline.LongMult[buffersEmptied, bufferPages]]]};  DeleteLogFile: PUBLIC PROC = {    {Enter: ENTRY PROC = INLINE {ENABLE UNWIND => NULL;      UNTIL spoolerState = done DO WAIT outputComplete ENDLOOP};    Enter[]};    {ENABLE Volume.RootDirectoryError => CONTINUE;    file: File.File = Volume.LookUpRootFile[PerformanceToolFileTypes.tBen];    Volume.RemoveRootFile[PerformanceToolFileTypes.tBen];    file.Delete[ ! File.Unknown => CONTINUE]}};  pEventWriter, pEventMax, pEndBuffer, pCheckNextBuffer:    LONG ORDERED POINTER TO Event;    InitTrace: PROC [      mode: Mode, psbToTrace: PSB.PsbIndex, priorityToTrace: Process.Priority] = {    TraceMonitor: ENTRY PROC = {      -- get data set for worker processes:      buffersFilled ¬ buffersEmptied ¬ buffersReadyForFilling ¬ 0;      recorderState ¬ running;  -- set here because Spooler looks at it.      pleaseQuit ¬ FALSE;      Process.Detach[spooler ¬ FORK Spooler[]];      UNTIL spoolerState = running DO WAIT spoolerReady ENDLOOP;      pEventWriter ¬ LOOPHOLE[logSpace.pointer];      pEventMax ¬ pEventWriter + Inline.LongMult[        bufferPages, nBuffers]*Environment.wordsPerPage - (Event.SIZE - 1);      pEndBuffer ¬ pEventWriter + bufferPages*Environment.wordsPerPage;      pCheckNextBuffer ¬ pEndBuffer - (Event.SIZE - 1);      -- write file format version number as first entry:      pEventWriter­ ¬ LOOPHOLE[BenDefs.Header[        version: versionID, time: System.GetClockPulses[], filler: ALL[0]]];      pEventWriter ¬ pEventWriter + Event.SIZE     --tracingBen ¬ TRUE    };  -- end TraceMonitor    -- Only mode=all is implemented.  psbToTrace and priorityToTrace are ignored.    logFile ¬ Volume.LookUpRootFile[      PerformanceToolFileTypes.tBen !      Volume.RootDirectoryError =>        IF type = rootFileUnknown THEN {          logFile ¬ File.Create[            volume: Volume.systemID, initialSize: 1,            type: PerformanceToolFileTypes.tBen];          Volume.InsertRootFile[PerformanceToolFileTypes.tBen, logFile];          File.MakePermanent[logFile];          CONTINUE}        ELSE REJECT];    logFile.SetSize[1];  -- Want a file full of zeroes!    logFile.SetSize[      Inline.LongMult[bufferPages, nBuffers] !      Volume.InsufficientSpace =>        IF nBuffers > 1 THEN {nBuffers ¬ nBuffers.PRED; RETRY} ELSE REJECT];    logSpace ¬ Space.Map[      window: [logFile, 0, Inline.LongMult[bufferPages, nBuffers]], life: dead,      swapUnits: [uniform[bufferPages]]];    logSpace.pointer­ ¬ 0;    Inline.LongCOPY[      from: logSpace.pointer, to: logSpace.pointer + 1,      nwords: Environment.wordsPerPage - 1];        TraceMonitor};  -- end InitTrace.     pvMap: LONG POINTER TO PVMap ¬ NIL;  PVMap: TYPE = RECORD [body: SEQUENCE length: NAT OF PVItem];  PVItem: TYPE = RECORD [    channel: DiskBackingStore.ChannelHandle, svMap: LONG POINTER TO SVMap];  SVMap: TYPE = RECORD [body: SEQUENCE length: NAT OF SVItem];  SVItem: TYPE = RECORD [    first, last: PhysicalVolume.PageNumber, id: System.VolumeID];    InitPVMap: PROC = {    PVList: TYPE = LONG POINTER TO PVRecord;    PVRecord: TYPE = RECORD [      handle: DiskBackingStore.ChannelHandle, next: PVList, lv: LVList ¬ NIL,      lvCount: NAT ¬ 0];    LVList: TYPE = LONG POINTER TO LVRecord;    LVRecord: TYPE = RECORD [      id: Volume.ID, next: LVList, start: PhysicalVolume.PageNumber,      count: Volume.PageCount];    Storage: TYPE = RECORD [      link: LONG POINTER TO Storage,      data: SEQUENCE COMPUTED CARDINAL OF WORD];    Alloc: PROC [      z: UNCOUNTED ZONE, nwords: CARDINAL] RETURNS [p: LONG POINTER] = {      IF nwords > wordsLeft THEN {        pagesToAlloc: CARDINAL = MAX[	  1, (nwords + Environment.wordsPerPage - 1)/Environment.wordsPerPage];        newStorage: LONG POINTER TO Storage = Space.ScratchMap[pagesToAlloc];	newStorage.link ¬ storage;	storage ¬ newStorage;	top ¬ storage + SIZE[LONG POINTER];	wordsLeft ¬ pagesToAlloc*Environment.wordsPerPage - SIZE[LONG POINTER]};      p ¬ top;      top ¬ top + nwords;      wordsLeft ¬ wordsLeft - nwords};    DeleteZone: PROC = {      next: LONG POINTER;      DO        next ¬ storage.link;        [] ¬ Space.Unmap[storage];	IF next = NIL THEN RETURN;	storage ¬ next;	ENDLOOP};    AllocFromResidentHeap: PROC [      z: UNCOUNTED ZONE, nwords: CARDINAL] RETURNS [LONG POINTER] = {      status: Zone.Status;      rp: Environment.Base RELATIVE POINTER TO UNSPECIFIED;      [rp, status] ¬ ResidentHeap.MakeNode[nwords];      IF status # okay THEN ERROR;      RETURN[@Environment.first64K[rp]]};    alloc: PROC [UNCOUNTED ZONE, CARDINAL] RETURNS [LONG POINTER] ¬ Alloc;    palloc: LONG POINTER ¬ @alloc;    z: UNCOUNTED ZONE = LOOPHOLE[LONG[@palloc]];    rhAlloc: PROC [      UNCOUNTED ZONE, CARDINAL] RETURNS [LONG POINTER] ¬ AllocFromResidentHeap;    prhAlloc: LONG POINTER ¬ @rhAlloc;    residentHeap: UNCOUNTED ZONE = LOOPHOLE[LONG[@prhAlloc]];    storage: LONG POINTER TO Storage ¬ Space.ScratchMap[1];    wordsLeft: CARDINAL ¬ Environment.wordsPerPage - SIZE[LONG POINTER];    top: LONG POINTER ¬ storage + SIZE[LONG POINTER];    pvCount: NAT ¬ 0;    pvList: PVList ¬ NIL;    storage.link ¬ NIL;    -- the following is commented out due to a compiler bug AR    «{dbs: LONG POINTER TO FRAME[DiskBackingStoreImpl] = LOOPHOLE[      SpecialRuntimeExtras.GlobalFrameFromProgram[DiskBackingStoreImpl]];»    {dbs: LONG POINTER TO FRAME[DiskBackingStoreImpl] = LOOPHOLE[      Runtime.GlobalFrame[LOOPHOLE[SpecialFile.Transfer, Runtime.ControlLink]]];    FOR pvID: PhysicalVolume.ID ¬ PhysicalVolume.GetNext[PhysicalVolume.nullID],      PhysicalVolume.GetNext[pvID] UNTIL pvID = PhysicalVolume.nullID DO      index: CARDINAL = PhysicalVolume.InterpretHandle[	PhysicalVolume.GetAttributes[pvID].instance].index;      handle: DiskBackingStore.ChannelHandle;      FOR handle IN dbs.HandleArrayIndex DO	diskChannel: DiskChannel.Handle = dbs.handleArray[handle];	IF diskChannel = DiskChannel.nullHandle THEN LOOP;	IF DiskChannel.GetDriveAttributes[	  DiskChannel.GetDrive[diskChannel]].deviceOrdinal = index THEN EXIT;	REPEAT FINISHED => FOR hl: dbs.PChanRec ¬ dbs.handleList, hl.next	  UNTIL hl = NIL DO	  IF hl.diskChannel # DiskChannel.nullHandle AND	    DiskChannel.GetDriveAttributes[	      DiskChannel.GetDrive[hl.diskChannel]].deviceOrdinal = index	    THEN EXIT;	  REPEAT FINISHED => {CantFindHandle: ERROR = CODE; ERROR CantFindHandle};	  ENDLOOP;	ENDLOOP;      pvList ¬ z.NEW[PVRecord ¬ [handle: handle, next: pvList]];      pvCount ¬ pvCount.SUCC;      FOR sv: SpecialVolume.SubVolume ¬ 	SpecialVolume.GetNextSubVolume[pvID, SpecialVolume.nullSubVolume],	SpecialVolume.GetNextSubVolume[pvID, sv] 	UNTIL sv = SpecialVolume.nullSubVolume DO	pvList.lv ¬ z.NEW[LVRecord ¬ [	  sv.lvID, pvList.lv, sv.firstPVPageNumber, sv.subVolumeSize]];	pvList.lvCount ¬ pvList.lvCount.SUCC;	ENDLOOP;      ENDLOOP};    {pv: PVList ¬ pvList;    pvMap ¬ residentHeap.NEW[PVMap[pvCount]];    FOR pvi: NAT IN [0..pvMap.length) DO      lv: LVList ¬ pv.lv;      pvMap[pvi] ¬ [pv.handle, residentHeap.NEW[SVMap[pv.lvCount]]];      FOR svi: NAT IN [0..pvMap[pvi].svMap.length) DO        pvMap[pvi].svMap[svi] ¬ [	  first: lv.start, last: lv.start + lv.count - 1, id: lv.id];	lv ¬ lv.next;	ENDLOOP;      pv ¬ pv.next;      ENDLOOP};    DeleteZone[]};    PageFaultRecorder: ENTRY VMPerf.TransferWatcher = {    MyProcess: PROC RETURNS [PROCESS] = INLINE {      RETURN[ProcessOperations.ProcessFromHandle[ProcessOperations.ReadPSB[]]]};    FindVolume: PROC [      channel: DiskBackingStore.ChannelHandle, page: PhysicalVolume.PageNumber]      RETURNS [System.VolumeID] = {      FOR pvi: CARDINAL IN [0..pvMap.length) DO        IF pvMap[pvi].channel = channel THEN {          OPEN svMap: pvMap[pvi].svMap;	  FOR svi: CARDINAL IN [0..svMap.length) DO	    OPEN item: svMap[svi];	    IF page IN [item.first..item.last] THEN RETURN[item.id];	    REPEAT FINISHED => RETURN[[System.nullID]];	    ENDLOOP};	REPEAT FINISHED => RETURN[[System.nullID]];	ENDLOOP};   	    IF tracingBen = FALSE OR pleaseQuit OR pEventWriter >= pEventMax THEN RETURN;    IF pEventWriter >= pCheckNextBuffer      AND buffersReadyForFilling ~> buffersFilled      AND buffersReadyForFilling < nBuffers THEN      Runtime.CallDebugger["Can't keep up with transfers"L];    IF transData.process = spooler THEN RETURN; -- don't log spooler I/O        -- Log the event    pEventWriter.page ¬ transData.pageData + transData.offsetFromData;    {frame: PrincOps.LocalFrameHandle;    IF transData.process = MyProcess[] THEN frame ¬ Frame.GetReturnFrame[]    ELSE {      psb: LONG POINTER TO PSB.ProcessStateBlock =        @PSB.PDA[ProcessOperations.HandleFromProcess[transData.process]];      frame ¬ IF psb.link.preempted OR psb.link.permanent        THEN PSB.PDA[psb.context.state].frame        ELSE psb.context.frame};    pEventWriter.gf ¬      FrameExtras.GFTHandleToLongGF[FrameExtras.ReadGlobalLink[frame]];    pEventWriter.pc ¬ Frame.ReadPC[frame]};    SELECT transferProc FROM      SpecialFile.Transfer => { -- normal disk I/O --         -- This is the same as DiskBackingStore.TransferProc        data: LONG POINTER TO DiskBackingStore.Data = LOOPHOLE[@transData.data];	pEventWriter.backingStore ¬ file;	pEventWriter.body ¬ file[	  f: [	    fileID: File.nullID, --data.file	    volumeID: FindVolume[data.channelHandle, data.volumePage]],	  type: data.type]};      VolBackingStore.Transfer => { -- vol root page --         -- This arm is not particularly useful right now since this item isn't exported from Pilot.        data: LONG POINTER TO VolBackingStore.Data = LOOPHOLE[@transData.data];	pEventWriter.backingStore ¬ volRoot;	pEventWriter.body ¬ volRoot[	  type: data.type, id: data.id, pvPage: data.pvPage]};      ENDCASE => { -- unknown event --        pEventWriter.backingStore ¬ unknown;	pEventWriter.body ¬ unknown[data: transData.data]};    pEventWriter.time ¬ System.GetClockPulses[];    pEventWriter ¬ pEventWriter + Event.SIZE;    IF pEventWriter >= pEventMax THEN GOTO done;    IF pEventWriter >= pEndBuffer THEN {      buffersFilled ¬ buffersFilled.SUCC;      NOTIFY bufferFull;       pEndBuffer ¬ pEndBuffer + bufferPages*Environment.wordsPerPage;      pCheckNextBuffer ¬	pCheckNextBuffer + bufferPages*Environment.wordsPerPage};	      EXITS done => {      buffersFilled ¬ buffersFilled.SUCC;      NOTIFY bufferFull;      recorderState ¬ done}};  -- end PageFaultRecorder.         Spooler: PROC = {    -- Must run at some ordinary client priority!    -- note that one buffer is always pinned ahead of where Recorder is writing (two ahead of where we are reading).    readerBuffer: Space.Interval ¬ [      pointer: logSpace.pointer, count: bufferPages];    readerPage: Environment.PageNumber ¬       Environment.PageFromLongPointer[readerBuffer.pointer];    VM.MakeResident[[readerPage, readerBuffer.count], wait];    buffersReadyForFilling ¬ 1;    PrepareSucessorBuffer[readerPage];  -- (tallies buffersReadyForFilling)    spoolerState ¬ running;    {Enter1: ENTRY PROC = INLINE {NOTIFY spoolerReady}; Enter1};    Process.SetPriority[prioritySpooler];    DO  --REPEAT ... UNTIL recorderState=done--      {Enter2: ENTRY PROC = INLINE {        ENABLE UNWIND => NULL;	UNTIL pleaseQuit OR buffersFilled > buffersEmptied DO	  WAIT bufferFull ENDLOOP};      Enter2};            IF pleaseQuit AND buffersFilled = buffersEmptied THEN EXIT;             -- get the filled buffer writing out..      VM.MakeSwappable[[readerPage, readerBuffer.count]];      VM.Deactivate[[readerPage, readerBuffer.count], wait];  -- output and reclaim the memory.      buffersEmptied ¬ buffersEmptied.SUCC;      readerBuffer.pointer ¬ Environment.LongPointerFromPage[        readerPage ¬ readerPage + readerBuffer.count];	      IF recorderState = done AND buffersFilled = buffersEmptied THEN EXIT;      -- pin the buffer ahead of where the writer is now:      PrepareSucessorBuffer[readerPage];  -- (tallies buffersReadyForFilling)      ENDLOOP;    IF readerBuffer ~= Space.nullInterval THEN      VM.MakeSwappable[[readerPage, readerBuffer.count]];    [] ¬ Space.Unmap[logSpace.pointer];    logFile.SetSize[MAX[1, Inline.LongMult[buffersEmptied, bufferPages]]];          -- truncate any excess.  Pilot will not take size of 0 in FileImpl.    spoolerState ¬ done;    {Enter3: ENTRY PROC = INLINE {NOTIFY outputComplete}; Enter3}}; --end Spooler.  PrepareSucessorBuffer: PROC [currentBuffer: Environment.PageNumber] = {    -- increments buffersReadyForFilling as a side effect.    nextBufferToPin: Environment.PageNumber ¬ currentBuffer + bufferPages;    IF nextBufferToPin >= Inline.LongMult[bufferPages, nBuffers] + Environment.PageFromLongPointer[logSpace.pointer] THEN RETURN    ELSE {      pointer: LONG POINTER TO CARDINAL =        Environment.LongPointerFromPage[nextBufferToPin];      VM.MakeResident[[nextBufferToPin, bufferPages], wait];      pointer­ ¬ 0;      Inline.LongCOPY[        from: pointer, to: pointer + 1,	nwords: bufferPages*Environment.wordsPerPage - 1];      buffersReadyForFilling ¬ buffersReadyForFilling.SUCC}}; -- end P..S..B..  InitPVMap[];  SpecialSpace.MakeGlobalFrameResident[    BenImpl !      SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE ELSE REJECT];	  SpecialSpace.MakeProcedureResident[LOOPHOLE[    PageFaultRecorder] !      SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE ELSE REJECT];	  SpecialSpace.MakeEntryVectorResident[LOOPHOLE[    PageFaultRecorder] !      SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE ELSE REJECT];    [] ¬ VMPerf.InstallTransferWatcher[PageFaultRecorder];    END.LOG9-Jul-81  9:38:03   WDK       Made dynamically loadable: no longer intimately bound with PilotKernel.  Merged Ben.mesa, BenImpl.mesa and Ben's version of PageFaultImpl.  Major rework of process interaction and spooling: now monitors during spooling.  Documented the source.  Added DeleteLogFile[].  28-Aug-81 13:55:14   XXM       Set back to normal priority before PageFaultRecorder process disappears to allow faulting on Processes.End.  Added twiddle that causes the cursor to be inverted every time a page fault occurs.September 9, 1981  3:56 PM   WDK       Must only unpin stuff that was not previously resident.  Comment out cursor twiddling since some systems do not have display.  Work around the bug that Rubicon MakeResident does not report back the previously pinned status (AR 9025).    5-Jan-82 19:21:48   AXD       Convert to Trinity.   25-Jan-82 16:09:28   AXD       Use BenDefs.    9-Dec-83 17:46:31   AXD       Convert to 11.0.  Make PageFaultWatcher a VMPerf.TransferWatcher. 11-Jan-84 12:19:18   AXD       Implement FindVolume.  17-Feb-84 19:00:16   DXG    25-Dec-86 23:15:04   RSV   Had to always say file.fileID = File.nullID since format of BackingStore changed.   29-Jan-87 20:48:32	ET	Merged in mds relief changes.  25-Jan-88 15:06:51   RSV   Fix assigning dbs in InitPVMap for AR 12659 due to compiler bug.
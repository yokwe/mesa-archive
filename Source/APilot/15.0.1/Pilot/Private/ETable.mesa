-- Copyright (C) 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- ETable.mesa     21-Jun-88 13:28:58 by RSV  DIRECTORY  Environment USING [Base, wordsPerPage],  File USING [ID, PageCount, PageNumber, Type],  KernelFile USING [PageGroup],  LogicalVolumeFormat USING [Handle],  VM USING [Interval],  VolTable USING [LVToken],  Volume USING [ID, PageCount, PageNumber];ETable: DEFINITIONS =  BEGIN    -- The ETable files (primary and copy) are exact duplicates of each other.  -- Each has the following format:  --    Header (currently 1 page)  --    Preimage log (currently 7 pages)  --    ETable for the primary ETF (currently 3 pages)  --    ETable for the copy ETF (currently 3 pages)  --    Hash buckets (number is a function of the volume size and is in header)  --    Overflow (1 to n, depending upon the hash)     -- ETableFile structure    fileSystemSeal: CARDINAL = 62626B;  fileSystemVersion: CARDINAL = 1;    ItemLogged: TYPE = {eTFET, overflowBucket, nothingLogged};    -- The following is the format of the first page (the header) of every ETable  -- file.  Both the primary and the copy ETable files have exactly the same  -- header.    FileHeader: TYPE = MACHINE DEPENDENT RECORD [    seal(0): CARDINAL,    version(1): CARDINAL,    lv(2): Volume.ID,    numberOfBuckets(7): CARDINAL,    numberOfBucketsToAdd(8): CARDINAL,    maxETableSize(9): CARDINAL,    overflowSize(10): File.PageCount,    preImageSize(12): File.PageCount,    numberOfPagesLogged(14): CARDINAL,    itemLogged(15): ItemLogged,     firstFilePageLogged(16): File.PageNumber,        -- The following record contains this information about the primary ETF.      -- All the volume pages refer to pages within the primary ETF:    --    myFirstETablePage: The volume page of the primary ETFET.    --    otherFirstETablePage: The volume page of the copy ETFET.    --    firstOverflowPage: The volume page of the first overflow page.    --    firstPreImagePage: The volume page of the first preimage page.        primaryETFHeader(18): SingleHeaderDescriptor,        -- The following record contains this information about the copy ETF.      -- All the volume pages refer to pages within the copy ETF:    --    myFirstETablePage: The volume page of the copy ETFET.    --    otherFirstETablePage: The volume page of the primary ETFET.    --    firstOverflowPage: The volume page of the first overflow page.    --    firstPreImagePage: The volume page of the first preimage page.        copyETFHeader(87): SingleHeaderDescriptor,    unused(156): ARRAY [0..Environment.wordsPerPage - 156) OF CARDINAL ¬ ALL[0]];      SingleHeaderDescriptor:  TYPE = MACHINE DEPENDENT RECORD [    myFirstETablePage(0): Volume.PageNumber,     otherFirstETablePage(2): Volume.PageNumber,    firstOverflowPage(4): Volume.PageNumber,     firstPreImagePage(6): Volume.PageNumber,     unused(8): ARRAY [0..61) OF CARDINAL ¬ ALL[0]];       FileHeaderHandle: TYPE = LONG POINTER TO FileHeader;     SingleHeaderHandle: TYPE = LONG POINTER TO SingleHeaderDescriptor;    -- Etable structure       ETableHeader: TYPE = MACHINE DEPENDENT RECORD [    fileID(0): File.ID,    vp(2): SELECT OVERLAID * FROM     inuse => [       howManyGroups(2:0..9): [0..1024) ¬ 0,       temporary(2:10..10): BOOLEAN,       bootable(2:11..11): BOOLEAN,       unused(2:12..15): [0..16) ¬ 0,       type(3): File.Type],     free => [       length(2): CARDINAL,       fill(3): CARDINAL],     ENDCASE];      ETable: TYPE = MACHINE DEPENDENT RECORD [    header: ETableHeader,    pageGroups: ARRAY [0..0) OF PageGroup];      ETableHandle: TYPE = LONG POINTER TO ETable;    PageGroup: TYPE = MACHINE DEPENDENT RECORD [    volumePage: Volume.PageNumber,    count: CARDINAL];    PageGroupPtr: TYPE = LONG POINTER TO PageGroup;  PageGroupSeq: TYPE = ARRAY [0..0) OF PageGroup;  PageGroupHandle: TYPE = LONG DESCRIPTOR FOR ARRAY OF PageGroup;  nullPageGroup: PageGroup = [count: 0, volumePage: 0];     -- bucket structure    BucketType: TYPE = {normal, overflow};    FreeSpaceInOverflow: TYPE = BucketHandle RELATIVE LONG ORDERED POINTER TO ETable;  BucketHeader: TYPE = MACHINE DEPENDENT RECORD [    SELECT OVERLAID * FROM       normal => [        eTablesInOverflowCount: CARDINAL,        firstFree: BucketHandle RELATIVE ORDERED POINTER TO ETable],      overflow => [        freeSpace: FreeSpaceInOverflow],      ENDCASE];        Bucket: TYPE = MACHINE DEPENDENT RECORD [    header : BucketHeader,    eTables: ARRAY [0..0) OF ETable];      BucketHandle: TYPE = LONG BASE POINTER TO Bucket;    -- cached bucket information    WhichETableFile: TYPE = {primary, copy, both};    LVBucketInfoData: TYPE = RECORD [    bucketHandle: BucketHandle,    currentBucketPage: File.PageNumber,    fileID: File.ID,    eTableHandle: ETableHandle,    inBucket: BOOLEAN,    overflowHandle: BucketHandle,    currentOverflowPage: File.PageNumber,    freeSpaceInOverflow: FreeSpaceInOverflow,    hash: CARDINAL,    firstBucketPage: File.PageNumber,    firstOverflowPage: File.PageNumber,    fileHandle: FileHeaderHandle,     primaryETableHandle: ETableHandle,    copyETableHandle: ETableHandle,    preImageLogHandle: LONG POINTER,    lvHandle: LogicalVolumeFormat.Handle,    token: VolTable.LVToken,    nextLVBucketInfo: ETableToken];      LVBucketInfo: TYPE = LONG POINTER TO LVBucketInfoData;    ETableToken: TYPE = Environment.Base RELATIVE POINTER TO LVBucketInfoData;    -- ETableFile operations    CreateFile: PROCEDURE [    lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken,    primaryStartPageHint: Volume.PageNumber,    copyStartPageHint: Volume.PageNumber, eTableSize: CARDINAL,    preImageSize: CARDINAL, numberOfBuckets: CARDINAL,    overflowSize: LONG CARDINAL];    DeleteFile: PROCEDURE [    lvBucketInfo: LVBucketInfo, whichFile: WhichETableFile,    eTable: ETableHandle];    GrowETableArea: PROCEDURE [    whichFile: WhichETableFile, count: File.PageCount]    RETURNS [countDone: File.PageCount];      -- ETable Operations    CreateETable: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID, pageGroups: PageGroupHandle,     type: File.Type];    DeleteETable: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID];      SetBootable: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID, bootable: BOOLEAN];      SetTemporary: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID, temporary: BOOLEAN];    -- Bucket operations    AddBuckets: PROCEDURE [lvBucketInfo: LVBucketInfo, count: CARDINAL];    -- Overflow Operations      AddToOverflow: PROCEDURE [    lvBucketInfo: LVBucketInfo, eTable: ETableHandle];    GrowOverflow: PROCEDURE [    lvBucketInfo: LVBucketInfo, count: LONG CARDINAL]    RETURNS [countDone: LONG CARDINAL];      -- PageGroup operations        GetPageGroup: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID, filePage: File.PageNumber]    RETURNS [found: BOOLEAN, group: KernelFile.PageGroup];    InsertPageGroup: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID,    groupPtr: LONG POINTER TO KernelFile.PageGroup];  ShrinkLastPageGroup: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID,     groupPtr: LONG POINTER TO KernelFile.PageGroup];    -- and more    Close: PROCEDURE [token: VolTable.LVToken];    GetFileAttributes: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID]    RETURNS [      fileSize: File.PageCount, temporary: BOOLEAN, bootable: BOOLEAN,       type: File.Type, howManyGroups: CARDINAL];        MakeFileList: PROCEDURE [    token: VolTable.LVToken, log: VM.Interval];      MinPagesForETables: PROCEDURE [Volume.PageCount] RETURNS [Volume.PageCount];  Open: PROCEDURE [token: VolTable.LVToken];    ReplacePage: PROCEDURE [    token: VolTable.LVToken, fileID: File.ID, oldFilePage: File.PageNumber,     newVolumePage: Volume.PageNumber];      -- Errors    Error: ERROR [error: ErrorType];    ErrorType: TYPE = {    duplicateFile, fileNotFound, invalidBucketInfo,    logFull, pageGroupNotFound, spansPageGroupBoundary, tooFragmented,     unexpectedDiskError, volumeNotOpen};    END.    LOG   16-Jun-86 18:00:59	ET/CJS  	Created file. 4-Aug-86 10:03:14      RSV             Deleted insufficientSpace ErrorType. 8-Sep-86 11:53:53      RSV             Added fields itemLogged and firstFilePageLogged to FileHeader type.  Added ItemLogged type.12-Sep-86 15:59:38      RSV             Changed type of firstFilePageLogged to File.PageNumber from File.PageCount.28-Jan-87 14:00:48      RSV             Added OldMakeFileList. 6-Feb-87 16:06:38      RSV             Deleted OldMakeFileList.18-Feb-87 19:17:28      RRR             Added comments.21-Jun-88 13:28:58      RSV             Changed PageGroupSeq and PageGroupHandle to be ARRAYs and DESCRIPTORs.
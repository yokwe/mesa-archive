-- Copyright (C) 1984, 1986, 1989  by Xerox Corporation. All rights reserved. -- VMDriver>VMInternal.mesa   12-Apr-89 12:12:06 by TxH    -- Private types and operations for use within the VMDriver configuration only.DIRECTORY  BackingStore USING [Data, Result, TransferProc],  Environment USING [PageCount, PageNumber],  PageFault USING [anyHelperProcesses, ProcessType],  Process USING [Priority],  ProcessOperations USING [ReadPSB],  ProcessPrioritiesExtras USING [priorityPageFaultLow],  Space USING [ErrorType],  VM USING [DoneWithStateVector, GuardStateVector, Interval, Swappability],  VMData USING [CheckOutData, --*--NewState, noStateChange--**--];VMInternal: DEFINITIONS IMPORTS PageFault, ProcessOperations, VM--inlines-- =  BEGIN  --~~~~~~~~~~~~~~ TYPES:  OpData: TYPE = MACHINE DEPENDENT RECORD [    << This record accumulates the information used by VMImpl to describe the state of a VM data transfer operation.  To better understand the usage of these items, see the descriptions in VMImpl of ProcessBatches and ProcessBatchProc.  Items are listed below in the order that they are initialized during an operation.  The record is declared machine dependent so as to put the most popular elements within the first 16 words of the beginning of the record, and to maximize the packing of items in the light of the desired lexical ordering of this declaration.    >>    process (36):  -- the process on whose behalf the operation is being done. Set by EnterVM.      --GENERIC-- PROCESS,    priorityPrev (0: 0..2):  -- original priority of "process". Set by EnterVM.      Process.Priority,    error (31):  -- ERROR that should be sent to client. Initialized by EnterVM to [noError[]].      ErrorDesc,    ioErrorHandler (34):  -- Called by VMImpl.IOTransfer if error. Initialized by EnterVM to NIL.      IOErrorHandler,    pageReadIn(0: 3..3): -- initialized by EnterVM to FALSE. Made TRUE by any read-in operation.      BOOLEAN,    checkOutData (9):  -- data describing the interval currently checked out. Set by ProcessIntervals.      VMData.CheckOutData,    fillA (0: 4..15): [0..1) ¬ TRASH,    ioInterval (1):  -- interval involved in actual I/O. Private data of individual operation.      VM.Interval,    buffer (5):  -- swap buffer if any. Private data of individual operation.      VM.Interval];  ErrorDesc: TYPE = RECORD [    vp: SELECT type: * FROM      ioError => [page: Environment.PageNumber],      noError => [],      spaceError => [type: Space.ErrorType],      ENDCASE];        IOErrorHandler: TYPE = PROCEDURE [error: error BackingStore.Result]    RETURNS [continuation: IOErrorContinuation];    IOErrorContinuation: TYPE = {    hangProcess, pressOn};  -- See VMImpl.IOTransfer.    returnOnError: IOErrorHandler = NIL;      --~~~~~~~~~~~~~~ Miscellaneous Procedures:    ProcessBatches: PROCEDURE [    pOpData: POINTER TO VMInternal.OpData, interval: VM.Interval,    options: ProcessBatchesOptions, processBatchProc: ProcessBatchProc];--**  ProcessBatchesOptions: TYPE = RECORD [    unmappedProcessing: {skipUnmapped, errorIfUnmapped},    intervalOrSwapUnits: {swapUnitsIncludingInterval, exactInterval},    checkInOption: {checkIn, leaveCheckedOut}];--**  ProcessBatchProc: TYPE = PROCEDURE [pOpData: POINTER TO VMInternal.OpData]    RETURNS [newState: VMData.NewState ¬ VMData.noStateChange,             changeInterval: VM.Interval];--**	       EnterVM: PROCEDURE [pOpData: POINTER TO OpData, interval: VM.Interval];  -- RETURNS [process, processType, priorityPrev]--  -- Actual parameters in pOpData­: none.  -- Actual returns in pOpData­: process, checkOutData.processType, priorityPrev, error ¬ [noError[]].  -- Calls GuardStateVector.  -- If any page of interval falls past the end of the processor's virtual memory, VM.Error[pagePastEndOfMemory] is raised.  ExitVM: PROCEDURE [pOpData: POINTER TO OpData];  -- Actual parameters in pOpData­: priorityPrev, error.  -- Calls DoneWithStateVector.  -- Raises any ERROR specified by error.  GetProcessType: PROCEDURE RETURNS [processType: PageFault.ProcessType] = INLINE    {    IF PageFault.anyHelperProcesses THEN RETURN LookUpProcessType[]    ELSE RETURN[client]};  LookUpProcessType: PRIVATE PROCEDURE    RETURNS [processType: PageFault.ProcessType];  PageFaultProcess: PROCEDURE[];  --~~~~~~~~~~~~~~ Real and Reserved memory management:  AllocateRealMemory: PROCEDURE [    interval: VM.Interval, processType: PageFault.ProcessType, resident: BOOLEAN];  -- Allocates real memory to back the entire interval.  -- If any page of the interval is mapped at entry, the debugger is called.  DeallocateMStoreIfClean: PROCEDURE [interval: VM.Interval]    RETURNS [countDeallocated: Environment.PageCount];  -- For each page in interval: if the real page behind the virtual page is is clean, MStore.Deallocates the real page; if the real page is dirty, nothing is done. Returns the number of pages deallocated.  -- The real memory must not have been promised to MStore.  ReadDead: PROCEDURE [pOpData: POINTER TO OpData, interval: VM.Interval];  -- Allocates real memory to back interval and fills it with clean writable garbage or, if specifed by a boot switch, dirty writable zeros.  --~~~~~~~~~~ State vector management:  GuardStateVector: PROCEDURE RETURNS [priorityPrev: Process.Priority] = INLINE {    -- All client processes that wish to enter a VM monitor may simply do so.  However, if within that monitor, the code will enter other monitors or do a WAIT, NOTIFY, BROADCAST, or Requeue (the normal case), it MUST have called this proc before it is allowed to do so. If it does, it must call DoneWithStateVector before returning to the client    RETURN VM.GuardStateVector[ProcessPrioritiesExtras.priorityPageFaultLow]};  DoneWithStateVector: PROCEDURE [priorityPrev: Process.Priority] = INLINE {    -- See description of GuardStateVector.    VM.DoneWithStateVector[priorityPrev]};  --~~~~~~~~~~ Operation queueing routines:  QueueOp: TYPE = RECORD [    oper: SELECT op: * FROM      activate => [],      copyIn, copyOut => [        transferProc: BackingStore.TransferProc, data: BackingStore.Data],      deactivate => [],      forceOut => [],      setSwappability => [swappability: VM.Swappability],      ENDCASE];  EnqueueOperation: PROCEDURE [interval: VM.Interval, op: QueueOp];  -- Caller must have a reserved state vector.  AwaitNoOverlappingOperations: PROCEDURE [interval: VM.Interval];  -- Waits till there are no queued operations overlapping interval, then returns.  -- A one-pass implementation is allowed.  --~~~~~~~~~~ VM Synchronous Operations:  ActivateSynchronous: PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval];  CopyInSynchronous: PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval,    transferProcIn: BackingStore.TransferProc, dataIn: BackingStore.Data];  CopyOutSynchronous: PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval,    transferProcOut: BackingStore.TransferProc, dataOut: BackingStore.Data];  DeactivateSynchronous: PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval];  ForceOutSynchronous: PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval];  SetSwappabilitySynchronous: PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval,    requestedSwappability: VM.Swappability];  --~~~~~~~~~~ Initialization of VM Internals:  InitializeSwapBuffer: PROCEDURE[];  -- StoragePrograms.AllocateVM and OutlawInterval must be operational before calling this proc.  InitializeVMUtilities: PROCEDURE [];  -- InitializeVMData: PROCEDURE [];  ++ part of ResMemMgr  InitializePageFault: PROCEDURE[];    InitializeVMDriverB: PROCEDURE;    END.    LOG20-Jul-82 13:19:39	WDK      Created file.26-Aug-82 11:11:08	WDK      Twiddles. 8-Nov-82 18:53:09	JXP     Convert to Space from NewSpace. Update fields of OpData since Environment PageNumbers and PageCounts are now LONG.12-Jul-83 18:08:22	JXP     Update OpData field positions since PROCs are long.26-Jan-84 10:50:53	AWL        Remove reservedAlreadyApproved field from OpData - no longer needed.18-Jun-84 13:46:23	KEK      Add pageReadIn field to OpData. Pass whole opData to ReadDead.10-Jul-84 16:17:35	KEK      move OpData.processType to VMData.CheckOutData.processType, move ApproveReserved and CountReservedTails to VMDataImpl... Remove all references to memType.16-Aug-84 19:50:39  	KEK      Add resident argument to AllocateRealMemory.12-Sep-86  7:16:12	et	Change ProcessPriorities to ProcessPrioritiesExtras.20-Jan-89 15:20:06	TxH	added ProcessBatches stuff12-Apr-89 12:12:04	TxH	added InitializeVMDriverB and deleted InitializeConsecutiveMemory. (SS-FX: AR#6, AR#26)
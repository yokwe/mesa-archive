-- Copyright (C) 1986, 1987, 1988, 1989  by Xerox Corporation and Fuji Xerox Co., Ltd. All rights reserved. -- VMMgr>SpaceImplB.mesa  16-May-89 11:29:22 by TxH DIRECTORY  BackingStore USING [Run],  DiskBackingStore USING [Transfer],  Environment USING [bitsPerWord],  File USING [PageCount, PageNumber, Type],  FileLock USING [fileLockNodeSize],  KernelFile USING [GetBackingStoreRunWithCache],  KernelSpaceUsage USING [fileLockSpace],  ObjAlloc USING [Allocate, Free, Interval],  PilotFileTypes USING [tUnassigned],  Space USING [PageFromLongPointer, Window, wordsPerPage],  SpaceInternal USING [    BiggerRuns, cache, defaultRunSize, fileLockFile, fileLockSpace,     FinishWithRuns, GetRuns, hasSystemVolume, incrementOnPilot,    lockAllocationPoolSpace, maxNumberNodes, Runs],  SpecialFile USING [GetBackingStoreRun],  VM USING [BackingStoreRuns, Map, PageCount];SpaceImplB: MONITOR  IMPORTS DiskBackingStore, FileLock, KernelFile, ObjAlloc,  Space, SpaceInternal, SpecialFile, VM  EXPORTS SpaceInternal =  BEGIN    debug: BOOLEAN = FALSE;  -- extra checking done when this is set to true    bitsPerWord: CARDINAL = Environment.bitsPerWord;    lowerBound: PUBLIC --SpaceInternal-- LONG POINTER;     -- initialized in InitializeVMMgr    lastLockPageMapped: PUBLIC --SpaceInternal-- CARDINAL;    invalidSizeNode: PUBLIC --SpaceInternal-- ERROR = CODE;      AllocateStorage: PUBLIC ENTRY PROCEDURE RETURNS [node: LONG POINTER] =    BEGIN    -- Allocates a node for storage and maps the page if it hasn't already been    -- mapped.     nodesBeforeLowerBound: LONG CARDINAL =       (lowerBound - SpaceInternal.lockAllocationPoolSpace.pointer) * bitsPerWord;    interval: ObjAlloc.Interval = ObjAlloc.Allocate[      pool: [        allocPool: lowerBound,        poolSize: SpaceInternal.maxNumberNodes - nodesBeforeLowerBound],      count: 1];    node ¬ ((interval.first + nodesBeforeLowerBound) * FileLock.fileLockNodeSize)      + SpaceInternal.fileLockSpace.pointer;    lowerBound ¬ lowerBound + (interval.first / bitsPerWord);    -- is this new node within pages already mapped    IF (((node - SpaceInternal.fileLockSpace.pointer + FileLock.fileLockNodeSize) - 1) /      Space.wordsPerPage) > lastLockPageMapped THEN      BEGIN      IF SpaceInternal.hasSystemVolume THEN        BEGIN  -- system volume therefore swappable	defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;	runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];	runs ¬ SpaceInternal.GetRuns[runs, [	   file: SpaceInternal.fileLockFile, base: lastLockPageMapped + 1,	   count: SpaceInternal.incrementOnPilot], FALSE];	VM.Map[	  interval: [	    page: Space.PageFromLongPointer[	      SpaceInternal.fileLockSpace.pointer] + lastLockPageMapped + 1,	    count: SpaceInternal.incrementOnPilot],	  transferProc: DiskBackingStore.Transfer, backingStoreRuns: runs.runs,	  usage: KernelSpaceUsage.fileLockSpace, class: data, access: readWrite,	  swapUnits: [unitary[]], life: dead, swappability: swappable];	SpaceInternal.FinishWithRuns[runs];	lastLockPageMapped ¬ lastLockPageMapped + SpaceInternal.incrementOnPilot;	END      ELSE        BEGIN  -- Utility Pilot therefore resident	VM.Map[	  interval: [	    page: Space.PageFromLongPointer[	      SpaceInternal.fileLockSpace.pointer] + lastLockPageMapped + 1,	    count: 1],	  transferProc: NIL, backingStoreRuns: NIL,	  usage: KernelSpaceUsage.fileLockSpace, class: data, access: readWrite,	  swapUnits: [unitary[]], life: dead, swappability: resident];	lastLockPageMapped ¬ lastLockPageMapped.SUCC;	END;      END;    END; --AllocateStorage--      DeallocateStorage: PUBLIC ENTRY PROCEDURE [node: LONG POINTER, length: CARDINAL]    RETURNS [LONG POINTER] =    BEGIN    IF (node # NIL) AND (length = FileLock.fileLockNodeSize) THEN      BEGIN      thisNode: LONG CARDINAL = (node - SpaceInternal.fileLockSpace.pointer) /        FileLock.fileLockNodeSize;      ObjAlloc.Free[	pool: [	  allocPool: SpaceInternal.lockAllocationPoolSpace.pointer, 	  poolSize: SpaceInternal.maxNumberNodes],	interval: [first: thisNode, count: 1],	validate: debug];      lowerBound ¬ LOOPHOLE[MIN[        (thisNode / bitsPerWord) + 	  LOOPHOLE[SpaceInternal.lockAllocationPoolSpace.pointer, LONG CARDINAL],	LOOPHOLE[lowerBound, LONG CARDINAL]], LONG POINTER];      RETURN[NIL];  -- just to make sure it isn't used anymore.      END    ELSE       ERROR invalidSizeNode;    END;          GetRuns: PUBLIC --SpaceInternal-- PROCEDURE [    initialRuns: SpaceInternal.Runs, window: Space.Window, usedVMBF: BOOLEAN]    RETURNS [newRuns: SpaceInternal.Runs] =    BEGIN    filePage: File.PageNumber;    type: File.Type ¬ PilotFileTypes.tUnassigned;    countLeft: File.PageCount;    countRuns: CARDINAL;    freeNewRunsIfError: BOOLEAN ¬ FALSE;    filePage ¬ window.base;    newRuns ¬ initialRuns;    countRuns ¬ 0;    countLeft ¬ window.count;    WHILE countLeft > 0 DO      ENABLE UNWIND =>         IF freeNewRunsIfError THEN SpaceInternal.FinishWithRuns[newRuns];      IF countRuns >= LENGTH[newRuns.runs] THEN {        newRuns ¬ SpaceInternal.BiggerRuns[newRuns];	freeNewRunsIfError ¬ TRUE};      IF usedVMBF THEN      -- may raise File.MissingPages.        [run: newRuns.runs[countRuns], resultType: type] ¬	KernelFile.GetBackingStoreRunWithCache[window.file, filePage, type,        SpaceInternal.cache]      ELSE        [run: newRuns.runs[countRuns], resultType: type] ¬        SpecialFile.GetBackingStoreRun[window.file, filePage, type];      filePage ¬ filePage + newRuns.runs[countRuns].count;      countLeft ¬        IF countLeft > newRuns.runs[countRuns].count THEN        countLeft - newRuns.runs[countRuns].count ELSE 0;      countRuns ¬ countRuns + 1;      ENDLOOP;    newRuns.runs ¬ DESCRIPTOR[BASE[newRuns.runs], countRuns];    END;  --GetRuns--    END.--LOG12-Nov-86 16:46:38      RSV  Created file. 7-Dec-86 19:26:29      RSV  Deleted commented out line in AllocateStorage.14-Jan-87 22:04:56      ET   Moved GetRuns here. 5-Jan-88 12:08:59      RSV  added incrementOnPilot, debug, and lowerBound.  Made swap units unitary instead of uniform. 6-Jan-88 18:51:51      RSV  moved incrementOnPilot to SpaceInternal.26-Jan-88 22:10:41      RSV  DeallocateStorage had bug (used SpaceInternal.fileLockSpace.pointer instead of SpaceInternal.lockAllocationPoolSpace.pointer when calculating lowerBound.30-Mar-89 13:46:54	TXT  Add InsertLockIntoRuns (from SpaceImplA) and really mapped paged count(countRest) is introduced.11-Apr-89 11:40:19	TxH  made changes so that InsertLockIntoRuns handle the mapUnitIndex. (SS-FX: AR#6, AR#26) 16-May-89 11:29:19	TxH  moved InsertLockIntoRuns to SpaceImplC.  
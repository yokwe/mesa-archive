-- Copyright (C) 1984, 1985, 1987  by Xerox Corporation. All rights reserved. -- BootChannelFloppy.mesa   28-Apr-87  8:10:01 by CAJ <<  This is a general-case floppy driver designed for use with the germ.  It was constructed from BootChannelFloppyDLion.mesa, using BootChannelDisk.mesa as an example...    Note how this makes for A LOT of code ("what's the matter, spock?" "I just felt a million vulcans die: eaten by a monster virus!" "Bones, quick -- a shot of monster antibodies!");  a giant germ.  Don't fret, the germ will be shrunk down to size after it is packaged and knows how to reclaim memory out from under the code (BootChannelFloppy, eg) it ceases to require.    OK, it's now packaged and real memory under initialization code gets returned after initialization (everybody's, not just this module), and under floppy code gets returned after inload.>>DIRECTORY  Boot USING [Location],  BootChannel USING [    Create, Handle, Operation, Result, transferCleanup, transferWait],  Device USING [Type],  DeviceTypes USING [sa800],  DeviceTypesExtras4 USING [ExtendedFloppy, FloppyTape],  Environment USING [Byte, first64K, LongNumber, LongPointerFromPage,    --PageFromLongPointer, --PageNumber],  GermOps USING [GermWorldError],  Inline USING [DIVMOD, LowHalf],  PilotMP USING [cGermDeviceError, cGermERROR, Code],  ResidentHeap USING [FreeNode, MakeNode],  FloppyDiskFace USING [    DeviceHandle, DiskAddress, DiskChangeClear, GetDeviceAttributes,    GetNextDevice, Initialize, initialAllocationLength, Initiate,    nullDeviceHandle, operationAlignment, operationBlockLength, OperationPtr,    Poll, SetContext, Status, Tries];BootChannelFloppy: PROGRAM  IMPORTS    RemainingChannels: BootChannel, Environment, GermOps, Inline,    ResidentHeap, FloppyDiskFace  EXPORTS BootChannel  SHARES Device, GermOps =  BEGIN    Ops: TYPE = [0..maxOps);  maxOps: CARDINAL = 2;    -- To stay within heapspace, max maxOps = 5(DLion) or 2(Dove).  OpsDescriptor: TYPE = RECORD [    op: FloppyDiskFace.OperationPtr,    state: {idle, busy}, -- idle means operation AND ERROR HANDLING are done.    opState: {running, completed}, -- completed means operation ONLY is done.    status: FloppyDiskFace.Status];  cylinders: CARDINAL;  tracksPerCylinder, sectorsPerTrack: Environment.Byte;  ops: ARRAY Ops OF OpsDescriptor;  initialOp: FloppyDiskFace.OperationPtr;  --used only in Create.  diskAddress: FloppyDiskFace.DiskAddress;  floppyTape: BOOLEAN;  maxTries: FloppyDiskFace.Tries = 128;  -- try real hard  -- The 128 is a magic number which fulfills the following conditions:  --   causes as many retries as possible,  --   >= DLion head's (floppy tape) private maxRetries value (30),  --   =  DLion head's (floppy disk) only value to cause retries (128),  --   >= Dove head's ActualNumberOfRetriesWhenDMAHit (50).  -- Changes in either head could invalidate the value.          Create: PUBLIC --BootChannel.-- PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation,    buffer: LONG POINTER]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- The buffer arg is not used by this boot channel.    IF pLocation.deviceType = DeviceTypes.sa800      OR pLocation.deviceType IN DeviceTypesExtras4.ExtendedFloppy      THEN RETURN CreateInternal[pLocation, operation]    ELSE        -- not anything I implement.  Pass it on.      RETURN RemainingChannels.Create[pLocation, operation];    END; --Create--  -- CreateInternal exists so that when memory backing germ-floppy code is  -- discarded, create code can be discarded without breaking the BootChannel  -- chain.  CreateInternal: PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    device: FloppyDiskFace.DeviceHandle;    IF pLocation.deviceOrdinal # 0 OR operation = write THEN      GermOps.GermWorldError[PilotMP.cGermDeviceError];    floppyTape ¬ pLocation.deviceType IN DeviceTypesExtras4.FloppyTape;    initialOp ¬ @Environment.first64K[      ResidentHeap.MakeNode[FloppyDiskFace.initialAllocationLength,	FloppyDiskFace.operationAlignment].node];    FloppyDiskFace.Initialize[notify: 0, initialAllocation: initialOp];    device ¬ FloppyDiskFace.GetNextDevice[FloppyDiskFace.nullDeviceHandle];    FloppyDiskFace.DiskChangeClear[device];          FOR i: Ops IN Ops DO      operation: LONG POINTER TO FloppyDiskFace.OperationPtr = @ops[i].op;      operation­ ¬ @Environment.first64K[        ResidentHeap.MakeNode[FloppyDiskFace.operationBlockLength,	  FloppyDiskFace.operationAlignment].node];      operation.device ¬ device;      operation.function ¬ readSector;      operation.incrementDataPointer ¬ TRUE;      operation.tries ¬ maxTries;      ops[i].state ¬ idle;      ENDLOOP;	    [] ¬ FloppyDiskFace.SetContext[device, [FALSE, IBM, double, 256]];    diskAddress ¬ LOOPHOLE[pLocation.diskFileID.da];    [[numberOfCylinders: cylinders,      numberOfHeads: tracksPerCylinder,      maxSectorsPerTrack: sectorsPerTrack]] ¬      FloppyDiskFace.GetDeviceAttributes[device];    RETURN[[ok[]], Transfer];    END;  --CreateInternal--  Transfer: BootChannel.Handle  --    --PROC [page, count] RETURNS [result: BootChannel.Result]-- =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    SELECT count FROM      = BootChannel.transferCleanup =>          BEGIN	  [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[initialOp]];          FOR i: Ops IN Ops DO            [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[ops[i].op]];	    ENDLOOP;	  END;      = BootChannel.transferWait =>          BEGIN          THROUGH Ops DO	    FinishRequest[];	    RotateOps[];	    ENDLOOP;	  END;      NOT IN CARDINAL => GermOps.GermWorldError[PilotMP.cGermERROR];      ENDCASE =>        BEGIN	IF ops[0].state = busy THEN FinishRequest[];	SubmitRequest[page, CARDINAL[count]];      	RotateOps[];	END; --ENDCASE--    RETURN[[ok[]]];    END; --Transfer--           FinishRequest: PROCEDURE =                 -- forces ops[0] to the idle state    BEGIN    ForceCompleted: PROCEDURE =      BEGIN      status: FloppyDiskFace.Status;      IF ops[0].state = idle THEN RETURN;      IF ops[0].opState = running THEN        BEGIN	WHILE (status ¬ FloppyDiskFace.Poll[ops[0].op].status) = inProgress DO	  THROUGH [0..100) DO ENDLOOP;  -- give the IOP a break	  ENDLOOP;	ops[0].opState ¬ completed;        ops[0].status ¬ status;        END;      END; --ForceCompleted--        UNTIL ops[0].state = idle DO      ForceCompleted[];      IF ops[0].status # goodCompletion THEN        BEGIN --error handler--	code: PilotMP.Code ¬	  (IF floppyTape AND (ops[0].status = otherError)	    THEN code ¬ 926--cGermMediaProblem--	  -- Replace 926 with PilotMP.cGermMediaProblem when we can use	  -- PilotMP.mesa it's in.	  ELSE PilotMP.cGermDeviceError);        GermOps.GermWorldError[code];	END --error handler--      ELSE        ops[0].state ¬ idle;      ENDLOOP;    END; --FinishRequest--      SubmitRequest: PROCEDURE [    page: Environment.PageNumber, count: CARDINAL] =    -- Initiates ops[0].    BEGIN    operation: FloppyDiskFace.OperationPtr ¬ ops[0].op;    ops[0].state ¬ busy;    ops[0].opState ¬ running;    operation.address ¬ diskAddress;    operation.dataPtr ¬ Environment.LongPointerFromPage[page];    operation.count ¬ count;    [] ¬ FloppyDiskFace.Initiate[operation]; -- throw away early status    diskAddress ¬ NewAddress[count];    -- note diskAddress already updated, so no retries    END; --SubmitRequest--          RotateOps: PROCEDURE =    BEGIN    t: OpsDescriptor = ops[0];    FOR i: Ops IN [1..LAST[Ops]] DO      ops[i-1] ¬ ops[i];      ENDLOOP;    ops[LAST[Ops]] ¬ t;    RETURN;    END; --RotateOps--          NewAddress: PROCEDURE [count: CARDINAL]    RETURNS [da: FloppyDiskFace.DiskAddress] =    BEGIN    q: CARDINAL;    [q, da.sector] ¬      Inline.DIVMOD[diskAddress.sector - 1 + count, sectorsPerTrack];    da.sector ¬ da.sector + 1;  -- sectors start with 1    [q, da.head] ¬ Inline.DIVMOD[diskAddress.head + q, tracksPerCylinder];    da.cylinder ¬ diskAddress.cylinder + q;    END;    END.LOG 30-Nov-81  8:07:40	FXH       Created file..12-Feb-82 16:57:10	LXD         Bug fix in ReadPage29-Jul-82  9:55:16	AEF        Modify for new IOPage layout13-Apr-83  9:58:49	WDK        Get LongPointerFromPage from Environment. Make compatible with new BootChannel. 8-Jun-84 13:34:34	AWL         Modify for new BootChannel (muliple buffering).  First implementation does single buffering. 1-Nov-84 12:34:02	KEK       Modify for Dove: remove FloppyDLion specific code (rename from BootChannelFloppyDLion.mesa, remove all stuff copied from SA800HeadDlion & FloppyDiskFace).  Much adapted from BootChannelDisk (incl double buffering?)... 7-Dec-84 16:05:05	KEK       convert to FloppyDiskFace.21-Mar-85 16:08:49	CAJ    Look for device types from DeviceTypesExtras.Floppy; add delay to Poll loop. 2-May-85 14:21:13	CAJ    Correct length for Ops operation allocation; replace straight a4 with   FloppyDiskFace.operationAlignment. 4-Feb-87  7:40:26	CAJ    Expand devices covered to include DeviceTypesExtras4.ExtendedFloppy. 6-Mar-87  7:15:07	CAJ    Modify NewAddress to increment the disk address rather than convert to page number, increment, and reconvert to disk address, to avoid CARDINAL overflow on new larger media (like floppy tape).  Set maxTries from 3 to 128 (magic number explained) and replace resubmitting of operation on error with GermWorldError.  2-Apr-87 12:45:07	CAJ    Put up retention MP code if error is otherError and device is floppy tape. 28-Apr-87  8:09:56	CAJ    Add buffer arg to Create for BootChannel change. 
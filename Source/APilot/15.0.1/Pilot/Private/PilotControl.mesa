-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Control>PilotControl.mesa       9-Jul-86 16:06:10 by MEW    -- PilotControl is the first program that is executed when a virgin boot file, created by MakeBoot, is InLoaded and invoked.  At that time, Boot.pRequest­ contains the information describing where the boot file was gotten from, and contains the boot switches passed by the invoker of the InLoad.  Note that Boot.pRequest­ gets changed on every world-swap, so it must be copied before PilotControl invokes any world-swap (e.g. KeyStop 0).DIRECTORY  BackingStore USING [Data, Run, TransferProc],  Boot USING [    currentRequestBasicVersion, currentRequestExtensionVersion, countGermVM,    DiskFileID, Location, pageGerm, pRequest, Request],  CommunicationPrograms USING [InitializeCommunication],  ControlModuleFormat USING [Call, MainBody],  CPSwapDefs USING [    ExternalStateVector, PatchTable, PatchTableEntry, SwapInfo],  DebuggerSwap USING [Parameters],  Device USING [nullType, Type],  DriverStartChain USING [Start],  Environment USING [    LongPointerFromPage, maxPagesInMDS, PageCount, PageNumber, PageOffset],  File USING [ID, nullFile, nullID],  Frame USING [Alloc, Free, SetReturnLink],  FrameExtras USING [LongGFToGFTHandle],  GermOps USING [GetPStartListHeader],  HeadStartChain USING [Start],  KernelPrograms USING [    InitializeHeap, InitializeStream, InitializeSystemA,    InitializeSystemB],  KernelSpaceUsage USING [germ, ioPage, pageMDSZero, pageZero],  MapLog USING [mapLogging],  PageMap USING [ExchangeFlags, flagsDirty, flagsVacant, State],  PilotClient USING [Run],  PilotMP USING [    Code, cBadBootFile, cBadBootGermVersion, cClient, cCommunication, cControl,    cMap, cStorage],  PilotSwitches USING [    break0, break1, break2, disableMapLog, eatGerm, fillMapLog, noStartCommunication,    remoteDebug],  PilotSwitchesExtras USING [makeCodeOnePageSwapUnits],  PrincOps USING [maxFrameSize, nullLocalFrame, ShortControlLink],  Process USING [Detach, Priority, SetPriority],  ProcessOperations USING [WriteWDC],  ProcessorFace USING [GetNextAvailableVM, SetMP, SpecialSetMP, Start],  ProcessPriorities USING [priorityClient],  PSB USING [PDA],  RealMemory USING [    Initialize, MoveIntervalToDisplayMemory, SpecialResidentCodeHandle],  ResMemPerf USING [SetFreeRealMemoryThreshold],  Runtime USING [CallDebugger, IsBound, UnboundProcedure],  RuntimeInternal USING [Bug, MakeFsi],  RuntimePrograms USING [    InitializeLoadStateA, InitializeLoadStateB,    InitializeProcessesA, InitializeProcessesB,    InitializeRuntimeLoader, InitializeSignals, InitializeSnapshot, Traps],  Space USING [    Access, Allocate, CopyIn, Deactivate, Deallocate, Interval,    LongPointerFromPage, MapAt, PageFromLongPointer, PagesFromWords,    Pointer, SwapUnitOption, SwapUnitSize, unknownUsage, virtualMemory, Window],  SpecialRuntime USING [Code],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  SpecialSystem USING [isDiagnosticPilot, switches],  StartList USING [    Entry, Index, SpaceIndex, StartIndex, SwapUnitInfo, Base, VersionID],  StoragePrograms USING [    AddReservedMStore, AllocateVM,    InitializeEarlyVMAlloc, InitializeFileBasics,    InitializeFileMgr, InitializeFrame, InitializeInterrupt, InitializeMStore,    InitializePCMemory, InitializePilotNub, InitializePinning,     InitializeResidentHeap, InitializeResidentMemory,    InitializeSpaceAllocation,     InitializeVMDataA, InitializeVMDataB, InitializeVMDataC,     InitializeVMDriver, InitializeVMMgr, InitializeZone,    OutlawInterval, PilotType, ResidentRunFastCodeHandle,    SpecialResidentCodeHandle, StartListProc, UnusedRealMemory],  StoreDriverStartChain USING [Start],  SwapperDriverStartChain USING [Start],  System USING [    defaultSwitches, GetLocalTimeParameters, isUtilityPilot,    LocalTimeParametersUnknown, switches, Switches],  VM USING [    AdjustReservedRealMemory, Interval, MakeResident, Map, nullInterval, Swappability],  Volume USING [nullID, SystemID],  XferTrap USING [WriteXTS];PilotControl: PROGRAM  IMPORTS    ControlModuleFormat, GermOps, CommunicationPrograms, DriverStartChain, Frame,    FrameExtras, HeadStartChain, KernelPrograms, MapLog, PilotClient,    PageMap, Process, ProcessOperations, ProcessorFace, RealMemory,    ResMemPerf, Runtime, RuntimeInternal,    RuntimePrograms, Space, SpecialRuntime, SpecialRuntimeExtras, SpecialSystem,    StoragePrograms, StoreDriverStartChain, SwapperDriverStartChain, System, VM,    Volume, XferTrap  EXPORTS DebuggerSwap, StoragePrograms  SHARES File, MapLog, PageMap, RuntimePrograms =  BEGIN OPEN Environment;  -- PARAMETERS:  maxSwapUnits: CARDINAL [0..absoluteMaxSwapUnits] ¬ 64;  -- The effect of this parameter is to cause a map unit consisting of a long sequence of irregular swap units to be broken into shorter map units.  -- Decreasing this number will cause more space to be used in the VM data base (bad), but will speed up the database search by causing the (efficient) binary search to get closer to the desired swap unit before the linear scan takes over (good).  -- The value of this parameter should be determined by performance testing. As of Sept 82, this had not been done.  maxPatches: CARDINAL = 50;  -- (User can ask debugger for more.)  defaultFreeRealMemoryThresholdForNormalPilot: Environment.PageCount = 4;  -- (Client can give different value by calling ResMemPerf.SetFreeRealMemoryThreshold.)  -- Types, Constants, and Variables:  -- EXPORTed to StoragePrograms:  countVM: PUBLIC PageCount;  -- size of VM implemented on this processor.  pageMDS: PUBLIC Environment.PageNumber;  -- first page of Pilot's (only) MDS.  pageHyperspace:  -- first page of non-MDS non-Germ VM. (Hyperspace is assumed to follow MDS.)    PUBLIC Environment.PageNumber;  countHyperspace: PUBLIC Environment.PageCount;  startList: PUBLIC StartList.Base;  -- base pointer of the StartList.  pilotType: PUBLIC StoragePrograms.PilotType;  -- EXPORTed to DebuggerSwap:  canSwap: PUBLIC BOOLEAN ¬    -- Does parameters describe an inloadable debugger?    -- (If commanded to teledebug, canSwap stays false forever.)    FALSE;  parameters: PUBLIC DebuggerSwap.Parameters;  -- Assorted global variables:  -- Boot file info: Make copy in case it is changed by a world-swap  --   before we finish using it here.  request: Boot.Request ¬ Boot.pRequest­;  PEntry: TYPE = POINTER TO StartList.Entry;  -- for debugger  BugType: TYPE = {    allocateVMTrouble, badStartList, codeHandleNotFound,    funnyBacking, funnyCase, funnySpaceType, funnyStartlistEntry, noPage,    notImplementedInUtilityPilot, pageFaultOnInitializationCodeOrData,    parentIsEmpty, pilotPackagedIncorrectly, startlistSaidWritable,    swapUnitAbsentOrDescendingOrder, swapUnitTooBig,    unimplementedStartListOptions};    nullShortLink: PrincOps.ShortControlLink = [frame[PrincOps.nullLocalFrame]];  PESV: PROCEDURE[] RETURNS [LONG POINTER TO CPSwapDefs.ExternalStateVector] =    INLINE {RETURN[      LOOPHOLE[PSB.PDA.available, CPSwapDefs.SwapInfo].externalStateVector]};  -- Heart of PilotControl:  StartPilot: PROC =    BEGIN    pageEndHyperspace: Environment.PageNumber;    pageExcessRealMemory: PageNumber;  -- real pages not backing bootloaded stuff.    pageFreeVM: PageNumber;  -- VM following that allocated by StartPilot.    teledebugging: BOOLEAN;  -- Has client ordered us to teledebug?    page: PageNumber;    count: PageCount;        ProcessorFace.SpecialSetMP[PilotMP.cControl];    -- Get start traps working first.    <<ControlModuleFormat.Call[ -- blows up compiler in pass 5.      RuntimeInternal.MainBody[        SpecialRuntime.GlobalFrameFromProgram[RuntimePrograms.Traps]]];>>    BEGIN  --workaround--    traps: PROGRAM ¬ RuntimePrograms.Traps;    ControlModuleFormat.Call[ -- blows up compiler in pass 5.      ControlModuleFormat.MainBody[FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[traps]]]];    END;  --workaround--    -- Initialize processor face:    ProcessorFace.Start[];  -- (gets software-implemented instructions working)    ProcessorFace.SetMP[PilotMP.cControl];  -- (sets ProcessorFace.mp)    -- Find the size of VM for this processor:    FOR countVM ¬ FIRST[PageNumber], page + count DO      [page, count] ¬ ProcessorFace.GetNextAvailableVM[countVM];      IF count = 0 THEN EXIT;      ENDLOOP;    IF request.requestBasicVersion ~= Boot.currentRequestBasicVersion      OR request.requestExtensionVersion ~= Boot.currentRequestExtensionVersion      THEN      -- not the version of Boot that we were compiled with.      DieWithMPCode[PilotMP.cBadBootGermVersion];    startList ¬ GermOps.GetPStartListHeader[];    IF startList.version ~= StartList.VersionID THEN      -- not the version of StartList that we were compiled with.      DieWithMPCode[PilotMP.cBadBootFile];    -- Get boot switch settings and boot device, and start System exporting them:    KernelPrograms.InitializeSystemA[      pSw:      IF request.switches ~= System.defaultSwitches THEN  --      @request.switches  -- use client's if any      ELSE  -- use those in boot file.        @LOOPHOLE[startList.switches, System.Switches],      bootDev: [      device: request.location.deviceType,      index: request.location.deviceOrdinal]];    pageMDS ¬ Space.PageFromLongPointer[  --      LOOPHOLE[1, POINTER]];  -- ("1" since "0" collides with NIL)    pageHyperspace ¬ pageMDS + maxPagesInMDS;  -- follows MDS.    pageEndHyperspace ¬ FIRST[PageNumber] + countVM;    countHyperspace ¬ pageEndHyperspace - pageHyperspace;    pageFreeVM ¬ startList.lastVMPage + 1;    pageExcessRealMemory ¬ startList.lastBootLoadedPage + 1;    -- Initialize PDA:  (debugger expects it initialized)    RuntimePrograms.InitializeProcessesA[  -- no required precursors.      pageUnusedRealMemory: pageExcessRealMemory,      countUnusedRealMemory: pageEndHyperspace - pageExcessRealMemory];    -- Note that InitializeProcessesA requires that the top frame    -- of the call stack have its return link be already set to nullShortLink.    -- Get debugger communication operational:    StoragePrograms.InitializePilotNub[];        -- Plant location of load state in esv (for debugger and loader):    PESV[].loadState ¬ Environment.LongPointerFromPage[      startList[startList[startList.initLoadState].parent].vmpage +      startList[startList.initLoadState].base];    -- Set location of debugger (if one known at this point):    teledebugging ¬ (System.switches[PilotSwitches.remoteDebug] = down);    IF ~teledebugging      AND LOOPHOLE[startList.locDebugger, Boot.Location].deviceType ~=        Device.nullType THEN {      -- OthelloOps put info in boot file.      parameters.locDebuggee ¬ LOOPHOLE[startList.locDebuggee, Boot.Location];      parameters.locDebugger ¬ LOOPHOLE[startList.locDebugger, Boot.Location];      canSwap ¬ TRUE};    parameters.pMicrocodeCopy ¬ parameters.pGermCopy ¬ NIL;  -- until microcode swapping installed.    -- We can get to debugger now if teledebug or debugger pointers set.    -- However, we delay one more step to allocate the patch table    -- so that we can set breakpoints at key stop zero.    StoragePrograms.InitializeFrame[];  -- (Processes must preceed.)    -- RuntimeInternal.MakeFsi is now operational.        -- Allocate patch table:    (InitializeFrame must preceed.)    BEGIN    InitialPatchEntries: TYPE =      ARRAY [0..maxPatches) OF CPSwapDefs.PatchTableEntry;    InitialPatchTable: TYPE = MACHINE DEPENDENT RECORD [      header: CPSwapDefs.PatchTable,  -- control info, no entries.      entries:  InitialPatchEntries]; -- must immediately follow header.    patchTable: POINTER TO InitialPatchTable =  -- death if frame fault here.      Frame.Alloc[RuntimeInternal.MakeFsi[words: InitialPatchTable.SIZE]];    patchTable.header ¬ [length: 0, maxlength: maxPatches, entries: NULL];    -- Tell debugger (and VMDriver) where it is:    PESV[].patchTable ¬ LONG[@patchTable.header];    END;        IF System.switches[PilotSwitches.break0] = down THEN      Runtime.CallDebugger["Key Stop 0"L];    -- Initialize rest of Mesa runtime support:    Process.SetPriority[  -- Set default priority for those that don't care.      ProcessPriorities.priorityClient];        RuntimePrograms.InitializeSignals[];        -- Determine the type of Pilot we are.    pilotType ¬ pilot;  -- assume normal Pilot..    BEGIN    IAmPilot[ ! Runtime.UnboundProcedure =>      BEGIN  -- We're not regular Pilot      IAmUtilityPilot[ ! Runtime.UnboundProcedure =>	BEGIN  -- We're not Utility Pilot	IAmDiagnosticPilot[	  ! Runtime.UnboundProcedure => Bug[pilotPackagedIncorrectly]];	pilotType ¬ diagnosticPilot;  -- It's DiagnosticPilot	GO TO GotPilotType;	END];      pilotType ¬ utilityPilot;  -- It's UtilityPilot      GO TO GotPilotType;      END];    EXITS      GotPilotType => NULL;    END;    RuntimePrograms.InitializeLoadStateA[];  -- (Processes must preceed.)    -- Global frame operations (notably ValidateGlobalFrame),    -- Runtime.IsBound, and  NEW <module>  are operational.    -- Mesa runtime facilities are now fully operational.    -- Initialize the Store configuration:    BEGIN OPEN S: StoragePrograms;    ProcessorFace.SetMP[PilotMP.cStorage];    -- Initalize ResMemMgr config (basic real and virtual memory facilities):    S.InitializeEarlyVMAlloc[      unusedVMNotInStartList: [      page: pageFreeVM, count: pageEndHyperspace - pageFreeVM]];    --~~~~~ Describe outlaw Spaces to EarlyVMAlloc:    -- We have to do the following AllocateVM's here since the largest empty    -- space in the first 64K includes page 0 and the Germ, and their VM    -- would be allocated to InitializeResidentMemoryA below if we didn't    -- grab it first.  This will be cleaner when MakeBoot implements the    -- EMPTY command. Note that AllocateVM does an OutlawInterval[] for us.    -- WHEN THESE AllocateVM'S ARE NO LONGER NECESSARY,    -- replace them with OutlawInterval[].    -- 1 of 2: Allocate outlaw space on unmapped page 0 (LONG[NIL]­):    IF S.AllocateVM[1, first64K, KernelSpaceUsage.pageZero, alwaysWhollyUnmapped] #      0 THEN Bug[allocateVMTrouble];  -- the space didn't come out in the right place.    -- 2 of 2: Allocate outlaw space on Germ (must do before InitializeResidentMemory):    IF S.AllocateVM[      Boot.countGermVM, first64K, KernelSpaceUsage.germ,      partiallyOrSometimesMapped] # Boot.pageGerm THEN  --        Bug[allocateVMTrouble];  -- the space didn't come out in the right place.    S.OutlawInterval[      [pageMDS, 1], KernelSpaceUsage.pageMDSZero, alwaysWhollyUnmapped];    -- Describe outlaw space on Processor I/O pages:    FOR endPrev: PageNumber ¬ FIRST[PageNumber], page + count DO      [page, count] ¬ ProcessorFace.GetNextAvailableVM[endPrev];      --UNTIL-- IF count = 0 THEN EXIT;  -- end of VM.      IF endPrev # FIRST[PageNumber] THEN        S.OutlawInterval[          [endPrev, page - endPrev], KernelSpaceUsage.ioPage,          alwaysWhollyMapped];      ENDLOOP;    RuntimePrograms.InitializeProcessesB[];  -- declares outlaw spaces in PDA.    RealMemory.Initialize[];  -- initializes exported real memory allocation table.    S.InitializeMStore[];  -- (RealMemory must preceed.)    S.UnusedRealMemory[[      page: pageExcessRealMemory,      count: pageEndHyperspace - pageExcessRealMemory]];    S.InitializePCMemory[]; -- (InitializeMStore, UnusedRealMemory must preceed.)    -- Reserve memory for one max-sized frame fault:    -- (PilotControl does this as a service to FrameImpl    --   since it is started too early to do it itself.)    VM.AdjustReservedRealMemory[  -- (MStore must preceed)      Space.PagesFromWords[PrincOps.maxFrameSize], add];    S.InitializeVMDataA[];  -- (AllocateReservedMStore now operational)        S.InitializeResidentMemory[];  -- (VMDataA must preceed.)    S.InitializeZone[];  -- (No required predecessors.)    S.InitializeResidentHeap[];  -- (Zone and ResidentMemory must preceed.)    S.InitializeVMDataB[];  -- (All of VMData now operational except    			    -- little used stuff that uses Pinning)        HeadStartChain.Start[];  -- start heads.    S.InitializeInterrupt[];  -- now that KeyboardFace.keyboard is defined.    KernelPrograms.InitializeSystemB[  -- sets exported vars, etc.      pilotType = utilityPilot, pilotType = diagnosticPilot];    StoreDriverStartChain.Start[];  -- start drivers not dependent on Store config.    S.InitializeVMDriver[];  -- VM is now operational.        S.InitializeVMDataC[];  -- all of VMData is now operational    S.InitializeFileBasics[];    [] ¬ ResMemPerf.SetFreeRealMemoryThreshold[      IF System.isUtilityPilot THEN 0      ELSE defaultFreeRealMemoryThresholdForNormalPilot];    SwapperDriverStartChain.Start[];    S.InitializeSpaceAllocation[];    -- Start FileMgr, which will find system volume (if any)    --    and possibly local debugger:    BEGIN  --scope of variables--    debuggerDevType: Device.Type;  -- for debugger boot files    debuggerDevOrdinal: CARDINAL;  -- device ordinal for debugger boot files    debugger, debugee: Boot.DiskFileID;    [debuggerDeviceType: debuggerDevType, debuggerDeviceOrdinal: debuggerDevOrdinal] ¬      S.InitializeFileMgr[      bootFile: @request.location,      pDebuggerResult: @debugger, pDebuggeeResult: @debugee];    -- If no debugger already and found a local one, use that one:    IF ~teledebugging AND ~canSwap AND debuggerDevType # Device.nullType      AND debugger.fID.fileID ~= File.nullID      AND debugee.fID.fileID ~= File.nullID THEN      BEGIN      parameters.locDebugger ¬ [        deviceType: debuggerDevType, deviceOrdinal: debuggerDevOrdinal,        vp: disk[diskFileID: debugger]];      parameters.locDebuggee ¬ [        deviceType: debuggerDevType, deviceOrdinal: debuggerDevOrdinal,        vp: disk[diskFileID: debugee]];      canSwap ¬ TRUE;      END;    END;  --scope of variables--    -- If no debugger, we limit maplogging to not go past when the maplog database fills up:    IF ~teledebugging AND ~canSwap THEN      SpecialSystem.switches[PilotSwitches.fillMapLog] ¬ down;    S.InitializeVMMgr[];    ProcessorFace.SetMP[PilotMP.cMap];    MapSwappableSpaces[];  -- and map log them.        -- now that all code is properly in the VM database we can set Pinning going    -- See comments at head of PinningImpl for notes about LIMITED use    -- of Pinning before this point.    S.InitializePinning[];         -- Now everything swappable allocated by MakeBoot has been placed    --    in the VMMgr databases and mapLogged.    IF System.switches[PilotSwitches.break1] = down THEN      Runtime.CallDebugger["Key Stop 1"L];    -- Move Germ (code and data) and most of Pilot resident code onto any    -- available non-PrincOps real memory (e.g. Dandelion display memory):    IF NOT SpecialSystem.isDiagnosticPilot THEN      BEGIN  --move germ to funny memory--      buffer: Space.Interval = Space.Allocate[count: 1];  -- (unmapped vm)      pageBuffer: Environment.PageNumber = Space.PageFromLongPointer[buffer.pointer];      RealMemory.MoveIntervalToDisplayMemory[  -- move and possibly reclaim the germ        page: Boot.pageGerm, count: Boot.countGermVM, bufferPage: pageBuffer];      MoveCodeToSpecialMemory[  -- move Kernel special code.        S.SpecialResidentCodeHandle, pageBuffer];      MoveCodeToSpecialMemory[  -- move Heads special code.        RealMemory.SpecialResidentCodeHandle, pageBuffer];      MoveCodeToSpecialMemory[  -- if any special memory remains, move more resident code        S.ResidentRunFastCodeHandle, pageBuffer];      Space.Deallocate[buffer];      IF System.switches[PilotSwitches.eatGerm] = down THEN        BEGIN  -- No germ. Reclaim patch table and disable maplogging:        patchTable: POINTER TO CPSwapDefs.PatchTable = Space.Pointer[	  PESV[].patchTable];	PESV[].patchTable ¬ NIL;        Frame.Free[patchTable];	MapLog.mapLogging ¬ FALSE;  -- Maplogging useless if no germ.	END;      END;  --move germ to funny memory--    END;  --OPEN StoragePrograms--    -- Make sure LocalTimeParameters are saved on nonvolatile storage:    [] ¬ System.GetLocalTimeParameters[      ! System.LocalTimeParametersUnknown => CONTINUE];    -- Initialize more of Misc configuration:     KernelPrograms.InitializeStream[];  -- (ByteBlt must preceed)    KernelPrograms.InitializeHeap[];  -- (Space must preceed)    RuntimePrograms.InitializeLoadStateB[];  -- (Heap must preceed)    RuntimePrograms.InitializeSnapshot[];  -- (Space must preceed)    DriverStartChain.Start[];  -- start drivers needing Heap and Space.    ProcessorFace.SetMP[PilotMP.cCommunication];    IF System.switches[PilotSwitches.noStartCommunication] = up      AND Runtime.IsBound[        LOOPHOLE[CommunicationPrograms.InitializeCommunication]] THEN      CommunicationPrograms.InitializeCommunication[];    IF Runtime.IsBound[LOOPHOLE[RuntimePrograms.InitializeRuntimeLoader]] THEN      RuntimePrograms.InitializeRuntimeLoader[];  -- Heap must preceed.    -- Ready to start the client. . .    ProcessorFace.SetMP[PilotMP.cClient];    Process.SetPriority[ProcessPriorities.priorityClient];    --  We always map log up to key stop 2. If told to disable maplogging,    --    we positively turn it off before starting the client.    IF System.switches[PilotSwitches.disableMapLog] = down THEN      MapLog.mapLogging ¬ FALSE;    IF System.switches[PilotSwitches.break2] = down THEN      Runtime.CallDebugger["Key Stop 2"L];    Process.Detach[FORK PilotClient.Run[]];    RETURN  -- This process vanishes.    END;  --StartPilot--  EnumerateStartList: PUBLIC --StoragePrograms.-- PROCEDURE [    proc: StoragePrograms.StartListProc] =    BEGIN    pEntry: LONG POINTER TO StartList.Entry ¬ @startList[StartList.StartIndex];    done:BOOLEAN ¬ FALSE;    UNTIL done DO        WITH e: pEntry SELECT FROM        space => 	  {done ¬ proc[pEntry]; pEntry ¬ pEntry + SIZE[space StartList.Entry]};        swapUnit => 	  {done ¬ proc[pEntry]; pEntry ¬ pEntry + SIZE[swapUnit StartList.Entry]};        stop => done ¬ TRUE;        ENDCASE => Bug[funnyStartlistEntry];      ENDLOOP;    END;  --~~~~~~~~~~ MapSwappableSpaces:  absoluteMaxSwapUnits: CARDINAL = 128;  SwapUnitIndex: TYPE = [0..absoluteMaxSwapUnits);  BlackHole: BackingStore.TransferProc --[transData] RETURNS [result]--  = {    -- "Swaps out" stuff by throwing it away.    -- This is the TransferProc for UtilityPilot ONLY.    SELECT transData.operation FROM      write => RETURN[[done[]]];  -- throw it away.      read => Bug[pageFaultOnInitializationCodeOrData];      ENDCASE => Bug[funnyCase]};  blackHoleData: BackingStore.Data =    -- [ALL[0]];  ++ TEMP until AR 12465 fixed.    [bunchOfZeroes];  bunchOfZeroes: ARRAY [0..7) OF WORD = [0, 0, 0, 0, 0, 0, 0];  MapSwappableSpaces: PROCEDURE[] =    -- Maps and maplogs all swappable spaces that were created    --   by MakeBoot and so are mapped to the boot file.    -- Handling of writable swappable spaces:    --   In regular Pilot, we actually map writable swappable spaces    --     to scratch backing storage and initialize the contents    --     from the boot file data.    --   In UtilityPilot, writable swappable spaces are mapped to the BlackHole,    --     and thus they can not write into and thus pollute the boot file.    BEGIN    swapUnitSizes:  -- scratch storage for MapSwappableSpace.      -- This causes a "large local frame". This seems an efficient and approriate use for one.      ARRAY SwapUnitIndex OF Space.SwapUnitSize;    MapSwappableSpace: StoragePrograms.StartListProc --[pEntry]--  =      -- Other actual arguments: swapUnitSizes of parent frame is used as scratch storage.      -- If this startList entry is a READONLY or RESIDENT swappable space (either      --   initiallyResident or initiallyOut), this proc Maps it.      -- This code uses a convenient feature of VM: A map unit may      --   have some of its pages swapped in when it is mapped.      BEGIN      space: LONG POINTER TO space StartList.Entry;  -- = @startList[pEntry]      pageNextMapped: Environment.PageNumber;      pageNextSwapUnit: Environment.PageNumber;      curSUIndex: SwapUnitIndex;      SwapUnitSizesOverflowed: ERROR = CODE;      FillInSwapUnitSizes: StoragePrograms.StartListProc --[pEntry]--  =        -- Other parameters: space, pageNextMapped, pageNextSwapUnit, curSUIndex, swapUnitSizes of parent frame.        -- Other results: curSUIndex, swapUnitSizesOverflowed,	-- swapUnitSizes[curSUIndex-1],         -- If this swap unit is the next one of the parent space "space",	-- fills in swapUnitSizes[curSUIndex], and updates curSUIndex	-- and pageNextSwapUnit.        -- EXCEPTION: If swapUnitSizes is full, SwapUnitSizesOverflowed	-- is raised.         BEGIN        -- Note: This implementation requires that a family is entirely	-- tiled with swap units (no holes), and that the swap unit        -- descriptors occur in ascending order in the start list.        WITH e: pEntry SELECT FROM          swapUnit =>            BEGIN            IF @startList[e.parent] # space THEN RETURN;	    IF space.vmpage + e.base < pageNextMapped THEN RETURN;            IF space.vmpage + e.base # pageNextSwapUnit THEN              Bug[swapUnitAbsentOrDescendingOrder];            IF curSUIndex >= maxSwapUnits THEN  --	      ERROR SwapUnitSizesOverflowed;  -- caller will do rest later.	    IF e.pages NOT IN CARDINAL THEN Bug[swapUnitTooBig]            ELSE swapUnitSizes[curSUIndex] ¬ CARDINAL[e.pages];            pageNextSwapUnit ¬ pageNextSwapUnit + e.pages;            curSUIndex ¬ SUCC[curSUIndex];            END;          space => RETURN;          ENDCASE => Bug[funnyStartlistEntry];        END;  --FillInSwapUnitSizes--      -- Begin main text of MapSwappableSpace:      WITH e: pEntry SELECT FROM        swapUnit => RETURN;        space =>          BEGIN  --space entry--          access: Space.Access;          swapUnits: Space.SwapUnitOption;          swappability: VM.Swappability;          countYetToMap: Environment.PageCount;          space ¬ @e;	  	  -- Get access and swap unit info (RETURN if resident):          WITH t: space.type SELECT FROM            empty => RETURN;            unitary => {              IF startList[t.swapUnit].info.state = resident THEN RETURN;              access ¬                IF startList[t.swapUnit].info.readOnly THEN readOnly                ELSE readWrite;	      swapUnits ¬	        IF System.switches[PilotSwitchesExtras.makeCodeOnePageSwapUnits] = down		  THEN [uniform[1]] ELSE [unitary[]]};            family =>              BEGIN              IF t.allResidentChildren THEN RETURN;              IF t.anyResidentDescriptorChildren                OR t.allResidentDescriptorChildren                OR (t.anyResidentChildren AND NOT t.allResidentChildren)                OR (t.anySwappableChildren AND NOT t.allSwappableChildren)                OR (t.anyReadOnlyChildren AND NOT t.allReadOnlyChildren) THEN                Bug[unimplementedStartListOptions];              access ¬ IF t.allReadOnlyChildren THEN readOnly ELSE readWrite;	      swapUnits ¬	        IF System.switches[PilotSwitchesExtras.makeCodeOnePageSwapUnits] = down		  THEN [uniform[1]] ELSE [irregular[DESCRIPTOR[swapUnitSizes]]];              END;            ENDCASE => Bug[funnySpaceType];          -- ASSERT: Space is swappable.          swappability ¬ swappable;          IF space.vmpage + space.pages > startList.lastVMPage + 1 THEN Bug[badStartList];                    pageNextMapped ¬ space.vmpage;          countYetToMap ¬ space.pages;          DO  --UNTIL whole of interval has been mapped--	    countMappedThisTime: Environment.PageCount ¬ countYetToMap;            IF swapUnits.swapUnitType = irregular THEN              BEGIN  --accumulate swap unit sizes for this map segment--              -- Set rest of parameters for FillInSwapUnitSizes:              pageNextSwapUnit ¬ pageNextMapped;              curSUIndex ¬ FIRST[SwapUnitIndex];              -- swapUnitSizesOverflowed ¬ FALSE;              EnumerateStartList[FillInSwapUnitSizes !                SwapUnitSizesOverflowed => {                  countMappedThisTime ¬                    pageNextSwapUnit - pageNextMapped;                  CONTINUE}];	      swapUnits ¬ [irregular[DESCRIPTOR[@swapUnitSizes[0], curSUIndex]]];              END;  --accumulate swap unit sizes for this map segment--            IF Volume.SystemID[] = Volume.nullID THEN              BEGIN  --no swappable anonymous backing storage--	      -- The swappable stuff in a Utility-Pilot boot file is:	      --   readOnly:  Initialization code.	      --   readWrite: There should be none. However, since MakeBoot does	      --     not yet allow us to make the load state resident, we must	      --     do it here. Also, there is also some other readWrite stuff	      --              due to a MakeBoot bug..	      -- When this stuff "swaps out", it is gone forever.              blackHoleRuns: ARRAY [0..1) OF BackingStore.Run;              blackHoleRuns[0] ¬ [	        count: countMappedThisTime, data: blackHoleData];              IF access = readOnly AND space.bootLoaded THEN  --                -- Account for MakeBoot-created reserved pages:		-- (do just before Map)                StoragePrograms.AddReservedMStore[countMappedThisTime];              VM.Map[                interval: [page: pageNextMapped, count: countMappedThisTime],		transferProc: BlackHole,                backingStoreRuns: DESCRIPTOR[blackHoleRuns],                usage: Space.unknownUsage, class: unknown, access: access,                swapUnits: swapUnits, life: alive, swappability: swappability];              BEGIN  -- TEMP until AR 4308 fixed.	      -- Pin the load state:              pageLoadState: Environment.PageNumber =                startList[startList[startList.initLoadState].parent].vmpage +                  startList[startList.initLoadState].base;              countLoadState: Environment.PageNumber =                startList[startList.initLoadState].pages;              IF System.isUtilityPilot OR SpecialSystem.isDiagnosticPilot AND                pageNextMapped = pageLoadState THEN                VM.MakeResident[[pageLoadState, countLoadState], wait];              END;  -- TEMP until AR 12747 fixed.              END  --no swappable anonymous backing storage--            ELSE              BEGIN  --has swappable anonymous backing storage--	      -- Readonly swappable spaces are mapped to boot file.	      -- Writable initially-in swappable spaces have their pages	      --   marked dirty and then are mapped to scratch storage.	      -- Writable initially-out swappable spaces are mapped to scratch	      --   storage, then initialized via CopyIn from the boot file.	      sourceWindow: Space.Window;  -- the data in the boot file.	      scratchWindow: Space.Window;  -- in case we copy the data.	      allocInterval, mapUnit: Space.Interval;	      IF space.backingStore # self THEN Bug[funnyStartlistEntry];	      sourceWindow ¬ [	        file: [request.location.diskFileID.fID.fileID, Volume.SystemID[]],	        base: request.location.diskFileID.firstPage +		  space.backingPage + (pageNextMapped - space.vmpage),		count: countMappedThisTime];	      scratchWindow ¬ [	        file: File.nullFile, base: NULL, count: countMappedThisTime];	      IF access = readWrite AND space.bootLoaded THEN  --	        -- We mark dirty all pages of a writable swappable boatloaded		-- space before mapping the space. This assures		-- that they will swap out to the new backing storage.	        BEGIN		FOR page: Environment.PageNumber IN [pageNextMapped..pageNextMapped+countMappedThisTime) DO		  -- We use ExchangeFlags to guarantee atomic access.		  oldState: PageMap.State = PageMap.ExchangeFlags[		    page, PageMap.flagsDirty].oldState;  -- (assumes unreferenced)		  IF oldState.flags = PageMap.flagsVacant THEN Bug[noPage];		  IF oldState.flags.readonly THEN Bug[startlistSaidWritable];		  ENDLOOP;		END;  --make pages dirty before mapping--	      allocInterval ¬ [	        pointer: Space.LongPointerFromPage[pageNextMapped],		count: countMappedThisTime];	        -- The VM was allocated during VMMgr Initialization              IF access = readOnly AND space.bootLoaded THEN  --                -- Account for MakeBoot-created reserved pages:		-- (do just before Map)                StoragePrograms.AddReservedMStore[countMappedThisTime];	      mapUnit ¬ Space.MapAt[	        at: allocInterval,	        window:		  IF access = readOnly THEN sourceWindow ELSE scratchWindow,		usage: Space.unknownUsage,  -- SHOULD COME FROM StartList!		class: globalFrame,  -- ASSUME. SHOULD COME FROM StartList!		access: access,		life: alive,  -- (ignored if scratchWindow)	        swapUnits: swapUnits];              IF access = readWrite AND NOT space.bootLoaded THEN	        BEGIN  --initialize space from boot file--	        -- At this point, the space is mapped to garbage. It is		-- essential that we not page fault on the space until		-- the following CopyIn is completed. Thus e.g. SpaceImpl's		-- global frame must be initially in.                [] ¬ Space.CopyIn[mapUnit.pointer, sourceWindow];		Space.Deactivate[mapUnit];		END;              END;  --has swappable anonymous backing storage--            pageNextMapped ¬ pageNextMapped + countMappedThisTime;            countYetToMap ¬ countYetToMap - countMappedThisTime;            --UNTIL-- IF countYetToMap = 0 THEN EXIT;            ENDLOOP;  --UNTIL whole of interval has been mapped--          END;  --space entry--        ENDCASE => Bug[funnyStartlistEntry];      END;  --MapSwappableSpace--    -- Begin main text of MapSwappableSpaces:    EnumerateStartList[MapSwappableSpace];    END;  --MapSwappableSpaces--  --~~~~~~~~~~ Other Procedures:  MoveCodeToSpecialMemory: PROCEDURE [    proc: --GENERIC-- PROCEDURE, pageBuffer: Environment.PageNumber] =    -- Exchanges any ordinary real pages, which are currently behind the swap    -- unit containing the code of the specified procedure, for any available    -- reserved real pages which are part of the Dandelion display memory.    -- Any recovered ordinary real pages are given to Pilot for general use.    BEGIN    procPage: Environment.PageNumber =  -- page containing first byte of proc's code.      Space.PageFromLongPointer[SpecialRuntime.Code[LOOPHOLE[proc]]];    procSwapUnit: VM.Interval ¬ VM.nullInterval;  -- swap unit containing proc.        FindSwapUnitContainingProc: StoragePrograms.StartListProc --[pEntry]--  =      -- Other arguments: procPage of parent frame.      -- Other results: procSwapUnit of parent frame.      BEGIN      WITH e: pEntry SELECT FROM        swapUnit =>          BEGIN          swapUnitPage: Environment.PageNumber = startList[e.parent].vmpage + e.base;          IF procPage IN [swapUnitPage .. swapUnitPage + e.pages) THEN            procSwapUnit ¬ [page: swapUnitPage, count: e.pages];          END;        ENDCASE => NULL;      END;  --FindSwapUnitContainingProc--        EnumerateStartList[FindSwapUnitContainingProc];    IF procSwapUnit.count = 0 THEN Bug[codeHandleNotFound];    RealMemory.MoveIntervalToDisplayMemory[      page: procSwapUnit.page, count: procSwapUnit.count, bufferPage: pageBuffer];    END;  -- When all else fails . . .  DieWithMPCode: PROCEDURE [c: PilotMP.Code] = INLINE {    ProcessorFace.SpecialSetMP[c]; DO ENDLOOP};  Bug: PROCEDURE [type: BugType] = {RuntimeInternal.Bug[type]};      <<    The following three procedures are used to distinguish between the    different flavors of Pilot.  When the packager is run, all but the    desired one of them is DISCARDed.  >>  IAmDiagnosticPilot: PROCEDURE = {};  IAmPilot: PROCEDURE = {};  IAmUtilityPilot: PROCEDURE = {};  -- Main Body code:  ProcessOperations.WriteWDC[1];  -- should be disabled already but just in case..  XferTrap.WriteXTS[off];  -- should be disabled already but just in case..  -- Clear return link so Processes can find top frame of this process and Detach it:  Frame.SetReturnLink[--PrincOps.--nullShortLink];  StartPilot[];  -- when returns, initial process vanishes.  END.LOG   (For earlier log entries, see Pilot 10.0 archive version.)13-Oct-82  9:44:46   WDK        Use new VM init facilities. Make compatible with new StoragePrograms.   Major rework. Now can get to debugger earlier.15-Oct-82 18:19:19   WDK     	Redo MoveCodeToSpecialMemory using StartList. 3-Nov-82 19:16:14   WDK     	Make compatible with new ResMemPerf.15-Dec-82 18:11:45   WDK     	Add regular-Pilot mapping code, convert off of NewSpace.22-Dec-82 13:22:50   AWL         Added IAm*Pilot and code to detect which one is present.   Misc fixes to make compile against NewP 4-Jan-83 11:28:03   JXP   	Modify Pilot type determination, catch unboundProc.18-Mar-83 10:10:26   WDK     	Make compatible with new StoragePrograms.26-Mar-83 12:03:34   JXP      Inside MapSwappableSpaces: 1) don't reallocate VM for Spaces, its done when   initializing the VMMgr, 2) set the correct number of swap units when mapping   irregular spaces, 3) IsUtilityPilot test => Do we have a system volume test.22-Apr-83  9:31:48   AWL         FillIn SwapUnits broke if the parent had more than maxSwapUnits swap units. 3-May-83 16:56:50   WDK        Must AddReserved for UtilityPilot too. Use actual length of load state.   Actually FORK PilotClient.17-May-83 11:48:14   JXG    	allow StartListProc to stop EnumerateStartList21-Jun-83 16:44:16   JXG    	changes to StartPilot for Pinning.12-Jul-83 15:09:52   WDK        Make compatible with new PrincOps, StoragePrograms, RuntimePrograms, and CPSwapDefs. Patch table now allocated from frame heap. Reclaim patch table and disable maplogging if no germ. Pass real memory for pda.12-Jul-83 15:09:52   WDK        Make compatible with new CPSwapDefs and RuntimeInternal.10-Aug-83 11:57:09   WDK        Make compatible with new RuntimePrograms and StoragePrograms. Deal with swappable load state in UtilityPilot.30-Sep-83 16:40:57   CAJ    Add bootswitch to cause code to be mapped with one page swap units.22-Aug-84 19:09:50   KEK       Add InitializePCMemory call (for PC emulation).29-May-85 15:36:54   AWL       Export, and set, StoragePrograms.pilotType. 1-Jul-86 17:16:31   MEW   Updated to newest princops.
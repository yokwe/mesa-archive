-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- ElevatorSchedulerImpl.mesa (last edited by: KAM      on: 29-May-84 12:36:06)DIRECTORY  DiskChannel USING [DiskPageNumber, Drive],  DiskScheduler USING [    CalculatePageAddress, DriveProc, GetNextRequestProc, RequestHandle,    Scheduler, ScheduleProc, Transition, TransitionProc],  ElevatorScheduler USING [],  Environment USING [Base, first64K],  ProcessOperations USING [],  ResidentHeap USING [FreeNode, MakeNode],  RuntimeInternal USING [Bug],  SpecialSpace USING [    MakeGlobalFrameResident, MakeGlobalFrameSwappable, MakeProcedureResident,    MakeProcedureSwappable, SpecialError],  Zone USING [Status];ElevatorSchedulerImpl: PROGRAM  IMPORTS DiskScheduler, ResidentHeap, RuntimeInternal, SpecialSpace  EXPORTS ElevatorScheduler =  BEGIN  RequestHandle: TYPE = DiskScheduler.RequestHandle;  Queue: TYPE = LONG POINTER TO QueueObject;  QueueObject: TYPE = MACHINE DEPENDENT RECORD [    thisPass(0), nextPass(1): RequestHandle,    lastCylinderAccessed(2): DiskChannel.DiskPageNumber,    drive(4): DiskChannel.Drive,    rpQueue(6): Environment.Base RELATIVE POINTER];  BugType: TYPE = {impossibleCase, residentHeapError};  -- PUBLIC procedure and variables  numberScheduledThisPass, numberScheduledNextPass: PUBLIC LONG CARDINAL ¬ 0;  scheduler: PUBLIC DiskScheduler.Scheduler = [    Transition, Drive, Schedule, GetNextRequest];  -- PRIVATE procedures  Bug: PROCEDURE [type: BugType] = {RuntimeInternal.Bug[type]};  Drive: DiskScheduler.DriveProc =    -- PROCEDURE [    --   drive: LONG POINTER TO DriveData, reason: CallReason,    --   channelDrive: DiskChannel.Drive]    BEGIN    rp: Environment.Base RELATIVE POINTER;    status: Zone.Status;    SELECT reason FROM      start =>        BEGIN	[rp, status] ¬ ResidentHeap.MakeNode[SIZE[QueueObject], a1];	IF status # okay THEN Bug[residentHeapError];	drive­ ¬ @Environment.first64K[rp];	LOOPHOLE[drive, LONG POINTER TO Queue]­­ ¬ [	  NIL, NIL, 0, channelDrive, rp];	END;      newCC => NULL;      stop =>        BEGIN	queue: Queue ¬ LOOPHOLE[drive, LONG POINTER TO Queue]­;	status ¬ ResidentHeap.FreeNode[queue.rpQueue];	IF status # okay THEN Bug[residentHeapError];	END;      ENDCASE => Bug[impossibleCase];    END;  GetNextRequest: DiskScheduler.GetNextRequestProc =    -- PROCEDURE [drive: LONG POINTER TO DriveData] RETURNS [req: RequestHandle]    BEGIN    queue: Queue ¬ LOOPHOLE[drive, LONG POINTER TO Queue]­;    IF (req ¬ queue.thisPass) # NIL THEN      BEGIN      queue.lastCylinderAccessed ¬ req.client;      IF req.next # NIL THEN queue.thisPass ¬ req.next      ELSE {queue.thisPass ¬ queue.nextPass; queue.nextPass ¬ NIL};      END;    RETURN[req];    END;  IncrNextPassCount: PROCEDURE = INLINE {    numberScheduledNextPass ¬ SUCC[numberScheduledNextPass]};  IncrThisPassCount: PROCEDURE = INLINE {    numberScheduledThisPass ¬ SUCC[numberScheduledThisPass]};  Schedule: DiskScheduler.ScheduleProc =    -- PROCEDURE [drive: LONG POINTER TO DriveData, req: RequestHandle]    BEGIN    Direction: TYPE = PROCEDURE [a, b: RequestHandle] RETURNS [BOOLEAN];    Incr: Direction = {RETURN[a.client < b.client]};    Decr: Direction = {RETURN[a.client > b.client]};    Insert: PROCEDURE [order: Direction, in: LONG POINTER TO RequestHandle] =      BEGIN      IF in­ = NIL OR order[req, in­] THEN {req.next ¬ in­; in­ ¬ req; RETURN};      FOR at: RequestHandle ¬ in­, at.next UNTIL at.next = NIL DO        IF order[req, at.next] THEN {req.next ¬ at.next; at.next ¬ req; RETURN};        REPEAT FINISHED => {req.next ¬ NIL; at.next ¬ req};        ENDLOOP;      END;    queue: Queue ¬ LOOPHOLE[drive, LONG POINTER TO Queue]­;    req.client ¬ DiskScheduler.CalculatePageAddress[      queue.drive, req.iorh.diskPage].cylinder;    SELECT TRUE FROM      queue.thisPass = NIL => {queue.thisPass ¬ req; IncrThisPassCount[]};      queue.lastCylinderAccessed <= queue.thisPass.client =>        IF req.client >= queue.lastCylinderAccessed THEN {          Insert[Incr, @queue.thisPass]; IncrThisPassCount[]}        ELSE {Insert[Decr, @queue.nextPass]; IncrNextPassCount[]};      ENDCASE =>        IF req.client >= queue.lastCylinderAccessed THEN {          Insert[Incr, @queue.nextPass]; IncrNextPassCount[]}        ELSE {Insert[Decr, @queue.thisPass]; IncrThisPassCount[]};    END;  Transition: DiskScheduler.TransitionProc =    -- PROCEDURE [type: Transition]    BEGIN    SELECT type FROM      start =>         BEGIN	SpecialSpace.MakeGlobalFrameResident[ElevatorSchedulerImpl !	  SpecialSpace.SpecialError => CONTINUE];	SpecialSpace.MakeProcedureResident[LOOPHOLE[GetNextRequest] !	  SpecialSpace.SpecialError => CONTINUE];	SpecialSpace.MakeProcedureResident[LOOPHOLE[Schedule] !	  SpecialSpace.SpecialError => CONTINUE];	END;      stop =>          BEGIN	SpecialSpace.MakeGlobalFrameSwappable[ElevatorSchedulerImpl !	  SpecialSpace.SpecialError => CONTINUE];	SpecialSpace.MakeProcedureSwappable[LOOPHOLE[GetNextRequest] !	  SpecialSpace.SpecialError => CONTINUE];	SpecialSpace.MakeProcedureSwappable[LOOPHOLE[Schedule] !	  SpecialSpace.SpecialError => CONTINUE];	END;      ENDCASE;    END;  END...
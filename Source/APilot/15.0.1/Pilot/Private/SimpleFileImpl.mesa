-- Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989  by Xerox Corporation and Fuji Xerox Co. Ltd. All rights reserved. -- SimpleFileImpl.mesa      11-Apr-89 11:58:21 by TxH    -- The module MONITOR only protects the marker page buffer used by the-- various Reconstruct and Update Procs.DIRECTORY  Boot USING [    BootFileDescriptorPageHandle, BootFileDescriptorPageSeal,    BootFileDescriptorPageVersion],  DataTransfer USING [ReadData],  DiskBackingStore USING [ChannelHandle, Data, UnpackFilePageNumber],  DiskChannel,  Environment USING [PageCount, PageNumber],  ETable USING [    Error, GetFileAttributes, GetPageGroup, InsertPageGroup, ShrinkLastPageGroup],  File USING [File, ID, PageCount, PageNumber, Type, Unknown],  FileBasicsPerf USING [],  FileBasicsPrograms USING [],  FileLock USING [GetLockHandleFromFileID, IsLocked, lockingEnabled,  DiscardLockAndVMData--**--],  FileInternal USING [MakeUnbootableInternal],  Inline,  KernelFile USING [FilePtr, Descriptor, PageGroup],  KernelSpaceUsage USING [markerPage],  LogicalVolumeFormat USING [Handle, nullVolumePage],  PhysicalVolumeFormat USING [MarkerHandle],  ProcessOperations,  ResidentHeap,  RuntimeInternal USING [Bug],  SimpleFile USING [],  Space USING [    Allocate, Deallocate, Error, LongPointerFromPage, PageFromLongPointer],  SpecialFile USING [InvalidParameters],  StoragePrograms USING [AllocateVM],  TemporaryBootingExtras USING [BootableFileError],  VM USING [Interval, nullInterval, ScratchMap, Unmap],  VolAllocMap USING [AllocPageGroup, FreePageGroup],  VolTable USING [    GetLVStatus, FindSV, LVAccess, LVAccessProc, MapMarkerPage, LVToken, SVAccess,    SVAccessProc, SVDesc, SVToken, UnmapMarkerPage],  Volume USING [ID, InsufficientSpace, PageNumber];SimpleFileImpl: MONITOR  IMPORTS    DataTransfer, DiskBackingStore, ETable, File, FileInternal, FileLock,    RuntimeInternal, Space, SpecialFile, StoragePrograms, TemporaryBootingExtras,    VolAllocMap, VolTable, Volume, VM  EXPORTS FileBasicsPerf, FileBasicsPrograms, SimpleFile  SHARES SimpleFile =  BEGIN   OPEN PVF: PhysicalVolumeFormat;  -- Buffer for accessing marker pages   marker: PVF.MarkerHandle = Space.LongPointerFromPage[    StoragePrograms.AllocateVM[    1, hyperspace, KernelSpaceUsage.markerPage, partiallyOrSometimesMapped]];  BugType: TYPE = {    clientError, fileSystemInconsistency, impossibleEndcase, programmingError};  setSizeRequests: PUBLIC LONG CARDINAL ¬ 0;  -- exported to FileBasicsPerf, counts number of requests to change the  -- size of a file.  InitSimpleFile: PUBLIC --FileBasicsPrograms.-- PROCEDURE = {};  GetAttributes: PUBLIC PROCEDURE [file: File.File]    RETURNS [type: File.Type, temporary: BOOLEAN] =    BEGIN    LockAndGetAttributes: VolTable.LVAccessProc --[tok, lvHandle]--  = {      [type: type, temporary: temporary] ¬        GetAttributesInternal[file, lvHandle, tok]};    VolTable.LVAccess[file.volumeID, LockAndGetAttributes, read, open];    END;  GetAttributesInternal: PROCEDURE [    file: File.File, lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken]    RETURNS [type: File.Type, temporary: BOOLEAN] =    BEGIN    found: BOOLEAN;    fileDesc: KernelFile.Descriptor;    found ¬ GetFileDescriptor[file, lvHandle, tok, @fileDesc].found;    IF ~found THEN ERROR File.Unknown[file];    RETURN[type: fileDesc.type, temporary: fileDesc.temporary];    END;  GetBackingStoreData: PUBLIC PROCEDURE [    file: File.ID, lvHandle: LogicalVolumeFormat.Handle,    filePage: File.PageNumber, type: File.Type, tok: VolTable.LVToken]    RETURNS [fileData: DiskBackingStore.Data, runLength: File.PageCount,      resultType: File.Type] =    BEGIN    success: BOOLEAN;    sv: VolTable.SVDesc;    group: KernelFile.PageGroup;    size: File.PageCount;    WITH d: fileData SELECT FileLock.lockingEnabled FROM      TRUE => d.lock ¬ FileLock.GetLockHandleFromFileID[			 [file, lvHandle.vID], filePage];                       -- may find that really want to return		       -- FileLock.nullLockHandle instead                       -- for efficiency reasons.      FALSE => d.file ¬ file;      ENDCASE;    [fileSize: size, temporary: fileData.fileAttributes.temporary,      type: fileData.type] ¬ ETable.GetFileAttributes[tok, file !        ETable.Error => IF error = fileNotFound THEN	  ERROR File.Unknown[[file, lvHandle.vID]]];    IF filePage >= size THEN      ERROR SpecialFile.InvalidParameters;    [readOnly: fileData.fileAttributes.readOnly] ¬      VolTable.GetLVStatus[lvHandle.vID];    [fileData.filePageLow, fileData.filePageHigh] ¬      DiskBackingStore.UnpackFilePageNumber[filePage];    [found: success, group: group] ¬ ETable.GetPageGroup[tok, file, filePage];    IF ~success THEN Bug[fileSystemInconsistency];    [found: success, channel: fileData.channelHandle] ¬ VolTable.FindSV[      lvHandle.vID, group.volumePage, @sv];    IF ~success THEN Bug[fileSystemInconsistency];    fileData.volumePage ¬      sv.pvPageOfSV + group.volumePage + (filePage - group.filePage);    RETURN[fileData, group.nextFilePage - filePage, fileData.type]    END;  --GetBackingStoreData--  GetFileDescriptor: PUBLIC PROCEDURE [    file: File.File, lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken,    fileDescPtr: KernelFile.FilePtr] RETURNS [found: BOOLEAN] =    BEGIN    found ¬ TRUE;    fileDescPtr.fileID ¬ file.fileID;    fileDescPtr.volumeID ¬ file.volumeID;    [fileSize: fileDescPtr.size, temporary: fileDescPtr.temporary,      type: fileDescPtr.type] ¬ ETable.GetFileAttributes[tok, file.fileID !        ETable.Error => IF error = fileNotFound THEN	  BEGIN	  found ¬ FALSE;	  CONTINUE;	  END];    RETURN[found];    END;  --GetFileDescriptor--  GetPageGroup: PUBLIC PROCEDURE [    lvHandle: LogicalVolumeFormat.Handle, fileDescPtr: KernelFile.FilePtr,    page: File.PageNumber, tok: VolTable.LVToken]    RETURNS [found: BOOLEAN, group: KernelFile.PageGroup] =    BEGIN    [found, group] ¬ ETable.GetPageGroup[      token: tok, fileID: fileDescPtr.fileID, filePage: page];    END;  --GetPageGroup--  GetSize: PUBLIC PROCEDURE [file: File.File] RETURNS [size: File.PageCount] =    BEGIN    GetSizeProc: VolTable.LVAccessProc = {      size ¬ GetSizeInternal[file, lvHandle, tok]};    VolTable.LVAccess[      lvID: file.volumeID, proc: GetSizeProc, lock: read, entryState: open];    END;  GetSizeInternal: PUBLIC PROCEDURE [    file: File.File, handle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken]    RETURNS [size: File.PageCount] =    BEGIN    bootable: BOOLEAN;    [fileSize: size, bootable: bootable] ¬      ETable.GetFileAttributes[tok, file.fileID !         ETable.Error => IF error = fileNotFound THEN ERROR File.Unknown[file]];    IF bootable THEN      BEGIN      desc: Boot.BootFileDescriptorPageHandle ¬ Space.Allocate[1].pointer;      descSize: CARDINAL;      group: KernelFile.PageGroup ¬ ETable.GetPageGroup[        token: tok, fileID: file.fileID, filePage: size - 1].group;      VM.ScratchMap[[Space.PageFromLongPointer[desc], 1]];      [] ¬ DataTransfer.ReadData[volume: file.volumeID,        volumePage: group.volumePage + (size - 1 - group.filePage),	memoryPage: Space.PageFromLongPointer[desc], handleErrors: TRUE,	tok: tok];      descSize ¬ desc.header.totalDescriptorPages;      IF desc.header.seal ~= Boot.BootFileDescriptorPageSeal OR        desc.header.version ~= Boot.BootFileDescriptorPageVersion	  THEN descSize ¬ 0;  -- ignore bootable in this case      size ¬ size - descSize;      VM.Unmap[Space.PageFromLongPointer[desc]];      Space.Deallocate[[desc, 1]];      END;    RETURN[size];    END;  SetSize: PUBLIC PROCEDURE [    file: File.File, size: File.PageCount, data: VM.Interval] =    BEGIN    SetSizeAccessProc: VolTable.LVAccessProc --[tok, lvHandle]-- =      BEGIN      bootable: BOOLEAN;      fileDesc: KernelFile.Descriptor;      fileDesc.fileID ¬ file.fileID;      fileDesc.volumeID ¬ file.volumeID;      [fileSize: fileDesc.size, temporary: fileDesc.temporary,        bootable: bootable, type: fileDesc.type]  ¬ ETable.GetFileAttributes[	  tok, file.fileID ! ETable.Error => IF error = fileNotFound THEN	    ERROR File.Unknown[file]];      IF bootable THEN fileDesc.size ¬ FileInternal.MakeUnbootableInternal[        tok: tok, file: file, fileSize: fileDesc.size, type: fileDesc.type,	lvHandle: lvHandle	! TemporaryBootingExtras.BootableFileError =>	  ERROR SpecialFile.InvalidParameters];      SetSizeInternal[fileDesc, lvHandle, size, tok, data];      END;    VolTable.LVAccess[  -- Lock the Volume and do the SetSize.      lvID: file.volumeID, proc: SetSizeAccessProc, lock: write,      entryState: open];    END;  SetSizeInternal: PUBLIC PROCEDURE [    fileD: KernelFile.Descriptor, vol: LogicalVolumeFormat.Handle,    size: File.PageCount, tok: VolTable.LVToken, data: VM.Interval] =    -- clients MUST now have fileD.type set coming into this procedure.    BEGIN        IF ETable.GetFileAttributes[tok, fileD.fileID      ! ETable.Error => IF error = fileNotFound THEN          ERROR File.Unknown[[fileD.fileID, fileD.volumeID]]]      .bootable THEN ERROR SpecialFile.InvalidParameters;              SELECT TRUE FROM      fileD.size < size => {  -- The file is growing.        GrowFile[fileD, vol, size, tok, data];	setSizeRequests ¬ SUCC[setSizeRequests]};	      fileD.size > size => {  -- File is shrinking.        IF data.count > 0 THEN Bug[clientError];		IF FileLock.IsLocked[[fileD.fileID, fileD.volumeID],	  size, checkPageAndAbove] # notLocked THEN {    -- * now the file is locked.    -- * check if it's possible, then we do shrink the file and also it's vm.          IF NOT FileLock.DiscardLockAndVMData[	    [fileD.fileID, fileD.volumeID],size] THEN	      ERROR Space.Error[stillMapped]}; 	      -- * not locked            ShrinkFile[fileD, vol, size, tok];	setSizeRequests ¬ SUCC[setSizeRequests]};      ENDCASE => NULL;  -- Size is correct.    END;  --SetSizeInternal--  RealUpdateLogicalMarkerPages: PUBLIC ENTRY PROCEDURE [    lvHandle: LogicalVolumeFormat.Handle] =    BEGIN    sv: VolTable.SVDesc;    lvPage: LONG CARDINAL ¬ 0;    UpdateInternal: VolTable.SVAccessProc =      --[tok: SVToken, markerPageLoc: PVF.PageNumber]--      BEGIN      VolTable.MapMarkerPage[tok: tok, markerPage: marker];      marker.logical.bootingInfo ¬ lvHandle.bootingInfo;      marker.logical.volumeRootDirectory ¬ lvHandle.volumeRootDirectory;      marker.logical.labelLength ¬ lvHandle.labelLength;      marker.logical.type ¬ lvHandle.type;      marker.logical.label ¬ lvHandle.label;      marker.logical.primaryETableStartPage ¬ lvHandle.primaryETableStartPage;      marker.logical.copyETableStartPage ¬ lvHandle.copyETableStartPage;      marker.logical.statusPrimaryETableFile ¬ lvHandle.statusPrimaryETableFile;      marker.logical.statusCopyETableFile ¬ lvHandle.statusCopyETableFile;      VolTable.UnmapMarkerPage[tok, marker];      END;    WHILE lvPage < lvHandle.volumeSize DO      [] ¬ VolTable.FindSV[lvHandle.vID, lvPage, @sv];      VolTable.SVAccess[        pvID: sv.pvID, lvID: lvHandle.vID, lvPage: lvPage, proc: UpdateInternal,        lock: write];      lvPage ¬ sv.svLength;      ENDLOOP;    END;  --========== Internal Procedures. Used to perform auxiliary functions  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  GrowFile: PROCEDURE [    fileD: KernelFile.Descriptor, vol: LogicalVolumeFormat.Handle,    size: File.PageCount, tok: VolTable.LVToken, data: VM.Interval] =    BEGIN    found: BOOLEAN;    group: KernelFile.PageGroup;    originalSize: File.PageCount ¬ fileD.size;    remainingData: VM.Interval ¬ data;    -- ~~~~ NOTE: modifies local copy of fileD. ~~~~    IF vol.freePageCount < (size - originalSize)      THEN ERROR Volume.InsufficientSpace[vol.freePageCount, fileD.volumeID];    -- updates fileD.type    [found: found, group: group] ¬      ETable.GetPageGroup[tok, fileD.fileID, fileD.size - 1];    IF ~found THEN Bug[fileSystemInconsistency];    WHILE fileD.size < size DO      amountAllocdThisTime: File.PageCount;      -- following needed to avoid Mesa order of computation problems for       -- assignment to group.      tempVolumePage: Volume.PageNumber ¬         group.volumePage + (group.nextFilePage - group.filePage);      tempNextFilePage: File.PageNumber ¬ group.nextFilePage;      group ¬ [        filePage: tempNextFilePage,        volumePage: tempVolumePage,        nextFilePage: size];      VolAllocMap.AllocPageGroup[        vol, @fileD, @group, remainingData, tok        -- AllocPageGroup changes the page group (volumePage and nextFilePage)        -- and the fileDesc (the size).        ! Volume.InsufficientSpace => {          ShrinkFile[fileD, vol, originalSize, tok]; REJECT}];      amountAllocdThisTime ¬ group.nextFilePage - group.filePage;      ETable.InsertPageGroup[        tok, fileD.fileID, @group !        Volume.InsufficientSpace => {          VolAllocMap.FreePageGroup[vol, @fileD, @group, tok];          ShrinkFile[fileD, vol, originalSize, tok];          REJECT}];      SELECT TRUE FROM        remainingData.count = 0 => NULL;  -- remainingData = VM.nullInterval	remainingData.count > amountAllocdThisTime =>	  remainingData ¬ [remainingData.page + amountAllocdThisTime,	    remainingData.count - amountAllocdThisTime];	ENDCASE => -- remainingData.count <= amountAllocdThisTime	  remainingData ¬ VM.nullInterval;      ENDLOOP;    END;  --GrowFile--  ShrinkFile: PROCEDURE [    fileD: KernelFile.Descriptor, vol: LogicalVolumeFormat.Handle,    size: File.PageCount, tok: VolTable.LVToken] =    BEGIN    group: KernelFile.PageGroup;    -- NOTE: ~~~~~~ Local copy of fileD is modified. ~~~~~~    WHILE fileD.size > size DO      group ¬ [size, LogicalVolumeFormat.nullVolumePage, fileD.size];      ETable.ShrinkLastPageGroup[tok, fileD.fileID, @group];  -- Modifies group.      IF group.volumePage = LogicalVolumeFormat.nullVolumePage THEN        fileD.size ¬ group.filePage      ELSE        VolAllocMap.FreePageGroup[          vol, @fileD, @group, tok  -- Changes fileD.size          ! ANY => Bug[fileSystemInconsistency]];      ENDLOOP;    END;  END.LOG11-Oct-82 15:19:22   JXP      Create File for Klamath. Pulled pieces primarily from MarkerPageImpl and   FileImpl (see 8.0 archive versions of those files).30-Nov-82 11:19:36   JXP      Add the implementation of GetSize and GetAttributes. Export FileBasicsPerf   and FileBasicsPrograms. Add new consistency checks, Change GetBSData to   expect a locked entry. Add GetPageGroup[] and GetFileDescriptor[]. SHARE   SimpleFile. Export RealUpdate?MarkerPages[]. Use File.File.14-Dec-82 10:48:29   JXP      Various twiddles. Add ReadLabel nested procedure to GetFileDescriptor.23-Dec-82 10:32:00   AWL      	File.nullID never referenced.15-Feb-83 11:07:18   WDK        Deleted CreateMarkerPage. GetFileDescriptor looked for wrong file. GetBackingStoreData returned first of group, not first page requested. Split out GetAttributesInternal. 1-Mar-83 10:43:22   JXP      Don't use GetFileDescriptor to find the size of a file. It does too much   (reads the disk). Modify GetBackingStoreData to match new interface.   Only do a GetAttributesInternal if its page 0 or no type was supplied. 9-May-83 11:13:24   JXP      Update Markers Routines should update more fields (label, labelLength   and type for LV's).10-May-83 11:12:43   JXP      Read file type from label of specified page in GetBackingStoreData. Fix   problem in GetFileDescriptor wrt files missing page 0.10-Jun-83 10:31:26   JXP      Fix GrowFile so that it doesn't screw up when nullInterval is passed in   and we must grow the file in more than one piece.16-Jun-83 11:01:11   JXP      Get file type from the B-Tree in GetBackingStoreData.23-Aug-83 10:42:57   JXP      Be prepared to raise File.MissingPages instead of File.Unknown in   GetBSData. 4-Sep-83 14:36:47   JXP   	Twiddles to GetBSData.14-Nov-83 13:54:26   WDK        Improve documentation of GetPageGroup. GetPageGroup now searches for group.nextFilePage rather than infinity. Make SetSize faster by avoiding GetFileDescriptor.29-Mar-84 11:54:23   KEK       AR 5801 fileData.fileAttributes.readOnly not set.23-Jan-85 21:34:02   CJS       AR 6275 twiddle calls to VolTable.FindSV.23-Apr-86  9:10:44   RSV   Added slop parameter to call to AllocPageGroup in GrowFile.  Also fixed AR 9325 in GrowFile (Mesa order of computation problem). 2-Jun-86 16:26:35   RSV   Back out of above change involving slop parameter 5-Jun-86 13:35:25   RSV   Added CHANGE comments.  Changed RealUpdateLogicalMarkerPages to include updating ETable file starts and status bytes.  Deleted ReadLabel and HandleBSError procedures.  Modified GetFileDescriptor to not rely upon labels.  Added check for bootable in SetSizeInternal.  Changed GetBackingStoreData, GetFileDescriptor, GetPageGroup, GetSizeInternal, SetSize, SetSizeInternal, GrowFile, and ShrinkFile to not use labels and the VFM.16-Jun-86 14:14:01   RSV   Fixed AR 6930 in GrowFile which could fail if contents were supplied.18-Jun-86 15:58:34   RSV   Set fileDesc.{temporary, type} in addition to size in SetSizeAccessProc. 7-Jul-86 16:52:10   RSV   Modified SetSize to only use write flag and modified GrowFile to not use LogicalVolumeFormat.FreeVolumePages. 6-Aug-86 11:13:53   RSV   Temporarily re-added writeWithChangingFlag to SetSize 7-Oct-86  8:30:43   CAJ   Make GetSize exclude descriptor size for bootable files.  Now ok to update new markerPage fields in RealUpdateLogicalMarkerPages.17-Nov-86 14:38:39   RSV   Changed GetBackingStoreData for file locking. 4-Dec-86 17:29:21   RSV   Added check if file being shrunk is still mapped. 8-Jan-87 22:40:07   RSV   Deleted last of CHANGE comments.  No code changes  9-Jan-87 14:48:00   RRR   Made changes necessary to enable move of lv root page.20-Feb-87 11:40:26   RSV   Added raising TemporaryBootingExtras.Error[alreadyBootable] instead of Bug[clientError].12-Mar-87 10:49:19   RSV/RRR   Delete PV Marker page references. Raise Space.Error[stillMapped] instead of Bug[clientError] when shrinking file which is mapped.27-Jun-87  9:41:04   CAJ   SetSize now makes a bootable file unbootable and setsizes instead of raising BootableFileError[alreadyBootable].  SetSizeInternal raises InvalidParameters if handed a bootable file.30-Jun-88 17:04:54   RSV   SetSize now uses write instead of writeWithChangingFlag.29-Jul-88 18:57:36   RSV   Fix to GetBackingStoreData to disable file locking.11-Apr-89 11:58:19   TxH  Added FileLock.DiscardLockAndVMData in SetSizeInternal. (SS-FX: AR#6, AR#26)
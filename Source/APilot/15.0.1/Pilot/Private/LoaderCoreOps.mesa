-- File: LoaderCoreOps.mesa - Last edit:-- JGS & ET              19-Jun-86  7:44:54-- Copyright (C) 1983, 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [CTIndex, IMPIndex, Portable, VersionStamp],  BcdOps USING [BcdBase, EXPHandle, SGHandle],  ControlModuleFormat USING [Finger, Fingers, List],  LoadedMem USING [Interval, TargetLongAddress],  LoadState USING [BcdInfoIndex, LPBcdInfoTable, ModuleInfoSequenceHandle],  LoadStateFormat USING [Handle, ModuleInfo],  PrincOpsExtras2 USING [GFTHandle, ImportLink];LoaderCoreOps: DEFINITIONS =   BEGIN    -- Remembered information about loaded Bcds    CodeSetData: TYPE = RECORD [interval: LoadedMem.Interval];  CodeSetRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[CodeSetData]);  CodeSetSequence: TYPE = RECORD [SEQUENCE length: CodeSetRange OF CodeSetData];  CodeSetSequenceHandle: TYPE = LONG POINTER TO CodeSetSequence;    WheresTheStorage: TYPE = {mds, vm};  BcdExtraData: TYPE = RECORD [    bootLoaded: BOOLEAN ¬ FALSE,    resolved: BOOLEAN ¬ FALSE,    frames: GFSequenceHandle ¬ NIL,    codeSets: CodeSetSequenceHandle ¬ NIL,    storage: RECORD[mds, vm: LoadedMem.TargetLongAddress ¬ NIL],    framePack: FramePackSequenceHandle ¬ NIL,    fingers: ControlModuleFormat.Fingers ¬ NIL,    nFingers: CARDINAL ¬ 0];  BcdExtraRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[BcdExtraData] - 1);  BcdExtraSequence: TYPE =     RECORD [      length: CARDINAL ¬ 0,      body: SEQUENCE maxLength: BcdExtraRange OF BcdExtraData];  BcdExtraSequenceHandle: TYPE = LONG POINTER TO BcdExtraSequence;  ExportRecord: TYPE = RECORD [    name: LONG STRING,    multipleExporters: BOOLEAN,    port: BcdDefs.Portable,    version: BcdDefs.VersionStamp,    links: ImportLinkSequenceHandle];    ERHandle: TYPE = LONG POINTER TO ExportRecord;  ERIndex: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[ExportRecord] - 1);  ERSequence: TYPE = RECORD [    length: ERIndex,    seq: SEQUENCE maxLength: ERIndex OF ExportRecord];  ERSequenceHandle: TYPE = LONG POINTER TO ERSequence;    ERIndexSequence: TYPE = RECORD [    length: ERIndex,    seq: SEQUENCE maxLength: ERIndex OF CARDINAL];  ERIndexSequenceHandle: TYPE = LONG POINTER TO ERIndexSequence;    Binding: TYPE = RECORD [    impi: BcdDefs.IMPIndex,    erIndex: CARDINAL];  BindingRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[Binding]);  BindingSequence: TYPE = RECORD [SEQUENCE length: BindingRange OF Binding];  BindingSequenceHandle: TYPE = LONG POINTER TO BindingSequence;    -- Principal Data Structure:    -- The following data structure is used by all parts of LoaderCoreImpl  -- to keep track of the bcd being loaded.  LoadInfoData: TYPE = RECORD [    -- This transient data structure describes stuff being loaded. Besides being    -- an accelerator, it allows us to back out of aborted load operations.    module: ModuleSequenceHandle ¬ NIL,    codeSeg: CodeSegSequenceHandle ¬ NIL,    config: ConfigSequenceHandle ¬ NIL];  LoadInfoHandle: TYPE = LONG POINTER TO LoadInfoData;  CodeSegData: TYPE = RECORD [ -- A code segment being loaded.    -- Note that there other, non-code segments in the bcd's Segment Table.    sgh: BcdOps.SGHandle,    address: LoadedMem.TargetLongAddress];  CodeSegRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[CodeSegData]);  CodeSegSequence: TYPE = RECORD [SEQUENCE length: CodeSegRange OF CodeSegData];  CodeSegSequenceHandle: TYPE = LONG POINTER TO CodeSegSequence;  ConfigData: TYPE = RECORD [  -- A config being loaded.    controlCti: BcdDefs.CTIndex,  -- control config of this config    list: ControlModuleFormat.List,    finger: ControlModuleFormat.Finger];  ConfigRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[ConfigData]);  ConfigSequence: TYPE = RECORD [  -- In bcd's Configuration Table order.    SEQUENCE length: ConfigRange OF ConfigData];  ConfigSequenceHandle: TYPE = LONG POINTER TO ConfigSequence;  FramePackData: TYPE = RECORD [  -- A frame pack being loaded.    storage: LoadedMem.TargetLongAddress,    smallFrame: BOOLEAN,    wheresTheStorage: WheresTheStorage];  FramePackRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[FramePackData]);  FramePackSequence: TYPE = RECORD [    SEQUENCE length: FramePackRange OF FramePackData];  FramePackSequenceHandle: TYPE = LONG POINTER TO FramePackSequence;  ModuleData: TYPE = RECORD [  -- A module being loaded.    info: LoadStateFormat.ModuleInfo,    actualLinkLoc: ActualLinkLoc];  ModuleRange: TYPE = CARDINAL[0..(LAST[CARDINAL])/SIZE[ModuleData]);  ModuleSequence: TYPE = RECORD [  -- In bcd's Module Table order.    SEQUENCE length: ModuleRange OF ModuleData];  ModuleSequenceHandle: TYPE = LONG POINTER TO ModuleSequence;  GFSequence: TYPE = RECORD [  -- In bcd's Module Table order.    SEQUENCE length: NATURAL OF PrincOpsExtras2.GFTHandle];  GFSequenceHandle: TYPE = LONG POINTER TO GFSequence;  -- Other local types:  BindingAction: TYPE = {bind, unbind};  ActualLinkLoc: TYPE = {codeLinks, frameLinks};  ImportLinkRange: TYPE =    CARDINAL[0..(LAST[CARDINAL])/SIZE[PrincOpsExtras2.ImportLink]);  ImportLinkSequence: TYPE = RECORD [    SEQUENCE length: ImportLinkRange OF PrincOpsExtras2.ImportLink];  ImportLinkSequenceHandle: TYPE = LONG POINTER TO ImportLinkSequence;  maxPagesInCodeSet: CARDINAL = 256;    Bug: ERROR [type: BugType];  BugType: TYPE = {    badAllocationArithmetic, codeSegsNotContiguous, entryPointIndexTooBig,    interfaceItemTooBig, linkMustBeBound, nilFinger,    noCodeSegs, notAnImportedLink,    notboundToInterface, notImplemented, segmentNotFound,    shouldBeVariable, swapUnitsOutOfOrder, topControlNotFound,    typeLink, unexpectedNbrLinks, unexpectedOffset, unknownCase, vacuousList};  Matches: TYPE = {noMatches, someMatches};  -- shared data    bcdExtra: BcdExtraSequenceHandle;  permanentZone, scratch: UNCOUNTED ZONE;  loadState: LoadStateFormat.Handle;  bcdInfo: LoadState.LPBcdInfoTable;  bcd: BcdOps.BcdBase;  -- the bcd being loaded or unloaded.  loadInfo: LoadInfoData;  -- describes structures built from bcd being loaded.  exportRecords: ERSequenceHandle;    UnbindBcdFromOthers: PROC [    disappearingBii: LoadState.BcdInfoIndex, exports: ERSequenceHandle];   SetLinks: PROC [    bcd: BcdOps.BcdBase, bii: LoadState.BcdInfoIndex, exports: ERSequenceHandle];  BindUnboundIfPossible: PROC [    importer: BcdOps.BcdBase, importerBii: LoadState.BcdInfoIndex,    exports: ERSequenceHandle,    importerModuleInfo: LoadState.ModuleInfoSequenceHandle,    action: LoaderCoreOps.BindingAction] RETURNS [importsAllResolved: BOOLEAN];  MakeOneExportRecord: PROC [    bcd: BcdOps.BcdBase, bii: LoadState.BcdInfoIndex, exph: BcdOps.EXPHandle,    frames: GFSequenceHandle] RETURNS [er: ExportRecord];  BuildExportRecords: PROC [    bcd: BcdOps.BcdBase, bii: LoadState.BcdInfoIndex, frames: GFSequenceHandle]    RETURNS [exports: ERSequenceHandle];  MergeExportRecords: PROC [    old, new: ERSequenceHandle] RETURNS [ERSequenceHandle];  MakeBinding: PROCEDURE [bcd: BcdOps.BcdBase, exports: ERSequenceHandle]    RETURNS [bindings: BindingSequenceHandle, anyBound: BOOLEAN ¬ FALSE];    RemoveExportRecords: PROC [    old, new: ERSequenceHandle] RETURNS [needRebuilding: ERIndexSequenceHandle];  RebuildExportRecords: PROC [    bcd: BcdOps.BcdBase, exports: ERSequenceHandle,    needRebuilding: ERIndexSequenceHandle, frames: GFSequenceHandle];  END.  << Change Log:19-Sep-83 11:54:58	Created by RES from LoaderCoreImpl's private types so that they could be shared with the Unloader as well.28-May-85 17:31:45      JWS&ET   Added imports, exports to BcdExtraData. 11-Jun-85 15:25:29      ET       storage moved from ModuleData to BcdExtraData.19-Jun-85 10:09:45      ET       added smallFrame to FramePackData. Moved framePack from LoadInfoData to BcdExtraData. 4-Apr-86  8:10:56      JWS&ET    Picked up JWS's edits to deal with new export records.18-Jun-86  7:45:00      ET	Added fingers, nFingers to BcdExtraData.19-Jun-86  7:45:20      ET	Change to new princops: storage in BcdExtraData and in FramePackData goes from TargetAddress to TargetLongAddress. FramePackData gets new. Added WheresTheStorage.
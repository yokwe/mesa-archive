-- Copyright (C) 1989  by Xerox Corporation and Fuji Xerox Co., Ltd. All rights reserved. -- VMMgr>SpaceImplC.mesa  16-May-89 11:24:02 by TxH -- *******************************************************************      DIRECTORY-- *******************************************************************  DiskBackingStore USING [BSDataFromDiskData, Data, DiskDataFromBSData],  File             USING [PageNumber],  FileLock         USING [GetLock, lockingEnabled],  RuntimeInternal  USING [Bug],  Space            USING [Access, Window],  SpaceInternal,   VM               USING [BackingStoreRuns, PageCount];-- *******************************************************************      SpaceImplC: MONITOR <<for mapUnitIndex >>-- *******************************************************************    IMPORTS       DiskBackingStore, FileLock, RuntimeInternal, SpaceInternal    EXPORTS       SpaceInternal =              BEGIN OPEN SpaceInternal;    mapUnitIndex: LONG CARDINAL ¬ 0;        BugType : TYPE = {impossibleError};    Bug: PROCEDURE [bugType: BugType] = INLINE{RuntimeInternal.Bug[BugType]};-- =============================================================--   InitializeVMMgrC: PUBLIC SpaceInternal. PROCEDURE =-- =============================================================--  BEGIN--  END;-- =============================================================     InsertLockIntoRuns: PUBLIC --SpaceInternal.-- ENTRY PROCEDURE-- =============================================================     [runs       : VM.BackingStoreRuns,       mappedCount: VM.PageCount,      window     : Space.Window,      access     : Space.Access] =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    -- only call this if FileLock.lockingEnabled is false    -- allocates storage and inserts the lock into the runs.    BEGIN    node: LONG POINTER;    diskRun: DiskBackingStore.Data;    currentPage: File.PageNumber ¬ window.base;    countRest: VM.PageCount ¬ mappedCount;-- mapUnitIndex = 0 is reserved for null state.        IF (mapUnitIndex ¬ SUCC[mapUnitIndex]) = 0 THEN mapUnitIndex ¬ 1;        FOR i: CARDINAL IN [0..LENGTH[runs]) DO      diskRun ¬ DiskBackingStore.DiskDataFromBSData[runs[i].data];      node ¬ AllocateStorage[];      WITH d: diskRun SELECT FileLock.lockingEnabled FROM        TRUE => d.lock ¬ FileLock.GetLock[		  node, window.file, currentPage, 		  IF countRest > runs[i].count THEN runs[i].count ELSE countRest,		  IF access = readWrite THEN readWriteLock ELSE readOnlyLock,		  mapUnitIndex];        FALSE => Bug[impossibleError];	ENDCASE;      runs[i].data ¬ DiskBackingStore.BSDataFromDiskData[diskRun];      currentPage ¬ currentPage + runs[i].count;      countRest ¬ countRest - runs[i].count;      ENDLOOP;    END; -- InsertLockIntoRuns --    END.   LOG  16-May-89 11:23:59    TxH    Created. Moved InsertLockIntoRuns here in order to protect the variable "mapUnitIndex".
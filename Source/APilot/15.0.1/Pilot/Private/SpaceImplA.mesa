-- Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989 by Xerox Corporation and Fuji Xerox Co., Ltd. All rights reserved. -- VMMgr>SpaceImplA.mesa  16-May-89 11:08:24 by TxH-- THINGS TO DO:-- 1.  Implement the returnWait arguments to Unmap and UnmapAtDIRECTORY  BackingStore USING [Run, TransferProc],  DiskBackingStore USING [    Data, DiskDataFromBSData, PackFilePageNumber, Transfer],  Environment USING [    Base, bitsPerWord, first64K, maxPagesInMDS, PageCount, PageNumber,    PageFromLongPointer, wordsPerPage],  File USING [    Create, Delete, File, firstPageNumber, GetAttributes, ID, lastPageNumber,    MakePermanent, nullFile, nullID, PageCount, PageNumber, SetSize, Type,    Unknown],  FileLock USING [    DeleteLock, FileLockInit, fileLockNodeSize, GetFileIDFromLock,     lockingEnabled, LockHandle «, nullLockHandle», AnyTrashedSpace],  FrameExtras USING [LongGFToGFTHandle],  Inline USING [LowHalf, LongMult],  KernelFile USING [    Cache, GetFileAttributes, GetRootFile, PutRootFile],  KernelSpaceUsage USING [    fileLockAllocationPool, fileLockSpace, mapLog, miscSpaceImplData],  MapLog USING [WriteLog],  ObjAlloc USING [    Allocate, AllocationPool, Error, Free, InitializePool, Interval],  PilotFileTypes USING [tAnonymousFile, tUnassigned, tVMBackingFile],  PilotFileTypesExtraExtras USING [tFileLockFile],  PilotMP USING [cInsuffBackingStore, cInsuffFileLockStorage],  PilotSwitches USING [    largeAnonymousBackingFile, mediumAnonymousBackingFile,    smallAnonymousBackingFile],  PilotSwitchesExtra7 USING [verySmallAnonymousBackingFile],  PrincOpsExtras2 USING [GFT],  PrincOps USING [LocalFrameHandle],  Process USING [    Detach, DisableAborts, DisableTimeout, GetPriority, Priority, SetPriority,    TooManyProcesses],  ProcessorFace USING [SetMP],  ProcessPriorities USING [priorityClientHigh],  ProcessPrioritiesExtras USING [priorityPageFaultLow],  ResidentHeap USING [first64K, FreeNode, MakeNode],  Runtime USING [IsBound],  RuntimeInternal USING [Bug],  Space USING [    Access, Allocate, Class, Deallocate, ErrorType, InsufficientSpace, Interval,    Life, LongPointerFromPage, nullInterval, PageFromLongPointer, ReturnWait,    SwapUnitOption, Usage, virtualMemory, Window],  SpaceInternal USING [    cache, DeallocateStorage, defaultRunSize, GetRuns,     incrementOnPilot, InsertLockIntoRuns, lastLockPageMapped, lowerBound, maxNumberNodes, Runs],  SpacePerf USING [],  SpecialSpaceExtras USING [IsAllocated],  SpecialFile USING [    GetBackingStoreRun, InterpretBackingStoreRun, InvalidParameters],  SpecialRuntime USING [    Code, GetCurrentSignal, GetSwapUnitsForCatchCode, GetSwapUnitsForEntryVector,    GetSwapUnitsForGlobalFrame, GetSwapUnitsForProcedure, ReraiseError],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  SpecialSpace USING [FaultFielder, SpecialErrorType],  StoragePrograms USING [ --InitializeVMMgr-- ],  System USING [switches],  VM USING [    Activate, AwaitAddressFault, AwaitWriteFault, BackingStoreRuns, CopyIn,    CopyOut, Deactivate, FaultType, FindMapUnit, ForceOut, GetMapUnitAttributes,    GetSwapUnitAttributes, Interval, Kill, MakeSwappable, Map,    nullInterval, PageCount, ReportFaultedProcess, RestartFaultedProcess, ReturnWait,    SetAccess, SupplyBackingStore, SetSwappability, Swappability, Unmap],  VMExtraExtras USING [GetMappedRunCount],  VMMPrograms USING [InitializeMapLog, SpaceForSpaceAllocation],  Volume USING [    GetAttributes, ID, InsufficientSpace, nullID, PageCount, ReadOnly, SystemID],  Zone USING [Status];SpaceImplA: MONITOR LOCKS ml USING ml: LONG POINTER TO MONITORLOCK  IMPORTS    DiskBackingStore, File, FileLock, FrameExtras, Inline, KernelFile, MapLog,     ObjAlloc, Process, ProcessorFace, ResidentHeap, Runtime, RuntimeInternal,    Space, SpaceInternal, SpecialSpaceExtras, SpecialFile, SpecialRuntime,     SpecialRuntimeExtras, System, VM, VMExtraExtras, VMMPrograms, Volume  EXPORTS Space, SpacePerf, SpaceInternal, SpecialSpace, StoragePrograms =  BEGIN  -- PUBLIC errors and variables  Error: PUBLIC ERROR [type: Space.ErrorType] = CODE;  IOError: PUBLIC ERROR [page: Environment.PageNumber] = CODE;  SpecialError: PUBLIC ERROR [error: SpecialSpace.SpecialErrorType] = CODE;  -- PRIVATE parameters, types and variables  defaultWindow: Space.Window = [File.nullFile, 0, 0];  hasSystemVolume: PUBLIC --SpaceInternal-- BOOLEAN ¬    (Volume.SystemID[] ~= Volume.nullID);  BugType: TYPE = {    dataSpaceFileWentAway, fileExcessivelyFragmented, impossibleEndcase,    impossibleError, mappedFileGone, noStorage, unexpectedObjAllocError,    unexpectedResidentHeapStatus, unexpectedVMError};      -- PRIVATE parameters, types and variables   -- Needed for DoCopy and DoCopyHelperProcess to communicate properly   CopyType: TYPE = {copyIn, copyOut};  CopyProcedureType: TYPE = PROCEDURE [    interval: VM.Interval, transferProc: BackingStore.TransferProc,    run: BackingStore.Run, returnWait: VM.ReturnWait];  MessagePtr: TYPE = LONG POINTER TO Message;  Message: TYPE = RECORD [    run: BackingStore.Run,    interval: VM.Interval,    copyProc: CopyProcedureType,    result:       SELECT resultTag:* FROM        copyError => [copyErrorType: Space.ErrorType],        inProgress => NULL,        okay => NULL,        ENDCASE];   msgQueueEmpty: CONDITION;  msgRequestDone: CONDITION;      newMessage: CONDITION;   copyLock: MONITORLOCK;  currentMsg: MessagePtr ¬ NIL;  -- VM BACKING FILE LAYOUT  --			Layout of VM backing file:  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- | MapLog | Operation | VM Alloc. | Lock Allocation | Backing Pool for |  -- |        | Queue     |    Map    |       Pool      |   Data Spaces    |  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Note that the MapLog and Operation Queue both have their sizes fixed at  --  compile time.  backingFile: File.File;  -- File.File of the backing file.  It is always on the system volume.  countLog: Environment.PageCount = 60;  -- Size of map log.  mapLogBase0: Environment.PageNumber = 0;  mapLogBase1: Environment.PageNumber = countLog;  -- First page in the backing file of the map log  opnQueueBase: File.PageNumber = mapLogBase0 + 2*countLog;  opnQueueSize: CARDINAL = 1;  -- in pages.  Note that this can't be an Environment.PageCount as this is  -- used to construct DESCRIPTOR's)  spaceAllocBase: File.PageNumber = opnQueueBase + opnQueueSize;  minCountDataPool: CARDINAL = 250;  -- enough space for a (Dolphin) bitmap.  maxDefaultCountDataPool: CARDINAL = 1000;  -- (arbitrary)  verySmallCountDataPool: CARDINAL = 325;  smallCountDataPool: CARDINAL = 550;  medCountDataPool: CARDINAL = 1200;  largeCountDataPool: CARDINAL = 1800;  largerCountDataPool: CARDINAL = 2500;  veryLargeCountDataPool: CARDINAL = 3500;  veryVeryLargeCountDataPool: CARDINAL = 5000;  hugeCountDataPool: CARDINAL = 7000;  dataPoolBase: File.PageNumber;  countDataPool: PUBLIC File.PageCount;  -- depends on space available on volume.  -- DATA POOL SPECIFIC INFORMATION  fractionThreshold: CARDINAL = 10;  -- initially countThreshold ¬ countDataPool/fractionThreshold.  dataPool: LONG POINTER TO ObjAlloc.AllocationPool;  dataPoolLock: MONITORLOCK;  cacheContents: BackingStore.Run;  -- Variables exported for data space performance monitoring  countThreshold: PUBLIC Environment.PageCount;  -- windows larger than countThreshold will be allocated as  -- separate files.  nDataSpaces: PUBLIC LONG CARDINAL;  nCreatedDataFiles: PUBLIC CARDINAL;  currentUtilization: PUBLIC File.PageCount;  -- OPERATION QUEUE SPECIFIC INFORMATION  opnQueueLock: MONITORLOCK;  opnQueue: LONG DESCRIPTOR FOR ARRAY [0..0) OF OpnQueueEntry;  OpnQueneEntryPtr: TYPE = LONG POINTER TO OpnQueueEntry;  Operation: TYPE = RECORD [    opn: SELECT opnType: OpnType FROM      unmap => [interval: Space.Interval],      fault => [        fault: VM.FaultType, process: PROCESS, page: Environment.PageNumber],      ENDCASE];  OpnQueueEntry: TYPE = RECORD [    state: OperationState, next: OpnQueneEntryPtr, opn: Operation];  OpnType: TYPE = {fault, unmap};  OperationState: TYPE = {free, waitingAction};  newOperation: CONDITION;  -- Used to NOTIFY when a new operation is available  queueEntryFree: CONDITION;  -- Used to NOTIFY when a queue entry comes free  opnQFirstFree, opnQLastInUse: OpnQueneEntryPtr;  -- Note that the queue of in use entries is maintained as a circular list  --  with opnQLastInUse poining ot the end of the list.  Thus  --  opnQLastInUse.next is always the first element in the queue and the  --  queue has one entry in it if and only if  --  opnQLastInUse.next = opnQLastInUse.  -- FAULT FIELDER SPECIFIC INFORMATION  faultFielderLock: MONITORLOCK;  FaultFielderEntry: TYPE = RECORD [    next: FaultFieldEntryPtr,    lock: CARDINAL ¬ 0,  -- count of locked entries    faultFielder: SpecialSpace.FaultFielder];  FaultFieldEntryPtr: TYPE = FFBase RELATIVE POINTER TO FaultFielderEntry;  FFBase: TYPE = Environment.Base;  ffBase: FFBase = ResidentHeap.first64K;  addrFaultFielderList: FaultFieldEntryPtr ¬ nilFaultFieldEntryPtr;  writeProtectFaultFielderList: FaultFieldEntryPtr ¬ nilFaultFieldEntryPtr;  nilFaultFieldEntryPtr: FaultFieldEntryPtr = LOOPHOLE[0];  ffUnlocked: CONDITION;    -- FILE LOCK SPECIFIC INFORMATION  fileLockFile: PUBLIC --SpaceInternal-- File.File;  lockAllocationPoolBase: File.PageNumber;  fileLockSpace: PUBLIC --SpaceInternal-- Space.Interval;  lockAllocationPoolSpace: PUBLIC --SpaceInternal-- Space.Interval;  lockAllocationPoolSize: CARDINAL = 10;  --Other Globals  cache: PUBLIC --SpaceInternal-- KernelFile.Cache;  unmapLock: MONITORLOCK;  -- PROCEDURES, in alphabetical order, of this module  Activate: PUBLIC PROCEDURE [interval: Space.Interval] =    BEGIN VM.Activate[interval: GetVMInterval[interval], returnWait: return]; END;  ActivateProc: PUBLIC PROCEDURE [proc: --GENERIC PROCEDURE-- PROCEDURE] =    BEGIN    IF ~Runtime.IsBound[LOOPHOLE[proc]] THEN ERROR Error[invalidProcedure];    Activate[GetSwapUnitAttributes[SpecialRuntime.Code[LOOPHOLE[proc]]].interval];    END;  AllocateDataWindow: PROCEDURE [window: POINTER TO Space.Window]    RETURNS[usedVMBF: BOOLEAN ¬ TRUE] =    BEGIN    AllocateFromPool: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN      allocatedInterval: ObjAlloc.Interval = ObjAlloc.Allocate[        pool: [allocPool: dataPool, poolSize: countDataPool], count: window.count,        willTakeSmaller: FALSE !        ObjAlloc.Error =>          IF error = insufficientSpace THEN GO TO CreateFile          ELSE Bug[unexpectedObjAllocError]];      currentUtilization ¬ currentUtilization + window.count;  -- Metering      window.file.fileID ¬ backingFile.fileID;      window.base ¬ dataPoolBase + allocatedInterval.first;      allocated ¬ TRUE;      EXITS CreateFile => NULL;  -- our caller will create a file      END;    IncrementCountDataSpaces: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      INLINE {nDataSpaces ¬ nDataSpaces + 1};  -- Metering    IncrementCountCreatedDataFiles: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      INLINE {nCreatedDataFiles ¬ nCreatedDataFiles + 1};  -- Metering    allocated: BOOLEAN;    IncrementCountDataSpaces[@dataPoolLock];    window.file.volumeID ¬ Volume.SystemID[];  -- True for all cases    IF ~hasSystemVolume THEN RETURN;  -- our caller will do the right thing    allocated ¬ FALSE;    IF window.count <= countThreshold THEN AllocateFromPool[@dataPoolLock];    IF ~allocated THEN      -- Create a file      BEGIN      usedVMBF ¬ FALSE;      IncrementCountCreatedDataFiles[@dataPoolLock];      window.file ¬        File.Create[	Volume.SystemID[], window.count, PilotFileTypes.tAnonymousFile];      window.base ¬ 0;      END    END;          BiggerRuns: PUBLIC -- SpaceInternal -- PROCEDURE [runs: SpaceInternal.Runs]     RETURNS [newRuns: SpaceInternal.Runs] =    -- Allocates a bigger Runs than runs, and frees runs.    BEGIN    newSize: CARDINAL =  -- allocate a single extra page      WITH r: runs SELECT FROM        frame => 1,        createdSpace =>          IF r.interval.count = LAST[CARDINAL] THEN BugV[          fileExcessivelyFragmented] ELSE CARDINAL[r.interval.count + 1]        ENDCASE => BugV[impossibleEndcase];    newSpace: Space.Interval = Space.Allocate[      newSize ! Space.InsufficientSpace => Bug[noStorage]];    VM.Map[      interval: [Space.PageFromLongPointer[newSpace.pointer], newSize],      transferProc: NIL, backingStoreRuns: NIL, life: alive,      usage: KernelSpaceUsage.miscSpaceImplData, swappability: resident,      swapUnits: [unitary[]]];    newRuns ¬ [      DESCRIPTOR[      newSpace.pointer,        (newSize * Environment.wordsPerPage) / SIZE[BackingStore.Run]],      createdSpace[newSpace]];    FOR i: CARDINAL IN [0..LENGTH[runs.runs]) DO      newRuns.runs[i] ¬ runs.runs[i]; ENDLOOP;    FinishWithRuns[runs];    END;  Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};  BugV: PROCEDURE [bugType: BugType] RETURNS [UNSPECIFIED] = {    Bug[bugType]; RETURN[0]};  CopyIn: PUBLIC PROCEDURE [pointer: LONG POINTER, window: Space.Window]    RETURNS [countRead: Environment.PageCount] = {    RETURN[DoCopy[pointer, window, KernelFile.GetFileAttributes[window.file].size, copyIn]]};  CopyOut: PUBLIC PROCEDURE [pointer: LONG POINTER, window: Space.Window]    RETURNS [countWritten: Environment.PageCount] =    BEGIN    size: File.PageCount;    readOnly: BOOLEAN;    [size: size, readOnly: readOnly] ¬ KernelFile.GetFileAttributes[window.file];    IF readOnly THEN ERROR Volume.ReadOnly[window.file.volumeID];    RETURN[DoCopy[pointer, window, size, copyOut]];    END;  Deactivate: PUBLIC PROCEDURE [interval: Space.Interval] =    BEGIN    VM.Deactivate[interval: GetVMInterval[interval], returnWait: return];    END;  DeactivateProc: PUBLIC PROCEDURE [proc: --GENERIC PROC-- PROCEDURE] =    BEGIN    IF ~Runtime.IsBound[LOOPHOLE[proc]] THEN ERROR Error[invalidProcedure];    Deactivate[      GetSwapUnitAttributes[SpecialRuntime.Code[LOOPHOLE[proc]]].interval];    END;  DeallocatePossibleDataWindow: PROCEDURE [    fileID: File.ID, type: File.Type, base: File.PageNumber,    size: Environment.PageCount] =    BEGIN    DeallocateFromDataPool: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN      ObjAlloc.Free[        pool: [allocPool: dataPool, poolSize: countDataPool],        interval: [first: base - dataPoolBase, count: size], validate: FALSE];      currentUtilization ¬ currentUtilization - size;  -- Metering      END;    IF ~hasSystemVolume THEN RETURN;    IF IsDataSpace[type] THEN      IF fileID = backingFile.fileID THEN DeallocateFromDataPool[@dataPoolLock]      ELSE  -- we had to create a file        File.Delete[          [fileID, Volume.SystemID[]] !          File.Unknown => Bug[dataSpaceFileWentAway]];    END;   DoCopy: PROCEDURE [    pointer: LONG POINTER, window: Space.Window, size: File.PageCount,    copyType: CopyType] RETURNS [countDone: Environment.PageCount] =    BEGIN    msg: Message;    BEGIN  -- for EXITS to notice msg variable    copyProc: CopyProcedureType;    intervalPage: Environment.PageNumber = Space.PageFromLongPointer[pointer];    page: Environment.PageNumber ¬ intervalPage;    run: BackingStore.Run ¬ SpecialFile.GetBackingStoreRun[      window.file, window.base, PilotFileTypes.tUnassigned !  --      SpecialFile.InvalidParameters => GOTO InvalidParams       -- File.Unknown, File.MissingPages, Volume.Unknown,      -- Volume.NotOnline, Volume.NeedsScavenging, and Volume.NotOpen      -- just go flying right out to the client, as advertised.      ].run;    countRun: Environment.PageCount ¬ MIN[window.count, run.count];    maxCount: Environment.PageCount ¬ MIN[window.count, size - window.base];    countDone ¬ countRun;    SELECT copyType FROM      copyIn => copyProc ¬ VM.CopyIn;      copyOut => copyProc ¬ VM.CopyOut;      ENDCASE => Bug[impossibleEndcase];    WHILE countDone < maxCount DO      msg ¬ [run: run, interval:[page: page, count: countRun], copyProc: copyProc, result: okay[]];      SendMessageToHelper[msgPtr: @msg, ml: @copyLock];      run ¬ SpecialFile.GetBackingStoreRun[        window.file, window.base + countDone, PilotFileTypes.tUnassigned !  --        SpecialFile.InvalidParameters => GOTO EndOfFile;  -- off end of file.	ANY => {WaitForMessageFromHelper[@copyLock]; REJECT}        -- File.Unknown, File.MissingPages, Volume.Unknown,        -- Volume.NotOnline, Volume.NeedsScavenging, and Volume.NotOpen        -- after processing message in progress, 	-- just go flying right out to the client, as advertised.        ].run;      countRun ¬ MIN[window.count - countDone, run.count];      WaitForMessageFromHelper[@copyLock];      WITH msg SELECT FROM        okay => NULL;	copyError => Error[copyErrorType];	ENDCASE => Bug[impossibleEndcase];      page ¬ intervalPage + countDone;      countDone ¬ countDone + countRun;      ENDLOOP;    copyProc[      interval: [page: page, count: countRun],      transferProc: DiskBackingStore.Transfer, run: run, returnWait: wait];    EXITS      EndOfFile => BEGIN         --finish processing run in progress         WaitForMessageFromHelper[@copyLock];        WITH msg SELECT FROM          okay => NULL;	  copyError => Error[copyErrorType];	  ENDCASE => Bug[impossibleEndcase];	  END;      InvalidParams => RETURN [0];      END; --for exits clause to notice msg variable    END;  --DoCopy--              DoCopyHelperProcess: PROCEDURE =     BEGIN     err: Space.ErrorType;     ok: BOOLEAN;     run: BackingStore.Run;     copyProc: CopyProcedureType;     interval: VM.Interval;          DO  --forever       [run, interval, copyProc] ¬ WaitForNewMessage[ml: @copyLock];       ok ¬ TRUE;       copyProc[interval, DiskBackingStore.Transfer, run, wait !Error =>         {ok ¬ FALSE; err ¬ type; CONTINUE}];       SendNewMessageProcessed[ok, err, @copyLock];       ENDLOOP;     END; --DoCopyHelperProcess            SendMessageToHelper: ENTRY PROCEDURE [msgPtr: MessagePtr, ml: LONG POINTER TO MONITORLOCK] =    BEGIN    WHILE currentMsg # NIL DO      WAIT msgQueueEmpty;      ENDLOOP;    currentMsg ¬ msgPtr;    currentMsg.result ¬ inProgress[];    NOTIFY newMessage;    END;       WaitForMessageFromHelper: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =    BEGIN    DO      WITH currentMsg SELECT FROM        inProgress => WAIT msgRequestDone;        ENDCASE => EXIT;      ENDLOOP;    currentMsg ¬ NIL;    NOTIFY msgQueueEmpty;    END;          WaitForNewMessage: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]     RETURNS [run: BackingStore.Run, interval: VM.Interval, copyProc: CopyProcedureType] =    BEGIN    keepLooping: BOOLEAN ¬ IF currentMsg = NIL THEN TRUE       ELSE WITH currentMsg SELECT FROM        inProgress => FALSE        ENDCASE => TRUE;          WHILE keepLooping DO      WAIT newMessage;      IF currentMsg = NIL THEN keepLooping ¬ TRUE      ELSE WITH currentMsg SELECT FROM        inProgress => keepLooping ¬ FALSE;        ENDCASE => keepLooping ¬ TRUE;      ENDLOOP;    run ¬ currentMsg.run;    interval ¬ currentMsg.interval;    copyProc ¬ currentMsg.copyProc;    END;      SendNewMessageProcessed: ENTRY PROCEDURE [    ok: BOOLEAN, err: Space.ErrorType, ml: LONG POINTER TO MONITORLOCK] =    BEGIN    IF ok THEN currentMsg.result ¬ okay[]    ELSE currentMsg.result ¬ copyError[err];    NOTIFY msgRequestDone;    END;     DoneWithAddressFaultFielder: PUBLIC PROCEDURE [    fielder: SpecialSpace.FaultFielder] =    BEGIN    DoneWithFaultHandler[fielder, @addrFaultFielderList, @faultFielderLock];    END;  DoneWithFaultHandler: ENTRY PROCEDURE [    fielder: SpecialSpace.FaultFielder,    listHead: LONG POINTER TO FaultFieldEntryPtr, ml: LONG POINTER TO MONITORLOCK] =    BEGIN    lookInList: BOOLEAN ¬ TRUE;    WHILE lookInList DO      last: FaultFieldEntryPtr ¬ nilFaultFieldEntryPtr;      lookInList ¬ FALSE;      FOR current: FaultFieldEntryPtr ¬ listHead­, ffBase[current].next WHILE        current ~= nilFaultFieldEntryPtr DO        IF ffBase[current].faultFielder = fielder THEN          BEGIN          IF ffBase[current].lock > 0 THEN {            lookInList ¬ TRUE; WAIT ffUnlocked; GO TO TryAgain};          IF last = nilFaultFieldEntryPtr THEN listHead­ ¬ ffBase[current].next          ELSE ffBase[last].next ¬ ffBase[current].next;          IF ResidentHeap.FreeNode[current] ~= okay THEN            Bug[unexpectedResidentHeapStatus];          RETURN;          END;        last ¬ current;        REPEAT TryAgain => NULL;        ENDLOOP;      ENDLOOP;    END;  DoneWithWriteProtectFaultFielder: PUBLIC PROCEDURE [    fielder: SpecialSpace.FaultFielder] =    BEGIN    DoneWithFaultHandler[      fielder, @writeProtectFaultFielderList, @faultFielderLock];    END;  FaultFielder: PROCEDURE [faultType: VM.FaultType] =    BEGIN    AwaitFault: PROCEDURE [] RETURNS [process: PROCESS, address: LONG POINTER];    SELECT faultType FROM      addressFault => AwaitFault ¬ VM.AwaitAddressFault;      writeFault => AwaitFault ¬ VM.AwaitWriteFault;      ENDCASE => Bug[impossibleEndcase];    Process.SetPriority[ProcessPriorities.priorityClientHigh];    DO  -- FOREVER      process: PROCESS;      p: LONG POINTER;      [process, p] ¬ AwaitFault[];      QueueOperation[        [fault[faultType, process, Space.PageFromLongPointer[p]]], @opnQueueLock];      ENDLOOP;    END;  FaultProcess: PROCEDURE [    process: PROCESS, faultType: VM.FaultType, page: Environment.PageNumber] =    BEGIN    -- We could cause a state vector deadlock here if we were *extremely* unlucky    -- and us and the other Pilot processes at our priority (pageFaultHigh)    -- pageFaulted simultaneously.  Nevertheless, if that happened, the user could    -- swat to the debugger and find the root cause (the original address fault).     BEGIN    priorityPrev: Process.Priority = Process.GetPriority[];    Process.SetPriority[ProcessPriorities.priorityClientHigh];    -- so that a debugger Interpret Call will not use a Pilot state vector.    -- Pilot's state vectors are now safe.    BEGIN    ENABLE ABORTED => CONTINUE;  -- In case the client Aborts us from the debugger    VM.ReportFaultedProcess[process, faultType];    -- If the user Proceeds or Quits from the debugger, the faulted process    -- will wait forever.    -- Pilot and client processes are viable (assuming the faulted process holds    -- no vital monitor locks).    END;  -- End of scope of ENABLE    Process.SetPriority[priorityPrev];  -- in case we didn't get FORKed.    END;  -- process (usually) vanishes--    END;  FinishWithRuns: PUBLIC --SpaceInternal-- PROCEDURE [runs: SpaceInternal.Runs] =    BEGIN    WITH r: runs SELECT FROM      frame => NULL;      createdSpace =>        BEGIN        [] ¬ VM.Unmap[Space.PageFromLongPointer[r.interval.pointer]];        Space.Deallocate[r.interval];        END;      ENDCASE => Bug[impossibleEndcase];    END;  ForceOut: PUBLIC PROCEDURE [interval: Space.Interval] =    BEGIN VM.ForceOut[interval: GetVMInterval[interval], returnWait: wait]; END;  GetMapUnitAttributes: PUBLIC PROCEDURE [pointer: LONG POINTER]    RETURNS [      interval: Space.Interval, window: Space.Window, usage: Space.Usage,      class: Space.Class, swapUnits: Space.SwapUnitOption] =    BEGIN    page: Environment.PageNumber = Space.PageFromLongPointer[pointer];    runs: ARRAY [0..1) OF BackingStore.Run;    backingStoreRuns: VM.BackingStoreRuns;    mapUnit: VM.Interval;    transferProc: BackingStore.TransferProc;    [mapUnit: mapUnit, transferProc: transferProc, usage: usage,       class: class, swapUnits: swapUnits, backingStoreRuns: backingStoreRuns] ¬         VM.GetMapUnitAttributes[page, DESCRIPTOR[runs]];    interval ¬ [      pointer: Space.LongPointerFromPage[mapUnit.page], count: mapUnit.count];    window.count ¬ mapUnit.count;    IF mapUnit.count = 0 OR LENGTH[backingStoreRuns] = 0 THEN      BEGIN  -- unmapped memory or resident data map unit      window.file ¬ File.nullFile;      window.base ¬ 0;      END    ELSE  -- actually mapped to some file      BEGIN      fileType: File.Type;      IF transferProc # DiskBackingStore.Transfer THEN	ERROR Error[invalidParameters];      [file: window.file, page: window.base, fileType: fileType] ¬        SpecialFile.InterpretBackingStoreRun[        runs[0] ! SpecialFile.InvalidParameters => Error[invalidParameters]];      IF IsDataSpace[fileType] THEN        BEGIN window.file ¬ File.nullFile; window.base ¬ 0; END;      END;    END;  GetSwapUnitAttributes: PUBLIC PROCEDURE [pointer: LONG POINTER]    RETURNS [interval: Space.Interval, access: Space.Access, life: Space.Life] =    BEGIN    vmInterval: VM.Interval;    [swapUnit: vmInterval, access: access, life: life] ¬ VM.GetSwapUnitAttributes[      Space.PageFromLongPointer[pointer]];    RETURN[      interval: [      pointer: Space.LongPointerFromPage[vmInterval.page],      count: vmInterval.count], access: access, life: life];    END;  GetVMInterval: PROCEDURE [interval: Space.Interval]    RETURNS [vmInterval: VM.Interval] = INLINE    BEGIN    RETURN[      [page: Space.PageFromLongPointer[interval.pointer], count: interval.count]];    END;  InitializeVMMgr: PUBLIC PROCEDURE =    BEGIN    volSize: Volume.PageCount;    backingFileSize: File.PageCount;    spaceAllocSpace: Space.Interval = VMMPrograms.SpaceForSpaceAllocation[];    Process.DisableTimeout[@newOperation];    Process.DisableAborts[@newOperation];    Process.DisableTimeout[@queueEntryFree];    Process.DisableAborts[@queueEntryFree];    Process.DisableTimeout[@ffUnlocked];    Process.DisableAborts[@ffUnlocked];    lockAllocationPoolBase ¬ spaceAllocBase + spaceAllocSpace.count;    dataPoolBase ¬ lockAllocationPoolBase + lockAllocationPoolSize;        IF hasSystemVolume THEN      BEGIN  -- Create the VM Backing file      volSize ¬ Volume.GetAttributes[volume: Volume.SystemID[]].volumeSize;      countDataPool ¬        SELECT TRUE FROM  -- take largest option chosen	  System.switches[PilotSwitches.smallAnonymousBackingFile] = down AND	    System.switches[PilotSwitches.mediumAnonymousBackingFile] = down AND	    System.switches[PilotSwitches.largeAnonymousBackingFile] = down =>	    hugeCountDataPool,	  System.switches[PilotSwitches.mediumAnonymousBackingFile] = down AND	    System.switches[PilotSwitches.largeAnonymousBackingFile] = down =>	    veryVeryLargeCountDataPool,	  System.switches[PilotSwitches.smallAnonymousBackingFile] = down AND	    System.switches[PilotSwitches.largeAnonymousBackingFile] = down =>	    veryLargeCountDataPool,	  System.switches[PilotSwitches.smallAnonymousBackingFile] = down AND	    System.switches[PilotSwitches.mediumAnonymousBackingFile] = down =>	    largerCountDataPool,            System.switches[PilotSwitches.largeAnonymousBackingFile] = down =>            largeCountDataPool,          System.switches[PilotSwitches.mediumAnonymousBackingFile] = down =>            medCountDataPool,          System.switches[PilotSwitches.smallAnonymousBackingFile] = down =>            smallCountDataPool,	  System.switches[PilotSwitchesExtra7.verySmallAnonymousBackingFile]	    = down => verySmallCountDataPool,          ENDCASE =>  --default--            MAX[minCountDataPool, MIN[maxDefaultCountDataPool, volSize / 16]];      backingFileSize ¬        (2 * countLog) + spaceAllocSpace.count + opnQueueSize +	lockAllocationPoolSize + countDataPool;      backingFile ¬ [        KernelFile.GetRootFile[Volume.SystemID[], PilotFileTypes.tVMBackingFile],        Volume.SystemID[]];      --scope of NoSpace--      BEGIN      ENABLE        Volume.InsufficientSpace =>          -- User should reboot, specifying smaller size with boot switch.          {ProcessorFace.SetMP[PilotMP.cInsuffBackingStore]; DO ENDLOOP};      File.SetSize[        backingFile, backingFileSize !        File.Unknown =>          BEGIN          backingFile ¬ File.Create[            Volume.SystemID[], backingFileSize, PilotFileTypes.tVMBackingFile];          File.MakePermanent[backingFile];          KernelFile.PutRootFile[backingFile, PilotFileTypes.tVMBackingFile];          CONTINUE;          END];      END;      END    ELSE backingFile ¬ File.nullFile;  -- no VM backing file if not Pilot    -- Initialize the Data Pool    IF hasSystemVolume THEN      BEGIN      size: CARDINAL = Inline.LowHalf[        (countDataPool + Environment.bitsPerWord - 1) / Environment.bitsPerWord];      node: Environment.Base RELATIVE POINTER;      s: Zone.Status;      [node, s] ¬ ResidentHeap.MakeNode[size];      IF s ~= okay THEN Bug[noStorage];      dataPool ¬ LOOPHOLE[@Environment.first64K[node]];      ObjAlloc.InitializePool[        pool: [allocPool: dataPool, poolSize: countDataPool], initialState: free];      countThreshold ¬ countDataPool / fractionThreshold;      [run: cacheContents] ¬ SpecialFile.GetBackingStoreRun[        backingFile, dataPoolBase, PilotFileTypes.tVMBackingFile];      SpaceInternal.cache ¬ @cacheContents;      END;    -- Initialize the MapLogging machinery so that we can use Map    IF hasSystemVolume THEN      BEGIN      mapLogSpace0: Space.Interval = Space.Allocate[countLog];      mapLogSpace1: Space.Interval = Space.Allocate[countLog];      mapLogBase: Environment.PageNumber ¬ mapLogBase0;      mapLogSpace: Space.Interval ¬ mapLogSpace0;      defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;      runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];      THROUGH [0..1] DO -- 'cause we have to initialize 2 MapLogs        runs ¬ SpaceInternal.GetRuns[          runs, [file: backingFile, base: mapLogBase, count: countLog], FALSE];        VM.Map[          interval: [          page: Space.PageFromLongPointer[mapLogSpace.pointer], count: countLog],          transferProc: DiskBackingStore.Transfer, backingStoreRuns: runs.runs,          usage: KernelSpaceUsage.mapLog, class: data, access: readWrite,          swapUnits: [uniform[1]], life: dead, swappability: swappable];        FinishWithRuns[runs];        VMMPrograms.InitializeMapLog[mapLogSpace, runs.runs];        -- Turn on map logging; MapLog will map log the map log itself	mapLogBase ¬ mapLogBase1;	mapLogSpace ¬ mapLogSpace1;      ENDLOOP      -- INITIALLY: mapLogSpace0 is the CURRENT log.      END    ELSE  -- turn off map logging      VMMPrograms.InitializeMapLog[Space.nullInterval, NIL];    -- Start swapping the space allocation database    IF hasSystemVolume THEN      BEGIN      defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;      runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];      runs ¬ SpaceInternal.GetRuns[runs, [        file: backingFile, base: spaceAllocBase, count: spaceAllocSpace.count], FALSE];      VM.SupplyBackingStore[        page: Space.PageFromLongPointer[spaceAllocSpace.pointer],        transferProc: DiskBackingStore.Transfer, backingStoreRuns: runs.runs,        swapUnits: [uniform[1]]];      MapLog.WriteLog[        interval: [        page: Space.PageFromLongPointer[spaceAllocSpace.pointer],        count: spaceAllocSpace.count], transferProc: DiskBackingStore.Transfer,        runs: runs.runs, access: readWrite];      VM.MakeSwappable[        [        page: Space.PageFromLongPointer[spaceAllocSpace.pointer],        count: spaceAllocSpace.count]];      FinishWithRuns[runs];      END;    -- allocate lock allocation pool (manages actual locking storage) mapped to    -- backing file    lockAllocationPoolSpace ¬ Space.Allocate[lockAllocationPoolSize];    SpaceInternal.lowerBound ¬ lockAllocationPoolSpace.pointer;    IF hasSystemVolume THEN      BEGIN      defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;      runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];      runs ¬ SpaceInternal.GetRuns[runs, [        file: backingFile, base: lockAllocationPoolBase,        count: lockAllocationPoolSize], FALSE];      VM.Map[        interval:	  [page: Space.PageFromLongPointer[lockAllocationPoolSpace.pointer],	  count: lockAllocationPoolSize],	transferProc: DiskBackingStore.Transfer, backingStoreRuns: runs.runs,        usage: KernelSpaceUsage.fileLockAllocationPool, class: data,        access: readWrite, swapUnits: [uniform[1]], life: dead,        swappability: swappable];      MapLog.WriteLog[        interval: [        page: Space.PageFromLongPointer[lockAllocationPoolSpace.pointer],        count: lockAllocationPoolSpace.count],        transferProc: DiskBackingStore.Transfer, runs: runs.runs,        access: readWrite];      ObjAlloc.InitializePool[        pool: [allocPool: lockAllocationPoolSpace.pointer,	  poolSize: SpaceInternal.maxNumberNodes],        initialState: free];      FinishWithRuns[runs];      END    ELSE      BEGIN      VM.Map[        interval:	  [page: Space.PageFromLongPointer[lockAllocationPoolSpace.pointer],	  count: lockAllocationPoolSize],	transferProc: NIL, backingStoreRuns: NIL,        usage: KernelSpaceUsage.fileLockAllocationPool, class: data,        access: readWrite, swapUnits: [uniform[1]], life: dead,        swappability: resident];      ObjAlloc.InitializePool[        pool: [allocPool: lockAllocationPoolSpace.pointer,	  poolSize: SpaceInternal.maxNumberNodes],        initialState: free];      END;         -- Initialize the FileLocking machinery   FileLock.FileLockInit[];   -- Create the file that will supply backing store for locks themselves    -- and map first part of the file.   fileLockSpace ¬ Space.Allocate[     (Inline.LongMult[SpaceInternal.maxNumberNodes, FileLock.fileLockNodeSize] /     Environment.wordsPerPage) + 1];   IF hasSystemVolume THEN      BEGIN      defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;      runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];      fileLockFile ¬ File.Create[Volume.SystemID[], fileLockSpace.count,        PilotFileTypesExtraExtras.tFileLockFile !	Volume.InsufficientSpace => 	  {ProcessorFace.SetMP[PilotMP.cInsuffFileLockStorage]; DO ENDLOOP}];      runs ¬ SpaceInternal.GetRuns[         runs,	 [file: fileLockFile, base: 0, count: SpaceInternal.incrementOnPilot],	 FALSE];      VM.Map[        interval:	  [page: Space.PageFromLongPointer[fileLockSpace.pointer],	   count: SpaceInternal.incrementOnPilot],        transferProc: DiskBackingStore.Transfer, backingStoreRuns: runs.runs,        usage: KernelSpaceUsage.fileLockSpace, class: data, access: readWrite,        swapUnits: [unitary[]], life: dead, swappability: swappable];      FinishWithRuns[runs];      SpaceInternal.lastLockPageMapped ¬ SpaceInternal.incrementOnPilot - 1;      END    ELSE      BEGIN      VM.Map[        interval:	  [page: Space.PageFromLongPointer[fileLockSpace.pointer], count: 1],	transferProc: NIL, backingStoreRuns: NIL,        usage: KernelSpaceUsage.fileLockSpace, class: data, access: readWrite,	swapUnits: [unitary[]], life: dead, swappability: resident];      SpaceInternal.lastLockPageMapped ¬ 0;      END;    -- At this point, Space.Map works so we will now Map the operation queue    --   and initialize it appropriately.    BEGIN    opnQueueInterval: Space.Interval = Space.Allocate[opnQueueSize];    [] ¬ MapAt[      at: opnQueueInterval,      window: [file: backingFile, base: opnQueueBase, count: opnQueueSize],      usage: KernelSpaceUsage.miscSpaceImplData, class: data, access: readWrite,      life: dead,      swapUnits: IF opnQueueSize = 1 THEN [unitary[]] ELSE [uniform[1]]];    opnQueue ¬ DESCRIPTOR[      opnQueueInterval.pointer,        (opnQueueSize * Environment.wordsPerPage) / SIZE[OpnQueueEntry]];    FOR i: CARDINAL IN [0..LENGTH[opnQueue] - 1) DO      opnQueue[i] ¬ [free, @opnQueue[i + 1], NULL]; ENDLOOP;    opnQueue[LENGTH[opnQueue] - 1] ¬ [free, NIL, NULL];    opnQLastInUse ¬ NIL;    opnQFirstFree ¬ @opnQueue[0];    Process.Detach[FORK OperationHandler[]];    END;    -- Fork processes to handle all faults coming out of VM    FOR fault: VM.FaultType IN VM.FaultType DO      Process.Detach[FORK FaultFielder[fault]]; ENDLOOP;    -- Get DoCopyHelperProcess started    Process.Detach[FORK DoCopyHelperProcess[]];    END;  IsDataSpace: PROCEDURE [type: File.Type] RETURNS [BOOLEAN] = INLINE    BEGIN    RETURN[      type = PilotFileTypes.tVMBackingFile        OR type = PilotFileTypes.tAnonymousFile]    END;  Kill: PUBLIC PROCEDURE [interval: Space.Interval] =    BEGIN VM.Kill[GetVMInterval[interval]]; END;  MakeCatchCodeResident: PUBLIC PROCEDURE [proc: --GENERIC-- PROCEDURE] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForCatchCode[proc];    SetSwappability[resident, interval, swappability, changeable];    END;  MakeCatchCodeSwappable: PUBLIC PROCEDURE [proc: --GENERIC-- PROCEDURE] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForCatchCode[proc];    SetSwappability[swappable, interval, swappability, changeable];    END;  MakeEntryVectorResident: PUBLIC PROCEDURE [proc: --GENERIC-- PROCEDURE] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForEntryVector[proc];    SetSwappability[resident, interval, swappability, changeable];    END;  MakeEntryVectorSwappable: PUBLIC PROCEDURE [proc: --GENERIC-- PROCEDURE] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForEntryVector[proc];    SetSwappability[swappable, interval, swappability, changeable];    END;  MakeGlobalFrameResident: PUBLIC PROCEDURE [frame: --GENERIC-- PROGRAM] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    -- first make the global frame table page containing global frame entry resident    gftPointer: LONG POINTER ¬           @PrincOpsExtras2.GFT[FrameExtras.LongGFToGFTHandle[	  SpecialRuntimeExtras.GlobalFrameFromProgram[frame]]];    interval ¬ [Environment.PageFromLongPointer[gftPointer], 1];    SetSwappability[resident, interval, swappable, TRUE];    -- now make the global frame resident    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForGlobalFrame[frame];    SetSwappability[resident, interval, swappability, changeable];    END;  MakeGlobalFrameSwappable: PUBLIC PROCEDURE [frame: --GENERIC-- PROGRAM] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForGlobalFrame[frame];    SetSwappability[swappable, interval, swappability, changeable];    END;  MakeProcedureResident: PUBLIC PROCEDURE [proc: --GENERIC-- PROCEDURE] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForProcedure[proc];    SetSwappability[resident, interval, swappability, changeable];    END;  MakeProcedureSwappable: PUBLIC PROCEDURE [proc: --GENERIC-- PROCEDURE] =    BEGIN    interval: VM.Interval;    swappability: VM.Swappability;    changeable: BOOLEAN;    [interval, swappability, changeable] ¬      SpecialRuntime.GetSwapUnitsForProcedure[proc];    SetSwappability[swappable, interval, swappability, changeable];    END;  Map: PUBLIC PROCEDURE [    window: Space.Window, usage: Space.Usage, class: Space.Class,    access: Space.Access, life: Space.Life, swapUnits: Space.SwapUnitOption]    RETURNS [interval: Space.Interval] =    BEGIN    RETURN MapAtInternal[      at: Space.nullInterval, window: window, usage: usage, class: class,      access: access, life: life, swapUnits: swapUnits];    END;  MapAt: PUBLIC PROCEDURE [    at: Space.Interval, window: Space.Window, usage: Space.Usage,    class: Space.Class, access: Space.Access, life: Space.Life,    swapUnits: Space.SwapUnitOption] RETURNS [interval: Space.Interval] =    BEGIN    atPage: Environment.PageNumber ¬ Space.PageFromLongPointer[at.pointer];    mapUnit: VM.Interval ¬ VM.FindMapUnit[atPage];    IF at.count = 0 THEN ERROR Error[noWindow];    IF atPage IN [mapUnit.page..mapUnit.page + mapUnit.count)      OR mapUnit.page IN [atPage..atPage + at.count) THEN      ERROR Error[stillMapped];    IF ~SpecialSpaceExtras.IsAllocated[at] THEN ERROR Error[notAllocated];    RETURN MapAtInternal[at, window, usage, class, access, life, swapUnits];    END;  MapAtInternal: PROCEDURE [    at: Space.Interval, window: Space.Window, usage: Space.Usage,    class: Space.Class, access: Space.Access, life: Space.Life,    swapUnits: Space.SwapUnitOption] RETURNS [interval: Space.Interval] =    BEGIN    << Note that if at.count = 0 then this procedure is responsible for allocating      memory.  In this case, our caller has not supplied any memory to be mapped -      he has just supplied us with a window to be mapped to (at.pointer = NIL).>>    defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;    runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];    isDataSpace: BOOLEAN = (window.file.fileID = File.nullID);    mapUnit: VM.Interval;    usedVMBF: BOOLEAN ¬ isDataSpace; --might be reset by AllocateDataWindow    BEGIN    ENABLE      BEGIN      UNWIND => NULL;      ANY =>        BEGIN        ENABLE ANY => Bug[impossibleError];        -- This code MUST be idempotent!        cleanUpRuns: SpaceInternal.Runs = runs;        runs ¬ [TRASH, frame[]];	«FOR i: CARDINAL IN [0..LENGTH[cleanUpRuns.runs]) DO	  lock: FileLock.LockHandle ¬	    DiskBackingStore.DiskDataFromBSData[cleanUpRuns.runs[i].data].lock;	  storage: LONG POINTER;	  count: CARDINAL;	  IF lock # FileLock.nullLockHandle THEN	    BEGIN	    [storage: storage, count: count] ¬ FileLock.DeleteLock[lock];	    storage ¬ SpaceInternal.DeallocateStorage[storage, count];	    END;	  ENDLOOP;»        FinishWithRuns[cleanUpRuns];        IF isDataSpace AND hasSystemVolume AND window.file.fileID ~= File.nullID          THEN          BEGIN  -- clean up file behind data space          cleanUpFile: File.ID = window.file.fileID;          DeallocatePossibleDataWindow[            window.file.fileID, File.GetAttributes[window.file].type, window.base,            mapUnit.count];          window.file.fileID ¬ File.nullID;          END;        IF at.count = 0 AND mapUnit.page ~= 0 THEN {          mapUnit.page ¬ 0; Space.Deallocate[interval]};        REJECT;        END;      END;    mapUnit.page ¬ 0;  -- nonzero means should dealloc.    IF isDataSpace THEN      BEGIN      IF at.count > 0 AND window.count > at.count THEN  --        ERROR Error[invalidParameters];  -- Not enough VM supplied.      usedVMBF ¬ AllocateDataWindow[@window];      mapUnit.count ¬ window.count;      life ¬ dead;  -- ignore these client parameters in case of a data space      access ¬ readWrite;      END    ELSE      BEGIN      readOnly: BOOLEAN;      fileSize: File.PageCount;      IF window.base ~IN [File.firstPageNumber..File.lastPageNumber) THEN        ERROR Error[invalidWindow];      [fileSize, readOnly] ¬ KernelFile.GetFileAttributes[window.file];      IF readOnly AND access = readWrite THEN        ERROR Volume.ReadOnly[window.file.volumeID];      IF window.base >= fileSize THEN ERROR Error[noWindow];      mapUnit.count ¬ MIN[window.count, fileSize - window.base];      IF at.count > 0 AND mapUnit.count > at.count THEN  --        ERROR Error[invalidParameters];  -- Not enough VM supplied.      END;    interval ¬ [      pointer:      IF at.count = 0 THEN Space.Allocate[mapUnit.count].interval.pointer      ELSE at.pointer, count: mapUnit.count];    mapUnit.page ¬ Space.PageFromLongPointer[interval.pointer];    WITH sus: swapUnits SELECT FROM      unitary => NULL;      uniform => NULL;      irregular =>        BEGIN        suCount: Environment.PageCount ¬ 0;        FOR i: CARDINAL IN [0..LENGTH[sus.sizes]) DO          thisSize: Environment.PageCount = sus.sizes[i];          IF thisSize = 0 THEN ERROR Error[invalidSwapUnitSize];          suCount ¬ suCount + thisSize;          ENDLOOP;        IF suCount < mapUnit.count THEN ERROR Error[incompleteSwapUnits];        END;      ENDCASE => Bug[impossibleEndcase];    IF isDataSpace AND ~hasSystemVolume THEN      VM.Map[  -- Supply resident memory in this case        mapUnit, NIL, NIL, usage, class, access, swapUnits, alive, resident]    ELSE      BEGIN      runs ¬ SpaceInternal.GetRuns[  --        -- Could raise SpecialFile.InvalidParameters if client        -- shortened file since we got size above. "He shouldn't do that."        runs, [window.file, window.base, mapUnit.count], usedVMBF];      IF FileLock.lockingEnabled THEN        SpaceInternal.InsertLockIntoRuns[runs.runs, mapUnit.count, window, access];      VM.Map[        mapUnit, DiskBackingStore.Transfer, runs.runs, usage, class, access,        swapUnits, life, swappable];      MapLog.WriteLog[mapUnit, access, DiskBackingStore.Transfer, runs.runs];      FinishWithRuns[runs];      END;    RETURN[[Space.LongPointerFromPage[mapUnit.page], mapUnit.count]];    END;  --scope of ANY--    END;  --MapAtInternal--  OperationHandler: PROCEDURE =    BEGIN    -- Processes operations in opnQueue    -- We run him at a reserved priority level for state vector reasons    Process.SetPriority[ProcessPrioritiesExtras.priorityPageFaultLow];    DO  -- Forever      opn: Operation;      AwaitOpn: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]        RETURNS [opn: Operation] =        BEGIN        opnPtr: OpnQueneEntryPtr;        WHILE opnQLastInUse = NIL DO WAIT newOperation; ENDLOOP;        opnPtr ¬ opnQLastInUse.next;        opn ¬ opnPtr.opn;        opnQLastInUse ¬          IF opnPtr.next = opnPtr THEN NIL ELSE opnQLastInUse.next.next;        opnPtr.next ¬ opnQFirstFree;        opnPtr.state ¬ free;        opnQFirstFree ¬ opnPtr;        NOTIFY queueEntryFree;        END;      opn ¬ AwaitOpn[@opnQueueLock];      WITH o: opn SELECT FROM        unmap => VM.Unmap[Space.PageFromLongPointer[o.interval.pointer]];        fault =>          BEGIN          fielder: FaultFieldEntryPtr;          GetFielder: ENTRY PROCEDURE [            lastFielder: FaultFieldEntryPtr, ml: LONG POINTER TO MONITORLOCK]            RETURNS [nextFielder: FaultFieldEntryPtr] =            BEGIN            nextFielder ¬              IF lastFielder = nilFaultFieldEntryPtr THEN              SELECT o.fault FROM                addressFault => addrFaultFielderList,                writeFault => writeProtectFaultFielderList                ENDCASE => BugV[impossibleEndcase] ELSE ffBase[lastFielder].next;            IF nextFielder ~= nilFaultFieldEntryPtr THEN              ffBase[nextFielder].lock ¬ ffBase[nextFielder].lock + 1;            END;          FielderHandled: ENTRY PROCEDURE [            fielder: FaultFieldEntryPtr, ml: LONG POINTER TO MONITORLOCK] =            BEGIN            IF (ffBase[fielder].lock ¬ ffBase[fielder].lock - 1) = 0 THEN              BROADCAST ffUnlocked            END;          FOR fielder ¬ GetFielder[nilFaultFieldEntryPtr, @faultFielderLock],            GetFielder[fielder, @faultFielderLock] WHILE fielder ~=            nilFaultFieldEntryPtr DO            SELECT ffBase[fielder].faultFielder[o.process, o.page] FROM              notInterested => NULL;              restart =>                BEGIN                VM.RestartFaultedProcess[o.process, o.fault];                FielderHandled[fielder, @faultFielderLock];                GO TO FaultHandled;                END;              handled => {                FielderHandled[fielder, @faultFielderLock]; GO TO FaultHandled; };              callDebugger => {                FielderHandled[fielder, @faultFielderLock]; EXIT; };              ENDCASE => Bug[impossibleEndcase];            FielderHandled[fielder, @faultFielderLock];            ENDLOOP;          -- We give the client a new process for Interpret Call's.          Process.Detach[            FORK FaultProcess[o.process, o.fault, o.page] !            Process.TooManyProcesses => {              FaultProcess[o.process, o.fault, o.page]; CONTINUE}];          EXITS FaultHandled => NULL;  -- and wait for another operation to perform          END;        ENDCASE => Bug[impossibleEndcase];      ENDLOOP;    END;  Pointer: PUBLIC PROCEDURE [pointer: LONG POINTER] RETURNS [POINTER] =    BEGIN    mdsPage: Environment.PageNumber = Space.PageFromLongPointer[      LONG[LOOPHOLE[1, POINTER]]];    wordsPerMDS: LONG CARDINAL =      LONG[Environment.wordsPerPage] * LONG[Environment.maxPagesInMDS];    IF Space.PageFromLongPointer[pointer] IN      [mdsPage..mdsPage + Environment.maxPagesInMDS) THEN      RETURN[Inline.LowHalf[pointer - Space.LongPointerFromPage[mdsPage]]]    ELSE ERROR Error[invalidParameters];    END;  PointerFromPage: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [POINTER] =    BEGIN    mdsPage: Environment.PageNumber = Space.PageFromLongPointer[      LONG[LOOPHOLE[1, POINTER]]];    IF page IN [mdsPage..mdsPage + Environment.maxPagesInMDS) THEN      RETURN[        LOOPHOLE[Inline.LowHalf[page - mdsPage] * Environment.wordsPerPage,          POINTER]]    ELSE ERROR Error[invalidParameters];    END;  QueueOperation: ENTRY PROCEDURE [opn: Operation, ml: LONG POINTER TO MONITORLOCK] =    BEGIN    opnPtr: OpnQueneEntryPtr;    WHILE opnQFirstFree = NIL DO WAIT queueEntryFree; ENDLOOP;    opnPtr ¬ opnQFirstFree;    opnQFirstFree ¬ opnQFirstFree.next;    opnPtr­ ¬ [state: waitingAction, next: NIL, opn: opn];    IF opnQLastInUse = NIL THEN opnPtr.next ¬ opnQLastInUse ¬ opnPtr  -- empty list    ELSE      BEGIN  -- non-empty list      first: OpnQueneEntryPtr = opnQLastInUse.next;      opnQLastInUse.next ¬ opnPtr;      opnPtr.next ¬ first;      opnQLastInUse ¬ opnPtr;      END;    NOTIFY newOperation    END;  RegisterAddressFaultFielder: PUBLIC PROCEDURE [    fielder: SpecialSpace.FaultFielder] =    BEGIN    RegisterFaultFielder[fielder, @addrFaultFielderList, @faultFielderLock];    END;  RegisterFaultFielder: ENTRY PROCEDURE [    fielder: SpecialSpace.FaultFielder,    listHead: LONG POINTER TO FaultFieldEntryPtr, ml: LONG POINTER TO MONITORLOCK] =    BEGIN    faultFielder: FaultFieldEntryPtr;    status: Zone.Status;    [faultFielder, status] ¬ ResidentHeap.MakeNode[SIZE[FaultFielderEntry]];    IF status ~= okay THEN Bug[unexpectedResidentHeapStatus];    ffBase[faultFielder] ¬ [next: listHead­, faultFielder: fielder];    listHead­ ¬ faultFielder;    END;  RegisterWriteProtectFaultFielder: PUBLIC PROCEDURE [    fielder: SpecialSpace.FaultFielder] =    BEGIN    RegisterFaultFielder[      fielder, @writeProtectFaultFielderList, @faultFielderLock];    END;  SetAccess: PUBLIC PROCEDURE [interval: Space.Interval, access: Space.Access] =    BEGIN    mapUnit: VM.Interval;    backingStoreRuns: VM.BackingStoreRuns;    diskBackingStoreData: DiskBackingStore.Data;    runs: ARRAY [0..1) OF BackingStore.Run;    transferProc: BackingStore.TransferProc;    IF access = readWrite THEN      BEGIN      page: Environment.PageNumber ¬ Space.PageFromLongPointer[interval.pointer];      pageEnd: Environment.PageNumber = page + interval.count;      WHILE page < pageEnd DO        currentInterval: Space.Interval;       [mapUnit: mapUnit, backingStoreRuns: backingStoreRuns, transferProc: transferProc] ¬          VM.GetMapUnitAttributes[page, DESCRIPTOR[runs]];	currentInterval ¬ [          pointer: Space.LongPointerFromPage[mapUnit.page], count: mapUnit.count];	IF mapUnit.count = 0 OR LENGTH[backingStoreRuns] = 0 THEN	  -- unmapped VM found, so find next mapped page	  BEGIN	  nextMapUnit: VM.Interval = VM.FindMapUnit[page];	  IF nextMapUnit = VM.nullInterval	    THEN EXIT -- no more mapped VM after page, so we're done	  ELSE page ¬ nextMapUnit.page;	  END	ELSE -- mapped VM found	  BEGIN	  IF transferProc # DiskBackingStore.Transfer THEN	    ERROR Error[invalidParameters];	  diskBackingStoreData ¬	    DiskBackingStore.DiskDataFromBSData[backingStoreRuns[0].data];	  IF diskBackingStoreData.fileAttributes.readOnly THEN	    BEGIN	    volume: Volume.ID;	    [file:[volumeID:volume]] ¬ SpecialFile.InterpretBackingStoreRun[	      runs[0]];	    ERROR Volume.ReadOnly[volume];	    END	  ELSE	    page ¬ Space.PageFromLongPointer[	      currentInterval.pointer] + currentInterval.count;	  END;        ENDLOOP;      END;    VM.SetAccess[interval: GetVMInterval[interval], access: access];    END;  SetCountThreshold: PUBLIC PROCEDURE [newThreshold: Environment.PageCount]    RETURNS [oldThreshold: Environment.PageCount] =    BEGIN    SetCountThresholdEntry: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] = {      oldThreshold ¬ countThreshold; countThreshold ¬ newThreshold};    SetCountThresholdEntry[@dataPoolLock];    END;  SetSwappability: PROCEDURE [    swappability: VM.Swappability, interval: VM.Interval,    currentSwappability: VM.Swappability, changeableSwappability: BOOLEAN] =    BEGIN    IF swappability = currentSwappability THEN      IF currentSwappability = resident THEN ERROR SpecialError[alreadyResident]      ELSE ERROR SpecialError[alreadySwappable];    IF ~changeableSwappability THEN ERROR SpecialError[fixedSwappability];    VM.SetSwappability[interval, swappability, wait];    END;  Unmap: PUBLIC PROCEDURE [pointer: LONG POINTER, returnWait: Space.ReturnWait]    RETURNS [nil: LONG POINTER] =    BEGIN    interval: Space.Interval = UnmapAt[ <<**>>      pointer: pointer, returnWait: returnWait];    Space.Deallocate[interval];    RETURN[NIL];    END;  UnmapAt: PUBLIC PROCEDURE [pointer: LONG POINTER, returnWait: Space.ReturnWait]    RETURNS [interval: Space.Interval] =    BEGIN    signal: --GENERIC-- SIGNAL ¬ NIL;    signalArgs: PrincOps.LocalFrameHandle;    UnmapAtEntry: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] = INLINE      BEGIN      defaultRuns: ARRAY [0..SpaceInternal.defaultRunSize) OF BackingStore.Run;      runs: SpaceInternal.Runs ¬ [DESCRIPTOR[defaultRuns], frame[]];      BEGIN      ENABLE        ANY =>          -- If anything goes wrong, remember the signal, unlock the          -- monitor, and exit.          BEGIN          [signal, signalArgs] ¬ SpecialRuntime.GetCurrentSignal[];	  FinishWithRuns[runs];          GO TO ErrorExit;          END;	        WHILE LENGTH[runs.runs] < countOfRuns DO        runs ¬ BiggerRuns[runs];	ENDLOOP;	        -- must initialize before using (for GetFileIDFromLock call)      runs.runs[0].data.data ¬ ALL[0];            mapUnit ¬ VM.GetMapUnitAttributes[page, runs.runs].mapUnit;      << In principle, at this point we should take notice of returnWait.            However, we don't do so since implementing the "return" option	    involves major cooperation from the Pilot file system and from the	    booting operations.  So, we treat all Unmap's as Unmap[..., wait];        >>	      -- must save fileID and page since deleting lock next and munging run      WITH d: DiskBackingStore.DiskDataFromBSData[runs.runs[0].data] SELECT        FileLock.lockingEnabled FROM	TRUE =>  BEGIN	         fileID ¬ FileLock.GetFileIDFromLock[d.lock].fileID;		 type ¬ d.type;		 filePage ¬ DiskBackingStore.PackFilePageNumber[		   d.filePageLow, d.filePageHigh];		 END;	FALSE => BEGIN	         fileID ¬ d.file;		 type ¬ d.type;		 filePage ¬ DiskBackingStore.PackFilePageNumber[		   d.filePageLow, d.filePageHigh];		 END;	ENDCASE;            -- if there is not a mapUnit, there can be no locks      -- also, locking must be enabled or there are no locks      IF mapUnit # VM.nullInterval AND FileLock.lockingEnabled THEN        BEGIN	-- run through whole mapUnit, freeing all locks as we go	FOR i: CARDINAL IN [0..countOfRuns) DO	  node: LONG POINTER;	  length: CARDINAL;	  WITH d: DiskBackingStore.DiskDataFromBSData[runs.runs[i].data] SELECT	    FileLock.lockingEnabled FROM	    TRUE => [storage: node, count: length] ¬ FileLock.DeleteLock[d.lock];	    FALSE => Bug[impossibleError];	    ENDCASE;	  node ¬ SpaceInternal.DeallocateStorage[node, length];	  ENDLOOP;	END;	      IF IsDataSpace[type] THEN VM.Kill[mapUnit];      VM.Unmap[mapUnit.page];-- ** gets some trushed space to be deallocated this time.           mapUnit ¬  FileLock.AnyTrashedSpace[mapUnit];      MapLog.WriteLog[mapUnit, readWrite, NIL, NIL];      FinishWithRuns[runs];      EXITS ErrorExit => NULL;      END;  -- Scope of ENABLE      END;  -- UnmapAtEntry    page: Environment.PageNumber = Space.PageFromLongPointer[pointer];    mapUnit: VM.Interval;    fileID: File.ID;    filePage: File.PageNumber;    type: File.Type;    countOfRuns: CARDINAL =       VMExtraExtras.GetMappedRunCount[Space.PageFromLongPointer[pointer]];        -- In principle, at this point we should take notice of returnWait.    --   However, we don't do so since implementing the "return" option involves    --   major cooperation from the Pilot file system and from the booting    --   operations.  So, we treat all Unmap's as Unmap[..., wait];    UnmapAtEntry[@unmapLock];    IF signal # NIL THEN SpecialRuntime.ReraiseError[signalArgs, signal];    DeallocatePossibleDataWindow[fileID, type, filePage, mapUnit.count];    RETURN[[Space.LongPointerFromPage[mapUnit.page], mapUnit.count]];    END;  END.LOG24-Aug-82 11:22:42	AWL        Created file from Space.mesa of 29-Apr-82 12:29:26. 6-Oct-82 10:23:09	AWL        Map and MapAt now take a Space.Life parameter.23-Dec-82 19:53:28	AWL        Misc fixes for new VM/Space interfaces. 4-Jan-83 19:05:37	JXP     When mapping a data space take count from specified interval, not the window. Fix faulter fielder bug.14-Jan-83 18:59:29	AWL        Have GetMapUnitAttributes work correctly in UtilityPilot for data spaces. 4-Mar-83 16:44:47	AWL        Four monitors: data spaces, fault fielders, operation queue and serialize unmaps.  More perf. stuff.  Fixed map and mapAt so that only one call will be made to get the file's size.  Added MapAtInternal and made it clean up resources after raising an error. 8-Mar-83 10:23:22	JXP     Modify GetRuns to use the new interface to SpecialFile.GetBackingStoreRun.  When calling GetRuns from MapAtInternal make sure to pass in the proper count.29-Mar-83  8:10:31	JXP     Fix problem with allocation of data windows (wrong window passed to  AllocateDataWindow). Initialize dataPoolBase (=spaceAllocBase+spaceAllocCount). 1-Apr-83 15:54:15	AWL        Implement RegisterAddressFaultFielder and RegisterWriteProtectFaultFielder.  Fix DoneWith* to free up resident heap nodes when appropriate.25-Apr-83 13:53:00	JXP     Run FaultFielders at priority clientHigh.26-Apr-83 10:46:52	JXP     When recovering from an error in MapAtInternal, only deallocate the data window  if we got around to allocating one (check the file id).26-Apr-83 14:04:56	JXP     MapAtInternal has to be smarter about its validity check when it is about to  allocate a data window.29-Apr-83 17:43:08	AWL        DoCopy: failed to recognize window.base when window.count >file size. 3-May-83 15:54:29	EKN     ActivateProc: failed to raise Space.Error[invalidProcedure] for nil or unbound procedures 4-May-83 10:47:45	JXG      ActivateProc: corrected check for Space.Error[invalidProcedure]   DeactivateProc: also raises Space.Error[invalidProcedure] if appropriate 4-May-83 14:40:02 	JXG      check if interval is allocated in MapAt 20-May-83 10:51:54	JXG      improve MakeResident/MakeSwappable; provide SpecialRuntimeExtras.GetSwapUnitsForCode23-May-83 17:34:08	JXG       bug fix in GetSwapUnitsForCode 24-May-83 10:37:10	JXG       ignore client's access and life in MapAtInternal when mapping a data space 25-May-83 15:00:08	JXG       ...yet another go at getting swappability correct in GetSwapUnitsForCode 1-Jun-83 11:36:16	JXP       Handle ERRORs in UnmapAt - unlock the unmap monitor.  2-Jun-83 14:39:26	JXG       ...yet another go at getting swappability correct in GetSwapUnitsForCode -   change GetswapForCode to GetSwapUnitsFromBcd; remove SpecialRuntimeExtras;   SetSwappability returns result of interval; this result to be propogated to   next level on next round of interface changes10-Jun-83 15:40:02	JXG        checked if interval is already mapped in MapAt 14-Jun-83 10:39:02	JXG       add GetSwapUnitsFor...21-Jun-83 11:28:20	JXG       make GetSwapUnitsFor... work even on swappable stuff in startlist before it has been mapped  21-Jun-83 13:47:27	JXG       move GetswapUnitsFor... to VMImpl23-Jun-83 15:37:01	JXG        fold in Extras 12-Jul-83 14:50:55	JXP       Use the new VMMPrograms interface (fix up call to InitializeMapLog), and    the new StoragePrograms interface (InitVMMgr). Twiddles to make compile.26-Jul-83 10:56:28	WDK        Didn't check for file size <= window.count.11-Aug-83 17:11:40	WDK        SetSwappability should do check changeableSwappability last.18-Oct-83 16:46:19	CAJ    Map now raises noWindow if window.count = 0; DoneWithFaultHandler heap   reference problems corrected. 7-Dec-83 20:51:18	WDK        AR 5024: GetMapUnitAttributes[mapUnitNotFromSpace] => crash   Didn't raise Error[invalidParameters] if map unit was not created   by SpaceImpl or if e.g. File.Unknown.   Eliminate unnecessary GetFileAttributes in CopyIn.   Rewrite bogus error handling logic in DoCopy.   Eliminate redundant variables.   AR 4721: VM for "extra" backing store runs lost after File.MissingPages.   AR 5039: System Error during Space.MapAt.   AR 3567: MakeWritable[readOnlyVol] must raise Volume.ReadOnly.10-Jan-84  8:53:28 	EKN     Added DoCopyHelperProcess so that the proper errors raised in VM will not be thrown away when the Copy operations are done with a return vs. wait. For DoCopy and DoCopyHelperProcess to communicate the following were created: SendMessageToHelper, WaitForMessageFromHelper, WaitForNewMessage, SendNewMessageProcessed. (AR 4064,4337)   Also UnmapAtEntry now has a check to Kill a dataSpace before doing the Unmap (to save extra ForceOuts to the disk)13-Jan-84 14:54:43 	AWL         SetAccess[...readWrite] failed if unmapped at end AND the following VM was mapped to a read-only volume.26-Mar-84 14:11:50      KEK       AR 4707: Modified SetAccess to call VM.GetMapUnitAttributes (vs. the local one) directly, and to access DiskBackingStore's Data.fileAttributes.readOnly cache (vs. calling Volume.GetAttributes).   added a cache implementation to GetRuns (incl. call to GetBackingStoreRunsWithCache).17-Aug-84 12:00:26      EKN      Changed SpaceInternal to SpecialSpaceExtras.  GetMapUnitAttributes compares transferProcs...raised ERROR[invalidParameters] if they differ. 7-Aug-85 17:06:14      RSV    Added verySmallAnonymousBackingFile switch for VM backing file 1-Feb-86 10:54:02	CJS  Need two maplogs for client side map cleaning. 1-Jul-86 11:27:10	RRR  Fix 9567 in MapAtInternal.25-Aug-86 11:44:52      RSV  Added largerCountDataPool, veryLargeCountDataPool, veryVeryLargeCountDataPool, and hugeCountDataPool sizes.25-Aug-86 11:47:06      RSV  Changed window.base to 0 instead of 1 (used to avoid a disk label check by having this set to 1) and added CHANGE comments about Mapped File Locking.15-Sep-86 13:06:40      ET   Change ProcessPriorities to ProcessPrioritiesExtras for priorityPageFaultLow. 4-Nov-86  9:53:32      RSV  Changed name to SpaceImplA.  Moved Runs, AllocationSource, maxNumberNodes to SpaceInternal.  Made FinishWithRuns and GetRuns public to SpaceInternal.20-Nov-86 13:49:37      RSV  Initialize FileLock machinery before using variables from it.  Also initialize run.data to ALL[0] before passing this value anywhere.23-Nov-86 16:17:56      RSV  Added check to see if we overrun mapunit in Unmap. 1-Dec-86  9:13:14      RSV  Correction to determining file lock file size.  Also, skip deleting locks if pointer = NIL in Unmap. 8-Dec-86 13:46:39      RSV  Clean up locks space in MapAtInternal.  Changed around Unmap to always get correct number of runs.  Got rid of last of CHANGE comments.16-Dec-86 11:54:22      RSV  Set PilotMP.cInsuffFileLockStorage if needed during initialization.19-Dec-86 18:13:40      RSV  Used lockAllocationPoolSpace.count before initialization.  Now use lockAllocationPoolSize until after initialization. 8-Jan-87 22:44:12      RSV  Dynamically allocate correct number of runs in Unmap (finally the correct way).14-Jan-87 21:01:10	ET   MDS relief: all POINTER TO MONITORLOCKs become LONG POINTERS TO MONITORLOCKs since the monitor locks are global variables. MDS relief: Added code to MakeGlobalFrameResident to make the GFT page containing the globalframe also resident. It remains resident even after the global frame is made swappable. Moved GetRuns to SpaceImplB cause of compiler storage overflow.16-Jan-87 15:10:46	ET   added public cache. 4-Feb-87 14:14:07      RSV  Added parameter to InsertLockIntoRuns.13-Nov-87 17:44:52	KEK  bumped countLog from 40 to 60.  AR 11994.17-Dec-87 20:05:59      RSV  initialize SpaceInternal.lowerBound. 6-Jan-88 18:55:25      RSV  For the file lock file initially map incrementOnPilot if it is NOT UtilityPilot.25-Jan-88 14:29:20	RSV  AR 12673 - cardinal overflow in InitializeVMMgr while allocating fileLockSpace' space. 1-Aug-88 13:39:44      RSV  Fix to allow disabling of mapped file locking (edits to InsertLockIntoRuns, MapAtInternal, and UnmapAt.30-Mar-89 13:46:13	TXT  move InsertLockIntoRuns into SpaceImplB11-Apr-89 13:43:28	TxH  added the initialization of the mapUnitIndex variable imported from SpaceInternal. Changed Unmap proc. Made some other related changes. (SS-FX: AR#6, AR#26)16-May-89 11:08:19	TxH  change the calling point of FileLock.AnyTrashedSpace for correct map-loging, and made some other change.
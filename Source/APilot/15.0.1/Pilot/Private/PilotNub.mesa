-- Copyright (C) 1984, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- ResMemMgr>PilotNub.mesa        17-Nov-87 18:31:47 by CAJ    -- This module mediates all trips to the debugger, and is the debugger's representative in the client world.DIRECTORY  Boot USING [Location],  ControlModuleFormat USING [Call],  CPSwapDefs USING [    BBArray, BreakpointHandlerItem, currentVersion, ExternalStateVector,    nullBootSession, OperandDesc, PatchTable, Relations, ShortOrLong, SignalError,    StorageFaultType, SwapData, SwapInfo, UBBPointer, UserBreakBlock],  DebuggerSwap USING [AwaitDebuggerRequest, canSwap, parameters],  DeviceCleanup USING [Item, linkage, Linkage, Perform, Reason],  Environment USING [    LongPointerFromPage, PageCount, PageFromLongPointer, PageNumber],  ESCAlpha USING [aWRIT, aRRIT],  Frame USING [    GetReturnFrame, MyLocalFrame, ReadPC, ReadReturnLink, SetReturnFrame,    SetReturnLink, WriteReturnLink],  FrameExtras USING [GFTHandleToLongGF, GlobalOverhead, ReadCodebase, ReadGlobalLink],  GermOps USING [InLoad, OutLoad, Teledebug],  Inline USING [LowHalf],  KeyboardFace USING [keyboard, DownUp],  LevelVKeys,  Mopcodes USING [op, zDUP, zESC, zRLFS],  PilotMP USING [cCleanup, cHang],  PilotSwitches USING [hang, interruptWatcher, remoteDebug],  PrincOps USING [    BYTE, BytePC, ControlLink, FieldDescriptor, LocalFrameHandle,    Port, PrefixHandle, StateVector],  PrincOpsExtras2 USING [ControlLink, NewSignalDesc],  Process USING [GetPriority, Priority, SetPriority, Ticks],  ProcessOperations USING [    DisableInterrupts, EnableInterrupts, Enter, Exit, HandleFromIndex,    HandleFromProcess, IndexFromHandle, IndexFromProcess, ReadMDS,    ReadPSB, ReadPTC, ReadWDC, WritePSB, WritePTC, WriteWDC],  ProcessorFace USING [    BootButton, GetClockPulses, microsecondsPerHundredPulses, mp, SpecialSetMP],  ProcessPriorities USING [priorityFrameFault],  PSB USING [    Condition, PDA, PsbNull, qFrameFault, qPageFault, qWriteProtectFault, Ticks],  Runtime USING [],  RuntimeInternal USING [Bug, SourceDest],  SDDefs USING [sBreakTrap, SD, sXferTrap],  SpecialRuntime,  SpecialRuntimeExtras USING [ProgramFromGlobalFrame],  StoragePrograms USING [countVM],  System USING [GetClockPulses, switches, systemBootDevice],  VMMapLog USING [Descriptor],  Volume USING [nullID],  XferTrap USING [ReadXTS, Status, WriteXTS];PilotNub: MONITOR  -- just for CheckInterrupt, DeviceCleanup.Install  IMPORTS    ControlModuleFormat, Environment, GermOps, DebuggerSwap, DeviceCleanup,    Frame, FrameExtras, Inline, KeyboardFace, Process, ProcessOperations,    ProcessorFace, RuntimeInternal, SpecialRuntimeExtras,    StoragePrograms, System, XferTrap  EXPORTS    DebuggerSwap, DeviceCleanup, Runtime, RuntimeInternal, SpecialRuntime,    StoragePrograms  SHARES DeviceCleanup, RuntimeInternal =  BEGIN  -- PARAMETERS:    conditionalBreakBlocks: CARDINAL = 4;  -- Debugger communication data:  sessionState: CPSwapDefs.ExternalStateVector ¬ [    -- Exclusive access to this data is provided by disabling interrupts.    version: CPSwapDefs.currentVersion,    bootSession: TRASH,    loadState: NIL,    mapLog: NIL,    patchTable: NIL,    breakBlocks: @breakBlocks.header,    breakpointHandlers: @standardBreakHandler,    mds: ProcessOperations.ReadMDS[],    faultsBeingProcessed: ALL[NIL],    systemVolumeID: Volume.nullID,    virtualMemoryCount: StoragePrograms.countVM,    patchTableInUse: FALSE,    breakBlocksInUse: FALSE,    loadStateChanging: FALSE,    loadStateDirty: TRUE,  -- set FALSE by debugger    swapData: TRASH,    spareA: TRASH,    spareB: TRASH];    -- Breakpoint handler data:    standardBreakHandler: CPSwapDefs.BreakpointHandlerItem ¬ [    handler: LOOPHOLE[BreakPoint, PrincOpsExtras2.ControlLink],    type: standard, next: @noAllocBreakHandler];  noAllocBreakHandler: CPSwapDefs.BreakpointHandlerItem ¬ [    handler: TRASH, type: noAlloc, next: NIL];  -- Conditional breakpoint data:  BreakBlocks: TYPE = MACHINE DEPENDENT RECORD [    header(0): CPSwapDefs.BBArray,  -- length plus zero-length array of blocks.    body(1): ARRAY [0..conditionalBreakBlocks) OF CPSwapDefs.UserBreakBlock];  breakBlocks: BreakBlocks ¬ [  --    -- (break data is set by the debugger via "magic stores".)    header: [length: conditionalBreakBlocks, blocks: NULL],    body: ALL[ CPSwapDefs.UserBreakBlock[      codeBase: NIL, pc: [0], inst: 0, relation: CPSwapDefs.Relations.FIRST,      leftOperand: TRASH, rightOperand: TRASH]]];  breakReaders: CARDINAL ¬ 0;  breakReaderLock: MONITORLOCK;  -- just covers breakReaders.  -- Keyboard Interrupt Data:  -- Must use LevelVKeys.mesa to index keyboard as UserTerminal.keyboard is swappable.  ticksPerWakeup: Process.Ticks = 6;  -- only every 1/10th sec to minimize compute overhead.    Lock: LevelVKeys.KeyName = LevelVKeys.KeyName.Lock;  LeftShift: LevelVKeys.KeyName = LevelVKeys.KeyName.LeftShift;  RightShift: LevelVKeys.KeyName = LevelVKeys.KeyName.RightShift;  Stop: LevelVKeys.KeyName = LevelVKeys.KeyName.Stop;  keyboard: LONG POINTER TO LevelVKeys.KeyBits;   -- Linkage to debugger:  debuggerFielder:  --POINTER TO DebuggerSwap.AwaitDebuggerRequest--    PROCEDURE [LONG POINTER TO CPSwapDefs.ExternalStateVector];     -- xfer to this to get to debugger.  -- Code packaging handle:  SpecialResidentCodeHandle: PUBLIC --StoragePrograms.-- PROCEDURE = {};  -- This procedure's only purpose is to provide a handle on the PilotKernel  -- CODE PACK which contains resident code which may be moved to reserved memory.  -- Misc Data and Private Signals:    -- "Local" variables for InitializeAwaitDebuggerRequest:  -- (These are made globals so they can be initialized by separate code.  pulsesPerTwentySeconds: LONG CARDINAL;  nullCondition: PSB.Condition = [    tail: PSB.PsbNull, abortable: FALSE, wakeup: FALSE];  FinishUnwindingProcess: PRIVATE SIGNAL = CODE;  BugType: TYPE = {badFieldSize, funnyCase, notImplemented};  MyBug: PROC [type: BugType] = {RuntimeInternal.Bug[type]};  MyBugValue: PROC [type: BugType] RETURNS [UNSPECIFIED] =    {MyBug[type]; RETURN[0]};  MyBugLongValue: PROC [type: BugType] RETURNS [LONG UNSPECIFIED] =    {MyBug[type]; RETURN[0]};  --============== Initialization: ==============  InitializePilotNub: PUBLIC --StoragePrograms.-- PROC [] =    BEGIN        InitializeDeviceCleanup[];    DO      sessionState.bootSession ¬ System.GetClockPulses[];      IF sessionState.bootSession # CPSwapDefs.nullBootSession THEN EXIT;      ENDLOOP;    LOOPHOLE[PSB.PDA.available, CPSwapDefs.SwapInfo].externalStateVector ¬      @sessionState;    SDDefs.SD[SDDefs.sBreakTrap] ¬ LOOPHOLE[BreakPoint];        -- Initialize for worry break:    InitializeNoAllocBreak[];  -- allocates frame, initializes port.    -- (This must follow InitializeNoAllocBreak)    [] ¬ InitializeWorryCallDebugger[];  -- allocates frame, initializes PORT.    -- (This must follow InitializeNoAllocBreak)    [] ¬ InitializeBug[];  -- allocates frame, initializes port.    [] ¬ InitializeFlushTrashFromStack[];  -- allocates frame, initializes port.    pulsesPerTwentySeconds ¬      LONG[20]*1000000*100/ProcessorFace.microsecondsPerHundredPulses;    InitializeAwaitDebuggerRequest[];  -- allocates frame, initializes port.    END;  InitializeInterrupt: PUBLIC --StoragePrograms.-- PROC =    -- Initializes Pilot's keyboard interrupt watcher (if one was requested).    -- Must not be invoked until KeyboardFace has been initialized.    BEGIN    keyboard ¬ LOOPHOLE[KeyboardFace.keyboard];  -- initialized here (not globally) because KeyboardFace is now initialized    IF System.switches[PilotSwitches.interruptWatcher] = down THEN      BEGIN      throwAway: PROCESS;      priorityPrev: Process.Priority = Process.GetPriority[];      Process.SetPriority[ProcessPriorities.priorityFrameFault];      throwAway ¬ FORK CheckInterrupt[];  -- (no profit in Detaching)      Process.SetPriority[priorityPrev];      END;    END;  SetDebuggerFielder: PUBLIC --DebuggerSwap.-- PROCEDURE [    newDebuggerFielder: POINTER TO DebuggerSwap.AwaitDebuggerRequest]    RETURNS [      previousDebuggerFielder: POINTER TO DebuggerSwap.AwaitDebuggerRequest] =    BEGIN    << TYPE of debuggerFielder is PROCEDURE but it is really a       (LONG) POINTER TO PORT.  Since talking about LONG POINTERs TO PORTs doesn't       make any sense, we make the client deal with short pointers and hide the       grunge here.>>    previousDebuggerFielder ¬ Inline.LowHalf[LOOPHOLE[debuggerFielder]];    debuggerFielder ¬ LOOPHOLE[LONG[newDebuggerFielder]];    END;  --============== Breakpoint Processing: ==============  BreakPoint: PROC =  -- This is the normal trap handler for the BRK instruction.    BEGIN    lFrame: PrincOps.LocalFrameHandle;    codeBase: PrincOps.PrefixHandle;    pc: PrincOps.BytePC;    breakBlocks: LONG POINTER TO CPSwapDefs.BBArray;    d: RECORD [  -- (must allocate full size SwapData)      SELECT OVERLAID * FROM        bound => [swapData: breakpoint CPSwapDefs.SwapData],        unbound => [fullSizeSwapData: CPSwapDefs.SwapData],        ENDCASE];    instByteFromDebugger: PrincOps.BYTE;    sv: dst PrincOps.StateVector;    sv ¬ STATE;  -- dump stack. MUST be first instruction.    BeginReadingBreakData[];    breakBlocks ¬ sessionState.breakBlocks;  -- locate current break info.    lFrame ¬ Frame.GetReturnFrame[];    codeBase ¬ LOOPHOLE[FrameExtras.ReadCodebase[FrameExtras.ReadGlobalLink[lFrame]]];     pc ¬ Frame.ReadPC[lFrame];    BEGIN  --scope of DontBreak--    FOR k: CARDINAL IN [0..breakBlocks.length) DO      -- Look for condition for this break..      breakBlock: LONG POINTER TO CPSwapDefs.UserBreakBlock =        @breakBlocks.blocks[k];      IF breakBlock.codeBase = codeBase AND breakBlock.pc = pc THEN	BEGIN  -- found condition for this breakpoint..        IF ConditionSatisfied[breakBlock, lFrame, @sv] THEN  --	  EXIT  -- and take the break        ELSE	  BEGIN  -- condition false; return to client.	  sv.instbyte ¬ breakBlock.inst;	  EndReadingBreakData[];	  GOTO DontBreak;	  END;        END;      REPEAT	FINISHED =>  -- Condition not found;	  NULL;  -- fall through and unconditionally take the break.      ENDLOOP;    EndReadingBreakData[];    d.swapData ¬ [      lFrame: lFrame,      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: breakpoint[sv: @sv, instByteReceptacle: @instByteFromDebugger]];    CallDebuggerWithSwapData[@d.fullSizeSwapData];    sv.instbyte ¬ instByteFromDebugger;    EXITS DontBreak => NULL;    END;  --scope of DontBreak--    IF XferTrap.ReadXTS[] = on THEN XferTrap.WriteXTS[skip1];    STATE ¬ sv;  -- reload stack and break byte    RETURN;  -- will reexecute broken instruction using break byte.    END;  --BreakPoint--    BeginReadingBreakData: PROC = INLINE  -- (only called once)    BEGIN    WHILE NOT ProcessOperations.Enter[@breakReaderLock] DO NULL ENDLOOP;    sessionState.breakBlocksInUse ¬ TRUE;  -- keep others from altering.    breakReaders ¬ breakReaders.SUCC;    ProcessOperations.Exit[@breakReaderLock];    END;   EndReadingBreakData: PROC =    BEGIN    WHILE NOT ProcessOperations.Enter[@breakReaderLock] DO NULL ENDLOOP;    breakReaders ¬ breakReaders.PRED;    IF breakReaders = 0 THEN sessionState.breakBlocksInUse ¬ FALSE;    ProcessOperations.Exit[@breakReaderLock];    END;  ConditionSatisfied: PROC [    breakBlock: CPSwapDefs.UBBPointer, lFrame: PrincOps.LocalFrameHandle,    state: POINTER TO dst PrincOps.StateVector]    RETURNS [BOOLEAN] =  --out-of-line--    -- Returns TRUE if the breakpoint's condition is satisfied.    -- NOTE: This procedure is out-of-line    -- because the resident code is smaller that way.    BEGIN    leftOperand: LONG CARDINAL =      GetOperand[@breakBlock.leftOperand, lFrame, state];    rightOperand: LONG CARDINAL =      GetOperand[@breakBlock.rightOperand, lFrame, state];    RETURN[      SELECT breakBlock.relation FROM        eq => leftOperand = rightOperand,        ge => leftOperand >= rightOperand,        gt => leftOperand > rightOperand,        le => leftOperand <= rightOperand,        lt => leftOperand < rightOperand,	ne => leftOperand # rightOperand,	ENDCASE => MyBugValue[funnyCase]];    END;  --ConditionSatisfied--  GetOperand: PUBLIC --RuntimeInternal.-- PROC [    opDesc: LONG POINTER TO CPSwapDefs.OperandDesc,    lFrame: PrincOps.LocalFrameHandle,    state: POINTER TO dst PrincOps.StateVector]    RETURNS [opVal: LONG CARDINAL] =    BEGIN    PS: TYPE = POINTER TO CPSwapDefs.ShortOrLong;    PPS: TYPE = POINTER TO PS;    PLPS: TYPE = POINTER TO LONG POINTER TO CPSwapDefs.ShortOrLong;    IF opDesc.fieldSize = 32 THEN      BEGIN  -- long operand      RETURN[WITH op: opDesc SELECT FROM	counter => op.timesSoFar ¬ op.timesSoFar.SUCC,	immediate => op.value,	localVariable => LOOPHOLE[@lFrame[op.index], PS].long,	stack => LOOPHOLE[@state.stk[op.index], PS].long,	memory => op.address.long,	localIndirect => (LOOPHOLE[@lFrame[op.index], PLPS]­+op.offset).long,	localIndirectShort => (LOOPHOLE[@lFrame[op.index], PPS]­+op.offset).long,	stackIndirect => (LOOPHOLE[@state.stk[op.index], PLPS]­+op.offset).long,	stackIndirectShort => (LOOPHOLE[@state.stk[op.index], PPS]­+op.offset).long,	memoryIndirect => (op.addressOfPointer­+op.offset).long,	memoryIndirectShort => (op.addressOfPointer­+op.offset).long,	ENDCASE => MyBugLongValue[funnyCase]	];      END    ELSE      BEGIN  -- short operand      ReadField: PROC [LONG POINTER TO CARDINAL, PrincOps.FieldDescriptor]	RETURNS [CARDINAL] = MACHINE CODE {Mopcodes.zRLFS};      shortVal: CARDINAL ¬ WITH op: opDesc SELECT FROM	counter => Inline.LowHalf[op.timesSoFar ¬ op.timesSoFar.SUCC],	immediate => Inline.LowHalf[op.value],	localVariable => lFrame[op.index],	stack => state.stk[op.index],	memory => op.address.short,	localIndirect => (LOOPHOLE[@lFrame[op.index], PLPS]­+op.offset).short,	localIndirectShort => (LOOPHOLE[@lFrame[op.index], PPS]­+op.offset).short,	stackIndirect => (LOOPHOLE[@state.stk[op.index], PLPS]­+op.offset).short,	stackIndirectShort => (LOOPHOLE[@state.stk[op.index], PPS]­+op.offset).short,	memoryIndirect => (op.addressOfPointer­+op.offset).short,	memoryIndirectShort => (op.addressOfPointer­+op.offset).short,	ENDCASE => MyBugValue[funnyCase];      IF opDesc.fieldSize > 16 THEN MyBug[badFieldSize];      RETURN[LONG[ReadField[@shortVal,	[offset: 0, posn: opDesc.fieldPosition, size: opDesc.fieldSize]]]];      END;    END; --GetOperand--  InitializeNoAllocBreak: PROCEDURE [] RETURNS [--to match port args--] =    -- This is an alternate trap handler for the BRK instruction.    -- The debugger's Worry command installs it to be the current trap handler.    -- Note that this routine runs with interrupts disabled.    BEGIN    instByteFromDebugger: PrincOps.BYTE;    sourceDest: RuntimeInternal.SourceDest;    state: dst PrincOps.StateVector;    noAllocBreakHandler.handler ¬ [frame[Frame.MyLocalFrame[]]];    -- Set TRANSFER to return to caller:    state.instbyte ¬ 0;    state.stkptr ¬ 0;  -- SIZE of return items of InitializeNoAllocBreak.    ProcessOperations.DisableInterrupts[];  -- to cancel enable below.    DO  --FOREVER--      -- Return to caller; await next worry breakpoint:      sourceDest.dest ¬ [frame[Frame.GetReturnFrame[]]];      sourceDest.source ¬ --PrincOps.NullLink--LOOPHOLE[0];      IF XferTrap.ReadXTS[] = on THEN XferTrap.WriteXTS[skip1];      STATE ¬ state;  -- must be last instn before TRANSFER.      TRANSFER WITH sourceDest;  -- (interrupts enabled by TRANSFER)      -- Note that interrupts are disabled by the BRK instruction trap      --   because it is XFERing to a frame. Also, the XFER sets my return link.      -- Process worry breakpoint:      state ¬ STATE;  -- dump stack. MUST be first instn after TRANSFER.      sessionState.swapData ¬ [	lFrame: Frame.GetReturnFrame[],	process: TRASH,	mayCallDebuggee: FALSE, trashWasOnStack: FALSE, fillA: TRASH,	body: breakpoint[sv: @state, instByteReceptacle: @instByteFromDebugger]];      debuggerFielder[@sessionState];      state.instbyte ¬ instByteFromDebugger;      ENDLOOP;    END;  --InitializeNoAllocBreak--  --============== Uncaught Signals: ==============  ProcessUncaught: PUBLIC --RuntimeInternal.-- PROCEDURE [    signal: --GENERIC-- SIGNAL, signalArgs: PrincOps.LocalFrameHandle,     signalError: CPSwapDefs.SignalError, raiser: PrincOps.LocalFrameHandle,    root: PrincOps.LocalFrameHandle] =    BEGIN    swapData: CPSwapDefs.SwapData ¬ [  -- (must allocate full size SwapData)      lFrame: raiser,      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: uncaughtSignal[	signal: LOOPHOLE[signal, PrincOpsExtras2.NewSignalDesc],	signalError: signalError, signalArgs: signalArgs]];    CallDebuggerWithSwapData[      @swapData !  --      ABORTED => {        IF signal --already-- = ABORTED THEN {          StartUnwindingProcess[root]; ERROR FinishUnwindingProcess}        ELSE REJECT}  -- let ABORTED propagate.      ];    END;  --ProcessUncaught--  StartUnwindingProcess: PROC [root: PrincOps.LocalFrameHandle] =    -- This procedure splices its local frame into the call stack just above    -- the root frame of the current process, then returns, leaving its local    -- frame still allocated. Our caller raises FinishUnwindingProcess which is    -- in turn caught by this procedure (now above the entire original    -- call stack of this process; the signal is unwound, thus freeing all frames    -- of the process; then this procedure returns (with no results),    -- which causes the process to be deleted. If the process was supposed to    -- return any results, the parent of the process will get a stack error    -- when it attempts to JOIN it.    BEGIN    Caller: PROC[ --must match results of StartUnwindingProcess-- ] =      LOOPHOLE[LONG[Frame.GetReturnFrame[]]];    Frame.SetReturnFrame[Frame.ReadReturnLink[root].frame];    Frame.WriteReturnLink[lf: root, cl: [frame[Frame.MyLocalFrame[]]]];    Caller[ ! FinishUnwindingProcess => CONTINUE];    END;  -- process disappears  --============== Address and WriteProtect Faults: ==============  ReportFault: PUBLIC --RuntimeInternal.-- PROCEDURE [    process: PROCESS, faultType: CPSwapDefs.StorageFaultType] =    BEGIN    swapData: CPSwapDefs.SwapData ¬ [  -- (must allocate full size SwapData)      lFrame: PSB.PDA[PSB.PDA[        ProcessOperations.HandleFromProcess[process]].context.state].frame,      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: storageFault[        faultedProcess: ProcessOperations.IndexFromProcess[process],	type: faultType]];    CallDebuggerWithSwapData[@swapData];    END;  --ReportFault--  --~~~~~~~~~ Keyboard Go-To-Debugger Interrupt: ~~~~~~~~~  CheckInterrupt: ENTRY PROCEDURE =    -- Optional Pilot-supplied keyboard go-to-debugger process.    BEGIN    wakeup: CONDITION ¬ [timeout: ticksPerWakeup];    prevKeysState: {allKeysDown, someKeyUp};  -- initialized to TRASH is ok    DO  --FOREVER--      ENABLE ABORTED => CONTINUE;      WAIT wakeup;      IF keyboard[Lock] = down        AND keyboard[LeftShift] = down        AND keyboard[RightShift] = down        AND keyboard[Stop] = down THEN	BEGIN  -- all keys down	IF prevKeysState = someKeyUp THEN  -- only call on downward transition.          BEGIN	  ProcessOperations.DisableInterrupts[];	  sessionState.swapData ¬ [	    lFrame: Frame.MyLocalFrame[],	    process: TRASH,	    mayCallDebuggee: FALSE,	    trashWasOnStack: --probably--FALSE, fillA: TRASH,	    body: interrupt[]];	    debuggerFielder[@sessionState];	    ProcessOperations.EnableInterrupts[];	  END;	prevKeysState ¬ allKeysDown;	END      ELSE prevKeysState ¬ someKeyUp;      ENDLOOP;    END;  --CheckInterrupt--  --============== Miscellaneous Runtime, RuntimeInternal items: ==============  CallDebugger: PUBLIC --Runtime.-- PROC [s: LONG STRING] =    BEGIN    swapData: CPSwapDefs.SwapData ¬ [  -- (must allocate full size SwapData)      lFrame: Frame.GetReturnFrame[],      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: callDebugger[message: s]];    CallDebuggerWithSwapData[@swapData];    END;  Interrupt: PUBLIC --Runtime.-- PROC =    BEGIN    swapData: CPSwapDefs.SwapData ¬ [  -- (must allocate full size SwapData)      lFrame: Frame.GetReturnFrame[],      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: interrupt[]];    CallDebuggerWithSwapData[@swapData];    END;  WorryCallDebuggerInternal: PUBLIC  --RuntimeInternal.--    PROCEDURE [message: LONG STRING];  -- an indirect control link to the PORT in InitializeWorryCallDebugger.    InitializeWorryCallDebugger: PROC RETURNS[ --matches port args-- ] =    -- WorryCallDebugger runs with interrupts disabled.    -- Note: Initially, AwaitWorryCallDebuggerRequest is set    -- to return to the caller of InitializeWorryCallDebugger.    BEGIN        AwaitWorryCallDebuggerRequest: --RESPONDING-- PORT[]      RETURNS [message: LONG STRING];      -- args/results match worryCallDebuggerInternal (but swapped).          message: LONG STRING;    trashWasOnStack: BOOLEAN;    WorryCallDebuggerInternal ¬ LOOPHOLE[LONG[@AwaitWorryCallDebuggerRequest]];    -- set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitWorryCallDebuggerRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      message ¬ AwaitWorryCallDebuggerRequest[];  -- Get next request.      -- Process request:      -- Note: interrupts were disabled by the caller.      trashWasOnStack ¬ FlushTrashFromStack[].trashWasOnStack;      Frame.SetReturnFrame[LOOPHOLE[AwaitWorryCallDebuggerRequest,        PrincOps.Port].dest.frame];  -- for debugging me.      sessionState.swapData ¬ [        lFrame: Frame.GetReturnFrame[],        process: TRASH,        mayCallDebuggee: FALSE,	trashWasOnStack: trashWasOnStack, fillA: TRASH,        body: callDebugger[message: message]];      debuggerFielder[@sessionState];      ENDLOOP;    END;  --InitializeWorryCallDebugger--  BugInternal: PUBLIC --RuntimeInternal.-- PROCEDURE [bugType: UNSPECIFIED];    -- an indirect control link to the PORT is set in InitializeBug.  InitializeBug: --INTERNAL-- PROCEDURE RETURNS[ --to match PORT args-- ] =    -- Note: Initially, AwaitBugRequest is set to return    --    to the caller of InitializeBug.    -- Note that this routine runs with interrupts disabled.    BEGIN        AwaitBugRequest: --RESPONDING-- PORT[] RETURNS [bugType: UNSPECIFIED];      -- args/results match BugInternal (but swapped).         bugType: CARDINAL;    trashWasOnStack: BOOLEAN;    BugInternal ¬ LOOPHOLE[LONG[@AwaitBugRequest]];    -- set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitBugRequest, PrincOps.Port].dest ¬ [frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Await new request:      bugType ¬ AwaitBugRequest[];      -- Note that interrupts have already been disabled by the caller.      -- Process request:      trashWasOnStack ¬ FlushTrashFromStack[].trashWasOnStack;      Frame.SetReturnFrame[  -- for debugging me.        LOOPHOLE[AwaitBugRequest, PrincOps.Port].dest.frame];      sessionState.swapData ¬ [	lFrame: Frame.GetReturnFrame[], process: TRASH,	mayCallDebuggee: FALSE, trashWasOnStack: trashWasOnStack,	fillA: TRASH, body: bug[bugType]];      debuggerFielder[@sessionState];      << The user SHOULD NOT ATTEMPT TO PROCEED after a Bug. If he      does, the implementation of Bug has previously disabled interrupts      (to serialize access to this local frame), and therefore we need      to enable interrupts to give him a fighting chance of continuing.      Notice that this allows the possibility of another process entering      and executing in this local frame concurrently with the current process,      leading to havoc. However, this is unlikely to happen, and the user's      attempt to continue past the Bug is expected to cause him much more trouble.>>      ProcessOperations.EnableInterrupts[];  -- good luck; you'll need it!      ENDLOOP;  --FOREVER--    END;  --InitializeBug--  CleanMapLog: PUBLIC --RuntimeInternal.-- PROC[] =    BEGIN    swapData: CPSwapDefs.SwapData ¬ [  -- (must allocate full size SwapData)      lFrame: Frame.GetReturnFrame[],      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: cleanMapLog[]];    CallDebuggerWithSwapData[@swapData];    END;  VisitDebugger: PUBLIC --SpecialRuntime.-- PROC[] =    BEGIN    swapData: CPSwapDefs.SwapData ¬ [  -- (must allocate full size SwapData)      lFrame: Frame.GetReturnFrame[],      process: TRASH,      mayCallDebuggee: TRASH, trashWasOnStack: TRASH, fillA: TRASH,      body: noOp[]];    CallDebuggerWithSwapData[@swapData];    END;  --============== Procedures that cause swap to debugger: ==============  CallDebuggerWithSwapData: PROC [swapData: POINTER TO CPSwapDefs.SwapData] =    -- Called with interrupts enabled.  Procedure calls and signals allowed.    -- For caller's convenience, sets swapData.mayCallDebuggee and    -- .trashWasOnStack (and .process is set by debuggerFielder).    BEGIN    currentData: POINTER TO CPSwapDefs.SwapData ¬ swapData;    ordersOrResults:  -- orders from debugger or interpret call results.      CPSwapDefs.SwapData;    state: dst PrincOps.StateVector;  -- should use ordersOrResults, but see AR4114    DO  --UNTIL reason = proceed--      ProcessOperations.DisableInterrupts[];      -- Now have exclusive access to sessionState, coroutines, etc.      currentData.trashWasOnStack ¬ FlushTrashFromStack[].trashWasOnStack;      currentData.mayCallDebuggee ¬ TRUE;      sessionState.swapData ¬ currentData­;      debuggerFielder[@sessionState];  -- off to debugger.      ordersOrResults ¬ sessionState.swapData; -- copied before enable      ProcessOperations.EnableInterrupts[];      -- Look at the SwapReason that the debugger gave us:      WITH orders: ordersOrResults SELECT FROM        callDebuggee, start =>	  BEGIN ENABLE ABORTED => {	    ordersOrResults.lFrame ¬ NIL;  -- other fields TRASH.	    ordersOrResults.body ¬ returnAborted[];	    CONTINUE};          currentData ¬ @ordersOrResults;	  -- NOTE the enable above.	  WITH ord: ordersOrResults SELECT FROM            callDebuggee => {	      state ¬ ord.sv;  -- AR 4114.	      STATE ¬ state;  -- args to stack. Must be last before call.	      ControlModuleFormat.Call[ord.proc]};	    start =>  {	      prog: PROGRAM ¬ SpecialRuntimeExtras.ProgramFromGlobalFrame[	        FrameExtras.GFTHandleToLongGF[ord.gFrame]];	      IF FrameExtras.GlobalOverhead[FrameExtras.GFTHandleToLongGF[	        ord.gFrame]].extra.started THEN	        RESTART prog              ELSE START prog};	    ENDCASE => MyBug[funnyCase];          state ¬ STATE;  -- Save return values. Must be first following return	  ordersOrResults.lFrame ¬ NIL;  -- other fields TRASH.	  ordersOrResults.body ¬ return[@state];	  -- Fall through and loop to return to debugger.          END;  --scope of ABORTED--	          -- kill => handled by debuggerFielder.        proceed => EXIT;        quit => ERROR ABORTED;        resizeBreakBlockTable => MyBug[notImplemented];        resizePatchTable => MyBug[notImplemented];        -- showScreen => handled by debuggerFielder.        ENDCASE => MyBug[funnyCase];      ENDLOOP;  --UNTIL reason = proceed--    END;  --CallDebuggerWithSwapData--  InitializeAwaitDebuggerRequest: PROCEDURE[] RETURNS[ --to match PORT args-- ] =    << Caller is responsible for setting pESV.swapData (except     swapData.process) and assuring that there is no excess trash on the stack.    Interrupts must be disabled by caller.    This procedure runs with interrupts disabled;  It may call      only inlines and coroutines.    Note: Initially, awaitDebuggerRequest is set to return      to the caller of InitializeAwaitDebuggerRequest.    It's nice to have the local variables of this procedure actually be globals      so that we can see their sizes in the packaging map, etc.    NOTE: THE CODE BELOW having to do with DeviceCleanup and GermOps is REPLICATED      in SnapshotImpl.mesa.  If you make a change here, make it there too.>>    BEGIN        awaitDebuggerRequest: DebuggerSwap.AwaitDebuggerRequest;    -- the port on which InitializeAwaitDebuggerRequest is pending.    -- = PORT RETURNS [LONG POINTER TO CPSwapDefs.ExternalStateVector];    ReadIntervalTimer: PROCEDURE RETURNS [LONG CARDINAL] = MACHINE CODE      {Mopcodes.zESC, ESCAlpha.aRRIT};    WriteIntervalTimer: PROCEDURE [LONG CARDINAL] = MACHINE CODE      {Mopcodes.zESC, ESCAlpha.aWRIT};          debuggerFielder ¬ LOOPHOLE[LONG[@awaitDebuggerRequest]];    -- sets InitializeAwaitDebuggerRequest to return to InitializePilotNub    LOOPHOLE[awaitDebuggerRequest, PrincOps.Port].out ¬ Frame.GetReturnFrame[];    DO  --FOREVER--      -- Await next request to go to debugger:      pESV: LONG POINTER TO CPSwapDefs.ExternalStateVector ¬ awaitDebuggerRequest[];      Frame.SetReturnFrame[  -- for debugging me.        LOOPHOLE[awaitDebuggerRequest, PrincOps.Port].dest.frame];      DO   --until returned from debugger with exitable reason--        -- Save fault handlers:        savedFrameFaultFielder: PSB.Condition = PSB.PDA.fault[PSB.qFrameFault].condition;        savedPageFaultFielder: PSB.Condition = PSB.PDA.fault[PSB.qPageFault].condition;        savedWriteFaultFielder: PSB.Condition = PSB.PDA.fault[PSB.qWriteProtectFault].condition;        -- Save processor state not captured in PDA:	savedIntervalTimer: LONG CARDINAL = ReadIntervalTimer[];	savedPTC: PSB.Ticks = ProcessOperations.ReadPTC[];        savedXferTrapStatus: XferTrap.Status = XferTrap.ReadXTS[];        savedXferTrapHandler: PrincOps.ControlLink ¬	  LOOPHOLE[SDDefs.SD[SDDefs.sXferTrap]];        savedWDC: CARDINAL = ProcessOperations.ReadWDC[];        pESV.swapData.process ¬          ProcessOperations.IndexFromHandle[ProcessOperations.ReadPSB[]];        XferTrap.WriteXTS[off];        SDDefs.SD[SDDefs.sXferTrap] ¬  -- in case we are restarted in trap mode	  Frame.MyLocalFrame[];        -- Clear fault handlers to aid detecting Germ faults:        PSB.PDA.fault[PSB.qFrameFault].condition ¬ nullCondition;        PSB.PDA.fault[PSB.qPageFault].condition ¬ nullCondition;        PSB.PDA.fault[PSB.qWriteProtectFault].condition ¬ nullCondition;        -- Manually save the state of the current process so that Copilot        --   will be able to examine it just as if we were waiting:        PSB.PDA[ProcessOperations.ReadPSB[]].context.frame ¬ Frame.MyLocalFrame[];        DeviceCleanup.Perform[turnOff];  -- turn all devices off        -- Go to debugger or equivalent action:	SELECT TRUE FROM          System.switches[PilotSwitches.hang] = down =>            BEGIN            AddToStack: PROC [BOOLEAN] = MACHINE CODE BEGIN END;            GetTOS: PROC RETURNS [BOOLEAN] = MACHINE CODE              BEGIN Mopcodes.zDUP; END;            RemoveFromStack: PROC RETURNS [BOOLEAN] = MACHINE CODE BEGIN END;            AddToStack[TRUE];            ProcessorFace.SpecialSetMP[PilotMP.cHang];            WHILE GetTOS[] DO ENDLOOP;            [] ¬ RemoveFromStack[];            END;          ~DebuggerSwap.canSwap            OR System.switches[PilotSwitches.remoteDebug] = down =>	      BEGIN	      teledebugRequest: Boot.Location ¬ [	        deviceType: System.systemBootDevice.device,		deviceOrdinal: System.systemBootDevice.index,		vp: any[a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0]];              -- GermOps says the arg is meaningless, but it isn't now.	      GermOps.Teledebug[@teledebugRequest];	      END;          ENDCASE =>            BEGIN            -- OutLoad self, then inload debugger:            IF GermOps.OutLoad[              @DebuggerSwap.parameters.locDebuggee, restore].session =              continuingAfterOutLoad THEN              BEGIN OPEN p: DebuggerSwap.parameters;              -- Disconnect all devices (e.g. release funny memory):              DeviceCleanup.Perform[disconnect];              -- The next line should be in GermOps.InLoad but blows up the compiler              IF p.pMicrocodeCopy ~= NIL THEN DeviceCleanup.Perform[kill];              GermOps.InLoad[                p.pMicrocodeCopy, p.pGermCopy, p.nGerm, @p.locDebugger,                --pSwitches:-- NIL]              -- never returns here; Returns from OutLoad above with session=newSession.              END            ELSE --session=newSession-- NULL;  -- continue after return from debugger.            END;        -- Restore fault handlers:        PSB.PDA.fault[PSB.qFrameFault].condition ¬ savedFrameFaultFielder;        PSB.PDA.fault[PSB.qPageFault].condition ¬ savedPageFaultFielder;        PSB.PDA.fault[PSB.qWriteProtectFault].condition ¬ savedWriteFaultFielder;        -- Restore process state not captured in PDA:        ProcessOperations.WritePSB[	  ProcessOperations.HandleFromIndex[pESV.swapData.process]];        -- Restore processor state not captured in PDA:	WriteIntervalTimer[savedIntervalTimer];        ProcessOperations.WriteWDC[savedWDC];        ProcessOperations.WritePTC[savedPTC];        DeviceCleanup.Perform[turnOn];  -- turn devices back on        SDDefs.SD[SDDefs.sXferTrap] ¬ LOOPHOLE[savedXferTrapHandler];  -- 1 of 2        XferTrap.WriteXTS[savedXferTrapStatus];  -- 2 of 2        ProcessorFace.SpecialSetMP[ProcessorFace.mp];  -- announce our return        pESV.spareA ¬ LOOPHOLE[TRUE]; -- this is the place to set this for the debugger.        -- Handle some swap reasons right here..        WITH pESV.swapData SELECT FROM          kill => ProcessorFace.BootButton[];  -- good bye.          showScreen =>            BEGIN            pulsesStart: LONG CARDINAL = ProcessorFace.GetClockPulses[];            stopPrev: KeyboardFace.DownUp ¬ keyboard[Stop];            UNTIL ProcessorFace.GetClockPulses[] - pulsesStart >                pulsesPerTwentySeconds --or other conditions--  DO              IF stopPrev = down THEN  -- wait for stop key to go up	        stopPrev ¬ keyboard[Stop]              ELSE	        BEGIN  -- stop key was up..                IF keyboard[Stop] = down THEN {  --		  -- stop key was up and has gone down. Spin till up again.                  WHILE keyboard[Stop] = down DO --snore-- ENDLOOP;                  EXIT}                ELSE NULL;  -- and still is up		END;              ENDLOOP;            END;  -- fall through and swap back to debugger          ENDCASE => EXIT;  -- back to client who wanted to go to debugger.	--pESV.swapData.lFrame ¬ NIL;	pESV.swapData.body ¬ return[sv: NIL];  -- back to debugger.        ENDLOOP;  --until returned from debugger with exitable swapreason--      ENDLOOP;  --FOREVER--    END;  --InitializeAwaitDebuggerRequest--  FlushTrashFromStack: PROC RETURNS [trashWasOnStack: BOOLEAN];  -- an indirect control link to the PORT.  InitializeFlushTrashFromStack: PROC RETURNS [trashWasOnStack: BOOLEAN] =    BEGIN    -- This coroutine exists to save WorryCall and Bug (and CallDebuggerWithSwapData)    -- from all having to have a state vector in their fixed local frame.    -- Note: Initially, InitializeFlushTrashFromStack is set    -- to return to the caller of InitializeWorryCallDebugger.        AwaitFlushTrashFromStackRequest: --RESPONDING-- PORT [      trashWasOnStack: BOOLEAN] RETURNS [];      -- args/results match FlushTrashFromStack (but swapped).    d: RECORD [      padAwayFromLocalZero: ARRAY[0..3) OF WORD, state: dst PrincOps.StateVector];    FlushTrashFromStack ¬ LOOPHOLE[LONG[@AwaitFlushTrashFromStackRequest]];    -- set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitFlushTrashFromStackRequest, PrincOps.Port].dest ¬ [      frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return result; Await next request.      [] ¬ AwaitFlushTrashFromStackRequest[trashWasOnStack];      d.state ¬ STATE;  -- dump stack.      trashWasOnStack ¬ (d.state.stkptr # 0);      ENDLOOP;    END;      --============== DeviceCleanup implementation: ==============  Item: PUBLIC --DeviceCleanup.-- TYPE = RECORD [    pItemNext: POINTER TO Item,    Procedure: PROC [DeviceCleanup.Reason] RETURNS [POINTER TO Item] ¬ TRASH];  linkage: PUBLIC --DeviceCleanup.-- DeviceCleanup.Linkage;  pItemFirst: POINTER TO Item ¬ NIL;  -- list of waiting cleanup procedures    InitializeDeviceCleanup: PROC =    -- Note: Initially, AwaitPerform is set to return    --    to the caller of InitializeDeviceCleanup.    BEGIN        AwaitPerform: PORT RETURNS [reason: DeviceCleanup.Reason];        reason: DeviceCleanup.Reason;    pItem: POINTER TO Item;    linkage.Perform ¬ LOOPHOLE[LONG[@AwaitPerform]];    -- set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitPerform, PrincOps.Port].dest ¬ [frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      linkage.Await ¬ LOOPHOLE[Install];      reason ¬ AwaitPerform[];      ProcessorFace.SpecialSetMP[PilotMP.cCleanup];      linkage.Await ¬ LOOPHOLE[LONG[Frame.MyLocalFrame[]]];      FOR pItem ¬ pItemFirst, pItem.pItemNext WHILE pItem ~= NIL DO        [] ¬ pItem.Procedure[reason]  -- value should be pItem        ENDLOOP;      ProcessorFace.SpecialSetMP[ProcessorFace.mp];  -- restore mp.      ENDLOOP;  --FOREVER--    END;  Install: ENTRY PROC [pItem: POINTER TO Item] =    BEGIN    fCaller: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];  -- cleanup procedure    pItem­ ¬ [pItemNext: pItemFirst, Procedure: LOOPHOLE[LONG[fCaller]]];    pItemFirst ¬ pItem;    Frame.SetReturnLink[Frame.ReadReturnLink[fCaller]]    END;  --============== Support Procedures ==============  Pointer: PROCEDURE [lp: LONG POINTER] RETURNS [p: POINTER] = INLINE    -- Turn a long pointer into a short pointer. The caller guarantees that    -- the long pointer points into the MDS. If not, the results are undefined.    BEGIN    mdsPage: Environment.PageNumber =      Environment.PageFromLongPointer[LONG[LOOPHOLE[1, POINTER]]];    RETURN[Inline.LowHalf[lp-Environment.LongPointerFromPage[mdsPage]]];    END;  END.LOG   (For earlier log entries, see Pilot 10.0 archive version.)22-Sep-81 17:46:03   WDK     / BAM       Stop using SD for CallDebugger, Interrupt, WorryCallDebugger. Changed Interrupt watcher priority to priorityUserTerminal (same value as before).  Remove unnecessary Disable/EnableInterrupts inside worry call.  Implemented Bug.  Misc cleanups.  Fixed InterpretCall (to use its local frame) and removed why from showScreen.16-Nov-81 14:04:02   JXP       fold in changes made for bootstrap by WDK     and replace character    literals used as System.switch indices by constants defined in PilotSwitches.    Change Interrupt watcher to activate on lock, rightshift, leftshift, stop    key combination. 2-Dec-81 12:07:28   WDK       InterpretCall must DisableInterrupts before going. Deleted obsolete SpecialResidentEVHandle. ticksPerWakeup changed from 1 to 6. 7-Dec-81 13:01:25   WDK       Implement SetDebuggerFielder.  Merged Break and ProcessBreakpoint.  Use KeyStations instead of Keys. Save and clear fault handlers across world swap to aid detecting Germ faults.  Share state vectors between fixed-frame guys.  Move initialization code out of coroutines. 9-Dec-81 15:41:57   WDK    	Use ProcessUncaught.10-Dec-81 17:19:54   WDK    	Make it compile.11-Jan-82 15:58:53   WDK       Must do DeviceCleanup[disconnect] on system inloads.27-Jan-82 12:40:54   WDK       InterpretCall must not use TRANSFER WITH state per new PrincOps.29-Mar-82 11:38:03   AWL      	BreakPoint must do its ¬ STATE first.30-Sep-82 10:23:53   WDK        Added EnableInterruptsOnce[]. Export to StoragePrograms. Work around AR 12518. Document operation of StartUnwindingProcess (new name). Deleted CAbort and Quit signals. 1-Dec-82 15:21:53   WDK        ConditionSatisfied was inline defined after call site, generating poor code.22-Dec-82 14:02:30   AWL      	Initialize sessionState.faultQueues to NIL. 8-Feb-83 10:19:43   WDK     	Implement VisitDebugger. 9-Mar-83  9:32:41   WDK     	Handle truncation warnings.25-May-83 15:46:02   WDK     	Shouldn't use PilotMP.cCantSwap.22-Jun-83 15:53:52   JXG        change = to ¬ when init-ing  savedXferTrapHandler. 4-Jul-83 18:58:27   WDK        Gross revisions per new CPSwapDefs. Make robust against multiple proceses during interpret call. Remove xferTrap workaround. Save interval timer over world swaps.19-Jul-83 11:30:45   JXP   	Twiddles to make compile. 4-Aug-83 16:28:38   WDK        Make compatible with new CPSwapDefs and RuntimeInternal.18-Aug-83 10:17:56   WDK        Make compatible with new RuntimeInternal (Bug, ProcessUncaught).21-Aug-83 13:25:01   WDK        Check in GetOperand was wrong. Make compatible with new RuntimeInternal   (GetOperand, WorryCallDebuggerInternal).19-Sep-83 13:54:23   AWL         InitializeAwaitDebuggerRequest: savedXferTrapHandler must be ¬ not =. 7-Oct-83 10:01:59   WDK        Don't pass bound variant to proc expecting full size one. 5-Jan-84 17:35:45   CXH      Change state vectors in breakpoint and return swap reasons to be LONG POINTER TO  StateVector, added new break conditions for local and stack indirect 5-Feb-85 17:36:17   CJS       Rework use of KeyboardFace.keyboard to reflect new structure of all keyboard interfaces.19-Mar-85  9:31:42   CJS       Initialize keyboard in InitializeInterrupt, the right place. 5-Jun-86 16:57:35   CJS   ESV.spareA ¬ TRUE on return from world swap. spareA is really clientSideMapLogging: BOOLEAN. Debugger assumes FALSE (and sets this to FALSE on first visit) until it sees this on second visit to debugger. 1-Jul-86 16:19:51	MEW   Updated to newest princops. 5-Aug-86 17:30:08	ET   Move PORTs out of global frames into local frames. Make POINTERs to global variables LONG POINTERs to global variables.16-Feb-87 20:59:12      RSV   Changed InitializeAwaitDebuggerRequest line about "back to debugger" from TRASH to NIL plus commented out pESV.swapData.lFrame ¬ NIL in InitializeAwaitDebuggerRequest per AHL's request.17-Nov-87 18:31:41      CAJ   Send real arg to Teledebug.
-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved. -- LoaderCoreImplB.mesa      15-Oct-87 17:46:44 ETDIRECTORY  BcdDefs USING [    Base, EXPIndex, FTIndex, GFIndex, IMPIndex, Link, LinkFrag, MTIndex,    MTRecord, NameRecord, nullLink, unboundLink, VersionStamp],  BcdDefsExtras USING [OldMesaModule],  BcdOps USING [    BcdBase, ENHandle, EXPHandle, IMPHandle, MTHandle, NameString,    ProcessExports, ProcessImports],  BcdOpsExtras USING [    ENBaseFromBcd, FTBaseFromBcd, GfiFromMti, LFBaseFromBcd, MTBaseFromBcd,    MthFromGfi, MthFromMti, MtiFromGfi, NameStringFromBcd],  Environment USING [wordsPerPage],  Inline USING [LongCOPY, LongCOPYReverse, LowHalf],  LoadedMem USING [    Access, GlobalFrameFromGFTHandle, ReadBlock, ReadCodebase, ReadGlobalWord,     ReadCodeLinks, TargetLongAddress, WriteBlock, WriteCodeLinks],  LoaderCore USING [WrongVersion],  LoaderCoreOps,  LoadState USING [    BcdInfoIndex, GFFromBcdInfo, LPBcdInfoTable, MarkModuleResolved, ModuleInfoIndex,    ModuleInfoSequenceHandle],  LoadStateFormat USING [ModuleInfo],  PrincOps USING [GlobalCodebase, PrefixHandle],  PrincOpsExtras2 USING [    ControlLink, ControlLinkTag, ImportLink, LongGlobalFrameHandle,     GlobalOverhead, GFTHandle, nullLink, nullProcImportLink, nullSignalImportLink,     nullVariableImportLink, ShortGlobalFrameHandle, unboundLink],  Table USING [Base];LoaderCoreImplB: PROGRAM  IMPORTS     BcdOps, BcdOpsExtras, Inline, LoaderCore, LoadedMem, LoaderCoreOps,     LoadState  EXPORTS LoaderCoreOps =  BEGIN OPEN LoaderCoreOps;  -- Parameters:  maxCharsInErrorNameString: CARDINAL = 40;  sameNameDifferentVersion: CARDINAL = CARDINAL.LAST - 1;  -- PUBLIC Items:  -- Copied types and constants:  BcdInfoIndex: TYPE = LoadState.BcdInfoIndex;  LPBcdInfoTable: TYPE = LoadState.LPBcdInfoTable;  ModuleInfoIndex: TYPE = LoadState.ModuleInfoIndex;  --============= Import/Export and associated utilities: =============    SetLinks: PUBLIC PROCEDURE [    bcd: BcdOps.BcdBase, bii: BcdInfoIndex, exports: ERSequenceHandle] =    -- Other arguments: loadInfo.module.    -- Initializes all links of bcd to unbound, and resolves all of them    -- which are satisfied by the bcd itself.    BEGIN    lfBase: Table.Base = BcdOpsExtras.LFBaseFromBcd[bcd];    module: LoaderCoreOps.ModuleSequenceHandle = loadInfo.module;    bindings: BindingSequenceHandle ¬ MakeBinding[bcd, exports].bindings;        FOR m: LoaderCoreOps.ModuleRange IN [0..module.length) DO      ENABLE UNWIND => {scratch.FREE[@bindings]};            moduleData: LONG POINTER TO LoaderCoreOps.ModuleData = @module[m];      mth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, MtiFromOrdinal[m]];      linkFrag: LONG POINTER TO BcdDefs.LinkFrag = @lfBase[mth.links];      nLinks: LoaderCoreOps.ImportLinkRange = linkFrag.length;      linksSize: CARDINAL = nLinks * PrincOpsExtras2.ImportLink.SIZE;      pLinks: LoadedMem.TargetLongAddress =        (SELECT moduleData.actualLinkLoc FROM           codeLinks => Codebase[moduleData.info.gfi],           frameLinks =>             LOOPHOLE[	       LoadedMem.GlobalFrameFromGFTHandle[moduleData.info.gfi],	       LONG POINTER] - PrincOpsExtras2.GlobalOverhead.SIZE,           ENDCASE => ERROR) - linksSize;      links: LoaderCoreOps.ImportLinkSequenceHandle ¬ scratch.NEW[        LoaderCoreOps .ImportLinkSequence[nLinks]];      allLinksResolved: BOOLEAN ¬ TRUE;  -- assume      BEGIN      ENABLE UNWIND => scratch.FREE[@links];      -- NOTE: For Mesa 11.0, the compiler only generates procedure Links for      -- imports records. Thus we can not actually initialize unbound links      -- to their appropriate null value.      FOR k: LoaderCoreOps.ImportLinkRange IN [0..nLinks) DO        links[k] ¬          WITH linkFrag[k] SELECT FROM            procedure => PrincOpsExtras2.nullProcImportLink,            signal => PrincOpsExtras2.nullSignalImportLink,            variable => PrincOpsExtras2.nullVariableImportLink,            type => ERROR,  -- should not occur as a module link.            ENDCASE => ERROR;        ENDLOOP;      FOR k: LoaderCoreOps.ImportLinkRange IN [0..nLinks) DO        link: BcdDefs.Link = linkFrag[k];        gfi: BcdDefs.GFIndex = GfiFromLink[link];	resolvedLink: PrincOpsExtras2.ImportLink;        IF gfi >= bcd.firstdummy THEN 	  BEGIN  --link resolved from imports	  erIndex: ERIndex = bindings[gfi-bcd.firstdummy].erIndex;	  IF erIndex # CARDINAL.LAST AND erIndex # sameNameDifferentVersion THEN {	    er: ERHandle = @exports[erIndex];	    interfaceItem: CARDINAL =	      (WITH l: link SELECT FROM procedure => l.ep, ENDCASE => ERROR);	    resolvedLink ¬ er.links[interfaceItem];	    IF resolvedLink = PrincOpsExtras2.nullProcImportLink THEN	      allLinksResolved ¬ FALSE}	  ELSE {	    allLinksResolved ¬ FALSE;	    resolvedLink ¬ PrincOpsExtras2.nullProcImportLink};	  END        ELSE          BEGIN  --link resolved within bcd          IF link = BcdDefs.unboundLink THEN  -- Binder says link is unbindable.            resolvedLink ¬  --              PrincOpsExtras2.nullProcImportLink  -- ("proc" is arbitrary)          ELSE            WITH selfLink: link SELECT FROM              procedure =>                BEGIN                linkMti: BcdDefs.MTIndex = BcdOpsExtras.MtiFromGfi[selfLink.gfi];                linkMth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, linkMti];                entryVector: BcdOps.ENHandle = @BcdOpsExtras.ENBaseFromBcd[bcd][                  linkMth.entries];                IF selfLink.ep >= entryVector.nEntries THEN                  ERROR Bug[entryPointIndexTooBig];		IF linkMth.spare = BcdDefsExtras.OldMesaModule THEN {		  gfh: PrincOpsExtras2.ShortGlobalFrameHandle =		    Inline.LowHalf[LoadedMem.GlobalFrameFromGFTHandle[		      module[OrdinalFromMti[linkMti]].info.gfi]];		  resolvedLink ¬ 		    [oldProc[[shortProc[		      gf: gfh + ORD[PrincOpsExtras2.ControlLinkTag[shortProc]],		      pc: entryVector.initialPC[selfLink.ep]]]]] }		ELSE		  resolvedLink ¬ [newProc[[longProc[		    gfi: module[OrdinalFromMti[linkMti]].info.gfi +		      ORD[PrincOpsExtras2.ControlLinkTag[longProc]],		    pc: entryVector.initialPC[selfLink.ep]]]]];                END;              signal => {                linkMti: BcdDefs.MTIndex = BcdOpsExtras.MtiFromGfi[selfLink.gfi];		linkMth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, linkMti];		IF linkMth.spare = BcdDefsExtras.OldMesaModule THEN {		  gfh: PrincOpsExtras2.ShortGlobalFrameHandle =		    Inline.LowHalf[LoadedMem.GlobalFrameFromGFTHandle[		      module[OrdinalFromMti[linkMti]].info.gfi]];		  resolvedLink ¬ [oldSignal[[gf: gfh, index: selfLink.index]]] }		ELSE		  resolvedLink ¬ [newSignal[[		    gf: module[OrdinalFromMti[linkMti]].info.gfi		      + ORD[PrincOpsExtras2.ControlLinkTag[longProc]],		    index: selfLink.index]]]};              variable => {                linkMti: BcdDefs.MTIndex = BcdOpsExtras.MtiFromGfi[selfLink.gfi];                resolvedLink ¬ [variable[		    pointer: LoadedMem.GlobalFrameFromGFTHandle[module[		      OrdinalFromMti[linkMti]].info.gfi] + selfLink.offset]]};              type => ERROR Bug[typeLink];              ENDCASE => ERROR Bug[unknownCase];          END;        links[k] ¬ resolvedLink;        ENDLOOP;      IF allLinksResolved THEN module[m].info.resolved ¬ TRUE;      IF linksSize # 0 THEN        IF moduleData.actualLinkLoc = frameLinks THEN           LoadedMem.WriteBlock[            targetAddress: pLinks, localAddress: @links[0], size: linksSize,            access: readWrite]  -- (bcd being loaded is readWrite initially.)	ELSE LoadedMem.WriteCodeLinks[            targetAddress: pLinks, mth: mth, localAddress: DESCRIPTOR[links],            access: readWrite];      END;  --ENABLE FREE[@links]--      scratch.FREE[@links];      ENDLOOP;    scratch.FREE[@bindings];    END;  --SetLinks--  BindUnboundIfPossible: PUBLIC PROCEDURE [    importer: BcdOps.BcdBase, importerBii: BcdInfoIndex,    exports: ERSequenceHandle,    importerModuleInfo: LoadState.ModuleInfoSequenceHandle,    action: LoaderCoreOps.BindingAction]    RETURNS [importsAllResolved: BOOLEAN ¬ TRUE] =    -- Other arguments: loadInfo.module.    -- Binds previously loaded bcd to exports of newly loaded bcd.    BEGIN    lfBase: Table.Base = BcdOpsExtras.LFBaseFromBcd[importer];    module: LoaderCoreOps.ModuleSequenceHandle = loadInfo.module;  -- (local copy of pointer)    bindings: BindingSequenceHandle;    anyBound: BOOLEAN;    Interesting: PROC [      importLink: PrincOpsExtras2.ImportLink, dummyLink: BcdDefs.Link]      RETURNS [BOOLEAN] =      BEGIN      b: BOOLEAN = Bound[importLink];      IF action = bind THEN RETURN[NOT b]      ELSE        BEGIN        gfi: CARDINAL;        WITH dd: dummyLink SELECT FROM          procedure => gfi ¬ dd.gfi;          signal => gfi ¬ dd.gfi;          variable => gfi ¬ dd.gfi;          ENDCASE => gfi ¬ 0;        RETURN[b AND gfi >= importer.firstdummy];        END;      END;  --Interesting--          [bindings: bindings, anyBound: anyBound] ¬ MakeBinding[importer, exports];    IF ~anyBound THEN RETURN[FALSE];    FOR m: LoaderCoreOps.ModuleRange IN [0..importerModuleInfo.length) DO      links: LoaderCoreOps.ImportLinkSequenceHandle ¬ NIL;      info: LoadStateFormat.ModuleInfo = importerModuleInfo[m];      IF action = bind AND info.resolved THEN LOOP;      BEGIN      ENABLE UNWIND => scratch.FREE[@links];      mth: BcdOps.MTHandle = BcdOpsExtras.MthFromGfi[importer, info.cgfi];      nLinks: CARDINAL = lfBase[mth.links].length;      linksSize: CARDINAL = nLinks * PrincOpsExtras2.ImportLink.SIZE;      pLinks: LoadedMem.TargetLongAddress;       linksDirty: BOOLEAN;      linkFrag: LONG POINTER TO BcdDefs.LinkFrag = @lfBase[mth.links];      allModuleLinksResolved: BOOLEAN;      linkAccess: LoadedMem.Access ¬ readWrite;      links ¬ scratch.NEW[LoaderCoreOps .ImportLinkSequence[nLinks]];      IF LoadedMem.ReadGlobalWord[LoadedMem.GlobalFrameFromGFTHandle[        info.gfi]].codelinks THEN {	  IF action = unbind OR importer # bcd THEN linkAccess ¬ readOnly;	  pLinks ¬ Codebase[info.gfi] - linksSize;	  LoadedMem.ReadCodeLinks[	    targetAddress: pLinks, mth: mth, localAddress: DESCRIPTOR[links]]}      ELSE {        pLinks ¬ LoadedMem.GlobalFrameFromGFTHandle[info.gfi] - 	  PrincOpsExtras2.GlobalOverhead.SIZE - linksSize;	LoadedMem.ReadBlock[	  targetAddress: pLinks, localAddress: @links[0], size: linksSize]};      linksDirty ¬ FALSE;      allModuleLinksResolved ¬ TRUE;  -- assume.      FOR k: LoaderCoreOps.ImportLinkRange IN [0..nLinks) DO        link: BcdDefs.Link = linkFrag[k];	IF Interesting[links[k], link]  -- not bound if binding and vice versa          AND linkFrag[k] # BcdDefs.unboundLink THEN  -- and legal to resolve          BEGIN  -- not bound already and legal to bind          linkGfi: BcdDefs.GFIndex = GfiFromLink[link];	  erIndex: ERIndex = bindings[linkGfi-importer.firstdummy].erIndex;	  IF erIndex # CARDINAL.LAST AND erIndex # sameNameDifferentVersion THEN {	    er: ERHandle = @exports[erIndex];	    interfaceItem: CARDINAL =	      (WITH l: link SELECT FROM procedure => l.ep, ENDCASE => ERROR);	    resolvedLink: PrincOpsExtras2.ImportLink ¬ er.links[interfaceItem];	    IF resolvedLink = PrincOpsExtras2.nullProcImportLink THEN 	      allModuleLinksResolved ¬ FALSE	    ELSE {	      IF action = bind THEN {links[k] ¬ resolvedLink; linksDirty ¬ TRUE}	      ELSE	        IF links[k] = resolvedLink THEN {                  links[k] ¬ PrincOpsExtras2.nullProcImportLink;                  linksDirty ¬ TRUE}}}	  ELSE allModuleLinksResolved ¬ FALSE;          END;        ENDLOOP;  --[0..nLinks)--      IF allModuleLinksResolved AND action = bind THEN {        importerModuleInfo[m].resolved ¬ TRUE;        LoadState.MarkModuleResolved[importerModuleInfo[m].gfi, TRUE]}      ELSE importsAllResolved ¬ FALSE;      IF linksDirty THEN        BEGIN        IF ~LoadedMem.ReadGlobalWord[	    LoadedMem.GlobalFrameFromGFTHandle[info.gfi]].codelinks         THEN LoadedMem.WriteBlock[            targetAddress: pLinks, localAddress: @links[0], size: linksSize,            access: linkAccess]  	ELSE LoadedMem.WriteCodeLinks[            targetAddress: pLinks, mth: mth, localAddress: DESCRIPTOR[links],            access: linkAccess];        IF action # bind THEN          LoadState.MarkModuleResolved[importerModuleInfo[m].gfi, FALSE];        END;      END;  --ENABLE FREE[@links]--      scratch.FREE[@links];      ENDLOOP;    scratch.FREE[@bindings];    END;  --BindUnboundIfPossible--  -- Import/Export utilities:  Bound: PROC [importLink: PrincOpsExtras2.ImportLink] RETURNS [BOOLEAN] =    BEGIN    RETURN[      -- THE FOLLOWING TWO LINES ARE TEMP WHILE MakeBoot ACTS THIS WAY.      importLink # LOOPHOLE[PrincOpsExtras2.unboundLink]        AND  -- TEMP          importLink # LOOPHOLE[PrincOpsExtras2.nullLink]        AND  -- TEMP          importLink # PrincOpsExtras2.nullProcImportLink        AND importLink # PrincOpsExtras2.nullSignalImportLink        AND importLink # PrincOpsExtras2.nullVariableImportLink];    END;  Resolution: TYPE = {resolved, unresolved};  --============= General Utilities: =============  Codebase: PROC [gfi: PrincOpsExtras2.GFTHandle]    RETURNS [codebase: PrincOps.PrefixHandle] =    -- codebase will have its "out" bit off.    BEGIN    globalCodebase: PrincOps.GlobalCodebase ¬ LoadedMem.ReadCodebase[      LoadedMem.GlobalFrameFromGFTHandle[gfi]];    globalCodebase.out ¬ FALSE;    RETURN[globalCodebase.codebase];    END;  GfiFromLink: PROC [link: BcdDefs.Link] RETURNS [BcdDefs.GFIndex] = INLINE    BEGIN    WITH lk: link SELECT FROM      procedure => RETURN[lk.gfi];      signal => RETURN[lk.gfi];      variable => RETURN[lk.gfi];      type => ERROR Bug[typeLink];      ENDCASE => ERROR Bug[unknownCase];    END;  MtiFromOrdinal: PROC [ordinal: LoaderCoreOps.ModuleRange]    RETURNS [BcdDefs.MTIndex] = INLINE {    -- Returns BcdDefs.MTIndex given zero-origin ordinal of module in bcd's module table.    -- Not "Index" since BcdDefs uses that term for relative pointers!    RETURN[BcdDefs.MTIndex.FIRST + ordinal * BcdDefs.MTRecord.SIZE]};     OrdinalFromMti: PROC [mti: BcdDefs.MTIndex]    RETURNS [LoaderCoreOps.ModuleRange] = INLINE {    -- Returns zero-origin index of module in bcd's module table.    -- NOT a BcdDefs "Index" which is a relative pointer!    RETURN[(mti - BcdDefs.MTIndex.FIRST) / BcdDefs.MTRecord.SIZE]};  --  JGS  CompareNames: PROC [s1, s2: LONG STRING] RETURNS [{less, equal, greater}] =    BEGIN    i: CARDINAL;    l1: CARDINAL = s1.length;    l2: CARDINAL = s2.length;    c1, c2: CHARACTER;    FOR i IN [0..MIN[l1, l2]) DO      c1 ¬ s1[i];      c2 ¬ s2[i];      SELECT c1 FROM < c2 => RETURN[less]; > c2 => RETURN[greater]; ENDCASE;      ENDLOOP;    RETURN[SELECT l1 FROM < l2 => less, > l2 => greater, ENDCASE => equal]    END;  CompareVersions: PROC [    v1, v2: BcdDefs.VersionStamp] RETURNS [{less, equal, greater}] =    BEGIN    X: TYPE = RECORD [a: LONG CARDINAL, b: CARDINAL];    SELECT LOOPHOLE[v1, X].a FROM      < LOOPHOLE[v2, X].a => RETURN[less];      > LOOPHOLE[v2, X].a => RETURN[greater];      ENDCASE;    RETURN[      SELECT LOOPHOLE[v1, X].b FROM        < LOOPHOLE[v2, X].b => less,        > LOOPHOLE[v2, X].b => greater,        ENDCASE => equal]    END;  MakeOneExportRecord: PUBLIC PROC [    bcd: BcdOps.BcdBase, bii: BcdInfoIndex, exph: BcdOps.EXPHandle,    frames: GFSequenceHandle]    RETURNS [er: ExportRecord] = {    ns: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];    nameLength: CARDINAL = ns.size[exph.name];    name: LONG STRING = permanentZone.NEW[StringBody[nameLength]];    er ¬ [      name: name, multipleExporters: FALSE,      version: BcdOpsExtras.FTBaseFromBcd[bcd][exph.file].version,      port: exph.port, links: NIL];    name.length ¬ nameLength;    FOR k: CARDINAL IN [0..nameLength) DO      name[k] ¬ ns.string.text[exph.name + k]      ENDLOOP;    er.links ¬ MakeExportLinks[bcd, exph, frames];    RETURN};    MakeExportLinks: PUBLIC PROC [    bcd: BcdOps.BcdBase, exph: BcdOps.EXPHandle, frames: GFSequenceHandle]    RETURNS [links: ImportLinkSequenceHandle] = {    links ¬ permanentZone.NEW[ImportLinkSequence[exph.size]];    FOR i: NATURAL IN [0..exph.size) DO      exportedLink: BcdDefs.Link;      gfi: PrincOpsExtras2.GFTHandle;      exportedLink ¬ exph.links[i];      IF exportedLink = BcdDefs.nullLink THEN        links[i] ¬ PrincOpsExtras2.nullProcImportLink      ELSE	WITH expLink: exph.links[i] SELECT FROM	  procedure =>	    BEGIN	    expMth: BcdOps.MTHandle = BcdOpsExtras.MthFromGfi[	      bcd, expLink.gfi];	    entryVector: BcdOps.ENHandle = @BcdOpsExtras.ENBaseFromBcd[bcd][	      expMth.entries];	    IF expLink.ep >= entryVector.nEntries THEN	      ERROR Bug[entryPointIndexTooBig];	    gfi ¬ frames[expLink.gfi];	    IF expMth.spare = BcdDefsExtras.OldMesaModule THEN {	      gfh: PrincOpsExtras2.ShortGlobalFrameHandle =		Inline.LowHalf[LoadedMem.GlobalFrameFromGFTHandle[gfi]];	      links[i] ¬  [oldProc[[shortProc[		    gfh + ORD[PrincOpsExtras2.ControlLinkTag[shortProc]],		    entryVector.initialPC[expLink.ep]]]]] }	    ELSE	      links[i] ¬ [newProc[[longProc[		  gfi + ORD[PrincOpsExtras2.ControlLinkTag[longProc]], 		entryVector.initialPC[expLink.ep]]]]];	    END;	  signal => {	    expMth: BcdOps.MTHandle = BcdOpsExtras.MthFromGfi[	      bcd, expLink.gfi];	    gfi ¬ frames[expLink.gfi];	    links[i] ¬ IF expMth.spare = BcdDefsExtras.OldMesaModule THEN		[oldSignal[[		  gf: Inline.LowHalf[LoadedMem.GlobalFrameFromGFTHandle[gfi]],		  index: expLink.index]]]	      ELSE		[newSignal[[gf: gfi+ ORD[PrincOpsExtras2.ControlLinkTag[longProc]], 		index: expLink.index]]]};	  variable => {	    gfi ¬ frames[expLink.gfi];	    links[i] ¬ [variable[	      LoadedMem.GlobalFrameFromGFTHandle[gfi] + expLink.offset]]};	  type => links[i] ¬ [variable[NIL]];	  ENDCASE => ERROR Bug[unknownCase];      ENDLOOP;    };      BuildExportRecords: PUBLIC PROC [    bcd: BcdOps.BcdBase, bii: BcdInfoIndex, frames: GFSequenceHandle]    RETURNS [exports: ERSequenceHandle] = {    index: CARDINAL ¬ 0;    AddOneExport: PROCEDURE [exph: BcdOps.EXPHandle, expi: BcdDefs.EXPIndex]      RETURNS [quitNow: BOOLEAN] = {      exports[index] ¬ MakeOneExportRecord[bcd, bii, exph, frames];      index ¬ index + 1;      RETURN[FALSE]};    AddOneModuleExport: PROCEDURE [] = {      mti: BcdDefs.MTIndex = BcdDefs.MTIndex.FIRST;  -- the module itself      mth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, mti];      ns: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];      nameLength: CARDINAL = ns.size[mth.name];      name: LONG STRING = permanentZone.NEW[StringBody[nameLength]];      gf: PrincOpsExtras2.LongGlobalFrameHandle =         LoadedMem.GlobalFrameFromGFTHandle[LoadState.GFFromBcdInfo[	  cgfi: BcdOpsExtras.GfiFromMti[mti], bcdIndex: bii]];      links: ImportLinkSequenceHandle ¬         permanentZone.NEW[ImportLinkSequence[1]];      links[0] ¬ [variable[gf]];      exports[index] ¬ [	name: name, multipleExporters: FALSE,	version: --BcdOpsExtras.FTBaseFromBcd[bcd][mth.file].version-- bcd.version,	port: module, links: links];      name.length ¬ nameLength;      FOR k: CARDINAL IN [0..nameLength) DO	name[k] ¬ ns.string.text[mth.name + k]	ENDLOOP;      index ¬ index + 1;      RETURN};    ExportRecordLess: PROC [er1, er2: ERHandle] RETURNS [BOOLEAN] = INLINE {      SELECT CompareNames[er1.name, er2.name] FROM        less => RETURN[TRUE];	greater => RETURN[FALSE];	ENDCASE => 	  IF er1.port # er2.port THEN 	    SELECT TRUE FROM	      er1.port < er2.port => RETURN[TRUE];	      er1.port > er2.port => RETURN[FALSE];	      ENDCASE =>		SELECT CompareVersions[er1.version, er2.version] FROM		  less => RETURN[TRUE];		  ENDCASE => RETURN[FALSE]	  ELSE RETURN[FALSE]};    SiftUpExports: PROCEDURE [low, high: CARDINAL] =      BEGIN      k, son, kTimes2: CARDINAL;      er: ExportRecord;      k ¬ low;      DO	kTimes2 ¬ k*2;	IF kTimes2 > high THEN EXIT;	IF kTimes2 + 1 > high	  OR ExportRecordLess[@exports[kTimes2+1-1], @exports[kTimes2-1]] THEN	  son ¬ kTimes2	ELSE son ¬ kTimes2 + 1;	IF ExportRecordLess[@exports[son-1], @exports[k-1]] THEN EXIT;	er ¬ exports[son - 1];	exports[son - 1] ¬ exports[k - 1];	exports[k - 1] ¬ er;	k ¬ son;	ENDLOOP;      END;  --SiftUpExports--    IF bcd.nExports = 0 AND bcd.nConfigs # 0 THEN RETURN[NIL];    IF bcd.nExports = 0 AND bcd.nConfigs = 0 THEN {      -- only compiler module being exported, so one entry needed.      exports ¬ permanentZone.NEW[ERSequence[1] ¬ [length: 1, seq:]];      AddOneModuleExport[];      RETURN};    exports ¬ permanentZone.NEW[      ERSequence[bcd.nExports] ¬ [length: bcd.nExports, seq:]];    [] ¬ BcdOps.ProcessExports[bcd, AddOneExport];    FOR n: ERIndex DECREASING IN [1..exports.length / 2] DO      SiftUpExports[n, exports.length] ENDLOOP;    FOR n: ERIndex DECREASING IN [1..exports.length) DO      er: ExportRecord = exports[1 - 1];      exports[1 - 1] ¬ exports[n + 1 - 1];      exports[n + 1 - 1] ¬ er;      SiftUpExports[1, n];      ENDLOOP};     MergeExportRecords: PUBLIC PROC [    old, new: ERSequenceHandle] RETURNS [ERSequenceHandle] = {    iOld, iNew: NATURAL ¬ 0;        AddExportRecord: PROCEDURE =       BEGIN      erOld: ERHandle;      old ¬ AssureSpace[old, 1];      erOld ¬ @old[iOld];      Inline.LongCOPYReverse[	from: erOld, to: erOld + ExportRecord.SIZE,	nwords: (old.length - iOld)*ExportRecord.SIZE];      CopyExportRecord[from: @new[iNew], to: erOld];      old.length ¬ old.length + 1;      END;          IF new = NIL THEN RETURN[old];    IF old = NIL THEN RETURN[new];    UNTIL iOld = old.length OR iNew = new.length DO      SELECT CompareNames[old[iOld].name, new[iNew].name] FROM	less => {iOld ¬ iOld + 1; LOOP};	greater => {AddExportRecord[]; iNew ¬ iNew + 1; iOld ¬ iOld + 1; LOOP};	equal =>	  BEGIN	  IF old[iOld].port # new[iNew].port THEN {	    AddExportRecord[]; iNew ¬ iNew + 1; iOld ¬ iOld + 1; LOOP};	  SELECT CompareVersions[old[iOld].version, new[iNew].version] FROM	    less => {iOld ¬ iOld + 1; LOOP};	    greater => {AddExportRecord[]; iNew ¬ iNew + 1; iOld ¬ iOld + 1; LOOP};	    equal => {	      erNew: ERHandle = @new[iNew];	      erOld: ERHandle = @old[iOld];	      erOld.multipleExporters ¬ TRUE;	      FOR i: NATURAL IN [0..erOld.links.length) DO	        link: PrincOpsExtras2.ImportLink = erNew.links[i];		SELECT link FROM		  PrincOpsExtras2.nullProcImportLink => {};		  PrincOpsExtras2.nullSignalImportLink => {};		  PrincOpsExtras2.nullVariableImportLink => {};		  ENDCASE => erOld.links[i] ¬ link;		ENDLOOP;	      iNew ¬ iNew + 1;	      iOld ¬ iOld + 1;	     LOOP};	    ENDCASE;	    END;	ENDCASE;      ENDLOOP;    IF iNew # new.length THEN {      erNew: ERHandle ¬ @new[iNew];      erOld: ERHandle;      old ¬ AssureSpace[old, new.length-iNew];      old.length ¬ old.length + new.length-iNew;      erOld ¬ @old[iOld];      THROUGH [iNew..new.length) DO        CopyExportRecord[from: erNew, to: erOld];        erNew ¬ erNew + ExportRecord.SIZE;        erOld ¬ erOld + ExportRecord.SIZE;	ENDLOOP};    RETURN[old]};  RemoveExportRecords: PUBLIC PROC [    old, new: ERSequenceHandle] RETURNS [needRebuilding: ERIndexSequenceHandle] = {    iOld, iNew, iRebuild: NATURAL ¬ 0;    needRebuilding ¬ scratch.NEW[ERIndexSequence[new.length+1]];    UNTIL iOld = old.length OR iNew = new.length DO      SELECT CompareNames[old[iOld].name, new[iNew].name] FROM	less => {iOld ¬ iOld + 1; LOOP};	greater => ERROR Bug[unknownCase];	equal =>	  BEGIN	  IF old[iOld].port # new[iNew].port THEN {iOld ¬ iOld + 1; LOOP};	  SELECT CompareVersions[old[iOld].version, new[iNew].version] FROM	    less => {iOld ¬ iOld + 1; LOOP};	    greater => ERROR Bug[unknownCase];	    equal => {	      erOld: ERHandle ¬ @old[iOld];	      IF erOld.multipleExporters THEN {	        needRebuilding[iRebuild] ¬ iOld;		iRebuild ¬ iRebuild + 1;		needRebuilding.length ¬ needRebuilding.length + 1;		iOld ¬ iOld + 1;		FOR i: CARDINAL DECREASING IN [0..erOld.links.length) DO		  erOld.links[i] ¬ PrincOpsExtras2.nullProcImportLink;		  ENDLOOP}	      ELSE {		permanentZone.FREE[@erOld.name];		permanentZone.FREE[@erOld.links];		old.length ¬ old.length - 1;	        Inline.LongCOPY[		  from: erOld+ExportRecord.SIZE, to: erOld,		  nwords: (old.length - iOld)*ExportRecord.SIZE]};	      iNew ¬ iNew + 1;	      LOOP};	    ENDCASE;	    END;	ENDCASE;      ENDLOOP;    needRebuilding[iRebuild] ¬ CARDINAL.LAST};  RebuildExportRecords: PUBLIC PROC [    bcd: BcdOps.BcdBase, exports: ERSequenceHandle,    needRebuilding: ERIndexSequenceHandle, frames: GFSequenceHandle] = {    CheckOneExport: PROCEDURE [exph: BcdOps.EXPHandle, expi: BcdDefs.EXPIndex]      RETURNS [quitNow: BOOLEAN] = {      exportName: LONG STRING ¬ [100];      i: CARDINAL ¬ 0;      GetName[exportName, bcd, exph.name];      UNTIL needRebuilding[i] = CARDINAL.LAST DO	ftb: BcdDefs.Base = BcdOpsExtras.FTBaseFromBcd[bcd];	erh: ERHandle = @exports[needRebuilding[i]];	IF CompareNames[exportName, erh.name] = equal AND 	  exph.port = erh.port AND	  CompareVersions[ftb[exph.file].version, erh.version] = equal THEN {	  links: ImportLinkSequenceHandle ¬ MakeExportLinks[bcd, exph, frames];	  FOR l: NATURAL IN [0..links.length) DO	    link: PrincOpsExtras2.ImportLink = links[l];	    SELECT link FROM	      PrincOpsExtras2.nullProcImportLink => {};	      PrincOpsExtras2.nullSignalImportLink => {};	      PrincOpsExtras2.nullVariableImportLink => {};	      ENDCASE => erh.links[l] ¬ link;	    ENDLOOP;	  permanentZone.FREE[@links]};	i ¬ i + 1;	ENDLOOP;      RETURN[FALSE]};    -- Should the multipleExporter boolean be set back to FALSE? How?    [] ¬ BcdOps.ProcessExports[bcd, CheckOneExport];    RETURN};    CopyExportRecord: PROC [from, to: ERHandle] = {    CopyString: PROC [old: LONG STRING] RETURNS [new: LONG STRING] = INLINE{      new ¬ permanentZone.NEW[StringBody[old.length]];      FOR i: NATURAL DECREASING IN [0..new.length ¬ old.length) DO        new[i] ¬ old[i]; ENDLOOP};    CopyLinks: PROC [old: ImportLinkSequenceHandle]      RETURNS [new: ImportLinkSequenceHandle] = INLINE {      new ¬ permanentZone.NEW[ImportLinkSequence[old.length]];      FOR i: NATURAL DECREASING IN [0..new.length) DO        new[i] ¬ old[i]; ENDLOOP};    to­ ¬ [      name: CopyString[from.name], version: from.version, port: from.port,      multipleExporters: from.multipleExporters, links: CopyLinks[from.links]];    RETURN};    AssureSpace: PROC [e: ERSequenceHandle, n: NATURAL] RETURNS [    new: ERSequenceHandle] = {    erPerPage: CARDINAL = Environment.wordsPerPage/ExportRecord.SIZE;    newSize: CARDINAL =       ((e.maxLength+n+e.maxLength/5+erPerPage-1)/erPerPage * erPerPage)-1;    IF e.length + n < e.maxLength THEN RETURN[e];    new ¬ permanentZone.NEW[ERSequence[newSize] ¬ [      length: e.length, seq:]];    Inline.LongCOPY[      from: @e[0], to: @new[0], nwords: e.length*ExportRecord.SIZE];    permanentZone.FREE[@e]};    MakeBinding: PUBLIC PROCEDURE [bcd: BcdOps.BcdBase, exports: ERSequenceHandle]    RETURNS [bindings: BindingSequenceHandle, anyBound: BOOLEAN ¬ FALSE] =    BEGIN    GetImports: PROCEDURE [imph: BcdOps.IMPHandle, impi: BcdDefs.IMPIndex]      RETURNS [quitNow: BOOLEAN] = {      bindings[i] ¬ [impi: impi, erIndex: CARDINAL.LAST];      i ¬ i + 1;      RETURN[FALSE]};    i: BindingRange ¬ 0;    ImportLess: PROC [b1, b2: BindingRange] RETURNS [BOOLEAN] = {      itb: BcdDefs.Base = LOOPHOLE[bcd + bcd.impOffset];      imp1: BcdOps.IMPHandle = @itb[bindings[b1].impi];      imp2: BcdOps.IMPHandle = @itb[bindings[b2].impi];      ns: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];      i: CARDINAL;      name1: BcdDefs.NameRecord = imp1.name;      name2: BcdDefs.NameRecord = imp2.name;      l1: CARDINAL = ns.size[name1];      l2: CARDINAL = ns.size[name2];      c1, c2: CHARACTER;      FOR i IN [0..MIN[l1, l2]) DO	c1 ¬ ns.string.text[name1 + i];	c2 ¬ ns.string.text[name2 + i];	SELECT c1 FROM < c2 => RETURN[TRUE]; > c2 => RETURN[FALSE]; ENDCASE;	ENDLOOP;      SELECT l1 FROM < l2 => RETURN[TRUE]; > l2 => RETURN[FALSE]; ENDCASE;      SELECT TRUE FROM        imp1.port < imp2.port => RETURN[TRUE];	imp1.port > imp2.port => RETURN[TRUE];	ENDCASE => RETURN[CompareVersions[	  v1: BcdOpsExtras.FTBaseFromBcd[bcd][imp1.file].version,	  v2: BcdOpsExtras.FTBaseFromBcd[bcd][imp2.file].version] = less]};    GFILess: PROC [b1, b2: BindingRange] RETURNS [BOOLEAN] = {      imp1: BcdDefs.IMPIndex = bindings[b1].impi;      imp2: BcdDefs.IMPIndex = bindings[b2].impi;      itb: BcdDefs.Base = LOOPHOLE[bcd + bcd.impOffset];      RETURN[itb[imp1].gfi < itb[imp2].gfi]};    Less: PROC [b1, b2: BindingRange] RETURNS [BOOLEAN];    SiftUpBindings: PROCEDURE [low, high: CARDINAL] =      -- Partial sort of bindings by either name/version or gfi.      BEGIN      k, son, kTimes2: CARDINAL;      binding: Binding;      k ¬ low;      DO	kTimes2 ¬ k * 2;	IF kTimes2 > high THEN EXIT;	IF kTimes2 + 1 > high OR Less[kTimes2+1-1, kTimes2-1] THEN son ¬ kTimes2	ELSE son ¬ kTimes2 + 1;	IF Less[son-1, k-1] THEN EXIT;	binding ¬ bindings[son - 1];	bindings[son - 1] ¬ bindings[k - 1];	bindings[k - 1] ¬ binding;	k ¬ son;	ENDLOOP;      END;  --SiftUpBindings--    importName: LONG STRING ¬ [100];    exportLength: NATURAL = IF exports = NIL THEN 0 ELSE exports.length;    iBind, iExport: NATURAL ¬ 0;    currentNameIndex: CARDINAL ¬ CARDINAL.LAST;    itb: BcdDefs.Base = LOOPHOLE[bcd + bcd.impOffset];    IF bcd.nImports = 0 THEN RETURN[NIL];    bindings ¬ scratch.NEW[BindingSequence[bcd.nImports]];    [] ¬ BcdOps.ProcessImports[bcd, GetImports];    Less ¬ ImportLess;    FOR n: BindingRange DECREASING IN [1..bindings.length / 2] DO      SiftUpBindings[n, bindings.length] ENDLOOP;    FOR n: BindingRange DECREASING IN [1..bindings.length) DO      binding: Binding = bindings[1 - 1];      bindings[1 - 1] ¬ bindings[n + 1 - 1];      bindings[n + 1 - 1] ¬ binding;      SiftUpBindings[1, n];      ENDLOOP;    UNTIL iBind = bindings.length OR iExport = exportLength DO      impi: BcdDefs.IMPIndex = bindings[iBind].impi;      IF iBind # currentNameIndex THEN {        GetName[importName, bcd, itb[impi].name];	currentNameIndex ¬ iBind};      SELECT        CompareNames[importName, exports[iExport].name] FROM	  less => {iBind ¬ iBind + 1};	  greater => iExport ¬ iExport + 1;	  equal =>	    BEGIN	    IF itb[impi].port # exports[iExport].port THEN {iBind ¬ iBind + 1; LOOP};	    SELECT CompareVersions[	      BcdOpsExtras.FTBaseFromBcd[bcd][itb[impi].file].version,	      exports[iExport].version] FROM	      less => { -- we know this will raise a version mismatch	        bindings[iBind].erIndex ¬ sameNameDifferentVersion;		iBind ¬ iBind + 1};	      greater => { -- maybe the next export will be the same version	        bindings[iBind].erIndex ¬ sameNameDifferentVersion;		iExport ¬ iExport + 1};	      equal => {		bindings[iBind].erIndex ¬ iExport;		anyBound ¬ TRUE;		-- iExport ¬ iExport + 1;		-- don't bump export since may have duplicate import name		iBind ¬ iBind + 1};	      ENDCASE;	      END;	  ENDCASE;      ENDLOOP;   IF iBind # bindings.length THEN iBind ¬ iBind + 1; --don't forget the last case   FOR i: NATURAL IN [0..iBind) DO    ENABLE UNWIND => {scratch.FREE[@bindings]};    impi: BcdDefs.IMPIndex = bindings[i].impi;    IF bindings[i].erIndex = sameNameDifferentVersion THEN {      GetName[importName, bcd, itb[impi].name];      SIGNAL LoaderCore.WrongVersion[importName]};    ENDLOOP;    Less ¬ GFILess;    FOR n: BindingRange DECREASING IN [1..bindings.length / 2] DO      SiftUpBindings[n, bindings.length] ENDLOOP;    FOR n: BindingRange DECREASING IN [1..bindings.length) DO      binding: Binding = bindings[1 - 1];      bindings[1 - 1] ¬ bindings[n + 1 - 1];      bindings[n + 1 - 1] ¬ binding;      SiftUpBindings[1, n];      ENDLOOP;    FOR i: CARDINAL IN [1..bindings.length) DO      IF itb[bindings[i-1].impi].gfi = itb[bindings[i].impi].gfi THEN {        l, u: CARDINAL;	l ¬ i - 1;	u ¬ i + 1;        UNTIL u = bindings.length DO	  IF itb[bindings[l].impi].gfi # itb[bindings[u].impi].gfi THEN {	    l ¬ l + 1; bindings[l] ¬ bindings[u]};	  u ¬ u + 1;	  ENDLOOP;	EXIT};      ENDLOOP;    END;  --MakeBinding--  GetName: PROC [    s: LONG STRING, bcd: BcdOps.BcdBase, name: BcdDefs.NameRecord] = {    ns: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];    FOR i: CARDINAL IN [0..s.length ¬ ns.size[name]) DO      s[i] ¬ ns.string.text[name + i]; ENDLOOP};      END.<<LOG  (For previous log entries, please see Mesa 10.0 archive version.) 4-Dec-81 11:34:27   WDK   Exported type clash must be a ConfigError, not a VersionMismatch. 4-Jan-82 14:27:30   JGS   Config control module fingers must be stored in even addresses. 7-Sep-83 14:07:55   WDK   Made compatible with new LoadState and new interface LoadedMem. Ditch OPENs. Renamed from PilotLoaderCore to LoaderCoreImpl. Moved utility procs here from PilotLoaderSupport (old name). Desupported resident frames. Eliminated most loopholes. Better names. Eliminated dull one line procs. Dealt with demise of GlobalFrameTable. Fingers no longer have to be on 0 mod 2 boundaries. Quit looking at exporters as soon as module's imports are resolved. Resolve all imports first to avoid leaving a mess if load operaiton aborts. Create/maintain transient data structure describing objects being manipulated; back out cleanly on error. Unnest procs where reasonable. New ControlModuleFormat. Calculate values directly rather than by loops. Existing NEWed module instances were ignored in binding. Wrongly allowed access to all modules of config, not just exported ones. Single-module determination logic was wrong. Reorganize so as to also function as the loader in MakeBoot. Reorganize to make bootstrapping easier. Wasn't mapping whole code sets as a unit. Don't struggle to allocate all control lists in a block. Delete unused strings. Desupported gFrame.word.shared. Added lots of error checking.   19-Sep-83 16:12:05	RES   Moved type declarations into LoaderCoreOps10-Oct-83 16:52:01	RES  Fixed Unloading by not trying to resolve imports of remaining modules that were resolved internally (added dummyLink parameter to Interesting)11-Oct-83 15:35:03	RES  Put modules into loadstate before binding imports since if we export some link (like say a SIGNAL or ERROR) that we also export, it goes to the loadstate to get the global frame address.  It will work better if it can find it there at that point.20-Oct-83 15:56:37   WDK   AR 4715: Load[fileSatifyingPrevFilesFrameLinks] => Write Protect Fault 9-Nov-83 14:47:51   WDK   ExpandTablesInternal now returns new load state address, allowing us to not address fault.17-Nov-83 19:04:00   WDK   AllocAndInitIfUnallocated failed to provide enough slop to account for possibly inadequaterounding up in AccumulateFramePackSize.12-Dec-83 17:39:02   WDK   AR 2381: Mark table compiled modules as already started.16-Feb-84 11:19:07	RES  Initialize codeSets earlier as we were unwinding (and freeing them) beforehand if loading with code links on a readonly volume. 8-Jun-84 15:50:41	RES  Don't test against bcd in ResolveImportedLinks if unbinding. Fixes write protect fault from unloading a module that exported an item to the last thing loaded, if the last thing was loaded with code links. 9-Oct-84 13:46:11       ET   copyrite formatted.28-May-85 16:10:01       JGS & ET   Split LoaderCoreImpl into LoaderCoreImplA and LoaderCoreImplB. Changes made to incorporated JGS's new routing SortImportsAndExports.   2-Jun-85 17:09:14       ET   Changed test of a compiler-output module in FindExportsMatchingImports IF exporter.nConfigs = 0 (vs. IF exports = NIL)24-Apr-86  9:14:58       JGS & ET   Picked up all of JGS's edits. Added a few more. Getting rid of the old way of handling imports and exports to a new way with a table of export records that always stays around. importsAllResolved of BindUnboundIfPossible was not initialized.27-Jun-86  9:35:36	ET  Convert to new princops to handle both old and new bcds.  12-Aug-86 11:36:25      ET  Added calls to LoadedMem.WriteCodeLinks for makeboot.20-Aug-86 19:33:29	ET  Added calls to LoadedMem.ReadCodeLinks for makeboot.26-Aug-86 13:56:12	ET  Fix for 12.3: Fixed RebuildExportRecords to from erh.links[i] ¬ link to erh.links[l]. Otherwise we just keep righting over the first link.>>18-Sep-87 19:11:39      ET  Added one extra entry in needsRebuilding in RemoveExportRecords, so we don't smash LAST[CARDINAL] into the the next node or vm when we have multipleExporters.23-Sep-87 19:43:02      ET  Fixes to MakeBinding and BindUnboundIfPossible to communicate version mismatches differently. 15-Oct-87 17:46:57      ET  Move UNWIND scratch.FREE[@bindings] from BindUnboundIfPossible to MakeBinding.
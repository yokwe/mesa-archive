-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- ResMemMgr>ResidentMemoryImpl.mesa    16-Feb-87 10:53:05 by ET    -- IMPLEMENTATION RESTRICTION: No frame heap ALLOC's may be executed within any ENTRY procedures in this monitor, so that they may be called from the allocation trap handler.  If this rule were not followed, we could get an allocation trap when we held the monitor lock, thus making AllocateMDS inaccessible to the frame fault handler.  Please see comments in ResidentMemory.mesa.-- Implementation Notes:---- Pages requested to be allocated in Location[hyperspace] are currently allocated from the pages of Location[pda]. This is done because there is expected to be very little demand for pages in the pda, and sharing saves us countMax pages of virtual memory.---- STRINGs used in the fixed-frame procedures here are kept in the global frame so we can better see where storage is being spent.  (The local frames are resident anyway, so putting them there doesn't save anything.)DIRECTORY  Environment USING [PageCount, PageNumber],  Frame USING [GetReturnFrame, SetReturnFrame],  Inline USING [LowHalf],  KernelSpaceUsage USING [residentMemory],  MStore USING [Deallocate],  PrincOps USING [ControlLink, Port],  ResidentMemory USING [    AllocateInternal, AllocateMDSInternal, FreeInternal, Location],  RuntimeInternal USING [Bug, WorryCallDebugger],  SDDefs USING [SD],  SDDefsExtras USING [sLocalFramePages],  Space USING [LongPointerFromPage, PageFromLongPointer],  StoragePrograms USING [AllocateVM, PMDS],  VM USING [Interval],  VMData USING [AllocateReservedMStore];ResidentMemoryImpl: MONITOR LOCKS residentMemoryLock  IMPORTS    Frame, Inline, MStore, RuntimeInternal, Space, StoragePrograms, VMData  EXPORTS ResidentMemory, StoragePrograms  SHARES ResidentMemory =  BEGIN  -- PARAMETERS:  countMax: CARDINAL = 50;  -- amount of VM allocated for each location.  countMaxForMDS: CARDINAL =     Inline.LowHalf[SDDefs.SD[SDDefsExtras.sLocalFramePages]];    defaultLocation: AllocatingLocations = pda;  -- Allocation requests for a location not in AllocatingLocations  --    (i.e. hyperspace) are allocated here.  -- TYPES and VARIABLES:  residentMemoryLock: PUBLIC MONITORLOCK;  -- (PRIVATE in interface)  AllocatingLocations: TYPE = ResidentMemory.Location[first64K..mds];  -- excludes hyperspace.  -- Code assumes that the three desired locations are contiguous in AllocatingLocations:  assertFirst64KIncluded: BOOLEAN [TRUE..TRUE] =    (ResidentMemory.Location[first64K] IN AllocatingLocations);  assertPdaIncluded: BOOLEAN [TRUE..TRUE] =    (ResidentMemory.Location[pda] IN AllocatingLocations);  assertMdsIncluded: BOOLEAN [TRUE..TRUE] =    (ResidentMemory.Location[mds] IN AllocatingLocations);  assertHyperspaceExcluded: BOOLEAN [TRUE..TRUE] =    (ResidentMemory.Location[hyperspace] NOT IN AllocatingLocations);  locations: ARRAY AllocatingLocations OF LocationData;    LocationData: TYPE = RECORD [    page: Environment.PageNumber,  -- starting page of VM area.    vp: SELECT OVERLAID * FROM      first64K, pda => [allocationMap: AllocationMap],      mds => [mdsAllocationMap: AllocationMapForMDS],      ENDCASE];    AllocationMap: TYPE = PACKED ARRAY AllocIndex OF FreeBusy;  AllocationMapForMDS: TYPE = PACKED ARRAY AllocIndexForMDS OF FreeBusy;  AllocIndex: TYPE = [0..countMax);  AllocIndexForMDS: TYPE = [0..256);  -- 256 is a fudge factor max until we get the real one from countMaxForMDS.  FreeBusy: TYPE = {free, busy};    BugType: TYPE = {insufficientVM};  --~~~~~~~~~~ Initialization:  InitializeResidentMemory: PUBLIC --StoragePrograms.-- ENTRY PROCEDURE[] =    -- (An ENTRY so InitializeAllocate* can be called.)    BEGIN    FOR location: AllocatingLocations IN AllocatingLocations DO      IF location = mds THEN 	BEGIN	FOR j: CARDINAL IN [0..countMaxForMDS) DO	  locations[location].mdsAllocationMap[j] ¬ free; ENDLOOP;	locations[location].page ¬ StoragePrograms.AllocateVM[	  countMaxForMDS, location, KernelSpaceUsage.residentMemory,	  partiallyOrSometimesMapped];	END      ELSE BEGIN        FOR j: CARDINAL IN [0..countMax) DO	  locations[location].allocationMap[j] ¬ free; ENDLOOP;        locations[location].page ¬ StoragePrograms.AllocateVM[	  countMax, location, KernelSpaceUsage.residentMemory,	  partiallyOrSometimesMapped];        END      ENDLOOP;    [] ¬ InitializeAllocate[];  -- allocate frame;  initialize PORT.    [] ¬ InitializeAllocateMDS[];  -- allocate frame;  initialize PORT.    [] ¬ InitializeFree[];  -- allocate frame;  initialize PORT.    END;  --~~~~~~~~~~ Implementation:  allocateInternal: PUBLIC --INTERNAL-- ResidentMemory.AllocateInternal;    -- (PRIVATE in interface)  ("¬" due to compiler glitch)    -- Guaranteed not to do an ALLOC from the frame heap.    -- an indirect control link to the PORT is set in InitializeAllocate  InitializeAllocate: INTERNAL PROCEDURE    RETURNS [ --must match PORT args-- lp: LONG POINTER TO UNSPECIFIED] =    BEGIN        AwaitAllocateRequest: --RESPONDING-- PORT [lp: LONG POINTER TO UNSPECIFIED]      RETURNS [location: ResidentMemory.Location, pages: Environment.PageCount];       -- args/results match allocateInternal (but swapped).          loc: ResidentMemory.Location;    longCount: Environment.PageCount;    count: CARDINAL;    allocateInternal ¬ LOOPHOLE[LONG[@AwaitAllocateRequest]];    LOOPHOLE[AwaitAllocateRequest, PrincOps.Port].dest ¬  --      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];  -- set PORT call to return to caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [loc, longCount] ¬ AwaitAllocateRequest[lp];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitAllocateRequest, PrincOps.Port].dest.frame];      IF loc = mds AND longCount > countMaxForMDS THEN	RuntimeInternal.Bug[BugType[insufficientVM]];      IF loc # mds AND longCount > countMax THEN  -- 1 of 2.        RuntimeInternal.Bug[BugType[insufficientVM]];      count ¬ CARDINAL[longCount];  -- 2 of 2.      IF loc NOT IN AllocatingLocations THEN loc ¬ defaultLocation;      -- ASSERT: loc IN AllocatingLocations.      BEGIN  --scope of Done--      start, pageInRun: AllocIndexForMDS;      lData: LONG POINTER TO LocationData = @locations[loc];      cntMax: CARDINAL ¬ IF loc = mds THEN countMaxForMDS ELSE countMax;      FOR start ¬ 0, pageInRun + 1 WHILE start + count <= cntMax DO        -- Look for good starting page:        FOR pageInRun IN [start..start + count) DO  	-- look for count contiguous pages..	  IF loc = mds AND lData.mdsAllocationMap[pageInRun] = busy THEN EXIT;          IF lData.allocationMap[pageInRun] = busy THEN EXIT; 	   -- (pageInRun must survive loop exit.)          REPEAT            FINISHED =>  -- found count contiguous free pages.              BEGIN              VMData.AllocateReservedMStore[                VM.Interval[lData.page + start, count], TRUE];              FOR pageInRun IN [start..start + count) DO {	        IF loc = mds THEN lData.mdsAllocationMap[pageInRun] ¬ busy                ELSE lData.allocationMap[pageInRun] ¬ busy; }	        ENDLOOP;              lp ¬ Space.LongPointerFromPage[lData.page + start];              GO TO Done;              END;          ENDLOOP;        REPEAT  -- (not enough contiguous pages beginning at start)          FINISHED =>            DO              RuntimeInternal.WorryCallDebugger[                "Out of VM for resident memory"G];              ENDLOOP;        ENDLOOP;      EXITS Done => NULL;      END;  --scope of Done--      ENDLOOP;  --FOREVER--    END;  --InitializeAllocate--  allocateMDSInternal: PUBLIC --INTERNAL-- ResidentMemory.AllocateMDSInternal;    -- (PRIVATE in interface)  ("¬" due to compiler glitch)    -- Guaranteed not to do an ALLOC from the frame heap.    -- an indirect control link to the PORT is set in InitializeAllocateMDS  InitializeAllocateMDS: INTERNAL PROCEDURE RETURNS [p: POINTER TO UNSPECIFIED]    --to match PORT args--  =    BEGIN        AwaitAllocateMDSRequest: --RESPONDING-- PORT [p: POINTER TO UNSPECIFIED]      RETURNS [pages: Environment.PageCount];      -- args/results match allocateMDSInternal (but swapped).        pages: Environment.PageCount;    allocateMDSInternal ¬ [LOOPHOLE[LONG[@AwaitAllocateMDSRequest]]];    LOOPHOLE[AwaitAllocateMDSRequest, PrincOps.Port].dest ¬ PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    -- set my PORT call to return to my caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      pages ¬ AwaitAllocateMDSRequest[p];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitAllocateMDSRequest, PrincOps.Port].dest.frame];      p ¬ LOOPHOLE[CARDINAL[allocateInternal[mds, pages].lp - StoragePrograms.PMDS[]]];      ENDLOOP;    END;  --InitializeAllocateMDS--  freeInternal: PUBLIC --INTERNAL-- ResidentMemory.FreeInternal;    -- (PRIVATE in interface)  ("¬" due to compiler glitch)    -- Guaranteed not to do an ALLOC from the frame heap.    -- an indirect control link to the PORT is set in InitializeFree.    InitializeFree: INTERNAL PROCEDURE =    BEGIN        AwaitFreeRequest: --RESPONDING-- PORT      RETURNS [      location: ResidentMemory.Location, pages: Environment.PageCount,      lp: LONG POINTER TO UNSPECIFIED];        -- args/results match freeInternal (but swapped).           loc: ResidentMemory.Location;    page: Environment.PageNumber;    count: Environment.PageCount;    lp: LONG POINTER TO UNSPECIFIED;    lData: LONG POINTER TO LocationData;    start: AllocIndexForMDS;        freeInternal ¬ [LOOPHOLE[LONG[@AwaitFreeRequest]]];    LOOPHOLE[AwaitFreeRequest, PrincOps.Port].dest ¬ PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];  -- set my PORT call to return to my caller on call below.    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [loc, count, lp] ¬ AwaitFreeRequest[];      Frame.SetReturnFrame[LOOPHOLE[AwaitFreeRequest, PrincOps.Port].dest.frame];  -- for debugger      IF loc NOT IN AllocatingLocations THEN loc ¬ defaultLocation;      -- ASSERT: loc IN AllocatingLocations.      lData ¬ @locations[loc];      page ¬ Space.PageFromLongPointer[lp];      MStore.Deallocate[[page, count], notPromised];      -- Note: Implementation currently does not check that      -- page and count are sensible.      start ¬ AllocIndexForMDS[page - lData.page];      FOR pageInRun: AllocIndexForMDS IN [start..start + CARDINAL[count]) DO {        IF loc = mds THEN lData.mdsAllocationMap[pageInRun] ¬ free         ELSE lData.allocationMap[pageInRun] ¬ free };        ENDLOOP;      ENDLOOP;    END;  --InitializeFree--  END.LOGApril 16, 1980  8:52 AM   WDK       Created file from PilotControl of March 11, 1980.  Added InitializeResidentMemoryA/B. Names changed to AllocateMDS, FreeMDS.  Implement Free.  Make Allocate alloc in first64K and hyperspace, as well as MDS.  Made Allocate, AllocateMDS coroutines.April 28, 1980  9:56 AM   FXH       ControlDefs=>PrincOps, FrameOps => Frame.November 5, 1980  1:00 PM   WDK       Made Free a coroutine.  Get LongPointerFromPage, PageFromLongPointer from Utiliies.29-Oct-81  7:45:55   WDK       Use packed array of bit operations.  Remove checks for mds in first 64K. Fix AR 7179.24-Feb-82 15:11:25   CAJ    Change countMax from 40 to 50.14-Sep-82 10:41:49   WDK        CachedRegionInternal changes to VMData. Added AllocatingLocations.22-Dec-82 15:09:44   AWL         PilotSpaceUsage => KernelSpaceUsage, NewSpace => Space.18-Jan-83 11:39:35   AWL         Long page count bug in Free.18-Feb-83 16:21:55   WDK        Torpedoed Inline.LowHalfs.25-May-83  9:12:27   WDK        Allocate set its return link a little late, confusing the debugger.12-Jul-83 17:07:32   JXP      Fix port stuff.24-Jul-84 18:09:32   KEK       remove memType from call to Deallocate16-Aug-84 19:14:52   KEK     add "resident" argument to AllocateReservedMStore (for PC emulation).11-Jul-86 10:31:41   ET	     MDS relief: Move ports from global frames into local frames.16-Feb-87 10:53:12   ET      More MDS relief: Changed LocationData and InitializeResidentMemory procedure to allow local frame space in mds to vary. (It was countMax = 50 pages). SDDefsExtras will get a value from the .bootmesa, with a default remaining at 50.  
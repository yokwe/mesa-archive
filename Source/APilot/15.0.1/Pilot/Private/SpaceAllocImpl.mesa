-- Copyright (C) 1984, 1986, 1988  by Xerox Corporation. All rights reserved. -- SpaceAllocImpl.mesa   26-Jan-88 13:24:42 by RSV  -- IMPLEMENTATION NOTES-- At various places assumptions are made.  These are all checked with compile--   time assertions at those places.  These involve assumptions about the relative--   sizes of things and the values of various constants.DIRECTORY  Environment USING [     bitsPerWord, lastPageNumber, maxPagesInMDS, PageCount, PageNumber,     PageOffset, wordsPerPage],  KernelObjAlloc USING [     AllocateAt, AlreadyAllocated, FindFreeRange, AllSameState],  KernelSpaceUsage USING [spaceAllocationMap],  ObjAlloc USING [     AllocationPool, AllocFree, AlreadyFreed, Error, Free, InitializePool,     Interval, ItemCount, ItemIndex],  RuntimeInternal USING [Bug],  Space USING [     defaultBase, Error, ErrorType, InsufficientSpace, Interval,     LongPointerFromPage, PageCount, PageFromLongPointer, PageNumber],  SpecialSpaceExtras USING [],  SpecialSpace USING [],  StoragePrograms USING [     AllocateVM, countVM, EnumerateUnusedVM, UnusedVMProc],  VM USING [FindMapUnit, GetMapUnitAttributes, Interval, Map],  VMMPrograms USING [];SpaceAllocImpl: MONITOR   IMPORTS    KernelObjAlloc, ObjAlloc, RuntimeInternal, Space, StoragePrograms,    VM  EXPORTS Space, SpecialSpaceExtras, SpecialSpace, StoragePrograms, VMMPrograms =  BEGIN    --ASSERT--bitsPerWordTest: CARDINAL [0..0] =     (Environment.maxPagesInMDS MOD Environment.bitsPerWord);     --This code assumes that this asertion is true.  If it should ever be false,     -- the initialization of vmAllocationRegions gets harder.  --ASSERT--oneBitPerAllocItem: BOOLEAN [TRUE..TRUE] =     ((LOOPHOLE[FIRST[ObjAlloc.AllocFree], CARDINAL] = 0) AND     (LOOPHOLE[LAST[ObjAlloc.AllocFree], CARDINAL] = 1));     -- If this test fails, allocsPerWord, AllocateInInterval and FixUpRegion must     --   change.  AlignType: TYPE = {code, powerOf2};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Space monitor data:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Public Data:  InsufficientSpace: PUBLIC ERROR [available: Space.PageCount] = CODE;  virtualMemory: PUBLIC Space.Interval;  -- Private Data:  allocsPerWord: CARDINAL = Environment.bitsPerWord;  allocationArray: LONG POINTER TO ObjAlloc.AllocationPool;  maxPagesInCodeBlock: Space.PageCount = Environment.maxPagesInMDS;  mds: Space.Interval;    VMAllocationRegions: TYPE =     {hyperSpaceAfterMDS, hyperSpaceBeforeMDS, first64K, second64K, mds,      vm};  RegionInfo: TYPE = RECORD [     interval: ObjAlloc.Interval, -- i.e., an interval of VM     firstFree: ObjAlloc.ItemIndex -- i.e., a VM page number        -- Hint: all preceeding elements of this region are known to be allocated     ];  vmAllocationRegions: ARRAY VMAllocationRegions OF RegionInfo ¬ ALL[[[0, 0], 0]];  BugType: TYPE = {impossibleSelectError, unexpectedObjAllocError};  Bug: PROCEDURE [bug: BugType] = INLINE {RuntimeInternal.Bug[bug]};  --~~~~~~~~~~~~~~~~~~~~  -- Initialization  --~~~~~~~~~~~~~~~~~~~~  InitializeSpaceAllocation: PUBLIC --StoragePrograms-- PROCEDURE [] =    BEGIN    intervalMDS: Space.Interval =      [LONG[LOOPHOLE[1, POINTER]]-1, Environment.maxPagesInMDS];    bitsPerPage: CARDINAL = Environment.wordsPerPage*Environment.bitsPerWord;    allocationArrayPages: Environment.PageCount;    allocationArrayPage: Environment.PageNumber;    mdsPage: Environment.PageNumber =       Space.PageFromLongPointer[intervalMDS.pointer];    virtualMemory ¬ [pointer: NIL, count: StoragePrograms.countVM];    mds ¬ intervalMDS;    allocationArrayPages ¬ (virtualMemory.count+bitsPerPage-1)/bitsPerPage;    allocationArrayPage ¬       StoragePrograms.AllocateVM[         allocationArrayPages, hyperspace, KernelSpaceUsage.spaceAllocationMap,	 alwaysWhollyMapped];    allocationArray ¬ Space.LongPointerFromPage[allocationArrayPage];        VM.Map[       interval: [page: allocationArrayPage, count: allocationArrayPages],       transferProc: NIL,       backingStoreRuns: NIL,       usage: KernelSpaceUsage.spaceAllocationMap,       class: data,       access: readWrite,       swapUnits: [uniform[1]],       life: alive,       swappability: resident];        ObjAlloc.InitializePool[       pool: [allocPool: allocationArray, poolSize: virtualMemory.count],       initialState: alloc];        -- Now enumerate the unused parts of VM and mark as free:    BEGIN    UnusedVM: StoragePrograms.UnusedVMProc --[unused: VM.Interval]-- =      BEGIN      ObjAlloc.Free[        pool: [allocPool: allocationArray, poolSize: virtualMemory.count],	interval: [first: unused.page, count: unused.count],	validate: TRUE];      END;    StoragePrograms.EnumerateUnusedVM[UnusedVM];    END;  --InitializeSpaceAllocation--        -- Now explicitly mark page 0, MDS page 0 and our allocation array as    --   allocated.    allocationArray[0] ¬ alloc;    KernelObjAlloc.AllocateAt[       pool: [allocPool: allocationArray, poolSize: virtualMemory.count],       interval: [first: Space.PageFromLongPointer[intervalMDS.pointer],                  count: 1],	validate: FALSE];    KernelObjAlloc.AllocateAt[       pool: [allocPool: allocationArray, poolSize: virtualMemory.count],       interval: [first: allocationArrayPage, count: allocationArrayPages],       validate: FALSE];        -- Now set up vmAllocationRegions        vmAllocationRegions[first64K] ¬ [       interval: [first: 0, count: Environment.maxPagesInMDS],       firstFree: 0];        vmAllocationRegions[second64K] ¬ [       interval: [first: Environment.maxPagesInMDS,                  count: Environment.maxPagesInMDS],	firstFree: Environment.maxPagesInMDS];        -- note that firstFree allows for MDS page 0 being allocated    vmAllocationRegions[mds] ¬ [       interval: [first: mdsPage, count: mds.count],	firstFree: mdsPage];        vmAllocationRegions[hyperSpaceAfterMDS].interval.first ¬ mdsPage+mds.count;       -- Note that we use mds.interval.count above to correctly handle       -- the case where the MDS is at the end of VM and is not full-sized.    vmAllocationRegions[hyperSpaceAfterMDS].interval.count ¬       virtualMemory.count-       vmAllocationRegions[hyperSpaceAfterMDS].interval.first;    vmAllocationRegions[hyperSpaceAfterMDS].firstFree ¬      vmAllocationRegions[hyperSpaceAfterMDS].interval.first;        vmAllocationRegions[hyperSpaceBeforeMDS].interval.first ¬       vmAllocationRegions[second64K].interval.first+Environment.maxPagesInMDS;    vmAllocationRegions[hyperSpaceBeforeMDS].interval.count ¬      IF mdsPage > vmAllocationRegions[hyperSpaceBeforeMDS].interval.first      THEN mdsPage-vmAllocationRegions[hyperSpaceBeforeMDS].interval.first      ELSE 0;    vmAllocationRegions[hyperSpaceBeforeMDS].firstFree ¬      vmAllocationRegions[hyperSpaceBeforeMDS].interval.first;        vmAllocationRegions[vm] ¬ [       interval: [first: Space.PageFromLongPointer[virtualMemory.pointer],                  count: virtualMemory.count],       firstFree: 0];           -- now ensure all the firstFree hints are correct    FOR region: VMAllocationRegions IN VMAllocationRegions       DO      p: LONG POINTER TO RegionInfo = @vmAllocationRegions[region];      p.firstFree ¬ KernelObjAlloc.AllSameState[          pool:[allocPool: allocationArray, poolSize: virtualMemory.count],	  interval:p.interval,	  desiredState:alloc].firstDifferent      ENDLOOP;        END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- All other procedures, in alphabetical order  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AdjustRegionInterval: INTERNAL PROCEDURE [region: VMAllocationRegions]       RETURNS [ObjAlloc.Interval] = INLINE       BEGIN       -- We use a pointer since array references are so inefficient       p: LONG POINTER TO RegionInfo = @vmAllocationRegions[region];       RETURN [	     [first: p.firstFree,	      count: p.interval.count + p.interval.first - p.firstFree]];       END;    Allocate: PUBLIC ENTRY PROCEDURE [    count: Environment.PageCount, within: Space.Interval,    base: Environment.PageOffset]    RETURNS [interval: Space.Interval] =    BEGIN    firstPageOfWithin: Environment.PageNumber =       Space.PageFromLongPointer[within.pointer];    allocedInterval: ObjAlloc.Interval;    IF count = 0 OR       within.count > virtualMemory.count OR       firstPageOfWithin >= virtualMemory.count OR        firstPageOfWithin+within.count > virtualMemory.count THEN       RETURN WITH ERROR Space.Error[invalidParameters];    IF base ~= Space.defaultBase THEN       BEGIN       IF base+count > within.count THEN          RETURN WITH ERROR Space.Error[invalidParameters];       KernelObjAlloc.AllocateAt[          pool: [allocPool: allocationArray, poolSize: virtualMemory.count],	  interval: [	     first: firstPageOfWithin+base,	     count: count],	  validate: TRUE !	  KernelObjAlloc.AlreadyAllocated => GO TO alreadyAllocatedReturn;	  ObjAlloc.Error => Bug[unexpectedObjAllocError]];       FixUpWithInterval[          [first: firstPageOfWithin+base, count: count],  alloc];       RETURN [          [pointer: Space.LongPointerFromPage[firstPageOfWithin+base],	   count: count]];       END;    -- We have been given a default base so we get to choose the place    IF within = virtualMemory THEN       BEGIN       maxPossible: Space.PageCount ¬ 0;       FOR region: VMAllocationRegions IN VMAllocationRegions DO          allocedInterval ¬ 	     AllocateInInterval[AdjustRegionInterval[region], count];	  IF allocedInterval.count = count THEN	     BEGIN	     FixUpRegion[region, allocedInterval, alloc];	     RETURN DoAllocate[allocedInterval];	     END;	  maxPossible ¬ MAX[maxPossible, allocedInterval.count]	  ENDLOOP;       RETURN WITH ERROR Space.InsufficientSpace[maxPossible];       END    ELSE       -- the client has supplied us with a region to allocate from that is not VM       -- For simplicity, we don't try to use the "firstFree" hint associated with       -- parts of VM.       BEGIN       allocedInterval ¬         AllocateInInterval[[firstPageOfWithin, within.count], count];       IF allocedInterval.count = count THEN           BEGIN	  FixUpWithInterval[allocedInterval, alloc];          RETURN DoAllocate[allocedInterval];	  END       ELSE RETURN WITH ERROR Space.InsufficientSpace[allocedInterval.count];       END;    EXITS    alreadyAllocatedReturn => RETURN WITH ERROR Space.Error[alreadyAllocated]    END;  AllocateAligned: PUBLIC PROCEDURE [    count: Environment.PageCount, within: Space.Interval]    RETURNS [interval: Space.Interval] =    BEGIN    interval ¬ FindAlignedSpace[count, within, powerOf2];    END;  AllocateForCode: PUBLIC PROCEDURE [    count: Environment.PageCount, within: Space.Interval]    RETURNS [interval: Space.Interval] =    BEGIN    interval ¬ FindAlignedSpace[count, within, code];    END;         AllocateInInterval: INTERNAL PROCEDURE [    interval: ObjAlloc.Interval, count: ObjAlloc.ItemCount]    RETURNS [largestInterval: ObjAlloc.Interval] =    BEGIN        IF interval.count = 0 THEN RETURN[interval];        largestInterval ¬ KernelObjAlloc.FindFreeRange[       pool: [allocPool: allocationArray,              poolSize: interval.first+interval.count],       offset: interval.first,       count: count, willTakeSmaller: TRUE, carryIn: 0 !       ObjAlloc.Error => Bug[unexpectedObjAllocError]].interval;        RETURN [largestInterval];    END;     AllocateInterval: INTERNAL PROCEDURE [    interval: ObjAlloc.Interval]    RETURNS [largestInterval: ObjAlloc.Interval] =    BEGIN    allFree:BOOLEAN;    firstAlloc: ObjAlloc.ItemIndex;        [allFree, firstAlloc] ¬ KernelObjAlloc.AllSameState[       pool: [allocPool: allocationArray,              poolSize: virtualMemory.count],       interval:interval,        desiredState:free !       ObjAlloc.Error => Bug[unexpectedObjAllocError]];    largestInterval.first ¬ interval.first;        IF allFree THEN       largestInterval.count ¬ interval.count    ELSE      largestInterval.count ¬ firstAlloc - interval.first;          RETURN [largestInterval];    END;    Deallocate: PUBLIC ENTRY PROCEDURE [interval: Space.Interval] =    BEGIN    savedError: Space.ErrorType;    BEGIN    shortNIL: POINTER = NIL;    allocInterval: ObjAlloc.Interval;    intervalPage: Environment.PageNumber ¬      Space.PageFromLongPointer[interval.pointer];    mapUnit: VM.Interval ¬ VM.FindMapUnit[intervalPage !       Space.Error => {savedError ¬ type; GO TO spaceError}];    IF interval.pointer=NIL OR interval.pointer=shortNIL      THEN RETURN WITH ERROR Space.Error[invalidParameters];    IF intervalPage IN [mapUnit.page..mapUnit.page+mapUnit.count) OR      mapUnit.page IN [intervalPage..intervalPage+interval.count)      THEN RETURN WITH ERROR Space.Error[stillMapped];    IF interval.count=0 THEN RETURN;    allocInterval ¬ [      first: Space.PageFromLongPointer[interval.pointer],      count: interval.count];    ObjAlloc.Free[      pool: [allocPool: allocationArray, poolSize: virtualMemory.count],      interval: allocInterval, validate: TRUE !      ObjAlloc.AlreadyFreed =>        {savedError ¬ alreadyDeallocated; GO TO spaceError};      ObjAlloc.Error => Bug[unexpectedObjAllocError]];    FixUpWithInterval[allocInterval, free];    EXITS      spaceError => RETURN WITH ERROR Space.Error[savedError];    END; --nested for savedError--    END;   DoAllocate: INTERNAL PROCEDURE [allocate: ObjAlloc.Interval]    RETURNS [interval: Space.Interval] =    BEGIN    KernelObjAlloc.AllocateAt[       pool: [allocPool: allocationArray, poolSize: virtualMemory.count],       interval: [first: allocate.first, count: allocate.count],       validate: FALSE !       ObjAlloc.Error => Bug[unexpectedObjAllocError]];       -- note that this can also raise KernelObjAlloc.AlreadyAllocated       -- which could lead to a potential ML in this module....however, if       -- SpaceAllocImpl always sets things up correctly, then this should never       -- happen.    RETURN [[       pointer: Space.LongPointerFromPage[allocate.first],       count: allocate.count]];    END;   FindAlignedSpace: ENTRY PROCEDURE [    count: Space.PageCount, within: Space.Interval, alignType: AlignType]    RETURNS [interval: Space.Interval] =    BEGIN    firstPageOfWithin: Space.PageNumber =       Space.PageFromLongPointer[within.pointer];    alignment: LONG CARDINAL;    FindAlignedInInterval: INTERNAL PROCEDURE [interval: ObjAlloc.Interval]      RETURNS [largestInterval: ObjAlloc.Interval] =      BEGIN      -- This code relies on the fact that an ObjAlloc.Interval can      --    describe at least 64K more things than can a Space.Interval!      --ASSERT--objAllocIntervalBigger: BOOLEAN[TRUE..TRUE] =         LAST[ObjAlloc.ItemIndex]>Environment.lastPageNumber AND	 LAST[ObjAlloc.ItemIndex]-Environment.lastPageNumber > 200000B;      intervalPlusOne: ObjAlloc.ItemIndex = interval.first+interval.count;      largestInterval ¬ [first: 0, count: 0];      SELECT alignType FROM	 code =>	    BEGIN -- The allocated region can't cross 64K (MDS) boundaries	    sixtyFourK: LONG CARDINAL = Environment.maxPagesInMDS;	    candidateInterval: ObjAlloc.Interval;	    currentInterval: ObjAlloc.Interval ¬ interval;	    currentInterval.count ¬ MIN[	       -- don't go past end of interval	       intervalPlusOne-currentInterval.first,	       -- don't cross a 64K boundary	       ((currentInterval.first+sixtyFourK)/sixtyFourK)*sixtyFourK-	        currentInterval.first];	     candidateInterval ¬ AllocateInInterval[currentInterval, count];	     IF candidateInterval.count = count THEN RETURN[candidateInterval];	     currentInterval.first ¬	        ((currentInterval.first+sixtyFourK)/sixtyFourK)*sixtyFourK;	     currentInterval.count ¬ MIN[	        intervalPlusOne-currentInterval.first,		sixtyFourK];	     WHILE currentInterval.first < intervalPlusOne DO	        candidateInterval ¬ AllocateInInterval[currentInterval, count];	        IF candidateInterval.count = count THEN RETURN[candidateInterval];	        IF candidateInterval.count > largestInterval.count THEN	           largestInterval ¬ candidateInterval;	        currentInterval.first ¬ currentInterval.first+sixtyFourK;	        currentInterval.count ¬ MIN[	           intervalPlusOne-currentInterval.first,		   sixtyFourK];	        ENDLOOP;	    RETURN [largestInterval];	    END;	 powerOf2 =>	    BEGIN -- must be aligned on an "alignment" boundary	    currentInterval: ObjAlloc.Interval ¬ [	       first: interval.first, count: interval.count];	    currentInterval.first ¬	       ((currentInterval.first+alignment)/alignment)*alignment;	    WHILE currentInterval.first < intervalPlusOne DO	       candidateInterval: ObjAlloc.Interval;	       currentInterval.count ¬ MIN[	          count, -- this term ensures correct alignment		  intervalPlusOne-currentInterval.first];	       candidateInterval ¬ AllocateInterval[currentInterval];	       IF candidateInterval.count = count THEN RETURN[candidateInterval];	       IF candidateInterval.count > largestInterval.count THEN	          largestInterval ¬ candidateInterval;	       currentInterval.first ¬ currentInterval.first+alignment;	       ENDLOOP;	    RETURN [largestInterval];	    END;	 ENDCASE => Bug[impossibleSelectError];      END;        IF alignType = powerOf2 THEN       FOR alignment ¬ 1, alignment*2 UNTIL alignment >= count DO NULL ENDLOOP;    IF count = 0 OR       within.count > virtualMemory.count OR       firstPageOfWithin >= virtualMemory.count OR        firstPageOfWithin+within.count > virtualMemory.count OR       (alignType = code AND count > maxPagesInCodeBlock) THEN       RETURN WITH ERROR Space.Error[invalidParameters];    -- We have been given a default base so we get to choose the place    IF within = virtualMemory THEN       BEGIN       maxPossible: Space.PageCount ¬ 0;       FOR region: VMAllocationRegions IN VMAllocationRegions DO          allocInterval: ObjAlloc.Interval =             FindAlignedInInterval[AdjustRegionInterval[region]];	  IF allocInterval.count = count THEN	     BEGIN	     FixUpRegion[region, allocInterval, alloc];	     RETURN DoAllocate[allocInterval];	     END;	  maxPossible ¬ MAX[maxPossible, allocInterval.count]	  ENDLOOP;       RETURN WITH ERROR Space.InsufficientSpace[maxPossible];       END    ELSE       -- the client has supplied us with a region to allocate from that is not VM       BEGIN       allocInterval: ObjAlloc.Interval =          FindAlignedInInterval[             [first: Space.PageFromLongPointer[within.pointer],	      count: within.count]];       IF allocInterval.count = count THEN          BEGIN	  FixUpWithInterval[allocInterval, alloc];	  RETURN DoAllocate[allocInterval];	  END       ELSE RETURN WITH ERROR Space.InsufficientSpace[allocInterval.count];       END;    END;        FixUpRegion: INTERNAL PROCEDURE [       region: VMAllocationRegions, interval: ObjAlloc.Interval,       allocFree: ObjAlloc.AllocFree] =       BEGIN       SELECT allocFree FROM          free =>             vmAllocationRegions[region].firstFree ¬ MIN[                vmAllocationRegions[region].firstFree, interval.first];          alloc =>	     IF interval.first=vmAllocationRegions[region].firstFree	     THEN	       BEGIN	       allAlloc:BOOLEAN;  firstFree:ObjAlloc.ItemIndex;	       [allSame:allAlloc, firstDifferent:firstFree] ¬	         KernelObjAlloc.AllSameState[		   pool: [allocPool: allocationArray, poolSize: virtualMemory.count],		   interval: [first:interval.first+interval.count,		     	      count:vmAllocationRegions[region].interval.count-				    (interval.first+interval.count)],		   desiredState:alloc]; 	       IF ~allAlloc -- don't update hint if firstFree undefined!	       THEN vmAllocationRegions[region].firstFree ¬ firstFree	       END;	     -- ELSE -- -- vmAllocationRegions[region].firstFree is still valid	  ENDCASE => Bug[impossibleSelectError];       END;       FixUpWithInterval: INTERNAL PROCEDURE [       interval: ObjAlloc.Interval, allocFree: ObjAlloc.AllocFree] =       BEGIN       FOR region: VMAllocationRegions IN VMAllocationRegions DO          p: LONG POINTER TO RegionInfo = @vmAllocationRegions[region];          regionIntervalPlusOne: ObjAlloc.ItemIndex =             p.interval.first+p.interval.count;	  SELECT TRUE FROM	    interval.first IN [p.interval.first..regionIntervalPlusOne)	      =>	        BEGIN		regionInterval: ObjAlloc.Interval;		  -- regionInterval will be the intersection of p­ and interval		regionInterval.first ¬ interval.first;		regionInterval.count ¬		  MIN[regionIntervalPlusOne-interval.first, interval.count];		FixUpRegion[region, regionInterval, allocFree];		END;	    interval.first+interval.count IN	      [p.interval.first..regionIntervalPlusOne)	      =>	        BEGIN		regionInterval: ObjAlloc.Interval;		regionInterval.first ¬		  p.interval.first;		regionInterval.count ¬		  interval.first+interval.count-regionInterval.first;		FixUpRegion[region, regionInterval, allocFree];		END;	    (interval.first < p.interval.first AND	     interval.first+interval.count > regionIntervalPlusOne)	      => FixUpRegion[region, p.interval, allocFree];	    ENDCASE;	  ENDLOOP;       END;         IsAllocated: PUBLIC PROCEDURE [interval:Space.Interval] RETURNS [BOOLEAN] =      BEGIN      allSame:BOOLEAN ¬         KernelObjAlloc.AllSameState[          pool:[allocPool: allocationArray, poolSize: virtualMemory.count],	  interval:[first: Space.PageFromLongPointer[interval.pointer],                    count: interval.count],	  desiredState:alloc].allSame;      RETURN [allSame];      END;	  SpaceForSpaceAllocation: PUBLIC PROCEDURE RETURNS [space: Space.Interval] =      BEGIN      RETURN[[        allocationArray,	VM.GetMapUnitAttributes[	  Space.PageFromLongPointer[allocationArray], NIL].mapUnit.count]];      END;  END.LOG27-Jul-82 10:23:30   AWL      	   Created file.25-Aug-82 12:13:32   AWL         Added VMMPrograms.SpaceForSpaceAllocation.  Deleted references to Utilities.23-Dec-82 19:50:49   AWL         PilotSpaceUsage => KernelSpaceUsage.  Initialize database using StoragePrograms.EnumerateUnusedVM. 4-Jan-83 14:31:37   AWL         AllocateInInterval failed to relocate its results back to VM relative.  Added code to correctly keep the region hints current.14-Jan-83 11:41:11   AWL      	The global "mds" was off by one.18-Mar-83 17:50:09   JXG       Rewritten alloc case of FixUpRegion to be correct (and faster!)   Changed interval to allocInterval in RETURN WITH ERROR in FindAlignedSpace21-Mar-83 11:32:25   JXG       Changed interval to allocInterval in MAX expr in Allocate 2-May-83 10:40:40   JXG       change AllocateInInterval to use new 'offset' parameter in KernelObjAlloc.FindFreeRange  2-May-83 10:53:57   JXG       add new INTERNAL PROC AllocateInterval and use in FindAlignedSpace for powerOf2 subcase 2-May-83 14:55:47   JXG       change sixtyFourK to 256 and call it Environment.maxPagesInMDS in FindAlignedSpace  3-May-83 15:39:51   EKN      Fixed Allocate so InvalidParameters is raised if base+count > within.count (instead of  greaterThanOrEqual) 4-May-83 14:46:32    JXG       Added new routine IsAllocated for new interface SpaceInternal 12-May-83 12:06:35    JXG       fixed initialization of firstFree in all vm regions   updated firstFree when client supplies base in Allocate28-Jun-83 15:28:24   EKN      fixed Deallocate to raise StillMapped error. 7-Jul-83 14:50:00   WDK        Made compatible with new VMMPrograms. Ditch VMExtras.17-Aug-84 11:58:47   EKN     Change SpaceInternal to SpecialSpaceExtras. 5-Aug-86 14:40:00   ET   MDS relief: POINTERs to global variables => LONG POINTERs to global variables.26-Jan-88 13:24:42   RSV   Fix AR 11499 in ML in Deallocate. 
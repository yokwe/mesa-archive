-- Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989 by Xerox Corporation. All rights reserved. -- ResMemMgr>VMDataMapImpl.mesa      16-May-89  8:18:09 TxH **    <<Implements the VM data base mapping operations VMData.CreateMapUnit, VMData.DeleteMapUnit, VM.FindMapUnit, VM.SupplyBackingStore, VM.GetMapUnitAttributes, and VMExtraExtras.GetMappedRunCountWARNINGS:Procedure Calls:   Since vmDataLock is required to process a frame fault, it is required that any code which holds this lock may only call coroutines and inline procedures. Furthermore, the coroutines must not have more than 14 words of arguments or results, as this would also cause the allocation of a local frame. If this rule were not followed, we could take a frame fault while holding the lock, and the frame fault process would deadlock waiting for the monitor lock. See also comments in ResMemMgr.config and StateVectorManagement.press.   There are procedures in this module which run inside vmDataLock.  They are implemented as coroutines because it is critical that we never take a frame fault while holding vmDataLock, since it is the VMData implementation itself that is invoked to satisfy a frame fault.  Thus these coroutines themselves must also never call procedures which are not INLINEs or coroutines.  Large argument and results records:   Since no frame allocations may occur when vmDataLock is held, the coroutines must not have more than 14 words of arguments or results, as this would also cause the allocation of a local frame. To determine if there are any such, make a code listing and look for occurrences of the "AF" instruction. There is also a hack to look for Allocs.If the above two rules were not followed, we could take a frame fault while holding the lock, and the frame fault process would deadlock waiting for the monitor lock. See also comments in ResMemMgr.config and StateVectorManagement.press.WAITs:   It is critical that vmDataLock NEVER be released from a coroutine (by WAITing); otherwise, more than one process could execute within the coroutine's single local frame.IMPLEMENTATION NOTES:Swappable Arguments: The procedures GetMapUnitAttributes, CreateMapUnit, and SupplyBackingStore have arguments which are pointers into swappable storage. For these arguments, the following approach is taken to avoid page faults: A monitor external procedure calls an entry procedure. The entry procedure waits as necessary until all of the swap units containing the argument storage are available, then looks at the map flags of the pages. If all pages are swapped in, the routine proceeds sucessfully to completion. If any pages are swapped out, the entry proc returns  parametersNotSwappedIn to the external proc, which itself touches each of the pages--causing them to be faulted in--then retries the operation.>>DIRECTORY  BackingStore USING [Data, Run, TransferProc],  DiskBackingStore USING [Data, PackFilePageNumber], --**  Environment USING [Base, PageCount, PageNumber, PageOffset, wordsPerPage],  FileLock USING [LockHandle], --**  Frame USING [GetReturnFrame, SetReturnFrame],  Inline USING [LongCOPY, LongCOPYReverse, LongDivMod, UDDivMod],  MStore USING [Deallocate],  PageMap USING [    ExchangeFlags, flagsVacant, GetState, IsVacant, RealPageNumber, SetMapState,    State],  Pinning USING [CreatePinHandle, Pin, PinHandle, Unpin],  PrincOps USING [ControlLink, Port],  Process USING [Priority],  ProcessOperations USING [Enter, Exit],  ProcessPrioritiesExtras USING [priorityPageFaultHigh],  ResidentHeap USING [FreeNode, MakeNode],  ResMemPerf USING [],  RuntimeInternal USING [Bug],  Space USING [    Access, Class, defaultSwapUnitSize, Error, Life, PageFromLongPointer,    SwapUnitOption, SwapUnitSize, SwapUnitType, Usage],   SpecialSpace USING [realMemorySize],  StoragePrograms USING [countVM],  VM USING [    AdjustReservedRealMemory, BackingStoreRuns, DoneWithStateVector,    GuardStateVector, Interval, nullInterval, PageCount, PageNumber],  VMData USING [    AllocateReservedMStoreInternal, MapParams, ParamsSwapStatus, vmDataLock],  VMDataInternal USING [    AdjustSwapUnitTablePointers, AnyUnavailable, Continuation,    countRunTablePagesMapped, countSwapUnitTablePagesMapped, CreateTransferProcID,    Find, GetMapUnitBounds, GetSwapUnitTablePointers, GetTransferProc,    --**IrregularSwapUnitData,**-- MakeRoomInSwapUnitTable,    --**maxIrregularSwapUnitSize,**-- nilPSwapUnit, nilPTransferProcDesc, NSwapUnits,    offsetFree, pageBuffer, pageBufferPtr, pageRunTable, pageSwapUnitTable,    --**PIrregularSwapUnitData,**-- ProcessSwapUnits, PRun, pRunMaxInRealMem, pRunMaxInVM,    pRunFirst--**--, pRunTop, PSwapUnit, pSwapUnitMaxInRealMem, pSwapUnitNextFree,    PTransferProcDesc, PUniformSwapUnitData, Run, runBase, RunBase, RunTable,    swapUnitBase, SwapUnitBase, swapUnitCheckedInOrUnmapped, SwapUnitProcessor,    SwapUnitState, TransferProcDesc, UniformSwapUnitData],  VMExtraExtras USING [],  VMExtras2 USING [], --**  Zone USING [Status];VMDataMapImpl: MONITOR LOCKS VMData.vmDataLock  IMPORTS    Frame, Inline, MStore, PageMap, Pinning, ProcessOperations, ResidentHeap,    RuntimeInternal, Space, SpecialSpace, StoragePrograms, VM, VMData,    VMDataInternal, DiskBackingStore --**--  EXPORTS ResMemPerf, VM, VMData, VMDataInternal, VMExtraExtras,    VMExtras2--**--  SHARES PageMap, VMData =  BEGIN  OPEN VMDataInternal;  -- PARAMETERS:    ratioRealMemorySizeToDefaultSwapUnitSize:    CARDINAL = 256;  << refer to SwapUnitSizeTuning.doc by Earsh Nandkeshwar located on [Louie:OSBU North:Xerox]<PilotProse>Internal>. >>   DEBUG: BOOLEAN ¬ FALSE;  --for initial debugging  -- VARIABLES:  defaultSwapUnitSize: Space.SwapUnitSize;  -- Free storage for TransferProcDescs  useMeFreeMeLock: MONITORLOCK;  --serializes access to useMeTransferProcDesc and freeMeTransferProcDesc ONLY  useMeTransferProcDesc: PUBLIC PTransferProcDesc ¬ nilPTransferProcDesc;  --for CreateMapUnit, q.v.  freeMeTransferProcDesc: PUBLIC PTransferProcDesc ¬ nilPTransferProcDesc;  --for DeleteMapUnit, q.v.  -- Misc:    supplyBackingStorePinHandle, relocateMapUnitPinHandle:Pinning.PinHandle;  rBase: RunBase = VMDataInternal.runBase;  -- name not "runbase" since matches export.  suBase: SwapUnitBase =  -- name not "swapUnitBase" since matches export.    VMDataInternal.swapUnitBase;  RunTable: TYPE = VMDataInternal.RunTable;  --for debugger  nullBackingData: --BackingStore.Data-- ARRAY [0..7) OF WORD = [    0, 0, 0, 0, 0, 0, 0];  SwapUnitSize: TYPE = Space.SwapUnitSize;  wordsPerPage: CARDINAL = Environment.wordsPerPage;  pHold: PRun ¬ pRunFirst; <<**>>    Bug: PROCEDURE [bugType: BugType] = INLINE {RuntimeInternal.Bug[bugType]};  SwapUnitTypeBug: PROCEDURE [bugType: BugType]    RETURNS [bugValue: Space.SwapUnitOption] = INLINE {    -- For use in contexts demanding a return value.    Bug[bugType]; RETURN --[garbage]-- };  BugType: TYPE = {    cantExpandSwapUnitTable, insufficientBackingStoreRuns,    insufficientSwapUnitData, noSuchCase,    notAvailableOrNotResidentOrNotUniformAccess, notStartOfMapUnit,    notValidMapUnit, nSwapUnitsOverflow, nullRun, outOfVMForRunTable,    overlapsExistingMapUnit, processSwapUnitsError,    unableToAllocateResidentHeapNode, unableToFreeResidentHeapNode,    unmappedPage, vacuousInterval, wasntCheckedOut,     notMapped--**--};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --INLINEs  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Guarding of state vectors is necessary for procedures exported to the VM interface.  GuardStateVector: PROCEDURE RETURNS [priorityPrev: Process.Priority] = INLINE {    RETURN VM.GuardStateVector[ProcessPrioritiesExtras.priorityPageFaultHigh]};  -- All client processes that wish to enter the VMData monitor may simply do so.  However, if within that monitor, the code will enter other monitors or do a WAIT, NOTIFY, BROADCAST, or Requeue (the normal case), it MUST have called this proc before it is allowed to do so. If it does, it must call UnguardStateVector before returning to the client  UnguardStateVector: PROCEDURE [priorityPrev: Process.Priority] = INLINE {    VM.DoneWithStateVector[priorityPrev]};  -- See description of GuardStateVector.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeVMDataMapImplA: PUBLIC --VMData.-- INTERNAL PROCEDURE =    -- called to get most of the VMData world going - all except    -- the bits which use Pinning    BEGIN     optimizedSwapUnitSize: Space.SwapUnitSize = 32;     optimizedThreshold: Environment.PageCount = 7168;     -- 7168'D = 2000'H(realMemSize) - 300'H(noMemInCaseOfDaybreak) - 100'H(mapTable24Bit)     --        = 7424(realMemSize-threshold) - 256(mapTable-24bit)                defaultSwapUnitSize ¬       IF SpecialSpace.realMemorySize < optimizedThreshold THEN         Space.SwapUnitSize[SpecialSpace.realMemorySize/ratioRealMemorySizeToDefaultSwapUnitSize]      ELSE optimizedSwapUnitSize;           -- Reserve memory for RelocateInternal to back pageBuffer:    VM.AdjustReservedRealMemory[count: 1, addSub: add];    [] ¬ InitializeCreateMapUnitInternal[];    [] ¬ InitializeDeleteMapUnitInternal[];    [] ¬ InitializeDeleteMapUnitPartiallyInternal[]; --**    [] ¬ InitializeGetParamAvailablity[];    [] ¬ InitializeSwappedInStatus[];    [] ¬ InitializeVerifyResidentAndUniformAccess[];    END;      InitializeVMDataMapImplB: PUBLIC --VMData.-- PROCEDURE =    -- called to get the less well used bits of VM going -     -- specifically, those bits which use Pinning    BEGIN    supplyBackingStorePinHandle ¬       Pinning.CreatePinHandle[LOOPHOLE[SupplyBackingStore], 1];    relocateMapUnitPinHandle ¬       Pinning.CreatePinHandle[LOOPHOLE[RelocateMapUnit], 1];    END;  SetDefaultSwapUnitSize: PUBLIC --ResMemPerf.-- PROCEDURE [    size: Space.SwapUnitSize] RETURNS [oldSize: Space.SwapUnitSize] =    BEGIN    -- To be completely correct, this procedure should be an ENTRY proc    -- and therefore also resident. To save resident code, we do not do    -- this. Setting defaultSwapUnitSize is an atomic operation anyway    -- because it is a single word.     oldSize ¬ defaultSwapUnitSize;    defaultSwapUnitSize ¬ size;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CreateMapUnit  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CreateMapUnit: PUBLIC --VMData. EXTERNAL-- PROCEDURE [    mapParams: POINTER TO READONLY VMData.MapParams]    RETURNS [paramsSwapStatus: VMData.ParamsSwapStatus] =    BEGIN    status: Zone.Status;    WHILE NOT ProcessOperations.Enter[@useMeFreeMeLock] DO ENDLOOP;    IF useMeTransferProcDesc = nilPTransferProcDesc THEN      BEGIN      [useMeTransferProcDesc, status] ¬ ResidentHeap.MakeNode[        SIZE[TransferProcDesc]];      IF status # okay THEN Bug[unableToAllocateResidentHeapNode];      END;    paramsSwapStatus ¬ CreateMapUnitEntry[mapParams];    ProcessOperations.Exit[@useMeFreeMeLock];    END;  --CreateMapUnit--  CreateMapUnitEntry: ENTRY PROCEDURE [    mapParams: POINTER TO READONLY VMData.MapParams]    RETURNS [paramsSwapStatus: VMData.ParamsSwapStatus] =    -- Other actual arguments: useMeTransferProcDesc (must be    --     non-nil at entry; this is because we can't call procedures.)    -- Other actual results: useMeTransferProcDesc (may be nil on return).    -- COULD BE INLINE after debugging finished (?!)    BEGIN    -- See note on "Swappable arguments" at head of module.    IF mapParams.interval.count = 0 THEN Bug[vacuousInterval];    DO  --until backingStoreRuns and swapUnits.sizes are available and swapped in--      SELECT GetParamAvailablity[mapParams.backingStoreRuns, mapParams.swapUnits]      FROM        allSwappedIn => EXIT;        busy => NULL;  -- (waits below)        someSwappedOut => RETURN[parametersNotSwappedIn];        ENDCASE => Bug[noSuchCase];      WAIT swapUnitCheckedInOrUnmapped;      ENDLOOP;    --ASSERT: All of backingStoreRuns is available and swapped in.    CreateMapUnitInternal[mapParams];    RETURN[ok];    END;  --CreateMapUnitEntry--  CreateMapUnitInternal: --INTERNAL-- PROCEDURE [    mapParams: POINTER TO READONLY VMData.MapParams];      --indirect control link to the port is assigned in InitializeCreateMapUnitInternal  -- NOTE: backingStoreRuns­ and swapUnits.sizes­ must be swapped in.  InitializeCreateMapUnitInternal: INTERNAL PROCEDURE[]    RETURNS --must match port args-- [] =    BEGIN        AwaitCreateMapUnitInternalRequest: --RESPONDING-- PORT[]      RETURNS [mapParams: POINTER TO READONLY VMData.MapParams];      --args/results match CreateMapUnitInternal, but reversed          --"arguments"    pm: POINTER TO READONLY VMData.MapParams;    -- Note: To avoid going indirect through pm to get to our parameters,    -- we could make local copies of them (at least the popular    -- ones). This produces the unintuitive result that the code    -- generated is LARGER, not smaller. This is due to our local    -- frame getting large enough so that the instruction set    -- can't reference the copies very well.    -- Local variables    pRun: PRun;  -- insertion point for new run.    pNextRunWithSwapUnits: PRun;  -- and whose pointer need to be adjusted    nRuns: CARDINAL;  --number of runs in map unit    pSwapUnit: PSwapUnit;  -- insertion point for new swap unit data.    CreateMapUnitInternal ¬ LOOPHOLE[LONG[@AwaitCreateMapUnitInternalRequest]];    LOOPHOLE[AwaitCreateMapUnitInternalRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];  --set my PORT call to return to my caller on call below    DO  --FOREVER --      --Return result; Await new request; Process it;      pm ¬ AwaitCreateMapUnitInternalRequest[].mapParams;      Frame.SetReturnFrame[        LOOPHOLE[AwaitCreateMapUnitInternalRequest, PrincOps.Port].dest.frame];      -- Figure out number of runs it takes to cover interval:      IF pm.backingStoreRuns = NIL THEN nRuns ¬ 1      ELSE        BEGIN        bsCount: VM.PageCount ¬ 0;        FOR nRuns IN [0..LENGTH[pm.backingStoreRuns]) DO          IF pm.backingStoreRuns[nRuns].count = 0 THEN Bug[nullRun];          bsCount ¬ bsCount + pm.backingStoreRuns[nRuns].count;          IF --UNTIL-- bsCount >= pm.interval.count THEN {            nRuns ¬ nRuns + 1; EXIT};          REPEAT FINISHED => Bug[insufficientBackingStoreRuns];          ENDLOOP;        END;      -- Find where first run goes in table:      BEGIN      found: BOOLEAN;      [found, pRun] ¬ Find[pm.interval.page, rBase, pRunTop]; --**      IF found OR pm.interval.page + pm.interval.count > rBase[pRun].interval.page        THEN Bug[overlapsExistingMapUnit];      END;      -- Find first run in table after insertion point which has swap units:      FOR pNextRunWithSwapUnits ¬ pRun, pNextRunWithSwapUnits + SIZE[Run] WHILE        pNextRunWithSwapUnits < pRunTop        AND rBase[pNextRunWithSwapUnits].swapUnits = unitary DO ENDLOOP;      -- pNextRunWithSwapUnits now points either to top entry or to the first one      -- following the run insertion point which has a corresponding swap unit entry.      -- It is used to insert swap unit data and to adjust pointers in the run table.      -- Find where swap unit data is going to go:      IF pRun >= pRunTop THEN pSwapUnit ¬ pSwapUnitNextFree      ELSE        BEGIN        pSwapUnit ¬ GetSwapUnitTablePointers[pRun, pRunTop].pSwapUnitFirst;        IF pSwapUnit = nilPSwapUnit THEN pSwapUnit ¬ pSwapUnitNextFree;        END;      -- We now have:      --   pSwapUnit: insertion point for new swap unit data.      --   pNextRunWithSwapUnits: first Run whose swap unit pointer has to be adjusted.      --   pRun: insertion point for new Run      -- Allocate the necessary run table space:      BEGIN      SIZERuns: CARDINAL = nRuns*SIZE[Run];      SELECT pRunTop + offsetFree + SIZERuns FROM        <= pRunMaxInRealMem => NULL;  -- no allocation needed        <= pRunMaxInVM =>  --within VM but real memory allocation needed          BEGIN          pagesNeeded: CARDINAL;          pagesNeeded ¬            (pRunTop + offsetFree + SIZERuns - pRunMaxInRealMem +	     wordsPerPage-1)/wordsPerPage;          VMData.AllocateReservedMStoreInternal[interval: [	    page: pageRunTable + countRunTablePagesMapped, count: pagesNeeded],	    resident: TRUE];          countRunTablePagesMapped ¬ countRunTablePagesMapped + pagesNeeded;          pRunMaxInRealMem ¬            LOOPHOLE[CARDINAL[countRunTablePagesMapped]*wordsPerPage, PRun];          END;        ENDCASE => Bug[outOfVMForRunTable];      -- Open up run table at insertion point:      Inline.LongCOPYReverse[        from: @rBase[pRun], to: @rBase[pRun + SIZERuns],        nwords: pRunTop + offsetFree - pRun];      pRunTop ¬ pRunTop + SIZERuns;      END;      pNextRunWithSwapUnits ¬ pNextRunWithSwapUnits + nRuns*SIZE[Run];      -- Fill space with harmless dummy entries in case need for more real      -- memory  forces another search through the table before we can finish      -- incorporating new swap unit data.      -- And do this starting at the end with the highest page and decreasing by      -- one each so as to maintain the invariant of ordered, increasing entries.      BEGIN      page: Environment.PageNumber ¬ pm.interval.page + pm.interval.count - 1;      swapUnitState: SwapUnitState ¬  -- bogus "leave me alone" state        [busy, [pm.access, pm.initialLife, resident]];      FOR p: PRun ¬ pRun + (nRuns-1)*SIZE[Run], p - SIZE[Run] UNTIL p < pRun DO        rBase[p].interval ¬ [page: page, count: 1];        rBase[p].startOfMapUnit ¬ TRUE;        rBase[p].endOfMapUnit ¬ TRUE;        rBase[p].swapUnitData ¬ unitary[swapUnitState];	-- other fields don't matter        page ¬ page - 1;	ENDLOOP;      END;      --Insert runs and swap units into tables:      BEGIN      swapUnitState: SwapUnitState ¬  -- state of all new swap units.        [available, [pm.access, pm.initialLife, swappable]];      pageRun: VM.PageNumber ¬ pm.interval.page;  -- start page of current run.      swapUnitPagesCarriedOver:  -- fragment of swap unit carried over from previous run.        CARDINAL ¬ 0;      clientSwapUnitIndex: CARDINAL ¬ 0;  -- the first client s.u. which is entirely unprocessed.      SIZESwapUnitAdjustment:  -- Total adjustment to s.u. pointers of runs following interval.        CARDINAL ¬ 0;      SIZESwapUnitAdjustmentSoFar: CARDINAL ¬ 0;  -- Total of interim adjustments.      countRun: VM.PageCount;  -- count of the current run.      SIZESwapUnitData: CARDINAL;  -- SIZE of swap unit table data for current run.      FOR nRun: CARDINAL IN [0..nRuns) DO  --for each run        countRun ¬          IF nRuns = 1 THEN pm.interval.count          ELSE MIN[            pm.interval.page + pm.interval.count - pageRun, pm.backingStoreRuns[              nRun].count];        -- Allocate and fill in swap unit data for current run:	-- **           IF countRun <= defaultSwapUnitSize THEN {	   	<<unitary>>  SIZESwapUnitData ¬ 0;  -- all swap unit data is stored in run table entry             rBase[pRun].swapUnitData ¬ unitary[swapUnitState]}	    <<uniform>>  ELSE {            firstSwapUnitSize: Space.SwapUnitSize;            lastSwapUnitSize: Space.SwapUnitSize;            uniformSUData: LONG POINTER TO UniformSwapUnitData;            runSwapUnits: CARDINAL;  -- number of swap units to be created for this run.	    -- **       swapUnitSize: Space.SwapUnitSize ¬-- **       IF swapUnitType.size = Space.defaultSwapUnitSize THEN-- **       defaultSwapUnitSize ELSE swapUnitType.size;            --** use directly the defaultSwapUnitSize for swapUnitSize             -- Find size of first swap unit in run:            IF swapUnitPagesCarriedOver = 0 THEN              BEGIN  -- run starts new swap unit.--**--        firstSwapUnitSize ¬ SwapUnitSize[MIN[countRun, defaultSwapUnitSize--**--]];--**--        swapUnitPagesCarriedOver ¬ defaultSwapUnitSize - firstSwapUnitSize;              END            ELSE              BEGIN  -- run starts with fragment of previous swap unit.              firstSwapUnitSize ¬  --                -- (swapUnitPagesCarriedOver must be smaller than swap unit size)                SwapUnitSize[MIN[countRun, swapUnitPagesCarriedOver]];              swapUnitPagesCarriedOver ¬                swapUnitPagesCarriedOver - firstSwapUnitSize;              END;            -- If swapUnitPagesCarriedOver is nonzero here, then there is only one            -- swap unit and the run is smaller than the swap unit size.            -- Figure out number of swap units in run:            BEGIN            longRunSwapUnits: LONG CARDINAL = Inline.UDDivMod[--**--        num: countRun - firstSwapUnitSize, den: defaultSwapUnitSize].quotient;            IF longRunSwapUnits > LAST[NSwapUnits] - 2 THEN  -- (note two increments below)              Bug[nSwapUnitsOverflow];            runSwapUnits ¬ NSwapUnits[longRunSwapUnits];            END;            lastSwapUnitSize ¬ Inline.LongDivMod[--**--        num: countRun - firstSwapUnitSize, den: defaultSwapUnitSize].remainder;            runSwapUnits ¬ runSwapUnits + 1;  -- count first swap unit also            IF lastSwapUnitSize > 0 THEN {              runSwapUnits ¬ runSwapUnits + 1;  -- count final swap unit fragment--**--        swapUnitPagesCarriedOver ¬ defaultSwapUnitSize - lastSwapUnitSize};            SIZESwapUnitData ¬ SIZE[UniformSwapUnitData [runSwapUnits]];            IF ~MakeRoomInSwapUnitTable[pSwapUnit, SIZESwapUnitData, FALSE] THEN	      BEGIN	      -- first update pointers so table will be correct for allocate	      AdjustSwapUnitTablePointers[pNextRunWithSwapUnits, pRunTop,	        SIZESwapUnitAdjustment - SIZESwapUnitAdjustmentSoFar];	      SIZESwapUnitAdjustmentSoFar ¬ SIZESwapUnitAdjustment;	      IF ~MakeRoomInSwapUnitTable[pSwapUnit, SIZESwapUnitData, TRUE] THEN	        Bug[cantExpandSwapUnitTable];	      END;            -- Now safe for run table to point to entry:            rBase[pRun].swapUnitData ¬ uniform[              LOOPHOLE[pSwapUnit, PUniformSwapUnitData]];            -- now stuff data into table            uniformSUData ¬ @suBase[LOOPHOLE[pSwapUnit, PUniformSwapUnitData]];            uniformSUData.firstSwapUnitSize ¬ firstSwapUnitSize;--**--      uniformSUData.swapUnitSize ¬ defaultSwapUnitSize;            LOOPHOLE[@uniformSUData.state, LONG POINTER TO NSwapUnits]­ ¬  --              runSwapUnits;  -- set sequence tag.            FOR j: CARDINAL IN [0..runSwapUnits) DO              uniformSUData.state[j] ¬ swapUnitState;	    ENDLOOP}; --uniform case<<**        irregular =>            BEGIN            irregularSUData: LONG POINTER TO IrregularSwapUnitData;            irregularSwapUnitSize: Space.SwapUnitSize;            runSwapUnits: CARDINAL;  -- number of swap units to be created for this run.            -- Figure out how many swap units for this run:            IF countRun <= swapUnitPagesCarriedOver THEN  --              -- The only stuff in this run is a fragment              -- of a swap unit left over from previous run              runSwapUnits ¬                (SwapUnitSize[countRun] + maxIrregularSwapUnitSize -                   1)/maxIrregularSwapUnitSize            ELSE              BEGIN  -- more than just an initial fragment of a swap unit              totalSwapUnitPages: CARDINAL ¬ swapUnitPagesCarriedOver;              runSwapUnits ¬                (swapUnitPagesCarriedOver + maxIrregularSwapUnitSize -                   1)/maxIrregularSwapUnitSize;              FOR index: CARDINAL IN                [clientSwapUnitIndex..LENGTH[swapUnitType.sizes]) DO                --UNTIL we've found enough swap units to cover entire run                totalSwapUnitPages ¬                  totalSwapUnitPages + swapUnitType.sizes[index];                runSwapUnits ¬                  runSwapUnits +                    (swapUnitType.sizes[index] + maxIrregularSwapUnitSize -                       1)/maxIrregularSwapUnitSize;                IF totalSwapUnitPages >= countRun THEN EXIT;                REPEAT FINISHED => Bug[insufficientSwapUnitData];                ENDLOOP;              END;  -- more than a single initial fragment--            SIZESwapUnitData ¬ SIZE[IrregularSwapUnitData [runSwapUnits]];            IF ~MakeRoomInSwapUnitTable[pSwapUnit, SIZESwapUnitData, FALSE] THEN	      BEGIN	      -- first update pointers so table will be correct for allocate	      AdjustSwapUnitTablePointers[pNextRunWithSwapUnits, pRunTop,	        SIZESwapUnitAdjustment - SIZESwapUnitAdjustmentSoFar];	      SIZESwapUnitAdjustmentSoFar ¬ SIZESwapUnitAdjustment;	      IF ~MakeRoomInSwapUnitTable[pSwapUnit, SIZESwapUnitData, TRUE] THEN	        Bug[cantExpandSwapUnitTable];	      END;            -- Now safe for run table to point to entry:            rBase[pRun].swapUnitData ¬ irregular[              LOOPHOLE[pSwapUnit, PIrregularSwapUnitData]];            -- Fill in swap unit data:            irregularSUData ¬ @suBase[              LOOPHOLE[pSwapUnit, PIrregularSwapUnitData]];            LOOPHOLE[@irregularSUData.sizeAndState, LONG POINTER TO NSwapUnits]­ ¬              runSwapUnits;  -- set sequence tag.            BEGIN  -- scope of countRunRemaining--            countRunRemaining: VM.PageCount ¬ countRun;            FOR ourSwapUnitIndex: CARDINAL IN [0..runSwapUnits) DO              IF swapUnitPagesCarriedOver = 0 THEN                BEGIN  --initial or entire portion of next client swap unit                irregularSwapUnitSize ¬ SwapUnitSize[                  MIN[                  countRunRemaining, maxIrregularSwapUnitSize, swapUnitType.sizes[                  clientSwapUnitIndex]]];                swapUnitPagesCarriedOver ¬  -- (may be zero)                  swapUnitType.sizes[clientSwapUnitIndex] - irregularSwapUnitSize;                clientSwapUnitIndex ¬ clientSwapUnitIndex + 1;                END              ELSE                BEGIN  --trailing fragment of previous client swap unit                irregularSwapUnitSize ¬ SwapUnitSize[                  MIN[                  countRunRemaining, maxIrregularSwapUnitSize,                  swapUnitPagesCarriedOver]];                swapUnitPagesCarriedOver ¬                  swapUnitPagesCarriedOver - irregularSwapUnitSize;                END;              irregularSUData[ourSwapUnitIndex] ¬ [                irregularSwapUnitSize, swapUnitState];              countRunRemaining ¬ countRunRemaining - irregularSwapUnitSize;              ENDLOOP;            END;  --scope of countRunRemaining--            END;  --irregular case          ENDCASE => Bug[noSuchCase];** >>        -- Note: Can't use a constructor here since Mesa        --    can't use computed variants in a constructor.        rBase[pRun].interval ¬ [page: pageRun, count: countRun];        rBase[pRun].usage ¬ pm.usage;        rBase[pRun].class ¬ pm.class;        rBase[pRun].transferProcID ¬ CreateTransferProcID[pm.transferProc];        rBase[pRun].startOfMapUnit ¬ (nRun = 0);        rBase[pRun].endOfMapUnit ¬ (nRun = (nRuns - 1));        rBase[pRun].backingData ¬          IF pm.backingStoreRuns = NIL THEN LOOPHOLE[nullBackingData]          ELSE pm.backingStoreRuns[nRun].data;        -- Note: Variant part "swapUnitData" assigned previously.        --update pointers into the tables for the next time around the insertion loop        pRun ¬ pRun + SIZE[Run];        pSwapUnit ¬ pSwapUnit + SIZESwapUnitData;        SIZESwapUnitAdjustment ¬ SIZESwapUnitAdjustment + SIZESwapUnitData;        pageRun ¬ pageRun + countRun;        ENDLOOP;  -- each run      AdjustSwapUnitTablePointers[pNextRunWithSwapUnits, pRunTop,        SIZESwapUnitAdjustment - SIZESwapUnitAdjustmentSoFar];      END;  --Inserting runs and swap units into tables--      ENDLOOP;  --DO FOREVER--    END;  --CreateMapUnitInternal  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- DeleteMapUnit  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Note that freeing the real memory behind the map unit happens at a higher level  -- Implementation note:  DeleteMapUnit needs to be a facade to the ENTRY procedure DeleteMapUnitEntry (which invokes DeleteMapUnitInternal to do the real work), in order that heap nodes that have been deleted from the transferProc table can be deallocated from outside the monitor since this requires a procedure call.  DeleteMapUnit: PUBLIC --VMData.-- PROCEDURE [page: Environment.PageNumber]    RETURNS [notMapped: BOOLEAN] =    BEGIN    status: Zone.Status;    WHILE NOT ProcessOperations.Enter[@useMeFreeMeLock] DO ENDLOOP;    [notMapped] ¬ DeleteMapUnitEntry[page];    IF freeMeTransferProcDesc # nilPTransferProcDesc THEN      BEGIN      IF useMeTransferProcDesc = nilPTransferProcDesc  --        THEN useMeTransferProcDesc ¬ freeMeTransferProcDesc  --save it for next time one is needed      ELSE        BEGIN        status ¬ ResidentHeap.FreeNode[freeMeTransferProcDesc];        IF status # okay THEN Bug[unableToFreeResidentHeapNode];        END;      freeMeTransferProcDesc ¬ nilPTransferProcDesc;      END;    ProcessOperations.Exit[@useMeFreeMeLock];    END;  --DeleteMapUnit  DeleteMapUnitEntry: ENTRY PROCEDURE [page: Environment.PageNumber]    RETURNS [notMapped: BOOLEAN] = INLINE    BEGIN    BROADCAST swapUnitCheckedInOrUnmapped;  -- (probably unmapped.)    RETURN DeleteMapUnitInternal[page];    END;  --DeleteMapUnitEntry  DeleteMapUnitInternal: --INTERNAL-- PROCEDURE [page: Environment.PageNumber]    RETURNS [notMapped: BOOLEAN];  -- indirect control link to the port is set in InitializeDeleteMapUnitInternal  InitializeDeleteMapUnitInternal: INTERNAL PROCEDURE    RETURNS [notMapped: BOOLEAN] =    BEGIN        AwaitDeleteMapUnitInternalRequest: --RESPONDING-- PORT [  --      -- args/results match DeleteMapUnitInternal, but reversed      notMapped: BOOLEAN] RETURNS [page: Environment.PageNumber];          --"arguments"    page: Environment.PageNumber;    --local variables    pRun: PRun;    pRunFirstInMapUnit: PRun;    pRunLastInMapUnit: PRun;    SIZERuns: CARDINAL;    pSwapUnitFirstInMapUnit: PSwapUnit;    pSwapUnitFollowingMapUnit: PSwapUnit;    SIZESwapUnitData: CARDINAL;    nFreedPages: CARDINAL;  --number of pages of real memory freed by table deletion    found: BOOLEAN;    DeleteMapUnitInternal ¬ LOOPHOLE[LONG[@AwaitDeleteMapUnitInternalRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitDeleteMapUnitInternalRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER --      --Return result; Await new request; Process it;      [page] ¬ AwaitDeleteMapUnitInternalRequest[notMapped];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitDeleteMapUnitInternalRequest, PrincOps.Port].dest.frame];      [found, pRun] ¬ Find[page, rBase, pRunTop]; --**      notMapped ¬ NOT found;      IF notMapped THEN NULL      ELSE        BEGIN  --mapped--        [pRunFirstInMapUnit, pRunLastInMapUnit] ¬ GetMapUnitBounds[pRun];        IF DEBUG THEN          BEGIN  --check that really checked out--          VerifyCheckedOut: SwapUnitProcessor = {            --[pageSwapUnit, pageAfterSwapUnit, state] RETURNS [newState, continuation]            -- A real proc since just a bear trap.            IF state.availability # busy THEN Bug[wasntCheckedOut];            RETURN[newState: state, continuation: continue]};          [] ¬ ProcessSwapUnits[            [            page: rBase[pRunFirstInMapUnit].interval.page,            count:            rBase[pRunLastInMapUnit].interval.page + rBase[              pRunLastInMapUnit].interval.count - rBase[              pRunFirstInMapUnit].interval.page], errorIfUnmapped, spanRuns,            VerifyCheckedOut];          END;  --check that really checked out--        SIZERuns ¬ pRunLastInMapUnit - pRunFirstInMapUnit + SIZE[Run];        [] ¬ GetTransferProc[rBase[pRunFirstInMapUnit].transferProcID, deleteID];        [pSwapUnitFirstInMapUnit, pSwapUnitFollowingMapUnit] ¬          GetSwapUnitTablePointers[          pRunFirstInMapUnit, pRunLastInMapUnit + SIZE[Run]];        -- Compact run table:        Inline.LongCOPY[          from: @rBase[pRunFirstInMapUnit] + SIZERuns,          to: @rBase[pRunFirstInMapUnit],          nwords: pRunTop + offsetFree - (pRunLastInMapUnit + SIZE[Run])];        pRunTop ¬ pRunTop - SIZERuns;  --reduce by size of run table deletion        nFreedPages ¬ (pRunMaxInRealMem - (pRunTop + offsetFree))/wordsPerPage;        IF nFreedPages > 0 THEN  --update globals and deallocate real memory at end of table           BEGIN          pRunMaxInRealMem ¬ pRunMaxInRealMem - nFreedPages*wordsPerPage;          countRunTablePagesMapped ¬ countRunTablePagesMapped - nFreedPages;          MStore.Deallocate[            interval: [            page: pageRunTable + countRunTablePagesMapped, count: nFreedPages],            vow: notPromised];          END;        -- Perform swap unit table deletion and compaction,        -- and adjust pointers in run table into swap unit table:        SIZESwapUnitData ¬ pSwapUnitFollowingMapUnit - pSwapUnitFirstInMapUnit;        IF SIZESwapUnitData > 0 THEN  --compact swap unit table          BEGIN          Inline.LongCOPY[            from: @suBase[pSwapUnitFirstInMapUnit] + SIZESwapUnitData,            to: @suBase[pSwapUnitFirstInMapUnit],            nwords: pSwapUnitNextFree - pSwapUnitFollowingMapUnit];          pSwapUnitNextFree ¬ pSwapUnitNextFree - SIZESwapUnitData;  --reduce by size of deletion          --now update globals and return any unneeded real memory          nFreedPages ¬ (pSwapUnitMaxInRealMem - pSwapUnitNextFree)/wordsPerPage;          IF nFreedPages > 0 THEN  --deallocate real memory at end of table            BEGIN            pSwapUnitMaxInRealMem ¬              pSwapUnitMaxInRealMem - nFreedPages*wordsPerPage;            countSwapUnitTablePagesMapped ¬              countSwapUnitTablePagesMapped - nFreedPages;            MStore.Deallocate[              interval: [              page: pageSwapUnitTable + countSwapUnitTablePagesMapped,              count: nFreedPages], vow: notPromised];            END;  --nFreedPages > 0--          AdjustSwapUnitTablePointers[            pRunFirstInMapUnit, pRunTop, -SIZESwapUnitData];          END;  --SIZESwapUnitData > 0--        END;  --mapped--      ENDLOOP;  --FOREVER--    END;  --DeleteMapUnitEntry-- =============================================================     DeleteMapUnitPartially: PUBLIC --VMExtras2.-- ENTRY PROCEDURE-- =============================================================     [vm: VM.Interval] =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    BEGIN    BROADCAST swapUnitCheckedInOrUnmapped;    DeleteMapUnitPartiallyInternal[vm];    END;  --DeleteMapUnitPartially-- =============================================================--  DeleteMapUnitPartiallyInternal -- =============================================================  DeleteMapUnitPartiallyInternal: --INTERNAL-- PROCEDURE [vm: VM.Interval];-- =============================================================     InitializeDeleteMapUnitPartiallyInternal: --INTERNAL-- PROCEDURE -- =============================================================    -- RETURNS[xx]-- =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BEGIN<<*>>     AwaitDeleteMapUnitPartiallyInternalRequest: PORT --[xx]--    RETURNS [vm: VM.Interval];      -- * "arguments"  vm: VM.Interval;    -- * local variables  --~~  pRunProcessed: PRun;  found: BOOLEAN;  done: BOOLEAN;  thisIsUnitary: BOOLEAN;  -- TRUE(unitary), FALSE(uniform)  thisIsOnlyShrinked: BOOLEAN; -- TRUE(shrinked), FALSE(deleted)  --~~      nFreedPages: CARDINAL;  --~~      pFirstSU, pFollowingSU: PSwapUnit;  pToInSU: LONG POINTER;  SIZESwapUnitData: CARDINAL;<<* Note:    1. there is no irregular maps in Pilot 15.x, that is, all su data are put in with uniform style.      2. one map unit can include uniforms and unitaries at the same time.      3. shrinking does not change the remaining run type of the map unit, even if the interval mapped in uniform-type is shrinked to the size smaller than the deralutSwapunitSize. >>            -- * initialize  DeleteMapUnitPartiallyInternal ¬    LOOPHOLE[LONG[@AwaitDeleteMapUnitPartiallyInternalRequest]];  LOOPHOLE[AwaitDeleteMapUnitPartiallyInternalRequest, PrincOps.Port].dest ¬    PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];      DO  --FOREVER --    [vm] ¬ AwaitDeleteMapUnitPartiallyInternalRequest[];    Frame.SetReturnFrame[  -- for debugger.      LOOPHOLE[AwaitDeleteMapUnitPartiallyInternalRequest,	PrincOps.Port].dest.frame];    IF vm.count = 0 THEN LOOP;        -- * The given vm interval to be deleted must consecutively exist on the mapUnit end.        done ¬ FALSE;    UNTIL done DO --wholeInterval--          [found, pRunProcessed] ¬ Find[(vm.page + vm.count - 1), rBase, pRunTop];      IF NOT found THEN Bug[notMapped];      thisIsUnitary ¬ (rBase[pRunProcessed].swapUnits = unitary);      thisIsOnlyShrinked ¬ (vm.page > rBase[pRunProcessed].interval.page); -- *       IF thisIsUnitary THEN { --unitary--	IF thisIsOnlyShrinked THEN {--unitary.onlyShrinked--	  rBase[pRunProcessed].interval.count ¬ 	    vm.page - rBase[pRunProcessed].interval.page;       -- IF rBase[pRunProcessed].interval.page >= vm.page THEN ERROR;	  LOOPHOLE[rBase[pRunProcessed], unitary VMDataInternal.Run].	    swapUnitState.availability ¬ available; -- * do checking-in	  done ¬ TRUE;  	 } --unitary.onlyShrinked--       } --unitary--             ELSE { --uniform--            -- * read pFirstSU and pFollowingSU values before the nSwapUnits field for pRunProcessed gets modified.	[pFirstSU, pFollowingSU] ¬ 	  GetSwapUnitTablePointers[pRunProcessed, pRunProcessed + SIZE[Run]];	IF NOT thisIsOnlyShrinked THEN { --uniform.SU.deleted--	  pToInSU ¬ @suBase[pFirstSU]; 	  SIZESwapUnitData ¬ pFollowingSU - pFirstSU} --uniform.SU.deleted--	  	ELSE { --uniform.onlyShrinked--		  d: LONG POINTER TO UniformSwapUnitData;	  oldSUs, oldSUWords, newSUWords: CARDINAL;	  newCount: VM.PageCount;	  	  newCount ¬ vm.page - rBase[pRunProcessed].interval.page;       -- IF rBase[pRunProcessed].interval.page >= vm.page THEN ERROR;-- * pFollowingSU > pFirstSU	  d ¬ LOOPHOLE[@suBase[pFirstSU]];	  oldSUs ¬ LOOPHOLE[@d.state, LONG POINTER TO NSwapUnits]­;	  oldSUWords ¬ (oldSUs + 3)/4;	   	  IF newCount <= d.firstSwapUnitSize THEN { --only one su--	    d.firstSwapUnitSize ¬ CARDINAL[newCount];	    LOOPHOLE[@d.state, LONG POINTER TO NSwapUnits]­ ¬ 1;	    newSUWords ¬ 1} --only one su--	  ELSE { -- >=2 SUs--	    newSUs: CARDINAL ¬ CARDINAL[((newCount - d.firstSwapUnitSize) +	      (d.swapUnitSize - 1))/d.swapUnitSize + 1];	    LOOPHOLE[@d.state, LONG POINTER TO NSwapUnits]­ ¬ newSUs;	    newSUWords ¬ (newSUs + 3)/4;	    };-- >=2 SUs--	  	  rBase[pRunProcessed].interval.count ¬ newCount;	-- * the boundary swap unit data can be busy, so check it in.	  	  d.state[(d.nSwapUnits - 1)].availability ¬ available;-- * now calculate pToInSU and SIZESwapUnitData.        -- IF oldSUWords < newSUWords THEN ERROR;	  SIZESwapUnitData ¬ oldSUWords - newSUWords;	  pToInSU ¬ @suBase[pFollowingSU] - SIZESwapUnitData;	  done ¬ TRUE}; --uniform.uniform.onlyShrinked--	  	}; --uniform---- * compact run table.      IF NOT thisIsOnlyShrinked THEN { --delete run entries--	IF (vm.count ¬ vm.count - rBase[pRunProcessed].interval.count)	  = 0 THEN done ¬ TRUE;	Inline.LongCOPY[	  from: @rBase[pRunProcessed] + SIZE[Run],	  to: @rBase[pRunProcessed],	  nwords: pRunTop + offsetFree - (pRunProcessed + SIZE[Run])];	pRunTop ¬ pRunTop - SIZE[Run];	nFreedPages ¬ (pRunMaxInRealMem - (pRunTop + offsetFree))/wordsPerPage;	rBase[pRunProcessed-SIZE[Run]].endOfMapUnit ¬ TRUE; --* Don't forget!	IF nFreedPages > 0 THEN { --nFreedPages > 0--	  pRunMaxInRealMem ¬ pRunMaxInRealMem - nFreedPages*wordsPerPage;	  countRunTablePagesMapped ¬ countRunTablePagesMapped - nFreedPages;	  MStore.Deallocate[	    interval: [	      page: pageRunTable + countRunTablePagesMapped,	      count: nFreedPages],	    vow: notPromised];	  }; --nFreedPages > 0--      }; --delete run entries---- * Perform swap unit table deletion and compaction, and adjust pointers in run table into swap unit table.      	IF (NOT thisIsUnitary) AND 	     SIZESwapUnitData > 0 THEN { --SIZESwapUnitData > 0--	  Inline.LongCOPY[	    from: pToInSU + SIZESwapUnitData,	    to: pToInSU,	    nwords: pSwapUnitNextFree - pFollowingSU];	  pSwapUnitNextFree ¬ pSwapUnitNextFree - SIZESwapUnitData;	  nFreedPages ¬ (	    pSwapUnitMaxInRealMem - pSwapUnitNextFree)/wordsPerPage; 	  IF nFreedPages > 0 THEN { --nFreedPages > 0--	    pSwapUnitMaxInRealMem ¬	      pSwapUnitMaxInRealMem - nFreedPages*wordsPerPage;	    countSwapUnitTablePagesMapped ¬	      countSwapUnitTablePagesMapped - nFreedPages;	    MStore.Deallocate[	      interval: [	        page: pageSwapUnitTable + countSwapUnitTablePagesMapped,	        count: nFreedPages], vow: notPromised]}; --nFreedPages > 0--	  AdjustSwapUnitTablePointers[	    IF thisIsOnlyShrinked THEN pRunProcessed + SIZE[Run]	    ELSE pRunProcessed, pRunTop, -SIZESwapUnitData];	  }; --SIZESwapUnitData > 0--	          ENDLOOP;  --wholeInterval--      ENDLOOP;  --FOREVER--    END;  --InitializeDeleteMapUnitPartiallyInternal    -- =============================================================    GetVMIntervalWithLockHandle: PUBLIC --VMExtras2.-- PROCEDURE-- =============================================================     [node: FileLock.LockHandle] RETURNS [vm: VM.Interval] =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    BEGIN    priorityPrev: Process.Priority;        GetVMIntervalWithLockHandleEntry: ENTRY PROCEDURE =    BEGIN-- * from {FileLockImpl.mesa}        LockNode: TYPE = LONG POINTER TO MACHINE DEPENDENT RECORD [      fID      (0): LONG CARDINAL,      vIndex   (2): CARDINAL,      firstPage(3): LONG CARDINAL,      mCount   (5): LONG CARDINAL,      type     (7): CARDINAL,      mapUnit  (8): LONG CARDINAL,      next    (10): LONG POINTER];-- *           d: LONG POINTER TO TRUE DiskBackingStore.Data;    p, pEntry: PRun;        p ¬ pEntry ¬ IF pHold >= pRunTop THEN pRunFirst ELSE pHold;    DO      d ¬ LOOPHOLE[@rBase[p].backingData];      IF d.lock = node AND  -- * assume LockHandle # File.ID	 DiskBackingStore.PackFilePageNumber[	   low: d.filePageLow, high: d.filePageHigh] = 	     LOOPHOLE[node, LockNode].firstPage THEN EXIT;      IF (p ¬ p + SIZE[Run]) >= pRunTop THEN p ¬ pRunFirst;      -- * in this case, returns the null interval instead of raising Bug[notFoundFromLockHandle] for debugger use.      IF p = pEntry THEN {vm ¬ VM.nullInterval; RETURN};     ENDLOOP;        vm ¬ rBase[p].interval;    pHold ¬ IF (p ¬ p - SIZE[Run]) = FIRST[PRun] THEN pRunFirst ELSE p;    END; --GetVMIntervalWithLockHandleEntry--        -- * main line    priorityPrev ¬ GuardStateVector[];    GetVMIntervalWithLockHandleEntry[];         UnguardStateVector[priorityPrev];    END;  --GetVMIntervalWithLockHandle--      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- FindMapUnit  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  FindMapUnit: PUBLIC --VM. EXTERNAL-- PROCEDURE [page: Environment.PageNumber]    RETURNS [mapUnit: VM.Interval] =    BEGIN        FindMapUnitEntry: ENTRY PROCEDURE [page: Environment.PageNumber]      RETURNS [mapUnit: VM.Interval] = INLINE      BEGIN      p: PRun ¬ Find[page, rBase, pRunTop].pRun; --**            IF p=pRunTop THEN RETURN[VM.nullInterval]                -- no map unit starts at or after page.      ELSE        BEGIN        pStart, pEnd: PRun;        [pStart, pEnd] ¬ VMDataInternal.GetMapUnitBounds[p];        RETURN[mapUnit: [            page: rBase[pStart].interval.page,            count: rBase[pEnd].interval.page + rBase[pEnd].interval.count - 	      rBase[pStart].interval.page]];        END;      END;  --FindMapUnitEntry--    priorityPrev: Process.Priority;    IF page >= StoragePrograms.countVM THEN      ERROR Space.Error[pointerPastEndOfMemory];    priorityPrev ¬ GuardStateVector[];    mapUnit ¬ FindMapUnitEntry[page];    UnguardStateVector[priorityPrev];    END;  --FindMapUnit--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- GetMapUnitAttributes  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetMapUnitAttributes: PUBLIC --VM. EXTERNAL-- PROCEDURE [    page: Environment.PageNumber, backingStoreRunsStorage: VM.BackingStoreRuns]    RETURNS [      mapUnit: VM.Interval, transferProc: BackingStore.TransferProc,      backingStoreRuns: VM.BackingStoreRuns, usage: Space.Usage,      class: Space.Class, swapUnits: Space.SwapUnitOption] =    BEGIN    -- See note on "Swappable arguments" at head of module.    GetMapUnitAttributesEntry: ENTRY PROCEDURE      RETURNS [paramsSwapStatus: VMData.ParamsSwapStatus] =      -- Other actual arguments: all args of parent frame.      -- Other actual results: all results of parent frame.      BEGIN      -- See note on "Swappable arguments" at head of module.      pRun: PRun;      pRunFirstInMapUnit: PRun;      pRunLastInMapUnit: PRun;      found: BOOLEAN;      backingStoreRuns ¬ backingStoreRunsStorage;  -- (length may be shortened later)      DO  --until backingStoreRunsStorage is available and swapped in--        [found, pRun] ¬ Find[page, rBase, pRunTop];  -- ** do each loop trip since lock was released.        IF NOT found THEN {mapUnit ¬ VM.nullInterval; RETURN[ok]};        SELECT GetParamAvailablity[backingStoreRunsStorage] FROM          allSwappedIn => EXIT;          busy => NULL;  -- (stay in loop until available)          someSwappedOut => RETURN[parametersNotSwappedIn];          ENDCASE => Bug[noSuchCase];        WAIT swapUnitCheckedInOrUnmapped;        ENDLOOP;      --ASSERT: All of backingStoreRunsStorage is available and swapped in.      [pRunFirstInMapUnit, pRunLastInMapUnit] ¬ GetMapUnitBounds[pRun];      mapUnit.page ¬ rBase[pRunFirstInMapUnit].interval.page;      mapUnit.count ¬        rBase[pRunLastInMapUnit].interval.page + rBase[          pRunLastInMapUnit].interval.count - mapUnit.page;      -- The following fields are constant over map unit:      transferProc ¬ GetTransferProc[rBase[pRunFirstInMapUnit].transferProcID];      usage ¬ rBase[pRunFirstInMapUnit].usage;      class ¬ rBase[pRunFirstInMapUnit].class;      swapUnits ¬        WITH run: rBase[pRunFirstInMapUnit] SELECT FROM          unitary => [unitary[]],          uniform => [uniform[defaultSwapUnitSize]], --**          irregular => [irregular[NIL]],          ENDCASE => SwapUnitTypeBug[noSuchCase];      IF BASE[backingStoreRunsStorage] = NIL OR transferProc = NIL        OR LENGTH[backingStoreRunsStorage] = 0 THEN        backingStoreRuns ¬ DESCRIPTOR[BASE[backingStoreRunsStorage], 0]      ELSE        BEGIN        pRun ¬ pRunFirstInMapUnit;        FOR k: CARDINAL IN [0..LENGTH[backingStoreRunsStorage]) DO          backingStoreRunsStorage[k] ¬ [            count: rBase[pRun].interval.count, data: rBase[pRun].backingData];          IF pRun = pRunLastInMapUnit THEN GO TO finishedWithRuns;          pRun ¬ pRun + SIZE[Run];          REPEAT            finishedWithRuns =>              backingStoreRuns ¬ DESCRIPTOR[BASE[backingStoreRunsStorage], k + 1];            FINISHED => backingStoreRuns ¬ backingStoreRunsStorage;          ENDLOOP;        END;      RETURN[ok];      END;  --GetMapUnitAttributesEntry--    -- Begin main text of GetMapUnitAttributes:    paramsSwapStatus: VMData.ParamsSwapStatus;    priorityPrev: Process.Priority;    IF page >= StoragePrograms.countVM THEN      ERROR Space.Error[pointerPastEndOfMemory];    DO  -- until all pages of backingStoreRunsStorage are swapped in      priorityPrev ¬ GuardStateVector[];      paramsSwapStatus ¬ GetMapUnitAttributesEntry[];      UnguardStateVector[priorityPrev];      --UNTIL-- IF paramsSwapStatus = ok THEN EXIT;      -- Touch all of backingStoreRunsStorage to get it swapped in:      FOR k: CARDINAL IN [0..LENGTH[backingStoreRunsStorage]) DO        -- IF YOU ADDRESS FAULT HERE, it is because the        -- backingStoreRunsStorage (that you, the caller of VM, passed in)        -- is not entirely mapped storage. Tsk, tsk.        throwAway: BackingStore.Run ¬ backingStoreRunsStorage[k]; ENDLOOP;      ENDLOOP;    END;  --GetMapUnitAttributes--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- GetMappedRunCount  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetMappedRunCount: PUBLIC --VMExtraExtras. EXTERNAL-- PROCEDURE [    page: Environment.PageNumber] RETURNS [runCount: CARDINAL] =    BEGIN        GetMappedRunCountEntry: ENTRY PROCEDURE      RETURNS [runCount: CARDINAL] =      -- Other actual arguments: all args of parent frame.      -- Other actual results: all results of parent frame.      BEGIN      pRun: PRun;      pRunFirstInMapUnit: PRun;      pRunLastInMapUnit: PRun;      found: BOOLEAN;      runCount ¬ 1;      [found, pRun] ¬ Find[page, rBase, pRunTop]; --**      IF NOT found THEN RETURN[0];      [pRunFirstInMapUnit, pRunLastInMapUnit] ¬ GetMapUnitBounds[pRun];	        IF GetTransferProc[rBase[pRunFirstInMapUnit].transferProcID] = NIL THEN        RETURN[0]  -- if no transferProc, then is resident so no runs      ELSE	RETURN[((pRunLastInMapUnit - pRunFirstInMapUnit) / SIZE[Run]) + 1];      END;  --GetMappedRunCountEntry--    -- Begin main text of GetRunCount:    priorityPrev: Process.Priority;    IF page >= StoragePrograms.countVM THEN      ERROR Space.Error[pointerPastEndOfMemory];    priorityPrev ¬ GuardStateVector[];    runCount ¬ GetMappedRunCountEntry[];    UnguardStateVector[priorityPrev];    END;  --GetMappedRunCount--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Relocate  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --  Uses pageBuffer, a one-page buffer to perform the shuffle so that the operation can be performed even in the absence of any scratch memory in the tables.  RelocateMapUnit: PUBLIC --VMData.-- PROCEDURE [    from: Environment.PageNumber, to: Environment.PageNumber] =    BEGIN        RelocateMapUnitEntry: ENTRY PROCEDURE =      BEGIN      newPRun: PRun;  --"to"      pRunFirstInMapUnit: PRun;  --"from"      pRunLastInMapUnit: PRun;      newPSwapUnit: PSwapUnit;  --"to"      pSwapUnitFirstInMapUnit: PSwapUnit;  --"from"      pSwapUnitFollowingMapUnit: PSwapUnit;      SIZERuns: CARDINAL;  --number of words in run table for map unit      nPagesInMapUnit: VM.PageCount;  --number of words in map unit itself      SIZESwapUnitData: CARDINAL;  -- SIZE of swap unit data for map unit      offset: CARDINAL;      SIZEBeingMoved: CARDINAL;  --amount we shift into buffer at one time      found: BOOLEAN;      realPageNumber: PageMap.RealPageNumber;      pageMapState: PageMap.State;      IF from = to THEN RETURN;      DO  -- until  the entire map unit is checked in.        -- Note that table pointers must be recomputed        -- each time the monitor lock is released.        [found, pRunFirstInMapUnit] ¬ Find[from, rBase, pRunTop]; --**        IF NOT found THEN Bug[notValidMapUnit];        IF (rBase[pRunFirstInMapUnit].interval.page ~= from)          OR (NOT rBase[pRunFirstInMapUnit].startOfMapUnit) THEN          Bug[notStartOfMapUnit];        pRunLastInMapUnit ¬ GetMapUnitBounds[pRunFirstInMapUnit].pRunLastInMapUnit;        nPagesInMapUnit ¬          rBase[pRunLastInMapUnit].interval.page + rBase[            pRunLastInMapUnit].interval.count - rBase[            pRunFirstInMapUnit].interval.page;        [found, newPRun] ¬ Find[to, rBase, pRunTop]; --**        -- check that we do not have overlapping map units.        -- It's ok if the new location for the map unit overlaps its old location.        IF          (found  --first page is in some map unit            AND              ((newPRun NOT IN  --it's not in our old map unit                 [pRunFirstInMapUnit..pRunLastInMapUnit])                OR  --it smashes into following map unit                  (to + nPagesInMapUnit > rBase[                    pRunLastInMapUnit + SIZE[Run]].interval.page)))          OR            (NOT found  --first page is unmapped              AND  -- runs into map unit which is not our old one..                to + nPagesInMapUnit > rBase[newPRun].interval.page              AND newPRun # pRunFirstInMapUnit) THEN Bug[overlapsExistingMapUnit];        IF NOT AnyUnavailable[          [rBase[pRunFirstInMapUnit].interval.page, nPagesInMapUnit]] THEN EXIT;        WAIT swapUnitCheckedInOrUnmapped;        ENDLOOP;      --move the client real pages to destination      --WARNING:  RelocateInternal cannot give up the monitor lock once we start changing the page map.      --Implementation note:  distinguishing these 2 cases is important in the event the new location for the map unit overlaps its old location.      IF to <= from THEN        FOR offset: Environment.PageOffset IN [0..nPagesInMapUnit) DO          [oldState: pageMapState, real: realPageNumber] ¬ PageMap.ExchangeFlags[            virtual: from + offset, newFlags: PageMap.flagsVacant];          PageMap.SetMapState[            virtual: to + offset, real: realPageNumber, state: pageMapState];          ENDLOOP      ELSE  --from < to        FOR offset: Environment.PageOffset DECREASING IN [0..nPagesInMapUnit) DO          [oldState: pageMapState, real: realPageNumber] ¬ PageMap.ExchangeFlags[            virtual: from + offset, newFlags: PageMap.flagsVacant];          PageMap.SetMapState[            virtual: to + offset, real: realPageNumber, state: pageMapState];          ENDLOOP;      IF newPRun IN [pRunFirstInMapUnit..pRunLastInMapUnit + SIZE[Run]] THEN RETURN        -- no table shifting is needed      ELSE        BEGIN        VMData.AllocateReservedMStoreInternal[	  interval: [page: pageBuffer, count: 1], resident: TRUE];  --back the pageBuffer with real memory: pageBuffer will be used to perform the data shuffle        SIZERuns ¬ pRunLastInMapUnit - pRunFirstInMapUnit + SIZE[Run];        --now go get swap unit table pointers and see if there is swap unit data to be moved        [pSwapUnitFirstInMapUnit, pSwapUnitFollowingMapUnit] ¬          GetSwapUnitTablePointers[          pRunFirstInMapUnit, pRunLastInMapUnit + SIZE[Run]];        SIZESwapUnitData ¬ pSwapUnitFollowingMapUnit - pSwapUnitFirstInMapUnit;        IF SIZESwapUnitData > 0 THEN          [pSwapUnitFirst: newPSwapUnit] ¬ GetSwapUnitTablePointers[            newPRun, pRunTop];  --find where it's going to go        --perform shuffle of table(s)        IF from > to THEN          BEGIN          --offset is offset from the front end of the data to be moved          FOR offset ¬ 0, offset + SIZEBeingMoved WHILE offset < SIZERuns DO            SIZEBeingMoved ¬ MIN[SIZERuns - offset, wordsPerPage];            --move piece of "from" run table entries into buffer            Inline.LongCOPY[              from: @rBase[pRunFirstInMapUnit + offset], to: pageBufferPtr,              nwords: SIZEBeingMoved];            --shift remainder of "to" and entries between "to" and "from" to cover old "from" piece            Inline.LongCOPYReverse[              from: @rBase[newPRun + offset],              to: @rBase[newPRun + offset + SIZEBeingMoved],              nwords: pRunFirstInMapUnit - newPRun];            --move words from buffer into new location in table            Inline.LongCOPY[              from: pageBufferPtr, to: @rBase[newPRun + offset],              nwords: SIZEBeingMoved];            ENDLOOP;          IF SIZESwapUnitData > 0 THEN            BEGIN  --play the same game            FOR offset ¬ 0, offset + SIZEBeingMoved WHILE offset < SIZESwapUnitData              DO              SIZEBeingMoved ¬ MIN[SIZESwapUnitData - offset, wordsPerPage];              Inline.LongCOPY[                from: @suBase[pSwapUnitFirstInMapUnit] + offset, to: pageBufferPtr,                nwords: SIZEBeingMoved];              --shift swap unit table              Inline.LongCOPYReverse[                from: @suBase[newPSwapUnit + offset],                to: @suBase[newPSwapUnit + offset + SIZEBeingMoved],                nwords: pSwapUnitFirstInMapUnit - newPSwapUnit];              --move data from buffer into new location in table              Inline.LongCOPY[                from: pageBufferPtr, to: @suBase[newPSwapUnit] + offset,                nwords: SIZEBeingMoved];              ENDLOOP;            --adjust pointers for map unit that was relocated            AdjustSwapUnitTablePointers[              newPRun, newPRun + SIZERuns,              -(pSwapUnitFirstInMapUnit - newPSwapUnit)];            --adjust pointers for everybody else that got bumped            AdjustSwapUnitTablePointers[              newPRun + SIZERuns, pRunLastInMapUnit + SIZE[Run], SIZESwapUnitData];            END;          END  -- from > to        ELSE  --to > from          BEGIN          --in this case, offset is offset from the tail end of the data to be moved          FOR offset ¬ 0, offset + SIZEBeingMoved WHILE offset < SIZERuns DO            SIZEBeingMoved ¬ MIN[SIZERuns - offset, wordsPerPage];            --move data into buffer            Inline.LongCOPY[              from: @rBase[pRunFirstInMapUnit + SIZERuns - offset],              to: pageBufferPtr, nwords: SIZEBeingMoved];            --shift run table            Inline.LongCOPY[              from: @rBase[pRunFirstInMapUnit + SIZERuns - offset + SIZEBeingMoved],              to: @rBase[pRunFirstInMapUnit + SIZERuns - offset],              nwords: newPRun - pRunFirstInMapUnit];            --move words from buffer into new location in table            Inline.LongCOPY[              from: pageBufferPtr, to: @rBase[newPRun + SIZERuns - offset],              nwords: SIZEBeingMoved];            ENDLOOP;          IF SIZESwapUnitData > 0 THEN            BEGIN  --play the same game            FOR offset ¬ 0, offset + SIZEBeingMoved WHILE offset < SIZESwapUnitData              DO              SIZEBeingMoved ¬ MIN[SIZESwapUnitData - offset, wordsPerPage];              Inline.LongCOPY[                from: @suBase[pSwapUnitFirstInMapUnit + SIZESwapUnitData - offset],                to: pageBufferPtr, nwords: SIZEBeingMoved];              --shift swap unit table              Inline.LongCOPY[                from: @suBase[                pSwapUnitFirstInMapUnit + SIZESwapUnitData - offset +                  SIZEBeingMoved],                to: @suBase[pSwapUnitFirstInMapUnit + SIZESwapUnitData - offset],                nwords: newPSwapUnit - pSwapUnitFirstInMapUnit];              --move words from buffer into new location in table              Inline.LongCOPY[                from: pageBufferPtr,                to: @suBase[newPSwapUnit + SIZESwapUnitData - offset],                nwords: SIZEBeingMoved];              ENDLOOP;            --adjust pointers for map unit that was relocated            AdjustSwapUnitTablePointers[              newPRun, (newPRun + SIZERuns),              (newPSwapUnit - pSwapUnitFirstInMapUnit)];            --adjust pointers for everybody else in run table that got bumped            AdjustSwapUnitTablePointers[              pRunFirstInMapUnit, newPRun, -SIZESwapUnitData];            END;          END;  -- to > from	          --deallocate real memory backing the buffer we used for shuffling          MStore.Deallocate[interval: [page: pageBuffer, count: 1], vow: notPromised];        END;      END;  --RelocateMapUnitEntry--         Pinning.Pin[relocateMapUnitPinHandle]; -- ensure enclosing code pack is resident     RelocateMapUnitEntry[];    Pinning.Unpin[relocateMapUnitPinHandle]; -- free enclosing code pack    END;      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- SupplyBackingStore  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SupplyBackingStore: PUBLIC --VM.-- PROCEDURE [    page: Environment.PageNumber, transferProc: BackingStore.TransferProc,    backingStoreRuns: VM.BackingStoreRuns, swapUnits: Space.SwapUnitOption] =    BEGIN    -- See note on "Swappable arguments" at head of module.    SupplyBackingStoreEntry: ENTRY PROCEDURE[]      RETURNS [paramsSwapStatus: VMData.ParamsSwapStatus] =      -- Other actual arguments: all args of parent frame.      BEGIN      -- See note on "Swappable arguments" at head of module.      pRun, pRunLast: PRun;      found: BOOLEAN;      mapParams: VMData.MapParams;      mapParams.transferProc ¬ transferProc;      mapParams.backingStoreRuns ¬ backingStoreRuns;      mapParams.swapUnits ¬ swapUnits;      mapParams.initialLife ¬ alive;      DO  --until backingStoreRuns and swapUnits.sizes are available and swapped in--        SELECT GetParamAvailablity[backingStoreRuns, swapUnits] FROM          allSwappedIn => EXIT;          busy => NULL;  -- (waits below)          someSwappedOut => RETURN[parametersNotSwappedIn];          ENDCASE => Bug[noSuchCase];        WAIT swapUnitCheckedInOrUnmapped;        ENDLOOP;      --ASSERT: All of backingStoreRuns is available and swapped in.      -- Check that page is in a map unit and get its bounds:      [found, pRun] ¬ Find[page, rBase, pRunTop]; --**      IF NOT found THEN Bug[unmappedPage];      [pRun, pRunLast] ¬ GetMapUnitBounds[pRun];      -- Grab run table data before we delete the old map unit:      mapParams.interval.page ¬ rBase[pRun].interval.page;      mapParams.interval.count ¬        rBase[pRunLast].interval.page + rBase[pRunLast].interval.count -          mapParams.interval.page;      mapParams.usage ¬ rBase[pRun].usage;      mapParams.class ¬ rBase[pRun].class;      firstSwapUnit ¬ TRUE;  -- (arg of VerifyResidentAndUniformAccess)      [] ¬ ProcessSwapUnits[  -- sets suAccess        mapParams.interval, errorIfUnmapped, spanRuns,        VerifyResidentAndUniformAccess];      mapParams.access ¬ suAccess;      [] ¬ DeleteMapUnitInternal[mapParams.interval.page];      CreateMapUnitInternal[@mapParams];      RETURN[ok];      END;  --SupplyBackingStoreEntry--    -- Begin main text of SupplyBackingStore:    status: Zone.Status;    paramsSwapStatus: VMData.ParamsSwapStatus;    priorityPrev: Process.Priority;    IF page >= StoragePrograms.countVM THEN      ERROR Space.Error[pointerPastEndOfMemory];        --+++++++ Ensure that the containing code-pack is resident+++++++      Pinning.Pin[supplyBackingStorePinHandle];        DO      priorityPrev ¬ GuardStateVector[];      WHILE NOT ProcessOperations.Enter[@useMeFreeMeLock] DO ENDLOOP;      IF useMeTransferProcDesc = nilPTransferProcDesc THEN        BEGIN        [useMeTransferProcDesc, status] ¬ ResidentHeap.MakeNode[          SIZE[TransferProcDesc]];        IF status # okay THEN Bug[unableToAllocateResidentHeapNode];        END;      paramsSwapStatus ¬ SupplyBackingStoreEntry[];      IF freeMeTransferProcDesc # nilPTransferProcDesc THEN        BEGIN        IF useMeTransferProcDesc = nilPTransferProcDesc THEN  --          -- Save for next time one is needed          useMeTransferProcDesc ¬ freeMeTransferProcDesc        ELSE          BEGIN          status ¬ ResidentHeap.FreeNode[freeMeTransferProcDesc];          IF status # okay THEN Bug[unableToFreeResidentHeapNode];          END;        freeMeTransferProcDesc ¬ nilPTransferProcDesc;        END;      ProcessOperations.Exit[@useMeFreeMeLock];      UnguardStateVector[priorityPrev];      --UNTIL-- IF paramsSwapStatus = ok THEN EXIT;      -- Touch data to get it swapped in:      -- Note: There is a copy of this code in VMImpl.Map. We could      --   share it by moving SupplyBackingStore there..      FOR k: CARDINAL IN [0..LENGTH[backingStoreRuns]) DO        throwAway: BackingStore.Run ¬ backingStoreRuns[k];        -- IF YOU ADDRESS FAULT HERE, it is because the        -- backingStoreRuns (that you, the caller of VM, passed in)        -- is not entirely mapped storage. Tsk, tsk.        ENDLOOP;      WITH s: swapUnits SELECT FROM        unitary, uniform => NULL;        irregular =>          FOR k: CARDINAL IN [0..LENGTH[s.sizes]) DO            throwAway: Space.SwapUnitSize ¬ s.sizes[k];            -- IF YOU ADDRESS FAULT HERE, it is because the            -- swapUnits.sizes (that you, the caller of VM, passed in)            -- is not entirely mapped storage. Tsk, tsk.            ENDLOOP;        ENDCASE => Bug[noSuchCase];      ENDLOOP;            --++++++++ Release the containing code pack++++++      Pinning.Unpin[supplyBackingStorePinHandle];    END;  --SupplyBackingStore--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- GetParamAvailablity  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetParamAvailablity: PROCEDURE [    bsRuns: VM.BackingStoreRuns, swapUnits: Space.SwapUnitOption ¬ [unitary[]]]    RETURNS [paramAvailablity: ParamAvailablity];   -- indirect control link to port is set in InitializeGetParamAvailablity  -- Returns swap state of bsRuns­ and swapUnits.sizes­.  -- The default swapUnits value of [unitary[]] is supplied  -- for clients not having any swap unit argument.   -- Assumes bsRuns­ and swapUnits.sizes­ have <= LAST[CARDINAL] words.  ParamAvailablity: TYPE = {allSwappedIn, busy, someSwappedOut};  InitializeGetParamAvailablity: PROCEDURE    RETURNS --must match port args-- [paramAvailablity: ParamAvailablity] =    BEGIN        AwaitGetParamAvailablityRequest: --RESPONDING-- PORT [  --      -- args/results match GetParamAvailablity (but swapped)      paramAvailablity: ParamAvailablity]      RETURNS [bsRuns: VM.BackingStoreRuns, swapUnits: Space.SwapUnitOption];    bsRuns: VM.BackingStoreRuns;    swapUnits: Space.SwapUnitOption;    GetParamAvailablity ¬ LOOPHOLE[LONG[@AwaitGetParamAvailablityRequest]];    LOOPHOLE[AwaitGetParamAvailablityRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];  --set my PORT call to return to my caller on call below    DO  --FOREVER--      -- Return; Await new request; Process it.      [bsRuns, swapUnits] ¬ AwaitGetParamAvailablityRequest[paramAvailablity];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitGetParamAvailablityRequest, PrincOps.Port].dest.frame];      paramAvailablity ¬ SwappedInStatus[        data: BASE[bsRuns], size: LENGTH[bsRuns]*SIZE[BackingStore.Run]];      IF paramAvailablity = allSwappedIn THEN        BEGIN        WITH s: swapUnits SELECT FROM          unitary, uniform => NULL;          irregular =>            paramAvailablity ¬ SwappedInStatus[              data: BASE[s.sizes], size: LENGTH[s.sizes]*SIZE[Space.SwapUnitSize]]          ENDCASE => Bug[noSuchCase];        END;      ENDLOOP;  --FOREVER--    END;  --GetParamAvailablity--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --SwappedInStatus  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SwappedInStatus: PROCEDURE [data: LONG POINTER, size: CARDINAL]    RETURNS [paramAvailablity: ParamAvailablity];    -- indirect control link to port is set in InitializeSwappedInStatus  -- Returns state of requested block of memory.  -- Note that this proc is only useful for up to LAST[CARDINAL] words.  InitializeSwappedInStatus: PROCEDURE    RETURNS --must match port args-- [paramAvailablity: ParamAvailablity] =    BEGIN    data: LONG POINTER;    size: CARDINAL;        AwaitSwappedInStatusRequest: --RESPONDING-- PORT [  --      -- args/results match SwappedInStatus (but swapped)      paramAvailablity: ParamAvailablity]      RETURNS [data: LONG POINTER, size: CARDINAL];          SwappedInStatus ¬ LOOPHOLE[LONG[@AwaitSwappedInStatusRequest]];    LOOPHOLE[AwaitSwappedInStatusRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];  --set my PORT call to return to my caller on call below    DO  --FOREVER--      -- Return; Await new request; Process it.      [data, size] ¬ AwaitSwappedInStatusRequest[paramAvailablity];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitSwappedInStatusRequest, PrincOps.Port].dest.frame];      IF size = 0 THEN paramAvailablity ¬ allSwappedIn  -- (typical case)      ELSE        BEGIN        page: VM.PageNumber ¬ Space.PageFromLongPointer[data];        count: VM.PageCount ¬ Space.PageFromLongPointer[data + size - 1] - page + 1;        IF AnyUnavailable[[page, count]] THEN paramAvailablity ¬ busy        ELSE          BEGIN          --ASSERT: All of data is available.          THROUGH [0..count) DO            IF PageMap.IsVacant[page] THEN {              paramAvailablity ¬ someSwappedOut; EXIT};            page ¬ page.SUCC;            REPEAT FINISHED => paramAvailablity ¬ allSwappedIn;            ENDLOOP;          END;        END;      ENDLOOP;  --FOREVER--    END;  --SwappedInStatus--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- VerifyResidentAndUniformAccess: SwapUnitProcessor  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Other actual arguments and results:  firstSwapUnit: BOOLEAN;  suAccess: Space.Access;  -- Operation:  -- Marks swap unit busy.  -- If firstSwapUnit = TRUE, then does {suAccess ¬ <access of current swap unit>; firstSwapUnit ¬ FALSE}.  -- If firstSwapUnit = FALSE and access of the current swap unit # suAccess, the debugger is called.  -- If the swap unit is not resident or is not available, the debugger is called.  VerifyResidentAndUniformAccess: SwapUnitProcessor;    -- indirect control link to port InitializeVerifyResidentAndUniformAccess      InitializeVerifyResidentAndUniformAccess: PROCEDURE    RETURNS --must match port args-- [      state: SwapUnitState, continuation: Continuation] =    BEGIN        AwaitVerifyResidentAndUniformAccessRequest: --RESPONDING-- PORT [      -- args/results must match VerifyResidentAndUniformAccess (but swapped)      newState: SwapUnitState, continuation: Continuation]      RETURNS [swapUnitInterval: VM.Interval, state: SwapUnitState];        VerifyResidentAndUniformAccess ¬      LOOPHOLE[LONG[@AwaitVerifyResidentAndUniformAccessRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitVerifyResidentAndUniformAccessRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return; await new request; process it:      state ¬ AwaitVerifyResidentAndUniformAccessRequest[        newState: state, continuation: continue].state;      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitVerifyResidentAndUniformAccessRequest, PrincOps.Port].dest.frame];      IF firstSwapUnit THEN {suAccess ¬ state.st.access; firstSwapUnit ¬ FALSE};      IF state.availability # available OR state.st.swappability # resident OR        state.st.access # suAccess THEN Bug[notAvailableOrNotResidentOrNotUniformAccess];      state.availability ¬ busy;      ENDLOOP;  --FOREVER--    END;  --VerifyResidentAndUniformAccess--  END.LOG 7-Sep-82 21:52:04   LXD      	Created file for Klamath.28-Oct-82 14:27:00   WDK     	Made compatible with new PageMap.29-Oct-82 10:05:10   WDK     	Map set initial life wrong. 1-Dec-82 16:29:07   WDK        Made compatible with new VMDataInternal. Minor reworks and name changes. Map failed on irregular swap units broken by runs. Map failed to correctly carry over fragment from run smaller than uniform swap unit size. Added SetDefaultSwapUnitSize.15-Dec-82 11:28:59   WDK     	Made compatible with new VMDataInternal.23-Dec-82  9:29:07   AWL         NewSpace => Space.  Long page numbers.  Twiddles for new VM interface.14-Jan-83 16:49:38   WDK        LENGTH[GetMapUnitAttributes[dataMapUnit].backingStoreRuns] was wrong.10-Feb-83 14:20:50   WDK        Eliminate large argument records. Handle truncation warnings. 7-Mar-83 17:19:23   WDK     	Eliminate last large argument record.23-Mar-83 12:48:21   WDK        Plant bear trap for missing map unit. Make compatible with new SwapUnitProcessor. SupplyBackingStore must check out all swap units. 8-Apr-83 14:39:41   WDK     	Handle truncation warnings. 3-May-83 14:24:27   WDK     	Add FindMapUnit.10-Jun-83 11:39:21   JXG    	change FindMapUnit16-Jun-83 14:37:16   JXG    	use Pinning on RelocateMapUnit, SupplyBackingStor20-Jun-83  9:38:22   JXG    	changes to initialization for Pinning23-Jun-83 15:44:50   JXG    	fold in Extras 12-Jul-83 17:26:38   JXP   	Fix up port stuff. 4-Aug-83 11:37:56   WDK     	Get LongCOPYReverse from Inline.13-Feb-84 16:00:41   CAJ 	Maintain SwapUnitTable invariant of ordered entries: initialize hole, update pointers in moved part before new page added.12-Apr-84 17:51:21   CAJ 	Set run table pointer to swap unit table after entry is safely allocated.24-Jul-84 17:56:31   KEK    	remove memType from calls to Deallocate17-Aug-84 11:13:34   KEK    	add "resident" argument to AllocateReservedMStore (for PC emulation)  4-Sep-85 12:40:15   kam/jp    	InitializeSwappedInStatus miscalculated count when data was not page aligned. 12-Sep-86  7:06:00   et         Change ProcessPriorities to ProcessPrioritiesExtras. 8-Dec-86  8:28:22   RSV        Added GetRunCount procedure (from VMExtraExtras)14-Jan-87 23:32:36   et	        mds relief.21-Sep-88 14:36:52   TxH        made changes for Duke. See **.14-Dec-88 16:30:40   TxH,HxO    Set defaultSwapUnitSize for various real memory sizes15-Dec-88 10:51:13   HxO	Added any comments11-Apr-89 10:55:07   TxH        Added DeleteMapUnitPartially, its initialization, and GetVMIntervalWithLockHandle, which all exported to VMExtras2. And made some other related changes. (SS-FX: AR#6, AR#26)16-May-89  8:18:05   TxH        Fix bugs and make some changes in DeleteMapUnitPartially and GetVMIntervalWithLockHandle. 
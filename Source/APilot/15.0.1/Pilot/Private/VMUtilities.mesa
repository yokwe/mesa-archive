-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- VMDriver>VMUtilities.mesa   12-Sep-86  7:15:00 by et    -- This program implements miscellaneous utility functions for VMImpl, especially those which demand the protection of a monitor lock.-- PROGRAMMING NOTES:---- The availability of monitor lock of this module is crucial to the execution of many VM operations. This lock should be tied up only for short periods, and must not be held while calling any external procedure which may wait.-- LIMITATIONS:---- The current implementation does not support queuing operations by helper processes.-- PROBLEMS:---- CountReservedTails's result could overflow.-- THINGS TO CONSIDER:---- DeallocateMStoreIfClean might be better if it freed pages-- in more than single page clumps.---- Maybe make things VMPerf.BatchCounts rather than PageCounts.---- Consider reporting IOErrors back to the client when (if!) he calls Wait.DIRECTORY  Environment USING [PageCount, PageNumber, Word, wordsPerPage],  Inline USING [LongCOPY],  KernelSpaceUsage USING [vmUtilitiesBuffer],  MStore USING [    Allocate, Deallocate, RelocateAdjustingFlags],  PageMap USING [    ExchangeFlags, Flags, flagsDirty, flagsVacant, GetState,    maskNone, PageNumber, RealPageNumber, SetMapState, State],  PilotSwitches USING [zeroScratchMem],  Process USING [DisableAborts, DisableTimeout],  ProcessInternal USING [GetCurrent, SetPriority],  ProcessPrioritiesExtras USING [priorityPageFaultLow],  RuntimeInternal USING [Bug],  Space USING [LongPointerFromPage],  StoragePrograms USING [AllocateVM],  SwapBuffer USING [Allocate, Deallocate],  System USING [switches],  VM USING [Interval, PageCount],  VMData USING [AllocateReservedMStore, ProcessType],  VMInternal USING [    ActivateSynchronous, CopyInSynchronous, CopyOutSynchronous, DeactivateSynchronous,    ForceOutSynchronous, OpData, QueueOp, SetSwappabilitySynchronous],  VMPerf USING [];VMUtilities: MONITOR  --lock covers QueuedOperation data and pageFreeingBuffer ONLY--  IMPORTS    Inline, MStore, PageMap, Process, ProcessInternal, RuntimeInternal,    Space--inlines and errors--, StoragePrograms, SwapBuffer,    System, VMData, VMInternal  EXPORTS VMInternal, VMPerf  SHARES PageMap =  BEGIN OPEN VMInternal;  -- PARAMETERS:  defaultInitialQueuedOperationExecutors: CARDINAL = 1;  maxHelperProcs: CARDINAL = 4;  -- max number of helper processes easily supported.  maxQueuedOperations: CARDINAL = 4;  -- maximum number of operations that can be queued for asynchronous execution. Requests exceeding this will be made to wait.  countFreeingBuffer: Environment.PageCount = 1;  -- size of buffer used for freeing clean pages.  -- PERFORMANCE DATA (exported to VMPerf):  executorProcesses: PUBLIC CARDINAL;  queuedOperations: PUBLIC CARDINAL;  queuedOperationsDelayed: PUBLIC CARDINAL;  -- TYPES and CONSTANTS:  PageCount: TYPE = Environment.PageCount;  PageNumber: TYPE = Environment.PageNumber;  wordsPerPage: CARDINAL = Environment.wordsPerPage;  Interval: TYPE = VM.Interval;  BugType: TYPE = {    funnyCase, helperExpansionNotImplemented, invalidParameters, queueConfused,    runShorterThanInterval};  -- NOTE: The types and variables for a routine or set of them  -- are defined just before the routines.  pageFreeingBuffer: Environment.PageNumber;  -- used for freeing clean pages.  --~~~~~~~~~~ Initialization, testing, and performance facilities:  InitializeVMUtilities: PUBLIC --VMInternal.-- PROCEDURE[] =    BEGIN    Process.DisableAborts[@operationDequeued];    Process.DisableTimeout[@operationDequeued];    Process.DisableAborts[@operationEnqueued];    Process.DisableTimeout[@operationEnqueued];    pageFreeingBuffer ¬ StoragePrograms.AllocateVM[      countFreeingBuffer, hyperspace, KernelSpaceUsage.vmUtilitiesBuffer,      partiallyOrSometimesMapped].page;    InitializeOperationQueue[];    END;  AnotherExecutorProcess: PUBLIC --VMPerf.-- PROCEDURE[] = {    -- We don't make this an ENTRY proc because the expected probability    -- of concurrent access is thought to be infinitesimal    -- and the consequences of such access unimportant.    throwAway: PROCESS ¬ FORK ExecutorProcess[];  -- (no profit in detaching.)    executorProcesses ¬ executorProcesses.SUCC};  --~~~~~~~~~~ Operation queueing routines:<< Order of entries in the circular operation queue, and pointers into it:|free|...|free||beingEx'd|...|beingEx'd|awaitingEx...|awaitingEx|<wrap to free>  ­ nextFree                             ­ nextToExecute>>  QueueIndex: TYPE = [0..maxQueuedOperations);  queuedOperation: ARRAY QueueIndex OF QueueItem;  countQueued: [0..maxQueuedOperations] ¬ 0;  nextFree: QueueIndex;  -- next slot to use for incoming ops.  nextToExecute: QueueIndex;  -- next slot to execute.  operationDequeued: CONDITION;  operationEnqueued: CONDITION;  QueueItem: TYPE = RECORD [    requestingProcess: PROCESS,    interval: Interval,    status: PRIVATE {awaitingExecution, beingExecuted, free},    oper: QueueOp];  SuccQI: PROCEDURE [qi: QueueIndex] RETURNS [QueueIndex] = INLINE {    -- Circular SUCC function.    RETURN[SUCC[qi] MOD maxQueuedOperations]};  InitializeOperationQueue: PROCEDURE[] =    BEGIN    initialQueuedOperationExecutors: CARDINAL ¬  -- allows twiddling from debugger.      defaultInitialQueuedOperationExecutors;    nextToExecute ¬ nextFree ¬ FIRST[QueueIndex];    FOR qi: QueueIndex IN QueueIndex DO queuedOperation[qi].status ¬ free ENDLOOP;    THROUGH [1..initialQueuedOperationExecutors] DO      AnotherExecutorProcess[]; ENDLOOP;    END;  AwaitNoOverlappingOperations: PUBLIC --VMInternal.-- ENTRY PROCEDURE [    interval: VM.Interval] =    -- To make life easy, we require that queued operations must have a nonzero interval.count.    BEGIN    -- We make one pass through the execution queue, examining for overlaps.    << While we are waiting for an overlapping operation to be dispatched,    the queue could empty completely, then refill with new stuff,    thus causing the queue entry that we are looking at to be a completely    different one. However, the definition of VM.Wait is that we only need    to make a single pass through the queue; thus there is no need    to reexamine earlier parts of the queue. >>    start: QueueIndex = nextFree;    IF interval.count = 0 THEN RETURN;    DO  --UNTIL no op awaiting execution overlaps interval--      BEGIN  --scope of Wait--      qi: QueueIndex ¬ start;      DO  --REPEAT scan queue UNTIL find overlap (return if none)--        OPEN qin: queuedOperation[qi].interval;        SELECT queuedOperation[qi].status FROM          awaitingExecution, beingExecuted =>            BEGIN            IF qin.count = 0 THEN Bug[invalidParameters];            -- ASSERT: Both intervals are nonEmpty.            SELECT TRUE FROM              interval.page = qin.page => GOTO Wait;              interval.page < qin.page =>                IF interval.page + interval.count > qin.page THEN GOTO Wait;              ENDCASE =>  --interval.page > qin.page--                IF qin.page + qin.count > interval.page THEN GOTO Wait;            END;          free => NULL;          ENDCASE => Bug[funnyCase];        qi ¬ SuccQI[qi];        --UNTIL--IF qi = start THEN RETURN;  -- no overlaps in queue.        ENDLOOP;  --REPEAT scan queue UNTIL find overlap (return if none)--      EXITS Wait => WAIT operationDequeued;      END;  --scope of Wait--      ENDLOOP;  --UNTIL no op awaiting execution overlaps interval--    END;  --AwaitNoOverlappingOperations--  EnqueueOperation: PUBLIC --VMInternal.-- ENTRY PROCEDURE [    interval: VM.Interval, op: QueueOp] =    BEGIN    IF interval.count = 0 THEN RETURN;  -- as required by AwaitNoOverlappingOperations.    IF queuedOperation[nextFree].status ~= free THEN      queuedOperationsDelayed ¬ SUCC[queuedOperationsDelayed];    UNTIL queuedOperation[nextFree].status = free DO      WAIT operationDequeued ENDLOOP;    queuedOperation[nextFree] ¬ [      ProcessInternal.GetCurrent[], interval, awaitingExecution, op];    nextFree ¬ SuccQI[nextFree];    queuedOperations ¬ SUCC[queuedOperations];    NOTIFY operationEnqueued;    -- We want the ExecutorProcess to get working on this operation    -- right away. Typically, it is running at the same priority    -- as I am. However, when I exit from VMImpl, my priority    -- will typically be lowered and then the ExecutorProcess will run.    END;  FinishQueuedOperation: ENTRY PROCEDURE [qi: QueueIndex] = {    -- Checks in prev operation.    IF queuedOperation[qi].status ~= beingExecuted THEN      Bug[queueConfused];    queuedOperation[qi].status ¬ free;    BROADCAST operationDequeued};  GetNextQueuedOperation: ENTRY PROCEDURE RETURNS [next: QueueIndex] =    -- Gets next op to be done, waiting if necessary.    -- Operations are executed in the order in which they are queued.    BEGIN    UNTIL queuedOperation[nextToExecute].status = awaitingExecution DO      WAIT operationEnqueued ENDLOOP;    queuedOperation[nextToExecute].status ¬ beingExecuted;    next ¬ nextToExecute;    nextToExecute ¬ SuccQI[nextToExecute];    END;  ExecutorProcess: PROCEDURE[] =    BEGIN    opData: OpData;    qi: QueueIndex;    ProcessInternal.SetPriority[ProcessPrioritiesExtras.priorityPageFaultLow];    DO  --FOREVER--      [next: qi] ¬ GetNextQueuedOperation[];      BEGIN      ENABLE        ABORTED =>          -- If error, we will go to debugger, then operator can Quit if he wants to continue.          CONTINUE;      opData.process ¬ queuedOperation[qi].requestingProcess;      opData.checkOutData.processType ¬ client;      -- (since helper processes are not allowed to use returnWait=return.)      -- Note: there is a copy of the following code in VMImpl.EnterVM.      opData.error ¬ [noError[]];      opData.ioErrorHandler ¬ NIL;      WITH qo: queuedOperation[qi].oper SELECT FROM        activate => ActivateSynchronous[@opData, queuedOperation[qi].interval];        copyIn =>          CopyInSynchronous[            @opData, queuedOperation[qi].interval, qo.transferProc, qo.data];        copyOut =>          CopyOutSynchronous[            @opData, queuedOperation[qi].interval, qo.transferProc, qo.data];        deactivate =>          DeactivateSynchronous[@opData, queuedOperation[qi].interval];        forceOut => ForceOutSynchronous[@opData, queuedOperation[qi].interval];        setSwappability =>          SetSwappabilitySynchronous[            @opData, queuedOperation[qi].interval, qo.swappability];        ENDCASE => Bug[funnyCase];      END;  --ENABLE--      FinishQueuedOperation[qi];      ENDLOOP;  --FOREVER--    END;  --ExecutorProcess--  --~~~~~~~~~~ Miscellaneous utility routines:  AllocateRealMemory: PUBLIC --VMInternal.-- PROCEDURE [    interval: VM.Interval, processType: VMData.ProcessType, resident: BOOLEAN] =    BEGIN    SELECT processType FROM      client => MStore.Allocate[interval, resident];      helper => VMData.AllocateReservedMStore[interval, resident];      ENDCASE => Bug[funnyCase];    END;  Bug: PROCEDURE [type: BugType] =    {RuntimeInternal.Bug[type]};    DeallocateMStoreIfClean: PUBLIC --VMInternal.-- ENTRY PROCEDURE [    interval: VM.Interval]    RETURNS [countDeallocated: Environment.PageCount] =    BEGIN    -- Implementation note: This proc can not cause deadlocks    -- on its monitor because MStore.Deallocate always suceeds    -- without additional resource allocation.     oldState: PageMap.State;    real: PageMap.RealPageNumber;    countDeallocated ¬ 0;    FOR page: Environment.PageNumber IN      [interval.page..interval.page + interval.count) DO      [oldState, real] ¬  -- get flags, make vacant.        PageMap.ExchangeFlags[page, PageMap.flagsVacant];      IF oldState.flags = PageMap.flagsVacant THEN LOOP      ELSE        BEGIN  --mapped--        IF oldState.flags.dirty THEN  -- put back.          PageMap.SetMapState[virtual: page, real: real, state: oldState]        ELSE {          PageMap.SetMapState[  -- put behind buffer.            virtual: pageFreeingBuffer, real: real, state: oldState];          MStore.Deallocate[[pageFreeingBuffer, 1], notPromised];          countDeallocated ¬ SUCC[countDeallocated]};        END;  --mapped--      ENDLOOP;    END;  --DeallocateMStoreIfClean--  GetFlags: PROCEDURE [page: --PageNumber-- CARDINAL]    RETURNS [state: PageMap.State, real: PageMap.RealPageNumber] = {    -- Called only from debugger to peek at page flags.    RETURN PageMap.GetState[virtual: page]};  ReadDead: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval] =    BEGIN    -- Implementation note: AllocateRealMemory may have to wait for real    -- memory to be made available. If we had a common buffer    -- for ReadDead (protected by a monitor), we could get deadlocks    -- on helper processes trying to also do a ReadDead. Thus we must    -- allocate a buffer specifically for each activation.    OPEN pOpData;    resident: BOOLEAN ¬ (checkOutData.state.swappability = resident);    pageReadIn ¬ TRUE;      SELECT System.switches[PilotSwitches.zeroScratchMem] FROM      up =>  -- (clean and writable)        AllocateRealMemory[interval, checkOutData.processType, resident];      down =>        BEGIN	pageBuffer: Environment.PageNumber =	  SwapBuffer.Allocate[count: 1, sizeRequirement: willTakeLess].page;	pBuffer: LONG POINTER TO ARRAY [0..wordsPerPage) OF Environment.Word =	  Space.LongPointerFromPage[pageBuffer];        FOR pageDest: PageNumber IN          [interval.page..interval.page + interval.count) DO          AllocateRealMemory[[pageBuffer, 1], checkOutData.processType, resident];          pBuffer[0] ¬ 0;          Inline.LongCOPY[            from: @pBuffer[0], to: @pBuffer[1], nwords: wordsPerPage - 1];          [] ¬ MStore.RelocateAdjustingFlags[            interval: [pageBuffer, 1], pageDest: pageDest,            flagsKeep: PageMap.maskNone, flagsAdd: PageMap.flagsDirty];          ENDLOOP;	SwapBuffer.Deallocate[ [page: pageBuffer, count: 1] ];        END;      ENDCASE => Bug[funnyCase];    END;  END.LOG(For earlier log entries, see Pilot 8.0 archive version.)15-Jul-82  9:22:45   WDK        Created file.29-Sep-82 13:32:25   WDK        Twiddles.21-Oct-82 11:38:52   WDK        GetNextQueuedOperation returned <desiredValue+1>.22-Oct-82 10:00:33   WDK        Typo in DeallocateMStoreIfClean matched UNSPECIFIED.25-Oct-82 15:24:53   WDK        Made compatible with new PageMap. 4-Nov-82  9:12:49   WDK        Made compatible with new MStore.21-Dec-82 16:50:13   AWL         NewSpace => Space, PilotSpaceUsage => KernelSpaceUsage. 1-Mar-83 10:54:49   WDK         Added GetFlags. To prevent deadlock, must allocate buffer for each zeroScratchMem ReadDead request.19-Apr-83 10:08:03   WDK        Didn't wait for beingExecuted operations.28-Apr-83 14:03:33   WDK        Export perf variables. 7-Nov-83 21:11:35   WDK        broadcast, not notify.26-Jan-84 11:14:57   AWL         OpData.reserveAlreadApproved no longer around.18-Jun-84 13:58:34   KEK         Pass whole opData to ReadDead. Reset MaybeOut in ReadDead.10-Jul-84 17:02:12   KEK         VMInternal.OpData.processType now VMData.CheckOutData.processType.  Move ApproveReserved and CountReservedTails to VMDataImpl.16-Aug-84 19:28:15   KEK     added "resident" argument to AllocateRealMemory and MStore.Allocate and AllocateReservedMStore (for PC emulation).29-Nov-84 13:35:01   KEK        made GetNextQueuedOperation & FinishQueuedOperation not INLINE, in preparation to making ExecutorProcess swappable.12-Sep-86  7:15:06	et	Change ProcessPriorities to ProcessPrioritiesExtras.
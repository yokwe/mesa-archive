-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- MesaRuntime>Processes.mesa      18-Aug-86 19:19:42 by ET     -- THINGS TO CONSIDER: Should ValidProcess really be INLINE?DIRECTORY  CPSwapDefs USING [ProcessState],  Environment USING [    Long, PageCount, PageFromLongPointer, PageNumber, wordsPerPage],  Frame USING [    Alloc, Free, GetReturnFrame, GetReturnLink, MyLocalFrame,    ReadLocalWord, ReadPC, ReadReturnLink, WriteLocalWord,    WritePC, WriteReturnLink],  FrameExtras USING [ReadGlobalLink, WriteGlobalLink],  Inline USING [BITAND, BITNOT, BITOR, BITSHIFT, COPY],  PageMap USING [    flagsClean, IsMapped, IsVacant, flagsVacant, GetState,    RealPageNumber, SetMapFlags, State],  PrincOps USING [    ControlLink, LocalFrameHandle, LocalWord, LocalOverhead, FrameSizeIndex,    nullLocalFrame, PortHandle, ShortControlLink, StateVector],  Process USING [Milliseconds, Priority, Ticks],  ProcessInternal USING [    GetCurrent, GetPriority, SetPriority, Yield],  ProcessOperations USING [    Broadcast, DisableInterrupts, EnableInterrupts, Enter, Exit,    HandleFromIndex, IndexFromProcess, Notify, ProcessFromIndex,    ReadMDS, ReadPSB, ReEnter, Requeue, Wait, WritePSB,    WriteWDC],  ProcessPriorities USING [priorityClient, priorityClientHigh, priorityClientLow],  ProcessorFace USING [millisecondsPerTick, reservedNakedNotifyMask],  PSB USING [    Condition, ConditionVariable, FaultIndex, InterruptItem, InterruptLevel, Monitor, NoTimeout,    NullPsbHandle, NullStateVectorHandle, PDA, PDABase, Priority, ProcessDataArea,    ProcessStateBlock, PsbData, PsbHandle, PsbIndex, PsbNull, Queue,    StartPsb, StateVectorHandle, Ticks, UnlockedEmpty],  RuntimeInternal USING [FrameSize, SourceDest],  RuntimePrograms USING [],  Space USING [PagesFromWords, unknownUsage],  SpecialRuntime USING [],  SDDefs USING [SD, sFork, sJoin, sProcessTrap],  StoragePrograms USING [OutlawInterval, startList],  VM USING [DoneWithStateVector, GuardStateVector];Processes: MONITOR LOCKS processLock  IMPORTS    Environment, Frame, FrameExtras, Inline, PageMap, ProcessInternal, ProcessorFace,    ProcessOperations, RuntimeInternal, Space, StoragePrograms, VM  EXPORTS Process, RuntimePrograms, SpecialRuntime  SHARES PageMap =  BEGIN OPEN PSB, PrOp: ProcessOperations;  -- PUBLIC ITEMS:    priorityBackground: PUBLIC Process.Priority ¬    ProcessPriorities.priorityClientLow;  priorityForeground: PUBLIC Process.Priority ¬    ProcessPriorities.priorityClientHigh;  priorityNormal: PUBLIC Process.Priority ¬ ProcessPriorities.priorityClient;  InvalidProcess: PUBLIC ERROR [process: PROCESS] = CODE;  TooManyProcesses: PUBLIC ERROR = CODE;  -- CONSTANTS and TYPES:    ConditionVariable: TYPE = PSB.ConditionVariable;  FrameSizeIndex: TYPE = PrincOps.FrameSizeIndex;  ProcessState: TYPE = CPSwapDefs.ProcessState;  pda: PSB.PDABase = PSB.PDA;  nullPsbData: PsbData = LOOPHOLE[0];  nullShortControlLink: PrincOps.ShortControlLink = LOOPHOLE[0];  wordsPerPage: CARDINAL = Environment.wordsPerPage;  maxPSBs: CARDINAL = PsbIndex.LAST - PsbIndex.FIRST + 1;  -- Check that Process.Priority same as PSB.Priority:  priorityFirstsAreSame: BOOLEAN[TRUE..TRUE] = (Process.Priority.FIRST = PSB.Priority.FIRST);  priorityLastsAreSame: BOOLEAN[TRUE..TRUE] = (Process.Priority.LAST = PSB.Priority.LAST);  -- Check that Process.Ticks same as PSB.Ticks:  ticksFirstsAreSame: BOOLEAN[TRUE..TRUE] = (Process.Ticks.FIRST = PSB.Ticks.FIRST);  ticksLastsAreSame: BOOLEAN[TRUE..TRUE] = (Process.Ticks.LAST = PSB.Ticks.LAST);  collisionTimeout: PSB.Ticks =  -- value to use if client    PSB.NoTimeout + 1;  -- wants timeout numerically equal to NoTimeout.  noCollisionOverflow: BOOLEAN[TRUE..TRUE] = (PSB.NoTimeout # PSB.Ticks.LAST);  -- Values for localFrame.LocalWord.available:  FrameStateAlive: CARDINAL = 0;  FrameStateDead: CARDINAL = 1;  ProcState: PROCEDURE [psbh: PsbHandle] RETURNS [ProcessState] = INLINE {    -- for access to ProcessState field.    RETURN[LOOPHOLE[pda[psbh].flags.available, ProcessState]]};  -- VARIABLES:    -- Queues of processes which are..  rebirth: CONDITION;  -- ..unused.  frameReady: CONDITION;  -- ..parents waiting to rejoin their child.  frameTaken: CONDITION;  -- ..children waiting to rejoin their parent.  dead: CONDITION;  -- ..parents waiting for their child to clean up.  processLock: MONITORLOCK;  busyLevels: WORD;  -- bit-mask of busy naked-notify levels (numbered right-to-left)  deadFrame: PrincOps.LocalFrameHandle ¬ NIL;  -- the top-level frame of a  -- detached process which needs to be freed.  -- storage properly aligned to be pointed at by an indirect control link.  ProcOverlayingPort: TYPE = RECORD [    proc: PROCEDURE [], fill: LONG CARDINAL ¬ 0];  -- This used to be a PORT, but MDS relief forces it to be in the mds  -- seems easiest to allocate it from a local frame.  linkageToEndTarget: PrincOps.PortHandle ¬ Frame.Alloc[0] - 2; -- align 2 mod 4    countInitialStateVectorPool: --Environment.PageCount--CARDINAL;  Bug: PRIVATE SIGNAL [type: BugType] = CODE;  -- (usually raised as error)  BugType: TYPE = {    insufficientMappedPDA, noMoreNakedNotifyLevels, noSuchCondition,    orphaningStateVector, outOfRealMemory,    outOfUnmappedMemory, tooManyProcesses};       --~~~~~~~~~~~~ Initialization ~~~~~~~~~~~~  InitializeProcessesA: PUBLIC --RuntimePrograms.-- PROCEDURE [    pageUnusedRealMemory: Environment.PageNumber,    countUnusedRealMemory: Environment.PageCount] =    BEGIN    pagePDA: Environment.PageNumber = Environment.PageFromLongPointer[PDA];    countMaxPDA: --Environment.PageCount--CARDINAL =      CARDINAL[Space.PagesFromWords[maxPSBs*ProcessStateBlock.SIZE]];    pageNextUnusedRealMemory: Environment.PageNumber ¬ pageUnusedRealMemory;    countRemainingUnusedRealMemory: Environment.PageCount ¬      countUnusedRealMemory;    pageLastUnmappedRealMemory: Environment.PageNumber ¬      pageUnusedRealMemory + countUnusedRealMemory - 1;    countRemainingUnmappedRealMemory: Environment.PageCount ¬      countUnusedRealMemory;        AlignUp: PROC [unaligned, modulus: UNSPECIFIED]      RETURNS [aligned: UNSPECIFIED] = INLINE {      RETURN[((unaligned + modulus - 1)/modulus)*modulus]};    AlignDown: PROC [unaligned, modulus: UNSPECIFIED]      RETURNS [aligned: UNSPECIFIED] = INLINE {      RETURN[unaligned - unaligned MOD modulus]};    AssureMapped: PROC [page: Environment.PageNumber] =      BEGIN      state: PageMap.State; real: PageMap.RealPageNumber;      IF PageMap.IsMapped[page] THEN RETURN;      DO        IF countRemainingUnusedRealMemory = 0 THEN ERROR Bug[outOfRealMemory];        [state, real] ¬ PageMap.GetState[pageNextUnusedRealMemory];	IF state.flags # PageMap.flagsVacant THEN	  BEGIN	  PageMap.SetMapFlags[	    virtual: page, real: real, flags: PageMap.flagsClean];	  PageMap.SetMapFlags[	    virtual: pageNextUnusedRealMemory, real: TRASH, flags: PageMap.flagsVacant];	  RETURN;  -- It is harmless not to update page and count here.	  END;	pageNextUnusedRealMemory ¬ pageNextUnusedRealMemory.SUCC;	countRemainingUnusedRealMemory ¬ countRemainingUnusedRealMemory.PRED;	ENDLOOP;      END;  --AssureMapped--    AssureUnmapped: PROC [page: Environment.PageNumber] =      -- TEMP while MakeBoot maps pda.      BEGIN      state: PageMap.State; real: PageMap.RealPageNumber;      [state, real] ¬ PageMap.GetState[page];      IF state.flags = PageMap.flagsVacant THEN RETURN;      DO        IF countRemainingUnmappedRealMemory = 0 THEN	  ERROR Bug[outOfUnmappedMemory];        IF PageMap.IsVacant[pageLastUnmappedRealMemory] THEN	  BEGIN	  PageMap.SetMapFlags[	    virtual: pageLastUnmappedRealMemory, real: real, flags: PageMap.flagsClean];	  PageMap.SetMapFlags[	    virtual: page, real: TRASH, flags: PageMap.flagsVacant];	  RETURN;  -- It is harmless not to update page and count here.	  END;	pageLastUnmappedRealMemory ¬ pageLastUnmappedRealMemory.PRED;	countRemainingUnmappedRealMemory ¬	  countRemainingUnmappedRealMemory.PRED;	ENDLOOP;      END;  --AssureUnmapped--    -- Begin main text of InitializeProcessesA    countPDA: --Environment.PageCount--CARDINAL = CARDINAL[Space.PagesFromWords[      (StartPsb + StoragePrograms.startList.nProcesses)      * ProcessStateBlock.SIZE]];    totalPsbs: CARDINAL = (countPDA*wordsPerPage) / ProcessStateBlock.SIZE;    rStartPsb: PsbHandle = PrOp.HandleFromIndex[StartPsb];        DisableTimeout[@dead];    DisableAborts[@dead];    DisableTimeout[@frameReady];    DisableAborts[@frameReady];    DisableTimeout[@frameTaken];    DisableAborts[@frameTaken];    DisableTimeout[@rebirth];    DisableAborts[@rebirth];    SDDefs.SD[SDDefs.sProcessTrap] ¬ LOOPHOLE[ProcessTrap];    SDDefs.SD[SDDefs.sFork] ¬ LOOPHOLE[Fork];    SDDefs.SD[SDDefs.sJoin] ¬ LOOPHOLE[Join];    -- Map the Process Data Area:    BEGIN    IF StoragePrograms.startList.nProcesses > maxPSBs THEN      ERROR Bug[tooManyProcesses];    FOR page: Environment.PageNumber IN [pagePDA..pagePDA+countPDA) DO      AssureMapped[page] ENDLOOP;    FOR page: Environment.PageNumber IN [pagePDA+countPDA..pagePDA+countMaxPDA) DO      AssureUnmapped[page] ENDLOOP;  -- TEMP until MakeBoot does not map the pda.    END;  -- Significant part of PDA is now mapped.    -- Initialize the FaultVector:    FOR flt: FaultIndex IN FaultIndex DO      pda.fault[flt] ¬ [        queue: [tail: PsbNull],        condition: [tail: PsbNull, abortable: FALSE, wakeup: FALSE]];      ENDLOOP;    pda.count ¬ totalPsbs - StartPsb;        -- Initialize common fields of all psbs:    FOR psbi: PsbIndex IN [StartPsb..StartPsb + pda.count) DO      pda.block[psbi] ¬ ProcessStateBlock[      link: [        failed: FALSE, priority: FIRST[Priority], next: TRASH,	permanent: FALSE, preempted: FALSE],      flags: [        available: --TRASH--0,        cleanup: PsbNull, waiting: FALSE, abort: FALSE],      context: TRASH,      timeout: NoTimeout,      mds: ProcessOperations.ReadMDS[],      data: nullPsbData,      sticky: 0];      ENDLOOP;    -- Initialize first PSB to describe self - detached:    linkageToEndTarget­ ¬ LOOPHOLE[ProcOverlayingPort[End]];    pda[rStartPsb].link.next ¬ StartPsb;    pda[rStartPsb].flags.available ¬      LOOPHOLE[ProcessState[state: alive, detached: TRUE]];    -- Note that someone must have previously set the return link    -- of the topmost frame to PrincOps.NullFrame.    FOR root: PrincOps.LocalFrameHandle ¬ Frame.MyLocalFrame[],      Frame.ReadReturnLink[root].frame DO      IF Frame.ReadReturnLink[root].frame = PrincOps.nullLocalFrame THEN {        Frame.WriteReturnLink[	  lf: root, cl: [indirect[link[LOOPHOLE[linkageToEndTarget]]]]];	EXIT};      ENDLOOP;    PrOp.WritePSB[rStartPsb];  -- tell the processor.    pda.ready ¬ Queue[tail: StartPsb];    -- Put rest of PSBs into free pool:  (chained off "rebirth" condition)    -- The free list is set so that each successive new process created    -- will have a lower PsbIndex, thus causing the most-recently-created    -- processes to be listed first by CoPilot.    BEGIN    firstFree: PsbIndex = StartPsb + 1;    lastFree: PsbIndex = StartPsb + pda.count - 1;    LOOPHOLE[rebirth, ConditionVariable].condition.tail ¬ PsbNull;    FOR psbi: PsbIndex IN [firstFree..lastFree] DO      pda.block[psbi].link.next ¬ IF psbi = firstFree THEN lastFree ELSE psbi - 1;      -- Tell CoPilot that process is not in use:      LOOPHOLE[pda.block[psbi].flags.available, ProcessState].state ¬ dead;      REPEAT        FINISHED =>          LOOPHOLE[rebirth, ConditionVariable].condition.tail ¬ firstFree;      ENDLOOP;    END;  --Put rest of PSBs into free pool--    -- Map and allocate StateVector pool:    BEGIN    alignmentStateVector: CARDINAL = 4;  -- (a D0 requirement)    sizeStateVector: CARDINAL = AlignUp[      MAX[SIZE[PrincOps.StateVector], StoragePrograms.startList.stateVectorSize],      alignmentStateVector];    svPool: PDABase RELATIVE POINTER TO PrincOps.StateVector =      LOOPHOLE[countMaxPDA * wordsPerPage];    rState: PDABase RELATIVE POINTER TO PrincOps.StateVector ¬ svPool;    FOR pri: PSB.Priority IN PSB.Priority DO      pda.state[pri] ¬ PSB.NullStateVectorHandle;      THROUGH [0..StoragePrograms.startList.stateVectorCounts[pri]) DO        AssureMapped[Environment.PageFromLongPointer[@pda[rState]]];        pda[rState].stk[0] ¬ pda.state[pri];  -- chain onto list.        pda.state[pri] ¬ rState;        rState ¬ rState + sizeStateVector;        ENDLOOP;      ENDLOOP;    -- Use any remainder of the last page for priorityNormal:    WHILE PageMap.IsMapped[Environment.PageFromLongPointer[@pda[rState]]]    AND LOOPHOLE[rState, CARDINAL]+sizeStateVector MOD wordsPerPage      <= wordsPerPage DO      pda[rState].stk[0] ¬ pda.state[ProcessPriorities.priorityClient];      pda.state[ProcessPriorities.priorityClient] ¬ rState;      rState ¬ rState + sizeStateVector;      ENDLOOP;        countInitialStateVectorPool ¬ (rState+wordsPerPage-1 - svPool)/wordsPerPage;    END;  --Allocate StateVector pool--    -- Initialize naked-notify allocator:    busyLevels ¬ ProcessorFace.reservedNakedNotifyMask;    ProcessOperations.WriteWDC[0];  -- start interrupts.    END;  --InitializeProcessesA--  InitializeProcessesB: PUBLIC --RuntimePrograms.-- PROCEDURE [] =    BEGIN    pagePDA: Environment.PageNumber = Environment.PageFromLongPointer[PDA];    countMaxPDA: --Environment.PageCount--CARDINAL =      CARDINAL[Space.PagesFromWords[maxPSBs*ProcessStateBlock.SIZE]];    StoragePrograms.OutlawInterval[      [page: pagePDA, count: countMaxPDA], Space.unknownUsage,      partiallyOrSometimesMapped];    StoragePrograms.OutlawInterval[      [page: pagePDA+countMaxPDA, count: countInitialStateVectorPool],      Space.unknownUsage, alwaysWhollyMapped];    END;  --~~~~~~~~~~ EXTERNAL Procedures ~~~~~~~~~~  DisableAborts: PUBLIC  --EXTERNAL--    PROCEDURE [pCondition: LONG POINTER TO CONDITION] = {    LOOPHOLE[pCondition­, ConditionVariable].condition.abortable ¬ FALSE};  DisableTimeout: PUBLIC  --EXTERNAL--    PROCEDURE [pCondition: LONG POINTER TO CONDITION] = {    pCondition.timeout ¬ NoTimeout};  EnableAborts: PUBLIC  --EXTERNAL--    PROCEDURE [pCondition: LONG POINTER TO CONDITION] = {    LOOPHOLE[pCondition­, ConditionVariable].condition.abortable ¬ TRUE};  GetCurrent: PUBLIC --EXTERNAL-- PROCEDURE RETURNS [psbHandle: PROCESS ¬ TRASH] = {    RETURN[ProcessInternal.GetCurrent[]]};  GetPriority: PUBLIC --EXTERNAL since atomic action-- PROCEDURE[]    RETURNS [priority: Process.Priority] = {    RETURN[ProcessInternal.GetPriority[]]};  InitializeCondition: PUBLIC  --EXTERNAL-- PROCEDURE [   condition: LONG POINTER TO CONDITION, ticks: Process.Ticks] =   BEGIN   LOOPHOLE[condition­, ConditionVariable] ¬ [     condition: [tail: PsbNull, abortable: FALSE, wakeup: FALSE],     timeout: IF ticks = NoTimeout THEN collisionTimeout ELSE ticks];   END;  InitializeMonitor: PUBLIC  --EXTERNAL--    PROCEDURE [pMonitor: LONG POINTER TO MONITORLOCK] = {    LOOPHOLE[pMonitor­, PSB.Monitor] ¬ UnlockedEmpty};  MsecToTicks: PUBLIC --EXTERNAL-- PROCEDURE [ms: Process.Milliseconds]    RETURNS [Process.Ticks] = {    RETURN[      (IF ms >=       LAST[Process.Milliseconds] - (ProcessorFace.millisecondsPerTick - 1) THEN       LAST[Process.Milliseconds]  -- (avoid overflow)       ELSE         ms + ProcessorFace.millisecondsPerTick -           1)/ProcessorFace.millisecondsPerTick]};  ProcessTrap: --EXTERNAL-- PROCEDURE RETURNS [BOOLEAN] =    -- (called when an process with an abort pending attempts to reenter its monitor.)    BEGIN    PLockFromStackedWords: PROCEDURE [firstOnStack, secondOnStack: WORD]      RETURNS [LONG POINTER TO MONITORLOCK] = MACHINE CODE {};    d: RECORD [  -- keeps state vector away from local zero.      pAborteeLock: LONG POINTER TO MONITORLOCK,      abortee: PrincOps.LocalFrameHandle,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack. Must be first.    d.pAborteeLock ¬ PLockFromStackedWords[d.state.stk[0], d.state.stk[1]];    -- Acquire abortee's monitor lock:    UNTIL PrOp.Enter[d.pAborteeLock] DO ENDLOOP;    d.abortee ¬ Frame.GetReturnFrame[];    Frame.WritePC[  -- skip MonitorEntry instruction.      lf: d.abortee, pc: [Frame.ReadPC[d.abortee] + 2]];     pda[PrOp.ReadPSB[]].flags.abort ¬ FALSE;    ERROR ABORTED;    -- if ABORTED is made resumable, we should return [monitorEntered: TRUE]    -- as the result of the MonitorEnter instruction that got us here.    END;  --ProcessTrap--  SetPriority: PUBLIC --EXTERNAL-- PROCEDURE [p: Process.Priority] = {    ProcessInternal.SetPriority[p]};  SecondsToTicks: PUBLIC  --EXTERNAL--    PROCEDURE [sec: CARDINAL] RETURNS [Process.Ticks] =    BEGIN    ticks: Environment.Long = [      lc[      (LONG[sec]*LONG[1000] + ProcessorFace.millisecondsPerTick -         1)/ProcessorFace.millisecondsPerTick]];    RETURN[IF ticks.highbits ~= 0 THEN LAST[Ticks] ELSE ticks.lowbits]    END;  SetTimeout: PUBLIC --EXTERNAL-- PROCEDURE [    condition: LONG POINTER TO CONDITION, ticks: Process.Ticks] = {    condition.timeout ¬ IF ticks = NoTimeout THEN collisionTimeout ELSE ticks};  TicksToMsec: PUBLIC --EXTERNAL-- PROCEDURE [ticks: Ticks]    RETURNS [Process.Milliseconds] = {    RETURN[      IF ticks > LAST[Process.Milliseconds]/ProcessorFace.millisecondsPerTick THEN      LAST[Process.Milliseconds] ELSE ticks*ProcessorFace.millisecondsPerTick]};  Yield: PUBLIC --EXTERNAL-- PROCEDURE = {ProcessInternal.Yield[]};  --~~~~~~~~~~~~ ENTRY Procedures ~~~~~~~~~~~~  Abort: PUBLIC ENTRY PROCEDURE [process: PROCESS] =    BEGIN    priorityPrev: Process.Priority;    h: PsbHandle = ValidProcess[process];    IF h = NullPsbHandle THEN      RETURN WITH ERROR InvalidProcess[process];    priorityPrev ¬  -- (high priority gets interrupts enabled soonest)      VM.GuardStateVector[Process.Priority.LAST];    -- DO NOT CALL ANY PROCEDURES WHILE AT THIS PRIORITY! (only inlines)    ProcessOperations.DisableInterrupts[];  -- (also stops    --     ProcessTimeoutCounter from ticking.)    IF ProcState[h].state = alive THEN      BEGIN      pda[h].flags.abort ¬ TRUE;      IF pda[h].flags.waiting THEN        BEGIN  -- Wake the abortee up..        pda[h].flags.waiting ¬ FALSE;        pda[h].timeout ¬ NoTimeout;	<< The Requeue allows the abortee to run - with interrupts disabled!	  Since we have guarded our state vector, we are assured of getting	  to run again, and since we are at the highest priority, we will	  run soon when we will reenable interrupts. >>        PrOp.Requeue[NIL, @pda.ready, h];	END;      END;  --alive--    ProcessOperations.EnableInterrupts[];    VM.DoneWithStateVector[priorityPrev];    END;  --Abort--  AbortPending: PUBLIC PROCEDURE [] RETURNS [abortPending: BOOLEAN] =    {RETURN      [pda[PrOp.ReadPSB[]].flags.abort]};  AllocateNakedCondition: PUBLIC --SpecialRuntime.-- ENTRY PROC[]    RETURNS [cv: LONG POINTER TO CONDITION, mask: WORD] =    BEGIN    FOR level: InterruptLevel IN InterruptLevel DO      mask ¬ Inline.BITSHIFT[1, LAST[InterruptLevel] - level];      IF Inline.BITAND[mask, busyLevels] = 0 THEN        BEGIN        busyLevels ¬ Inline.BITOR[busyLevels, mask];        cv ¬ LOOPHOLE[@pda.interrupt[level]];        RETURN;        END;      ENDLOOP;    ERROR Bug[noMoreNakedNotifyLevels];    END;  CancelAbort: PUBLIC ENTRY PROCEDURE [process: PROCESS] =    BEGIN    h: PsbHandle;    IF (h ¬ ValidProcess[process]) = NullPsbHandle THEN      RETURN WITH ERROR InvalidProcess[process];    ProcessOperations.DisableInterrupts[];    IF ProcState[h].state = alive THEN pda[h].flags.abort ¬ FALSE;    ProcessOperations.EnableInterrupts[];    END;  DeallocateNakedCondition: PUBLIC --SpecialRuntime.-- PROC [    cv: LONG POINTER TO CONDITION] =    BEGIN    FOR level: InterruptLevel IN InterruptLevel DO      mask: WORD ¬ Inline.BITSHIFT[1, LAST[InterruptLevel] - level];      IF cv = LOOPHOLE[@pda.interrupt[level], LONG POINTER TO CONDITION] THEN        BEGIN        busyLevels ¬ Inline.BITAND[busyLevels, Inline.BITNOT[mask]];        pda.interrupt[level].condition.tail ¬ PsbNull;        RETURN;        END;      ENDLOOP;    ERROR Bug[noSuchCondition];    END;  Detach: PUBLIC ENTRY PROCEDURE [process: PROCESS] =    BEGIN    h: PsbHandle;    IF (h ¬ ValidProcess[process]) = NullPsbHandle THEN      RETURN WITH ERROR InvalidProcess[process];    LOOPHOLE[pda[h].flags.available, ProcessState].detached ¬ TRUE;    BROADCAST frameTaken;  -- wake child if waiting to JOIN.    END;  End: --"ENTRY"-- PROCEDURE =    -- When the top context of a process "returns", it Xfers to    --   this procedure with its results on the stack.    BEGIN    d: RECORD [      reservedForTrapParams: LONG CARDINAL,      results: dst PrincOps.StateVector];    myFrame: PrincOps.LocalFrameHandle;    lw: PrincOps.LocalWord;    h: PsbHandle;    d.results ¬ STATE;  -- save stack containing returned results.    myFrame ¬ Frame.MyLocalFrame[];    lw ¬ Frame.ReadLocalWord[myFrame];    lw.available ¬ FrameStateAlive;    Frame.WriteLocalWord[lf: myFrame, word: lw];    h ¬ PrOp.ReadPSB[];    IF pda[h].link.permanent THEN  --      SIGNAL Bug[orphaningStateVector];  -- proceedable    UNTIL PrOp.Enter[@processLock] DO NULL ENDLOOP;    LOOPHOLE[pda[h].flags.available, ProcessState].state ¬ frameReady;    pda[h].flags.abort ¬ FALSE;  -- too late for Aborts: they no-op    PrOp.Broadcast[@frameReady];  -- wake any parent process waiting to Join.    -- Wait till this process is Detached or Joined:    UNTIL ProcState[h].state = frameTaken OR ProcState[h].detached DO      PrOp.Wait[        @processLock, @frameTaken, NoTimeout];      UNTIL PrOp.ReEnter[@processLock, @frameTaken] DO NULL ENDLOOP;      ENDLOOP;    FreeOrphanFrame[];    IF ProcState[h].detached THEN  --      deadFrame ¬ myFrame;  -- If detached, leave our frame for freeing.    lw ¬ Frame.ReadLocalWord[myFrame];    lw.available ¬ FrameStateDead;  -- tell Joiner that we're done.    Frame.WriteLocalWord[lf: myFrame, word: lw];    LOOPHOLE[pda[h].flags.available, ProcessState].state ¬ dead;    PrOp.Broadcast[@dead];  -- tell parent our frame has been left for freeing.    PrOp.Wait[@processLock, @rebirth, NoTimeout];    -- This process is dead.  Its PSB sits in the rebirth queue until    -- it is recycled into a new process by Fork.    -- Our current frame however, has one of two fates:    -- (a) If this process was detached, the frame will simply be freed    -- by the next process that finishes ("deadFrame").    -- (b) if this process is being Joined, the parent process will    -- have acquired a pointer to our frame.  The JOIN code will Xfer    -- to our frame and the code below will be executed    -- BY THE PARENT PROCESS.  The parent process therefore    -- MUST BE RUNNING IN THE SAME MDS as the child process!    UNTIL PrOp.ReEnter[@processLock, @rebirth] DO NULL ENDLOOP;    PrOp.Exit[@processLock];    STATE ¬ d.results;  -- Reload returned results into stack.    RETURN;  -- Return to parent. (Join[] set my return link to parent.)    END;  --End--  Fork: --"ENTRY"-- PROCEDURE [ --argsForChild,-- rootProcedure: PrincOps.ControlLink]    RETURNS [child: PROCESS ¬ TRASH] =    BEGIN    PForkFrame: TYPE = POINTER TO FRAME[Fork];    childPsb: PsbIndex;    identity: {parent, child};    ChildBuilder: PROC [childPsb: PsbIndex] RETURNS[ --MUST BE NULL!-- ] =      -- Must be nested proc to have accesss to PForkFrame.      BEGIN      pChild: LONG POINTER TO ProcessStateBlock ¬ @pda.block[childPsb];      lf: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];      parentFrame: PForkFrame = LOOPHOLE[lf];      fsi: FrameSizeIndex = Frame.ReadLocalWord[lf].fsi;      childFrame: PForkFrame = Frame.Alloc[fsi];      Inline.COPY[        from: parentFrame, to: childFrame,        nwords: RuntimeInternal.FrameSize[fsi] - SIZE[PrincOps.LocalOverhead]];      FrameExtras.WriteGlobalLink[lf: LOOPHOLE[childFrame],         gftH: FrameExtras.ReadGlobalLink[lf]];      Frame.WriteReturnLink[lf: LOOPHOLE[childFrame], cl: nullShortControlLink];      Frame.WritePC[lf: LOOPHOLE[childFrame], pc: Frame.ReadPC[lf]];      childFrame.identity ¬ child;      -- Initialize the volatile fields of the psb:      pChild.link.priority ¬ pda[PrOp.ReadPSB[]].link.priority;      pChild.context ¬ [frame[LOOPHOLE[childFrame, PrincOps.LocalFrameHandle]]];      pChild.data ¬ nullPsbData;      pChild.sticky ¬ 0;      pChild.flags.available ¬  -- do this last for debugger's sake        LOOPHOLE[ProcessState[state: alive, detached: FALSE]];      PrOp.Notify[@rebirth];  -- starts the new process executing.  Its PC      -- is set to begin execution at the instruction after the call      -- to ChildBuilder.  Its stack is empty.  Therefore,      -- ChildBuilder MUST NOT RETURN ANY RESULTS!      END;  --ChildBuilder--        -- Begin main text of ForkInternal:    argsForChild: dst PrincOps.StateVector;    << The following must be the first instruction of the procedure so as    to save the args for the child proc and get them off our stack.    However, it is not the first instruction! Mesa has already popped rootProcedure    off the stack, and in addition initialized a hidden procedure variable    used to call ChildBuilder. It so happens that this code is exactly    at the brink of overflowing the stack. If anything changes, we may have to    reorganize this proc to avoid a stack overflow.>>    argsForChild ¬ STATE;  -- must be first instn!         identity ¬ parent;    UNTIL PrOp.Enter[@processLock] DO NULL ENDLOOP;    FreeOrphanFrame[];  -- convenient place to do this.    IF LOOPHOLE[rebirth, ConditionVariable].condition.tail = PsbNull THEN {      PrOp.Exit[@processLock]; ERROR TooManyProcesses};    childPsb ¬ pda.block[  --      -- walk to tail, then to head. MUST be head (see Notify above).      LOOPHOLE[rebirth, ConditionVariable].condition.tail].link.next;    [] ¬ ChildBuilder[childPsb];    -- Both parent and child processes will execute the following code:    SELECT identity FROM      parent => {  -- return child handle to FORKing parent.        PrOp.Exit[@processLock];	ProcessInternal.Yield[];  -- give the kid a shot.	RETURN[PrOp.ProcessFromIndex[childPsb]]};      child =>        BEGIN	sourceDest: RuntimeInternal.SourceDest;        -- Set child's top context to call End when it returns:	sourceDest.source ¬ [indirect[link[LOOPHOLE[linkageToEndTarget]]]];        sourceDest.dest ¬ rootProcedure;        STATE ¬ argsForChild;  -- must be next-to-last.        RETURN WITH sourceDest;  -- "call" root procedure of child. Must be last.        END;      ENDCASE;    END;  --Fork--  Join: ENTRY PROCEDURE [process: PROCESS]    RETURNS [PrincOps.ControlLink.frame ¬ TRASH] =    BEGIN    -- calling sequence is KFCB sJOIN; SFC;  i.e. the JOINer will    -- immediately transfer to the result of this procedure.    h: PsbHandle;    frame: PrincOps.LocalFrameHandle;    IF (h ¬ ValidProcess[process]) = NullPsbHandle THEN      RETURN WITH ERROR InvalidProcess[process];    -- Wait till process ready to be joined:    WHILE ProcState[h].state ~= frameReady DO WAIT frameReady ENDLOOP;    -- Guaranteed to be a dying frame by the time we get here.    frame ¬ pda[h].context.frame;    LOOPHOLE[pda[h].flags.available, ProcessState].state ¬ frameTaken;    BROADCAST frameTaken;  -- tell child process we've got his frame.    -- Wait till he has finished cleaning up:    WHILE Frame.ReadLocalWord[frame].available ~= FrameStateDead DO      WAIT dead ENDLOOP;    -- At this point, we (the parent process)  have acquired responsibility    -- for the child's frame.  IT MUST BE IN THE SAME MDS AS THE PARENT.     Frame.WriteReturnLink[lf: frame, cl: Frame.GetReturnLink[]];  -- We use the child frame's    -- return link as a mailbox to pass to the child's frame the address    -- of the JOINer's frame, which the child should return to.    RETURN[[frame[frame]]];    -- JOINer will next Xfer to "frame", which will reload the    -- results into the stack and return them to the JOINer.    END;  --Join--  Pause: PUBLIC ENTRY PROC [ticks: Process.Ticks] =    BEGIN    ENABLE ABORTED => GO TO Aborted;    c: CONDITION;    SetTimeout[@c, ticks];    EnableAborts[@c];    WAIT c;    EXITS Aborted => RETURN WITH ERROR ABORTED;    END;  ValidateProcess: PUBLIC ENTRY PROCEDURE [p: PROCESS] = {    IF ValidProcess[p] = NullPsbHandle THEN RETURN WITH ERROR InvalidProcess[p]};  --~~~~~~~~~~~~ INTERNAL Procedures ~~~~~~~~~~~~  FreeOrphanFrame: --INTERNAL-- PROCEDURE [] = INLINE {    -- Frees any frame left over from a previous dead detached process.    IF deadFrame # NIL THEN {Frame.Free[deadFrame]; deadFrame ¬ NIL}};  ValidProcess: INTERNAL PROCEDURE [p: PROCESS]    RETURNS [h: PsbHandle] =    -- returns NullPsbHandle if invalid.    BEGIN    index: PsbIndex ¬ PrOp.IndexFromProcess[p];    h ¬ PrOp.HandleFromIndex[index];    IF index ~IN [StartPsb..StartPsb + pda.count)    OR ProcState[h].state IN [frameTaken..dead] THEN      h ¬ NullPsbHandle;    FreeOrphanFrame[];  -- convenient place to do this.    END;  END.LOG   (For earlier log entries, please see Mesa 10.0 archive version.)14-Jan-82 13:43:09   JGS	Implement Fork12, ForkInternal. 2-Mar-82 14:07:44   CAJ 	Make SetPriority use ProcessInternal.SetPriority.11-Mar-82 12:35:09   JGS	Fix ar 10744: ForkInternal.argsForChild.instByte ¬ 0. 7-Sep-82 10:44:07   WDK       AR 8717: Processes.ForkInternal should set child return link to NIL. Also, use GetCurrent, GetPriority, and Yield in ProcessInternal.22-Dec-82 14:49:25   AWL      	Long page numbers. 2-Mar-83 14:43:49   WDK     	Abort could deadlock on state vector. 1-Apr-83 13:30:12   AWL      	Implement AbortPending.11-Apr-83 11:22:05   JXP   	Don't use obsolete SDExtra interface. 5-May-83 11:02:56   WDK        Abort must guard state vector since Requeue does a Reschedule..13-Jul-83 12:36:02   WDK        PrincOps changes: Fork12 disappears; Fork and ForkInternal merged. timeout vector disappears. Get info directly from startlist. Map pda if it is not mapped already. Allocate state vectors in separate page, leave vm for max number of psbs.28-Jul-83 15:17:56   WDK        Ditch multiple blanket OPENs.13-Jul-83 17:44:02   RXJ     	?28-Jul-83 17:38:56   WDK        AssureMapped used wrong variables. Public proc take arg of type PROCESS. ValidProcess out of line savees 120 bytes.  Utilize all of last state vector page. Free orphan frame more often. Initialize common fields of al psbs in initialization, not in Fork. Holler if orphaning state vector. Let child run first. 3-Aug-83 13:46:24   WDK     	pageLastUnmappedRealMemory.PRED, not SUCC. 3-Aug-83 15:19:53   WDK     	Page boundary problem.15-Aug-83 20:52:34   RXJ     	Join must return ControlLink.18-Aug-83  9:39:08   WDK        Add warning about how close Fork is to stack overflow. Change GetCurrent to RETURNS [PROCESS ¬ TRASH] to bum out unwanted initialization.18-Aug-83  9:39:41   RXJ     	??? 9-Dec-83  9:56:07   WDK     	Abort shouldn't keep interrupts disabled for long. 1-Jul-86 13:38:18   MEW	Updated to new princops. Only changes were in ChildBuilder.18-Aug-86 19:19:53   ET		Moved PORTs from global frames to local frames.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- SwapBufferImpl.mesa    27-Sep-85 10:13:58 by RSV    -- Implementation notes:---- This implementation allocates buffers from a statically allocated pool of buffers. The buffers in the pool have assorted sizes; they are collectively referred to as "main buffers".---- To prevent deadlocks, SwapBufferImpl must always be able to allocate at least a one-page buffer without waiting for any buffers to become free. In order to be able to satisfy this requirement, this implementation has a pool of a large number of one-page "backup buffers". The number of backup buffers must be large enough so that the pool NEVER becomes exhausted.---- SwapBufferImpl must always be able to allocate a buffer of the requested size if the caller is willing to wait for it. This requirement can be satisfied by having a buffer big enough to contain all of the pages of real memory. On a Dorado however, this is an unacceptable amount of virtual memory to reserve. Also, the size of virtual memory on a Dandelion is a somewhat scarce resource. Therefore, SwapBufferImpl restricts the maximum size of a buffer to a size less than the size of real memory. Clients must restrict their requests accordingly. This is acceptable because "Attempting to read in a swap unit, either by an explicit operation on that swap unit or by a reference to a page of virtual memory contained in the swap unit, may have a severe negative impact on system performance if the swap unit is a substantial fraction of real memory size. Clients should ensure that map units are divided into swap units of manageable size. As a general rule, a swap unit should not exceed one-tenth the size of real memory." ++ from the Space functional specification.-- PERFORMANCE TUNING:-- The ideal composition of the main buffer pool should be determined by performance experimentation.-- THINGS TO CONSIDER:---- Consider making layout of main buffer pool dependent on size of real memory.-- Consider making the number of backup buffers dependent on number of processes the system was configured for.DIRECTORY  SwapBuffer USING [maxBufferSize, SizeRequirement],  Environment USING [PageCount, PageNumber],  PageMap USING [IsMapped],  KernelSpaceUsage USING [swapBuffer],  RuntimeInternal USING [Bug],  StoragePrograms USING [AllocateVM],  VM USING [Interval],  VMInternal USING [],  VMPerf USING [BatchCount];SwapBufferImpl: MONITOR  IMPORTS PageMap, RuntimeInternal, StoragePrograms  EXPORTS SwapBuffer, VMPerf, VMInternal =  BEGIN  -- Parameters:  countMainBuffers: CARDINAL = 16;  defaultMainBufferSize: ARRAY MainBufferIndex OF BufferSize = [    -- The count and sizes of the main buffers should be determined by performance experiments. This has not been done yet.    1, 1, 1, 1, 2, 2, 4, 4, 8, 8, 16, 16, 32, 64, 128, LAST[BufferSize]];  countBackupBuffers: CARDINAL = 100;  -- The number of buffers required is limited to the number of processes which simultaneously attempt to perform I/O, which is <= the number of processes in the system, which is always <= 1024. At present, we have less than 1024 buffers in order to conserve virtual memory. If the system crashes with all backup buffers exhausted, double countBackupBuffers and try again.   -- Performance data:  --VMPerf.-- swapBufferTotalAllocations: PUBLIC LONG CARDINAL ¬ 0;  --VMPerf.-- swapBufferEmergencyAllocations: PUBLIC CARDINAL ¬ 0;  -- occurrences indicate suboptimal layout of main buffer pool.  --VMPerf.-- swapBufferMaxBackupsUsed: PUBLIC CARDINAL ¬ 0;  -- system crashes when > countBackupBuffers.  --VMPerf.-- swapBufferWaits: PUBLIC CARDINAL ¬ 0;  -- occurrences indicate suboptimal layout of main buffer pool.  -- Types and variables:  BufferSize: TYPE = VMPerf.BatchCount;  -- (best if fits in 15 bits)  assert: BOOLEAN [TRUE..TRUE] = (LAST[BufferSize] <= SwapBuffer.maxBufferSize);  Status: TYPE = {free, busy};  MainBuffer: TYPE = RECORD [    page: Environment.PageNumber, size: BufferSize, status: Status];  MainBufferIndex: TYPE = [0..countMainBuffers);  mainBuffer: ARRAY MainBufferIndex OF MainBuffer;  BackupBufferIndex: TYPE = [0..countBackupBuffers);  backupBufferStatus: PACKED ARRAY BackupBufferIndex OF Status;  pageBackupBuffers: Environment.PageNumber;  -- page of first backup buffer.  sizeBackupBuffer: BufferSize = 1;  -- size of each backup buffer.  mainBufferFreed: CONDITION;  backupBuffersInUse: CARDINAL ¬ 0;  BugType: TYPE = {    alreadyFree, insufficientBackupSwapBuffers, noSuchBuffer, overflow,    realMemInFreedBuffer};  InitializeSwapBuffer: PUBLIC --VMInternal.-- PROCEDURE[] =    -- StoragePrograms.AllocateVM must be operational before calling this proc.    BEGIN    bufferSize: ARRAY MainBufferIndex OF BufferSize ¬ defaultMainBufferSize;  -- allows experimentation from debugger.    pageAvailable: Environment.PageNumber;    -- Total up the vm required for all buffers:    totalVMRequired: Environment.PageCount ¬ countBackupBuffers*sizeBackupBuffer;    FOR jBuf: MainBufferIndex IN MainBufferIndex DO      totalVMRequired ¬ totalVMRequired + bufferSize[jBuf]; ENDLOOP;    pageAvailable ¬ StoragePrograms.AllocateVM[      totalVMRequired, hyperspace, KernelSpaceUsage.swapBuffer,      partiallyOrSometimesMapped];    FOR jBuf: MainBufferIndex IN MainBufferIndex DO      mainBuffer[jBuf] ¬ [        page: pageAvailable, size: bufferSize[jBuf], status: free];      pageAvailable ¬ pageAvailable + bufferSize[jBuf];      ENDLOOP;    pageBackupBuffers ¬ pageAvailable;    backupBufferStatus ¬ ALL[free];    END;  --InitializeSwapBuffer--  Allocate: PUBLIC ENTRY PROCEDURE [     count: Environment.PageCount, sizeRequirement: SwapBuffer.SizeRequirement]    RETURNS [interval: VM.Interval] =    BEGIN    swapBufferTotalAllocations ¬ SUCC[swapBufferTotalAllocations];    DO  --... UNTIL suitable buffer available--      FOR jBuf: MainBufferIndex IN MainBufferIndex DO        IF mainBuffer[jBuf].size >= count AND mainBuffer[jBuf].status = free THEN          {          mainBuffer[jBuf].status ¬ busy; RETURN[[mainBuffer[jBuf].page, count]]};        ENDLOOP;      IF sizeRequirement = exactSizeRequired THEN {        IF count > SwapBuffer.maxBufferSize THEN RuntimeInternal.Bug[BugType[overflow]];        swapBufferWaits ¬ SUCC[swapBufferWaits];        WAIT mainBufferFreed;        LOOP}  -- try again.      ELSE        BEGIN  --sizeRequirement=willTakeLess--        swapBufferEmergencyAllocations ¬ SUCC[swapBufferEmergencyAllocations];        backupBuffersInUse ¬ SUCC[backupBuffersInUse];        IF backupBuffersInUse > swapBufferMaxBackupsUsed THEN          swapBufferMaxBackupsUsed ¬ backupBuffersInUse;        FOR jBuf: BackupBufferIndex IN BackupBufferIndex DO          IF backupBufferStatus[jBuf] = free THEN {            backupBufferStatus[jBuf] ¬ busy;            RETURN[[pageBackupBuffers + jBuf, sizeBackupBuffer]]};          ENDLOOP;        RuntimeInternal.Bug[BugType[insufficientBackupSwapBuffers]];        END;      ENDLOOP;    END;  --Allocate--  Deallocate: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    -- Note that the present implementation does not use interval.count in any way.    VerifyUnmapped: PROCEDURE [unmappedInterval: VM.Interval] =      -- A local proc to simplify packaging.      -- This proc modifies its arguments.      BEGIN      WHILE unmappedInterval.count > 0 DO        IF PageMap.IsMapped[unmappedInterval.page] THEN          RuntimeInternal.Bug[BugType[realMemInFreedBuffer]];        unmappedInterval.page ¬ SUCC[unmappedInterval.page];        unmappedInterval.count ¬ PRED[unmappedInterval.count];        ENDLOOP;      END;  --VerifyUnmapped--    -- Begin main text of Deallocate --    IF interval.page IN [pageBackupBuffers..pageBackupBuffers + countBackupBuffers) THEN      BEGIN  --backup buffer--      jBuf: BackupBufferIndex = BackupBufferIndex[  --        interval.page - pageBackupBuffers];  -- (avoiding underflow)      VerifyUnmapped[[interval.page, sizeBackupBuffer]];      IF backupBufferStatus[jBuf] = free THEN        RuntimeInternal.Bug[BugType[alreadyFree]];      backupBufferStatus[jBuf] ¬ free;      backupBuffersInUse ¬ PRED[backupBuffersInUse];      END  --backup buffer--    ELSE      BEGIN  --main buffer--      FOR jBuf: MainBufferIndex IN MainBufferIndex DO        IF interval.page = mainBuffer[jBuf].page THEN {          VerifyUnmapped[[interval.page, mainBuffer[jBuf].size]];          IF mainBuffer[jBuf].status = free THEN            RuntimeInternal.Bug[BugType[alreadyFree]];          mainBuffer[jBuf].status ¬ free;          BROADCAST mainBufferFreed;          RETURN};        ENDLOOP;      RuntimeInternal.Bug[BugType[noSuchBuffer]];      END;  --main buffer--    END;  --Deallocate--  END.LOGMay 22, 1978  10:57   PXM       Created file.August 4, 1978  9:42   PXM       Allocate allocationMap locally; add initialization, condition variable.August 18, 1978  11:53   PXM       Initialization followed module END!September 7, 1978  10:42   DXR      Allow allocation/deallocation of zero-length buffers.September 8, 1978  2:00   PXM       Fix check for end of intervalBuffer in Allocate.October 5, 1979  9:03   PXM       Allocation map in heapApril 2, 1980  1:54   WDK       Add InitializeSwapBufferSeptember 23, 1980  12:15   PXM       Check that buffer is not mapped in Deallocate.December 2, 1980  12:21   AWL         Make inner loop in Allocate be DECREASING for efficiency reasons.   Make Get/Set status be Inline's.3-Nov-81 14:48:16   JGS   New Instruction Set: PageMap.GetF => PageMap.GetFlags.28-Jul-82  9:49:59   WDK       Complete rewrite; new interface, new implementation.   Now can always allocate a buffer without waiting.13-Sep-82 16:20:38   WDK       Twiddles.29-Sep-82 13:23:52   WDK        Deallocate now takes an interval.21-Dec-82 16:20:17   AWL         PilotSpaceUsage => KernelSpaceUsage.18-Feb-83 17:49:34   WDK        Handle truncation warning.27-Nov-84 11:33:07   KEK    	add "count > maxBufferSize" test to Allocate27-Sep-85 10:15:52   RSV        move "count > maxBufferSize" into check for "sizeRequirement = exactSizeRequired" in Allocate
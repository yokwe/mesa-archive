-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- SOSP83HeapMDS.mesa    29-Jun-87 16:30:19 by RSV    DIRECTORY  Environment USING [PageCount, wordsPerPage],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Error, ErrorType, NWords],  HeapExtras USING [],  Inline USING [LowHalf],  Runtime USING [GetCaller],  SOSP83HeapInternal USING [    Data, Handle, maxSegmentPages, MdsHandle, MDSProcs, MDSZoneObject,    MDSZoneRep, NodeHeader, NodeLength, NormalHandle, OwnerObject, SegmentHandle,    SegmentObject, ShortMdsHandle, UncountedZoneObject, UncountedZoneRep],  SOSP83HeapOps USING [    DeleteHeap, EnumerateLargeNodes, ExpandNormalHeap, FlushNormalHeap,    FreeNormalNode, IsNormalEmpty, MakeNormalNode, MakeSpace, MakeResidentHeap,    MakeSwappableHeap],  Space USING [    defaultSwapUnitSize, InsufficientSpace, Interval, MDS, PageCount,    SwapUnitSize],  SpecialHeap USING [],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  System USING [VolumeID],  Volume USING [systemID];SOSP83HeapMDS: MONITOR LOCKS h.lock USING h: SOSP83HeapInternal.Handle  IMPORTS    FrameExtras, Heap, SOSP83HeapOps, Inline, Runtime, Space,    SpecialRuntimeExtras, Volume  EXPORTS Heap, HeapExtras, SOSP83HeapOps, SpecialHeap =  BEGIN OPEN SOSP83HeapInternal;  systemMDSZone: PUBLIC --Heap, SOSP83HeapOps-- MDSZone;      -- initialized in InitializeHeap  -- Types  NWords: TYPE = CARDINAL;  --  -- Constants  wpp: CARDINAL = Environment.wordsPerPage;  defaultSwapUnit: Space.SwapUnitSize = Space.defaultSwapUnitSize;  mdsOverhead: CARDINAL =    Data.normal.mds.SIZE + SIZE[MDSProcs] + SegmentObject.SIZE;  ownerNameSize: CARDINAL = OwnerObject.SIZE;  -- MDS Heap implementation  CreateMDS: PUBLIC --Heap-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NodeLength,    ownerChecking, checking: BOOLEAN] RETURNS [MDSZone] =    BEGIN    RETURN[NewCreateMDS[initial, maxSize, increment, swapUnitSize, threshold,      largeNodeThreshold, ownerChecking, checking, Volume.systemID]];    END;      NewCreateMDS: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,     swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NodeLength,    ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID]    RETURNS [MDSZone] =    BEGIN    MyMake: PROCEDURE [z: MDSZone, n: CARDINAL] RETURNS [POINTER] = {      RETURN[base]};    zo: MDSZoneObject ¬ [@myProcs, NIL];    myProcs: MDSProcs ¬ [Make: MyMake, Free: NULL];    myZone: MDSZone ¬ LOOPHOLE[@zo];    h: ShortMdsHandle;    base: ORDERED POINTER;    segment: SegmentHandle;    IF initial = 0 THEN initial ¬ 1;  -- since not yet ready to extend    IF maxSize < initial THEN ERROR Heap.Error[maxSizeExceeded];    IF initial > maxSegmentPages THEN ERROR Heap.Error[insufficientSpace];    increment ¬ MIN[increment, maxSegmentPages];    base ¬ Narrow[SOSP83HeapOps.MakeSpace[      parent: Space.MDS[], pages: initial, swapUnitSize: swapUnitSize,       resident: FALSE, volumeID: volumeID !         Space.InsufficientSpace => GOTO InsufficientSpace]];    segment ¬ base + Data.normal.mds.SIZE + SIZE[MDSProcs];    segment^ ¬ [      next: NIL,      length: CARDINAL[initial*Environment.wordsPerPage - mdsOverhead],      base: LOOPHOLE[segment + SegmentObject.SIZE],      initial: TRUE];    IF base + mdsOverhead # segment.base THEN ERROR;    segment.base^ ¬ [segment.length, NIL, NIL];    h ¬ myZone.NEW[mds normal Data ¬ [      ownerChecking: ownerChecking, checking: checking, maxSize: maxSize,      currentSize: initial, increment: increment, swapUnit: swapUnitSize,      volumeID: volumeID,      v1: normal[root: segment.base, segments: segment, threshold: threshold,        largeNodeThreshold: largeNodeThreshold,	v2: mds[mzo: [procs: base + Data.normal.mds.SIZE, data: NULL]]]]];    h.mzo.procs­ ¬ MDSProcs[Make: MakeMdsNode, Free: FreeMdsNode];    h.mzo.data ¬ h;    RETURN[LOOPHOLE[@h.mzo]]    EXITS InsufficientSpace => ERROR Heap.Error[insufficientSpace]    END;  DeleteMDS: PUBLIC --Heap-- PROCEDURE [    z: MDSZone, checkEmpty: BOOLEAN] = {    OPEN rep: LOOPHOLE[z, MDSZoneRep];    IF checkEmpty THEN      IF ~IsEmptyMDS[z, rep.data] THEN ERROR Heap.Error[invalidHeap];    SOSP83HeapOps.DeleteHeap[rep.data]};  MakeMdsNode: PROCEDURE [z: MDSZone, n: NodeLength] RETURNS [p: POINTER] =    BEGIN OPEN mzr: LOOPHOLE[z, MDSZoneRep];    uz: UncountedZoneObject ¬ [procs: NULL, data: mzr.data];    p ¬ Narrow[SOSP83HeapOps.MakeNormalNode[UZ[@uz], n]];    IF mzr.data.ownerChecking THEN      BEGIN OPEN o: LOOPHOLE[p - OwnerObject.SIZE, POINTER TO OwnerObject];      o.frame ¬ FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]];      END;    END;  FreeMdsNode: PROCEDURE [z: MDSZone, p: ORDERED POINTER TO NodeHeader] =    BEGIN OPEN mzr: LOOPHOLE[z, MDSZoneRep];    uz: UncountedZoneObject ¬ [procs: NULL, data: mzr.data];    IF p = NIL THEN RETURN;    SOSP83HeapOps.FreeNormalNode[UZ[@uz], p];    END;  GetAttributesMDS: PUBLIC --Heap-- PROC [z: MDSZone]    RETURNS [      heapPages, largeNodePages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, threshold,      largeNodeThreshold: Heap.NWords, ownerChecking, checking: BOOLEAN] =    BEGIN    [heapPages: heapPages, largeNodePages: largeNodePages, maxSize: maxSize,      increment: increment, swapUnitSize: swapUnitSize, threshold: threshold,      largeNodeThreshold: largeNodeThreshold, ownerChecking: ownerChecking,      checking: checking] ¬ NewGetAttributesMDS[z];    END;      NewGetAttributesMDS: PUBLIC --HeapExtras-- PROC [z: MDSZone]    RETURNS [      heapPages, largeNodePages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize,       threshold, largeNodeThreshold: Heap.NWords,      ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID] =    BEGIN    MdsAttributes: ENTRY PROCEDURE [h: MdsHandle] = INLINE      BEGIN ENABLE UNWIND => NULL;      SpaceSize: PROCEDURE [sI: Space.Interval] =        {largeNodePages ¬ sI.count + largeNodePages};      largeNodePages ¬ 0;      SOSP83HeapOps.EnumerateLargeNodes[h, SpaceSize !        Heap.Error => {savedType ¬ type; GOTO Error};];      threshold ¬ h.threshold;      largeNodeThreshold ¬ h.largeNodeThreshold;      heapPages ¬ h.currentSize;      swapUnitSize ¬ Space.SwapUnitSize[h.swapUnit];      increment ¬ h.increment;      maxSize ¬ h.maxSize;      ownerChecking ¬ h.ownerChecking;      checking ¬ h.checking;      volumeID ¬ h.volumeID;      EXITS        Error => RETURN WITH ERROR Heap.Error[savedType];      END;    savedType: Heap.ErrorType;    MdsAttributes[LOOPHOLE[z, MDSZoneRep].data];    END;  ExpandMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone, pages: Space.PageCount] = {    OPEN mzr: LOOPHOLE[z, MDSZoneRep];    uz: UncountedZoneObject ¬ [procs: NULL, data: mzr.data];    SOSP83HeapOps.ExpandNormalHeap[UZ[@uz], LOOPHOLE[uz.data], pages]};  FlushMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone] = {    OPEN mzr: LOOPHOLE[z, MDSZoneRep];    uz: UncountedZoneObject ¬ [procs: NULL, data: mzr.data];    SOSP83HeapOps.FlushNormalHeap[UZ[@uz], LOOPHOLE[uz.data]]};  IsEmptyMDS: PUBLIC --SOSP83HeapOps-- PROCEDURE [z: MDSZone, h: MdsHandle]    RETURNS [BOOLEAN] =     BEGIN    OPEN mzr: LOOPHOLE[z, MDSZoneRep];    uz: UncountedZoneObject ¬ [procs: NULL, data: mzr.data];    RETURN[SOSP83HeapOps.IsNormalEmpty[UZ[@uz], LOOPHOLE[h, NormalHandle]]];    END;    PruneMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone] = {    --PruneMdsHeap[LOOPHOLE[z, MDSZoneRep].data]--};  CheckOwnerMDS: PUBLIC --Heap-- PROCEDURE [p: POINTER, z: MDSZone] = {    IF LOOPHOLE[z, MDSZoneRep].data.ownerChecking THEN      IF p = NIL THEN ERROR Heap.Error[invalidNode]      ELSE {OPEN pp: LOOPHOLE[p - OwnerObject.SIZE, POINTER TO OwnerObject];      IF pp.frame # FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]]        THEN ERROR Heap.Error[invalidOwner]}};        OwnerCheckingMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone] RETURNS [BOOLEAN] = {    RETURN[LOOPHOLE[z, MDSZoneRep].data.ownerChecking]};      SetCheckingMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone, checking: BOOLEAN] = {    h: MdsHandle = LOOPHOLE[z, MDSZoneRep].data;    h.checking ¬ checking};  MakeResidentMDS: PUBLIC --SpecialHeapHeap-- PROCEDURE [z: MDSZone] =    {SOSP83HeapOps.MakeResidentHeap[LOOPHOLE[z, MDSZoneRep].data]};  MakeSwappableMDS: PUBLIC PROCEDURE [z: MDSZone] =    {SOSP83HeapOps.MakeSwappableHeap[LOOPHOLE[z, MDSZoneRep].data]};  Narrow: PROCEDURE [p: LONG POINTER] RETURNS [ORDERED POINTER] = INLINE {    -- Convert a long pointer assumed to point into this mds into a short pointer.    -- recall MDS are 64K aligned    RETURN[LOOPHOLE[Inline.LowHalf[p]]]};    UZ: PROCEDURE [z: UncountedZoneRep] RETURNS [UNCOUNTED ZONE] = INLINE {    RETURN[LOOPHOLE[z]]};    END...LOG31-Jan-84  8:59:13  XXJ  Created file.27-Jun-86 13:56:36  RSV  Added log, changed _ to ¬, changed names to SOSP83*, and added checkEmpty check to DeleteMDS. 7-Nov-86 15:17:36  RSV  Added MakeResidentMDS procedure (exported to SpecialHeap)30-Dec-86 22:25:56  ???  Converted to MDS relief.10-Feb-87 17:41:33  RSV  Remade MakeResidentMDS edit (deleted during MDS relief conversion.18-Mar-87 14:40:27  RSV  Can't use PrincOps.GlobalFrameHandle.  Must use PrincOpsExtras2.GFTHandle.29-Jun-87 16:30:19  RSV  Provide support for putting backing files on other open logical volumes.
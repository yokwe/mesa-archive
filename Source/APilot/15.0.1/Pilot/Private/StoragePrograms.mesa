-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- PilotKernel>StoragePrograms.mesa    29-May-85 15:30:48 by AWL    -- This Private interface contains items used in initializing the Store configuration.DIRECTORY  Boot USING [DiskFileID, Location],  Device USING [Type],  Environment USING [PageCount, PageNumber],  ResidentHeap USING [Location],  Space USING [PageFromLongPointer, Usage],  StartList USING [Base, Entry],  VM USING [Interval];StoragePrograms: DEFINITIONS IMPORTS Space =  BEGIN  --~~~~~~~~~~ Programs of the Store configuration:  InitializeEarlyVMAlloc: PROCEDURE [unusedVMNotInStartList: VM.Interval];  -- Makes StoragePrograms.AllocateVM operational.  -- (Initializes early VM allocator from MakeBoot-allocated empty  --   spaces. Also copies data on mapped resident spaces into oulaw table.)  -- (No required predecessors.)  -- (There must be only one interval of unused vm  --    which is not described in the StartList.)  InitializeFileMgr: PROCEDURE [    bootFile: LONG POINTER TO Boot.Location,    pDebuggerResult: POINTER TO Boot.DiskFileID,    pDebuggeeResult: POINTER TO Boot.DiskFileID]    RETURNS [debuggerDeviceType: Device.Type, debuggerDeviceOrdinal: CARDINAL];  -- If bootFile.deviceType IN Device.PilotDisk then  --   1. Sets system volume to logical volume containing bootFile.id.da.  --   2. If local debugging and no debugger known yet then  --     2a. If a local debugger can be found then returns type  --         and DiskFileIDs of it  --     2b. Else (no debugger can be found) returns debuggerDeviceType=nullType.  InitializeFileBasics: PROCEDURE[];  InitializeFrame: PROCEDURE[];  -- On return, RuntimeInternal.FrameSize and RuntimeInternal.MakeFsi  -- are operational. Frame fault handling will become operational  -- as soon as ResidentMemory is operational.  -- (Processes must be initialized first.)  InitializeInterrupt: PROCEDURE[];  -- Initializes Pilot's keyboard interrupt watcher (if one was requested).  -- (KeyboardFace and Processes must be initialized previously.)  -- (Implemented in PilotNub.)  InitializeMStore: PROCEDURE[];  -- (Processes, RealMemory, and System.switches must be initialized first.)    InitializePCMemory: PROCEDURE[];  -- Clears all germ-placed resident mapped pages out of the area designated  -- for PC emulation.  It does this by exchanging resident pages for non-PC bank  -- swappable pages.  -- (MStore, UnusedRealMemory must be initialized first.)  InitializePilotNub: PROCEDURE [];  -- Initialize DeviceCleanup facilities, sets exported variables,  --    and initializes debugger communication  --    (world swapping, breakpoints, Bug[], CallDebugger, etc.).  -- (PDA (i.e. Processes) must be initialized first since used for debugger communication.)  InitializePinning: PROCEDURE[];  -- (VMDriver must be initialized first)    InitializeResidentHeap: PROCEDURE[];  -- (Processes, Zone, and ResidentMemory must be initialized first.)  InitializeResidentMemory: PROCEDURE[];  -- (MStore, EarlyVMAlloc, and VMData must be initialized first.)  InitializeSpaceAllocation: PROCEDURE [];  InitializeVMDataA: PROCEDURE[];  -- Makes AllocateReservedMStore operational.  -- (Processes, EarlyVMAlloc, and MStore must be initialized first.)  InitializeVMDataB: PROCEDURE[];  -- Makes all of VMData operational except pinned procedures.  -- (ResidentHeap must be initialized first.)    InitializeVMDataC: PROCEDURE[];  -- Makes all of VMData operational.  -- (Pinning must be initialized first.)  InitializeVMDriver: PROCEDURE [];  InitializeVMMgr: PROCEDURE [];  InitializeZone: PROCEDURE[];  -- (No required predecessors.)  --~~~~~~~~~~ Facilities used during initialization of the Store config:  --~~~~~ Exported by PilotControl:  countVM: Environment.PageCount;  -- amount of virtual memory implemented by this processor.  PMDS: PROCEDURE[] RETURNS [LONG POINTER] = INLINE {    -- returns a pointer to Pilot's (only) MDS.    RETURN[LONG[LOOPHOLE[1, POINTER]] - 1]};  pageHyperspace: Environment.PageNumber;  -- first page following Pilot's MDS.  countHyperspace: Environment.PageCount;  startList: StartList.Base;  -- base pointer to the Start List.  EnumerateStartList: PROCEDURE [proc: StartListProc];  -- Calls Proc once for each entry in the StartList.  StartListProc:     TYPE = PROCEDURE [pEntry: LONG POINTER TO StartList.Entry]       RETURNS [done:BOOLEAN ¬ FALSE];    PilotType: TYPE = {diagnosticPilot, utilityPilot, pilot};  pilotType: READONLY PilotType;  --~~~~~ Exported by MStore in the ResMemMgr config:  AddReservedMStore: PROCEDURE [countAdded: Environment.PageCount];  -- Increases by countAdded the number of reserved pages  --   (swappable, readonly, and swapped-in) currently available.  -- This is for use in handling such pages which are placed in memory by MakeBoot.  RecoverMStore: PROCEDURE[];  -- SHOULD BE IN RuntimeInternal!  -- Places all unused free real memory into arbitrary vacant non-germ virtual pages.  -- The caller must have interrupts disabled.  -- This is intended for use just before booting, to put any free  --   real pages back into the page map where the germ can find them.  -- Upon return from this proc, Pilot's real memory facilities  --   must not be used. This means no frame allocations and thus no procedure calls.  UnusedRealMemory: PROCEDURE [interval: VM.Interval];  -- Declares, to the real memory allocator, an interval of virtual memory  -- which contains unused real memory pages. The real memory allocator  -- will PrincOps.unmap the pages and assume ownership of the real memory.  --~~~~~ Facilities for allocating virtual memory: (exported by EarlyVMAllocImpl)  -- These facilities are for use before the Space Allocation subsystem  -- has been initialized; they can not be used after Space Allocation  -- has been initialized.  OutlawMapping: TYPE = {    alwaysWhollyUnmapped, partiallyOrSometimesMapped, alwaysWhollyMapped};  AllocateVM: PROCEDURE [    count: Environment.PageCount, location: ResidentHeap.Location,    usage: Space.Usage, mapping: OutlawMapping]    RETURNS [page: Environment.PageNumber];  -- Allocates virtual memory, for use before the Space Allocation subsystem  --   has been initialized.  -- Also does an OutlawInterval[] for you.  EnumerateUnusedVM: PROCEDURE [unusedProc: UnusedVMProc];  -- Calls UnusedVMProc with each interval of virtual memory which    --   is currently unused. The intervals are enumerated in no particular order.  -- After this proc has been called, further calls to AllocateVM  --   will take you to the debugger.  -- This proc allows the Space virtual memory allocator to discover  --   what parts of virtual memory are available for allocation and use.  UnusedVMProc: TYPE = PROCEDURE [unused: VM.Interval];  OutlawInterval: PROCEDURE [    interval: VM.Interval, usage: Space.Usage, mapping: OutlawMapping];  -- Declares an interval of virtual memory whose contents will not  -- be managed by Space/VM. (Such intervals are backed wholly  -- or partially by resident memory.) This declaration is made  -- for the use of debugging and perf tools only.  -- (An outlaw interval does not appear in the VM database.)  -- DO NOT do an OutlawInterval[] on intervals gotten from AllocateVM!  --~~~~~ Utilities:  PageMDS: PROCEDURE RETURNS [Environment.PageNumber] = INLINE {    RETURN[Space.PageFromLongPointer[LONG[LOOPHOLE[1, POINTER]] - 1]]};  -- ("1" since 0 collides with NIL.)  -- Pointer to Pilot's (only) MDS.  --~~~~~ Code pack handles for special memory:  SpecialResidentCodeHandle: PROCEDURE;  -- This procedure's only purpose is to provide a handle  -- on the PilotKernel CODE PACK which contains resident code  -- which should be moved to reserved memory.  ResidentRunFastCodeHandle: PROCEDURE;  -- This procedure's only purpose is to provide a handle on the CODE PACK  -- which contains resident code which may be moved to reserved memory  -- if there is still room after the SpecialResident stuff has been moved.  END.LOG (For earlier log entries, please see Mesa 8.0 archive version.)Apr 16, 80 9:04 AM   WDK       Added InitializeResidentMemoryA/B, InitializeRegionCacheA/B, InitializeMStore, InitializeSimpleSpace, RecoverMStore, StartListProc, countVM, pageMDS, pageMDSGerm, lpMDS, pageHyperspace, countHyperspace, EnumerateStartList, tableBase.  InitializeSwapper takes fewer parameters.  Changed IsBoundIfNotUtilityPilot to IsUtilityPilot, added IsDiagnosticPilot.July 1, 80 4:55 PM   WDK       New StartList format.  Redo SpaceOptions.  Made inlines really inline.July 7, 80 5:13 PM   RXG   	Added InitializeTransactionData, RecoverTransactions.January 26, 1981  11:45 AM   WDK       Added nullTransactionHandle.27-Oct-81 10:50:51   WDK       Deleted pageMDSGerm (Germ now bolted into mds 0).  Deleted Inlines.13-Nov-81 17:40:52   WDK       Added special memory handles.  IsUtilityPilot and IsDiagnosticPilot become WhichPilot.16-Sep-82  9:16:26   WDK       Deleted nullSpaceHandle, nullTransactionHandle, SpaceOptions, createSimpleSpace, DescribeSpace, HandleFromPage, PointerFromPage, SuperFromPage (just use VM), HighStoreSpecialResidentEVHandle. Added AllocateVM, UnusedVirtualMemory, UnusedRealMemory, OutlawInterval, ResidentRunFastCodeHandle, Etc.15-Oct-82 17:13:33   WDK     	Added AddReservedMStore. 8-Nov-82 18:15:30   JXP   	Use Space instead of NewSpace.23-Dec-82 19:01:22   AWL      	Deleted WhichPilot.11-Mar-83 12:35:41   WDK     	Improved InitializeFileMgr. 5-Apr-83 10:38:11   JXP   	ResidentMemory.Location => ResidentHeap.Location.17-May-83 11:37:21   JXG    	allow StartListProc to stop EnumerateStartList14-Jun-83 16:12:16   LXD      	InitializeFileMgr's bootFile arg is now writable.17-Jun-83 16:04:26   JXG    	add InitializeVMDataC, InitializePinning. 7-Jul-83 13:40:30   WDK        No longer pass around data for debugger - modules can store it in the esv themselves. Don't pass countVM to VMMgr nor SpaceAllocation.10-Aug-83  9:31:40   WDK     	InitializeFrameImpl => InitializeFrame.22-Aug-84 19:07:13   KEK    	Add InitializePCMemory.29-May-85 15:30:45   AWL    	Add PilotType and pilotType.
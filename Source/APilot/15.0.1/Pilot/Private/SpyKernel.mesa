-- Copyright (C) 1981, 1982, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- SpyKernel.mesa - last edited by-- JBD    	 9-Sep-86 16:23:13-- AXD    	 3-Jan-84 19:20:23-- JXG    	18-Apr-83 15:20:09-- BXM  	25-Jan-82 17:40:19-- LXD      	 5-Jan-82 11:14:58-- RXL  	 2-Nov-81 18:16:29-- MXB   	16-Aug-81 13:30:07  DIRECTORY  Environment: TYPE USING [PageCount, PageFromLongPointer, wordsPerPage],  Frame: TYPE USING [ReadPC, ReadReturnLink],  FrameExtras: TYPE USING [ReadGlobalLink],  GFHash: TYPE USING [Create, Fetch, Insert, MakeResident, Table],  Inline: TYPE USING [BITAND, LongCOPY, LongDiv, LowHalf],  LoadState: TYPE USING [LockBcdInfo, OriginalModule, UnlockBcdInfo],  LoadStateFormat: TYPE USING [Handle],  PageMap: TYPE USING [flagsVacant, GetState],  PrincOps: TYPE USING [LocalFrameHandle],  PrincOpsExtras2: TYPE USING [ControlLink, nullGFH, GFTHandle],  Process: TYPE USING [    Detach, GetPriority, Priority, priorityForeground, priorityNormal,    SetPriority],  ProcessOperations: TYPE USING [HandleToIndex, ReadPSB],  ProcessPriorities: TYPE USING [priorityRealTime],  PSB: TYPE USING [    NullStateVectorHandle, PDA, Priority, ProcessStateBlock, PsbHandle,    PsbIndex, PsbLink],  Runtime: TYPE USING [GlobalFrame],  Space: TYPE USING [    Access, Interval, nullInterval, PageFromLongPointer, ScratchMap, Unmap],  SpecialSpace: TYPE USING [    MakeEntryVectorResident, MakeGlobalFrameResident, MakeProcedureResident,    SpecialError],  SpyClient: TYPE USING [],  SpyFormat: TYPE USING [    All, Buckets, Count, FixedStorage, Ignore, LevelData, MapBase, MapHandle,    PcMapHandle, ProcessAction, ProcessTable],  UserTerminal: TYPE USING [WaitForScanLine],  VM: TYPE USING [Interval, MakeResident, MakeSwappable, PageCount];  SpyKernel: MONITOR  IMPORTS    Frame, GFHash, Inline, LoadState, PageMap, Process, ProcessOperations,    Runtime, Space, SpecialSpace, UserTerminal, VM, FrameExtras  EXPORTS SpyClient  SHARES PageMap =   BEGIN  -- Types and Related Constants --  initialVariableSpace: CARDINAL = Environment.wordsPerPage;  SpyState: TYPE = {off, on, disabled};  maxStackDepth: CARDINAL = 200;    GFTHandle: TYPE = PrincOpsExtras2.GFTHandle;  -- Global Variables accessed by CoPilot --    active: INTEGER ¬ 0;    priority: Process.Priority ¬ Process.priorityNormal;  << Spy watches processes with priority less than the Spy's that have not been excluded explicitly via the processTable. If priority = SpyFormat.All, then Spy watches all such processes; otherwise, it watches only those at level "priority". >>    wakeups: SpyFormat.Count ¬ 0;    -- Number of times that Spy has scanned the process queue.  notScheduled: SpyFormat.Count ¬ 0;    -- Number of times that Spy has scanned process queue and failed to find an interesting    -- process.  (Hence notScheduled <= wakeups.)  skips: SpyFormat.Count ¬ 0;    << Number of times that Spy has given up because (1) it detected an invalid stack frame, or (2) it scanned 200 stack frames without finding someone to charge. >>    Allocator: PROC [wordsNeeded: CARDINAL] ¬ AllocateFromCoPilot;  variableStorageAllocated: LONG CARDINAL ¬ 0;  maps: SpyFormat.MapBase ¬ NIL;  pails: SpyFormat.Buckets ¬ NIL;    hist: GFHash.Table;  levelData: LONG POINTER TO SpyFormat.LevelData ¬ NIL;  processTable: LONG POINTER TO SpyFormat.ProcessTable ¬ NIL;  -- Other Global Variables --  fixedSpace: Space.Interval ¬ Space.nullInterval;  variableSpace: Space.Interval ¬ Space.nullInterval;  spyState: SpyState ¬ off;  wordsToAllocate: CARDINAL ¬ 0;  coPilot: CONDITION ¬ [timeout: 0];    VMIntervalFromSpaceInterval: PROC [    s: Space.Interval] RETURNS [v: VM.Interval] = INLINE {    RETURN[[Space.PageFromLongPointer[s.pointer], s.count]]};  -- Client Interface --  -- Note:  These procedures need not be resident.  StartCounting: PUBLIC ENTRY PROC = {active ¬ active + 1};    StopCounting: PUBLIC ENTRY PROC = {active ¬ active - 1};  -- Spy Process --  -- All code invoked by this process should be resident  ValidFrame: PROC [f: PrincOpsExtras2.ControlLink]    RETURNS [lf: PrincOps.LocalFrameHandle,       gf: GFTHandle] = INLINE {    IF f.proc OR f.indirect       OR (gf ¬ FrameExtras.ReadGlobalLink[f.frame]) = PrincOpsExtras2.nullGFH OR      PageMap.GetState[        Inline.LongDiv[	  LOOPHOLE[gf, CARDINAL], Environment.wordsPerPage]].state.flags	  = PageMap.flagsVacant THEN RETURN[NIL, PrincOpsExtras2.nullGFH];    lf ¬ f.frame};  Lookup: PROC [gf: GFTHandle]    RETURNS [p: LONG POINTER TO SpyFormat.Count] = INLINE {    p ¬ hist.Fetch[gf];    IF p = NIL THEN {p ¬ hist.Insert[gf]; IF p # NIL THEN p­ ¬ 0}};      ReturnLink: PROC [    f: PrincOps.LocalFrameHandle] RETURNS [PrincOpsExtras2.ControlLink] = INLINE {    RETURN[[indirect[link[link: LOOPHOLE[Frame.ReadReturnLink[f].link]]]]]};      IncrementBucket: INTERNAL PROC [frame: PrincOps.LocalFrameHandle] = INLINE {    << This procedure finds the appropriate bucket to be incremented, if any.    Generally, it searches up the stack beginning with 'frame', using the frame's pc to locate a bucket.  If no bucket exists, or if the bucket spanning the pc is marked 'ignore', we advance to the next frame on the stack.  If, at any time, we encounter a copied module with a pcMap, we use the corresponding original module to locate the buckets.  Because it is not possible to know if a frame's return link is valid (in the presence of PORTs it may be obsolete), we are careful to validate each frame as we walk up the stack.  We also place an absolute bound of 'maxStackDepth' on any attempt to find a bucket, after which we give up and increment the 'skips' counter.  Thus, this procedure always increments precisely one counter. >>        gf: GFTHandle;    [frame, gf] ¬ ValidFrame[[frame[frame: frame]]];    THROUGH [0..maxStackDepth) UNTIL frame = NIL DO      pCount: LONG POINTER TO SpyFormat.Count = Lookup[gf];      IF pCount # NIL THEN SELECT pCount­ FROM	< SpyFormat.Ignore => {pCount­ ¬ pCount­ + 1; RETURN};	= SpyFormat.Ignore => NULL;	ENDCASE => {          pcMap: SpyFormat.PcMapHandle;	  gf ¬ LoadState.OriginalModule[gf]; 	  pcMap ¬ @pails[Inline.LowHalf[pCount­ - SpyFormat.Ignore - 1]];	  IF pcMap.length > 0 THEN {	    pc: CARDINAL ¬ Frame.ReadPC[frame];	    pcVals: SpyFormat.MapHandle ¬ @maps[pcMap.pcVals];	    bottom: CARDINAL ¬ 0;	    top: CARDINAL ¬ pcMap.length - 1;	    DO	      probe: CARDINAL ¬ (top + bottom) / 2;	      SELECT pc FROM	        < pcVals[probe].origin =>	          IF probe = 0 THEN EXIT ELSE top ¬ probe - 1;	        >= pcVals[probe].origin + pcVals[probe].length =>		  IF probe = pcMap.length -1 THEN EXIT ELSE bottom ¬ probe + 1;	        ENDCASE => {		  IF pcVals[probe].ignore THEN EXIT;		  pcVals[probe].count ¬ pcVals[probe].count + 1;		  RETURN};	      IF top < bottom THEN EXIT;	      ENDLOOP}};      [frame, gf] ¬ ValidFrame[ReturnLink[frame]];      ENDLOOP;    skips ¬ skips + 1};  Spy: PROC = {    OPEN PSB;    handleMask: PsbLink = [      priority: 0, next: PsbIndex.LAST, failed: FALSE, permanent: FALSE,      preempted: FALSE];    originalLevel: Process.Priority = Process.GetPriority[];    myPSB: PsbHandle = ProcessOperations.ReadPSB[];    myPriority: Process.Priority ¬ ProcessPriorities.priorityRealTime;        LinkCellToNextHandle: PROC [link: UNSPECIFIED] RETURNS [PsbHandle] = INLINE {      RETURN[Inline.BITAND[link, handleMask]]};    SkipThisProcess: PROC [p: PsbHandle] RETURNS [BOOLEAN] = INLINE {      RETURN[processTable[ProcessOperations.HandleToIndex[p]] = ignore]};    EnsureSpyOn: PROC = INLINE {      IF spyState = on THEN RETURN;      VM.MakeResident[VMIntervalFromSpaceInterval[fixedSpace], wait];      VM.MakeResident[VMIntervalFromSpaceInterval[variableSpace], wait];      hist.MakeResident[];      Process.SetPriority[myPriority];      spyState ¬ on};    EnsureSpyOff: PROC = INLINE {      IF spyState = off THEN RETURN;      Process.SetPriority[originalLevel];      VM.MakeSwappable[VMIntervalFromSpaceInterval[fixedSpace]];      VM.MakeSwappable[VMIntervalFromSpaceInterval[variableSpace]];      spyState ¬ off};    DoSpying: ENTRY PROC = INLINE {      IF spyState = disabled THEN RETURN;      IF active <= 0 THEN EnsureSpyOff[]      ELSE {	headOfReadyList, current: PsbHandle;        EnsureSpyOn[];	headOfReadyList ¬ LinkCellToNextHandle[PDA.ready];	current ¬ myPSB;	wakeups ¬ wakeups + 1;	<< The following loop assumes that this process will not get preempted once it begins examining the ready list.  Since all the data structures it touches are pinned, this process will never fault; however, QDTS (the pseudo-timeslicer) can rearrange the ready list at essentially arbitrary times.  To avoid trouble, this process always runs at priorityRealTime, which is the same as QDTS. >>	UNTIL current = headOfReadyList DO	  psb: LONG POINTER TO ProcessStateBlock =	    @PDA[current ¬ LinkCellToNextHandle[PDA[current].link]];	  link: PsbLink = psb.link;	  level: Process.Priority = link.priority;	  IF level = myPriority THEN LOOP;	  IF ~(level = priority OR priority = SpyFormat.All) THEN LOOP;	  IF link.failed OR PDA.state[level] = NullStateVectorHandle OR	     SkipThisProcess[current] THEN LOOP;	  levelData[level] ¬ levelData[level] + 1;	  IncrementBucket[	    IF link.preempted OR link.permanent THEN PDA[psb.context.state].frame	    ELSE psb.context.frame];	  RETURN;	  ENDLOOP;	notScheduled ¬ notScheduled + 1}};        -- The Spy's main loop --    DO UserTerminal.WaitForScanLine[0]; DoSpying[]; ENDLOOP};  -- Storage Allocation --    Zero: PROC [p: LONG POINTER, nwords: LONG CARDINAL] = {    delta: LONG CARDINAL = CARDINAL.LAST.LONG + 1;    UNTIL nwords <= CARDINAL.LAST DO      p­ ¬ 0;      Inline.LongCOPY[from: p, to: p + 1, nwords: CARDINAL.LAST - 1];      p ¬ p + delta;      nwords ¬ nwords - delta;      ENDLOOP;    p­ ¬ 0;    IF nwords > 1 THEN      Inline.LongCOPY[from: p, to: p + 1, nwords: CARDINAL[nwords] - 1]};      Words: PROC [n: CARDINAL]    RETURNS [space: Space.Interval, size: LONG CARDINAL] = {    pages: Environment.PageCount =      (n + Environment.wordsPerPage-1)/Environment.wordsPerPage;    size ¬ pages*Environment.wordsPerPage;    space ¬ [Space.ScratchMap[pages], pages];    -- The following ensures that the space is dirty, causing the state    -- in Pilot to be "alive", not "dead".  This ensures that any alterations    -- to the space made by CoPilot will be seen by the Client side.    Zero[space.pointer, n];    LOOPHOLE[space.pointer, LONG POINTER TO CARDINAL]­ ¬ 0;    IF spyState # off THEN VM.MakeResident[      VMIntervalFromSpaceInterval[space], wait]};  AllocateFromCoPilot: ENTRY PROC [wordsNeeded: CARDINAL] = {    << Note:  This procedure is called from whatever process went to CoPilot.  If this process is the interrupt key watcher (quite likely), then we are running at priorityRealTime and cannot fault.  For this reason, we perform the allocation in another process that is known to run at an acceptably low priority. >>    oldSpyState: SpyState ¬ spyState;    IF (wordsToAllocate ¬ wordsNeeded) <= variableStorageAllocated THEN RETURN;    spyState ¬ disabled;    NOTIFY coPilot;    UNTIL wordsToAllocate = 0 DO WAIT coPilot ENDLOOP;    spyState ¬ oldSpyState};    LowPriorityAllocator: ENTRY PROC = {    Process.SetPriority[Process.priorityForeground];    DO      UNTIL wordsToAllocate > 0 DO WAIT coPilot ENDLOOP;      AllocateVariableSpace[wordsToAllocate];      wordsToAllocate ¬ 0;      NOTIFY coPilot;      ENDLOOP};  AllocateVariableSpace: PROC [wordsNeeded: CARDINAL] = {    IF variableSpace # Space.nullInterval THEN      [] ¬ Space.Unmap[variableSpace.pointer];    [variableSpace, variableStorageAllocated] ¬ Words[wordsNeeded];    maps ¬ variableSpace.pointer};  -- Initialization --    {OPEN SpecialSpace;  MakeProcedureResident[Spy ! SpecialError => CONTINUE];  MakeEntryVectorResident[Spy ! SpecialError => CONTINUE];  MakeGlobalFrameResident[SpyKernel ! SpecialError => CONTINUE];  MakeProcedureResident[    LOOPHOLE[LoadState.OriginalModule] ! SpecialError => CONTINUE];  MakeEntryVectorResident[    LOOPHOLE[LoadState.OriginalModule] ! SpecialError => CONTINUE];  MakeGlobalFrameResident[    Runtime.GlobalFrame[      LOOPHOLE[LoadState.OriginalModule]] ! SpecialError => CONTINUE]};  Process.Detach[FORK Spy[]];  fixedSpace ¬ Words[SpyFormat.FixedStorage.SIZE].space;  levelData ¬ fixedSpace.pointer;  levelData­ ¬ ALL[0];  processTable ¬ LOOPHOLE[levelData + SpyFormat.LevelData.SIZE];  processTable­ ¬ ALL[SpyFormat.ProcessAction[watch]];  {ls: LoadStateFormat.Handle = LoadState.LockBcdInfo[].loadState;  hist ¬ GFHash.Create[    ngf: MAX[ls.maxModules + ls.maxModules/2, ls.maxModules],    dataSize: SpyFormat.Count.SIZE];  LoadState.UnlockBcdInfo[]};  LOOPHOLE[hist.Insert[PrincOpsExtras2.nullGFH], LONG POINTER TO SpyFormat.Count]­ ¬ SpyFormat.Ignore;  wordsToAllocate ¬ 0;  Process.Detach[FORK LowPriorityAllocator[]];  AllocateVariableSpace[initialVariableSpace];  END.
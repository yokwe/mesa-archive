-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- PinningImpl.mesa    last edited by ET     30-Sep-87 12:13:06-- Pinning provides a simple way of making code be resident when it is in-- use and otherwise swappable without the overhead of calls to-- VM.MakeResident and VM.MakeSwappable on every call.--  Note: It is convenient that Pinning be available very early on in-- Pilot's initialization.  This is because there are routines which need-- to be called there, but which would later on benefit from Pinning.-- However, if these routines are swappable in the bootfile then calls-- to MakeResident/MakeSwappable are inappropriate before those swappable-- spaces have been registered in the VM database (at PilotMP 970).-- The initialisation is made a two stage process.  Initially,-- pinningInitialized is set to FALSE and CreatePinHandle will artificially-- increase the pinsOutstanding count for the routine to inhibit calls-- to MakeResident/MakeSwappable.  It is assumed that the code for these-- routines will be marked IN initially to avoid any page-faults.-- Eventually, the spaces will be put in the VM database and the initialization-- of Pinning can complete.  pinningInitialized is set TRUE and the -- pinsOutstanding of all PinObject is decremented.  If at this point the count-- is positive, the object is made resident, otherwise it remains swappable-- and will no doubt be swapped out in due course as appropriate.-- In the following code, InitializePinning sets up the world, and after-- it completes, Pinning is fully operational.  However, by using-- pinningInitialized as above, with care it is safe to call CreatePinHandle,-- Pin and Unpin before InitializePinning. The only requirements are that-- sufficient of the VM world be available to call GetSwapUnitsForProcedure-- safely. In this case pinningInitialized will be set on the start trap-- to FALSE and Pin and Unpin effectively become no-ops until InitializePinning-- is called. -- I suppose that according to convention there ought to be another-- initialization routine to call to force the start trap but as it would -- simpl be a RETURN it hardly seems worth while.DIRECTORY  Pinning USING [],  Process USING [DisableTimeout, priorityBackground, Seconds, SecondsToTicks,     SetPriority, SetTimeout],  ResidentHeap USING [first64K, FreeNode, MakeNode],  RuntimeInternal USING [Bug],  SpecialRuntime USING [GetSwapUnitsForProcedure],  StoragePrograms USING [--InitializePinning--],  System USING [gmtEpoch, isUtilityPilot, GetGreenwichMeanTime,     SecondsSinceEpoch],  VM USING [Interval, MakeResident, MakeSwappable, SetSwappability, Swappability],  Zone USING [Base, nil, Status];  PinningImpl:  MONITOR  IMPORTS Process, ResidentHeap, RuntimeInternal, SpecialRuntime, System, VM  EXPORTS Pinning, StoragePrograms =  BEGIN    PinHandle: PUBLIC TYPE = Zone.Base RELATIVE POINTER TO PinObject;  PinObject: PUBLIC TYPE = PRIVATE RECORD     [swapUnit: VM.Interval,		-- interval of VM to be pinned/unpinned     swappability: VM.Swappability ¬ swappable,	-- current state of interval     pinsOutstanding: CARDINAL ¬ 0,	-- use count of outstanding Pin calls     objectUseCount: CARDINAL ¬ 1,	-- use count of this record     time:Time ¬ 0,			-- time at which it next becomes swappable     timeout:Process.Seconds ¬ 0,	-- length of time before code times out     next:PinHandle			-- link all objects together     ];       pinObjectList: PinHandle ¬ Zone.nil;  pinBase: Zone.Base ¬ ResidentHeap.first64K;    makeUnusedProceduresSwappableProcess: PROCESS ¬ NIL;  procUnpinnedOrTimeout:CONDITION;     pinningInitialized: BOOLEAN ¬ FALSE;   Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};  BugType: TYPE =     {alreadyResident, cantMakeHandle, invalidHandle, pinsOutstanding};    Time: TYPE=LONG CARDINAL;  GetTime: PROCEDURE RETURNS [Time] = INLINE    {RETURN[System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]]]};        InitializePinning: PUBLIC ENTRY PROCEDURE =    BEGIN        IF System.isUtilityPilot     THEN RETURN;     -- ie, we don't want a process to make things swappable;     -- we don't want to adjust the pinsOutstanding count so calls     -- to MakeResident/MakeSwappable might happen     -- and we want to leave pinningInitialized FALSE so that further     -- calls to Create/Delete/Pin/unpin become effective no-ops        makeUnusedProceduresSwappableProcess ¬ FORK MakeUnusedProceduresSwappable;    FOR pH:PinHandle ¬ pinObjectList, pinBase[pH].next UNTIL pH=Zone.nil      DO      pin:LONG POINTER TO PinObject ¬ @pinBase[pH];      pin.pinsOutstanding ¬ pin.pinsOutstanding-1;      IF pin.pinsOutstanding>0      THEN {pin.swappability ¬ resident; VM.MakeResident[pin.swapUnit, wait]};      ENDLOOP;    pinningInitialized ¬ TRUE;    END;          CreatePinHandle:     PUBLIC ENTRY PROCEDURE [p:--GENERIC--PROCEDURE, timeout:Process.Seconds]     RETURNS [pH:PinHandle] =    BEGIN    swapUnit:VM.Interval;    status:Zone.Status;    swappability:VM.Swappability;    [swapUnit, swappability] ¬ SpecialRuntime.GetSwapUnitsForProcedure[p];        -- check whether interval is already in an extant PinObject    -- if so, increment use count and return that one    FOR pH ¬ pinObjectList, pinBase[pH].next UNTIL pH=Zone.nil      DO      IF swapUnit=pinBase[pH].swapUnit       THEN {pinBase[pH].objectUseCount ¬ pinBase[pH].objectUseCount+1;             pinBase[pH].timeout ¬ MAX[pinBase[pH].timeout, timeout];	    RETURN [pH]}      ENDLOOP;        -- interval does not exist in a PinObject; create a new one...         IF swappability=resident AND ~System.isUtilityPilot    THEN Bug[alreadyResident];        [pH, status] ¬          ResidentHeap.MakeNode[n: SIZE[PinObject], location:first64K];    IF status#okay THEN Bug[cantMakeHandle];        pinBase[pH] ¬ [swapUnit:swapUnit, timeout: timeout, next: pinObjectList];    IF NOT pinningInitialized     THEN pinBase[pH].pinsOutstanding ¬ 1; -- see comments at head        pinObjectList ¬ pH;        RETURN [pH];    END;          DestroyPinHandle:    PUBLIC ENTRY PROCEDURE [ppH:LONG POINTER TO PinHandle] =    BEGIN    pHToDelete:PinHandle ¬ ppH­;    pinToDelete:LONG POINTER TO PinObject ¬ @pinBase[pHToDelete];    ppH­ ¬ Zone.nil;       pinToDelete.objectUseCount ¬ pinToDelete.objectUseCount-1;       IF pinToDelete.objectUseCount=0    THEN       BEGIN      IF pinToDelete.pinsOutstanding#0       THEN Bug[pinsOutstanding];            IF pinToDelete.swappability=resident  -- it might not have timed out yet      THEN VM.MakeSwappable[pinToDelete.swapUnit];            FOR pH:PinHandle ¬ pinObjectList, pinBase[pH].next UNTIL pH=Zone.nil        DO 	IF pinBase[pH].next=pHToDelete         THEN         {pinBase[pH].next ¬ pinToDelete.next; 	  [] ¬ ResidentHeap.FreeNode[p:pHToDelete, location:first64K];	  RETURN}        ENDLOOP;	      Bug[invalidHandle];	      END;           END;          Pin: PUBLIC ENTRY PROCEDURE [pH:PinHandle] =    BEGIN    pin:LONG POINTER TO PinObject ¬ @pinBase[pH];    pin.pinsOutstanding ¬ pin.pinsOutstanding+1;    IF pin.pinsOutstanding=1 AND pin.swappability=swappable    THEN {pin.swappability ¬ resident; VM.MakeResident[pin.swapUnit, wait]};    END;          Unpin: PUBLIC ENTRY PROCEDURE [pH:PinHandle] =    BEGIN    pin:LONG POINTER TO PinObject ¬ @pinBase[pH];    pin.pinsOutstanding ¬ pin.pinsOutstanding-1;    IF pin.pinsOutstanding=0     THEN {pin.time ¬ GetTime[]+pin.timeout; NOTIFY procUnpinnedOrTimeout};    END;          MakeUnusedProceduresSwappable: ENTRY PROCEDURE =    BEGIN    currentTime:Time;    secondsToNextTimeout: Process.Seconds;        Process.SetPriority[Process.priorityBackground];    Process.DisableTimeout[@procUnpinnedOrTimeout];    currentTime ¬ GetTime[];        DO  -- forever --    WAIT procUnpinnedOrTimeout; -- until something has been unpinned     				-- or something is due to be made swappable        currentTime ¬ GetTime[];    secondsToNextTimeout ¬ LAST[Process.Seconds];        FOR pH:PinHandle ¬ pinObjectList, pinBase[pH].next UNTIL pH=Zone.nil      DO       IF pinBase[pH].swappability=resident AND pinBase[pH].pinsOutstanding=0      THEN         IF currentTime >= pinBase[pH].time        THEN	  BEGIN	  pinBase[pH].swappability ¬ swappable;	  VM.SetSwappability[pinBase[pH].swapUnit, swappable, wait];	  END        ELSE 	  secondsToNextTimeout ¬ 	    MIN[secondsToNextTimeout, CARDINAL[pinBase[pH].time-currentTime]]      ENDLOOP;          IF secondsToNextTimeout=LAST[Process.Seconds]    THEN Process.DisableTimeout[@procUnpinnedOrTimeout]    ELSE Process.SetTimeout[@procUnpinnedOrTimeout,            Process.SecondsToTicks[secondsToNextTimeout]];	           ENDLOOP;        END;    END....LOG16-Jun-83 14:02:34 JXG      created file22-Jun-83 11:59:54 JXG      add code for utility pilot23-Jun-83 15:42:45 JXG      fold in Extras30-Sep-87 12:09:34 ET       Fix AR 10475-Deadlock with PinningImpl/VMUtilitites. (Change MakeUnusedProceduresSwappable to call SetSwappability itself, with returnWait = wait, vs calling MakeSwappable which defaults it to return). 
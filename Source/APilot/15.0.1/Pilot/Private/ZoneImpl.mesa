-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- ResMemMgr>ZoneImpl.mesa    7-Jun-84 17:01:10 by KEK    -- *** TO DO: ***-- 1) Make Recreate smarter (see comment above code)-- A set of procedures to manage allocation within a zone.-- Coalescing of free nodes occurs mainly during allocation; all free nodes-- following a candidate node are merged before any space is allocated.  The-- logic is derived from a BCPL program by E. M. McCreight and was suggested-- by an exercise in Knuth Volume I, p. 453 #19.--	This version was adapted for Pilot from the Free Storage Package of-- the Mesa 4.0 System.  The principal differences are: (1) the zone is-- managed in terms of 16-bit RELATIVE POINTERs relative to a client supplied-- BASE; (2) no SIGNALs are raised, since the implementation is used by-- resident parts of Pilot which cannot invoke the Signaller, (3) the-- mechanism for adding space to a zone is changed, (4) some coalescing of-- free nodes may be done when a node is freed, and (5) the free list is-- maintained in virtual memory location order by segment.DIRECTORY  Inline USING [BITAND, BITSHIFT, LongNumber],  Process USING [InitializeMonitor],  RuntimeInternal USING [Bug],  StoragePrograms USING [],  Zone USING [    Alignment, Base, BlockSize, Handle, nil, nullSegment, SegmentHandle, Status],  ZoneInternal USING [    FreeNodePointer, InuseNodePointer, NodeHeader, NodePointer, OrderedBase, RPtr,    SegmentHeader, SegmentPointer, TemporaryBlocksize, ZoneHeader, ZonePointer,    zoneSeal, zoneVersion];ZoneImpl: MONITOR  LOCKS LOOPHOLE[zH, ZoneInternal.ZonePointer].LOCK USING zH: Zone.Handle  IMPORTS Inline, Process, RuntimeInternal  EXPORTS StoragePrograms, Zone, ZoneInternal =  BEGIN OPEN ZoneInternal;  -- PUBLIC Types    Handle: PUBLIC TYPE = ZoneInternal.ZonePointer;  SegmentHandle: PUBLIC TYPE = ZoneInternal.SegmentPointer;    -- The roverStrategy variable was added for performance experiments.  It allows  -- changing (via the debugger) the method by which the position of the rover  -- is determined.  The default strategy is the original strategy taken from  -- Knuth Volume I, p. 597 #6.  The experimental code was left in because it  -- imposes very little overhead, and because more experimentation may be done  -- in the future.  RoverStrategy: TYPE = {knuthRover, MRF, head};  -- knuthRover:  use the original rover strategy outlined by Knuth (to avoid  --              fragmentation).  -- MRF:  rover points to Most Recently Freed node (to reduce page faults).  -- head:  rover always points to the head of the free list (to keep nodes clumped  --        together to reduce working set).  roverStrategy: RoverStrategy ¬ knuthRover;  usedNodeSize: Zone.BlockSize = SIZE[inuse NodeHeader];  freeNodeSize: Zone.BlockSize = SIZE[free NodeHeader];  zoneHeaderSize: Zone.BlockSize = SIZE[ZoneHeader];  segmentHeaderSize: Zone.BlockSize = SIZE[SegmentHeader];  zoneOverhead: CARDINAL = zoneHeaderSize + freeNodeSize + usedNodeSize;  segmentOverhead: CARDINAL = segmentHeaderSize + freeNodeSize + usedNodeSize;  nodeOverhead: CARDINAL = SIZE[inuse NodeHeader];  -- NOTE: A zone whose largest possible node is N words, must have  -- N + zoneOverhead + nodeOverhead words of storage  nilSeg: SegmentPointer = LOOPHOLE[0];  orderedRelativeNil: OrderedBase RELATIVE POINTER = LOOPHOLE[0];  -- Exported (READONLY) variables  minimumNodeSize: PUBLIC Zone.BlockSize ¬ freeNodeSize;  nil: Zone.Base RELATIVE POINTER = Zone.nil;  nullSegment: Zone.SegmentHandle = Zone.nullSegment;    -- Private errors   BugType: TYPE = {heapSmash};  Bug: PROCEDURE [type: BugType] = INLINE {RuntimeInternal.Bug[type]};  -- Module initialization:   InitializeZone: PUBLIC --StoragePrograms.-- PROC = {};  -- procedures  AddSegment: PUBLIC ENTRY PROC [    zH: Zone.Handle, storage: LONG POINTER, length: Zone.BlockSize]    RETURNS [sH: Zone.SegmentHandle, s: Zone.Status] =    -- Adds a segment to the zone zH.  The storage must be capable of being    -- addressed with 16-bit pointers relative to the zoneBase of the zone.    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    st: LONG ORDERED POINTER = LOOPHOLE[storage];    sp: SegmentPointer = Relative[zb, st];    fn, fnAtEnd: FreeNodePointer;    an: InuseNodePointer;    IF LOOPHOLE[length, CARDINAL] > LAST[ZoneInternal.TemporaryBlocksize] THEN      RETURN[nullSegment, storageOutOfRange];    IF zb > st OR st + length - 1 > zb + LAST[Zone.BlockSize] THEN      RETURN[nullSegment, storageOutOfRange];    IF length < segmentOverhead + MAX[freeNodeSize, LOOPHOLE[z.threshold, CARDINAL]] THEN      RETURN[nullSegment, segmentTooSmall];    IF (s ¬ ValidateZone[zH]) # okay THEN RETURN[sH: nullSegment, s: s];    -- set up the bulk of the segment as one large free node.    fn ¬ LOOPHOLE[sp + segmentHeaderSize];    zb[fn] ¬ NodeHeader[      length: length - (segmentOverhead),      extension: free[fwdp: z.freeList, backp: z.node.backp]];    z.node.backp ¬ zb[zb[fn].backp].fwdp ¬ fn;    -- set up another free node (smallest possible) at end of block.    -- (This allows FreeNodeInternal to avoid traversing the segment list for post-Rubicon    -- zones.  To remain compatible with Rubicon zones, ZoneImpl cannot count on the    -- existence of this special free node.)    fnAtEnd ¬ LOOPHOLE[sp + (length - usedNodeSize - freeNodeSize)];    zb[fnAtEnd] ¬ NodeHeader[      length: freeNodeSize,      extension: free[fwdp: z.freeList, backp: z.node.backp]];    z.node.backp ¬ zb[zb[fnAtEnd].backp].fwdp ¬ fnAtEnd;    -- set up allocated node (smallest possible) at end of block.    an ¬ LOOPHOLE[sp + (length - usedNodeSize)];    zb[an] ¬ NodeHeader[length: usedNodeSize, extension: inuse[]];    -- set up the segment header and link it into the chain of segments    zb[sp] ¬ SegmentHeader[length: length, nextSegment: z.nextSegment];    z.nextSegment ¬ sp;    RETURN[LOOPHOLE[sp], okay];    END;  CheckNode: PUBLIC PROC [zH: Handle, node: NodePointer]    RETURNS [s: Zone.Status] =    -- Checks to see that the node is properly part of this zone and is    -- correctly linked to the free list    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    -- First check to see that node lies within this zone.    BEGIN    sp: SegmentPointer;    rz: RPtr = Relative[zb, LOOPHOLE[zH]];    -- get the zone pointer relative to the zone base    endNode: RPtr = node + zb[node].length;    -- the address of the end of the node    IF node > rz AND endNode < rz + z.length THEN GOTO okay;    --is node in primary part of zone?    FOR sp ¬ z.nextSegment, zb[sp].nextSegment WHILE sp # nilSeg DO      IF node > LOOPHOLE[sp] AND endNode < sp + zb[sp].length THEN GOTO okay;  --is node in this segment of zone?      ENDLOOP;    RETURN[invalidNode];  --node is not in any segment of the zone    EXITS okay => NULL;    END;    -- Now check that node is properly linked on the free list    IF zb[node].state = free THEN      DO        WITH zb[node] SELECT FROM          inuse => IF length = usedNodeSize THEN EXIT;  -- end of zone          free =>            BEGIN            IF zb[fwdp].backp # node OR zb[backp].fwdp # node THEN              RETURN[invalidNode];            IF length = 0 AND node # z.freeList THEN RETURN[invalidNode];            END;          ENDCASE;        node ¬ node + zb[node].length;        IF zb[node].state # inuse THEN EXIT;        ENDLOOP;    RETURN[okay]    END;  CheckZone: PUBLIC PROC [zH: Handle] RETURNS [s: Zone.Status] =    -- Checks that the zone is well-formed and that its free list is intact    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    node: FreeNodePointer;    count: INTEGER;    IF (s ¬ ValidateZone[zH]) # okay THEN RETURN[s];    count ¬       (LAST[ZoneInternal.TemporaryBlocksize] - FIRST[ZoneInternal.TemporaryBlocksize])/       freeNodeSize + 1;    node ¬ z.freeList;    DO      IF (s ¬ CheckNode[zH, node]) # okay THEN RETURN[invalidNode];      IF (count ¬ count - 1) < 0 THEN RETURN[nodeLoop];      IF (node ¬ zb[node].fwdp) = z.freeList THEN EXIT;      ENDLOOP;    RETURN[okay]    END;  Create: PUBLIC PROC [    storage: LONG POINTER, length: Zone.BlockSize, zoneBase: Zone.Base,    threshold: Zone.BlockSize, checking: BOOLEAN]    RETURNS [zH: Zone.Handle, s: Zone.Status] =    -- Makes a zone out of the storage provided by the caller.  The caller also    -- provides a LONG BASE POINTER to which all addressing within the zone    -- will be RELATIVE.  This LONG BASE POINTER must cover all of the storage.    BEGIN    fn, fnAtEnd: FreeNodePointer;    an: InuseNodePointer;    z: ZonePointer = LOOPHOLE[storage];    zb: OrderedBase = LOOPHOLE[zoneBase];    rp: RPtr = Relative[zb, z];    freeList: FreeNodePointer = Relative[zb, @z.node];    IF LOOPHOLE[length, CARDINAL] > LAST[ZoneInternal.TemporaryBlocksize] THEN      RETURN[LOOPHOLE[z, Zone.Handle], storageOutOfRange];    IF zb > z OR z + length - 1 > zb + LAST[CARDINAL] THEN      RETURN[LOOPHOLE[z], storageOutOfRange];    IF length < zoneOverhead + MAX[freeNodeSize, threshold] THEN      RETURN[LOOPHOLE[z], zoneTooSmall];    -- set up the bulk of the zone as one large free node.    fn ¬ rp + zoneHeaderSize;    zb[fn] ¬ NodeHeader[      length: length - (zoneOverhead),      extension: free[fwdp: freeList, backp: freeList]];    -- set up another free node (smallest possible) at end of block.    -- (This allows FreeNodeInternal to avoid traversing the segment list for post-Rubicon    -- zones.  To remain compatible with Rubicon zones, ZoneImpl cannot count on the    -- existence of this special free node.)    fnAtEnd ¬ rp + (length - usedNodeSize - freeNodeSize);    zb[fnAtEnd] ¬ NodeHeader[      length: freeNodeSize, extension: free[fwdp: freeList, backp: fn]];    zb[fn].fwdp ¬ fnAtEnd;    -- set up allocated node (smallest possible) at end of block.    an ¬ rp + (length - usedNodeSize);    zb[an] ¬ NodeHeader[length: usedNodeSize, extension: inuse[]];    -- set up the zone header    z.seal ¬ zoneSeal;    z.version ¬ zoneVersion;    z.root ¬ orderedRelativeNil;    z.rover ¬ fn;    z.freeList ¬ freeList;    z.length ¬ length;    z.nextSegment ¬ nilSeg;    z.zoneBase ¬ zb;    z.threshold ¬ MAX[freeNodeSize, threshold];    z.checking ¬ checking;    z.node ¬ NodeHeader[length: 0, extension: free[fwdp: fn, backp: fnAtEnd]];    Process.InitializeMonitor[@z.LOCK];    RETURN[LOOPHOLE[z], okay]    END;  FreeNode: PUBLIC ENTRY PROC [zH: Zone.Handle, p: LONG POINTER]    RETURNS [s: Zone.Status] =    -- returns the node pointed to by p to the free list    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    pp: LONG ORDERED POINTER = LOOPHOLE[p];    node: NodePointer = Relative[zb, p - usedNodeSize];    IF pp < zb OR pp > zb + LAST[CARDINAL] THEN RETURN[invalidNode];    -- Can't compress to a 16-bit relative pointer if not from this zone.    IF z.checking THEN      BEGIN      IF (s ¬ CheckZone[zH]) # okay THEN RETURN[invalidZone];      IF (s ¬ CheckNode[zH, node]) # okay THEN RETURN[invalidNode];      END;    RETURN[FreeNodeInternal[zH, node]];    END;  FreeNodeInternal: INTERNAL PROC [zH: Zone.Handle, node: NodePointer]    RETURNS [s: Zone.Status] =    -- Returns the node pointed to by node to the free list, keeping the free    -- list ordered by virtual memory location by segment. Also coalesces new    -- free node with the preceding free node if possible, but does not coalesce    -- with the following free node in order to avoid a possible unnecessary page    -- fault fixing the links. Called by FreeNode and SplitNode.    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    freeNode: FreeNodePointer ¬ LOOPHOLE[nil];    headerSize: Zone.BlockSize;    nextNode: NodePointer;    nextSeg: SegmentPointer;    nl: Zone.BlockSize;    startPtr: RPtr;    WITH zb[node] SELECT FROM      free => RETURN[invalidNode];      inuse =>        BEGIN        -- try to find a following free node in this segment        FOR nextNode ¬ node + zb[node].length, nextNode + nl DO          WITH zb[nextNode] SELECT FROM            inuse => {	      IF (nl ¬ length) = usedNodeSize THEN EXIT  -- end of segment	      ELSE IF nl = 0 THEN Bug[heapSmash]};            free =>              BEGIN              IF backp + zb[backp].length = node THEN                BEGIN  -- coalesce with preceding free node                zb[backp].length ¬ zb[backp].length + zb[node].length;	        zb[node] ¬ NodeHeader[0, free[fwdp: NULL, backp: NULL]];                IF roverStrategy = MRF THEN z.rover ¬ backp;                RETURN[okay];                END              ELSE                BEGIN  -- insert new free node between nodes in free list                zb[node] ¬ NodeHeader[                  zb[node].length, free[                  fwdp: LOOPHOLE[nextNode, FreeNodePointer], backp: backp]];                backp ¬ zb[backp].fwdp ¬ LOOPHOLE[node, FreeNodePointer];                IF roverStrategy = MRF THEN                  z.rover ¬ LOOPHOLE[node, FreeNodePointer];                RETURN[okay];                END              END;            ENDCASE => RETURN[invalidNode];          ENDLOOP;        -- no following free node in segment; try to find preceding free node.	-- (This only happens with Rubicon-created zones; post-Rubicon zones	-- are built with a permanent special free node at the end of each	-- segment.)  Search through list of zone segments for the one containing	-- the new free node. (special case the primary part of the zone since it	-- doesn't have a SegmentHeader.)        startPtr ¬ Relative[zb, LOOPHOLE[zH]];  -- get relative pointer for primary part        headerSize ¬ zoneHeaderSize;        IF node NOT IN [startPtr..startPtr + z.length) THEN  -- check other segments           FOR nextSeg ¬ z.nextSegment, zb[nextSeg].nextSegment DO            IF nextSeg = nilSeg THEN RETURN[invalidNode];  -- node not in any segment            startPtr ¬ nextSeg;            IF node IN [startPtr..startPtr + zb[nextSeg].length) THEN              BEGIN  -- found the segment containing the new free node              headerSize ¬ segmentHeaderSize;              EXIT;              END;            ENDLOOP;        -- try to find a preceding free node in the current segment to link the new one to.        FOR nextNode ¬ LOOPHOLE[startPtr + headerSize], nextNode + nl WHILE          nextNode < node DO          nl ¬ zb[nextNode].length;          WITH zb[nextNode] SELECT FROM            inuse => IF nl = usedNodeSize THEN RETURN[invalidSegment];            -- found end of segment before finding node being freed            free => freeNode ¬ LOOPHOLE[nextNode, FreeNodePointer];  -- remember the last free node            ENDCASE => RETURN[invalidNode];          ENDLOOP;        IF freeNode # LOOPHOLE[nil] THEN  -- found preceding free node          IF freeNode + zb[freeNode].length = node THEN            BEGIN  -- coalesce with preceding free node            zb[freeNode].length ¬ zb[freeNode].length + zb[node].length;	    zb[node] ¬ NodeHeader[0, free[fwdp: NULL, backp: NULL]];            IF roverStrategy = MRF THEN z.rover ¬ freeNode;            RETURN[okay];            END          ELSE            BEGIN  -- can't coalesce, so just insert new free node in list            zb[node] ¬ NodeHeader[              zb[node].length, free[fwdp: zb[freeNode].fwdp, backp: freeNode]];            zb[freeNode].fwdp ¬ zb[zb[freeNode].fwdp].backp ¬ LOOPHOLE[node,              FreeNodePointer];            IF roverStrategy = MRF THEN z.rover ¬ LOOPHOLE[node, FreeNodePointer];            RETURN[okay];            END;        -- no other free nodes in this segment, so just add new free node at end of free list        zb[node] ¬ NodeHeader[length, free[z.freeList, z.node.backp]];        z.node.backp ¬ zb[z.node.backp].fwdp ¬ LOOPHOLE[node, FreeNodePointer];        IF roverStrategy = MRF THEN z.rover ¬ LOOPHOLE[node, FreeNodePointer];        RETURN[okay];        END;      ENDCASE => RETURN[invalidNode];    END;  GetAttributes: PUBLIC ENTRY PROC [zH: Zone.Handle]    RETURNS [      zoneBase: Zone.Base, threshold: Zone.BlockSize, checking: BOOLEAN,      storage: LONG POINTER, length: Zone.BlockSize, next: Zone.SegmentHandle] =    -- Returns the attributes of the zone (without checking)    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    RETURN[      zoneBase: z.zoneBase, threshold: z.threshold, checking: z.checking,        storage: @z, length: z.length, next: LOOPHOLE[z.nextSegment]]    END;  GetRootNode: PUBLIC PROC [zH: Zone.Handle]    RETURNS [node: Zone.Base RELATIVE POINTER] = {    RETURN[LOOPHOLE[LOOPHOLE[zH, ZonePointer].root]]};  GetSegmentAttributes: PUBLIC ENTRY PROC [    zH: Zone.Handle, sH: Zone.SegmentHandle]    RETURNS [      storage: LONG POINTER, length: Zone.BlockSize, next: Zone.SegmentHandle] =    -- Returns the next segment in the chain, given sH; returns nullSegment if    -- there is none.  This procedure does not check the zone or segment for    -- validity    BEGIN    OPEN z: LOOPHOLE[zH, ZonePointer],      seg: z.zoneBase[LOOPHOLE[sH, SegmentPointer]];    sp: SegmentPointer = LOOPHOLE[sH];    IF sH # nullSegment THEN      RETURN[storage: @seg, length: seg.length, next: LOOPHOLE[seg.nextSegment]]    END;  MakeNode: PUBLIC ENTRY PROC [    zH: Zone.Handle, n: Zone.BlockSize, alignment: Zone.Alignment]    RETURNS [node: Zone.Base RELATIVE POINTER, s: Zone.Status] =    -- Allocates a node of size n from the free list.  The node is aligned on a    -- multiple-word boundary determined by alignment.  Search for a suitable    -- node begins with z.rover; adjacent free nodes are coalesced on the way;    -- a large node is split in two if the remainder after allocating the node    -- is larger than z.threshold    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    rover: FreeNodePointer ¬ z.rover;    temp, neighbour: NodePointer;    nodelength, nl: Zone.BlockSize;    n ¬ MAX[n + usedNodeSize, freeNodeSize];    --add the node overhead to the length of the request    IF z.checking THEN IF (s ¬ CheckZone[zH]) # okay THEN RETURN[nil, s];    IF roverStrategy = head THEN z.rover ¬ rover ¬ z.node.fwdp;    -- start cycling through the free list    DO      nodelength ¬ zb[rover].length;      IF ~SpecialFreeNode[zb, rover, nodelength] THEN        BEGIN        --	first coalesce all free nodes adjacent to the rover        FOR neighbour ¬ rover + nodelength, neighbour + nl DO          WITH zb[neighbour] SELECT FROM            inuse => EXIT;            free =>              BEGIN  -- coalesce              IF (nl ¬ length) = 0 THEN EXIT;  -- end of zone              IF SpecialFreeNode[zb, neighbour, nl] THEN EXIT;  -- don't coalesce with special free node              zb[fwdp].backp ¬ backp;              zb[backp].fwdp ¬ fwdp;              z.rover ¬ rover;  -- in case neighbor was z.rover              nodelength ¬ nodelength + nl;              END;            ENDCASE;          ENDLOOP;        -- if the node pointed to by rover is big enough        -- and alignment is not required, allocate it        IF alignment = a1 AND nodelength >= n THEN          BEGIN  -- if it was too big, first split off the remainder          IF (nl ¬ (nodelength - n)) > z.threshold THEN            BEGIN  -- split the block            z.rover ¬ rover;            zb[rover].length ¬ nl;            temp ¬ LOOPHOLE[rover + nl];            nodelength ¬ n;            END          ELSE            BEGIN            zb[zb[rover].fwdp].backp ¬ zb[rover].backp;            z.rover ¬ zb[zb[rover].backp].fwdp ¬ zb[rover].fwdp;            temp ¬ LOOPHOLE[rover];            END;          zb[temp] ¬ NodeHeader[nodelength, inuse[]];          RETURN[LOOPHOLE[temp + usedNodeSize], okay]          END          -- otherwise, either this node is not big enough or          -- special alignment is required        ELSE zb[rover].length ¬ nodelength;        -- if multiple word alignment is required, see if we can carve up        -- this node to fit        IF alignment # a1 THEN          BEGIN          zr: LONG ORDERED POINTER = LOOPHOLE[@zb[rover]];          mask: WORD = Inline.BITSHIFT[177777B, LOOPHOLE[alignment, INTEGER]];          aPtr: MACHINE DEPENDENT RECORD [            SELECT OVERLAID * FROM            lp => [lp: LONG ORDERED POINTER],            num => [lowbits, highbits: CARDINAL],            ENDCASE];          aPtr.lp ¬ zr + nodelength - n + usedNodeSize;          --address of the node (without node overhead)          aPtr.lowbits ¬ Inline.BITAND[aPtr.lowbits, mask];          --address rounded down to be aligned          aPtr.lp ¬ aPtr.lp - usedNodeSize;  --subtract the node overhead again          -- check if node fits exactly          IF aPtr.lp = zr THEN            BEGIN            zb[zb[rover].fwdp].backp ¬ zb[rover].backp;            z.rover ¬ zb[zb[rover].backp].fwdp ¬ zb[rover].fwdp;            temp ¬ LOOPHOLE[rover];            END            -- check if we can safely break off and free the front of the node          ELSE            IF aPtr.lp >= zr + z.threshold THEN              BEGIN  -- split the block              diff: Inline.LongNumber;              diff.lc ¬ aPtr.lp - zr;              z.rover ¬ rover;              zb[rover].length ¬ diff.lowbits;              temp ¬ LOOPHOLE[rover + diff.lowbits];              nodelength ¬ nodelength - diff.lowbits;              END              -- otherwise, we failed to allocate from this node            ELSE GO TO failure;          zb[temp] ¬ NodeHeader[nodelength, inuse[]];          [] ¬ Split[zH, temp, n];          RETURN[LOOPHOLE[temp + usedNodeSize], okay];          EXITS failure => NULL          END;        END;  -- IF ~SpecialFreeNode      -- Check to see if we have gone around the chain of free nodes      IF (rover ¬ zb[rover].fwdp) = z.rover THEN EXIT;      ENDLOOP;    RETURN[nil, noRoomInZone];    END;  NodeSize: PUBLIC PROC [p: LONG POINTER] RETURNS [Zone.BlockSize] =    BEGIN    -- Returns the actual size of the allocated node (not including the    -- overhead).  The node is not checked for validity    node: LONG POINTER TO NodeHeader = p - usedNodeSize;    RETURN[node.length - usedNodeSize]    END;  LongPointerDifference: TYPE = MACHINE DEPENDENT RECORD [    lowHalf: RPtr, highHalf: CARDINAL];  Recreate: PUBLIC PROC [storage: LONG POINTER, zoneBase: Zone.Base]    RETURNS [      zH: Zone.Handle, rootNode: Zone.Base RELATIVE POINTER, s: Zone.Status] =    -- **NOTE: Currently the storage pointer and base supplied MUST be offset    -- by the same amount that they were before the zone was recreated.  This    -- should be fixed someday.    BEGIN    z: ZonePointer ¬ LOOPHOLE[storage];    zH ¬ LOOPHOLE[z];    IF z.seal # zoneSeal THEN {s ¬ wrongSeal; RETURN};    IF z.version # zoneVersion THEN {      rootNode ¬ LOOPHOLE[z.root]; s ¬ wrongVersion; RETURN};    z.zoneBase ¬ LOOPHOLE[zoneBase];    rootNode ¬ LOOPHOLE[z.root];    s ¬ ValidateZone[zH];    IF s # okay THEN RETURN;    Process.InitializeMonitor[@z.LOCK];    RETURN;    END;  Relative: PROC [base, p: LONG POINTER] RETURNS [RPtr] =    -- computes a RELATIVE POINTER with respect to the zoneBase of zone z.    -- No check is made to see that p is within range of base    INLINE {RETURN[LOOPHOLE[p - base, LongPointerDifference].lowHalf]};   IsZoneEmpty: PUBLIC ENTRY PROCEDURE[zH: Zone.Handle]    RETURNS[empty: BOOLEAN ¬ TRUE] =     BEGIN      z: ZonePointer = LOOPHOLE[zH];     sH: Zone.SegmentHandle ¬ LOOPHOLE[z.nextSegment];     zb: OrderedBase = z.zoneBase;     nl: Zone.BlockSize;     node: NodePointer;     firstNode: NodePointer = LOOPHOLE[Relative[zb,z] + zoneHeaderSize];     lastNode: NodePointer = LOOPHOLE[Relative[zb,z] + z.length - usedNodeSize];     --Check to see if initial segment is empty.     FOR node ¬ firstNode, node + nl WHILE node < lastNode AND empty DO       nl ¬ zb[node].length;        WITH zb[node] SELECT FROM          inuse => empty ¬ FALSE;          ENDCASE;        ENDLOOP;     --Check added on segments.     WHILE sH # nullSegment AND empty DO       IF IsSegmentEmptyInternal[zH,sH] THEN          sH ¬ LOOPHOLE[zb[LOOPHOLE[sH,SegmentPointer]].nextSegment]          ELSE empty ¬ FALSE;     ENDLOOP;   END;   IsSegmentEmpty: PUBLIC ENTRY PROCEDURE[zH: Zone.Handle, sH: Zone.SegmentHandle]    RETURNS[empty: BOOLEAN ¬ TRUE] =    BEGIN    empty ¬ IsSegmentEmptyInternal[zH, sH];    END;         IsSegmentEmptyInternal: PROCEDURE[zH: Zone.Handle, sH: Zone.SegmentHandle]    RETURNS[empty: BOOLEAN ¬ TRUE] =    BEGIN     zb: OrderedBase = LOOPHOLE[zH, ZonePointer].zoneBase;     sp: SegmentPointer = LOOPHOLE[sH];     lastNode: NodePointer = LOOPHOLE[sp + zb[sp].length - usedNodeSize];     node: NodePointer;     nl: Zone.BlockSize;         -- Check to see if segment is empty     FOR node ¬ LOOPHOLE[sp + segmentHeaderSize], node + nl      WHILE node < lastNode AND empty DO       nl ¬ zb[node].length;        WITH zb[node] SELECT FROM          inuse => empty ¬ FALSE;          ENDCASE;        ENDLOOP;    END;           RemoveSegment: PUBLIC ENTRY PROC [zH: Zone.Handle, sH: Zone.SegmentHandle]    RETURNS [storage: LONG POINTER, s: Zone.Status] =    -- short description of what this procedure does    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    sp: SegmentPointer = LOOPHOLE[sH];    lastNode: NodePointer = LOOPHOLE[sp + zb[sp].length - usedNodeSize];    t: SegmentPointer;    node: NodePointer;    nl: Zone.BlockSize;    storage ¬ @zb[sp];    IF (s ¬ ValidateZone[zH]) # okay THEN RETURN[storage, s];    IF z.checking THEN IF (s ¬ CheckZone[zH]) # okay THEN RETURN[storage, s];    IF sp = nilSeg THEN RETURN[storage, invalidSegment];    -- Check to see if segment is empty    FOR node ¬ LOOPHOLE[sp + segmentHeaderSize], node + nl WHILE node < lastNode      DO      nl ¬ zb[node].length;      WITH zb[node] SELECT FROM        inuse => RETURN[storage, nonEmptySegment];        ENDCASE;      ENDLOOP;    -- Remove segment from chain    IF sp = z.nextSegment THEN z.nextSegment ¬ zb[sp].nextSegment    ELSE      FOR t ¬ z.nextSegment, zb[t].nextSegment WHILE t ~= nilSeg DO        IF sp = zb[t].nextSegment THEN GOTO unlink;        REPEAT          unlink => zb[t].nextSegment ¬ zb[sp].nextSegment;          --remove the segment from the chain          FINISHED => RETURN[storage, invalidSegment];        --OOPS! The segment was not part of this zone        ENDLOOP;    -- Remove all free nodes from free list    FOR node ¬ LOOPHOLE[sp + segmentHeaderSize], node + nl WHILE node < lastNode      DO      nl ¬ zb[node].length;      WITH zb[node] SELECT FROM        inuse => EXIT;        -- as a result of previous checking,        -- we are guaranteed to be at end of segment now.        free => BEGIN zb[backp].fwdp ¬ fwdp; zb[fwdp].backp ¬ backp; END;        ENDCASE;      ENDLOOP;    z.rover ¬ z.node.fwdp;  --reset rover to be outside segment    RETURN[storage, okay];    END;  SetChecking: PUBLIC ENTRY PROC [zH: Zone.Handle, checking: BOOLEAN]    RETURNS [s: Zone.Status] =    -- sets the checking attribute of the zone;    -- if this is true, the zone is checked    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    z.checking ¬ checking;    s ¬ IF checking THEN CheckZone[zH] ELSE okay;    END;  SetRootNode: PUBLIC PROC [zH: Zone.Handle, node: Zone.Base RELATIVE POINTER] = {    LOOPHOLE[zH, ZonePointer].root ¬ LOOPHOLE[node]};  SpecialFreeNode: INTERNAL PROC [    zb: OrderedBase, node: NodePointer, nl: Zone.BlockSize] RETURNS [BOOLEAN] =    -- Returns TRUE if node is the special free node at the end of a segment.  This special    -- free node should not be allocated or coalesced with a preceding free node because    -- its purpose in life is to guarantee that FreeNodeInternal can always find a free    -- node following the node being freed.  This allows FreeNodeInternal to avoid    -- traversing the segment list.  Such a traversal can be very costly in terms of page    -- faults and working set.  Note that Rubicon-created zones do not have such a free node    -- at the end of each segment, so compatibility requires not counting on its presence.    {    RETURN[      nl = freeNodeSize AND zb[node + nl].state = inuse        AND zb[node + nl].length = usedNodeSize]};  Split: INTERNAL PROC [zH: Zone.Handle, node: NodePointer, n: Zone.BlockSize]    RETURNS [s: Zone.Status] =  -- does the actual work of splitting a node    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    lastpart: NodePointer;    t: INTEGER;    IF z.checking THEN IF (s ¬ CheckZone[zH]) # okay THEN RETURN[s];    n ¬ MAX[n + usedNodeSize, freeNodeSize];    --ensure that node remains large enough to free    WITH zb[node] SELECT FROM      free => RETURN[invalidNode];      inuse =>        IF (t ¬ zb[node].length - n) >= z.threshold THEN          BEGIN  --fabricate a free node out of the last part of the split node          zb[node].length ¬ n;  --adjust size of remaining node          lastpart ¬ LOOPHOLE[node + n];          zb[lastpart] ¬ NodeHeader[length: t, extension: inuse[]];  -- fabricate node          RETURN[FreeNodeInternal[zH, lastpart]];  -- free it          END;      ENDCASE;    RETURN[okay]    END;  SplitNode: PUBLIC ENTRY PROC [    zH: Zone.Handle, p: LONG POINTER, n: Zone.BlockSize]    RETURNS [s: Zone.Status] =    -- Splits a node, keeping the first n words and freeing the rest.    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    node: NodePointer = Relative[zb, p - usedNodeSize];    RETURN[Split[zH, node, n]]    END;  ValidateZone: PUBLIC PROC [zH: Handle] RETURNS [Zone.Status] =    -- Checks to see that the zone is well-formed    BEGIN OPEN z: LOOPHOLE[zH, ZonePointer];    zb: OrderedBase = z.zoneBase;    lastNodePointer: LONG POINTER =      LOOPHOLE[zH, ZonePointer] + z.length - usedNodeSize;    -- to get around a compiler bug (this constant could be embedded in the declaration of the next one    lastNode: NodePointer;    sp: SegmentPointer;    -- Check seal and version    IF z.seal # zoneSeal THEN RETURN[wrongSeal];    IF z.version # zoneVersion THEN RETURN[wrongVersion];    -- Check that primary storage of zone is okay    lastNode ¬ Relative[zb, lastNodePointer];    SELECT TRUE FROM      (z.node.length # 0), (zb[lastNode].length # usedNodeSize),        (zb[z.node.fwdp].backp # z.freeList OR zb[z.node.backp].fwdp # z.freeList)        => RETURN[invalidZone];      ENDCASE;    -- Check that additional segments of zone are okay    FOR sp ¬ z.nextSegment, zb[sp].nextSegment WHILE sp # nilSeg DO      lastNode ¬ LOOPHOLE[sp + zb[sp].length - usedNodeSize, NodePointer];      IF zb[lastNode].length # usedNodeSize THEN RETURN[invalidSegment]      ENDLOOP;    RETURN[okay]    END;  END.LOG   (For previous log entries, please see Mesa 8.0 archive version.)7-Aug-81 16:15:32	CRF   Reworked FreeNode to keep free list sorted in virtual memory location   order for each segment.  Added a special free node at the end of each segment   to make freeing a node easier.  Note that the new code is compatible with the   Pilot 6.0 zone implementation in which the free list was not sorted, and in   which there was no special free node at the end of each segment.  Created   FreeNodeInternal from the guts of FreeNode so that Split could call it rather   than do the freeing itself.  For the sake of performance experiments, added   roverStrategy variable.21-Aug-81 17:09:40	AWL         Changes to accomodate ZoneInternal.TemporaryBlocksize ~= Zone.BlockSize.   Changes for Zone.Handle and SegmentHandle being exported types.20-Nov-81 10:53:53	JXP      Added procedures IsSegmentEmpty and IsZoneEmpty5-Oct-82 15:13:04	JXP      Changed FreeNodeInternal so that when a node is coalesced with a previous   free block, that node's type is changed from free to inuse. Done solely   for checking purposes.27-Oct-82 17:01:54	WDK        StoragePrograms replaces MiscPrograms.21-Dec-82 12:13:30	AWL         Get nil and nullSegment from Zone interface. 4-Nov-83 12:17:55	AWL         IsSegmentEmpty had a dangerous, unitialized variable.28-Dec-83 15:44:55	EKN     FreeNodeInternal will raise Bug[heapSmash] if the nextNode length is 0 7-Feb-84 15:00:52      KEK       Changed IsSegmentEmpty to handle deadlock with IsZoneEmpty.  Changed IsZoneEmpty to   check initial segment.
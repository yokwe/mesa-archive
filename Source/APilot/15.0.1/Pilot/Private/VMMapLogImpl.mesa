-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- VMMapLogImpl.mesa     2-Oct-86 10:20:24 by RSV  -- This module really has trouble with exported types! -- TO DO:--   Use an actual Usage for the buffer.-- NOTES:--   This module no longer is able to check whether it is reading or writing--   the correct page.  This check used to be done by using a checksum of the--   label field of the first page, but since labels no longer exist, this is--   no longer possible.DIRECTORY  Environment USING [PageNumber],  Inline USING [LongCOPY, LongCOPYReverse],  VMMapLog USING [    Entry, EntryHandle, DiskErrorType, Log, Operation, SpecialLookup],  VMMapLogInternal USING [Entry, EntryHandle],  DiskChannel USING [    Create, defaultTries, DoIO, Drive, GetNextDrive, GetDriveTag, Handle,    goodCompletion, IORequest, IOStatus, nullDrive],  Space USING [    Interval, PageFromLongPointer, PageOffset],  VM USING [MakeResident, MakeSwappable, ReturnWait];VMMapLogImpl: MONITOR  -- just protects buffer, etc for MovePages.  IMPORTS DiskChannel, Inline, Space, VM EXPORTS VMMapLog =  BEGIN  -- Public Items:  nullEntry: PUBLIC Entry ¬ [    page: 0, count: 0, writeProtected: FALSE, fill: 0,    backingStorage: nil[ALL[0]]];  InvalidPageNumber: PUBLIC ERROR = CODE;  DiskError: PUBLIC ERROR [error: VMMapLog.DiskErrorType] = CODE;  LogFull: PUBLIC ERROR = CODE;  WriteProtected: PUBLIC ERROR = CODE;  Unmapped: PUBLIC ERROR = CODE;  -- Implementation Items:  Entry: PUBLIC TYPE = VMMapLogInternal.Entry;  E: PROC [e: VMMapLog.Entry] RETURNS [VMMapLogInternal.Entry] = INLINE    -- Use of this procedure is the only way to access the opaque Entries    -- inside a VMMapLog.LogDesc without loopholes.    {RETURN[e]};    PEntries: TYPE =  -- for debugger.    LONG POINTER TO ARRAY [0..2000--say--) OF VMMapLogInternal.Entry;  drive: DiskChannel.Drive ¬ DiskChannel.nullDrive;  chan: DiskChannel.Handle;  Bug: PRIVATE ERROR [type: BugType] = CODE;  BugType: TYPE = {    cantFindDrive, driveNotReady, duplicateOrOverlappingMapEntry,    impossibleEndcase, inProgressReturnedByDoIO,    invalidEntryType, myError, mapEntryHasTooManyPages,    mapEntryMissing, offEndOfLog, problemWithDrive};  FindEntry: PUBLIC PROCEDURE [    vmPage: Environment.PageNumber, log: VMMapLog.Log,    specialLookup: VMMapLog.SpecialLookup]    RETURNS [entry: LONG POINTER TO Entry] =    BEGIN    hi: CARDINAL ¬ log.count - 1;    lo: CARDINAL ¬ 0;    IF log.count = 0 THEN ERROR Unmapped;    WHILE hi >= lo DO      mid: CARDINAL = (hi + lo)/2;      entry ¬        (IF specialLookup = NIL THEN @log.entries[mid]         ELSE specialLookup[log, mid]);      SELECT vmPage FROM        > entry.page + entry.count - 1 => lo ¬ mid + 1;        < entry.page => IF mid = 0 THEN EXIT ELSE hi ¬ mid - 1        ENDCASE => RETURN;      ENDLOOP;    ERROR Unmapped;    END;  --FindEntry--  FindFirstForInsert: PUBLIC PROCEDURE [log: VMMapLog.Log]    RETURNS [index: CARDINAL] =    BEGIN    FOR index IN [0..log.count - 1) DO      IF E[log.entries[index]].page > E[log.entries[index + 1]].page THEN RETURN;      ENDLOOP;    index ¬ log.count;    END;  InEntry: PUBLIC PROCEDURE [    page: Environment.PageNumber, entry: VMMapLogInternal.EntryHandle]    RETURNS [BOOLEAN] = {RETURN[page IN [entry.page..entry.page + entry.count)]};  InsertEntry: PUBLIC PROCEDURE [    entry: LONG POINTER TO Entry, log: VMMapLog.Log] =    BEGIN    entryEnd: Environment.PageNumber ¬ entry.page + entry.count;    hi: CARDINAL;    lo: CARDINAL ¬ 0;    IF entry.count = 0 THEN RETURN;  -- a vacuous entry    IF log.count > 0 THEN      BEGIN      mid: CARDINAL;      IF E[log.entries[hi ¬ log.count-1]].page < entry.page      THEN {lo ¬ log.count; GOTO done};      -- Find the spot to insert into --      WHILE hi >= lo DO        mid ¬ (hi + lo)/2;        SELECT E[log.entries[mid]].page FROM          > entry.page => IF mid = 0 THEN EXIT ELSE hi ¬ mid - 1;          < entry.page => lo ¬ mid + 1;          ENDCASE => {lo ¬ mid; EXIT};        ENDLOOP;      EXITS done => NULL;      END    ELSE lo ¬ 0;  -- this is the first entry    --ASSERT: entry.page <= log.entries[lo].page    -- or alternatively: log.entries[lo].page >= entry.page.        IF entry.kind = nil THEN      BEGIN  -- it's an unmap      -- Accumulate the entries that are covered by this unmap:      -- Note that any of the matching map entries may be absent due to       --   their cancellation and re-use in the debugee world.      maxDeletableEntries: CARDINAL = log.count - lo;      entriesToDelete: CARDINAL;      FOR entriesToDelete ¬ 0, entriesToDelete.SUCC        WHILE entriesToDelete < maxDeletableEntries	AND E[log.entries[lo + entriesToDelete]].page < entryEnd DO  --	--ASSERT: entries[lo + entriesToDelete].page >= entry.page.        ENDLOOP;      -- Delete the map entries:      Inline.LongCOPY[        from: @log.entries[lo + entriesToDelete], to: @log.entries[lo],	nwords: (log.count-(lo + entriesToDelete))*VMMapLog.Entry.SIZE];      log.count ¬ log.count - entriesToDelete;      END    ELSE      BEGIN  -- it's a map      IF log.count >= log.limit THEN ERROR LogFull;      IF lo < log.count THEN        BEGIN  -- there is a following entry.        IF entry.page = E[log.entries[lo]].page	OR entryEnd > E[log.entries[lo]].page THEN	  ERROR Bug[duplicateOrOverlappingMapEntry];	END;      -- Make room in table:      Inline.LongCOPYReverse[        from: @log.entries[lo], to: @log.entries[lo + 1],	nwords: (log.count-lo)*VMMapLog.Entry.SIZE];      log.entries[lo] ¬ entry­;  -- insert the new map entry      log.count ¬ log.count + 1;      END;    END;  --InsertEntry--  IsWriteProtected: PUBLIC PROCEDURE [entry: VMMapLogInternal.EntryHandle]    RETURNS [BOOLEAN] = {RETURN[entry.writeProtected]};  MovePages: PUBLIC ENTRY PROCEDURE [    op: VMMapLog.Operation, clientVMPage: Environment.PageNumber,    entry: VMMapLogInternal.EntryHandle, buffer: Space.Interval,    count: Environment.PageNumber ¬ 1] =    BEGIN    ENABLE UNWIND => NULL;  -- unlock monitor.    WITH diskEntry: entry SELECT FROM      disk =>  -- (this is the only valid variant)        BEGIN  --disk entry--        req: DiskChannel.IORequest;        offset: Space.PageOffset ¬ clientVMPage - entry.page;        status: DiskChannel.IOStatus;        IF clientVMPage + count > diskEntry.page + diskEntry.count THEN          RETURN WITH ERROR InvalidPageNumber;        -- Find the Drive, create a channel to it:        IF drive = DiskChannel.nullDrive          OR diskEntry.driveTag # DiskChannel.GetDriveTag[drive] THEN          BEGIN          drive ¬ DiskChannel.nullDrive;          UNTIL (drive ¬ DiskChannel.GetNextDrive[drive]) = DiskChannel.nullDrive            DO            IF DiskChannel.GetDriveTag[drive] = diskEntry.driveTag THEN {              chan ¬ DiskChannel.Create[drive]; EXIT};            REPEAT FINISHED => ERROR Bug[cantFindDrive];            ENDLOOP;          END;        -- Set the IO request block to move a run of pages --        req.diskPage ¬ diskEntry.diskPage + offset;        req.tries ¬ DiskChannel.defaultTries;        req.useSamePage ¬ FALSE;        req.command ¬          IF op = write THEN write ELSE read;        req.count ¬ count;        req.memoryPage ¬ Space.PageFromLongPointer[buffer.pointer];        VM.MakeResident[          [Space.PageFromLongPointer[buffer.pointer], buffer.count], wait];        status ¬ DiskChannel.DoIO[chan, @req].status;        VM.MakeSwappable[          [Space.PageFromLongPointer[buffer.pointer], buffer.count]];        IF status # DiskChannel.goodCompletion THEN {  -- (test is perf accelerator only)          SignalIfError[status]};        END;  --disk entry--      ENDCASE => ERROR Bug[invalidEntryType];  -- all other types are invalid    END;  --MovePages--  SeeEntry: PUBLIC PROCEDURE [entry: VMMapLogInternal.EntryHandle]    RETURNS [page: Environment.PageNumber, count: [1..4096]] = {    RETURN[page: entry.page, count: entry.count]};  SignalIfError: PROCEDURE [status: DiskChannel.IOStatus] =    -- NOTE: The caller is responsible for unlocking his monitor (through    -- UNWINDS).    BEGIN    WITH status SELECT FROM      invalidChannel, invalidDriveState => ERROR Bug[problemWithDrive];      disk =>        SELECT status FROM          inProgress => ERROR Bug[inProgressReturnedByDoIO];          goodCompletion => NULL;          notReady => ERROR Bug[driveNotReady];          headerCRCError, dataCRCError, headerNotFound, dataVerifyError =>	    RETURN WITH ERROR DiskError[unreadablePage];          writeFault, memoryError, memoryFault, clientError => ERROR Bug[myError];          recalibrateError, seekTimeout, overrunError, otherError =>            RETURN WITH ERROR DiskError[hardwareError];          ENDCASE => ERROR Bug[impossibleEndcase];      ENDCASE => ERROR Bug[impossibleEndcase];    END;  --SignalIfError--  END.Log12-Jan-82 19:35:23   JXP      Fixed problem in bin searches in insertEntry and and FindEntry to handle   a boundary condition24-Feb-82 11:46:49   AWL         When writing, make the client's buffer resident and implement SpecialLookup24-Mar-82 23:26:42   RXJ        Write from "buffer" instead of "labelReadBuffer"!18-Apr-83 18:23:53   EKN   	Update to Klamath 9-May-83 18:07:44   WDK        Don't map infinite size labelReadBuffer. Use Map rather than Allocate + MapAt. MovePages: Clarify logic and comments for combining label read with user request. label read should be vrr, not vvr. Don't use RuntimeInternal. Merge all private errors. Create local definition for SpecialLookup; Improve documentation of local definition of Log; shoot corresponding LOOPHOLEs. Alphabetize procs. Improve error handling, especially on label read. Use LongCOPY for table manipulation. 4-Jul-83 18:06:54   WDK     	count=0 means vacuous entry.13-Jul-83 14:25:11   AWL      	nullEntry must set all fields.24-Aug-83 18:18:15   WDK        Add sanity checks in InsertEntry. Didn't handle unmap with no or only partial matching map entries. Didn't detect duplicate or overlapping maps.25-Aug-83  9:47:16   WDK     	Don't check if insert at end. 8-Oct-84 17:41:50   EKN        Copyrite formatted. 9-Jul-86 16:57:58   CJS	Added AHL's perf perk to InsertEntry. 2-Oct-86 10:20:24   RSV        Convert to labelless by changing MovePages to read immediately into the client's buffer (rather than the and not do any checksums on the label.  Also changed SignalError to not return a boolean (which wasn't being initialized anyway).
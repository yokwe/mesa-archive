-- Copyright (C) 1983, 1986, 1987  by Xerox Corporation. All rights reserved. -- SnapshotImpl.mesa      27-Sep-87 21:43:24 by KEK    DIRECTORY  Boot USING [    DiskFileID, EthernetRequest, Location, LVBootFiles, NullDiskFileID,    PVBootFiles],  BootFile,  GermOps USING [InLoad, OutLoad],  Device USING [Type],  DeviceTypes USING [ethernet, ethernetOne],  DeviceTypesExtras4 USING [fad5000],  DeviceCleanup USING [Perform],  Environment USING [PageCount, wordsPerPage],  FloppyChannel USING [DiskAddress],  File USING [File, GetSize, PageCount, PageNumber, Type],  FileTypes USING [tUntypedFile],  Frame USING [GetReturnFrame],  Inline USING [LowHalf, HighHalf],  KernelFile USING [GetBootLocation, MakeBootable, MakeUnbootable],  PhysicalVolume USING [    GetAttributes, GetContainingPhysicalVolume, ID, InterpretHandle],  PilotDisk,  PilotDiskFace USING [DiskAddress],  PrincOps USING [ControlLink, Port],  PrincOpsExtras2,  ProcessOperations USING [    DisableInterrupts, EnableInterrupts, ReadPSB, ReadPTC, ReadWDC,    WritePSB, WritePTC, WriteWDC],  ProcessorFace USING [BootButton, mp, SpecialSetMP],  PSB USING [PsbHandle],  RuntimeInternal USING [Bug],  RuntimePrograms USING [],  Snapshot USING [],  SpecialFile USING [InvalidParameters],  SpecialBooting USING [],  SpecialBootingExtras USING [],  SpecialSpace USING [    MakeProcedureResident, MakeProcedureSwappable, SpecialError],  SpecialVolume USING [    GetLogicalVolumeBootFiles, GetPhysicalVolumeBootFiles,    SetLogicalVolumeBootFiles, SetPhysicalVolumeBootFiles],  StoragePrograms USING [RecoverMStore],  System USING [defaultSwitches, Switches],  TemporaryBooting USING [BootLocation],  TemporarySetGMT USING [FixupClock],  Volume USING [ID];  SnapshotImpl: MONITOR  -- just to protect space used by MakeBootable  IMPORTS    Boot, DeviceCleanup, File, Frame, GermOps, Inline, KernelFile,    PhysicalVolume, ProcessOperations, ProcessorFace, RuntimeInternal,    SpecialFile, SpecialSpace, SpecialVolume, StoragePrograms, TemporarySetGMT  EXPORTS RuntimePrograms, Snapshot, SpecialBooting, SpecialBootingExtras,    TemporaryBooting  SHARES File =    BEGIN    PVLocation: PUBLIC --TemporaryBooting.-- TYPE =  ARRAY [0..11) OF WORD;  VolumeLocation: PUBLIC --TemporaryBooting.-- TYPE = ARRAY [0..11) OF WORD;  FileLocation: PUBLIC --TemporaryBooting.-- TYPE =  ARRAY [0..11) OF WORD;   tBootFile: PUBLIC --TemporaryBooting.-- File.Type ¬    FileTypes.tUntypedFile;  -- delete this soon...       InvalidParameters: PUBLIC --TemporaryBooting.-- ERROR = CODE;  InvalidVersion: PUBLIC --TemporaryBooting.-- ERROR = CODE;  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  BugType: TYPE = {fileTooLong, germTooLarge, impossibleEndcase};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeSnapshot: PUBLIC  --RuntimePrograms.-- PROCEDURE =    BEGIN    [] ¬ InitializeInLoadFromBootLoc[];  -- allocate frame, initialize PORT    END;      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- PUBLIC Procedures:    (TemporaryBooting, Snapshot, and SpecialBooting)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~          BootButton: PUBLIC --TemporaryBooting.-- PROCEDURE [switches: System.Switches] =    BEGIN    -- WHAT SHOULD WE DO WITH THE SWITCHES?    ProcessorFace.BootButton[]  -- never returns    END;  BootFromFloppy: PUBLIC --SpecialBootingExtras.-- PROCEDURE [    floppyRequest: FloppyChannel.DiskAddress,    deviceOrdinal: CARDINAL ¬ 0,    switches: System.Switches ¬ System.defaultSwitches] =    BEGIN    location: Boot.Location ¬ [      deviceType: DeviceTypesExtras4.fad5000,      deviceOrdinal: deviceOrdinal,      vp: NULL];    location.diskFileID.fID ¬ PilotDisk.nullFileID;	--NOT USED     location.diskFileID.firstPage ¬ 0;		--NOT USED     location.diskFileID.da ¬ LOOPHOLE[floppyRequest];    InLoadFromBootLocation[      pMicrocode: NIL, pGerm: NIL, countGerm: 0,      location: @location, switches: switches];    END; --BootFromFloppy--  BootFromEthernet: PUBLIC --SpecialBooting.-- PROCEDURE [    ethernetRequest:Boot.EthernetRequest, deviceOrdinal:CARDINAL ¬ 0,    switches:System.Switches ¬ System.defaultSwitches] =    BEGIN    location: Boot.Location ¬ [      deviceType: DeviceTypes.ethernet, deviceOrdinal: deviceOrdinal,      vp: ethernet[ethernetRequest: ethernetRequest]];    InLoadFromBootLocation[      pMicrocode: NIL, pGerm: NIL, countGerm: 0, location: @location,      switches: switches];    END;  BootFromEthernetOne: PUBLIC --SpecialBooting.-- PROCEDURE [    bootFileNumber, net, host:CARDINAL, deviceOrdinal:CARDINAL ¬ 0,    switches:System.Switches ¬ System.defaultSwitches] =    BEGIN    location: Boot.Location ¬ [      deviceType: DeviceTypes.ethernetOne, deviceOrdinal: deviceOrdinal,      vp: ethernetOne[bootFileNumber: bootFileNumber, net: net, host: host]];    InLoadFromBootLocation[      pMicrocode: NIL, pGerm: NIL, countGerm: 0, location: @location,      switches: switches];    END;  BootFromFile: PUBLIC --TemporaryBooting.-- PROCEDURE [    file: File.File, firstPage: File.PageNumber, switches: System.Switches] =    BEGIN    InLoad[      pMicrocode: NIL, pGerm: NIL, countGerm: 0, file: file, firstPage: firstPage,      switches: switches]    END;  -- This procedure should be changed to take a PhysicalVolume.ID:  BootFromPhysicalVolume: PUBLIC PROCEDURE [    volume: Volume.ID, switches: System.Switches] =    BEGIN    pvID: PhysicalVolume.ID = PhysicalVolume.GetContainingPhysicalVolume[volume];    bootFiles: Boot.PVBootFiles;    location: Boot.Location;    SpecialVolume.GetPhysicalVolumeBootFiles[pvID, @bootFiles];    location.diskFileID ¬ bootFiles[pilot];    [deviceType: location.deviceType, deviceOrdinal: location.deviceOrdinal] ¬      GetDevice[pvID];    InLoadFromBootLocation[      pMicrocode: NIL, pGerm: NIL, countGerm: 0, location: @location,      switches: switches]    END;  BootFromVolume: PUBLIC --TemporaryBooting.-- PROCEDURE [volume: Volume.ID, switches: System.Switches] =    BEGIN    bootFiles: Boot.LVBootFiles;    location: Boot.Location;    SpecialVolume.GetLogicalVolumeBootFiles[volume, @bootFiles];    location.diskFileID ¬ bootFiles[pilot];    [deviceType: location.deviceType, deviceOrdinal: location.deviceOrdinal] ¬      GetDevice[PhysicalVolume.GetContainingPhysicalVolume[volume]];    InLoadFromBootLocation[      pMicrocode: NIL, pGerm: NIL, countGerm: 0, location: @location,      switches: switches]    END;  GetFileLocation: PUBLIC --TemporaryBooting.-- PROCEDURE [    file: File.File, firstPage: File.PageNumber]    RETURNS [bootLocation: file TemporaryBooting.BootLocation] =    BEGIN     type: Device.Type;    ord: CARDINAL;    diskAddress: PilotDiskFace.DiskAddress;    loc: Boot.Location;    id: Boot.DiskFileID;        -- test if firstPage specified is within bounds of the file    size: File.PageCount ¬ File.GetSize[file];    bootLocation ¬ [body:file[NULL]];    IF firstPage >= size THEN ERROR InvalidParameters;    [deviceType: type, deviceOrdinal: ord, diskAddress: diskAddress] ¬       KernelFile.GetBootLocation[file, firstPage];    id ¬ [      [volumeRelative[fileID: file.fileID]], firstPage, diskAddress];    loc ¬ [type, ord, disk[LOOPHOLE[id]]];    bootLocation ¬ [file[LOOPHOLE[loc]]];    END;  GetPVLocation: PUBLIC --TemporaryBooting.-- PROCEDURE [    volume: PhysicalVolume.ID]    RETURNS [bootLocation: physicalVolume TemporaryBooting.BootLocation] =    BEGIN    bootFiles: Boot.PVBootFiles;    type: Device.Type;    ord: CARDINAL;    loc: Boot.Location;    id: Boot.DiskFileID;        bootLocation ¬ [body:physicalVolume[NULL]];    SpecialVolume.GetPhysicalVolumeBootFiles[volume, @bootFiles];    --check if specified volume has boot file installed on it    IF Boot.NullDiskFileID[bootFiles[pilot]] THEN      ERROR InvalidParameters;    id ¬ bootFiles[pilot];    [deviceType: type, deviceOrdinal: ord] ¬ GetDevice[volume];    loc ¬ [type, ord, disk[LOOPHOLE[id]]];    bootLocation ¬ [physicalVolume[LOOPHOLE[loc]]];    END;  GetVolumeLocation: PUBLIC --TemporaryBooting.-- PROCEDURE [volume: Volume.ID]    RETURNS [bootLocation: logicalVolume TemporaryBooting.BootLocation] =    BEGIN    type: Device.Type;    ord: CARDINAL;    loc: Boot.Location;    id: Boot.DiskFileID;    bootFiles: Boot.LVBootFiles;        bootLocation ¬ [body:logicalVolume[NULL]];    SpecialVolume.GetLogicalVolumeBootFiles[volume, @bootFiles];    --check if specified volume has boot file installed on it    IF Boot.NullDiskFileID[bootFiles[pilot]] THEN      ERROR InvalidParameters;    id ¬ bootFiles[pilot];    [deviceType: type, deviceOrdinal: ord] ¬      GetDevice[PhysicalVolume.GetContainingPhysicalVolume[volume]];    loc ¬ [type, ord, disk[LOOPHOLE[id]]];    bootLocation ¬ [logicalVolume[LOOPHOLE[loc]]];    END;     InLoad: PUBLIC --Snapshot.-- PROCEDURE [    pMicrocode, pGerm: LONG POINTER, countGerm: Environment.PageCount,    file: File.File, firstPage: File.PageNumber, switches: System.Switches] =    BEGIN    location: disk Boot.Location;    location.diskFileID ¬      [fID: [volumeRelative[fileID: file.fileID]], firstPage: firstPage, da: NULL];    [deviceType: location.deviceType, deviceOrdinal: location.deviceOrdinal,      diskAddress: location.diskFileID.da] ¬      KernelFile.GetBootLocation[file, firstPage];    InLoadFromBootLocation[pMicrocode, pGerm, countGerm, @location, switches]    -- Can't get here...    END;  InstallPhysicalVolumeBootFile: PUBLIC --TemporaryBooting.-- ENTRY PROCEDURE [    file: File.File, firstPage: File.PageNumber] =    BEGIN    bootFiles: Boot.PVBootFiles;    diskAddress: PilotDiskFace.DiskAddress =      KernelFile.GetBootLocation[file, firstPage].diskAddress;    pvID: PhysicalVolume.ID =      PhysicalVolume.GetContainingPhysicalVolume[file.volumeID];    SpecialVolume.GetPhysicalVolumeBootFiles[pvID, @bootFiles];    bootFiles[pilot] ¬ [      [volumeRelative[fileID: file.fileID]], firstPage, diskAddress];    SpecialVolume.SetPhysicalVolumeBootFiles[pvID, @bootFiles];    END;  InstallVolumeBootFile: PUBLIC --TemporaryBooting.-- ENTRY PROCEDURE [    file: File.File, firstPage: File.PageNumber] =    BEGIN    bootFiles: Boot.LVBootFiles;    diskAddress: PilotDiskFace.DiskAddress =      KernelFile.GetBootLocation[file, firstPage].diskAddress;    SpecialVolume.GetLogicalVolumeBootFiles[file.volumeID, @bootFiles];    bootFiles[pilot] ¬ [      [volumeRelative[fileID: file.fileID]], firstPage, diskAddress];    SpecialVolume.SetLogicalVolumeBootFiles[file.volumeID, @bootFiles];    END;  MakeBootable: PUBLIC --TemporaryBooting.-- PROCEDURE [    file: File.File, firstPage: File.PageNumber] =    BEGIN    -- only pilot boot files are made bootable through this procedure.    count: Environment.PageCount;    wrongVersion: BOOLEAN;    [count, wrongVersion] ¬ GetBootFileSize[@file, firstPage];    [] ¬ KernelFile.MakeBootable[      file: file, firstPage: firstPage, count: count, type: pilot      ! SpecialFile.InvalidParameters => ERROR InvalidParameters];    IF wrongVersion THEN ERROR InvalidParameters;    END;       MakeUnbootable: PUBLIC --TemporaryBooting.-- PROCEDURE [    file: File.File, firstPage: File.PageNumber] =    BEGIN    KernelFile.MakeUnbootable[      file: file, firstPage: File.PageNumber.FIRST,      count: File.GetSize[file]];    END;  OutLoad: PUBLIC --Snapshot.-- PROCEDURE [file: File.File, firstPage: File.PageNumber]    RETURNS [inLoaded: BOOLEAN] =    BEGIN    location: disk Boot.Location;    psb: PSB.PsbHandle;    ptc: CARDINAL;    wdc: CARDINAL;    location.diskFileID ¬ [      fID: [volumeRelative[fileID: file.fileID]], firstPage: firstPage, da:];    [deviceType: location.deviceType, deviceOrdinal: location.deviceOrdinal,      diskAddress: location.diskFileID.da] ¬      KernelFile.GetBootLocation[file, firstPage];    -- Save process state not captured in PDA:    SpecialSpace.MakeProcedureResident[LOOPHOLE[OutLoad] !      SpecialSpace.SpecialError => CONTINUE];    ProcessOperations.DisableInterrupts[];  -- make it hold still first    psb ¬ ProcessOperations.ReadPSB[];    ptc ¬ ProcessOperations.ReadPTC[];    wdc ¬ ProcessOperations.ReadWDC[];    DeviceCleanup.Perform[turnOff];  -- turn all devices off.    -- Save our state on a boot file:  (If the boot file is inloaded    -- later, we will reappear here with inLoaded=TRUE.)    inLoaded ¬ GermOps.OutLoad[@location, restore] ~= continuingAfterOutLoad;    IF inLoaded THEN      BEGIN      -- Restore process state not captured in PDA.      ProcessOperations.WriteWDC[wdc];      ProcessOperations.WritePTC[ptc];      ProcessOperations.WritePSB[psb];      -- The following is necessary for processors without clock chips.      -- We must do it with interrupts off or Communication will be using      -- the Ethernet.      -- if we get an allocation trap, all is lost.      [] ¬ TemporarySetGMT.FixupClock[];      END;    DeviceCleanup.Perform[turnOn];  -- turn devices back on    ProcessorFace.SpecialSetMP[ProcessorFace.mp];  -- announce our return    ProcessOperations.EnableInterrupts[];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[OutLoad] !      SpecialSpace.SpecialError => CONTINUE];    END;  OutLoadInLoad: PUBLIC --TemporaryBooting.-- PROCEDURE [    outloadLocation: file TemporaryBooting.BootLocation,    inloadLocation: TemporaryBooting.BootLocation,    pMicrocode, pGerm: LONG POINTER, countGerm: Environment.PageCount,    switches: System.Switches] =    << NOTE: it would be very nice to share as much code as possible with       PilotNub and the OutLoad PROCEDURE here. PilotNub has the best version       of the code. >>    BEGIN    psb: PSB.PsbHandle;    ptc: CARDINAL;    wdc: CARDINAL;    continuing: BOOLEAN;        SpecialSpace.MakeProcedureResident[      LOOPHOLE[OutLoadInLoad] ! SpecialSpace.SpecialError => CONTINUE];    ProcessOperations.DisableInterrupts[];  -- make it hold still first    psb ¬ ProcessOperations.ReadPSB[];    ptc ¬ ProcessOperations.ReadPTC[];    wdc ¬ ProcessOperations.ReadWDC[];    DeviceCleanup.Perform[turnOff];  -- turn all devices off.    -- Save our state on a boot file:  (If the boot file is inloaded    -- later, we will reappear here with continuing=FALSE.)    continuing ¬      GermOps.OutLoad[        @LOOPHOLE[outloadLocation.fileLocation, disk Boot.Location], restore]      = continuingAfterOutLoad;    IF continuing THEN      BEGIN      -- inload state of specified inloadLocation      WITH  inloadLocation SELECT FROM        bootButton => ProcessorFace.BootButton[];	none => NULL;  -- Don't inload.        physicalVolume,	logicalVolume, file => {	  StoragePrograms.RecoverMStore[];	  InLoadFromBootLoc[	    pMicrocode, pGerm, countGerm,	    @LOOPHOLE[	      LOOPHOLE[	        inloadLocation, file TemporaryBooting.BootLocation].fileLocation,	      disk Boot.Location],	    switches] };        ENDCASE => RuntimeInternal.Bug[BugType[impossibleEndcase]];	-- We should only get here if the inloadLocation was none.      END;    -- newsession or inloadLocation was none    -- Restore process state not captured in PDA.    ProcessOperations.WriteWDC[wdc];    ProcessOperations.WritePTC[ptc];    ProcessOperations.WritePSB[psb];    -- The following is necessary for processors without clock chips.    -- We must do it with interrupts off or Communication will use the Ethernet.    -- if we get an allocation trap, all is lost.    [] ¬ TemporarySetGMT.FixupClock[];    DeviceCleanup.Perform[turnOn];  -- turn devices back on    ProcessorFace.SpecialSetMP[ProcessorFace.mp];  -- announce our return    ProcessOperations.EnableInterrupts[];    SpecialSpace.MakeProcedureSwappable[      LOOPHOLE[OutLoadInLoad] ! SpecialSpace.SpecialError => CONTINUE];    END;               --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Utility Routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     GetBootFileSize: PRIVATE ENTRY PROCEDURE [    pFile: POINTER TO File.File, firstPage: File.PageNumber]    RETURNS [count: Environment.PageCount, wrongVersion: BOOLEAN] =    BEGIN    wrongVersion ¬ FALSE;    count ¬ File.GetSize[pFile­] - firstPage;    END;  GetDevice: PROCEDURE [pvID: PhysicalVolume.ID]    RETURNS [deviceType: Device.Type, deviceOrdinal: CARDINAL] =    BEGIN OPEN PhysicalVolume;    [type: deviceType, index: deviceOrdinal] ¬ InterpretHandle[      GetAttributes[pvID].instance];    END;  InLoadFromBootLoc: PROCEDURE [    pMicrocode, pGerm: LONG POINTER, countGerm: Environment.PageCount,    location: POINTER TO Boot.Location, switches: System.Switches];  -- an indirect control link to the PORT is set in InitializeInLoadFromBootLoc.    InLoadFromBootLocation: PROCEDURE [    pMicrocode, pGerm: LONG POINTER, countGerm: Environment.PageCount,    location: POINTER TO Boot.Location, switches: System.Switches] =    BEGIN    -- Prevent other processes from running:    ProcessOperations.DisableInterrupts[];    -- Ensure all (PrincOps) real memory is mapped somewhere    -- in virtual address space:    StoragePrograms.RecoverMStore[];    InLoadFromBootLoc[pMicrocode, pGerm, countGerm, location, switches];    -- ..which never returns.  (It may "return" by inloading    -- from another snapshot boot file.)    END;          InitializeInLoadFromBootLoc: PROCEDURE RETURNS[ --must match PORT args-- ] =    -- If the local frame of this procedure were built out of    -- funny memory, the call below to Perform[disconnect] might    -- unmap our local frame.  Therefore, this procedure runs in a    -- fixed frame to ensure that its local frame is built from    -- PrincOps real memory (not "funny memory").  It is initialized    -- early in the world, before funny memory becomes available to Pilot.    -- THE CODE BELOW having to do with DeviceCleanup and GermOps is REPLICATED    -- in PilotNub.mesa.  If you make a change here, make it there too.    BEGIN        AwaitInLoadFromBootLocRequest: --RESPONDING-- PORT      -- args/results must match InLoadFromBootLoc (but swapped) --      RETURNS [        pMicrocode, pGerm: LONG POINTER, countGerm: Environment.PageCount,        location: POINTER TO Boot.Location, switches: System.Switches];	    pMicrocode, pGerm: LONG POINTER;    countGerm: Environment.PageCount;    nGerm: Environment.PageCount;    location: POINTER TO Boot.Location;    switches: System.Switches;    InLoadFromBootLoc ¬ LOOPHOLE[LONG[@AwaitInLoadFromBootLocRequest]];    -- set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitInLoadFromBootLocRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    [pMicrocode, pGerm, countGerm, location, switches] ¬      AwaitInLoadFromBootLocRequest[];    DeviceCleanup.Perform[turnOff];  -- turn all devices off    -- Disconnect all devices (e.g. release funny memory):    DeviceCleanup.Perform[disconnect];    -- The next line should be in GermOps.InLoad but blows up the compiler    IF pMicrocode ~= NIL THEN DeviceCleanup.Perform[kill];    -- Copy switches to communication area (in germ's SD):    -- (must do in GermOps.InLoad if pGerm~=NIL)    nGerm ¬ countGerm*Environment.wordsPerPage;    IF Inline.HighHalf[nGerm] ~= 0 THEN Bug[germTooLarge];    GermOps.InLoad[      pMicrocode, pGerm, Inline.LowHalf[nGerm], location, @switches]    -- ..which never returns.  (It may "return" by inloading    --   from another snapshot boot file.)    END;  END.LOG  (For earlier log entries, see Mesa 10.0 archive version.)10-Nov-81 14:10:18   JXP     GetBootFileSize now returns a boolean indicating wrong version number. If  version is wrong, count is set to length of whole file. MakeBootable now  makes the file bootable then raises an error if the version number was invalid.19-Nov-81 15:48:38   JXP     Added PUBLIC InvalidVersion ERROR to satisfy export. Not currently used.10-Dec-81 16:58:11   WDK       Get DisableInterrupts from ProcessOperations.11-Jan-82 16:35:46   WDK       Improved documentation.Feb 16, 82 1:27 PM   KAM        TemporarySetGMT.SetGMT=>TemporarySetGMT.FixupClock.22-Nov-82 14:43:36   EKN     Added Public procedures: GetFileLocation, GetVolumeLocation, GetPVLocation,  OutLoadInLoad.  Added types: PVLocation, VolumeLocation, FileLocation. Changed  Outload procedure to call SpecialSetMP instead of SetMP.29-Nov-82 17:47:20   AWL         Converted to Klamath.22-Dec-82 15:13:44   AWL         Twiddles for new SpecialFile.11-Apr-83 11:45:09   WDK        MakeUnbootable the whole file. Twiddles for new KernelFile.   BootingExtras  and TemporarySetGMTExtra are gone. alphabetize procs.21-Apr-83 11:47:14   JXP      GetBootFileSize should only map the first page of the bootfile, not all of it.18-Jul-83 10:04:59   JXP      Fix up the port stuff.25-Jul-83 10:56:10   JXP      Add SpecialBooting BootFromEthernet(One) stuff.13-Sep-83 10:54:20   JXP      Fix bug in GetPVLocation.11-Dec-84 12:43:53   ERN      InLoadFromBootLocation declared private14-Jul-86 17:30:43   ET	      Moved PORTs from global frames to local frames.15-Jan-87  0:55:16   ET       Added edits of: 9-Jul-86  9:29:58   RSV   Added type parameter to KernelFile.MakeBootable call.20-Feb-87  7:36:17   CAJ      MakeBootable no longer gets the size of the file to be made bootable from the bootfile header because we no longer have the assurance that nonzero content is a header.27-Sep-87 21:43:33   KEK   Added bootfromfloppy
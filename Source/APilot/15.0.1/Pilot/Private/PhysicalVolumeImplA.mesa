-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- FileMgr>PhysicalVolumeImplA.mesa     1-Dec-88 12:19:28 by RSV    -- NOTES:-- * This module is MONITORed to protect the relationship between drives and--   physical volumes. Each drive has its own monitor so that operations may--   may proceed in parallel on separate disks (e.g., scavenge one physical--   volume while onlining another).-- * Currently, a buffer is allocated for the root page (really the descriptor)--   of each Drive. If at some point this becomes a problem, one might consider--   replacing them with a buffer pool. In this case the pool would have to be--   protected by some sort of Monitor. One could extend the module's Object--   Monitor, or hand code a Monitor.-- * Each of the ENTRY procedures has an CATCH phrase at the outer most level--   which catches stray ERRORS and converts them into calls on bug. Note that--   ERRORS raised within the ENTRY procedures will not be caught by these CATCH--   phrases since they are raised by RETURNing WITH ERROR.-- * Major sections of the module are separated by two rows of tildas. To find--   the divisions quickly, select the following tildas, and use Find. v~~~~~~~vDIRECTORY  Boot USING [DiskFileID, Location, PVBootFiles],  DataTransfer USING [DiskStatusToDataStatus, ReadPVData],  Device USING [nullType, PilotDisk, Type],  DiskBackingStore USING [ChannelHandle, RegisterChannel, ReleaseHandle],  DiskChannel USING [    AwaitStateChange, Create, Drive, DriveState, GetDrive, GetDriveAttributes,    GetNextDrive, GetPageNumber, goodCompletion, Handle, InspectDiskShape,    IOStatus, IsReady, nullDrive, SetDriveState, SetDriveTag],  Environment USING [Base, PageCount, PageNumber, wordsPerPage],  File USING [PageCount],  FMPrograms USING [    FindDebugger, FindSystemLV, InitFile, InitVolume],  Inline USING [HighHalf, LowHalf],  KernelPhysicalVolume USING [PVHandle, ScavengeWithLock],  KernelSpaceUsage USING [pvRootPage],  KernelVolume USING [AllRightToTakePVAway, NewPVOnline],  LogicalVolumeFormat USING [nullVolumePage, rootPageNumber],  PhysicalVolume USING [    ErrorType, ID, Layout, noProblems, nullBadPage, nullDeviceIndex, nullID,    PageCount, PageNumber, RepairType, ScavengerStatus, VolumeType],  PhysicalVolumeExtras,  PhysicalVolumeFormat USING [    DuplicateHandle, duplicateRootPageSize, Handle, IDCheckSum, MarkerID,    maxNumberDataLostPages, maxSubVols, nullBadPage, nullDataLostPage,    PageCount, PageNumber, physicalVolumeLabelLength, rootPageNumber,    rootPageSize, SubVolumeDesc],  PhysicalVolumeInternal USING [    CompareDuplicateAndMainPVRootPages, DriveData, DriveDataHandle,    DriveFromIndex, DuplicatePVHandle, ErrorType, GetDriveData,    PhysicalRootPageCheck, PVHandle, PVIDFromDrive, ValidateDrive,    WriteDuplicatePVRootPage, WritePVRootPage],  PilotMP USING [    cDeleteTemps,  cDriveNotReady, cLVNeedsRiskyRepair, cPVNeedsScavenging],  PilotDiskFace USING [DeviceHandle, GetDriveInfo],  Process USING [InitializeMonitor],  ProcessorFace USING [mp, SetMP],  ResidentHeap USING [first64K, MakeNode],  Runtime USING [CallDebugger],  RuntimeInternal USING [Bug],  Space USING [Allocate, Deallocate, PageFromLongPointer],  SpecialVolume USING [nullSubVolume, SubVolume],  StoragePrograms USING [],  System USING [    GetLocalTimeParameters, GetUniversalID, isUtilityPilot, LocalTimeParameters,    LocalTimeParametersUnknown, nullID],  VM USING [ForceOut, Map, PageCount, ScratchMap, Unmap],  VolTable USING [    FindSV, GetBSChannel, GetDrive, GetNextPV, GetNextSV, MapDuplicatePVRootPage,    MapPVRootPage, nullSVDesc, PVAccess, PVAccessProc, PVEntryState,    RegisterPVMarkerID, SetPVOffline, SetSVOffline, SetPVOnline, SetSVOnline,     SVAccess, SVAccessProc, SVDesc, TableAccess, TableAccessProc,    UnmapDuplicatePVRootPage, UnmapPVRootPage],  Volume USING [    ID, NeedsScavenging, nullID, Open, PageCount, systemID, Unknown],  Zone USING [Status];PhysicalVolumeImplA: MONITOR LOCKS data   USING data: PhysicalVolumeInternal.DriveDataHandle  IMPORTS    DataTransfer, DiskBackingStore, DiskChannel, FMPrograms,    Inline, KernelPhysicalVolume, KernelVolume, PhysicalVolumeFormat,    PhysicalVolumeInternal, PilotDiskFace, Process, ProcessorFace,     ResidentHeap, Runtime, RuntimeInternal, Space, System, VM, VolTable,    Volume  EXPORTS    KernelPhysicalVolume, PhysicalVolume, PhysicalVolumeExtras,    PhysicalVolumeInternal, SpecialVolume, StoragePrograms  SHARES Device, File, PhysicalVolume =  BEGIN  OPEN PVF: PhysicalVolumeFormat;  -- Types  Handle: PUBLIC TYPE = KernelPhysicalVolume.PVHandle;  PVHandle: TYPE = PhysicalVolumeInternal.PVHandle;  DuplicatePVHandle: TYPE = PhysicalVolumeInternal.DuplicatePVHandle;  -- Constants  wordsPerPage: CARDINAL = Environment.wordsPerPage;  nullPVID: PhysicalVolume.ID = PhysicalVolume.nullID;  rootPage: PVF.PageNumber = PVF.rootPageNumber;  rootPageSize: File.PageCount = LOOPHOLE[PVF.rootPageSize];  duplicateRootPageSize: File.PageCount = LOOPHOLE[    PVF.duplicateRootPageSize];  nullDrive: DiskChannel.Drive = DiskChannel.nullDrive;  nullSVDesc: PVF.SubVolumeDesc = [    lvID: Volume.nullID, lvSize: 0, lvPage: LogicalVolumeFormat.nullVolumePage,    pvPage: 0, nPages: 0];  -- VARIABLES  numberOfDrives: PUBLIC --PhysicalVolumeInternal-- CARDINAL;  dataTable: PUBLIC --PhysicalVolumeInternal-- LONG POINTER TO ARRAY [0..0) OF    PhysicalVolumeInternal.DriveData;  maxSubvolumesOnPhysicalVolume: PUBLIC CARDINAL ¬ PVF.maxSubVols;  -- ERRORs and Bugs  NeedsScavenging: PUBLIC --PhysicalVolume-- ERROR = CODE;  Error: PUBLIC --PhysicalVolume.-- ERROR [error: PhysicalVolume.ErrorType] =    CODE;  ErrorExtras: PUBLIC --PhysicalVolumeExtras-- ERROR [    error: PhysicalVolumeExtras.ErrorType] = CODE;  ErrorInternal: PUBLIC --PhysicalVolumeInternal-- ERROR [    error: PhysicalVolumeInternal.ErrorType] = CODE;  BugType: TYPE = {    allocationError, bootFileDeviceNotAPilotDisk, cantWriteDuplicateRootPage,    cantWriteRootPage, cleanupNotImplemented, dupAndMainRootPagesDontMatch,    dupRootPageNumberUnknown, funnyErrorFromOpen, funnyErrorFromScavenge,    impossibleDriveStateChangeFailure, impossibleOffLineFailure,    impossibleEndcase, impossibleState, invalidSubVolumeNumber,    dataNotFound, noSubVolumes, pvWentAway, physicalVolumeNotFound,    tooManyBadPages, tooManyDataLostPages, troubleScavengingSysVol,    unexpectedError};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --  File Manager Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeFileMgr: PUBLIC --StoragePrograms.-- PROCEDURE [    bootFile: LONG POINTER TO Boot.Location,    pDebuggerResult: POINTER TO Boot.DiskFileID,    pDebuggeeResult: POINTER TO Boot.DiskFileID]    RETURNS [debuggerDeviceType: Device.Type, debuggerDeviceOrdinal: CARDINAL] =    BEGIN    status: Zone.Status;    systemPV: PhysicalVolume.ID;    drive: DiskChannel.Drive;    dataTableRel: Environment.Base RELATIVE POINTER;    deviceHandle: PilotDiskFace.DeviceHandle;    -- The first thing to do is start the rest of the FileMgr.    FMPrograms.InitFile[];    FMPrograms.InitVolume[];    debuggerDeviceType ¬ Device.nullType;    -- Inspect and allocate table entry for each drive:    numberOfDrives ¬ 0;    FOR drive ¬ DiskChannel.GetNextDrive[nullDrive], DiskChannel.GetNextDrive[      drive] UNTIL drive = nullDrive DO      [] ¬ DiskChannel.InspectDiskShape[drive, quickReadOnly];      numberOfDrives ¬ SUCC[numberOfDrives];      ENDLOOP;    [dataTableRel, status] ¬ ResidentHeap.MakeNode[      numberOfDrives * SIZE[PhysicalVolumeInternal.DriveData]];    IF status ~= okay THEN Bug[allocationError];    dataTable ¬ @ResidentHeap.first64K[dataTableRel];    FOR i: CARDINAL IN [0..numberOfDrives) DO      dataTable[i].drive ¬        IF i = 0 THEN DiskChannel.GetNextDrive[nullDrive]        ELSE DiskChannel.GetNextDrive[dataTable[i - 1].drive];      dataTable[i].pv ¬ Space.Allocate[count: rootPageSize].pointer;      dataTable[i].dupPV ¬ Space.Allocate[count: duplicateRootPageSize].pointer;      deviceHandle ¬        DiskChannel.GetDriveAttributes[dataTable[i].drive].deviceHandle;      IF ~DiskChannel.InspectDiskShape[        dataTable[i].drive, quickReadOnly].knownType THEN        dataTable[i].dupRootPageNumValid ¬ FALSE      ELSE        BEGIN	dataTable[i].dupRootPageNumValid ¬ TRUE;	dataTable[i].duplicateRootPageNumber ¬ DiskChannel.GetPageNumber[	  dataTable[i].drive, PilotDiskFace.GetDriveInfo[	  deviceHandle].lastPageOfInitialMicrocode] + 1;	END;      Process.InitializeMonitor[@dataTable[i].LOCK];      ENDLOOP;    -- Handle system physical and logical volumes (if any):    IF bootFile.deviceType NOT IN Device.PilotDisk OR System.isUtilityPilot THEN      NULL  -- No system volume    ELSE      BEGIN  --regular Pilot and booted from disk--      sysDrive: DiskChannel.Drive;      diskBootFile: LONG POINTER TO disk Boot.Location =  --        -- must be a disk Location since booted from disk.        -- (Loophole unavoidable since Location is overlaid variant record.)        @LOOPHOLE[bootFile­, disk Boot.Location];      -- Find the System physical volume:      -- (Assumes that a disk whose type could not be readily      --  determined in the loop above is not the system boot drive.)      FOR sysDrive ¬ DiskChannel.GetNextDrive[nullDrive],        DiskChannel.GetNextDrive[sysDrive] UNTIL sysDrive = nullDrive DO        IF DiskChannel.GetDriveAttributes[sysDrive].deviceOrdinal =          bootFile.deviceOrdinal THEN EXIT;        REPEAT FINISHED => Bug[bootFileDeviceNotAPilotDisk];        ENDLOOP;      systemPV ¬ InitialOnline[sysDrive];  -- online the System PV      -- NOTE: If the system LV spans PV's then this whole thing doesn't      -- work!! We assume that there is only one system PV.      FMPrograms.FindSystemLV[systemPV, diskBootFile];      IF Volume.systemID # Volume.nullID THEN        BEGIN  --open the system volume--        ProcessorFace.SetMP[PilotMP.cDeleteTemps];        Volume.Open[  -- also learns sys vol type.          Volume.systemID !          Volume.NeedsScavenging =>            BEGIN  --NeedsScavenging--	    DO ProcessorFace.SetMP[PilotMP.cLVNeedsRiskyRepair] ENDLOOP;            END;  --NeedsScavenging--          ANY => Bug[funnyErrorFromOpen]];  --Volume.Open        -- Now that system volume type is known, find the debugger:        [debuggerDeviceType, debuggerDeviceOrdinal] ¬ FMPrograms.FindDebugger[          pvID: systemPV, pDebuggerResult: pDebuggerResult,          pDebuggeeResult: pDebuggeeResult];        END;  --open the system volume--      END;  --regular Pilot and booted from disk--    END;  --InitializeFileMgr--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The PhysicalVolume Implementation:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AssertNotAPilotVolume: PUBLIC PROCEDURE [instance: Handle] =    -- Assert that the drive instance is not a Pilot Volume.    BEGIN    AssertNotAPilotVolumeEntry: ENTRY PROCEDURE       [data: PhysicalVolumeInternal.DriveDataHandle] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN        RETURN WITH ERROR Error[invalidHandle];      SELECT DiskChannel.SetDriveState[      instance.drive, instance.changeCount, direct] FROM        ok => NULL;        wrongChangeCount => RETURN WITH ERROR Error[invalidHandle];        illegalState => RETURN WITH ERROR Error[alreadyAsserted];        ENDCASE => Bug[impossibleEndcase];      END;    AssertNotAPilotVolumeEntry[      PhysicalVolumeInternal.GetDriveData[instance.drive]];    END;  AssertPilotVolume: PUBLIC PROCEDURE [instance: Handle]    RETURNS [pvID: PhysicalVolume.ID] =    -- Assert that this drive instance is a Pilot Volume.    BEGIN    AssertPilotVolumeEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle]      RETURNS [pvID: PhysicalVolume.ID] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      alreadyOnline: BOOLEAN;      localError: PhysicalVolume.ErrorType;      IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN        RETURN WITH ERROR Error[invalidHandle];      IF ~DiskChannel.IsReady[instance.drive] THEN        RETURN WITH ERROR Error[notReady];      BEGIN  -- Provide Scope for EXITS      SELECT DiskChannel.SetDriveState[      instance.drive, instance.changeCount, channel] FROM        wrongChangeCount => RETURN WITH ERROR Error[invalidHandle];        illegalState => RETURN WITH ERROR Error[alreadyAsserted];        ok =>          BEGIN	  IF ~data.dupRootPageNumValid THEN 	    BEGIN	    IF ~DiskChannel.InspectDiskShape[data.drive, quickReadOnly].knownType	      THEN RETURN WITH ERROR Error[badDisk]	    ELSE	      BEGIN	      data.dupRootPageNumValid ¬ TRUE;	      data.duplicateRootPageNumber ¬ DiskChannel.GetPageNumber[		data.drive, PilotDiskFace.GetDriveInfo[		DiskChannel.GetDriveAttributes[		data.drive].deviceHandle].lastPageOfInitialMicrocode] + 1;	      END;	    END;          [pvID, alreadyOnline] ¬ PhysicalVolumeOnLineInternal[            instance.drive, data.pv, data.dupPV, instance.changeCount,	    data.duplicateRootPageNumber !            Error => {localError ¬ error; GO TO PVError};            NeedsScavenging => GO TO NeedsScavenging];          IF alreadyOnline THEN RETURN WITH ERROR Error[alreadyAsserted];          END;        ENDCASE => Bug[impossibleEndcase];      EXITS        PVError =>          BEGIN          [] ¬ DiskChannel.SetDriveState[instance.drive, 0, inactive];          RETURN WITH ERROR Error[localError];          END;        NeedsScavenging =>          BEGIN          [] ¬ DiskChannel.SetDriveState[instance.drive, 0, inactive];          RETURN WITH ERROR NeedsScavenging;          END;      END;  -- End Scope for EXITS      END;    RETURN AssertPilotVolumeEntry[      PhysicalVolumeInternal.GetDriveData[instance.drive]];    END;  AwaitStateChange: PUBLIC PROCEDURE [changeCount: CARDINAL, index: CARDINAL]    RETURNS [currentChangeCount: CARDINAL] = {    RETURN[DiskChannel.AwaitStateChange[changeCount, GetHandle[index].drive]]};      ChangeName: PUBLIC PROCEDURE [pvID: PhysicalVolume.ID, newName: LONG STRING] =    BEGIN        ChangeNameInternal: VolTable.PVAccessProc --[tok, rootPageLoc]-- =      BEGIN            ChangeNameEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN	VolTable.MapPVRootPage[tok, data.pv];	VolTable.MapDuplicatePVRootPage[tok, data.dupPV];	data.pv.labelLength ¬ data.dupPV.labelLength ¬ MIN[          newName.length, PVF.physicalVolumeLabelLength];        FOR i: CARDINAL IN [0..data.pv.labelLength) DO 	  data.pv.label[i] ¬ data.dupPV.label[i] ¬ newName[i];	  ENDLOOP;	VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];        VolTable.UnmapPVRootPage[tok, data.pv];	END;	      ChangeNameEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;        IF newName = NIL OR newName.length = 0 THEN ERROR Error[nameRequired];    VolTable.PVAccess[pvID: pvID, proc: ChangeNameInternal, lock: write];    END;      ClearDataLostPage: PUBLIC --PhysicalVolumeInternal--PROCEDURE [    pvID: PhysicalVolume.ID, dataLostPage: PhysicalVolume.PageNumber] =    BEGIN    ClearDataLostPageInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      ClearDataLostPageEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        shortDataLostPageCount: CARDINAL;        VolTable.MapPVRootPage[tok, data.pv];	VolTable.MapDuplicatePVRootPage[tok, data.dupPV];        IF Inline.HighHalf[data.dupPV.dataLostPageList.header.countPages] ~= 0 THEN 	  Bug[tooManyDataLostPages];        shortDataLostPageCount ¬	  Inline.LowHalf[data.dupPV.dataLostPageList.header.countPages];        FOR i: CARDINAL IN [0..shortDataLostPageCount) DO          SELECT data.dupPV.dataLostPageList.pages[i] FROM            > dataLostPage =>              BEGIN	      VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];	      VolTable.UnmapPVRootPage[tok, data.pv];	      RETURN;              END;            < dataLostPage => LOOP;            = dataLostPage => 	      BEGIN	      FOR j: CARDINAL IN [i..shortDataLostPageCount - 1) DO	        data.dupPV.dataLostPageList.pages[i] ¬		  data.dupPV.dataLostPageList.pages[i + 1];	      ENDLOOP;	      data.dupPV.dataLostPageList.pages[shortDataLostPageCount - 1] ¬	        PVF.nullDataLostPage;	      data.dupPV.dataLostPageList.header.countPages ¬	        data.pv.dataLostPageCount ¬ data.dupPV.dataLostPageCount ¬		data.dupPV.dataLostPageList.header.countPages - 1;	      VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];	      VolTable.UnmapPVRootPage[tok, data.pv];	      RETURN;	      END;            ENDCASE => Bug[impossibleEndcase];          ENDLOOP;	RETURN WITH ERROR ErrorInternal[notInTable];        END;  -- ClearDataLostPageEntry--      ClearDataLostPageEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  --ClearDataLostPageInternal--    VolTable.PVAccess[pvID, ClearDataLostPageInternal, write];    END; --ClearDataL        CreatePhysicalVolume: PUBLIC PROCEDURE [instance: Handle, name: LONG STRING]    RETURNS [PhysicalVolume.ID] =    -- Create a physical volume on this drive instance.    BEGIN    CreatePhysicalVolumeEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle]      RETURNS [pvID: PhysicalVolume.ID] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      timeParamsValid: BOOLEAN;      timeParams: System.LocalTimeParameters;      pv: PVHandle = data.pv;      dupPV: DuplicatePVHandle = data.dupPV;      labelLength: CARDINAL;      changeCount: CARDINAL;      status: DiskChannel.IOStatus;      state: DiskChannel.DriveState;      diskChannel: DiskChannel.Handle;      markerID: PVF.MarkerID;      bsChannel: DiskBackingStore.ChannelHandle;      deviceHandle: PilotDiskFace.DeviceHandle;      IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN        RETURN WITH ERROR Error[invalidHandle];      -- See if the drive passed in is already out of date.      [changeCount: changeCount, state: state, deviceHandle: deviceHandle] ¬        DiskChannel.GetDriveAttributes[instance.drive];      IF changeCount ~= instance.changeCount THEN        RETURN WITH ERROR Error[invalidHandle];      IF ~DiskChannel.IsReady[instance.drive] THEN        RETURN WITH ERROR Error[notReady];      SELECT state FROM        inactive => NULL;  -- That's just the way we want it.        direct, channel => RETURN WITH ERROR Error[alreadyAsserted];        ENDCASE => Bug[impossibleEndcase];      IF DiskChannel.SetDriveState[instance.drive, instance.changeCount, channel]        ~= ok THEN Bug[impossibleDriveStateChangeFailure];      -- Create all of the necessary objects, like pv ID's marker ID's,      -- disk channel's, etc..      pvID ¬ [System.GetUniversalID[]];      markerID ¬ [System.GetUniversalID[]];      diskChannel ¬ DiskChannel.Create[instance.drive];      -- Now make sure we got a diskChannel on the same drive we entered with.      changeCount ¬ DiskChannel.GetDriveAttributes[        DiskChannel.GetDrive[diskChannel]].changeCount;      IF changeCount ~= instance.changeCount THEN        RETURN WITH ERROR Error[invalidHandle];      bsChannel ¬ DiskBackingStore.RegisterChannel[diskChannel];      DiskChannel.SetDriveTag[        instance.drive, PVF.IDCheckSum[pvID]];      -- OK, now we're in a position to fill in the root page.      VM.Map[        interval: [page: Space.PageFromLongPointer[pv], count: rootPageSize],        transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],        life: dead, swappability: resident, usage: KernelSpaceUsage.pvRootPage];      VM.Map[        interval: [page: Space.PageFromLongPointer[dupPV],        count: duplicateRootPageSize],        transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],        life: dead, swappability: resident, usage: KernelSpaceUsage.pvRootPage];      labelLength ¬ MIN[        name.length, PVF.physicalVolumeLabelLength];      -- When the bad page list has a device dependent length, be sure to assign      -- to maxBadPages in the following constructor.      pv­ ¬ [        labelLength: labelLength, pvID: pvID, label: NULL, subVolumeCount: 0,        subVolumeMarkerID: markerID, subVolumes: ALL[nullSVDesc],        badPageList: ALL[PVF.nullBadPage]];      dupPV­ ¬ [        labelLength: labelLength, pvID: pvID, label: NULL, subVolumeCount: 0,        subVolumeMarkerID: markerID, subVolumes: ALL[nullSVDesc],	dataLostPageList: [[0, PVF.maxNumberDataLostPages],	  ALL[PVF.nullDataLostPage]]];      FOR i: CARDINAL IN [0..labelLength) DO        pv.label[i] ¬ dupPV.label[i] ¬ name[i];        ENDLOOP;      timeParamsValid ¬ TRUE;      timeParams ¬ System.GetLocalTimeParameters[        !        System.LocalTimeParametersUnknown => {timeParamsValid ¬ FALSE; CONTINUE}];      IF timeParamsValid THEN        BEGIN        pv.localTimeParametersValid ¬ dupPV.localTimeParametersValid ¬ TRUE;        pv.localTimeParameters ¬ dupPV.localTimeParameters ¬ timeParams;        END;      -- Always find out the duplicate root page location (in case the disk      -- type is changed).  This is needed for EIDisk and SDD page type stuff.      IF ~DiskChannel.InspectDiskShape[data.drive, quickReadOnly].knownType THEN	Bug[dupRootPageNumberUnknown]      ELSE	BEGIN	data.dupRootPageNumValid ¬ TRUE;	data.duplicateRootPageNumber ¬ DiskChannel.GetPageNumber[	  data.drive, PilotDiskFace.GetDriveInfo[	  deviceHandle].lastPageOfInitialMicrocode] + 1;	END;      -- Write the data out to the disk by writing duplicate out first.      status ¬ PhysicalVolumeInternal.WriteDuplicatePVRootPage[	page: Space.PageFromLongPointer[dupPV], channel: diskChannel,	duplicateRootPage: data.duplicateRootPageNumber].status;      VM.Unmap[Space.PageFromLongPointer[dupPV]];      IF status ~= DiskChannel.goodCompletion THEN {        VM.Unmap[Space.PageFromLongPointer[pv]];        DiskBackingStore.ReleaseHandle[bsChannel];        RETURN WITH ERROR Error[badDisk]};      status ¬ PhysicalVolumeInternal.WritePVRootPage[	page: Space.PageFromLongPointer[pv], channel: diskChannel].status;      VM.Unmap[Space.PageFromLongPointer[pv]];      IF status ~= DiskChannel.goodCompletion THEN {        DiskBackingStore.ReleaseHandle[bsChannel];        RETURN WITH ERROR Error[badDisk]};      -- Finally, assert the PV.      [] ¬ PhysicalVolumeOnLineInternal[        instance.drive, pv, dupPV, changeCount, data.duplicateRootPageNumber];      END;  -- CreatePhysicalVolumeEntry    -- Begin main text of CreatePhysicalVolume:    IF name = NIL OR name.length = 0 THEN ERROR Error[nameRequired];    RETURN CreatePhysicalVolumeEntry[      PhysicalVolumeInternal.GetDriveData[instance.drive]];    END;  --CreatePhysicalVolume--  FinishWithNonPilotVolume: PUBLIC PROCEDURE [instance: Handle] =    BEGIN    FinishWithNonPilotVolumeEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN        RETURN WITH ERROR Error[invalidHandle];      IF DiskChannel.GetDriveAttributes[instance.drive].state = channel THEN        RETURN WITH ERROR Error[hasPilotVolume];      SELECT DiskChannel.SetDriveState[      instance.drive, instance.changeCount, inactive] FROM        ok => NULL;  --- Thats what we want...        illegalState => Bug[impossibleDriveStateChangeFailure];        wrongChangeCount => RETURN WITH ERROR Error[invalidHandle];        ENDCASE => Bug[impossibleEndcase];      END;    FinishWithNonPilotVolumeEntry[      PhysicalVolumeInternal.GetDriveData[instance.drive]];    END;  GetAttributes: PUBLIC PROCEDURE [pvID: PhysicalVolume.ID, label: LONG STRING]    RETURNS [instance: Handle, layout: PhysicalVolume.Layout] =    BEGIN    GetAttributesInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      -- PROCEDURE [tok: PVToken, rootPageLoc: PhysicalVolume.PageNumber]      BEGIN      GetAttributesEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        drive: DiskChannel.Drive ¬ VolTable.GetDrive[tok];        count: Volume.PageCount;        instance ¬ [drive, DiskChannel.GetDriveAttributes[drive].changeCount];        VolTable.MapPVRootPage[tok, data.pv];        IF label ~= NIL THEN  -- Copy the label string.          BEGIN          label.length ¬ MIN[label.maxlength, data.pv.labelLength];          FOR i: CARDINAL IN [0..label.length) DO            label[i] ¬ data.pv.label[i]; ENDLOOP;          END;        layout ¬ empty;  -- No Subvolumes.        IF data.pv.subVolumeCount ~= 0 THEN          BEGIN          count ¬ 0;          FOR i: CARDINAL IN [0..data.pv.subVolumeCount) DO            IF data.pv.subVolumes[i].lvID ~= data.pv.subVolumes[0].lvID THEN {              layout ¬ multipleLogicalVolumes; EXIT};            count ¬ count + data.pv.subVolumes[i].nPages;            REPEAT              FINISHED =>                layout ¬                  IF count = data.pv.subVolumes[0].lvSize THEN singleLogicalVolume                  ELSE partialLogicalVolume;            ENDLOOP;          END;        VolTable.UnmapPVRootPage[tok, data.pv];        END;  -- GetAttributesEntry      GetAttributesEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  --GetAttributesInternal    VolTable.PVAccess[pvID, GetAttributesInternal, read];    END;  GetContainingPhysicalVolume: PUBLIC PROCEDURE [lvID: Volume.ID]    RETURNS [pvID: PhysicalVolume.ID] =    BEGIN    found: BOOLEAN;    svDesc: VolTable.SVDesc;    [found: found] ¬ VolTable.FindSV[      lvID, LogicalVolumeFormat.rootPageNumber, @svDesc];    IF ~found THEN ERROR Volume.Unknown[lvID];    RETURN[svDesc.pvID];    END;      GetDuplicatePVRootLocation: PUBLIC --PhysicalVolumeExtras-- PROCEDURE [    index: CARDINAL] RETURNS [startPage: PhysicalVolume.PageNumber,    count: PhysicalVolume.PageCount] =    BEGIN    drive: DiskChannel.Drive =      PhysicalVolumeInternal.DriveFromIndex[index].drive;          GetDuplicatePVRootLocationEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle]       RETURNS [PhysicalVolume.PageNumber] =      BEGIN ENABLE UNWIND => NULL;      IF ~data.dupRootPageNumValid THEN        BEGIN        IF ~DiskChannel.InspectDiskShape[drive, quickReadOnly].knownType THEN	  RETURN WITH ERROR Error[badDisk]        ELSE          BEGIN	  data.dupRootPageNumValid ¬ TRUE;	  data.duplicateRootPageNumber ¬ DiskChannel.GetPageNumber[            drive, PilotDiskFace.GetDriveInfo[DiskChannel.GetDriveAttributes[	    drive].deviceHandle].lastPageOfInitialMicrocode] + 1;	  END;        END;      RETURN[data.duplicateRootPageNumber];      END;    IF drive = nullDrive THEN ERROR Error[noSuchDrive];    RETURN[GetDuplicatePVRootLocationEntry[      PhysicalVolumeInternal.GetDriveData[drive]], PVF.duplicateRootPageSize];    END;  --GetDuplicatePVRootLocation--      GetHandle: PUBLIC PROCEDURE [index: CARDINAL] RETURNS [Handle] =    BEGIN    drive: DiskChannel.Drive = PhysicalVolumeInternal.DriveFromIndex[index];    -- index = null => drive = null    IF drive = nullDrive THEN ERROR Error[noSuchDrive];    RETURN[[drive, DiskChannel.GetDriveAttributes[drive].changeCount]]    END;  GetHints: PUBLIC PROCEDURE [instance: Handle, label: LONG STRING]    RETURNS [pvID: PhysicalVolume.ID, volumeType: PhysicalVolume.VolumeType] =    -- This should get smarter about returning information when the volume is     -- partially trashed.  Also, it should not work by onlining/offlining the     -- volume as this has side effects (in principle) which this operation    -- should not produce. That is, it opens a window in which a client can    -- transiently see the PV and contained LV's.    BEGIN    GetHintsEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle]      RETURNS [pvID: PhysicalVolume.ID, volumeType: PhysicalVolume.VolumeType] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      changeCount: CARDINAL;      found, success: BOOLEAN;      driveState: DiskChannel.DriveState;      localError: PhysicalVolume.ErrorType;      CopyLabel: VolTable.PVAccessProc --[tok, rootPageLoc]--  =        -- [tok: PVToken, rootPageLoc: PhysicalVolume.PageNumber];        BEGIN        VolTable.MapPVRootPage[tok, data.pv];        IF label # NIL THEN          BEGIN          label.length ¬ MIN[label.maxlength, data.pv.labelLength];          FOR i: CARDINAL IN [0..label.length) DO            label[i] ¬ data.pv.label[i]; ENDLOOP;          END;        VolTable.UnmapPVRootPage[tok, data.pv];        END;      BEGIN      --~~~~~~~~ BEGIN Validity Checks      IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN        RETURN WITH ERROR Error[invalidHandle];      [changeCount: changeCount, state: driveState] ¬        DiskChannel.GetDriveAttributes[instance.drive];      IF ~DiskChannel.IsReady[instance.drive] THEN        RETURN WITH ERROR Error[notReady];      IF instance.changeCount ~= changeCount THEN        RETURN WITH ERROR Error[invalidHandle];      --~~~~~~~~ END Validity Checks      IF driveState = direct THEN RETURN[PhysicalVolume.nullID, notPilot];      [found, pvID] ¬ PhysicalVolumeInternal.PVIDFromDrive[instance.drive];      IF ~found THEN        -- Try onlining it. If it can't be onlined, it must not be a Pilot        -- Volume. In that case, reset the drive state and return notPilot.        BEGIN        [pvID, success] ¬ TempOnline[          instance ! Error => {localError ¬ error; GO TO ErrExit}];        IF ~success THEN          BEGIN          [] ¬ DiskChannel.SetDriveState[instance.drive, 0, inactive];          RETURN[PhysicalVolume.nullID, notPilot];          END;        END;      -- The PV is now online, it must be a Pilot Volume. Get the Label String.      VolTable.PVAccess[pvID, CopyLabel, read, online];      IF ~found THEN  -- Undo the temporary online that we did above.        BEGIN        PhysicalVolumeOffLineInternal[pvID];        [] ¬ DiskChannel.SetDriveState[instance.drive, 0, inactive];        END;      RETURN[pvID, isPilot];      EXITS ErrExit => RETURN WITH ERROR Error[localError];      END;  -- End of Scope for EXITS      END;  -- End GetHintsEntry    RETURN GetHintsEntry[PhysicalVolumeInternal.GetDriveData[instance.drive]];    END;  GetNext: PUBLIC PROCEDURE [pvID: PhysicalVolume.ID]    RETURNS [PhysicalVolume.ID] = {RETURN[VolTable.GetNextPV[pvID]]};  GetNextBadPage: PUBLIC PROCEDURE [    pvID: PhysicalVolume.ID, thisBadPageNumber: PhysicalVolume.PageNumber]    RETURNS [nextBadPageNumber: PhysicalVolume.PageNumber] =    BEGIN    found: BOOLEAN ¬ (thisBadPageNumber = PhysicalVolume.nullBadPage);    GetNextBadPageInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      GetNextBadPageEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        VolTable.MapPVRootPage[tok, data.pv];        IF Inline.HighHalf[data.pv.badPageCount] ~= 0 THEN Bug[tooManyBadPages];        FOR i: CARDINAL IN [0..Inline.LowHalf[data.pv.badPageCount]) DO          IF found THEN {nextBadPageNumber ¬ data.pv.badPageList[i]; EXIT};          found ¬ (data.pv.badPageList[i] = thisBadPageNumber);          REPEAT FINISHED => nextBadPageNumber ¬ PhysicalVolume.nullBadPage;          ENDLOOP;        VolTable.UnmapPVRootPage[tok, data.pv];        END;  -- GetNextBadPageEntry      GetNextBadPageEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- GetNextBadPageInternal    VolTable.PVAccess[pvID, GetNextBadPageInternal, read];    END;  GetNextDataLostPage: PUBLIC --PhysicalVolumeExtras-- PROCEDURE [    pvID: PhysicalVolume.ID, thisDataLostPageNumber: PhysicalVolume.PageNumber]    RETURNS [nextDataLostPageNumber: PhysicalVolume.PageNumber] =    BEGIN    found: BOOLEAN ¬       (thisDataLostPageNumber = PhysicalVolumeExtras.nullDataLostPage);    GetNextDataLostPageInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      GetNextDataLostPageEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        VolTable.MapDuplicatePVRootPage[tok, data.dupPV];        IF Inline.HighHalf[	  data.dupPV.dataLostPageList.header.countPages] ~= 0 THEN 	  Bug[tooManyDataLostPages];        FOR i: CARDINAL IN	  [0..Inline.LowHalf[data.dupPV.dataLostPageList.header.countPages]) DO          IF found THEN	    {nextDataLostPageNumber ¬ data.dupPV.dataLostPageList.pages[i]; EXIT};          found ¬ (data.dupPV.dataLostPageList.pages[i] = thisDataLostPageNumber);          REPEAT FINISHED => nextDataLostPageNumber ¬ PhysicalVolume.nullBadPage;          ENDLOOP;        VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];        END;  -- GetNextBadPageEntry      GetNextDataLostPageEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- GetNextDataLostPageInternal    VolTable.PVAccess[pvID, GetNextDataLostPageInternal, read];    END;  GetNextDrive: PUBLIC PROCEDURE [index: CARDINAL] RETURNS [nextIndex: CARDINAL] =    -- Stateless enumeration beginning with nullDeviceIndex as an argument and    -- ending with nullDeviceIndex as a result.    BEGIN    drive: DiskChannel.Drive =      DiskChannel.GetNextDrive[PhysicalVolumeInternal.DriveFromIndex[index]];    RETURN[      IF drive = nullDrive THEN PhysicalVolume.nullDeviceIndex      ELSE DiskChannel.GetDriveAttributes[drive].deviceOrdinal];    END;  GetNextLogicalVolume: PUBLIC PROCEDURE [    pvID: PhysicalVolume.ID, lvID: Volume.ID] RETURNS [Volume.ID] =    BEGIN    newLVID: Volume.ID;    GetNextLVInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      GetNextLVEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        svCount: CARDINAL;        pv: PVF.Handle ¬ data.pv;        VolTable.MapPVRootPage[tok, pv];        svCount ¬ pv.subVolumeCount;        IF svCount ~= 0 THEN  -- there are SV's          BEGIN          IF lvID = Volume.nullID THEN newLVID ¬ pv.subVolumes[0].lvID          ELSE  -- Find the specified LV, and get the next one.            BEGIN            foundPrevoius: BOOLEAN ¬ FALSE;            FOR i: CARDINAL IN [0..svCount) DO              IF lvID = pv.subVolumes[i].lvID THEN foundPrevoius ¬ TRUE              ELSE IF foundPrevoius THEN {newLVID ¬ pv.subVolumes[i].lvID; EXIT};              REPEAT                FINISHED =>                  IF foundPrevoius = TRUE THEN newLVID ¬ Volume.nullID                  ELSE ERROR Error[noSuchLogicalVolume];              ENDLOOP;            END;          END        ELSE -- svCount = 0 -- newLVID ¬ Volume.nullID;        VolTable.UnmapPVRootPage[tok, pv];        END;  -- GetNextLVEntry      GetNextLVEntry[PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- GetNextLVInternal    VolTable.PVAccess[pvID: pvID, proc: GetNextLVInternal, lock: read];    RETURN[newLVID];    END;  InterpretHandle: PUBLIC PROCEDURE [instance: Handle]    RETURNS [type: Device.Type, index: CARDINAL] =    BEGIN    changeCount: CARDINAL;    IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN      ERROR Error[invalidHandle];    [deviceType: type, deviceOrdinal: index, changeCount: changeCount] ¬      DiskChannel.GetDriveAttributes[instance.drive];    IF instance.changeCount ~= changeCount THEN ERROR Error[invalidHandle]    END;  IsReady: PUBLIC PROCEDURE [instance: Handle] RETURNS [ready: BOOLEAN] =    BEGIN    changeCount: CARDINAL;    IF ~PhysicalVolumeInternal.ValidateDrive[instance.drive] THEN      ERROR Error[invalidHandle];    [changeCount: changeCount] ¬ DiskChannel.GetDriveAttributes[      instance.drive];    IF changeCount = instance.changeCount THEN      -- Note that there is a race condition in that the previous test on      -- the change count could succeed but the following could die with a      -- bad change count if it changed at the wrong moment.      RETURN[DiskChannel.IsReady[instance.drive]]    ELSE ERROR Error[invalidHandle]    END;  MarkDataLostPage: PUBLIC --PhysicalVolumeExtras-- PROCEDURE [    index: CARDINAL, dataLostPage: PhysicalVolume.PageNumber] =    BEGIN    MarkDataLostPageInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      MarkDataLostPageEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        shortDataLostPageCount: CARDINAL;        VolTable.MapPVRootPage[tok, data.pv];	VolTable.MapDuplicatePVRootPage[tok, data.dupPV];        IF Inline.HighHalf[data.dupPV.dataLostPageList.header.countPages] ~= 0 THEN 	  Bug[tooManyDataLostPages];        shortDataLostPageCount ¬	  Inline.LowHalf[data.dupPV.dataLostPageList.header.countPages];        FOR i: CARDINAL IN [0..shortDataLostPageCount) DO          SELECT data.dupPV.dataLostPageList.pages[i] FROM            > dataLostPage =>              BEGIN              tmp: PhysicalVolume.PageNumber ¬	        data.dupPV.dataLostPageList.pages[i];              data.dupPV.dataLostPageList.pages[i] ¬ dataLostPage;              dataLostPage ¬ tmp;              END;            < dataLostPage => LOOP;            = dataLostPage => 	      BEGIN	      VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];	      VolTable.UnmapPVRootPage[tok, data.pv];	      RETURN;	      END;            ENDCASE => Bug[impossibleEndcase];          ENDLOOP;        IF shortDataLostPageCount 	  >= data.dupPV.dataLostPageList.header.maxEntries THEN          RETURN WITH ERROR ErrorExtras[dataLostSpotTableFull];        data.dupPV.dataLostPageList.pages[shortDataLostPageCount] ¬ dataLostPage;        data.dupPV.dataLostPageList.header.countPages ¬ 	  data.pv.dataLostPageCount ¬ data.dupPV.dataLostPageCount  ¬	  data.dupPV.dataLostPageList.header.countPages + 1;	VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];        VolTable.UnmapPVRootPage[tok, data.pv];        END;  -- MarkDataLostPageEntry      MarkDataLostPageEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- MarkDataLostPageInternal    alreadyAsserted: BOOLEAN ¬ FALSE;    handle: Handle ¬ GetHandle[index];    pvID: PhysicalVolume.ID;    pvID ¬ AssertPilotVolume[handle !      Error => IF error = alreadyAsserted THEN {alreadyAsserted ¬ TRUE; CONTINUE}               ELSE REJECT];    IF alreadyAsserted THEN pvID ¬ PhysicalVolumeInternal.PVIDFromDrive[      PhysicalVolumeInternal.DriveFromIndex[index]].pvID;    VolTable.PVAccess[pvID, MarkDataLostPageInternal, write];    IF NOT alreadyAsserted THEN Offline[pvID];    END;  MarkPageBad: PUBLIC PROCEDURE [    pvID: PhysicalVolume.ID, badPage: PhysicalVolume.PageNumber] =    BEGIN    MarkPageBadInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      MarkPageBadEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        shortBadPageCount: CARDINAL;        VolTable.MapPVRootPage[tok, data.pv];	VolTable.MapDuplicatePVRootPage[tok, data.dupPV];        IF Inline.HighHalf[data.pv.badPageCount] ~= 0 THEN Bug[tooManyBadPages];        shortBadPageCount ¬ Inline.LowHalf[data.pv.badPageCount];        FOR i: CARDINAL IN [0..shortBadPageCount) DO          SELECT data.pv.badPageList[i] FROM            > badPage =>              BEGIN              tmp: PhysicalVolume.PageNumber ¬ data.pv.badPageList[i];              data.pv.badPageList[i] ¬ badPage;              badPage ¬ tmp;              END;            < badPage => LOOP;            = badPage => 	      BEGIN	      VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];	      VolTable.UnmapPVRootPage[tok, data.pv];	      RETURN;	      END;            ENDCASE => Bug[impossibleEndcase];          ENDLOOP;        IF shortBadPageCount >= data.pv.maxBadPages THEN          RETURN WITH ERROR Error[badSpotTableFull];        data.pv.badPageList[shortBadPageCount] ¬ badPage;        data.pv.badPageCount ¬ data.pv.badPageCount + 1;	data.dupPV.badPageCount ¬ data.dupPV.badPageCount + 1;	IF data.pv.badPageCount # data.dupPV.badPageCount THEN	  Bug[dupAndMainRootPagesDontMatch];	VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];        VolTable.UnmapPVRootPage[tok, data.pv];        END;  -- MarkPageBadEntry      MarkPageBadEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- MarkPageBadInternal    VolTable.PVAccess[pvID, MarkPageBadInternal, write];    END;  Offline: PUBLIC PROCEDURE [pvID: PhysicalVolume.ID] =    BEGIN    drive: DiskChannel.Drive;    GetDrive: VolTable.PVAccessProc --[tok, rootPageLoc]--  = {      drive ¬ VolTable.GetDrive[tok]};    OfflineEntry: ENTRY PROCEDURE       [data: PhysicalVolumeInternal.DriveDataHandle] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      localError: PhysicalVolume.ErrorType;      BEGIN  -- scope of OfflineError      PhysicalVolumeOffLineInternal[        pvID ! Error --[error]-- => {localError ¬ error; GO TO OfflineError}];      IF DiskChannel.SetDriveState[drive, 0, inactive] ~= ok THEN        Bug[impossibleDriveStateChangeFailure];      EXITS OfflineError => RETURN WITH ERROR Error[localError];      END;  -- scope of OfflineError      END;  -- OfflineEntry    VolTable.PVAccess[pvID, GetDrive, read];  -- Can raise PVunknown    OfflineEntry[PhysicalVolumeInternal.GetDriveData[drive]];    END;  --Offline--  Scavenge: PUBLIC PROCEDURE [    instance: Handle, repair: PhysicalVolume.RepairType, okayToConvert: BOOLEAN]    RETURNS [status: PhysicalVolume.ScavengerStatus] =    BEGIN    ScavengeEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      localError: PhysicalVolume.ErrorType;      driveState: DiskChannel.DriveState;      BEGIN  -- Provide scope for EXITS.      driveState ¬ DiskChannel.GetDriveAttributes[instance.drive].state;      IF driveState # inactive THEN RETURN WITH ERROR Error[alreadyAsserted];      IF ~DiskChannel.IsReady[instance.drive] THEN        RETURN WITH ERROR Error[notReady];      IF DiskChannel.SetDriveState[instance.drive, instance.changeCount, channel]        ~= ok THEN Bug[impossibleDriveStateChangeFailure];      status ¬ KernelPhysicalVolume.ScavengeWithLock[        instance, repair, okayToConvert !        Error => {localError ¬ error; GO TO ScavengeError}];      IF DiskChannel.SetDriveState[instance.drive, instance.changeCount, inactive]        ~= ok THEN Bug[impossibleDriveStateChangeFailure];      EXITS        ScavengeError =>          BEGIN          IF DiskChannel.SetDriveState[            instance.drive, instance.changeCount, inactive] ~= ok THEN            Bug[impossibleDriveStateChangeFailure];          RETURN WITH ERROR Error[localError];          END;      END;  -- End of scope for EXITS.      END;  -- End of ScavengeEntry.    ScavengeEntry[PhysicalVolumeInternal.GetDriveData[instance.drive]];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The SpecialVolume Implementation.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SubVolumeUnknown: PUBLIC --SpecialVolume.-- ERROR = CODE;  GetNextSubVolume: PUBLIC PROCEDURE [    pvID: PhysicalVolume.ID, this: SpecialVolume.SubVolume]    RETURNS [next: SpecialVolume.SubVolume] =    BEGIN    GetNextSubVolumeInternal: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      GetNextSubVolumeEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        SVIndex: TYPE = [0..PVF.maxSubVols);        ConstructSV: PROCEDURE [svIndex: SVIndex]          RETURNS [SpecialVolume.SubVolume] = INLINE          BEGIN OPEN sv: data.pv.subVolumes[svIndex];          RETURN[[sv.lvID, sv.nPages, sv.lvPage, sv.pvPage]];          END;        found: BOOLEAN ¬ TRUE;        VolTable.MapPVRootPage[tok, data.pv];        IF this = SpecialVolume.nullSubVolume THEN          -- The caller wants the first SV.          IF data.pv.subVolumeCount = 0 THEN next ¬ SpecialVolume.nullSubVolume          ELSE next ¬ ConstructSV[svIndex: 0]        ELSE          FOR i: SVIndex IN [0..data.pv.subVolumeCount) DO            sv: LONG POINTER TO PVF.SubVolumeDesc =              @data.pv.subVolumes[i];            IF sv.lvID = this.lvID AND sv.nPages = this.subVolumeSize              --AND sv.lvPage = this.firstLVPageNumber              AND sv.pvPage = this.firstPVPageNumber THEN              IF i + 1 >= data.pv.subVolumeCount  -- Zero orgin count                THEN {next ¬ SpecialVolume.nullSubVolume; EXIT}              ELSE {next ¬ ConstructSV[i + 1]; EXIT};            REPEAT FINISHED => found ¬ FALSE;            -- Looked at all and prev SV ~found.             ENDLOOP;        VolTable.UnmapPVRootPage[tok, data.pv];        IF ~found THEN ERROR SubVolumeUnknown;        END;  -- GetNextSubVolumeEntry      GetNextSubVolumeEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- GetNextSubVolumeInternal    VolTable.PVAccess[pvID, GetNextSubVolumeInternal, read];    END;  GetPhysicalVolumeBootFiles: PUBLIC PROCEDURE [    pvID: PhysicalVolume.ID, pBootFiles: LONG POINTER TO Boot.PVBootFiles] =    BEGIN    Copy: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      CopyBootFileInfo: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        VolTable.MapPVRootPage[tok, data.pv];        pBootFiles­ ¬ data.pv.bootingInfo;        VolTable.UnmapPVRootPage[tok, data.pv];        END;      CopyBootFileInfo[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;    VolTable.PVAccess[pvID, Copy, read];    END;  SetPhysicalVolumeBootFiles: PUBLIC PROCEDURE [    pvID: PhysicalVolume.ID, pBootFiles: LONG POINTER TO Boot.PVBootFiles] =    BEGIN    Copy: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      CopyBootFileInfo: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        VolTable.MapPVRootPage[tok, data.pv];	VolTable.MapDuplicatePVRootPage[tok, data.dupPV];        data.pv.bootingInfo ¬ data.dupPV.bootingInfo ¬ pBootFiles­;	VM.ForceOut[[Space.PageFromLongPointer[	  data.dupPV], duplicateRootPageSize], wait];        VM.ForceOut[[Space.PageFromLongPointer[data.pv], rootPageSize], wait];	VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];        VolTable.UnmapPVRootPage[tok, data.pv];        END;      CopyBootFileInfo[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;    VolTable.PVAccess[pvID, Copy, write];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --  The KernelPhysicalVolume Implementation.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetSavedLocalTimeParameters: PUBLIC PROCEDURE [pvID: PhysicalVolume.ID]    RETURNS [valid: BOOLEAN, params: System.LocalTimeParameters] =    BEGIN    GetSavedLTP: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      GetSavedLTPEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        VolTable.MapPVRootPage[tok, data.pv];        IF valid ¬ data.pv.localTimeParametersValid THEN          params ¬ data.pv.localTimeParameters;        VolTable.UnmapPVRootPage[tok, data.pv];        END;  -- GetSavedLTPEntry      GetSavedLTPEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- GetSavedLTP    IF pvID = System.nullID THEN      BEGIN      IF System.isUtilityPilot THEN RETURN[valid: FALSE, params: NULL];      pvID ¬ GetContainingPhysicalVolume[Volume.systemID];      END;    VolTable.PVAccess[pvID, GetSavedLTP, read];    END;  SetSavedLocalTimeParameters: PUBLIC PROCEDURE [    params: System.LocalTimeParameters, pvID: PhysicalVolume.ID]    RETURNS [updated: BOOLEAN] =    BEGIN    SetSavedLTP: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      BEGIN      SetSavedLTPEntry: ENTRY PROCEDURE        [data: PhysicalVolumeInternal.DriveDataHandle] =        BEGIN        VolTable.MapPVRootPage[tok, data.pv];	VolTable.MapDuplicatePVRootPage[tok, data.dupPV];        data.pv.localTimeParameters ¬ data.dupPV.localTimeParameters ¬ params;        data.pv.localTimeParametersValid ¬	  data.dupPV.localTimeParametersValid ¬ TRUE;	VolTable.UnmapDuplicatePVRootPage[tok, data.dupPV];        VolTable.UnmapPVRootPage[tok, data.pv];        END;  -- SetSavedLTPEntry      SetSavedLTPEntry[        PhysicalVolumeInternal.GetDriveData[VolTable.GetDrive[tok]]];      END;  -- SetSavedLTP    IF pvID = System.nullID THEN      BEGIN      IF System.isUtilityPilot THEN RETURN[updated: FALSE];      pvID ¬ GetContainingPhysicalVolume[Volume.systemID];      END;    VolTable.PVAccess[pvID, SetSavedLTP, write];    RETURN[updated: TRUE];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Procedures which are private to this module.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  InitialOnline: PROCEDURE [drive: DiskChannel.Drive]    RETURNS [pvID: PhysicalVolume.ID] =    BEGIN    InitialOnlineEntry: ENTRY PROCEDURE      [data: PhysicalVolumeInternal.DriveDataHandle] =      BEGIN      ENABLE ANY => Bug[unexpectedError];      mp: CARDINAL ¬ ProcessorFace.mp;  -- Current MP Code.      changeCount: CARDINAL ¬ DiskChannel.GetDriveAttributes[drive].changeCount;      IF DiskChannel.SetDriveState[drive, changeCount, channel] ~= ok THEN        Runtime.CallDebugger["Could not set Drive state to Pilot"L];      IF ~data.dupRootPageNumValid THEN Bug[dupRootPageNumberUnknown];      [pvID: pvID] ¬ PhysicalVolumeOnLineInternal[        drive, data.pv, data.dupPV, changeCount, data.duplicateRootPageNumber !        NeedsScavenging =>          DO ProcessorFace.SetMP[PilotMP.cPVNeedsScavenging]; ENDLOOP;        Error =>          IF error ~= diskReadError THEN {            ProcessorFace.SetMP[PilotMP.cDriveNotReady]; RETRY}          ELSE CONTINUE];      ProcessorFace.SetMP[mp];      END;    InitialOnlineEntry[      PhysicalVolumeInternal.GetDriveData[drive]];    END;  PhysicalVolumeOffLineInternal: INTERNAL PROCEDURE [pvID: PhysicalVolume.ID] =    BEGIN    sv: VolTable.SVDesc;    hasOpenVolumes: BOOLEAN;    OfflineIfNoOpenLVs: VolTable.TableAccessProc --[]--  =      -- Other actual results: hasOpenVolumes.      BEGIN      DeregisterSubvolume: VolTable.SVAccessProc --[tok]--  = {        VolTable.SetSVOffline[tok]};      DeregisterPV: VolTable.PVAccessProc --[tok, rootPageLoc]--  = {        DiskBackingStore.ReleaseHandle[VolTable.GetBSChannel[tok]];        VolTable.SetPVOffline[tok]};      -- Ensure that there are no open logical volumes on the physical volume:      IF (hasOpenVolumes ¬ NOT KernelVolume.AllRightToTakePVAway[pvID].allRight)        THEN RETURN;      BEGIN      ENABLE ANY => Bug[cleanupNotImplemented];      VolTable.GetNextSV[[byPV[pvID, [first[]]]], @sv];      UNTIL sv = VolTable.nullSVDesc DO        VolTable.SVAccess[          --pvID, sv.lvID, sv.lvPageOfSV, DeregisterSubvolume, write];	pvID, sv.lvID, 0, DeregisterSubvolume, write];	VolTable.GetNextSV[[byPV[pvID, [next[sv.pvPageOfSV]]]], @sv];        ENDLOOP;      VolTable.PVAccess[pvID, DeregisterPV, write];      END;  --scope of cleanupNotImplemented      END;  --OfflineIfNoOpenLVs--    -- Begin main text of PhysicalVolumeOffLineInternal:    VolTable.TableAccess[proc: OfflineIfNoOpenLVs];  -- locks pv and all possible lvs    IF hasOpenVolumes THEN ERROR Error[containsOpenVolumes];    END;  --PhysicalVolumeOffLineInternal--  PhysicalVolumeOnLineInternal: INTERNAL PROCEDURE [    drive: DiskChannel.Drive, pv: PVHandle,    dupPV: DuplicatePVHandle, changeCount: CARDINAL,    duplicateRootPageNumber: PVF.PageNumber]    RETURNS [pvID: PhysicalVolume.ID, alreadyOnline: BOOLEAN] =    BEGIN    diskChannel: DiskChannel.Handle;    OnlinePVAndSVs: VolTable.PVAccessProc --[tok, rootPageLoc]--  =      -- Other arguments: diskChannel of parent frame.      BEGIN      i: CARDINAL;      bsChannel: DiskBackingStore.ChannelHandle;      OnlineSV: VolTable.SVAccessProc = {        OPEN sv: pv.subVolumes[i];        VolTable.SetSVOnline[tok, sv.pvPage, sv.lvPage, sv.nPages]};      diskStatus: DiskChannel.IOStatus;      badPageListPage: PVF.PageNumber;      dataLostPageListPage: PVF.PageNumber;      numPagesForBadPages: PVF.PageCount;      numPagesForDataLostPages: PVF.PageCount;      scratchSpace: LONG POINTER ¬ Space.Allocate[count: 1].pointer;      DiskChannel.SetDriveTag[drive, PVF.IDCheckSum[[pvID]]];      bsChannel ¬ DiskBackingStore.RegisterChannel[diskChannel];      VM.ScratchMap[[Space.PageFromLongPointer[scratchSpace], 1]];      BEGIN      ENABLE UNWIND => {               DiskBackingStore.ReleaseHandle[bsChannel];	       VM.Unmap[Space.PageFromLongPointer[scratchSpace]];	       Space.Deallocate[[scratchSpace, 1]]};      -- The following four statements must be executed in that order!!      VolTable.SetPVOnline[tok, bsChannel];  -- 1 of 4      BEGIN      ENABLE UNWIND => VolTable.SetPVOffline[tok];      VolTable.MapPVRootPage[tok, pv];  -- 2 of 4      BEGIN      ENABLE UNWIND => VolTable.UnmapPVRootPage[tok, pv];      VolTable.MapDuplicatePVRootPage[tok, dupPV];  -- 3 of 4      BEGIN      ENABLE UNWIND => VolTable.UnmapDuplicatePVRootPage[tok, dupPV];      VolTable.RegisterPVMarkerID[tok, pv.subVolumeMarkerID];  -- 4 of 4      --~~~~~~~ BEGIN Validate the PV      IF ~PhysicalVolumeInternal.PhysicalRootPageCheck[pv, pvID].ok         OR ~PhysicalVolumeInternal.CompareDuplicateAndMainPVRootPages[	  dupPV, pv].ok THEN        ERROR NeedsScavenging;      -- Now check to see that the labels on the bad page list page(s) are correct      numPagesForBadPages ¬        (pv.maxBadPages * SIZE[PhysicalVolume.PageNumber] + wordsPerPage - 1) /          wordsPerPage;      FOR badPageListPage IN [rootPage + 1..rootPage + numPagesForBadPages] DO        diskStatus ¬ DataTransfer.ReadPVData[          diskChannel, badPageListPage, Space.PageFromLongPointer[scratchSpace]];        WITH stat: diskStatus SELECT FROM          invalidChannel => ERROR Error[invalidHandle];          invalidDriveState => Bug[impossibleState];          disk =>            SELECT DataTransfer.DiskStatusToDataStatus[stat] FROM              valid => NULL;              invalid, diskError => ERROR NeedsScavenging;              ENDCASE => Bug[impossibleEndcase];          ENDCASE => Bug[impossibleEndcase];        ENDLOOP;      -- Now check to see that the data on the data lost page list pages(s) are ok      numPagesForDataLostPages ¬        (MIN[dupPV.dataLostPageList.header.maxEntries, PVF.maxNumberDataLostPages]        * SIZE[PhysicalVolume.PageNumber] + wordsPerPage - 1) / wordsPerPage;      FOR dataLostPageListPage IN [        duplicateRootPageNumber + 1..duplicateRootPageNumber +        numPagesForDataLostPages] DO        diskStatus ¬	   DataTransfer.ReadPVData[diskChannel, dataLostPageListPage,	   Space.PageFromLongPointer[scratchSpace]];        WITH stat: diskStatus SELECT FROM          invalidChannel => ERROR Error[invalidHandle];          invalidDriveState => Bug[impossibleState];          disk =>            SELECT DataTransfer.DiskStatusToDataStatus[stat] FROM              valid => NULL;              invalid, diskError => ERROR NeedsScavenging;              ENDCASE => Bug[impossibleEndcase];          ENDCASE => Bug[impossibleEndcase];	ENDLOOP;      --change this so that disk select arm is always valid?      --~~~~~~~ END Validate the PV      BEGIN      ENABLE ANY => Bug[cleanupNotImplemented];      FOR i IN [0..pv.subVolumeCount) DO        -- Register SubVolume[i]...        VolTable.SVAccess[  -- Register The Subvolume.          pvID: pvID, lvID: pv.subVolumes[i].lvID,         -- lvPage: pv.subVolumes[i].lvPage, proc: OnlineSV, lock: write,	  lvPage: 0, proc: OnlineSV, lock: write,          entryState: offline];        ENDLOOP;      END;  --scope of cleanupNotImplemented--      END;  --scope of UnmapDuplicatePVRootPage--      VolTable.UnmapDuplicatePVRootPage[tok, dupPV];      END;  --scope of UnmapPVRootPage--      VolTable.UnmapPVRootPage[tok, pv];      END;  --scope of SetPVOffline--      END;  --scope of ReleaseHandle--      VM.Unmap[Space.PageFromLongPointer[scratchSpace]];      Space.Deallocate[[scratchSpace, 1]];      END;  --OnlinePVAndSVs--    BringNewPVOnline: VolTable.TableAccessProc =      -- Sets parent variable diskChannel      BEGIN      found: BOOLEAN;      diskStatus: DiskChannel.IOStatus;      diskChangeCount: CARDINAL;      pv: LONG POINTER ¬ Space.Allocate[count: duplicateRootPageSize].pointer;      --~~~~~~~~~ SEQUENCER ~~~~~~~~~--      alreadyOnline ¬ FALSE;  -- Assume that the PV is not already there.      -- First do the Physical Volume Stuff --      IF ~DiskChannel.InspectDiskShape[drive, longReadOnly].knownType THEN        ERROR Error[notReady];      [found: found, pvID: pvID] ¬ PhysicalVolumeInternal.PVIDFromDrive[drive];      IF found THEN {alreadyOnline ¬ TRUE; RETURN};      diskChannel ¬ DiskChannel.Create[drive];      diskChangeCount ¬ DiskChannel.GetDriveAttributes[        DiskChannel.GetDrive[diskChannel]].changeCount;      IF changeCount # diskChangeCount THEN        ERROR Error[invalidHandle];      IF        ~DiskChannel.IsReady[	  DiskChannel.GetDrive[diskChannel]] THEN ERROR Error[notReady];      -- Can use either of the two root pages.  Use main but only look      -- at first page of it (i.e. Treat it as the duplicate root page)      VM.ScratchMap[        [Space.PageFromLongPointer[pv], CARDINAL[duplicateRootPageSize]]];      diskStatus ¬ DataTransfer.ReadPVData[        diskChannel, rootPage, Space.PageFromLongPointer[pv]];      WITH stat: diskStatus SELECT FROM        invalidChannel => ERROR Error[invalidHandle];        invalidDriveState => Bug[impossibleState];        disk =>          SELECT DataTransfer.DiskStatusToDataStatus[stat] FROM            valid => NULL;            invalid, diskError => ERROR NeedsScavenging;            ENDCASE => Bug[impossibleEndcase];        ENDCASE => Bug[impossibleEndcase];      -- get volume ID from source other than label      pvID ¬ LOOPHOLE[pv, DuplicatePVHandle].pvID;      VM.Unmap[Space.PageFromLongPointer[pv]];      Space.Deallocate[[pv, duplicateRootPageSize]];      IF pvID = nullPVID THEN ERROR NeedsScavenging;      IF KernelPhysicalVolume.ScavengeWithLock[        instance: Handle[        drive, DiskChannel.GetDriveAttributes[drive].changeCount],        repair: checkOnly, okayToConvert: TRUE].status ~=        PhysicalVolume.noProblems THEN ERROR NeedsScavenging;      VolTable.PVAccess[pvID, OnlinePVAndSVs, write, offline];      -- ~~~ Now do the Logical Volume stuff.      KernelVolume.NewPVOnline[pvID];      -- Notify the subsystem(s) above us that a new physical volume has come      -- online. It is up to them to take the appropriate action whatever that      -- might be. NOTE that the VolTable is still locked.      END;  -- BringNewPVOnline    -- Begin Main Code of PhysicalVolumeOnLineInternal    VolTable.TableAccess[BringNewPVOnline];    RETURN[pvID, alreadyOnline]    END;  TempOnline: INTERNAL PROCEDURE [pvH: Handle]    RETURNS [pvID: PhysicalVolume.ID, success: BOOLEAN] =    -- Drive must be in the inactive state. Called only from GetHints.    -- Bug if the online returns ok and the PV was already online.    BEGIN    alreadyOnline: BOOLEAN;    data: PhysicalVolumeInternal.DriveDataHandle =      PhysicalVolumeInternal.GetDriveData[pvH.drive];    success ¬ TRUE;    SELECT DiskChannel.SetDriveState[pvH.drive, pvH.changeCount, channel] FROM      ok => NULL;      illegalState => Bug[impossibleDriveStateChangeFailure];      wrongChangeCount => ERROR Error[invalidHandle];      ENDCASE => Bug[impossibleEndcase];    BEGIN  -- Provide scope for EXITS    IF ~data.dupRootPageNumValid THEN Bug[dupRootPageNumberUnknown];    [pvID, alreadyOnline] ¬ PhysicalVolumeOnLineInternal[      pvH.drive, data.pv, data.dupPV, pvH.changeCount,      data.duplicateRootPageNumber !      Error, NeedsScavenging => GO TO unsucessful];    IF alreadyOnline THEN Bug[impossibleState];    EXITS unsucessful => RETURN[pvID: pvID, success: FALSE];    END;  -- End scope for EXITS    RETURN[pvID: pvID, success: TRUE];    END;  END.LOG   (For earlier log entries, see Pilot 10.0 archive version.)30-Nov-82 10:29:55   JXP      Update for Klamath. Remove Erase and Create Logical Volume. Make the   following procedures speak in terms of only Device Index: GetNextDrive,   GetHandle, and AwaitStateChange. GetAttributes and GetHints take LONG   STRINGS. Use VolTable to manage most locking. Monitor changed to object   monitor, one per drive. Remove knowledge about logical volumes.14-Dec-82 15:37:57   JXP      Write to PV root manually in CreatePV. Use new VolTable Interface (changes   in Map/Unmap PV, FindSV). Call NewPVOnline AFTER releasing PV data in    PVOnlineInternal23-Dec-82 13:05:49   AWL      	KernelPV.Scavenge => KernelPV.ScavengeWithLock 4-Jan-83 18:20:20   JXP   	Fix GetNextDrive, CreatePV. 7-Jan-83 15:56:53   JXP      Fix various bug fixes. Call KernelVolume.NewPVOnline[] with table lock. 11-Jan-83 16:48:49   JXP   	Use new VolTable interface, some names have changed.16-Feb-83 10:53:18   JXP      Fix bug in PVOnlineInternal, GetNextLogicalVolume. modify some comments.   GetNextBadPage26-Feb-83 13:37:34   JXP      Remove unused item from Directory to get rid of compiler warning.18-Mar-83 14:47:18   WDK        Make compatible w/ new StoragePrograms.   Only open sys PV and (using Volume.Open) LV. 1-Apr-83 12:58:17   AWL      	Export maxSubvolumesOnPhysicalVolume.15-Apr-83 16:38:46   JXP   	Initialize Monitor Locks. 5-May-83 17:11:23   JXP   	Check and set DriveState in Scavenge.31-May-83 15:08:28   JXP      Any proc. that Maps the PV Root must be an ENTRY proc.14-Jun-83 16:41:11   LXD         bootFile arg to InitializeFileMgr is no longer READONLY.12-Jul-83 10:32:13   JXP      New argument to Scavenger.Scavenge and PhysicalVolume.Scavenge (okayToConvert). 9-Aug-83 10:53:15   JXP      InitializeFileMgr calls Scavenger to CheckBootLocation when vol is scavenged. 4-Dec-83 13:22:58   WDK        Split finding sys vol and debugger.   AR3632: PhysicalVolume.*[invalidHandle] => death.   Can't convert vol on boot cause maybe can't tell what version it is.   PhysicalVolumeOnLineInternal didn't always clean up right after error.   PhysicalVolumeOffLineInternal forgot to release DiskBackingStore handle.17-Jan-84 13:06:56   EKN     Implement ChangeName.24-Jan-85 11:32:23   CJS       Twiddled calls to VolTable.(GetNextSV & FindSV).25-Mar-85  9:00:04   CJS       Check disk notReady in BringNewPVOnline and ScavengeEntry.        13-Jun-85 16:03:37   AWL   Temporarily, DiskChannelExtras.IsReady is the true source of "readiness" for a disk.  DiskChannel.GetDriveAttributes always returns TRUE.20-Oct-85 15:22:15   RSV   Moved catch phrase in PVIDFromDrive from call to VolTable.PVAccess into loop surrounding FOR loop to preven physicalVolumeUnknown error from VolTable.GetNextPV (like AR 8135).10-Jun-86 10:49:56   RSV   Added CHANGE comments.  Added duplicate root page usage by adding procedures WriteDuplicatePVRootPage and CompareDuplicateAndMainPVRootPages and by modifying procedures CreatePhysicalVolumeEntry, InitialOnlineEntry, AssertPilotVolumeEntry, MarkPageBadEntry, SetPhysicalVolumeBootFiles, SetSavedLTPEntry, and BringNewPVOnline.  Fixed AR 5364 in MarkPageBadEntry (changed to RETURN WITH ERROR). 7-Aug-86 11:33:48   RSV   Did what CHANGE comments said for going labeless.  Also changed PilotDiskFace.Command structure.  Deleted references to Scavenger.Scavenge since Volume.Open now automatically runs the Verifier.29-Sep-86 15:36:46   RSV   OnlinePVAndSV modified to check readability of DataLostTable.  CompareDuplicateAndMainPVRootPages modified to check DataLostTable fields in root pages. 3-Oct-86 14:06:41   CAJ   Import IsReady from DiskChannel instead of DiskChannelExtras. 7-Oct-86 16:33:01   RSV   Added unmapping duplicate PV root page in = badPage case.13-Nov-86 15:25:07   RSV   Deleted last of CHANGE comments (no functional changes).15-Dec-86 15:44:15   RSV   Deleted PVF.duplicateRootPageNumber.  Instead get it from PilotDiskFace.GetDriveAttributes  9-Jan-87 11:56:15   RRR   Changes necessary to enable moving root page15-Jan-87 17:11:22   RRR   Correction to the above changes.18-Jan-87 17:30:28   RSV   Changed things involving moving DataLostTable page count into the table itself. 3-Feb-87 10:56:37   RSV   Added GetDuplicatePVRootLocation working even if PV is offline.20-Feb-87 13:53:26   RSV   Edited Create to do duplicateRootPage correctly.12-Mar-87 10:43:33   RRR   Get rid of Physical Subvolume Marker setting.30-Mar-87 22:34:22   RSV   Use internal values of data lost table to compare, not PV root page version.  Change MarkDataLostPage to take a drive index, instead of a pvID.21-Jun-87 23:14:43   RSV   Added dupRootPageNumValid to DriveData record.  Bug out if dupRootPageNumValid except in creating physical volume, in which case try to find out the duplicate root page number again (needs to be done for EIDisk, which first formats a virgin self describing disk, then create a physical volume on it, but during the boot  the duplicateRootPageNumber is unkown since the SDD page hasn't been written yet).22-Sep-87 13:07:48   CAJ   Comment out INLINE on ConstructSV to make it compile until such time as we can reorganize this thing.19-Nov-87 16:25:01   RSV   Fix up some of the FOR loops to not bomb out on smashes.16-Dec-87 10:52:31   RSV   Fix AssertPilotVolume to return Error[badDisk] when dupRootPageNumValid = FALSE.  Also, if it is false the first time, try again to InspectDiskShape.  Moved a bunch of stuff from here to PhysicalVolumeImplB, and renamed this module to PhysicalVolumeImplA.29-Dec-87 17:09:59   RSV   ConstructSV is an INLINE again. 5-Jan-88 16:37:31   RSV   Change GetDuplicatePVRootLocation to take a drive index, instead of a pvID. 1-Dec-88 12:19:28   RSV   In CreatePhysicalVolumeEntry, always compute duplicateRootPageNumber in case disk type changed during this boot.
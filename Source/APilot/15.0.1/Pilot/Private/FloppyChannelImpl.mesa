-- Copyright (C) 1984, 1985, 1986, 1987, 1989  by Xerox Corporation. All rights reserved. -- FloppyChannelImpl.mesa            20-Jan-89 15:32:00 by MS   -- THINGS TO DO:--  1) Troy format<< NOTES:     The locking scheme for the three monitor locks is:       contextLock - to lock procedures calling into the FloppyDiskFace.       lockAroundNakedNotifyWaits - to lock procedures that do a WAIT nakedNotify,          but can not afford giving up the contextLock       bufferLock - to lock the global variables clientDataSpace, clientDataSpacePage     We must guard the state vector in procedures that hold      the contextLock and call into SubmitRequest. SubmitRequest WAITS      on the nakedNotify, thus releasing its SV for other clients to use before     it awakens. To avoid it waiting for a SV while holding monitor locks,      we guard the SV using a reserved priority, and set it back outside the locked     procedures. >>       DIRECTORY   DeviceError,   DeviceTypesExtras4 USING [FloppyTape],   Environment USING [Base, first64K, PageNumber, wordsPerPage],   FloppyDiskFace,   FloppyChannel,   FloppyChannelExtras,   Inline USING [LongCOPY],   Process USING [DisableAborts, MsecToTicks, Priority, SetTimeout],   ResidentHeap USING [MakeNode],   RuntimeInternal USING [Bug],   Space USING [Error, Interval, LongPointerFromPage, unknownUsage],   StoragePrograms USING [AllocateVM],   SwapperDriverStartChain USING [Start],   SpecialFloppyChannel,   SpecialFloppyChannelExtras USING [Statistics],   SpecialFloppyTapeFace USING [GetStatistics, Retention, Statistics],   SpecialRuntime USING [AllocateNakedCondition, DeallocateNakedCondition],   VM USING [DoneWithStateVector, GuardStateVector, Map, Unmap],   VMExtras2 USING [GetConsecutiveVMResidentRealMemory, FreeConsecutiveVMResidentRealMemory],   Zone USING [Status];FloppyChannelImpl: MONITOR LOCKS ml USING ml: LONG POINTER TO MONITORLOCK   IMPORTS      FloppyDiskFace, Inline, Process, ResidentHeap, RuntimeInternal, Space,      StoragePrograms, RemainingDrivers: SwapperDriverStartChain, SpecialRuntime,      SpecialFloppyTapeFace, VM, VMExtras2   EXPORTS      DeviceError, FloppyChannel, FloppyChannelExtras, SpecialFloppyChannel,       SpecialFloppyChannelExtras, SwapperDriverStartChain =   BEGIN   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- Signals, Types and Loopholes   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   Attributes: TYPE = FloppyChannel.Attributes;   ChangeCount: TYPE = CARDINAL;   Context: TYPE = FloppyChannel.Context;   DiskAddress: TYPE = FloppyChannel.DiskAddress;   Drive: TYPE = FloppyChannel.Drive;   Status: TYPE = FloppyChannel.Status;      NotGetConsecutiveVMResidentRealMemory: PUBLIC SIGNAL = CODE;   DriveInfo: TYPE = RECORD [      faceDevice: FloppyDiskFace.DeviceHandle, changeCount: ChangeCount];   Handle: PUBLIC TYPE = RECORD [      drive: Drive,  -- index into the drives array      changeCount: CARDINAL];  -- when handle was issued         nullHandle: PUBLIC Handle ¬ [drive: FloppyChannel.nullDrive, changeCount: LAST[CARDINAL]];   OpBlock: TYPE = RECORD [      function: FloppyDiskFace.Function,      address: FloppyDiskFace.DiskAddress,      dataPtr: LONG POINTER,      incrementDataPtr: BOOLEAN,      tries: FloppyDiskFace.Tries,      count: CARDINAL];   WhichContext: TYPE = RECORD [      vp: SELECT contextType: * FROM         useCurrentContext => [],         useMyContext => [context: FloppyChannel.Context],         ENDCASE];	    Bug: PROCEDURE [bug: BugType] = INLINE {RuntimeInternal.Bug[bug]};   BugType: TYPE = {impossibleEndcase, unexpectedErrorStatus};   Error: PUBLIC ERROR [type: FloppyChannel.ErrorType] = CODE;   FaceToChannelContext: PROC [c: FloppyDiskFace.Context] RETURNS [Context] = INLINE {      RETURN[[        protect: c.protect, 	format: IF c.format = IBM THEN IBM ELSE Troy,        density: IF c.density = single THEN single ELSE double,        sectorLength: c.sectorLength]]};   ChannelToFaceContext: PROC [c: Context] RETURNS [FloppyDiskFace.Context] = INLINE {      RETURN[[        protect: c.protect,        format: IF c.format = IBM THEN IBM ELSE Troy,        density: IF c.density = single THEN single ELSE double,        sectorLength: c.sectorLength]]};   FaceToChannelAttributes: PROC [a: FloppyDiskFace.Attributes] RETURNS [Attributes] =      INLINE {RETURN [[	 a.type, a.numberOfCylinders, a.numberOfHeads, a.maxSectorsPerTrack, 	 a.formatLength, a.ready, a.diskChange, a.twoSided]]};      GetDA: PROC [a: DiskAddress] RETURNS [address: FloppyDiskFace.DiskAddress] = INLINE {      RETURN[LOOPHOLE[a]]};   FilterStatus: PROC [s: FloppyDiskFace.Status]      RETURNS [status: Status] =      BEGIN      SELECT s FROM         inProgress => NULL;	 goodCompletion => status ¬ goodCompletion;	 diskChange => status ¬ diskChange;	 notReady => status ¬ notReady; 	 cylinderError => status ¬ cylinderError; 	 recordNotFound => status ¬ recordNotFound; 	 headerError => status ¬ headerError;	 dataError => status ¬ dataError;         dataLost => status ¬ dataLost;	 deletedData => status ¬ deletedData;	 writeFault => status ¬ writeFault;	 otherError => status ¬ otherError;	 memoryError, invalidOperation, aborted => Bug[unexpectedErrorStatus];         ENDCASE => Bug[impossibleEndcase];      END;   -- Constants   maxDrives: Drive = 4;   idLength: CARDINAL = 3;  -- words   nullAddress: FloppyDiskFace.DiskAddress = [0, 0, 0];   nDrives: Drive [0..maxDrives) ¬ 0;   priorityReserved: Process.Priority ¬ 3;   -- Global Variables   clientDataSpace: Space.Interval;   clientDataSpacePage: Environment.PageNumber;   drives: ARRAY Drive [0..maxDrives) OF DriveInfo;   doRequestTask: FloppyDiskFace.OperationPtr;   nakedNotify: LONG POINTER TO CONDITION;   bufferLock, lockAroundNakedNotifyWaits, contextLock: MONITORLOCK;   -- Globals for DeviceError implementation   errorData: RECORD [      totalGoodCompletions: LONG CARDINAL ¬ 0,      totalRetries: LONG CARDINAL ¬ 0,      errorsSinceLastReport: CARDINAL ¬ 0,      logAllOpsIfNotZero: CARDINAL ¬ 0,      last: RECORD [         status: FloppyDiskFace.Status,         operation: FloppyDiskFace.Operation,         ordinal: CARDINAL,         retries: CARDINAL] ¬ NULL,      error: CONDITION];   -- Private errors   FloppyIocbAllocError: ERROR = CODE;   ZeroCount: ERROR = CODE;   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- PUBLIC PROCS    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      AwaitFloppyError: PUBLIC PROC [logAllOperations: BOOLEAN ¬ FALSE]       RETURNS [         operation: FloppyDiskFace.Operation, deviceOrdinal: CARDINAL,         status: FloppyDiskFace.Status, retriesThisOperation: CARDINAL,         errorsSinceLastReport: CARDINAL, totalCompletions: LONG CARDINAL,         totalRetries: LONG CARDINAL] =      BEGIN      AwaitFloppyErrorWithLock: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] =         BEGIN         copyErrorsSinceLastReport: CARDINAL;         initialTotalCompletions: LONG CARDINAL = errorData.totalGoodCompletions;         IF logAllOperations THEN            errorData.logAllOpsIfNotZero ¬ errorData.logAllOpsIfNotZero + 1;         DO            copyErrorsSinceLastReport ¬ errorData.errorsSinceLastReport;            IF copyErrorsSinceLastReport # 0 THEN EXIT;            IF (errorData.logAllOpsIfNotZero # 0)               AND (initialTotalCompletions # errorData.totalGoodCompletions) THEN               EXIT;            WAIT errorData.error;            ENDLOOP;         IF logAllOperations THEN            errorData.logAllOpsIfNotZero ¬ errorData.logAllOpsIfNotZero - 1;         errorData.errorsSinceLastReport ¬ 0;         operation ¬ errorData.last.operation;         deviceOrdinal ¬ errorData.last.ordinal;         status ¬ errorData.last.status;         retriesThisOperation ¬ errorData.last.retries;         errorsSinceLastReport ¬ copyErrorsSinceLastReport;         totalCompletions ¬ errorData.totalGoodCompletions;         totalRetries ¬ errorData.totalRetries;         END;      AwaitFloppyErrorWithLock[ml: @contextLock];      END;             DoDirectIO: PUBLIC PROC [     -- SpecialFloppyChannel --     operationPtr: FloppyDiskFace.OperationPtr]     RETURNS [       status: FloppyDiskFace.Status, retryCount: CARDINAL,        rawStatus: FloppyDiskFace.LogStatus] =     BEGIN          DoDirectIOWithLock: ENTRY PROC[ml: LONG POINTER TO MONITORLOCK] =       BEGIN              CompleteDirectIO: ENTRY PROC[ml: LONG POINTER TO MONITORLOCK] =         BEGIN         DO	 [status, retryCount] ¬ FloppyDiskFace.Poll[operationPtr];	 SELECT status FROM 	   inProgress => WAIT nakedNotify;	   ENDCASE => RETURN;	 ENDLOOP;	 END;              IF FloppyDiskFace.Initiate[operationPtr] = inProgress          THEN CompleteDirectIO[@lockAroundNakedNotifyWaits]	 ELSE [status, retryCount] ¬ FloppyDiskFace.Poll[operationPtr];       IF status = diskChange THEN          NoticeDiskChangedDirectIO[operationPtr.device];       rawStatus ¬ FloppyDiskFace.GetLogStatus[operationPtr];       END;            DoDirectIOWithLock[@contextLock];     END;            DoTapeDirectIO: PUBLIC PROC [     -- SpecialFloppyChannelExtras --     operationPtr: FloppyDiskFace.OperationPtr]     RETURNS [       status: FloppyDiskFace.Status, retryCount: CARDINAL,        rawStatus: FloppyDiskFace.LogStatus] =     BEGIN          DoTapeDirectIOWithLock: ENTRY PROC[ml: LONG POINTER TO MONITORLOCK] =       BEGIN              «CompleteTapeDirectIO: ENTRY PROC[ml: LONG POINTER TO MONITORLOCK] =         BEGIN         DO	 [status, retryCount] ¬ FloppyDiskFace.Poll[operationPtr];	 SELECT status FROM 	   inProgress => WAIT nakedNotify;	   ENDCASE => RETURN;	 ENDLOOP;	 END;»              «IF FloppyDiskFace.Initiate[operationPtr] = inProgress          THEN CompleteDirectIO[@lockAroundNakedNotifyWaits]	 ELSE [status, retryCount] ¬ FloppyDiskFace.Poll[operationPtr];»       --ABOVE CHANGED TO THE FOLLOWING IF-THEN-ELSE STATEMENT       IF FloppyDiskFace.Initiate[operationPtr] = inProgress THEN         BEGIN	 DO	 [status, retryCount] ¬ FloppyDiskFace.Poll[operationPtr];	 SELECT status FROM 	   inProgress => WAIT nakedNotify;	   ENDCASE => RETURN;	 ENDLOOP;	 END       ELSE [status, retryCount] ¬ FloppyDiskFace.Poll[operationPtr];              IF status = diskChange THEN          NoticeDiskChangedDirectIO[operationPtr.device];       rawStatus ¬ FloppyDiskFace.GetLogStatus[operationPtr];       END;            DoTapeDirectIOWithLock[@contextLock];     END;             GetContext: PUBLIC PROC [handle: Handle] RETURNS [context: Context] =      BEGIN      GetContextWithLock: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] = {         IF ~ValidHandle[handle] THEN RETURN WITH ERROR Error[invalidHandle];         context ¬ FaceToChannelContext[            FloppyDiskFace.GetContext[GetDeviceHandle[handle]]]};      GetContextWithLock[@contextLock];      END;         GetDeviceAttributes: PUBLIC PROC [handle: Handle]      RETURNS [attributes: Attributes] =      BEGIN      GetDeviceAttributesWithLock: ENTRY PROC [         ml: LONG POINTER TO MONITORLOCK] = {         IF ~ValidHandle[handle] THEN RETURN WITH ERROR Error[invalidHandle];         attributes ¬ GetDeviceAttributesInternal[GetDeviceHandle[handle]]};      GetDeviceAttributesWithLock[@contextLock];      END;  GetDeviceAttributesInternal: INTERNAL PROC [handle: FloppyDiskFace.DeviceHandle]    RETURNS [attributes: Attributes] = {    RETURN[FaceToChannelAttributes[FloppyDiskFace.GetDeviceAttributes[handle]]]};   GetDeviceHandle: PUBLIC PROC [handle: Handle]      RETURNS [FloppyDiskFace.DeviceHandle] =     BEGIN     RETURN[drives[handle.drive].faceDevice];     END;   GetHandle: PUBLIC PROC [drive: Drive] RETURNS [handle: Handle] =      BEGIN      prevPriority: Process.Priority;      GetHandleWithLock: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] = {         prevPriority ¬ VM.GuardStateVector[priorityReserved];         IF drive ~IN [0..nDrives) THEN RETURN WITH ERROR Error[invalidDrive];         -- clear possible residual DiskChanges         THROUGH [0..2) DO            op: OpBlock ¬ [nop, nullAddress, NIL, FALSE, 1, 1];            [] ¬ SubmitRequest[               [drive: drive, changeCount: drives[drive].changeCount], @op];            ENDLOOP;         handle ¬ [drive: drive, changeCount: drives[drive].changeCount]};      GetHandleWithLock[@contextLock];      VM.DoneWithStateVector[prevPriority];      END;         GetNextDrive: PUBLIC PROC [lastDrive: Drive] RETURNS [nextDrive: Drive] = {      IF lastDrive = FloppyChannel.nullDrive THEN nextDrive ¬ 0      ELSE         IF lastDrive NOT IN [0..nDrives) THEN ERROR Error[invalidDrive]         ELSE nextDrive ¬ SUCC[lastDrive];      IF nextDrive >= nDrives THEN nextDrive ¬ FloppyChannel.nullDrive};         FormatTracks: PUBLIC PROC [      handle: Handle, start: DiskAddress, trackCount: CARDINAL]      RETURNS [status: Status, countDone: CARDINAL] = {      [status, countDone] ¬ DoRequestWithBuffer[         handle, GetDA[start], NIL, trackCount, FALSE, formatTrack, @bufferLock]};	 	    InterpretHandle: PUBLIC PROC [handle: Handle] RETURNS [drive: Drive] =      BEGIN      InterpretHandleWithLock: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] = {         IF ~ValidHandle[handle] THEN RETURN WITH ERROR Error[invalidHandle];         drive ¬ handle.drive};      InterpretHandleWithLock[@contextLock];      END;      	    Nop: PUBLIC PROC [handle: Handle] RETURNS [status: Status] = {      prevPriority: Process.Priority;      [status, prevPriority] ¬ DoSimpleRequest[handle, nop, nullAddress, NIL, @contextLock];      VM.DoneWithStateVector[prevPriority]};	 	    ReadID: PUBLIC PROC [handle: Handle, address: DiskAddress, buffer: LONG POINTER]      RETURNS [status: Status] = {      prevPriority: Process.Priority;      [status, prevPriority] ¬ DoSimpleRequest[         handle, readID, GetDA[address], buffer, @contextLock];      VM.DoneWithStateVector[prevPriority]};               ReadSectors: PUBLIC PROC [      handle: Handle, address: DiskAddress, buffer: LONG POINTER, count: CARDINAL,      incrementDataPtr: BOOLEAN] RETURNS [status: Status, countDone: CARDINAL] = {      [status, countDone] ¬ DoRequestWithBuffer[         handle, GetDA[address], buffer, count, incrementDataPtr, readSector,         @bufferLock]};	    ReadSectorsWithContext: PUBLIC PROC [      handle: Handle, address: DiskAddress, buffer: LONG POINTER, count: CARDINAL,      incrementDataPtr: BOOLEAN, context: FloppyChannel.Context]      RETURNS [status: Status, countDone: CARDINAL] = {      prevPriority: Process.Priority;            IF ~ValidHandleWithLock[handle, @contextLock] THEN ERROR Error[invalidHandle];      IF count = 0 THEN {status ¬ Nop[handle]; countDone ¬ 0; RETURN};      IF buffer = NIL THEN incrementDataPtr ¬ FALSE;      [status, countDone, ,prevPriority] ¬ SetUpRequestAndSubmit[         handle, GetDA[address], buffer, buffer, count, incrementDataPtr, 	 readSector, [useMyContext[context]], @contextLock];       VM.DoneWithStateVector[prevPriority]};                 SetContext: PUBLIC PROC [handle: Handle, context: Context] RETURNS [BOOLEAN] =      BEGIN      SetContextWithLock: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK]         RETURNS [BOOLEAN] = {         IF ~ValidHandle[handle] THEN RETURN WITH ERROR Error[invalidHandle];         IF context.format # IBM THEN RETURN[FALSE];         SELECT context.sectorLength FROM            64, 128, 256, 512 --words-- => NULL;            ENDCASE => RETURN[FALSE];         RETURN[            FloppyDiskFace.SetContext[               GetDeviceHandle[handle], ChannelToFaceContext[context]]]};      RETURN[SetContextWithLock[@contextLock]];      END;         WriteDeletedSectors: PUBLIC PROC [      handle: Handle, address: DiskAddress, buffer: LONG POINTER, count: CARDINAL,      incrementDataPtr: BOOLEAN] RETURNS [status: Status, countDone: CARDINAL] = {      [status, countDone] ¬ DoRequestWithBuffer[         handle, GetDA[address], buffer, count, incrementDataPtr,         writeDeletedSector, @bufferLock]};	    WriteSectors: PUBLIC PROC [      handle: Handle, address: DiskAddress, buffer: LONG POINTER, count: CARDINAL,      incrementDataPtr: BOOLEAN] RETURNS [status: Status, countDone: CARDINAL] = {      [status, countDone] ¬ DoRequestWithBuffer[         handle, GetDA[address], buffer, count, incrementDataPtr, writeSector,         @bufferLock]};	    WriteSectorsWithContext: PUBLIC PROC [      handle: Handle, address: DiskAddress, buffer: LONG POINTER, count: CARDINAL,      incrementDataPtr: BOOLEAN, context: FloppyChannel.Context]      RETURNS [status: Status, countDone: CARDINAL] = {      prevPriority: Process.Priority;            IF ~ValidHandleWithLock[handle, @contextLock] THEN ERROR Error[invalidHandle];      IF count = 0 THEN {status ¬ Nop[handle]; countDone ¬ 0; RETURN};      IF buffer = NIL THEN incrementDataPtr ¬ FALSE;      [status, countDone, ,prevPriority] ¬ SetUpRequestAndSubmit[         handle, GetDA[address], buffer, buffer, count, incrementDataPtr, 	 writeSector, [useMyContext[context]], @contextLock];      VM.DoneWithStateVector[prevPriority]};   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- PUBLIC PROCS ONLY FOR FloppyTapes     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      GetDeviceStatistics: PUBLIC -- SpecialFloppyChannelExtras -- PROCEDURE [     drive: CARDINAL, stats: LONG POINTER] =     BEGIN          GetDeviceStatisticsWithLock: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] =       BEGIN       statInfo: SpecialFloppyTapeFace.Statistics;       IF drive >= nDrives OR         LOOPHOLE[           GetDeviceAttributesInternal[drives[drive].faceDevice].deviceType,           CARDINAL]         NOT IN DeviceTypesExtras4.FloppyTape THEN         RETURN WITH ERROR Error[invalidDrive];       IF stats = NIL THEN RETURN;       statInfo ¬ SpecialFloppyTapeFace.GetStatistics[];         -- does this call into FloppyDiskFace?  If not, doesn't have to be	 -- an entry procedure      LOOPHOLE[stats, LONG POINTER TO SpecialFloppyChannelExtras.Statistics]­ ¬ [         statInfo.retriesDone, statInfo.recordNotFoundErrors, 	 statInfo.totalRetriesDone, statInfo.retentionNeeded,	 LOOPHOLE[statInfo.retentionsDone, CARDINAL]];       END;  --GetDeviceStatisticsWithLock--            GetDeviceStatisticsWithLock[@contextLock];     END;  --GetDeviceStatistics--        Retention: PUBLIC -- SpecialFloppyChannelExtras -- PROCEDURE [     handle: FloppyChannel.Handle] RETURNS [status: FloppyChannel.Status] =     BEGIN          RetentionWithLock: ENTRY PROC[ml: LONG POINTER TO MONITORLOCK] =       BEGIN       device: FloppyDiskFace.DeviceHandle;       s: FloppyDiskFace.Status;       storage: ARRAY [0..idLength) OF UNSPECIFIED;              CompleteRetention: ENTRY PROC[ml: LONG POINTER TO MONITORLOCK] =         BEGIN	 DO	 [s, ] ¬ FloppyDiskFace.Poll[doRequestTask];	 SELECT s FROM 	   inProgress => WAIT nakedNotify;	   ENDCASE => RETURN;	 ENDLOOP;	 END;	        device ¬ GetDeviceHandle[handle];       doRequestTask­ ¬ [-- device, function, count are ignored by head --         device: device, function: nop,         incrementDataPointer: FALSE, address: nullAddress,         dataPtr: @storage, tries: FloppyDiskFace.SuggestedTries[device], count: 1];       IF (s ¬ SpecialFloppyTapeFace.Retention[doRequestTask]) = inProgress THEN         CompleteRetention[@lockAroundNakedNotifyWaits];       status ¬ FilterStatus[s];       END;     RetentionWithLock[@contextLock];     END;   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- ENTRY PROCS   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      -- called with contextLock   DoSimpleRequest: ENTRY PROC [      handle: Handle, func: FloppyDiskFace.Function, address: FloppyDiskFace.DiskAddress,      clientStorage: LONG POINTER TO ARRAY [0..idLength) OF UNSPECIFIED,      ml: LONG POINTER TO MONITORLOCK]       RETURNS [status: Status, prevPriority: Process.Priority] = {      storage: ARRAY [0..idLength) OF UNSPECIFIED;      op: OpBlock ¬ [func, address, @storage, FALSE, 1, 1];      IF ~ValidHandle[handle] THEN RETURN WITH ERROR Error[invalidHandle];      prevPriority ¬ VM.GuardStateVector[priorityReserved];      [status, , ] ¬ SubmitRequest[handle, @op];      IF status = diskChange THEN RETURN WITH ERROR Error[invalidHandle];      IF clientStorage # NIL THEN clientStorage­ ¬ storage};         -- called with bufferLock   DoRequestWithBuffer: ENTRY PROC [      handle: Handle, address: FloppyDiskFace.DiskAddress, pUser: LONG POINTER,      countLeft: CARDINAL, incrementDataPtr: BOOLEAN, function: FloppyDiskFace.Function,      ml: LONG POINTER TO MONITORLOCK]      RETURNS [status: Status, countDone: CARDINAL ¬ 0] =      BEGIN      ENABLE UNWIND => VM.Unmap [clientDataSpacePage ! Space.Error => CONTINUE];      deviceHandle: FloppyDiskFace.DeviceHandle ¬ GetDeviceHandle[handle];      prevPriority: Process.Priority;      pPinned: LONG POINTER ¬ clientDataSpace.pointer;      itemsPerRun, itemLength, wordsNeeded: CARDINAL;      updatedAddress: FloppyDiskFace.DiskAddress;      pagesToMap: CARDINAL;      ok: BOOLEAN;            -- called with contextLock      GetCurrentSectorScoop: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK]        RETURNS [sectorsPerTrack, sectorLength: CARDINAL] = {        sectorLength ¬ FloppyDiskFace.GetContext[deviceHandle].sectorLength;        sectorsPerTrack ¬           FloppyDiskFace.GetDeviceAttributes[deviceHandle].maxSectorsPerTrack};            -- called with contextLock      GetWordsNeeded: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] = {        wordsNeeded ¬ 	  FloppyDiskFace.GetDeviceAttributes[deviceHandle].attributes.formatLength};            IF ~ValidHandle[handle] THEN RETURN WITH ERROR Error[invalidHandle];      IF countLeft = 0 THEN RETURN[status: Nop[handle], countDone: 0];      SELECT function FROM         formatTrack => {            GetWordsNeeded[@contextLock];            itemsPerRun ¬ countLeft};         readSector, writeSector, writeDeletedSector => {            [sectorsPerTrack: itemsPerRun, sectorLength: itemLength] ¬               GetCurrentSectorScoop[@contextLock];            IF pUser = NIL THEN incrementDataPtr ¬ FALSE;            IF incrementDataPtr THEN wordsNeeded ¬ itemLength * itemsPerRun            ELSE {wordsNeeded ¬ itemLength; itemsPerRun ¬ countLeft}};         ENDCASE => ERROR;      IF wordsNeeded # 0 THEN         BEGIN	 pagesToMap ¬ MAX [Pages[wordsNeeded], 2];    --for 1024 Format	 IF pagesToMap > clientDataSpace.count THEN {	    pagesToMap ¬ CARDINAL[clientDataSpace.count];	    itemsPerRun ¬ pagesToMap};	 VM.Map[            interval: [clientDataSpacePage, pagesToMap], transferProc: NIL,            backingStoreRuns: NIL, class: pilotResident, swapUnits: [unitary[]],            swappability: resident];	 IF itemLength = 512 --1024/2-- THEN {    -- get consecutive real memory	    FOR i:CARDINAL IN [0..10) DO	    ok ¬ VMExtras2.GetConsecutiveVMResidentRealMemory[interval: [clientDataSpacePage, pagesToMap]];	    IF ok THEN GOTO Success;	    ENDLOOP;	        VM.Unmap[clientDataSpacePage];		SIGNAL NotGetConsecutiveVMResidentRealMemory;	    EXITS Success => NULL};	 END      ELSE pPinned ¬ NIL;      -- countLeft is remaining sectors      -- pUser points to client storage      -- pPinned points to driver storage      -- itemsPerRun, itemLength are initialized with sector info      -- if formatTracks, pUser=NIL and incrementDataPtr=FALSE      updatedAddress ¬ address;      WHILE countLeft > 0 DO         countThisPass: CARDINAL ¬ MIN[countLeft, itemsPerRun];         IF pUser # NIL THEN            SELECT function FROM               writeDeletedSector, writeSector => {                  -- try to track align write runs for quicker verify                  IF incrementDataPtr AND updatedAddress.sector IN [1..itemsPerRun] THEN                     countThisPass ¬ MIN[                        countThisPass, 1 + itemsPerRun - updatedAddress.sector];		  IF incrementDataPtr THEN                    Inline.LongCOPY[                       from: pUser, nwords: (countThisPass * itemLength),                       to: pPinned]		  ELSE Inline.LongCOPY[                       from: pUser, nwords: itemLength, to: pPinned]};               ENDCASE;         [status, countThisPass, updatedAddress, prevPriority] ¬ SetUpRequestAndSubmit[            handle, updatedAddress, pUser, pPinned, countThisPass, incrementDataPtr,	    function, [useCurrentContext[]], @contextLock];	 VM.DoneWithStateVector[prevPriority];         IF pUser # NIL THEN {            length: CARDINAL =               itemLength *                  (IF incrementDataPtr OR countThisPass = 0 THEN countThisPass                   ELSE 1);            SELECT function FROM               readSector =>                  Inline.LongCOPY[from: pPinned, nwords: length, to: pUser];               ENDCASE;            IF incrementDataPtr THEN pUser ¬ pUser + length};         countLeft ¬ countLeft - countThisPass;         countDone ¬ countDone + countThisPass;         IF status # goodCompletion THEN EXIT;         ENDLOOP;      IF wordsNeeded ~= 0 THEN {      IF itemLength = 512 --1024/2-- THEN  {         VMExtras2.FreeConsecutiveVMResidentRealMemory[interval: [clientDataSpacePage, pagesToMap]];};         VM.Unmap[clientDataSpacePage];};      END;      -- called with contextLock   SetUpRequestAndSubmit: ENTRY PROC [      handle: Handle, address: FloppyDiskFace.DiskAddress, pUser: LONG POINTER,      pPinned: LONG POINTER, countLeft: CARDINAL, incrementDataPtr: BOOLEAN,      function: FloppyDiskFace.Function, whichContext: WhichContext,      ml: LONG POINTER TO MONITORLOCK]      RETURNS [status: Status, countDone: CARDINAL ¬ 0,         updatedAddress: FloppyDiskFace.DiskAddress, prevPriority: Process.Priority] =      BEGIN      o, verify: OpBlock ¬ NULL;      savedContext: FloppyDiskFace.Context;            o.incrementDataPtr ¬ incrementDataPtr;      o.address ¬ address;      o.count ¬ countLeft;      -- o.tries is set within SubmitRequest also      -- but it should be done here instead      o.tries ¬ FloppyDiskFace.SuggestedTries[GetDeviceHandle[handle]];      o.dataPtr ¬ pPinned;      o.function ¬ function;      verify ¬ o;      WITH whichContext SELECT FROM         useCurrentContext => NULL;         useMyContext => {            savedContext ¬ FloppyDiskFace.GetContext[GetDeviceHandle[handle]];            [] ¬ FloppyDiskFace.SetContext[               GetDeviceHandle[handle], ChannelToFaceContext[context]]};         ENDCASE;             prevPriority ¬ VM.GuardStateVector[priorityReserved];      [status, countDone, updatedAddress] ¬ SubmitRequest[handle, @o];      IF pUser # NIL AND pUser # pPinned THEN         -- This test avoids writing into the client buffer when verifying.	 -- Eventually we should fix this so a verify can be done with a	 -- read operation into another one page buffer         BEGIN         SELECT function FROM            writeDeletedSector, writeSector =>               IF countDone > 0 THEN {                  verifyStatus: Status;                  verifyCount: CARDINAL;                  verify.function ¬ readSector;                  verify.count ¬ countDone;                  [verifyStatus, verifyCount, ] ¬ SubmitRequest[handle, @verify];                  IF verifyCount < countDone THEN status ¬ verifyStatus};            ENDCASE;         END;      WITH whichContext SELECT FROM         useCurrentContext => NULL;         useMyContext =>	   [] ¬ FloppyDiskFace.SetContext[GetDeviceHandle[handle], savedContext];         ENDCASE;      IF status = diskChange THEN RETURN WITH ERROR Error[invalidHandle];      END;      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- INTERNAL PROCS   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- as a side effect, this guy copies the final "head" next disk address   -- back to pOp.address   SubmitRequest: INTERNAL PROC [handle: Handle, pOp: POINTER TO OpBlock]      RETURNS [status: Status, countDone: CARDINAL, updatedAddress: FloppyDiskFace.DiskAddress] =      BEGIN            CompleteDeviceOperation: ENTRY PROC [ml: LONG POINTER TO MONITORLOCK] =         BEGIN         DO	    [faceStatus, retriedCount] ¬ FloppyDiskFace.Poll[doRequestTask];            status ¬ FilterStatus[faceStatus];            SELECT TRUE FROM               faceStatus = inProgress => WAIT nakedNotify;               ENDCASE --error or goodCompletion-- => RETURN;            ENDLOOP;         END;      faceStatus: FloppyDiskFace.Status;      device: FloppyDiskFace.DeviceHandle ¬ GetDeviceHandle[handle];      retriedCount: CARDINAL ¬ 0;          -- tries should be passed in, but GetHandle doesn't know how      -- so we do it again here      doRequestTask­ ¬ [         device: device, function: pOp.function,         incrementDataPointer: pOp.incrementDataPtr, address: pOp.address,         dataPtr: pOp.dataPtr, tries: FloppyDiskFace.SuggestedTries[device], count: pOp.count];      status ¬ FilterStatus[faceStatus ¬ FloppyDiskFace.Initiate[doRequestTask]];      IF faceStatus = inProgress THEN         CompleteDeviceOperation[@lockAroundNakedNotifyWaits];      IF status # goodCompletion OR errorData.logAllOpsIfNotZero # 0 THEN {         errorData.last ¬ [            status: faceStatus, operation: doRequestTask­,            retries: retriedCount, ordinal: handle.drive];         BROADCAST errorData.error};      IF status # goodCompletion THEN         errorData.errorsSinceLastReport ¬ errorData.errorsSinceLastReport + 1      ELSE errorData.totalGoodCompletions ¬ errorData.totalGoodCompletions + 1;      errorData.totalRetries ¬         errorData.totalRetries + retriedCount;      countDone ¬ pOp.count - doRequestTask.count;      updatedAddress ¬ pOp.address ¬ doRequestTask.address;      IF status = diskChange THEN NoticeDiskChanged[handle];      END;      NoticeDiskChanged: INTERNAL PROC [handle: Handle] = {      drives[handle.drive].changeCount ¬ drives[handle.drive].changeCount + 1;      FloppyDiskFace.DiskChangeClear[GetDeviceHandle[handle]]};   NoticeDiskChangedDirectIO: INTERNAL PROC [      deviceHandle: FloppyDiskFace.DeviceHandle] = {      FOR i: CARDINAL IN [0..nDrives) DO        IF drives[i].faceDevice = deviceHandle THEN {	  drives[i].changeCount ¬ drives[i].changeCount + 1;	  FloppyDiskFace.DiskChangeClear[deviceHandle];	  EXIT};	ENDLOOP};   Pages: PROC [c: CARDINAL] RETURNS [CARDINAL] = INLINE {      RETURN[(c + Environment.wordsPerPage - 1) / Environment.wordsPerPage]};   ValidHandle: INTERNAL PROC [handle: Handle] RETURNS [valid: BOOLEAN] = {      RETURN[         handle.drive IN [0..nDrives)            AND handle.changeCount = drives[handle.drive].changeCount]};      ValidHandleWithLock: ENTRY PROC      [handle: Handle, ml: LONG POINTER TO MONITORLOCK] RETURNS [valid: BOOLEAN] = {      RETURN[         handle.drive IN [0..nDrives)            AND handle.changeCount = drives[handle.drive].changeCount]};	          -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- INITIALIZATION PROCS   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   RegisterDrives: PROC =      BEGIN      maxWordsPerTrack: CARDINAL = 4096;  -- of all densities, sector sizes      trackPagesForBuffer: CARDINAL = maxWordsPerTrack / Environment.wordsPerPage;      device: FloppyDiskFace.DeviceHandle ¬ FloppyDiskFace.nullDeviceHandle;      wakeupMask: WORD;            AllocIOCB: PROC [wds: CARDINAL] RETURNS [p: LONG POINTER] = {         status: Zone.Status;         gsp: Environment.Base RELATIVE POINTER;         IF wds = 0 THEN RETURN[NIL];         [gsp, status] ¬ ResidentHeap.MakeNode[	   n: wds, alignment: FloppyDiskFace.operationAlignment];         IF status # okay THEN ERROR FloppyIocbAllocError;         RETURN[@Environment.first64K[gsp]]};      [cv: nakedNotify, mask: wakeupMask] ¬ SpecialRuntime.AllocateNakedCondition[         ];      FloppyDiskFace.Initialize[         notify: wakeupMask,         initialAllocation: AllocIOCB[FloppyDiskFace.initialAllocationLength]];      THROUGH [0..maxDrives) DO         IF (device ¬ FloppyDiskFace.GetNextDevice[device]) = FloppyDiskFace.nullDeviceHandle            THEN EXIT;         FloppyDiskFace.DiskChangeClear[device];         drives[nDrives] ¬ [faceDevice: device, changeCount: 0];         FloppyDiskFace.InitializeCleanup[];         nDrives ¬ nDrives + 1;         [] ¬ FloppyDiskFace.SetContext[            device, [            protect: FALSE, format: IBM, density: single, sectorLength: 256]];         ENDLOOP;      IF nDrives # 0 THEN         BEGIN         Process.SetTimeout[            condition: nakedNotify, ticks: Process.MsecToTicks[1000]];	 Process.DisableAborts[nakedNotify];         doRequestTask ¬ AllocIOCB[FloppyDiskFace.operationBlockLength];         clientDataSpacePage ¬ StoragePrograms.AllocateVM[            trackPagesForBuffer + 1, hyperspace, Space.unknownUsage,            partiallyOrSometimesMapped];	 IF (clientDataSpacePage MOD 2 # 0) THEN clientDataSpacePage ¬ clientDataSpacePage + 1;         clientDataSpace ¬ [            Space.LongPointerFromPage[clientDataSpacePage], trackPagesForBuffer];         END      ELSE         BEGIN         SpecialRuntime.DeallocateNakedCondition[cv: nakedNotify];         nakedNotify ¬ NIL;         END;      END;   Start: PUBLIC PROC = {RemainingDrivers.Start[]};   RegisterDrives[];   END....LOG23-Oct-81 20:39:42		AWL         Trimmed log to Rubicon.  Modified for floppy's not supporting Pilot   physical volumes.  Modified FormatTrack and DoRequest to support   FormatTrack not taking a buffer as an argument. 2-Nov-81 16:12:19		FXH       Bug fixes; change to be independent of several Disk drivers interfaces. 23-Dec-82 11:34:18		AWL         Converted to Klamath. 6-Nov-84 10:49:01		EKN     Added SpecialFloppyChannel.ReadSectorsWithContext, WriteSectorsWithContext.   Fix AR 6396: Recover doesn't initialize okay.   Fix AR 6494: Fixed SubmitRequest to not let go of lock when waiting on    nakedNotify, by restructuring code to use SA800Lock and   lockAroundNakedNotifyWaits.   Fix AR 6501: DoRequest to get pageFaulting out of when it is holding a lock.   Added guarding of SV for nakedNotify in DeviceOperationCompleted to avoid   SV deadlock if in page fault handling path.   Fix AR 6561: DisableAborts on nakedNotify  4-Feb-85 15:39:45		EKN     Changed name of SA800Lock to contextLock.   Change SA800Face calls to FloppyDiskFace calls.   Prettied up code (change proc names, take out a couple of procsWithLocks)  4-Apr-85 10:05:56		EKN     DoRequestWithBuffer does a test on incrementDataPtr to determine how much to LongCopy. Avoids address fault when incrementDataPtr is FALSE. 26-Sep-85 18:23:56             ET   DoRequestWithBuffer needed ENABLE UNWIND to let go of bufferLock. AR 7790.17-Apr-86 17:17:48              CAJ   CompleteDirectIO: INTERNAL ¬ ENTRY. 5-Aug-86 19:14:44		ET   MDS relief: make those POINTERs to global variables LONG POINTERs to global variables.13-Apr-87 13:05:26		ET   Merge in Horizon work. (Implemented GetDeviceStatistics, Retention)15-Jun-87 19:49:16              RSV   Really implemented GetDeviceStatistics.17-Sep-87 20:04:18              RSV   Added NoticeDiskChangedDirectIO and call it from DoDirectIO. 8-Oct-87 12:02:31              RSV   Added EXIT to NoticeDiskChangedDirectIO (11948) and GetHandle now sets prevPriority before all possible uses (8706).  Also made GetDeviceHandle public.  maxDrives to 4.  Implement DoTapeDirectIO.10-Dec-87 11:10:07              RSV   Fixed GetDeviceStatistics to work with non-zero drives20-Jan-89 15:31:56		MS/TxH	Support 1024
-- Copyright (C) 1984, 1985, 1986, 1987, 1989  by Xerox Corporation. All rights reserved. -- ResMemMgr>MStoreImpl.mesa  22-Jan-89 17:24:07 by TxH **-- The procedure RecoverMStore may be invoked while a process is inside MStore's monitor lock (1) as a result of a process which is inside MStore's monitor lock hitting a breakpoint, or (2) by any other process deciding to go to the debugger.  To allow the first case, RecoverMStore does not enter the MStore monitor.  This implies that the monitor data which it uses be consistent any place in this program where breakpoints are allowed.  To handle the second case, interrupts are disabled over the same sections of code.  The monitor data used by RecoverMStore consists of realPageMin, realPageMax, and allocationMap, and the contents of the hardware page map.-- Note: Noframe allocations may be performed (e.g. no out-of-line procedures may be called) within any ENTRY procedures in this monitor, so that they may be called from the allocation fault handler.  If this rule were not followed, we could get an allocation fault when we held the monitor lock, thus making AllocateIfFree and Deallocate inaccessible to the allocation fault handler.  Please see comments in MStore.mesa and ResMemMgr.config.-- CURRENT LIMITATIONS: The present implementation assumes that real page numbers are less than 2**16 (i.e. max amount of real memory is 2**16 pages = 2**24 words = 16 megawords).-- REMEMBER: You should only use Worry-mode breakpoints within any of the routines in this program.-- Things to consider:--   1) Divide allocationMap into "segments"DIRECTORY  Boot USING [countGermVM, mdsiGerm, pageGerm],  Environment USING [    bitsPerWord, maxPagesInMDS, PageCount, PageFromLongPointer, PageNumber, PageOffset, wordsPerPage],  Frame USING [GetReturnFrame, SetReturnFrame],  Inline USING [BITAND, BITOR, COPY, LongCOPY],  MStore USING [Deallocate, IfReservedLow, Vow],  MStoreExtras USING [StatusGet], --**  PageMap USING [    ExchangeFlags, Flags, flagsClean, flagsNone, IsMapped, IsVacant,maskNone,    maskNotReadOnly, flagsVacant, GetState, RealPageNumber, SetMapFlags, State],  PilotSwitches USING [    stdDandelionMemorySize, PilotDomainA, tinyDandelionMemorySize],  PilotSwitchesExtra5 USING [    tinyDoveMemSizeTinyVMTinyDisplay, tinyDoveMemSizeTinyVMBigDisplay,    tinyDoveMemSizeMedVMTinyDisplay, tinyDoveMemSizeMedVMBigDisplay,    tinyDoveMemSizeBigVMTinyDisplay, tinyDoveMemSizeBigVMBigDisplay],  PilotSwitchesExtra6 USING [pcEmulationBank],  PrincOps USING [ControlLink, Port],  Process USING [DisableAborts, DisableTimeout, InitializeMonitor, Priority],  ProcessInternal USING [GetCurrent],  ProcessOperations USING [DisableInterrupts, EnableInterrupts, Enter, Exit],  ProcessPrioritiesExtras USING [priorityPageFaultHigh],  PSB USING [PDA],  RealMemory USING [allocMap, Count],  RealMemoryExtras USING [PCBank],  ResMemPerf USING [],  RuntimeInternal USING [Bug, WorryCallDebugger],  Space USING [LongPointerFromPage, unknownUsage, virtualMemory],  SpecialSpace USING [],  StartList USING [Entry],  StoragePrograms USING [    AllocateVM, countVM, EnumerateStartList, pilotType, startList, StartListProc],  System USING [switches],  VM USING [AddSub, DoneWithStateVector, GuardStateVector, Interval, nullInterval],  VMExtras USING [SwitchType];MStoreImpl: MONITOR LOCKS mStoreLock  IMPORTS    Frame, Inline, MStore, PageMap, Process, ProcessInternal, ProcessOperations,    RealMemory, RealMemoryExtras, RuntimeInternal, Space, StoragePrograms, System, VM  EXPORTS MStore, MStoreExtras--**--, SpecialSpace, StoragePrograms, ResMemPerf, VM  SHARES MStore, PageMap =  BEGIN    -- PC memory data.  -- the PC bank maximum size is defined by [PCstart..PCend).  PCstart: ShortRealPageNumber; --on a 64K boundary, past i/o page.  PCend: ShortRealPageNumber; --PCstart+128sufiBlock+640maxPCE    -- PC globals ~sigh~  PCactive: ShortRealPageNumber; -- the PC bank in use is defined by [PCstart..PCactive), initially empty.  PCMode: BOOLEAN ¬ FALSE; --TRUE when entering and inside PC emulation mode  peeCeeVMInterval: VM.Interval ¬ VM.nullInterval; -- invalid if PCMode = FALSE, set by MStoreEmulatePC.  peeCeeProblem: BOOLEAN; -- TRUE when all free memory is inside PC bank or "consecutive-pool" **  peeCeeLock: MONITORLOCK; -- guards notPCvmPageG inside RelocatePCMemory  notPCvmPageG: Environment.PageNumber; -- an intermediate vmPage...    -- Performance data (exported to ResMemPerf):  swapOutBursts: PUBLIC LONG CARDINAL ¬ 0;  -- Types and Constants:  ShortRealPageNumber: TYPE = CARDINAL;  -- will be LONG someday.  FreeInUse: TYPE = {free, inUse};  AllocDesc: TYPE = PACKED ARRAY [0..bitsPerWord) OF FreeInUse;  allAllocated, noneFree: AllocDesc = ALL[inUse];  flagsVacant: PageMap.Flags = PageMap.flagsVacant;  stdDandelionMemSize: Environment.PageCount =    -- realMemorySize on a standard 8010 Star workstation.    -- assumes all extra reserved real memory is used by Germ and resident code.    4*256  --256K words memory--      - 64 --Dandelion map-- ;  tinyDandelionMemSize: Environment.PageCount =    -- realMemorySize on a standard 192K NS server.    -- assumes all extra reserved real memory is used by Germ and resident code.    4*192  --192K words memory--      - 64 --Dandelion map-- ;  realMemorySize: PUBLIC --SpecialSpace.-- Environment.PageCount;    -- Simulate 640k bytes of Dove memory on a Dandelion  -- To simulate dove memory on a dandelion, the VMMap, the display,  -- and the ioRegion must be accounted for. Dove VMMap could be in   -- three sizes: 64, 128, 256 pages (unlike Dandelion which is only 64)  -- The dove display memory is 130 pages for a 15" display and  -- 242 pages for a 19" display. (Dandelion display takes 200 pages)  -- The ioRegion is 24 pages. (Dandelion io page takes 1 page)  -- The following calculations first take the amount of words of real memory  -- wanted to be simulated, subtract the Dove VMMap from it,   -- subtract the difference between Dandelion ioregion and Dove ioregion,  -- add the difference of the dove display size compared to the dandelion display size.  -- Note: the realMemoryCount returned by RealMemory.Count accounts for all  -- memory pages except the VMMap, so that's why it needs to be subtracted here.  tinyDoveMemSizeTinyVMTinyDisplaySize:Environment.PageCount = 320*4 - 64 - 23 + 70;  tinyDoveMemSizeTinyVMBigDisplaySize:Environment.PageCount = 320*4 - 64 - 23 - 42;  tinyDoveMemSizeMedVMTinyDisplaySize: Environment.PageCount = 320*4 - 128 - 23 + 70;  tinyDoveMemSizeMedVMBigDisplaySize: Environment.PageCount = 320*4 - 128 - 23 - 42;  tinyDoveMemSizeBigVMTinyDisplaySize:Environment.PageCount = 320*4 - 256 - 23 + 70;  tinyDoveMemSizeBigVMBigDisplaySize: Environment.PageCount = 320*4 - 256 - 23 - 42;    -- Monitor data:  mStoreLock: PUBLIC --MStore.-- MONITORLOCK;  -- (PRIVATE in interface)  -- allocationMap is logically => PACKED ARRAY RealPageNumber OF FreeInUse;  allocationMap: POINTER TO ARRAY OF AllocDesc ¬ LOOPHOLE[BASE[    RealMemory.allocMap]];  -- Logically, the real page number part of each entry in the hardware page map are part of the monitor data.  -- Bounds on in-use part of allocation map:  -- Assertion: all free real pages are IN [realPageMin..realPageMax].  realPageMin: ShortRealPageNumber;  realPageMax: ShortRealPageNumber;  -- MONITOR INVARIANTS:  -- The basic monitor invariants are:  --   (1) countFree >= countHeldBack  --   (2) countFree + countReserved >= reserveRequirement + countHeldBack.  -- Ordinary memory allocation must maintain (1) and (2).  -- Reserved memory allocation (i.e. SubtractReserved[doAnyway])  -- must only maintain (1).  -- Additionally, the variables countWanted and countWantedReserve communicate  -- the requirements of waiting processes to AwaitBelowThreshold, and cause  -- it to swap stuff out; the waiters will proceed when there is enough  -- free memory to allow them to maintain the above invariants.  -- The variable countPromised communicates to AwaitBelowThreshold  -- the memory that is "on the way".  reserveRequirement: Environment.PageCount ¬ 0;  -- Specifies the current size requirement for the reserved memory pool  countReserved: Environment.PageCount ¬ 0;  -- Specifies the current size of the reserved memory pool  countWanted: Environment.PageCount ¬ 0;  -- amount of memory requested due to allocates  countWantedReserve: Environment.PageCount ¬ 0;  -- amount of memory requested due to SubtractReserve requirements  countFree: Environment.PageCount ¬ 0;  countPromised: Environment.PageCount ¬ 0;  countThreshold: Environment.PageCount ¬ 0;  countHeldBack: Environment.PageCount ¬ 0;  -- for simulation of Dandelion memory size.    -- frequently used combinations of the above count globals:  OrdinaryMemoryNeeded: INTERNAL PROCEDURE RETURNS[LONG CARDINAL] = INLINE {    RETURN[ countWanted + countThreshold + countHeldBack ]};  OrdinaryMemoryAvailable: INTERNAL PROCEDURE RETURNS[LONG CARDINAL] = INLINE {    RETURN[ countFree + countPromised ]};  ReserveMemoryNeeded: INTERNAL PROCEDURE RETURNS[LONG CARDINAL] = INLINE {    RETURN[ countWantedReserve + reserveRequirement + countHeldBack ]};  ReserveMemoryAvailable: INTERNAL PROCEDURE RETURNS[LONG CARDINAL] = INLINE {    RETURN[ countFree + countReserved ]};  ReserveIsLow: INTERNAL PROCEDURE RETURNS[BOOLEAN] = INLINE {    RETURN[ ReserveMemoryAvailable[] < ReserveMemoryNeeded[] ]};  MemoryIsLow: INTERNAL PROCEDURE RETURNS[BOOLEAN] = INLINE {    RETURN[ countFree < OrdinaryMemoryNeeded[] OR ReserveIsLow[]]};  activeSOP: PROCESS ¬ NIL;  -- ID of the current SwapOutProcess. NIL if none.  moreNeeded: CONDITION;  -- NOTIFYed whenever more of some kind of memory is needed  moreAvailable: CONDITION;  -- BROADCASTed whenever more of some kind of memory has become available. We BROADCAST rather than NOTIFY since both Allocate and AddReservedRequirement may want to be awakened.  bitsPerWord: CARDINAL = Environment.bitsPerWord;  BugType: TYPE = {    allocateButAlreadyMapped, badAllocate, bogusRealPage, funnyCase,    negativeReserve, notEnoughPagesAllocated, peeCeeError, reclaimButDirty,    tooMuchRealMemory, unexpectedInUse, unimplementedStartListOptions,    consecutiveGet, consecutiveCheck, consecutiveFree--**--};-- ** set so that consecutive real block will not disturb processor memories(= ioregion, mapTable ...).  consecutiveRealLimit: CARDINAL = 64;-- ** the start and end address of contiguous real memory block(= page #).   consecutiveRealMemoryStart: CARDINAL; --  consecutiveRealMemoryEnd: CARDINAL;-- ** the interval [specialMemStart ... specialMemEnd] consists of 2 intervals  [consecutiveRealMemoryEnd..consecutiveRealMemoryStart] and [PCstart..PCend).  specialMemStart: CARDINAL;  specialMemEnd:   CARDINAL;-- **   ConsecutiveMap:  TYPE = ARRAY CARDINAL[0.. wEnd] OF AllocDesc;  consecutiveMap: ConsecutiveMap ¬ ALL[ALL[free]]; -- ** the virtual memory interval whose real is being allocated consecutively.  activeConsecutiveInterval: VM.Interval;  -- ** [consecutiveActiveStart..consecutiveActiveEnd] is the active consecutive real interval being allocated.  consecutiveActiveStart: CARDINAL;  consecutiveActiveEnd:   CARDINAL;-- ** constants for get-proc     wEnd: CARDINAL = consecutiveRealLimit/bitsPerWord;   bEnd: CARDINAL = consecutiveRealLimit MOD bitsPerWord;  --~~~~~~~~~~ Initialization:  InitializeMStore: PUBLIC --StoragePrograms.-- ENTRY PROCEDURE =    BEGIN    longRealMin, longRealMax, longPCstart, longPCend: PageMap.RealPageNumber;    Process.InitializeMonitor[@peeCeeLock]; -- for RelocatePCMemory temps    Process.DisableAborts[@moreNeeded];    Process.DisableAborts[@moreAvailable];    Process.DisableTimeout[@moreNeeded];    Process.DisableTimeout[@moreAvailable];    allocationMap[0] ¬ noneFree;    Inline.COPY[      from: @allocationMap[0], to: @allocationMap[1],      nwords: SIZE[WORD]*(LENGTH[RealMemory.allocMap] - 1)];    [count: realMemorySize, realPageMin: longRealMin, realPageMax: longRealMax] ¬      RealMemory.Count[];    IF longRealMax NOT IN ShortRealPageNumber THEN Bug[tooMuchRealMemory];    realPageMin ¬ ShortRealPageNumber[longRealMin];    realPageMax ¬ ShortRealPageNumber[longRealMax];        -- The Size And Location Of The PC Bank Are Set Here.    -- If there is a PC bank, we must ensure that PCstart = PCend = realPageMin.    [longPCstart, longPCend] ¬ RealMemoryExtras.PCBank[];    IF longPCstart = longPCend THEN PCstart ¬ PCend ¬ PCactive ¬ realPageMin    ELSE SELECT StoragePrograms.pilotType FROM       diagnosticPilot => PCstart ¬ PCend ¬ PCactive ¬ realPageMin;       utilityPilot =>	  SELECT System.switches[PilotSwitchesExtra6.pcEmulationBank] FROM	     up => PCstart ¬ PCend ¬ PCactive ¬ realPageMin;	     down =>		BEGIN		PCactive ¬ PCstart ¬ ShortRealPageNumber[longPCstart];		PCend ¬ ShortRealPageNumber[longPCend];		END;	     ENDCASE => Bug[funnyCase];       pilot =>	  SELECT System.switches[PilotSwitchesExtra6.pcEmulationBank] FROM	     down => PCstart ¬ PCend ¬ PCactive ¬ realPageMin;	     up =>		BEGIN		PCactive ¬ PCstart ¬ ShortRealPageNumber[longPCstart];		PCend ¬ ShortRealPageNumber[longPCend];		END;	     ENDCASE => Bug[funnyCase];       ENDCASE => Bug[funnyCase];        SELECT TRUE FROM      System.switches[PilotSwitches.tinyDandelionMemorySize] = down =>        BEGIN        IF realMemorySize > tinyDandelionMemSize THEN {          countHeldBack ¬ realMemorySize - tinyDandelionMemSize;          realMemorySize ¬ tinyDandelionMemSize}        END;      System.switches[PilotSwitches.stdDandelionMemorySize] = down =>        BEGIN        IF realMemorySize > stdDandelionMemSize THEN {          countHeldBack ¬ realMemorySize - stdDandelionMemSize;          realMemorySize ¬ stdDandelionMemSize}        END;      System.switches[PilotSwitchesExtra5.tinyDoveMemSizeTinyVMTinyDisplay] = down =>        BEGIN	IF realMemorySize > tinyDoveMemSizeTinyVMTinyDisplaySize THEN {          countHeldBack ¬ realMemorySize - tinyDoveMemSizeTinyVMTinyDisplaySize;          realMemorySize ¬ tinyDoveMemSizeTinyVMTinyDisplaySize}	END;      System.switches[PilotSwitchesExtra5.tinyDoveMemSizeTinyVMBigDisplay] = down =>        BEGIN	IF realMemorySize > tinyDoveMemSizeTinyVMBigDisplaySize THEN {          countHeldBack ¬ realMemorySize - tinyDoveMemSizeTinyVMBigDisplaySize;          realMemorySize ¬ tinyDoveMemSizeTinyVMBigDisplaySize}	END;      System.switches[PilotSwitchesExtra5.tinyDoveMemSizeMedVMTinyDisplay] = down =>        BEGIN	IF realMemorySize > tinyDoveMemSizeMedVMTinyDisplaySize THEN {          countHeldBack ¬ realMemorySize - tinyDoveMemSizeMedVMTinyDisplaySize;          realMemorySize ¬ tinyDoveMemSizeMedVMTinyDisplaySize}	END;      System.switches[PilotSwitchesExtra5.tinyDoveMemSizeMedVMBigDisplay] = down =>        BEGIN	IF realMemorySize > tinyDoveMemSizeMedVMBigDisplaySize THEN {          countHeldBack ¬ realMemorySize - tinyDoveMemSizeMedVMBigDisplaySize;          realMemorySize ¬ tinyDoveMemSizeMedVMBigDisplaySize}	END;      System.switches[PilotSwitchesExtra5.tinyDoveMemSizeBigVMTinyDisplay] = down =>        BEGIN	IF realMemorySize > tinyDoveMemSizeBigVMTinyDisplaySize THEN {          countHeldBack ¬ realMemorySize - tinyDoveMemSizeBigVMTinyDisplaySize;          realMemorySize ¬ tinyDoveMemSizeBigVMTinyDisplaySize}	END;      System.switches[PilotSwitchesExtra5.tinyDoveMemSizeBigVMBigDisplay] = down =>        BEGIN	IF realMemorySize > tinyDoveMemSizeBigVMBigDisplaySize THEN {          countHeldBack ¬ realMemorySize - tinyDoveMemSizeBigVMBigDisplaySize;          realMemorySize ¬ tinyDoveMemSizeBigVMBigDisplaySize}	END;      ENDCASE => countHeldBack ¬ 0;    -- **-- consecutive real memory block location depends on PC-bank location.  -- there are 2 cases. One case is consecutive block follows PC bank, -- another case is PC bank follows consecutive block.---- ((realPageMax - PCend) < consecutiveRealLimit) AND--   ((PCstart - (DIO.ioRegionPage + --                  DIO.ioRegionPageCount)) < consecutiveRealLimit))----  this means that there is not enough real memory.--  but the above case can not be found. In other words, consecutiveRealLimit--  must be set so that the above case will not be found.--       IF PCstart = PCend THEN {         consecutiveRealMemoryStart ¬ realPageMax - 1;	 specialMemEnd ¬ consecutiveRealMemoryStart + 1;	 specialMemStart ¬ specialMemEnd - consecutiveRealLimit}      ELSE {-- PCstart # PCend...there is a pc bank  	IF realPageMax >= PCend AND	  (realPageMax - PCend) >= consecutiveRealLimit THEN {	      consecutiveRealMemoryStart ¬ PCend + consecutiveRealLimit - 1;	      specialMemEnd ¬ consecutiveRealMemoryStart + 1;	      specialMemStart ¬ PCstart}	ELSE {consecutiveRealMemoryStart ¬ PCstart - 1;	      specialMemStart ¬ PCstart - consecutiveRealLimit;	      specialMemEnd ¬ PCend}};    activeConsecutiveInterval ¬ VM.nullInterval;         -- allocate coroutine frames; initialize PORTS.    [] ¬ InitializeAllocateIfFree[];    InitializeDeallocate[];    InitializeAddReservedInternal[];    [] ¬ InitializeSubtractReservedInternal[];        --allocate a temporary PC vm interval for RelocatePCMemory    notPCvmPageG ¬ StoragePrograms.AllocateVM[1, hyperspace,      Space.unknownUsage, partiallyOrSometimesMapped];    END;  --InitializeMStore--  UnusedRealMemory: PUBLIC --StoragePrograms.-- PROCEDURE [    interval: VM.Interval] = {DeallocateInternal[interval, notPromised]};  --~~~~~~~~~~ Implementation:    AddReservedInternal: PUBLIC --MStore PRIVATE-- PROCEDURE [    countAdded: Environment.PageCount];  -- an indirect control link to the PORT.      InitializeAddReservedInternal: INTERNAL PROCEDURE =    BEGIN        AwaitAddReservedInternalRequest: --RESPONDING-- PORT      RETURNS [countAdded: Environment.PageCount];     -- args/results match AddReservedInternal (but swapped).         --"arguments"    countAdded: Environment.PageCount;    AddReservedInternal ¬ LOOPHOLE[LONG[@AwaitAddReservedInternalRequest]];    -- Set my PORT call below to return to my caller.    LOOPHOLE[AwaitAddReservedInternalRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      countAdded ¬ AwaitAddReservedInternalRequest[];  -- (uninitialized warning ok)      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitAddReservedInternalRequest, PrincOps.Port].dest.frame];      countReserved ¬ countReserved + countAdded;      BROADCAST moreAvailable;      ENDLOOP; --DO FOREVER--    END; --AddReservedInternal--  AddReservedMStore: PUBLIC --StoragePrograms-- ENTRY PROCEDURE [      countAdded: Environment.PageCount] =     -- Note: In principle, AddReservedMStore should protectits state vector.    -- However, it is only used during Pilot initialization when a state vector deadlock is not possible (he said).    BEGIN    countReserved ¬ countReserved + countAdded;    BROADCAST moreAvailable;    END; --AddReservedMStore--  Allocate: PUBLIC --MStore.-- ENTRY PROCEDURE [    interval: VM.Interval, resident: BOOLEAN] =    BEGIN    --uses global peeCeeProblem.    countWanted ¬ countWanted + interval.count;      -- WHILE there are not enough free pages (just for me)..    WHILE countFree < interval.count+countHeldBack OR ReserveIsLow[] DO      NOTIFY moreNeeded; WAIT moreAvailable ENDLOOP;    peeCeeProblem ¬ TRUE; --loop startup value    WHILE peeCeeProblem DO -- ** until PC and "consecutive" is satisfied        -- (most likely, AllocateIfFreeInternal will turn off peeCeeProblem)      countAllocated: Environment.PageCount ¬ AllocateIfFreeInternal[        interval, resident].countAllocated;      IF countAllocated < interval.count THEN        BEGIN	IF peeCeeProblem THEN -- ** PC or "consecutive", or both is hoarding all free memory        {countWanted ¬ countWanted + (specialMemEnd - specialMemStart); --**	 NOTIFY moreNeeded; WAIT moreAvailable; --adjust countWanted to ignore PC	 peeCeeProblem ¬ TRUE; -- just in case someone changed it while we were WAITing.	 countWanted ¬ countWanted - (specialMemEnd - specialMemStart); --**	 interval.page ¬ interval.page + countAllocated; --adjust to unallocated interval	 interval.count ¬ interval.count - countAllocated}        ELSE Bug[notEnoughPagesAllocated];        END;      ENDLOOP; -- until PC is satisfied    countWanted ¬ countWanted - interval.count;    END;  --Allocate--  AllocateIfFreeInternal: PUBLIC --MStore PRIVATE-- PROCEDURE  [    interval: VM.Interval, resident: BOOLEAN]    RETURNS [countAllocated: Environment.PageCount];    -- Guaranteed not to do an ALLOC from the frame heap.  -- an indirect control link to the PORT.  InitializeAllocateIfFree: INTERNAL PROCEDURE[]    RETURNS [  --to match PORT args--      countAllocated: Environment.PageCount ¬ NULL] =    BEGIN        AwaitAllocateIfFreeRequest: --RESPONDING-- PORT [      countAllocated: Environment.PageCount] RETURNS [      interval: VM.Interval, resident: BOOLEAN];      -- args/results match AllocateIfFreeInternal (but swapped).        --uses global peeCeeProblem.    interval: VM.Interval;    resident: BOOLEAN;    w, b: CARDINAL;  -- allocationMap rover: word and bit number    pageMarker: LONG CARDINAL; --marker to stop the search after one pass thru mem.        AllocateIfFreeInternal ¬ LOOPHOLE[LONG[@AwaitAllocateIfFreeRequest]];    -- Set my PORT call below to return to my caller.    LOOPHOLE[AwaitAllocateIfFreeRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    w ¬ realPageMin/bitsPerWord;    b ¬ 0;  -- ok to check of a couple unnecessary pages at first        DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [interval, resident] ¬ AwaitAllocateIfFreeRequest[countAllocated];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitAllocateIfFreeRequest, PrincOps.Port].dest.frame];            countAllocated ¬ 0;      peeCeeProblem ¬ FALSE;      pageMarker ¬ w;      b ¬ 0;  -- begin searching at *beginning* of pageMarker!      IF resident THEN -- tippytoe around special memory(pc, consecutive) **        BEGIN	pageMarker ¬ specialMemStart/bitsPerWord; --**	IF specialMemEnd > realPageMax THEN -- ** (special case protection)	 {w ¬ realPageMin/bitsPerWord; b ¬ 0}	ELSE	 {w ¬ specialMemEnd/bitsPerWord; b ¬ specialMemEnd MOD bitsPerWord};	END;            WHILE interval.count > 0 DO  -- until count is allocated          quit: BOOLEAN ¬ FALSE;          	  IF allocationMap[w][b] # free THEN	    -- catch that first bit, which would otherwise be skipped since	    -- the next line bumps b (*this test is always a no-op for	    -- subsequent pages in this same interval*).	    BEGIN	    DO --for all memory              DO  -- Advance to next possible bit position                IF (b ¬ (b + 1) MOD bitsPerWord) = 0 THEN                  DO  -- Advance to next word with free bits                    w ¬                      IF w >= realPageMax/bitsPerWord THEN realPageMin/bitsPerWord                      ELSE w + 1; --(">" is redundant with the special protection above)		    IF w = pageMarker THEN -- all memory is InUse		      BEGIN		      IF resident <<AND (PeeCeeBankExists[]		            OR consecutiveRealLimit # 0) **>> THEN		         peeCeeProblem ¬ TRUE;		      GOTO quitEarly;		      END;                    IF allocationMap[w] ~= allAllocated THEN EXIT;                    ENDLOOP; -- Advance to next word                -- See if it is free:                IF allocationMap[w][b] = free THEN EXIT;                ENDLOOP; -- Advance to next bit	      GOTO continue;	      REPEAT	      quitEarly => quit ¬ TRUE;	      continue => NULL; --this is the normal "I found one" exit.	      ENDLOOP;  --for all memory	      END;	              IF quit THEN EXIT;          ProcessOperations.DisableInterrupts[]; -- for RecoverMStore...          -- DO NOT SET BREAKPOINTS IN THE FOLLOWING SECTION!          allocationMap[w][b] ¬ inUse;          -- Verify that page is not already mapped:          IF PageMap.IsMapped[interval.page] THEN Bug[allocateButAlreadyMapped];          PageMap.SetMapFlags[            virtual: interval.page, real: w*bitsPerWord + b,            flags: PageMap.flagsClean];          ProcessOperations.EnableInterrupts[];  -- Breakpoints allowed again.          countFree ¬ countFree - 1;          interval.page ¬ interval.page + 1;          interval.count ¬ interval.count - 1;	  countAllocated ¬ countAllocated + 1;          ENDLOOP;  -- until count is allocated	        NOTIFY moreNeeded;  -- maybe more needed.      ENDLOOP;  --FOREVER--    END;  --InitializeAllocateIfFree--  burstState: {burstInProgress, idle} ¬ idle;  AwaitBelowThreshold: PUBLIC --MStore.-- ENTRY PROCEDURE    RETURNS [countNeeded: Environment.PageCount] =    BEGIN    DO    --UNTIL more needed AND nobody else already trying to make more free.      ordinaryMemoryNeeded: LONG CARDINAL ¬ OrdinaryMemoryNeeded[];      ordinaryMemoryAvailable: LONG CARDINAL ¬ OrdinaryMemoryAvailable[];      reserveMemoryNeeded: LONG CARDINAL ¬ ReserveMemoryNeeded[];      reserveMemoryAvailable: LONG CARDINAL ¬ ReserveMemoryAvailable[];      countNeeded ¬ MAX[  --        -- Ordinary memory needed:        IF ordinaryMemoryNeeded <= ordinaryMemoryAvailable THEN 0        ELSE ordinaryMemoryNeeded - ordinaryMemoryAvailable,        -- Reserved memory needed:        IF reserveMemoryNeeded <= reserveMemoryAvailable THEN 0        ELSE reserveMemoryNeeded - reserveMemoryAvailable];      --UNTIL--      IF countNeeded > 0        AND  --          (activeSOP = ProcessInternal.GetCurrent[] OR activeSOP = NIL) THEN EXIT;      IF activeSOP = ProcessInternal.GetCurrent[] THEN  --        -- The designated swap out process is returning without doing a Promise.        activeSOP ¬ NIL;      IF countNeeded = 0 AND burstState = burstInProgress THEN {        swapOutBursts ¬ swapOutBursts + 1;  -- end of burst.        burstState ¬ idle};      WAIT moreNeeded;      ENDLOOP;    IF activeSOP = NIL THEN {  -- start of burst.      activeSOP ¬ ProcessInternal.GetCurrent[]; burstState ¬ burstInProgress};    END;  --AwaitBelowThreshold--  AdjustReservedRealMemory: PUBLIC --VM.-- ENTRY PROCEDURE [    count: Environment.PageCount, addSub: VM.AddSub] =    BEGIN    priorityPrev: Process.Priority ¬ VM.GuardStateVector[      ProcessPrioritiesExtras.priorityPageFaultHigh];    IF addSub = add THEN      BEGIN      countWantedReserve ¬ countWantedReserve + count;      -- WHILE the new reserve req. is more than is available..      WHILE ReserveIsLow[] DO        NOTIFY moreNeeded; WAIT moreAvailable ENDLOOP;      countWantedReserve ¬ countWantedReserve - count;      reserveRequirement ¬ reserveRequirement + count;      END    ELSE {  -- Decrease the requirement      IF count > reserveRequirement THEN Bug[negativeReserve];      reserveRequirement ¬ reserveRequirement - count;      BROADCAST moreAvailable};    VM.DoneWithStateVector[priorityPrev];    END;  --AdjustReservedRealMemory--    DeallocateInternal: PUBLIC --MStore PRIVATE-- PROCEDURE [    interval: VM.Interval, vow: MStore.Vow];  -- an indirect control link to the PORT is set in InitializeDeallocate.    InitializeDeallocate: INTERNAL PROCEDURE =    BEGIN        AwaitDeallocateRequest: --RESPONDING-- PORT      RETURNS [interval: VM.Interval, vow: MStore.Vow];    -- args/results match DeallocateInternal (but swapped).      interval: VM.Interval;    vow: MStore.Vow;    count: Environment.PageCount;    promised: BOOLEAN;    -- set my PORT call to return to my caller on call below:    DeallocateInternal ¬ LOOPHOLE[LONG[@AwaitDeallocateRequest]];    LOOPHOLE[AwaitDeallocateRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Await new request;  Process it;      [interval, vow] ¬ AwaitDeallocateRequest[];      Frame.SetReturnFrame[LOOPHOLE[AwaitDeallocateRequest, PrincOps.Port].dest.frame];  -- for debugger      promised ¬ (vow = promised);      count ¬ 0;      ProcessOperations.DisableInterrupts[];  -- maintain consistency for RecoverMStore      -- DO NOT SET BREAKPOINTS IN THE FOLLOWING SECTION!      FOR offset: Environment.PageOffset IN [0..interval.count) DO        state: PageMap.State;        real: PageMap.RealPageNumber;        [oldState: state, real: real] ¬ PageMap.ExchangeFlags[          virtual: interval.page + offset, newFlags: flagsVacant];	IF state.flags ~= flagsVacant THEN          BEGIN          w: CARDINAL = ShortRealPageNumber[real]/bitsPerWord;          bit: CARDINAL = ShortRealPageNumber[real] MOD bitsPerWord;          IF (ShortRealPageNumber[real] NOT IN [realPageMin..realPageMax])	    OR (allocationMap[w][bit] = free) THEN Bug[bogusRealPage];	  IF PCMode AND IsActivePeeCee[real] THEN { -- give the page to PCE.	    PageMap.SetMapFlags[              peeCeeVMInterval.page+(real-PCstart), real, PageMap.flagsClean];	    IF promised THEN {countPromised ¬ countPromised - 1; NOTIFY moreNeeded}}	  ELSE { --** give the page to active consecutive block	    IF activeConsecutiveInterval # VM.nullInterval AND	     --** it's a kind of "IsActiveConsecutiveRealInternal".              real IN [consecutiveActiveStart..consecutiveActiveEnd] THEN {	       PageMap.SetMapFlags[		activeConsecutiveInterval.page +		  (real-consecutiveActiveStart), real, PageMap.flagsClean];	      IF promised THEN {countPromised ¬ countPromised - 1; NOTIFY moreNeeded}}	    ELSE {allocationMap[w][bit] ¬ free; count ¬ count + 1}}; -- free the page.          END;        ENDLOOP;      ProcessOperations.EnableInterrupts[];  -- Breakpoints allowed again.      countFree ¬ countFree + count;      IF promised THEN countPromised ¬ countPromised - count;      BROADCAST moreAvailable;  -- (maybe more available)      ENDLOOP;    END;  --InitializeDeallocate--  DonateDedicatedRealMemory: PUBLIC --SpecialSpace.-- ENTRY PROCEDURE [    page: Environment.PageNumber, count: Environment.PageCount] =    BEGIN    FOR offset: Environment.PageOffset IN [0..count) DO      state: PageMap.State;      real: PageMap.RealPageNumber;      [state, real] ¬ PageMap.GetState[page + offset];      IF real NOT IN ShortRealPageNumber THEN Bug[tooMuchRealMemory];      IF state.flags ~= flagsVacant THEN {        realPageMin ¬ MIN[realPageMin, ShortRealPageNumber[real]];        realPageMax ¬ MAX[realPageMax, ShortRealPageNumber[real]]};      ENDLOOP;    DeallocateInternal[  -- (BROADCASTs moreAvailable)      [page: page, count: count], notPromised];    END;  Promise: PUBLIC --MStore.-- ENTRY PROCEDURE [count: Environment.PageCount] =    BEGIN    countPromised ¬ countPromised + count;    activeSOP ¬ NIL;  -- retire him since he'll be doing I/O for a while    NOTIFY moreNeeded;  -- (possibly more needed)    END;  FlagsAnd: PROCEDURE [flags1, flags2: PageMap.Flags] RETURNS [PageMap.Flags] =    LOOPHOLE[Inline.BITAND];  RelocateAdjustingFlags: PUBLIC --MStore.-- PROCEDURE [    interval: VM.Interval, pageDest: Environment.PageNumber,    flagsKeep, flagsAdd: PageMap.Flags]    RETURNS [flags: PageMap.Flags, anyVacant: BOOLEAN] =    -- See note in MStore    BEGIN    FlagsOr: PROCEDURE [flags1, flags2: PageMap.Flags] RETURNS [PageMap.Flags] =      LOOPHOLE[Inline.BITOR];    flagsNew: PageMap.Flags =  -- flags to set when page first examined.      (IF flagsKeep = PageMap.maskNone AND interval.page = pageDest THEN flagsAdd       ELSE flagsVacant);    flagsMax: PageMap.Flags ¬ PageMap.flagsNone;    stateCur: PageMap.State;    real: PageMap.RealPageNumber;    anyVacant ¬ FALSE;  -- no vacant pages yet..    FOR offset: Environment.PageOffset IN [0..interval.count) DO      ProcessOperations.DisableInterrupts[];  -- maintain consistency for RecoverMStore      -- DO NOT SET BREAKPOINTS IN THE FOLLOWING SECTION!      [oldState: stateCur, real: real] ¬ PageMap.ExchangeFlags[        virtual: interval.page + offset, newFlags: flagsNew];      IF stateCur.flags = flagsVacant THEN anyVacant ¬ TRUE      ELSE        BEGIN        IF flagsNew = flagsVacant THEN          PageMap.SetMapFlags[            virtual: pageDest + offset, real: real,            flags: FlagsOr[flagsAdd, FlagsAnd[flagsKeep, stateCur.flags]]];        flagsMax ¬ FlagsOr[flagsMax, stateCur.flags];        END;      ProcessOperations.EnableInterrupts[];  -- Breakpoints allowed again.      ENDLOOP;    flags ¬ flagsMax;    END;  --RelocateAdjustFlags--  SubtractReservedInternal: PUBLIC --MStore PRIVATE-- PROCEDURE [    countSubtracted: Environment.PageCount, ifReservedLow: MStore.IfReservedLow]    RETURNS [ok: BOOLEAN];  -- an indirect control link to the PORT.     InitializeSubtractReservedInternal: INTERNAL PROCEDURE RETURNS [ok: BOOLEAN] =    BEGIN        AwaitSubtractReservedInternalRequest: --RESPONDING-- PORT [ok: BOOLEAN] RETURNS [      countSubtracted: Environment.PageCount, ifReservedLow: MStore.IfReservedLow];      -- args/results match SubtractReservedInternal (but swapped).          --"arguments"    countSubtracted: Environment.PageCount;    ifReservedLow: MStore.IfReservedLow;    SubtractReservedInternal ¬ LOOPHOLE[LONG[@AwaitSubtractReservedInternalRequest]];    -- Set my PORT call below to return to my caller.    LOOPHOLE[AwaitSubtractReservedInternalRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return result;  Await new request;  Process it;      [countSubtracted, ifReservedLow] ¬ AwaitSubtractReservedInternalRequest[ok];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitSubtractReservedInternalRequest, PrincOps.Port].dest.frame];      BEGIN --scope of Finish--        countWantedReserve ¬ countWantedReserve + countSubtracted;        IF ReserveIsLow[] THEN          SELECT ifReservedLow FROM            doAnyway => NOTIFY moreNeeded;            returnIfLow => {NOTIFY moreNeeded; ok ¬ FALSE; GOTO Finish};            waitTillEnough =>              BEGIN              WHILE ReserveIsLow[] DO                NOTIFY moreNeeded; WAIT moreAvailable; ENDLOOP;              END;            ENDCASE => Bug[funnyCase];        IF countSubtracted > countReserved THEN Bug[negativeReserve];        countReserved ¬ countReserved - countSubtracted;        ok ¬ TRUE;        GOTO Finish;        EXITS Finish => countWantedReserve ¬ countWantedReserve - countSubtracted;	END; --scope of Finish--      ENDLOOP; --DO FOREVER--    END;  --SubtractReservedInternal--      RecoverMStore: PUBLIC --StoragePrograms.-- PROCEDURE =    BEGIN    -- DO NOT SET BREAKPOINTS IN THE FOLLOWING PROCEDURE!    -- Getting ready to go to the Debugger    vmPage: Environment.PageNumber ¬ Boot.pageGerm + Boot.countGermVM - 1;    -- (we don't put the real pages in the germ's vm)        FOR realPage: ShortRealPageNumber IN [realPageMin..realPageMax] DO      w: CARDINAL = realPage/bitsPerWord;      bit: CARDINAL = realPage MOD bitsPerWord;      IF allocationMap[w][bit] = free THEN        WHILE (vmPage ¬ vmPage + 1) < StoragePrograms.countVM DO  -- next vacant vm page          IF PageMap.IsVacant[vmPage] THEN {            PageMap.SetMapFlags[              virtual: vmPage, real: realPage, flags: PageMap.flagsClean];            EXIT};          REPEAT            FINISHED =>              -- Last part of real memory gets lost until bootbutton next pushed.	      -- This is only a problem if realMemorySize > virtualMemorySize-countGermVM.              RETURN;          ENDLOOP;      ENDLOOP;    END; --RecoverMStore--  SetFreeRealMemoryThreshold: PUBLIC --ResMemPerf.-- ENTRY PROCEDURE [    count: Environment.PageCount] RETURNS [oldCount: Environment.PageCount] =    BEGIN    oldCount ¬ countThreshold;    countThreshold ¬ count;    NOTIFY moreNeeded;  -- maybe more needed.    BROADCAST moreAvailable;  -- maybe more available.    END;  SetCountHeldBack: ENTRY PROCEDURE [newCountHeldBack: Environment.PageCount]    RETURNS [oldCountHeldBack: Environment.PageCount] =    -- Interpret-called from the Debugger only, used for performance tests.    BEGIN    countWantedAdditional: Environment.PageCount =  -- (avoiding underflow)      MAX[countHeldBack, newCountHeldBack] - countHeldBack;    oldCountHeldBack ¬ countHeldBack;    countWanted ¬ countWanted + countWantedAdditional;    -- Wait till all necessary swapping has completed:    WHILE MemoryIsLow[] DO      NOTIFY moreNeeded; WAIT moreAvailable ENDLOOP;    countWanted ¬ countWanted - countWantedAdditional;    countHeldBack ¬ newCountHeldBack;    END;  Bug: PROCEDURE [type: BugType] = INLINE {  -- MUST be inline!    RuntimeInternal.Bug[type]};              --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Pee Cee stuff follows!  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    RelocatePCMemory: PUBLIC --MStore.-- PROCEDURE [interval: VM.Interval] =    BEGIN    --globals: notPCvmPageG and peeCeeLock.    FOR pCvmPage: Environment.PageNumber IN      [interval.page..interval.page+interval.count) DO      pCFlags: PageMap.Flags; pCrealPage: PageMap.RealPageNumber;      notPCrealPage: PageMap.RealPageNumber;      [state:[flags:pCFlags], real:pCrealPage] ¬ PageMap.GetState[pCvmPage];      IF pCFlags # flagsVacant AND IsMaxPeeCee[pCrealPage] THEN          BEGIN -- the pCvmPage is in forbidden PC territory	  pCPtr, notPCPtr: LONG POINTER;	  -- LOCK up the global notPCvmPageG temp!          -- make vmPage point to newVMPage's real and newVMPage point to NIL.	  UNTIL ProcessOperations.Enter[@peeCeeLock] DO NULL ENDLOOP;          Allocate[[notPCvmPageG, 1], TRUE]; -- get non-PC real memory	  notPCrealPage ¬ PageMap.GetState[notPCvmPageG].real;	  notPCPtr ¬ Space.LongPointerFromPage[notPCvmPageG];	  pCPtr ¬ Space.LongPointerFromPage[pCvmPage];          ProcessOperations.DisableInterrupts[];	  -- DO NOT SET BREAKPOINTS IN THE FOLLOWING SECTION!	  Inline.LongCOPY[pCPtr, Environment.wordsPerPage, notPCPtr];	  PageMap.SetMapFlags[pCvmPage, notPCrealPage, pCFlags];	  PageMap.SetMapFlags[notPCvmPageG, pCrealPage, PageMap.flagsClean];	  ProcessOperations.EnableInterrupts[];  -- Breakpoints allowed again.	  MStore.Deallocate[[notPCvmPageG, 1], notPromised];	  ProcessOperations.Exit[@peeCeeLock];	  END; -- forbidden PC territory      ENDLOOP;    END; --RelocatePCMemory--      MStoreEmulatePC: PUBLIC --MStore.-- ENTRY PROCEDURE [    switch: VMExtras.SwitchType, interval: VM.Interval] =    -- called only from VMImpl.EmulatePC (further: first thing, too)!    BEGIN    -- sets globals PCMode and peeCeeVMInterval and PCactive.    realPage: ShortRealPageNumber;    vmPage: Environment.PageNumber;        SELECT switch FROM      on =>        BEGIN	IF PCMode = TRUE THEN	  BEGIN -- want to allocate a different sized PC bank interval.	  -- reallocate the old-interval (peeCeeVM) part of the new interval (interval).	  realPage ¬ PCstart;	  FOR offset: Environment.PageNumber IN [0..	     MIN[peeCeeVMInterval.count,interval.count]) DO	    oldVMPage: Environment.PageNumber ¬ peeCeeVMInterval.page + offset;	    vmPage ¬ interval.page + offset;	    ProcessOperations.DisableInterrupts[]; -- DO NOT SET BREAKPOINTS IN HERE!            [] ¬ PageMap.ExchangeFlags[ oldVMPage, flagsVacant ];	    PageMap.SetMapFlags[vmPage, realPage, PageMap.flagsClean];	    ProcessOperations.EnableInterrupts[]; --breakpoints allowed again.	    realPage ¬ realPage + 1;	    ENDLOOP;	  -- free up PC pages in old interval if the new interval is smaller	  FOR vmPage IN [peeCeeVMInterval.page+interval.count..	      peeCeeVMInterval.page+peeCeeVMInterval.count) DO	    real: PageMap.RealPageNumber;	    oldFlags: PageMap.Flags;	    ProcessOperations.DisableInterrupts[]; -- DO NOT SET BREAKPOINTS IN HERE!	    [oldState:[flags: oldFlags], real:real] ¬	      PageMap.ExchangeFlags[vmPage, flagsVacant];	    realPage ¬ CARDINAL[real];	    IF oldFlags = flagsVacant THEN Bug[peeCeeError];	    allocationMap[realPage/bitsPerWord][realPage MOD bitsPerWord] ¬ free;	    ProcessOperations.EnableInterrupts[]; --breakpoints allowed again.	    countFree ¬ countFree + 1;	    ENDLOOP;	  NOTIFY moreAvailable;	  END        ELSE	  PCMode ¬ TRUE; -- want to allocate a brand new PC bank interval.	PCactive ¬ PCstart + CARDINAL[interval.count];	IF PCactive > PCend OR interval.count = 0 THEN	   Bug[peeCeeError]; --interval too big.	peeCeeVMInterval ¬ interval; -- update old-interval to new.        [] ¬ GetFreeSpecialRealMemory[PCstart, interval.page, PCactive]; --**        END; --on--      off =>        BEGIN        FOR vmPage IN [peeCeeVMInterval.page..         peeCeeVMInterval.page+peeCeeVMInterval.count) DO	  realPage ¬ CARDINAL[PageMap.GetState[vmPage].real];	  IF PageMap.IsVacant[vmPage] THEN Bug[peeCeeError];          ProcessOperations.DisableInterrupts[]; -- DO NOT SET BREAKPOINTS IN HERE!	  allocationMap[realPage/bitsPerWord][realPage MOD bitsPerWord] ¬ free;          [] ¬ PageMap.ExchangeFlags[vmPage, flagsVacant];	  ProcessOperations.EnableInterrupts[]; --breakpoints allowed again.	  ENDLOOP;        countFree ¬ countFree + (PCactive - PCstart);	PCactive ¬ PCstart;	PCMode ¬ FALSE;        END; --off--      ENDCASE => Bug[funnyCase];    END; --MStoreEmulatePC--      IsPeeCee: PUBLIC --MStore.-- ENTRY PROCEDURE [realPage: PageMap.RealPageNumber]    RETURNS [BOOLEAN] = {RETURN IsActivePeeCee[realPage]};      IsActivePeeCee: PROCEDURE [realPage: PageMap.RealPageNumber]    RETURNS [BOOLEAN] = INLINE {RETURN[ realPage IN [PCstart..PCactive) ]};      IsMaxPeeCee: PROCEDURE [realPage: PageMap.RealPageNumber]    RETURNS [BOOLEAN] = INLINE {RETURN[ realPage IN [specialMemStart..specialMemEnd)]}; --**      PeeCeeBankExists: PROCEDURE RETURNS [BOOLEAN] = INLINE {RETURN[ PCstart # PCend ]};       InitializePCMemory: PUBLIC --StoragePrograms.--  ENTRY PROCEDURE =    BEGIN    -- the convention here for vmPage/realPage/flags/ptr variables are:    --   a ~pC~ prefix refers to a page allocated illegally in the PC bank;    --   a ~notPC~ prefix refers to a page allocated outside the PC bank.    --   middleMan is a transient allocated vmPage for swapping pC/notPC pages.    notPCvmPage: Environment.PageNumber ¬ 0;    pCvmPage: Environment.PageNumber;    middleMan: Environment.PageNumber;    p: PROCESS;    suicide: BOOLEAN ¬ FALSE;  -- termination conditions for FindSwitchable    suicideOK: BOOLEAN ¬ FALSE; -- FindSwitchable's request for suicide.    findSwappableDone: BOOLEAN ¬ FALSE; -- FALSE while still looking for swappable pages.    needSwappableNotPeeCee: CONDITION;    swappableNotPeeCeeAvailable: CONDITION;    ------------------------------------    --internal initialization procedures    ------------------------------------    FindSwitchable: ENTRY PROCEDURE =      BEGIN  -- this is running in parallel with SwitchPCMemory!      --uses notPCvmPage.      FindSwappable: INTERNAL StoragePrograms.StartListProc --[        --pEntry: LONG POINTER TO StartList.Entry]-- =        BEGIN          BEGIN --scope of FoundOne--          WITH pEntry SELECT FROM            space =>	      WITH type SELECT FROM	        empty => NULL;	        unitary =>	          IF StoragePrograms.startList[swapUnit].info.state = swappable      	            THEN GOTO FoundOne;	        family =>	          IF anySwappableChildren THEN	            {IF allSwappableChildren THEN GOTO FoundOne	             ELSE Bug[unimplementedStartListOptions]};	        ENDCASE => Bug[funnyCase]; --of space pEntry.type--	    swapUnit => NULL;            ENDCASE => Bug[funnyCase]; --of pEntry--          EXITS            FoundOne => -- give each notPCvmPage in the interval to ClearPCMemory.	      BEGIN	      int: space StartList.Entry ¬	        LOOPHOLE[pEntry­, space StartList.Entry];	      FOR index:Environment.PageNumber IN	          [int.vmpage..int.vmpage + int.pages) DO	        IF suicide THEN RETURN[done: TRUE]; -- termination clause	        IF PageMap.IsMapped[index] AND                  NOT IsMaxPeeCee[PageMap.GetState[index].real] THEN	          BEGIN		  UNTIL notPCvmPage = 0 DO		    WAIT needSwappableNotPeeCee;		    ENDLOOP;	           notPCvmPage ¬ index;	           NOTIFY swappableNotPeeCeeAvailable;		   END;	        ENDLOOP;	      END;	  END; --scope of FoundOne--        IF suicide THEN RETURN[done: TRUE]; -- termination clause        END; --FindSwappable--    --begin FindSwitchable code--      w,b: CARDINAL;      findSwappableDone ¬ FALSE;      StoragePrograms.EnumerateStartList[FindSwappable];      findSwappableDone ¬ TRUE;      UNTIL findSwitchableMode = freeOrSwappable DO        WAIT needSwappableNotPeeCee;	ENDLOOP;      UNTIL suicide DO             --FindFree!--        notPCrealPage: ShortRealPageNumber ¬ realPageMin-1;        UNTIL notPCrealPage = realPageMax DO	  IF notPCrealPage = specialMemStart-1 THEN notPCrealPage ¬ specialMemEnd --**	    ELSE notPCrealPage ¬ notPCrealPage + 1;	  w ¬ notPCrealPage/bitsPerWord; b ¬ notPCrealPage MOD bitsPerWord;	  IF allocationMap[w][b] = free THEN	    BEGIN	    UNTIL notPCvmPage = 0 DO	      WAIT needSwappableNotPeeCee;	      ENDLOOP;	    notPCvmPage ¬ pCvmPage; --(I need a vm allocation temporarily... and global pCvmPage is unused now)	    PageMap.SetMapFlags[notPCvmPage, notPCrealPage, PageMap.flagsClean];	    NOTIFY swappableNotPeeCeeAvailable;	    END;	  IF suicide THEN EXIT; -- termination clause	  ENDLOOP; --FOR notPCrealPage--	IF PageMap.IsMapped[notPCvmPage] THEN -- undo the temp vm allocation above...	  [] ¬ PageMap.ExchangeFlags[notPCvmPage, flagsVacant];	IF NOT suicide THEN	  Bug[peeCeeError]; --pCresident > notPCswappable + notPCfree.	ENDLOOP; --FindFree!--      NOTIFY swappableNotPeeCeeAvailable;      suicideOK ¬ TRUE; --it's okay to suicide now      END; --FindSwitchable--    ClearPCMemory: INTERNAL StoragePrograms.StartListProc --[      --pEntry: LONG POINTER TO StartList.Entry]-- =      BEGIN      WITH pEntry SELECT FROM        space =>          WITH type SELECT FROM	    empty => NULL;	    unitary =>	      IF StoragePrograms.startList[swapUnit].info.state = resident	        THEN GOTO FoundOne;	    family =>	      IF anyResidentChildren THEN		IF allResidentChildren THEN GO TO FoundOne	        ELSE Bug[unimplementedStartListOptions];	    ENDCASE => Bug[funnyCase]; --of space pEntry.type--        swapUnit => NULL;        ENDCASE => Bug[funnyCase]; --of pEntry--      EXITS        FoundOne => -- exchg the disallowed pCvmPage for an allowed notPCvmPage.	  BEGIN	  int: space StartList.Entry ¬ LOOPHOLE[pEntry­, space StartList.Entry];	  CheckPCMemory[[int.vmpage, int.pages]];	  END;      END; --ClearPCMemory--	    SwitchPCMemory: INTERNAL PROCEDURE [        pCvmPage: Environment.PageNumber, pCrealPage: PageMap.RealPageNumber,	notPCvmPageL: Environment.PageNumber] =        BEGIN -- this is running in parallel with FindSwappable!	  --uses notPCvmPage.	  notPCrealPage: PageMap.RealPageNumber;	  pCFlags, notPCFlags: PageMap.Flags; -- original flags	  -- (remember to turn off any readOnly flag so's to be able to switch!)--	  pCPtr, notPCPtr: LONG POINTER;	  pCmap, notPCmap: FreeInUse; -- allocation map status	  middleManPtr: LONG POINTER ¬ Space.LongPointerFromPage[middleMan];	  middleManReal: PageMap.RealPageNumber;	  pCWord, pCBit, notPCWord, notPCBit: CARDINAL;	 	  ProcessOperations.DisableInterrupts[];	  -- keep those map flags and data from changing!	  -- DO NOT SET BREAKPOINTS IN THE FOLLOWING SECTION OF CODE!	  	  --get the flags, ptr, map of the {resident|free} disallowed page in the PC bank	  pCFlags ¬ PageMap.GetState[pCvmPage].state.flags;	  PageMap.SetMapFlags[	    pCvmPage, pCrealPage, FlagsAnd[pCFlags, PageMap.maskNotReadOnly]];	  pCPtr ¬ Space.LongPointerFromPage[pCvmPage];	          pCWord ¬ CARDINAL[pCrealPage]/bitsPerWord;	          pCBit ¬ CARDINAL[pCrealPage] MOD bitsPerWord;	          pCmap ¬ allocationMap[pCWord][pCBit];	          allocationMap[pCWord][pCBit] ¬ inUse; -- so middleMan doesn't grab it	 	  --get the flags, realPage, ptr, map  for a page NOT in PC bank	  [state: [flags: notPCFlags], real: notPCrealPage] ¬	    PageMap.GetState[notPCvmPageL];	  PageMap.SetMapFlags[	    notPCvmPageL, notPCrealPage, FlagsAnd[notPCFlags, PageMap.maskNotReadOnly]];	  notPCPtr ¬ Space.LongPointerFromPage[notPCvmPageL];	          notPCWord ¬ CARDINAL[notPCrealPage]/bitsPerWord;	          notPCBit ¬ CARDINAL[notPCrealPage] MOD bitsPerWord;	          notPCmap ¬ allocationMap[notPCWord][notPCBit];	          allocationMap[notPCWord][notPCBit] ¬ inUse; --keep away middleMan!	 	  --swap 'em!	  IF AllocateIfFreeInternal[[middleMan,1], FALSE].countAllocated ~= 1	    THEN Bug[badAllocate];	  middleManReal ¬ PageMap.GetState[middleMan].real;	  -- The Following Exchange Code Must Preserve The Original Contents Behind pCvmPage And notPCvmPageL!!	  -- (if this is not strictly followed, there is a risk of seppuku if the contents are this-code or this-frame).	  Inline.LongCOPY[notPCPtr, Environment.wordsPerPage, middleManPtr];	  [] ¬ PageMap.ExchangeFlags[middleMan, flagsVacant];	  PageMap.SetMapFlags[notPCvmPageL, middleManReal, PageMap.flagsClean];	  PageMap.SetMapFlags[middleMan, notPCrealPage, PageMap.flagsClean];	  Inline.LongCOPY[pCPtr, Environment.wordsPerPage, middleManPtr];	  [] ¬ PageMap.ExchangeFlags[middleMan, flagsVacant];	  PageMap.SetMapFlags[pCvmPage, notPCrealPage, pCFlags];	  PageMap.SetMapFlags[middleMan, pCrealPage, PageMap.flagsClean];	  Inline.LongCOPY[notPCPtr, Environment.wordsPerPage, middleManPtr];	  [] ¬ PageMap.ExchangeFlags[middleMan, flagsVacant];	  PageMap.SetMapFlags[notPCvmPageL, pCrealPage, notPCFlags];	  PageMap.SetMapFlags[middleMan, middleManReal, PageMap.flagsClean];	  DeallocateInternal[[middleMan,1], notPromised];	  allocationMap[pCWord][pCBit] ¬ notPCmap;	  allocationMap[notPCWord][notPCBit] ¬ pCmap;	  IF pCmap = free THEN [] ¬ PageMap.ExchangeFlags[pCvmPage, flagsVacant];	  ProcessOperations.EnableInterrupts[];	  -- INTERRUPTS PERMITTED AGAIN	END; --SwitchPCMemory--        CheckPCMemory: INTERNAL PROCEDURE [int: VM.Interval] =    -- just a quickie routine that runs through int looking for and    -- switching out any pages mapped to the PC bank.      BEGIN      	FOR pCvmPage: Environment.PageNumber IN [int.page..int.page + int.count) DO	  pCrealPage: PageMap.RealPageNumber ¬ PageMap.GetState[pCvmPage].real;	  -- WHY is pCvmPage potentially vacant at this point????!!!!	  IF PageMap.IsVacant[pCvmPage] THEN LOOP; -- problem w/ Processes...	  IF IsMaxPeeCee[pCrealPage] THEN	    BEGIN	    WHILE notPCvmPage = 0 DO	      NOTIFY needSwappableNotPeeCee;	      WAIT swappableNotPeeCeeAvailable;	      ENDLOOP;	    SwitchPCMemory[pCvmPage, pCrealPage, notPCvmPage];	    notPCvmPage ¬ 0;	    END;	  ENDLOOP;	END; -- CheckPCMemory --    ------------------------------------    --main initialization procedure body    ------------------------------------    findSwitchableMode: {swappableOnly, freeOrSwappable} ¬ swappableOnly;    pCvmPage ¬ StoragePrograms.AllocateVM[  -- preallocate a vmPage for a free pCrealPage      1, hyperspace, Space.unknownUsage, partiallyOrSometimesMapped];    middleMan ¬ StoragePrograms.AllocateVM[  -- preallocate intermediate vmPage      1, hyperspace, Space.unknownUsage, partiallyOrSometimesMapped];    --start up the FindSwappable coprocess.    p ¬ FORK FindSwitchable[];        --switch free PC pages for swappable non-PC pages    FOR pCrealPage: ShortRealPageNumber IN [specialMemStart..specialMemEnd) DO --**      IF allocationMap[pCrealPage/bitsPerWord][pCrealPage MOD bitsPerWord] = free THEN        BEGIN -- exchg the disallowed pCrealPage for an allowed notPCrealPage.        IF findSwappableDone THEN GO TO noMoreSwappablePages;        PageMap.SetMapFlags[pCvmPage,pCrealPage,PageMap.flagsClean];	--those flagsClean get returned to flagsVacant inside SwitchPCMemory if	--pCrealPage's allocMap entry is free (which it is in this case!).	--get the notPCvmPage for a page NOT in PC bank	  WHILE notPCvmPage = 0 DO	    NOTIFY needSwappableNotPeeCee;	    WAIT swappableNotPeeCeeAvailable;	    IF findSwappableDone THEN GO TO noMoreSwappablePages;	    ENDLOOP;	SwitchPCMemory[pCvmPage, pCrealPage, notPCvmPage];	notPCvmPage ¬ 0;        END;      REPEAT noMoreSwappablePages =>      		--pCvmPage was free to start with, and it must be guarenteed		-- free at the end, for consistency.  sigh!		[] ¬ PageMap.ExchangeFlags[pCvmPage, PageMap.flagsVacant];      ENDLOOP;              --wake up FindSwitchable if it's waiting with a free page...    findSwitchableMode ¬ freeOrSwappable;    NOTIFY needSwappableNotPeeCee; --           --switch PDA pages mapped to the PC bank for swappable non-PC pages    CheckPCMemory[[Environment.PageFromLongPointer[PSB.PDA], Environment.maxPagesInMDS]];        --switch germ pages mapped to the PC bank for swappable non-PC pages    CheckPCMemory[[Boot.mdsiGerm+Boot.pageGerm, Boot.countGermVM]];          --switch resident PC pages for swappable non-PC pages    StoragePrograms.EnumerateStartList[ClearPCMemory];        -- finish up the FindSwitchable coprocess.    suicide ¬ TRUE;    UNTIL suicideOK  -- until for FindSwitchable to be ready to die      -- (the "wait" is in case FindSwitchable never got a chance to start...)      DO NOTIFY needSwappableNotPeeCee; WAIT swappableNotPeeCeeAvailable; ENDLOOP;    JOIN p;    END; --InitializePCMemory--            CheckMap: ENTRY PROCEDURE =    BEGIN    -- This is a trouble-shoooting routine to be used via debugger interpret calls.    localCount: LONG CARDINAL ¬ 0;        -- SHORTCUT/WASTEFUL Check for double mapping.    -- Need to declare global localMap: PACKED ARRAY [0..7777B] OF BOOLEAN;    --FOR index: CARDINAL IN [0..realPageMax] DO    --  localMap[index] ¬ FALSE;  ++ zero out local map.    --  ENDLOOP;    --FOR vmPage: Environment.PageNumber IN [0..Space.virtualMemory.count) DO    --  realPage: CARDINAL ¬ CARDINAL[PageMap.GetState[vmPage].real];    --  IF PageMap.IsVacant[vmPage] THEN LOOP;    --  IF NOT (realPage IN [realPageMin..realPageMax])    --     AND NOT (realPage IN [0..400b) ++ display bank ++ ) THEN    --    {RuntimeInternal.WorryCallDebugger["bad PageMap."G]; LOOP};    --  IF localMap[realPage] = TRUE THEN    --    RuntimeInternal.WorryCallDebugger["double mapped real page."G];    --  localMap[realPage] ¬ TRUE;    --  ENDLOOP;        -- Check for double mapping.    FOR realPage: ShortRealPageNumber IN [realPageMin..realPageMax) DO      thisReal: ShortRealPageNumber ¬ 0; -- Search Main Memory!      thisVmPage: Environment.PageNumber;      FOR vmPage: Environment.PageNumber IN [0..Space.virtualMemory.count) DO        IF PageMap.IsVacant[vmPage] THEN LOOP;	IF CARDINAL[PageMap.GetState[vmPage].real] = realPage THEN {	  IF thisReal # 0 THEN	    RuntimeInternal.WorryCallDebugger["double mapped real page."G];	  thisReal ¬ realPage;	  thisVmPage ¬ vmPage;}        ENDLOOP;      IF allocationMap[CARDINAL[realPage/bitsPerWord]][CARDINAL[realPage MOD bitsPerWord]] = inUse AND thisReal = 0 THEN        RuntimeInternal.WorryCallDebugger["an inUse page is not pointed to."G];      IF allocationMap[CARDINAL[realPage/bitsPerWord]][CARDINAL[realPage MOD bitsPerWord]] = free AND thisReal # 0 THEN        RuntimeInternal.WorryCallDebugger["a free page is pointed to."G];      ENDLOOP;          FOR realPage: ShortRealPageNumber IN [1..400b) DO      thisReal: ShortRealPageNumber ¬ 0; -- Search Display Memory!      thisVmPage: Environment.PageNumber;      FOR vmPage: Environment.PageNumber IN [0..Space.virtualMemory.count) DO        IF PageMap.IsVacant[vmPage] THEN LOOP;	IF CARDINAL[PageMap.GetState[vmPage].real] = realPage THEN {	  IF thisReal # 0 THEN	    RuntimeInternal.WorryCallDebugger["double mapped real page."G];	  thisReal ¬ realPage; 	  thisVmPage ¬ vmPage;}       ENDLOOP;      IF thisReal = 0 THEN  -- real pages 1 to 377B cannot be free in current implementation        RuntimeInternal.WorryCallDebugger["an inUse page is not pointed to."G];      ENDLOOP;        -- Check countFree accuracy.    FOR w: CARDINAL IN [realPageMin/bitsPerWord..realPageMax/bitsPerWord] DO      IF allocationMap[w] = allAllocated THEN LOOP;      FOR b: CARDINAL IN [0..bitsPerWord) DO        IF allocationMap[w][b] = free THEN 	  localCount ¬ localCount + 1;	ENDLOOP;      ENDLOOP;    IF localCount # countFree THEN      RuntimeInternal.WorryCallDebugger["bad countFree in MStoreImpl."];            -- Check PC memory is on properly.    IF PCMode THEN      FOR offset: CARDINAL IN [0..CARDINAL[peeCeeVMInterval.count]) DO        vmPage: Environment.PageNumber ¬ peeCeeVMInterval.page+offset;	realPage: CARDINAL ¬ CARDINAL[PageMap.GetState[vmPage].real];        IF realPage # PCstart+offset THEN	  RuntimeInternal.WorryCallDebugger["bad PC bank."G];	ENDLOOP;    IF PCMode THEN      FOR vmPage: Environment.PageNumber IN [0..Space.virtualMemory.count) DO        realPage: CARDINAL ¬ CARDINAL[PageMap.GetState[vmPage].real];      IF PageMap.IsVacant[vmPage] THEN LOOP;      IF IsActivePeeCee[realPage] AND         NOT (vmPage IN [peeCeeVMInterval.page..peeCeeVMInterval.page+peeCeeVMInterval.count))	 THEN RuntimeInternal.WorryCallDebugger["bad PC bank."G];      ENDLOOP;        END;  -- CheckMap --       -- *******************************************     GetConsecutiveRealMemory:-- *******************************************     PUBLIC --MStoreExtras.-- ENTRY PROCEDURE [interval: VM.Interval]                            RETURNS [status: MStoreExtras.StatusGet] =-- created from MStoreEmulatePC.			           BEGIN<< Notes:   1. The argment "interval" must not be nullInterval. 2. The case that the "interval" already backed by consecutive memories makes things confused.>>     skipped: BOOLEAN;  count: CARDINAL;  w, b: CARDINAL;-- Is somebody getting consecutive real pages ?       IF activeConsecutiveInterval # VM.nullInterval THEN Bug[consecutiveGet];<< find a hole. If no one found, then return with the status "cannot".   	 [0123 4567 89AB CDEF]                 [0123 4567 89AB CDEF]	  aaaa bbbb cccc dddd                   aaaa bbbb cccc dddd	      .......                               .......	  aaaa bbbb cccc dddd                   aaaa bbbb xxxx yyyy (wEnd)-->­ (bEnd=0)                  (wEnd)--> cccc dd­(bEnd=6)      >>       count ¬ CARDINAL[interval.count];  w ¬ b ¬ LAST[CARDINAL];    WHILE count > 0 DO    IF (b ¬ (b + 1) MOD bitsPerWord) = 0 THEN {      DO        w ¬ w + 1;	IF w > wEnd OR (w = wEnd AND bEnd = 0) THEN RETURN[cannot];	IF consecutiveMap[w] ~= allAllocated THEN EXIT;	count ¬ CARDINAL[interval.count];      ENDLOOP}    ELSE       IF w = wEnd AND b = bEnd THEN RETURN[cannot];    IF consecutiveMap[w][b] = free THEN count ¬ count - 1    ELSE count ¬ CARDINAL[interval.count];  ENDLOOP;<< As for the correspondence of consecutiveMap[w][b] to the actula real page,              [0][0] => consecutiveRealMemoryStart             [0][1] => consecutiveRealMemoryStart - 1                  .......       [wEnd][bEnd] => consecutiveRealMemoryEnd       ## consecutive pool = [consecutiveRealMemoryEnd..consecutiveRealMemoryStart]    Make the given interval active by setting "activeConsecutiveInterval", "consecutiveActiveStart" and "consecutiveActiveEnd". A [consecutiveActiveStart .. consecutiveActiveEnd] is the expected real pages interval for the given interval. "activeConsecutiveInterval" is like "peeCeeVMInterval". "consecutiveActive" is like "PCactive".>>    activeConsecutiveInterval ¬ interval;   consecutiveActiveStart ¬ consecutiveRealMemoryStart -                                              (bitsPerWord*w + b);   consecutiveActiveEnd ¬ consecutiveActiveStart +                                              CARDINAL[interval.count] - 1;     -- deallocate current all real pages. Note that interval is resident.    DeallocateInternal[interval, notPromised];-- allocate explicitly only if the corresponding consecutive real page is free.    skipped ¬ GetFreeSpecialRealMemory[      consecutiveActiveStart, interval.page, consecutiveActiveEnd + 1];        IF skipped THEN RETURN[partially] -- If passCase = false = (all alocated), CheckConsecutiveInterval will not be called.Update variables here.    ELSE {     UpdateConsecutiveMap[       ShortRealPageNumber[consecutiveRealMemoryStart - consecutiveActiveEnd],       CARDINAL[interval.count], inUse];     activeConsecutiveInterval ¬ VM.nullInterval;     RETURN[all]};   END; --GetConsecutiveRealMemory--    -- *******************************************     CheckOrSweapConsecutiveInterval:-- *******************************************     PUBLIC --MStore.-- ENTRY PROCEDURE [interval: VM.Interval, sweap: BOOLEAN]                              RETURNS [BOOLEAN] =   BEGIN      realPage, expectedRealPage: PageMap.RealPageNumber;   mapFlags: PageMap.Flags;         IF activeConsecutiveInterval = VM.nullInterval THEN                              Bug[consecutiveCheck];-- In case of sweap, clear activeConsecutiveInterval first, since for deallocation.--    IF sweap THEN activeConsecutiveInterval ¬ VM.nullInterval;   -- "consecutiveActiveEnd" is the consecutive real page of the last page of the given interval.--      expectedRealPage ¬ consecutiveActiveEnd;      FOR page: Environment.PageNumber     DECREASING IN [interval.page..interval.page+interval.count) DO     [state: [flags: mapFlags], real: realPage] ¬ PageMap.GetState[page];-- Check map flags.     IF mapFlags = PageMap.flagsVacant THEN        IF NOT sweap THEN RETURN[FALSE];-- Check real page.     IF ShortRealPageNumber[realPage] # expectedRealPage THEN {       IF NOT sweap THEN RETURN[FALSE]}     ELSE -- realPage = expectedRealPage       IF sweap THEN DeallocateInternal[[page, 1], notPromised];     expectedRealPage ¬ expectedRealPage - 1;   ENDLOOP; -- We have confirmed that all pages of the given interval is backed by the expected consecutive real pages. Update variables.--   IF NOT sweap THEN {     UpdateConsecutiveMap[       ShortRealPageNumber[consecutiveRealMemoryStart - consecutiveActiveEnd],       CARDINAL[interval.count], inUse];     activeConsecutiveInterval ¬ VM.nullInterval};   RETURN[TRUE];   END; --CheckConsecutiveInterval---- *******************************************     FreeConsecutiveRealMemory:-- *******************************************     PUBLIC --MStoreExtras-- ENTRY PROC [interval: VM.Interval] =       BEGIN   << Notes:   1. The argment "interval" must not be nullInterval. 2. The "interval" must have consecutive real pages. >>   realPage: PageMap.RealPageNumber;-- Impossible case.     IF activeConsecutiveInterval # VM.nullInterval THEN Bug[consecutiveFree];-- maintain consecutiveMap !   [state:  , real: realPage] ¬       PageMap.GetState[(interval.page + interval.count - 1)];   UpdateConsecutiveMap[       ShortRealPageNumber[consecutiveRealMemoryStart - realPage],       CARDINAL[interval.count], free];    		    -- Deallocation with DeallocateInternal--		       DeallocateInternal[interval, notPromised];   END; --FreeConsecutiveReal--   -- *******************************************         GetFreeSpecialRealMemory:-- *******************************************    INTERNAL PROCEDURE [realPage: ShortRealPageNumber,             vmPage: Environment.PageNumber, limit: ShortRealPageNumber]	   RETURNS [skipped: BOOLEAN ¬ FALSE] =  BEGIN    startRM: ShortRealPageNumber ¬ realPage;  startVM: Environment.PageNumber ¬ vmPage;    WHILE realPage < limit DO --for every page    w: CARDINAL ¬ realPage/bitsPerWord;    b: CARDINAL ¬ realPage MOD bitsPerWord;    IF allocationMap[w][b] = free THEN {      countWanted ¬ countWanted + 1;      IF MemoryIsLow[] THEN	 BEGIN	 WHILE MemoryIsLow[] DO	   NOTIFY moreNeeded; WAIT moreAvailable; ENDLOOP;	 realPage ¬ startRM; --restart the search at the top...	 vmPage ¬ startVM;	 countWanted ¬ countWanted - 1;	 LOOP; --restart the outer loop to catch any newly freed pages...	 END;      -- It's okay to eat up this free page:      ProcessOperations.DisableInterrupts[]; -- DO NOT SET BREAKPOINTS IN HERE!      allocationMap[w][b] ¬ inUse;      PageMap.SetMapFlags[vmPage, realPage, PageMap.flagsClean];      ProcessOperations.EnableInterrupts[]; --breakpoints allowed again.      countWanted ¬ countWanted - 1;      countFree ¬ countFree - 1;      NOTIFY moreNeeded}  --just in case    ELSE skipped ¬ TRUE;    vmPage ¬ vmPage + 1;    realPage ¬ realPage + 1;    ENDLOOP; --for every page  END; --GetFreeSpecialRealMemory--         -- *******************************************             UpdateConsecutiveMap:-- *******************************************    PROCEDURE [realPage: ShortRealPageNumber, count: CARDINAL,             newState: FreeInUse] =     BEGIN  w, b: CARDINAL;    w ¬ realPage/bitsPerWord;  b ¬ realPage MOD bitsPerWord;  UNTIL count = 0 DO    consecutiveMap[w][b] ¬ newState;    IF (b ¬ (b + 1) MOD bitsPerWord) = 0 THEN w ¬ w + 1;    count ¬ count - 1;  ENDLOOP;  END; --UpdateConsecutiveMap---- *******************************************     IsActiveConsecutiveReal:-- *******************************************     PUBLIC --MStoreExtras.-- ENTRY PROC [realPage: PageMap.RealPageNumber]                                RETURNS [BOOLEAN] = {   RETURN[ShortRealPageNumber[realPage] IN                    [consecutiveActiveStart..consecutiveActiveEnd]]};                  END.LOG	(For earlier entries, see Mesa 8.0 archive version)28-Jul-82 17:21:56   JXP      Modify for Klamath. Change BROADCAST's on moreNeeded to NOTIFY's to   work with multiple SwapOutProcesses. Add AddReserved, SubtractReserved,   SubtractReservedOrReclaim, ChangeReservedRequirement.15-Oct-82 16:40:32   WDK        Added perf counters. Clean up. Add AddReservedMStore.25-Oct-82 11:34:50   WDK        Made compatible with new PageMap.30-Nov-82 11:42:10   WDK        ChangeReservedRequirement renamed to AdjustReservedRealMemory. Export to ResMemPerf. Relocate renamed to RelocateAdjustFlags due to [censored] export conflict. AwaitBelowThreshold was returning negative count. Add smallDandelionMemorySize. Allocate must wait if reserved low. SubtractReserved[doAnyway] must NOTIFY moreNeeded.22-Dec-82 11:56:47   AWL         Export DonateDedicatedRealMemory correctly. 9-Mar-83  9:05:30   WDK        Bug must be inline. Ditched Inline.LowHalf's.22-Mar-83 10:15:18   WDK        Make compatible with new PilotSwitches.31-Mar-83 17:26:59   WDK        add check for negative reserve. 2-May-83 15:55:50   WDK        Make compatible with new MStore.12-Jul-83 16:42:49   JXP   	Fix up ports. 7-Oct-83 11:14:29   WDK        SetCountHeldBack must wait till swapping complete before changing countHeldBack.24-Feb-84 16:30:14   AWL         SubtractReserved: for local correctness, it should NOTIFY moreNeeded even if the client said to returnIfLow.24-Jul-84 17:22:10   KEK       twiddle AllocateIfFree and Deallocate to talk to the VARs in the interface.  Make SubtractReservedInternal and AddReservedInternal be coroutines. remove memType stuff from Deallocate (is done in CheckInSwapUnits, now). Toss SubtractReservedOrReclaim!!11-Sep-84 12:26:01   KEK       Add PC memory stuff28-Sep-84 13:43:52   KEK      fix infinite loop associated w/ PC stuff, in AllocateIfFree.  Rearrange SwitchPC code to delicately handle local frame. Other PC bug fixes (sigh).  Add IsPeeCee[], modify Deallocate to that it doesn't drop a PCpage on the floor in PCMode.12-Dec-84 16:00:54	KEK    	commonized some common code.29-Jan-85 23:47:06	KEK     added the code involving PCactive (to be able to change the size of the PC bank w/o affecting the contents of the previous PC bank.  It's trick: you can do this while mapping the entire thing to a different vm interval.  Also added IsActivePeeCee/IsMaxPeeCee, removed IsPeeCeeInternal. 7-Feb-85 19:07:17	KEK     added "b ¬ 0" to AllocateIfFree to cover the case of all free pages being between [pageMarker][b] and [pageMarker][0] (they were being skipped if they were!). also add the "catch first bit" IF stmt  (This might be a performance hit). 8-Feb-85 11:52:00	KEK     move PC bank initialization to AFTER realPageMin is defined; make empty PC bank be [realPageMin..realPageMin).  Add PeeCeeBankExists[]. 8-Apr-85 10:32:59	ET	Use RealMemoryExtras.PCBank to get PCstart and PCEnd.  Simulate 650k bytes dove memory for different size VM Maps and different size displays.16-Apr-85 18:55:50	KEK	fix boundary problem for when PCend > realPageMax in AllocateIfFree.  poo.22-Apr-85 15:23:19	AWL	Deallocate must do countPromised accounting if freeing a page in the active PC interval.24-Apr-85 15:02:00	kek	restore peeCeeProblem to TRUE after peeCeeProblem-loop WAIT.25-Apr-85 10:37:43	kek	Make non-ENTRY RelocatePCMemory call ENTRY MStore.Deallocate.  Make MStoreEmulatePC free up unused PC bank when asked for a smaller active bank than last time.30-May-85 15:47:57	AWL	Make reservation of the PC bank conditional on a switch and the type of Pilot that we are.28-Jun-85 16:52:32	AWL	Do not let FindSwitchable produce a free page until the main code of InitializePC is ready for a free page.17-Jul-85 11:08:23	kek	add undoing of temp vm allocation in InitializePCMemory.FindSwitchable.19-Aug-85 16:25:54	kek	fix freeing of overlap PC interval pages in EmulatePC.  This is only the first of two bugs that were found at the same time... haven't found the second yet...27-Aug-85 15:41:54	kek	add CheckMap debugging routine, for InterpretCall debugging.  Also added Bug beartrap in MStoreEmulatePC turn-off code.29-Aug-85 11:25:14	kek	found second bug! InitializePCMemory now checks for PDA/germ pages mapped inside the PC bank, and switches them out (added CheckPCMemory). 1-Sep-85 12:56:55    kek/jgs	fixed bug in new CheckPCMemory... poo.  and moved freeAndSwappable assignment above the PDA switching... double poo.29-Oct-85 17:37:59      RSV     fixed CheckMap debugging routine so that it works.  Added some enhancements to it also (checks PageMap against allocationMap now).20-Jan-86 18:00:32      kek     add notify moreNeeded to InitializeDeallocate for when a promised page is stolen away by an active PCBank. AR 7573.23-Jul-86 16:55:28      kek     add undoing of temp VM mapping in the "switch free" loop of InitializePCMemory.  This is just like the bug that was fixed by the 17-Jul-85 11:08:23 edit, sigh.12-Sep-86  7:04:05	et	Change ProcessPriorities to ProcessPrioritiesExtras.14-Jan-87 23:10:16	et	MDS relief.16-Jan-89 14:21:37	TxH	added consecutive pages functions. **22-Jan-89 17:24:04	TxH	fixed consecutive functions bugs
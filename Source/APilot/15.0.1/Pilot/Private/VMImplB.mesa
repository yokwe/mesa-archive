-- Copyright (C) 1989 by Fuji Xerox Co., Ltd. All rights reserved. -- <>VMDriver>VMImplB.mesa   12-Apr-89 13:45:10 by TxH-- *******************************************************************      DIRECTORY-- *******************************************************************  Environment     USING [PageCount, PageNumber],  MStore          USING [Allocate, Deallocate, IsPeeCee,                         RelocateAdjustingFlags, RelocatePCMemory,                         MStoreEmulatePC],  MStoreExtras    USING [CheckOrSweapConsecutiveInterval,                         FreeConsecutiveRealMemory, GetConsecutiveRealMemory,			 IsActiveConsecutiveReal, StatusGet],  PageMap         USING [Flags, GetState, flagsVacant, maskAll, maskNone,                           RealPageNumber],  Pinning         USING [CreatePinHandle, Pin, PinHandle, Unpin],  Process         USING [DisableAborts, DisableTimeout],  StoragePrograms USING [countVM],  SwapBuffer      USING [Allocate, Deallocate],  VM              USING [Interval, nullInterval],  VMExtras        USING [SwitchType],  VMExtras2,  VMInternal; -- *******************************************************************      VMImplB: MONITOR <<for consecutive functions>>-- *******************************************************************    IMPORTS       MStore, MStoreExtras, PageMap, Pinning, Process,      StoragePrograms, SwapBuffer, VMInternal    EXPORTS       VMInternal, VMExtras, VMExtras2     SHARES      PageMap =        BEGIN OPEN VMInternal;    pCPin: Pinning.PinHandle; -- PC emulation procedure handle    consecutiveGetPin: Pinning.PinHandle; -- Get Consecutive procedure handle    moreConsecutivesReals: CONDITION;        -- * copied from VMImplA    flagsVacant: PageMap.Flags = PageMap.flagsVacant;    maskNone   : PageMap.Flags = PageMap.maskNone;    maskAll    : PageMap.Flags = PageMap.maskAll;-- =============================================================     InitializeVMDriverB: PUBLIC --VMInternal.-- PROCEDURE =-- =============================================================    BEGIN    pCPin ¬ Pinning.CreatePinHandle[LOOPHOLE[EmulatePC], 1];    consecutiveGetPin ¬ Pinning.CreatePinHandle[                  LOOPHOLE[GetConsecutiveVMResidentRealMemory], 1];    Process.DisableAborts[@moreConsecutivesReals];    Process.DisableTimeout[@moreConsecutivesReals];    END; --InitializeVMDriverB---- =============================================================     EmulatePC: PUBLIC --VMExtras.-- PROCEDURE-- =============================================================     [switch: VMExtras.SwitchType, interval: VM.Interval] =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    BEGIN        EmulatePCBatch: ProcessBatchProc --[pOpData]-- =    -- trade swappable intervals out of the PC bank.      BEGIN OPEN pOpData.checkOutData;      flags: PageMap.Flags;      realPage: PageMap.RealPageNumber;      FOR vmPage: Environment.PageNumber IN [activeInterval.page..        activeInterval.page+activeInterval.count) DO	[state: [flags: flags], real: realPage] ¬ PageMap.GetState[vmPage];	IF flags # flagsVacant AND MStore.IsPeeCee[realPage] THEN	  BEGIN	  [flags: flags] ¬	    MStore.RelocateAdjustingFlags[[vmPage,1],pageBuffer,maskAll,maskNone];	  -- Note that Deallocate is weirded out with PCMode, and doesn't ~deallocate~	  -- PC pages, it just remaps them to the PC VM.interval passed in here.	  IF flags.dirty OR flags.referenced THEN	    BEGIN	    MStore.RelocatePCMemory[[pageBuffer,1]]; -- keep it in memory.	    [] ¬ MStore.RelocateAdjustingFlags[[pageBuffer,1],vmPage,maskAll,maskNone];	    END	  ELSE	    MStore.Deallocate[[pageBuffer,1], notPromised]; -- throw it out of memory          END;	ENDLOOP;      pOpData.ioInterval.count ¬ 0;      END; --EmulatePCBatch--          pageBuffer: Environment.PageNumber ¬      SwapBuffer.Allocate[1, exactSizeRequired].page;    Pinning.Pin[pCPin];    --mess with the free real pages of the PC bank    MStore.MStoreEmulatePC[switch, interval];    IF switch = on THEN      BEGIN      opData: OpData;      --swapout all mapped real pages in the PC bank      EnterVM[@opData, [0, StoragePrograms.countVM]];      ProcessBatches[@opData, [0, StoragePrograms.countVM],        [skipUnmapped, exactInterval, checkIn], EmulatePCBatch];      ExitVM[@opData];      END;    SwapBuffer.Deallocate[[pageBuffer,1]];    Pinning.Unpin[pCPin];    END; --EmulatePC--	-- =============================================================     GetConsecutiveVMResidentRealMemory:         PUBLIC --VMExtras2.-- ENTRY PROCEDURE-- =============================================================       [interval: VM.Interval] RETURNS [BOOLEAN] =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    BEGIN-- created from VMImpl.EmulatePC.<< Notes 1. The case that the "interval" already backed by consecutive memories makes things confused. 2. The process that failed in getting consecutive real memories due to a consecutive pool overflow keeps waiting untill the pool gets enough room. >>    opData: OpData;    pageBuffer: Environment.PageNumber;    status: MStoreExtras.StatusGet;    retryCount: CARDINAL ¬ 0;    ok: BOOLEAN ¬ FALSE;        ConsecutiveBatch: ProcessBatchProc --[pOpData]-- =    -- trade swappable intervals out of the activeConsecutiveInterval.      BEGIN OPEN pOpData.checkOutData;      flags: PageMap.Flags;      realPage: PageMap.RealPageNumber;    -- no resident memory in consecutive block except consecutive intervals      IF state.swappability = swappable THEN {      	FOR vmPage: Environment.PageNumber IN [activeInterval.page..	  activeInterval.page+activeInterval.count) DO	  	  [state: [flags: flags], real: realPage] ¬ PageMap.GetState[vmPage];	  IF flags # flagsVacant AND 	      MStoreExtras.IsActiveConsecutiveReal[realPage] THEN	    BEGIN	    [flags: flags] ¬	      MStore.RelocateAdjustingFlags[	        [vmPage,1],pageBuffer, maskAll, maskNone];	      	  -- Note that Deallocate doesn't ~deallocate active consecutive pages,	  -- it just remaps them to the concecutive VM.interval passed in here.	    IF flags.dirty OR flags.referenced THEN	      BEGIN	      MStore.RelocatePCMemory[[pageBuffer,1]]; -- keep it in memory.	      [] ¬ MStore.RelocateAdjustingFlags[	        [pageBuffer,1],vmPage, maskAll, maskNone];	      END	    ELSE	      MStore.Deallocate[[pageBuffer,1], notPromised]; -- throw it out of memory	    END;	  ENDLOOP};      pOpData.ioInterval.count ¬ 0;      END; --ConsecutiveBatch--   IF interval = VM.nullInterval THEN RETURN[TRUE];           Pinning.Pin[consecutiveGetPin];      -- 1. deallocate current all real pages.-- 2. set the activeConsecutiveInterval in MStoreImpl-- 3. allocate explicitly--      only if the corresponding consecutive real page is free.     DO    SELECT status ¬ MStoreExtras.GetConsecutiveRealMemory[interval] FROM      cannot => WAIT moreConsecutivesReals;      partially => EXIT;      all => {Pinning.Unpin[consecutiveGetPin]; RETURN[TRUE]};    ENDCASE;    ENDLOOP;    -- for relocating            pageBuffer ¬ SwapBuffer.Allocate[1, exactSizeRequired].page;    UNTIL ok OR retryCount = 10 DO    -- swapout all mapped real pages in the active consecutive real block      EnterVM[@opData, [0, StoragePrograms.countVM]];      ProcessBatches[@opData, [0, StoragePrograms.countVM],	[skipUnmapped, exactInterval, checkIn], ConsecutiveBatch];      ExitVM[@opData];    -- make sure that all interval pages are backed by consecutive real pages      ok ¬ MStoreExtras.CheckOrSweapConsecutiveInterval[                         interval: interval, sweap: FALSE];      retryCount ¬ retryCount + 1;    ENDLOOP;         SwapBuffer.Deallocate[[pageBuffer,1]];    Pinning.Unpin[consecutiveGetPin];    IF NOT ok THEN {      [] ¬ MStoreExtras.CheckOrSweapConsecutiveInterval[                         interval: interval, sweap: TRUE];      MStore.Allocate[interval: interval, resident: TRUE]};    RETURN[ok];    END; --MakeItResidentWithConsecutiveRealMemory---- =============================================================    FreeConsecutiveVMResidentRealMemory:      PUBLIC --VMExtras2-- ENTRY PROCEDURE-- =============================================================    [interval: VM.Interval] = -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<< Notes:   1. The "interval" must have consecutive real pages. >>    BEGIN     IF interval = VM.nullInterval THEN RETURN;     MStoreExtras.FreeConsecutiveRealMemory[interval];     BROADCAST moreConsecutivesReals;   END;--FreeConsecutiveVMResidentRealMemory--    END.   LOG  12-Apr-89 13:45:08    TxH    Created. Moved VMDriver's PCEmulation stuff from VMImpl(A). Also ConsecutiveRealVMImpl's merged into here.
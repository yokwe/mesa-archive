-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- GFHashImpl.mesa, edited by-- JBD    	 9-Sep-86 15:53:29-- AXD    	 7-Sep-83 14:53:45DIRECTORY  Environment USING [PageFromLongPointer, wordsPerPage],  GFHash USING [EachPairAction, GFTHandle],  GFHashFormat USING [    available, Base, FirstIndex, Hash, Index, mod, Nil, Node, TableRep],  Inline USING [LongCOPY],  Space USING [PageFromLongPointer, ScratchMap, Unmap],  SpecialSpace USING [    MakeGlobalFrameResident, MakeProcedureResident, SpecialError],  VM USING [MakeResident];GFHashImpl: PROGRAM  IMPORTS GFHashFormat, Inline, Space, SpecialSpace, VM EXPORTS GFHash = PUBLIC  BEGIN  Table: TYPE = GFHashFormat.Base;  Create: PROC [ngf: CARDINAL, dataSize: CARDINAL] RETURNS [self: Table] = {    Zero: PROC [p: LONG POINTER, words: CARDINAL] = INLINE {      p­ ¬ 0; Inline.LongCOPY[from: p, to: p + 1, nwords: words - 1]};    words: CARDINAL = GFHashFormat.TableRep[      ngf * GFHashFormat.Node[dataSize].SIZE].SIZE;    pages: CARDINAL =      (words + Environment.wordsPerPage - 1) / Environment.wordsPerPage;    limit: GFHashFormat.Index =      GFHashFormat.FirstIndex + (ngf - 1) * GFHashFormat.Node[dataSize].SIZE;    self ¬ Space.ScratchMap[pages];    Zero[self, words];    self.dataSize ¬ dataSize;    self.tableSize ¬ words;    self.resident ¬ FALSE;    self.array ¬ ALL[GFHashFormat.Nil];    self.array[GFHashFormat.available] ¬ GFHashFormat.FirstIndex;    FOR ni: GFHashFormat.Index ¬ GFHashFormat.FirstIndex,      ni + GFHashFormat.Node[dataSize].SIZE WHILE ni < limit DO      self[ni].next ¬ ni + GFHashFormat.Node[dataSize].SIZE; ENDLOOP};  Destroy: PROC [self: Table] = {[] ¬ Space.Unmap[self]};  MakeResident: PROC [self: Table] = {    IF self.resident THEN RETURN;    VM.MakeResident[      [      Space.PageFromLongPointer[self],      (self.tableSize + Environment.wordsPerPage - 1) / Environment.wordsPerPage],      wait ! SpecialSpace.SpecialError => CONTINUE];    SpecialSpace.MakeGlobalFrameResident[      GFHashImpl ! SpecialSpace.SpecialError => CONTINUE];    SpecialSpace.MakeProcedureResident[      LOOPHOLE[MakeResident] ! SpecialSpace.SpecialError => CONTINUE]};  Fetch: PROC [self: Table, gf: GFHash.GFTHandle] RETURNS [data: LONG POINTER] = {    hash: CARDINAL = GFHashFormat.Hash[gf];    FOR ni: GFHashFormat.Index ¬ self.array[hash], self[ni].next WHILE ni #      GFHashFormat.Nil DO      IF gf = self[ni].gf THEN RETURN[@self[ni].data]; ENDLOOP;    RETURN[NIL]};  Insert: PROC [self: Table, gf: GFHash.GFTHandle] RETURNS [LONG POINTER] = {    hash: CARDINAL = GFHashFormat.Hash[gf];    ni: GFHashFormat.Index;    FOR ni ¬ self.array[hash], self[ni].next UNTIL ni = GFHashFormat.Nil DO      IF gf = self[ni].gf THEN RETURN[@self[ni].data]; ENDLOOP;    IF (ni ¬ self.array[GFHashFormat.available]) = GFHashFormat.Nil THEN      RETURN[NIL];    self.array[GFHashFormat.available] ¬ self[ni].next;    <<self[ni] ¬ [gf: gf, next: self.array[hash], data: TRASH];      ­ Compiler complains that self[ni] cannot be updated >>    self[ni].gf ¬ gf;    self[ni].next ¬ self.array[hash];    RETURN[@self[self.array[hash] ¬ ni].data]};  Delete: PROC [self: Table, gf: GFHash.GFTHandle] RETURNS [BOOLEAN] = {    hash: CARDINAL = GFHashFormat.Hash[gf];    node: GFHashFormat.Index ¬ self.array[hash];    head: GFHashFormat.Index ¬ node;    lag: GFHashFormat.Index ¬ GFHashFormat.Nil;    WHILE node # GFHashFormat.Nil DO      IF gf = self[node].gf THEN {        IF lag = GFHashFormat.Nil THEN self.array[hash] ¬ self[node].next        ELSE self[lag].next ¬ self[node].next;        self[node].next ¬ self.array[GFHashFormat.available];        self.array[GFHashFormat.available] ¬ node;        RETURN[TRUE]};      lag ¬ node;      node ¬ self[node].next;      ENDLOOP;    RETURN[FALSE]};  Pairs: PROC [self: Table, action: GFHash.EachPairAction]    RETURNS [quit: BOOLEAN] = {    FOR hash: CARDINAL IN [0..GFHashFormat.mod) DO      FOR ni: GFHashFormat.Index ¬ self.array[hash], self[ni].next UNTIL ni =        GFHashFormat.Nil DO        IF action[self[ni].gf, @self[ni].data] THEN RETURN[TRUE]; ENDLOOP;      ENDLOOP;    RETURN[FALSE]};  END.
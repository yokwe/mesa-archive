-- Copyright (C) 1983, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- FormatPilotDiskImpl.mesa      19-Oct-87 11:50:28 by CAJ    -- The current implementation does not prevent several client processes from invoking one of these operations on the same drive at the same time. This is thought not to be a problem.-- Should we do something about assert non-pilot volumes???-- Within this program, Public procs are first; private procs follow in a separate section.DIRECTORY  Boot USING [BootFileDescriptorPageHandle, BootFileDescriptorPageSeal,    BootFileDescriptorPageVersion, BootFileType, eofDescriptorLink],  Device USING [PilotDisk, Type],  DiskChannel USING [    ChannelStatus, Create, defaultTries, Drive, DiskChannelPrivate, DriveObject,    diskOpWordAlignment, DiskPageNumber, DirectOperation, DoDirectIO, GetDrive,    GetDriveAttributes, GetPageAddress, GetPageNumber, Handle, InspectDiskShape,    IOStatus, operationSize, Tries],  Environment USING [Base, first64K, PageCount, PageFromLongPointer,    wordsPerPage],  FormatPilotDisk USING [DiskPageNumber, FailureType, PassesLeft, RetryLimit],  Inline USING [LongCOPY],  KernelPhysicalVolume USING [PVHandle],  PhysicalVolume USING [PageCount],  -- exports Handle  PilotDisk USING [Handle],  PilotDiskFace USING [    Command, DeviceHandle, DiskAddress, FormattingSpec, FormattingUnit,    GetDeviceAttributes, GetDriveInfo, Operation, Status],  ResidentHeap USING [FreeNode, MakeNode],  SelfDescribingDisks USING [DiskShapeDescriptorAddress],  Space USING [Allocate, Deallocate],  System USING [GetClockPulses],  VM USING [Map, nullBackingStoreRuns, Unmap],  Zone USING [Status];FormatPilotDiskImpl: MONITOR  -- just guards the random number generator  IMPORTS    DiskChannel, Environment, Inline, PilotDiskFace, ResidentHeap,    Space, System, VM  EXPORTS FormatPilotDisk, PhysicalVolume  --[Handle]--  SHARES Device, DiskChannel, FormatPilotDisk =  BEGIN  Handle: PUBLIC TYPE = KernelPhysicalVolume.PVHandle;  BadPage: PUBLIC SIGNAL [p: DiskPageNumber] = CODE;  CantInstallUCodeOnThisDevice: PUBLIC ERROR = CODE;  FormattingMustBeTrackAligned: PUBLIC ERROR = CODE;  FormattingUnitConflict: PUBLIC ERROR = CODE;  MicrocodeInstallFailure: PUBLIC SIGNAL [m: FormatPilotDisk.FailureType] = CODE;  NotAPilotDisk: PUBLIC ERROR = CODE;  PassDone: PUBLIC SIGNAL [passesLeft: FormatPilotDisk.PassesLeft] = CODE;  DiskPageNumber: TYPE = FormatPilotDisk.DiskPageNumber;  PageOfCardinals: TYPE = ARRAY [0..Environment.wordsPerPage) OF CARDINAL;  IRand: TYPE = [0..33);  iRandMax: CARDINAL = LAST[IRand];  RandArray: TYPE = ARRAY IRand OF CARDINAL;  RandomTable: TYPE = RECORD [i: IRand ¬ 0, rand: RandArray];  initRandomTable: RandArray = [    31377B, 131235B, 144466B, 41705B, 44600B, 146005B, 132355B, 114267B, 164223B,    171113B, 26244B, 77772B, 127054B, 67771B, 36434B, 63276B, 146515B, 105045B,    34427B, 36624B, 114375B, 12402B, 176741B, 133667B, 6714B, 106565B, 45545B,    135442B, 21360B, 104071B, 43770B, 34255B, 160315B];  randomTable: RandomTable ¬ [0, initRandomTable];  userAbort: BOOLEAN ¬ FALSE;  wholeDiskFormatCount: CARDINAL = 1;  Bug: ERROR [type: BugType] = CODE;  BugType: TYPE = {badIOStatus, funnyCase, residentHeapError, unknownDiskType};  --=============================  -- PUBLIC Procedures:  --=============================  DiskInfo: PUBLIC PROC [h: Handle]    RETURNS [      firstPilotPage: DiskPageNumber, countPages: PhysicalVolume.PageCount,      pagesPerTrack: CARDINAL, pagesPerCylinder: CARDINAL] =    BEGIN    diskDeviceHandle: PilotDisk.Handle;    IF ~DiskChannel.InspectDiskShape[drive: h.drive, mode: quickReadOnly]      THEN ERROR NotAPilotDisk;      [deviceHandle: diskDeviceHandle, nPages: countPages] ¬      DiskChannel.GetDriveAttributes[h.drive];    firstPilotPage ¬ DiskChannel.GetPageNumber[      drive: h.drive,      page: PilotDiskFace.GetDriveInfo[diskDeviceHandle].firstPilotPage];    pagesPerTrack ¬ PilotDiskFace.GetDeviceAttributes[      diskDeviceHandle].sectorsPerTrack;    pagesPerCylinder ¬      pagesPerTrack * PilotDiskFace.GetDeviceAttributes[        diskDeviceHandle].movingHeads;    END;  Format: PUBLIC PROC [    h: Handle, firstPage: DiskPageNumber, count: LONG CARDINAL, passes: CARDINAL,    retries: FormatPilotDisk.RetryLimit, returnOnUserAbort: BOOLEAN,    signalPassDone: BOOLEAN] =    BEGIN    CleanUp: PROC = {      VM.Unmap[Environment.PageFromLongPointer[buffer]];      Space.Deallocate[[buffer, bufferPages]]};    bufferPages: CARDINAL = 2;  -- one for formatting buffer, one for SDD page    buffer: LONG POINTER TO PageOfCardinals;    channel: DiskChannel.Handle = DiskChannel.Create[h.drive];    sddPage: DiskPageNumber = DiskChannel.GetPageNumber[      drive: h.drive, page: SelfDescribingDisks.DiskShapeDescriptorAddress];    sddPageBuffer: LONG POINTER;    userAbort ¬ FALSE;    buffer ¬ Space.Allocate[count: bufferPages].pointer;    sddPageBuffer ¬ buffer + Environment.wordsPerPage;    VM.Map[  -- resident memory      interval: [page: Environment.PageFromLongPointer[buffer],      count: bufferPages], transferProc: NIL,      backingStoreRuns: VM.nullBackingStoreRuns, class: data,      swapUnits: [unitary[]], swappability: resident];    BEGIN    ENABLE UNWIND => CleanUp[];    commandList: PilotDiskFace.FormattingSpec;    commandListCount: CARDINAL;    formatCount: LONG CARDINAL;    formatTotal: LONG CARDINAL;    tries: DiskChannel.Tries =  -- note that a RetryLimit      retries + 1;  --  is cleverly defined so this will not overflow.    -- Preserve contents of the self-describing disks descriptor page.    IF sddPage IN [firstPage..firstPage + count) THEN      Transfer[        h, channel, sddPage, 1, read, sddPageBuffer, DiskChannel.defaultTries];    -- Do actual formatting.    formatCount ¬      AssertPilotDiskAndGetFormatInfo[h: h, first: firstPage, count: count];    formatTotal ¬      IF formatCount = wholeDiskFormatCount THEN wholeDiskFormatCount ELSE count;    commandList ¬ PilotDiskFace.GetDriveInfo[      DiskChannel.GetDriveAttributes[h.drive].deviceHandle].formattingSpec;    commandListCount ¬ LENGTH[commandList];    IF returnOnUserAbort AND userAbort THEN GOTO abort;    FOR commandCount: CARDINAL ¬ 0, commandCount + 1 WHILE commandCount <      commandListCount DO      {      formatCommand: PilotDiskFace.Command ¬ commandList[commandCount];      FOR countDone: LONG CARDINAL ¬ 0, countDone + formatCount          WHILE countDone < formatTotal DO        Transfer[          h, channel, firstPage + countDone, formatCount, formatCommand,          buffer, DiskChannel.defaultTries];        ENDLOOP;      };      ENDLOOP;    -- Do verify passes.    FOR pass: CARDINAL IN [0..passes) DO      firstRandom: CARDINAL = 10;      dataValue: CARDINAL ¬ SELECT (pass MOD 12) FROM        0 => 0FFFFH,	1 => 0,        2 => 0AAAAH,	3 => 5555H,        4 => 6DB6H,	5 => 9249H,        6 => 0B6DBH,	7 => 4924H,        8 => 0DB6DH,	9 => 2492H,        ENDCASE --firstRandom-- => Random[];      IF (pass MOD 12) < firstRandom        THEN SetBlock[buffer, Environment.wordsPerPage, dataValue]	ELSE InitRandomData[buffer];      IF returnOnUserAbort AND userAbort THEN GOTO abort;      Transfer[        h, channel, firstPage, count, write, buffer, tries];      Transfer[        h, channel, firstPage, count, verify, buffer, tries];      IF signalPassDone THEN SIGNAL PassDone[passesLeft: passes - (pass + 1)];      IF returnOnUserAbort AND userAbort THEN GOTO abort;      ENDLOOP;    EXITS abort => userAbort ¬ FALSE;    END;  --scope of UNWIND--    -- Restore contents of the self-describing disks descriptor page.    IF sddPage IN [firstPage..firstPage + count) THEN      Transfer[        h, channel, sddPage, 1, write, sddPageBuffer, DiskChannel.defaultTries];    CleanUp[];    END;  --Format--  FormatBootMicrocodeArea: PUBLIC PROC [    h: Handle, passes: CARDINAL, retries: FormatPilotDisk.RetryLimit] =    BEGIN    ucodeStart, ucodeLastPage: DiskPageNumber;    [ucodeStart, ucodeLastPage] ¬ AssertPilotDiskAndGetUCodeInfo[h];    Format[      h: h, firstPage: ucodeStart, count: 1 + ucodeLastPage - ucodeStart,      passes: passes, retries: retries, returnOnUserAbort: FALSE,      signalPassDone: FALSE];    END;  InstallBootMicrocode: PUBLIC PROC [    h: Handle, getPage: PROC RETURNS [LONG POINTER]] =    BEGIN    buffer: LONG POINTER;    bufferPages: CARDINAL = 3;    CleanUp: PROC = {      VM.Unmap[Environment.PageFromLongPointer[buffer]];      Space.Deallocate[[buffer, bufferPages]]};    channel: DiskChannel.Handle = DiskChannel.Create[h.drive];    ucodeStart, ucodeLastPage: DiskPageNumber;    [ucodeStart, ucodeLastPage] ¬ AssertPilotDiskAndGetUCodeInfo[h];    buffer ¬ Space.Allocate[count: bufferPages].pointer;      -- three pages: descriptor, data, and makeBootable buffer    VM.Map[  -- resident memory      interval: [page: Environment.PageFromLongPointer[buffer],      count: bufferPages], transferProc: NIL,      backingStoreRuns: VM.nullBackingStoreRuns, class: data,      swapUnits: [unitary[]], swappability: resident];    InstallBootMicrocode1[      h, channel, buffer, getPage, ucodeStart, ucodeLastPage !      UNWIND => CleanUp[]];    CleanUp[];    END;  Scan: PUBLIC PROC [    h: Handle, firstPage: DiskPageNumber, count: LONG CARDINAL,    retries: FormatPilotDisk.RetryLimit] =    BEGIN    buffer: LONG POINTER;  -- one page.    CleanUp: PROC = {      VM.Unmap[Environment.PageFromLongPointer[buffer]];      Space.Deallocate[[buffer, 1]]};    tries: DiskChannel.Tries =  -- note that a RetryLimit      retries + 1;  --  is cleverly defined so this will not overflow.    channel: DiskChannel.Handle = DiskChannel.Create[h.drive];    [] ¬ PilotDiskFromHandle[h];  -- may raise NotAPilotDisk.    buffer ¬ Space.Allocate[count: 1].pointer;    VM.Map[  -- resident memory      interval: [page: Environment.PageFromLongPointer[buffer], count: 1],      transferProc: NIL, backingStoreRuns: VM.nullBackingStoreRuns, class: data,      swapUnits: [unitary[]], swappability: resident];    Transfer[      h, channel, firstPage, count, read, buffer, tries !      UNWIND => CleanUp[]];    CleanUp[];    END;  --Scan--  SetUserAbort: PUBLIC PROC = {userAbort ¬ TRUE};  --=============================  -- PRIVATE Procedures  --=============================  AllocateDirectOperation: PROC    RETURNS [      pOp: LONG POINTER TO DiskChannel.DirectOperation,      pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] =    -- pOp will be aligned per requirements of DoDirectIO.    -- pStorage should be used when freeing.    BEGIN    rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;    status: Zone.Status;    [pStorage, status] ¬ ResidentHeap.MakeNode[      n: DiskChannel.operationSize + DiskChannel.diskOpWordAlignment - 1,      alignment: a1];    IF status ~= okay THEN ERROR Bug[residentHeapError];    rpDirOp ¬ pStorage;    pOp ¬ @Environment.first64K[rpDirOp];    pOp ¬ LOOPHOLE[((LOOPHOLE[pOp, LONG CARDINAL]      + SIZE[DiskChannel.DiskChannelPrivate] + DiskChannel.diskOpWordAlignment-1)	  / DiskChannel.diskOpWordAlignment) * DiskChannel.diskOpWordAlignment	    - SIZE[DiskChannel.DiskChannelPrivate]];    END;  AssertPilotDiskAndGetFormatInfo: PROC [    h: Handle, first: DiskPageNumber, count: LONG CARDINAL]    RETURNS [countFormat: LONG CARDINAL] =    BEGIN    diskPages: PhysicalVolume.PageCount;    formattingUnit: PilotDiskFace.FormattingUnit ¬ PilotDiskFace.GetDriveInfo[      DiskChannel.GetDriveAttributes[h.drive].deviceHandle].formattingAlignment;    [countPages: diskPages, pagesPerTrack: countFormat] ¬ DiskInfo[h];    IF formattingUnit = wholeDisk THEN      -- For wholeDisk disks, we check here that count = whole disk, but we must      -- special-case the countFormat and rely on an assumption shared by the      -- head that the operation count is ignored if formattingUnit = wholeDisk.      -- This is because a wholeDisk is more than a CARDINAL's worth of pages,      -- but the operation count field is CARDINAL.      {IF (first = 0) AND (count = diskPages)        THEN RETURN[countFormat: wholeDiskFormatCount]       ELSE ERROR FormattingUnitConflict};    IF (first MOD countFormat) # 0 OR (count MOD countFormat) # 0 THEN      {IF formattingUnit = arbitrary THEN RETURN[countFormat: count]       ELSE ERROR FormattingMustBeTrackAligned};    END;  AssertPilotDiskAndGetUCodeInfo: PROC [h: Handle]    RETURNS [ucodeStart, ucodeLastPage: DiskPageNumber] =    BEGIN    first, last: PilotDiskFace.DiskAddress;    [firstPageOfInitialMicrocode: first, lastPageOfInitialMicrocode: last] ¬       PilotDiskFace.GetDriveInfo[         DiskChannel.GetDriveAttributes[h.drive].deviceHandle];    ucodeStart ¬ DiskChannel.GetPageNumber[h.drive, first];    ucodeLastPage ¬ DiskChannel.GetPageNumber[h.drive, last];    END;  CopyPage: PROC [from, to: LONG POINTER] = INLINE {    Inline.LongCOPY[from: from, to: to, nwords: Environment.wordsPerPage]};  FreeDirectOperation: PROC [pStorage: Environment.Base RELATIVE POINTER] = {    status: Zone.Status ¬ ResidentHeap.FreeNode[pStorage];    IF status ~= okay THEN ERROR Bug[residentHeapError]};  GetDiskAddress: PROC [h: DiskChannel.Handle, p: DiskPageNumber]    RETURNS [PilotDiskFace.DiskAddress] = {    x: PilotDiskFace.DiskAddress = DiskChannel.GetPageAddress[      DiskChannel.GetDrive[h], p];    RETURN[[cylinder: x.cylinder, head: x.head, sector: x.sector]]};  GetPageNumber: PROC [d: DiskChannel.Drive, a: PilotDiskFace.DiskAddress]    RETURNS [DiskPageNumber] = {    RETURN[      DiskChannel.GetPageNumber[        d, [cylinder: a.cylinder, head: a.head, sector: a.sector]]]};  InitRandomData: PROC [    data: LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF CARDINAL] =    BEGIN    k, r: CARDINAL;    pulses: LONG CARDINAL = System.GetClockPulses[];    RandomFromPulses: TYPE = MACHINE DEPENDENT RECORD [      miscHiBits16to31(0:0..15): CARDINAL,      miscHiBits10to15(1:10..15): [0..64),      randomBits0to9(1:0..9): [0..1024)];    FOR k IN [0..LOOPHOLE[pulses, RandomFromPulses].randomBits0to9] DO      r ¬ Random[] ENDLOOP;    FOR k IN [0..Environment.wordsPerPage) DO data[k] ¬ Random[]; ENDLOOP;    END;  InstallBootMicrocode1: PROC [    h: Handle, channel: DiskChannel.Handle, myPage: LONG POINTER,    getPage: PROC RETURNS [LONG POINTER],    ucodeStart, lastUcodePage: DiskPageNumber] =    -- h has been asserted to be a PilotDisk.    BEGIN    device: PilotDiskFace.DeviceHandle = DiskChannel.GetDriveAttributes[      h.drive].deviceHandle;    GetDA: PROC [p: DiskPageNumber] RETURNS [PilotDiskFace.DiskAddress] = INLINE {      RETURN[GetDiskAddress[channel, p]]};  -- for brevity    IO: PROC [command: PilotDiskFace.Command,      diskAddress: PilotDiskFace.DiskAddress, data: LONG POINTER]      RETURNS [success: BOOLEAN] =      << Other actual arguments: device.         Performs the command on the single page at diskAddress and returns	 success code. If command = write, the data is read back and verified.>>      BEGIN      op: LONG POINTER TO DiskChannel.DirectOperation;      opStorage: Environment.Base RELATIVE POINTER;      ioStatus: DiskChannel.IOStatus;      [op, opStorage] ¬ AllocateDirectOperation[];      op.diskOp ¬ [        clientHeader: diskAddress, dataPtr: data, incrementDataPtr: FALSE,        command: command, tries: DiskChannel.defaultTries,        pageCount: IF command = makeBootable THEN 2 ELSE 1, device: device];      ioStatus ¬ DiskChannel.DoDirectIO[op].status;      WITH s: ioStatus SELECT FROM        invalidChannel, invalidDriveState => Bug[badIOStatus];        disk =>          SELECT s.status FROM            inProgress => ERROR Bug[badIOStatus];            goodCompletion => NULL;            notReady, recalibrateError, seekTimeout, headerCRCError, reserved6,              dataCRCError, headerNotFound, reserved9, dataVerifyError,              overrunError, writeFault, memoryError, memoryFault, clientError,              operationReset, otherError => RETURN[success: FALSE];            ENDCASE => ERROR Bug[funnyCase];        ENDCASE => ERROR Bug[funnyCase];      FreeDirectOperation[opStorage];      RETURN[        success: IF command = write THEN IO[verify, diskAddress, data] ELSE TRUE];      END;  --IO--    bits: LONG POINTER ¬ getPage[];    currentGroup: CARDINAL ¬ LAST[CARDINAL];  -- initial increment to 0    desc: Boot.BootFileDescriptorPageHandle;    makeBootableBuffer: LONG POINTER;    prevPage: LONG CARDINAL ¬ LOOPHOLE[LONG[-1]];  -- init so ~= ucodeStart-1    thisPage: LONG CARDINAL ¬ ucodeStart;    makeBootableBuffer ¬ myPage + Environment.wordsPerPage;    desc ¬ makeBootableBuffer + Environment.wordsPerPage;    IF bits = NIL THEN GOTO emptyFile;    CopyPage[from: bits, to: myPage];    desc.header ¬ [      seal: Boot.BootFileDescriptorPageSeal,      version: Boot.BootFileDescriptorPageVersion,      bootFileType: Boot.BootFileType[initialMicrocode],      pageRunsCount: 0,      nextPage: Boot.eofDescriptorLink,      thisDescriptorPages: 1,      totalDescriptorPages: 1];    -- Write out all the pages of the file    DO      bits ¬ getPage[];      DO        IF thisPage > lastUcodePage THEN GOTO tooBig;        IF IO[write, GetDA[thisPage], myPage] THEN EXIT;        IF thisPage = ucodeStart THEN GOTO firstPageBad          ELSE thisPage ¬ thisPage + 1;	-- Keep trying until write succeeds or past end of ucode area.        ENDLOOP;      IF thisPage = (prevPage + 1) THEN        desc.pageRuns[currentGroup].count ¬ desc.pageRuns[currentGroup].count + 1	ELSE {        -- Start a new page group.        -- Note we do not get here if the first page is bad	currentGroup ¬ currentGroup + 1;	desc.pageRuns[currentGroup] ¬ [da: GetDA[thisPage], count: 1]};      IF bits = NIL THEN EXIT;      CopyPage[from: bits, to: myPage];      prevPage ¬ thisPage;      thisPage ¬ thisPage + 1;      ENDLOOP;    -- File all done; now write out descriptor.    desc.header.pageRunsCount ¬ currentGroup + 1;    IF ~IO[makeBootable, GetDA[ucodeStart], makeBootableBuffer]      THEN GOTO makeBootableFailed;    EXITS      emptyFile => SIGNAL MicrocodeInstallFailure[emptyFile];      firstPageBad => SIGNAL MicrocodeInstallFailure[firstPageBad];      tooBig => SIGNAL MicrocodeInstallFailure[microcodeTooBig];      makeBootableFailed => SIGNAL MicrocodeInstallFailure[makeBootableFailed];    END;  --InstallBootMicrocode1--  PilotDiskFromHandle: PROC [h: Handle] RETURNS [t: Device.Type] = {    -- May raise NotAPilotDisk.    t ¬ DiskChannel.GetDriveAttributes[h.drive].deviceType;    IF t ~IN Device.PilotDisk THEN ERROR NotAPilotDisk};  Random: ENTRY PROC RETURNS [CARDINAL] =    -- Random takes the random table as a circular array    -- Rand[i] ¬ Rand[i] + Rand[20]    BEGIN    i: CARDINAL = randomTable.i;    randomTable.i ¬ (i + 1) MOD iRandMax;    RETURN[      randomTable.rand[i] ¬        randomTable.rand[i] + randomTable.rand[(i + 20) MOD iRandMax]];    END;  SetBlock: PROC [location: LONG POINTER, length, value: CARDINAL] = INLINE {    location­ ¬ value;    Inline.LongCOPY[from: location, to: location + 1, nwords: length - 1]};  Transfer: PROC [    h: Handle, channel: DiskChannel.Handle, firstPage: DiskPageNumber,    count: LONG CARDINAL, cmd: PilotDiskFace.Command,    data: LONG POINTER, tries: DiskChannel.Tries] =    -- h must refer to a PilotDisk device.    -- data­ must be a resident one-page buffer, page aligned.    BEGIN    device: PilotDiskFace.DeviceHandle = DiskChannel.GetDriveAttributes[      h.drive].deviceHandle;    op: LONG POINTER TO DiskChannel.DirectOperation;    opStorage: Environment.Base RELATIVE POINTER;    [op, opStorage] ¬ AllocateDirectOperation[];    FOR page: DiskPageNumber ¬ firstPage, page + CARDINAL.LAST WHILE page <      firstPage + count DO      -- Do as much as requested, but not more than CARDINAL.LAST per operation.      CARDINALcount: CARDINAL ¬ CARDINAL[        MIN[CARDINAL.LAST.LONG, firstPage + count - page]];      op.diskOp ¬ [        clientHeader: GetDiskAddress[channel, page], reserved1: NIL,        dataPtr: data, incrementDataPtr: FALSE, command: cmd, tries: tries,        pageCount: CARDINALcount, device: device];      DO  --until goodCompletion--        ioStatus: DiskChannel.IOStatus ¬ DiskChannel.DoDirectIO[op].status;        WITH s: ioStatus SELECT FROM          invalidChannel, invalidDriveState => Bug[badIOStatus];          disk =>            SELECT s.status FROM              inProgress => Bug[badIOStatus];              goodCompletion => EXIT;              notReady, recalibrateError, seekTimeout, headerCRCError,                reserved6, dataCRCError, headerNotFound, reserved9,                dataVerifyError, overrunError, writeFault, memoryError,                memoryFault, clientError, operationReset, otherError =>                BEGIN                page: DiskPageNumber = GetPageNumber[                  h.drive, op.diskOp.clientHeader];                SIGNAL BadPage[page];                op.diskOp.clientHeader ¬ GetDiskAddress[channel, page + 1];                IF (op.diskOp.pageCount ¬ op.diskOp.pageCount.PRED) = 0 THEN EXIT;                END;              ENDCASE => ERROR Bug[funnyCase];          ENDCASE => ERROR Bug[funnyCase];        ENDLOOP;  --until goodCompletion--      ENDLOOP;  -- CARDINAL.LAST-length runs of pages--    FreeDirectOperation[opStorage];    END;  --Transfer--  END.LOGJune 1, 1980  1:23 AM	FXH       Changed to use sanitized interface.  Added limit checking on InstallMicrocode.  Trimmed log.July 28, 1980  8:22 AM	FXH       Retrofited PXM     changes for new SA4000face.  Converted to SA1000and4000.September 30, 1980  5:31 PM	AWL         Increment File Page numbers in labels after finding a bad page in Transfer. May 13, 1981  1:48 PM	AWL         Modify Transfer to handle very long runs of pages (> LAST[CARDINAL]).9-Jun-81 14:59:57	SXY   	SA4000Face => PilotDiskFace 7-Jul-81 14:39:04	Glassman   Improve formatter (multiple passes and no retries), Change name of file20-Aug-81 18:20:54	FXH    	clean up 9-Dec-81 15:46:16	FXH       changed formatting phase to be Write, write, write vs. write, nop, nop.  This is especially important for soft sectored disks (SA1000).  Fixed bug causing recalibrate on EVERY sa1000 track formatted.10-Dec-81 15:05:01	FXH       Changed names of old SA4000&1000 stuff to PilotDisk; add code to handle quantums.. 8-Jan-82 10:20:14	FXH       Fixed bug for installing trident ucode; patch module to 29 sectors.13-Jan-82 10:03:39	FXH    	changed to 30 sectors.29-Mar-83 18:18:10	EKN      Update to Klamath (Space, DiskChannel, PilotDisk). Fixed AR - PilotDiskFace procedures are not called by this code (only types are referenced).  DiskChannel.DoDirectIO substituted for PilotDiskFace.Initiate, Poll.26-Apr-83 10:43:25	WDK        InstallBootMicrocode1.IO initialized op­, then aligned op. op was wrong size. Ditched default PUBLIC, blanket OPENs, LOOPHOLEs. Didn't check for all errors returned by DoDirectIO. Allocates and frees storage as required. AssertPilotDiskAndGetFormatInfo no longer assumes that an unknown device has no formatting restrictions. Disk buffer was not resident. Ditched global resources, making it robust against multiple clients operating on different drives. 4-Nov-83 11:42:17	AWL         Support q2080.30-Jan-85 14:38:02      CJS       Implement DiskInfo: as part of removal of disk shape constants from FormatPilotDisk.AssertPilotDiskAndGetUCodeInfo no longer raises CantInstallUCodeOnThisDevice. 6-Feb-85 18:13:08	CJS      DiskInfo should raise NotAPilotDisk.        22-Jul-86 12:16:39	CAJ      Remove label use, replace boot chain links with boot descriptor in InstallBootMicrocode1.         2-Jul-87 17:32:49	CAJ      Add Format changes for diag: Format args returnOnUserAbort and signalPassDone, more verification patterns, userAbort handling, modified pass handling; new proc SetUserAbort.  Make Format save and restore self-describing disk descriptor page if it is in the format area.  New error FormattingUnitConflict.  Make Format and FormatBootMicrocodeArea deal with wholeDisk FormattingUnit.10-Jul-87  8:29:03	CAJ      Fix up wholeDisk formatting count and document hidden assumptions.17-Sep-87 11:10:31	CAJ      Write instead of verify saved SDD page.19-Oct-87 11:49:30	CAJ      Fixed PassDone returned value.
-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- MesaRuntime>Traps.mesa-- ET		18-Sep-87  6:58:17    <<Programming notes:All trap handlers immediately increment the trapee's pc past the trapped instruction, process the trap, decrement the pc, then resume the trapee. Thus the trapee appears to have sucessfully executed the instruction causing the trap during trap processing. This is required because the trapee's pc is used for determining which of his catch phrases are currently enabled, and the signaller assumes that the pc of the folks up the stack have been incremented past the current instruction (which procedure calls do, but traps do not). Also, the debugger will correctly display the trapee statement which caused the trap.>> DIRECTORY  ControlModuleFormat USING [Call, Finger, Item, List, MainBody],  Environment USING [Byte],  ESCAlpha USING [alpha, aLUDIV, aPI, aPO, aPOR, aSDDIV, aSDIV, aUDDIV, aUDIV],  Frame USING [Free, GetReturnFrame, GetReturnLink,     MyLocalFrame, ReadPC,  ReadReturnLink, SetReturnFrame, SetReturnLink,     WritePC, WriteReturnLink],  FrameExtras USING [GFTHandleToLongGF, GlobalOverhead, LongGFToGFTHandle,     MyGlobalFrame, ReadCodebase, ReadGlobalLink, WriteCodebase, WriteGlobalExtra],  Inline USING [BITAND, DBITAND],  Mopcodes USING [op, zESC, zESCL],  MopcodesExtras USING [zSTC],  PilotMP USING [cEarlyTrap],  PrincOps USING [AV, AVHandle, BytePC, ControlLink, GlobalCodebase,     GlobalFrameHandle, LargeReturnSlot, LocalFrameHandle, NullLocalFrame,     Port, PortHandle, PrefixHandle, ShortControlLink, StateVector],  PrincOpsExtras USING [SourceDest],  PrincOpsExtras2 USING [ControlLink, ExtraGlobalWord, GFTHandle, GFTIndexToHandle,     LongGlobalFrameHandle, NullGlobalFrame],  ProcessorFace USING [SpecialSetMP],  Runtime USING [CallDebugger, ControlLink, ValidateGlobalFrame],  RuntimeInternal USING [Bug],  RuntimePrograms USING [],  SDDefs USING [sBoundsTrap, sCodeTrap, sControlTrap, SD, sDivCheckTrap, sDivZeroTrap, sHardwareError, sInterruptError, sNarrowFault, sPointerTrap, sRescheduleError, sRestart, sSignal, sStackError, sStart, sStringInit, sUnboundTrap],  SDDefsExtras USING [sBytePointerTrap],  SpecialRuntimeExtras USING [Codebase, GlobalFrameFromProgram, ProgramFromGlobalFrame],  Trap USING [LongParameter, Parameter];Traps: MONITOR  IMPORTS ControlModuleFormat, Frame, FrameExtras, Inline, PrincOpsExtras2,    ProcessorFace, RuntimeInternal, SpecialRuntimeExtras, Runtime, Trap  EXPORTS Runtime, RuntimePrograms =  BEGIN    -- PARAMETERS:  OpcodeLengths: PACKED ARRAY [0..255] OF [0..3] = [    -- (Generated by Lister of 19-Jun-86  9:29:08 for 13.0.)    1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,    1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,2,2,1,1,0,2,    1,1,2,1,2,1,2,1,2,1,2,2,2,2,2,1,2,2,2,1,1,1,1,2,2,1,2,2,2,2,2,2,    2,2,2,2,2,2,3,2,3,1,3,3,2,3,3,2,2,2,3,3,1,2,2,2,2,2,2,1,2,1,2,2,    2,1,1,1,1,1,1,1,2,3,2,2,3,2,2,3,2,2,2,2,2,2,2,2,1,1,2,1,1,2,2,2,    3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,0,    1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,2,2,1,1,1,1,1,1,1,2,3,1,1,2,3,3,1,    1,1,1,1,1,1,1,1,1,1,1,1,2,3,1,1,2,1,1,1,1,1,1,1,2,3,1,2,3,3,0,1];  -- Public items:  BoundsFault: PUBLIC SIGNAL = CODE;  ControlFault: PUBLIC SIGNAL [source: LONG LocalFrameHandle] = CODE;  DivideCheck: PUBLIC SIGNAL = CODE;  LinkageFault: PUBLIC ERROR = CODE;  NarrowFault: PUBLIC ERROR = CODE;  PointerFault: PUBLIC SIGNAL = CODE;  PortFault: PUBLIC ERROR = CODE;  StartFault: PUBLIC SIGNAL [dest: PROGRAM] = CODE;  UnboundProcedure: PUBLIC SIGNAL [dest: Runtime.ControlLink] = CODE;  ZeroDivisor: PUBLIC SIGNAL = CODE;  -- Private Items:    AV: PrincOps.AVHandle = PrincOps.AV;  ControlLink: TYPE = PrincOpsExtras2.ControlLink;  ShortControlLink: TYPE = PrincOps.ShortControlLink;  LongGlobalFrameHandle: TYPE = PrincOpsExtras2.LongGlobalFrameHandle;  GFTHandle: TYPE = PrincOpsExtras2.GFTHandle;  LargeReturnSlot: CARDINAL = PrincOps.LargeReturnSlot;  LocalFrameHandle: TYPE = PrincOps.LocalFrameHandle;  nullShortLink: PrincOps.ShortControlLink = [frame[NIL]];  CodeBytesPtr: TYPE = LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte;  StartTrapeeHasResults: PRIVATE SIGNAL = CODE;  -- proceedable.  UseOfUnnewedProgram: PRIVATE ERROR = CODE;  BugType: TYPE = {    codeTrapButStarted, hardwareError, interruptError, rescheduleError, stackError};  --~~~~~~~~~~ Non-trap-handler procedures, utilities: ~~~~~~~~~~    Bug: PROCEDURE [type: BugType] = {RuntimeInternal.Bug[type]};  BumpPC: PROCEDURE [f: LocalFrameHandle, i: INTEGER] = INLINE {    Frame.WritePC[lf: f, pc: [Frame.ReadPC[f] + i]]};  BumpPCOfTrapee: PROCEDURE RETURNS [    opLength: CARDINAL, op, alpha: Environment.Byte] =  --out-of-line--    BEGIN    -- Must be called directly from trap routine!    trapee: PrincOps.LocalFrameHandle =      Frame.ReadReturnLink[Frame.GetReturnFrame[]].frame;    pc: PrincOps.BytePC = Frame.ReadPC[trapee];    pCode: CodeBytesPtr =      LOOPHOLE[FrameExtras.ReadCodebase[FrameExtras.ReadGlobalLink[trapee]]];    op ¬ pCode[pc];    alpha ¬ (      IF op = Mopcodes.zESC OR op = Mopcodes.zESCL THEN pCode[pc+1]      ELSE Environment.Byte.LAST);    opLength ¬ OpcodeLengths[op];    BumpPC[trapee, opLength];    END;  GFIFromControlLinkGFI: PROCEDURE [gfi: GFTHandle]    RETURNS [GFTHandle] = INLINE --    -- Turns off the procedure tag bit which is overlaid on    -- a GlobalFrameHandle when it is part of a ControlLink.    -- SHOULD be in Frame.mesa!    {RETURN[Inline.BITAND[gfi, 177774B]]};  GFrameFromControlLinkGFrame: PROCEDURE [gf: PrincOps.GlobalFrameHandle]    RETURNS [PrincOps.GlobalFrameHandle] = INLINE --    -- same as above but for old procedure descriptors    {RETURN[Inline.BITAND[gf, 177774B]]};  NarrowFaultCall: --"PUBLIC"-- PROC =  -- (Invoked by KFCB, sNarrowFault)    {ERROR NarrowFault};  Restart: --"PUBLIC"-- PROC [program: PROGRAM] =    -- (Invoked by RESTART statement via SDDefs.sRestart.)    BEGIN    gFrame: LongGlobalFrameHandle = SpecialRuntimeExtras.GlobalFrameFromProgram[program];    stops: BOOLEAN;    lFrame: LocalFrameHandle;    Runtime.ValidateGlobalFrame[LOOPHOLE[program]];    IF ~Started[gFrame] THEN Start[program];    stops ¬ LOOPHOLE[      SpecialRuntimeExtras.Codebase[program], PrincOps.PrefixHandle].header.stops;    IF ~stops THEN ERROR StartFault[program];    IF (lFrame ¬ gFrame[0]) # PrincOps.NullLocalFrame THEN      BEGIN      Frame.WriteReturnLink[lf: lFrame, cl: Frame.GetReturnLink[]];      Frame.SetReturnFrame[lFrame];      END    END;  OKToValidateGlobalFrame: PROCEDURE RETURNS [BOOLEAN] = INLINE {    -- (Can validate if implementing module has been started.)    vgf:  rep1 ControlLink ¬ LOOPHOLE[Runtime.ValidateGlobalFrame];    gf: ControlLink ¬ vgf;    RETURN[ WITH foo: gf SELECT vgf.tag FROM      shortProc => Started[LONG[GFrameFromControlLinkGFrame[foo.gf]]],      longProc => Started[        FrameExtras.GFTHandleToLongGF[GFIFromControlLinkGFI[foo.gfi]]]      ENDCASE => ERROR ] };    Started: PROCEDURE [gf: LongGlobalFrameHandle] RETURNS [BOOLEAN] = INLINE {    RETURN[ FrameExtras.GlobalOverhead[gf].extra.started ] };  Start: --"PUBLIC"-- PROCEDURE [  --    --args for MAIN,-- program: PROGRAM]  --    --RETURNS [results from MAIN]-- =    -- (Invoked by START statement via SDDefs.sStart.)    -- Starts the control modules of the PROGRAM, then starts the PROGRAM    -- itself (if it wasn't started as a control module).    BEGIN    -- This proc both marks the global frame as started and turns its    -- code trap bit off.    -- NOTE: There are copies of some of this code in Traps and in GermOpsImpl.    -- IF YOU CHANGE one place, make corresponding changes in the other.    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..2) OF WORD,      gf: LongGlobalFrameHandle,      argsForMain: dst PrincOps.StateVector];    -- Note that Mesa has already popped program of the stack.    d.argsForMain ¬ STATE;  -- save args for MAIN.    IF program = NIL THEN      BEGIN      IF d.argsForMain.stkptr = 0 THEN RETURN  -- START <NIL> is ok.      ELSE {Bug[stackError]; ERROR ABORTED};  -- passed args to NIL program.      END;    IF OKToValidateGlobalFrame[] THEN  -- (don't start trap module Frames early!)      Runtime.ValidateGlobalFrame[LOOPHOLE[program]];    d.gf ¬ SpecialRuntimeExtras.GlobalFrameFromProgram[program];    IF d.gf  = PrincOpsExtras2.NullGlobalFrame OR Started[d.gf] THEN        StartFault[program];    StartControlList[d.gf[0], d.gf, @d.argsForMain];    IF NOT --yet-- Started[d.gf] THEN      BEGIN  -- Was NOT started by control module list. Start it now.      StartMainBody[FrameExtras.LongGFToGFTHandle[d.gf], @d.argsForMain, resultsOK];      -- any results are on stack now.      END;    -- any results are on stack now.    END;  --Start--  StartControlList: PROCEDURE [    finger: ControlModuleFormat.Finger, originalStartee: LongGlobalFrameHandle,    argsForOriginalStartee: POINTER TO dst PrincOps.StateVector] = INLINE {    -- (Perf accelerator only.)    IF finger # NIL THEN      StartNonNilControlList[finger, originalStartee, argsForOriginalStartee]};  StartNonNilControlList: PROCEDURE [    finger: ControlModuleFormat.Finger, originalStartee: LongGlobalFrameHandle,    argsForOriginalStartee: POINTER TO dst PrincOps.StateVector] =    -- Starts all control modules associated with finger, parent configs first.    BEGIN    -- NOTE: There are copies of some of this code in Traps and in GermOpsImpl.    -- IF YOU CHANGE one place, make corresponding changes in the other.    list: ControlModuleFormat.List;    originalStarteeGfi: GFTHandle;    IF finger = NIL OR finger­ = NIL THEN RETURN;        -- Start parent configs first:    StartControlList[finger­­.parent, originalStartee, argsForOriginalStartee];    -- Now start this config:    list ¬ finger­;    IF list = NIL THEN RETURN;  -- was processed while starting of parent.    -- ASSERT: list # NIL.    originalStarteeGfi ¬ PrincOpsExtras2.GFTIndexToHandle[      FrameExtras.GlobalOverhead[originalStartee].word.gfi];    finger­ ¬ NIL;  -- clear list to avoid processing twice.    FOR i: CARDINAL IN [0..list.length) DO      listItem: ControlModuleFormat.Item ¬ list.items[i];      WITH item: listItem SELECT FROM        --indirect = -- FALSE =>          BEGIN	  itemgf: LongGlobalFrameHandle = FrameExtras.GFTHandleToLongGF[item.gfi];          IF NOT Started[itemgf] THEN	      StartControlList[itemgf[0], originalStartee, argsForOriginalStartee];          IF --still-- NOT Started[itemgf] THEN	      StartMainBody[		item.gfi,		IF item.gfi = originalStarteeGfi THEN argsForOriginalStartee ELSE NIL,		noResultsAllowed]          END;        --indirect = -- TRUE =>          StartControlList[item.finger, originalStartee, argsForOriginalStartee];        ENDCASE;      ENDLOOP;    IF NOT FrameExtras.GlobalOverhead[originalStartee].extra.copied THEN  --      -- copied TEMP means gframe and thus control list was created by Loader.      Frame.Free[list];  -- (MakeBoot allocated list from frame heap.)    --ELSE someday free the list to the Loader's heap.    END;  --StartControlList--      StartMainBody: PROCEDURE [    gfi: GFTHandle, argsForMain: POINTER TO dst PrincOps.StateVector,    resultProcessing: {resultsOK, noResultsAllowed}] =    -- If results=noResultsAllowed but has results, StartTrapeeHasResults is raised.    -- Otherwise returns with any results on stack.    BEGIN    d: RECORD [  -- keeps state away from local zero.      codeBase: PrincOps.GlobalCodebase,      egw: PrincOpsExtras2.ExtraGlobalWord,      stack: dst PrincOps.StateVector];    frame: LongGlobalFrameHandle ¬ FrameExtras.GFTHandleToLongGF[gfi];    d.egw ¬ FrameExtras.GlobalOverhead[frame].extra;    d.egw.started ¬ TRUE;    FrameExtras.WriteGlobalExtra[lgf: frame, gw: d.egw];    d.codeBase ¬ FrameExtras.ReadCodebase[gfi];    d.codeBase.out ¬ FALSE;    FrameExtras.WriteCodebase[gfi: gfi, cb: d.codeBase];    IF argsForMain # NIL THEN {      d.stack ¬ argsForMain­;      STATE ¬ d.stack};  -- load args for Main body.    ControlModuleFormat.Call[ControlModuleFormat.MainBody[gfi]];    -- any results are on stack now.    IF resultProcessing = noResultsAllowed THEN {      d.stack ¬ STATE;      IF d.stack.stkptr # 0 THEN SIGNAL StartTrapeeHasResults};    END;  --StartMainBody--    StringInit: --"PUBLIC"-- PROCEDURE [coffset, n: CARDINAL, reloc, dest: POINTER] =    -- Used by compiler to initialize arrays of constant strings.    -- (Invoked by call through SD[sStringInit].)    BEGIN    gfi: GFTHandle = FrameExtras.ReadGlobalLink[Frame.GetReturnFrame[]];    gf: LongGlobalFrameHandle = FrameExtras.GFTHandleToLongGF[gfi];    codeBase: LONG POINTER = SpecialRuntimeExtras.Codebase[      SpecialRuntimeExtras.ProgramFromGlobalFrame[gf]] + coffset;    FOR k: CARDINAL IN [0..n) DO (dest + k)­ ¬ (codeBase + k)­ + reloc ENDLOOP;    END;  --StringInit--  -- ~~~~~~~~~~ Trap Handlers: ~~~~~~~~~~    -- NOTE: See note at head of module about bumping trapee's pc during trap processing.  BoundsFaultTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      trapee: PrincOps.LocalFrameHandle,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- must be first.    [] ¬ BumpPCOfTrapee[];    SIGNAL BoundsFault;    -- pc is advanced on this trap    <<When a BNDCK instruction is executed, the topmost stack WORD    is the "range" and the next WORD is the "index". When it finishes    execution, the "index" should be left on top of the stack.>>    d.state.stkptr ¬ d.state.stkptr - 1;  -- pop (#inputs-#outputs) off stack.    STATE ¬ d.state;  -- must be last.    END;  -- return to trapee to press on.  CodeTrap: --"PUBLIC"-- PROC [--args of called procedure--] =  -- "Start trap"    -- This procedure is called by the microcode via SD[sCodeTrap] (commonly    -- referred to as "start trap") when globalFrame.codeBaseLow.out=TRUE    -- during an attempt to XFER into a new context.    BEGIN    -- NOTE: There are copies of some of this code in Traps and in GermOpsImpl.    -- IF YOU CHANGE one place, make corresponding changes in the other.    -- We use globalFrame.word.started=TRUE to indicate    -- (to us and to the debugger) that that global    -- frame is being started by us. The global frame is simultaneously    -- marked codeBaseLow.out=FALSE.    -- A typical scenario is as follows:    -- The client calls a (non-MAIN) procedure in an unstarted module - which    -- has codeBaseLow.out=TRUE and globalFrame.word.started=FALSE.    -- It traps to here. We verify that we have not attempted to start    -- this module, and so call Start, which starts the control modules    -- associated with the globalFrame, then marks the    -- globalFrame.word.started=TRUE and globalFrame.codeBaseLow.out=FALSE    -- and calls the MAIN of the globalFrame to actually start it.    -- Then this procedure returns to the client who will re-execute his call    -- to the (non-MAIN) procedure in the module.    d: RECORD [  -- keeps state away from trap params.      trapee: LocalFrameHandle,      gfi: GFTHandle,      dest: ControlLink,  -- procedure being called.      opLength: INTEGER,      codeBase: PrincOps.PrefixHandle,      state: dst PrincOps.StateVector];  -- holds args of called procedure.    gFrame: LongGlobalFrameHandle;    d.state ¬ STATE;  -- save args for called proc. Must be first.    d.gfi ¬ Trap.Parameter[];  -- Must be second.    gFrame ¬ FrameExtras.GFTHandleToLongGF[d.gfi];    d.trapee ¬ Frame.GetReturnFrame[];    d.opLength ¬ BumpPCOfTrapee[].opLength;    d.codeBase ¬ Inline.DBITAND[LOOPHOLE[      FrameExtras.ReadCodebase[d.gfi]], 3777777776B];    IF d.codeBase = NIL THEN  --      -- (UnNew sets gFrame's codeBase to NIL when a gframe is freed.)      ERROR UseOfUnnewedProgram;    IF --already-- Started[gFrame] THEN Bug[codeTrapButStarted];    Start[SpecialRuntimeExtras.ProgramFromGlobalFrame[gFrame]];    BumpPC[d.trapee, -d.opLength];    STATE ¬ d.state;  -- Must be last.    END;  -- Return to trapee (he retries).  ControlTrap: PROC =    -- Invoked by xfer to null local frame.    -- Can happen during normal coroutine initialization.    BEGIN    argsForRespondingCoroutine: dst PrincOps.StateVector;    sourceLink: ShortControlLink;    trapee: LocalFrameHandle;    op, alpha: Environment.Byte;    argsForRespondingCoroutine ¬ STATE;  -- Must be first.    sourceLink ¬ Trap.Parameter[];  -- Must be second.    trapee ¬ Frame.GetReturnFrame[];    [op: op, alpha: alpha] ¬ BumpPCOfTrapee[];    BEGIN  --scope of OrdinaryFault--    IF op = Mopcodes.zESC AND      (alpha = ESCAlpha.aPO OR alpha = ESCAlpha.aPOR) THEN      BEGIN  --was calling out through a port--      -- SEE Mesa Lang Manual pp 148..150, especially page 150.       pSourcePort: PrincOps.PortHandle;      IF argsForRespondingCoroutine.stkptr < SIZE[PrincOps.PortHandle] THEN  --        GOTO OrdinaryFault;  -- control trap caused by other trap caused by port call.      pSourcePort ¬  -- must be a portHandle since was a PO instruction.        argsForRespondingCoroutine.stk[	  argsForRespondingCoroutine.stkptr - SIZE[PrincOps.PortHandle]];      IF sourceLink # [indirect[port[pSourcePort]]] THEN  --        GOTO OrdinaryFault;  -- control trap caused by other trap caused by port call.      --ASSERT: Control trap was caused directly by the original port call.      IF pSourcePort.dest.port = NIL THEN  --	ERROR LinkageFault;  -- source port not connected at all. See AR 4214.      --ASSERT:  sourcePort is not conected to a proc;      --  if it was, we could not get a ControlTrap.      IF NOT pSourcePort.dest.indirect  -- port conected to frame      --ASSERT:  sourcePort is not conected to a link to a proc;      --  if it was, we could not get a ControlTrap.      OR pSourcePort.dest.link.indirect  -- port conected to link to link        THEN GOTO OrdinaryFault;  -- port not connected to another port.      -- ASSERT: sourcePort is connected to a null frame.      --  We assume the frame is the first component of another port      --  with no frame pending on it (yet).       -- Make trapee pending on source port: (simulate PO/POR instruction)      -- (Note: pc already saved by trap.)      pSourcePort.frame ¬ trapee;      argsForRespondingCoroutine.stkptr ¬  -- pop @port off stack.        argsForRespondingCoroutine.stkptr - SIZE[PrincOps.PortHandle];            IF argsForRespondingCoroutine.stkptr > 0 AND alpha = ESCAlpha.aPO THEN        BEGIN  --non-RESPONDING port, with arguments--	-- Must buffer arguments for later. See MLM page 150.	RaisePortFaultRetainingControlTrapsFrame: PROC = --out-of-line-- {	  -- Signal goes to this proc, then trapee's caller.	  -- Frame of ControlTrap and trapee stays allocated.	  Frame.SetReturnLink[Frame.ReadReturnLink[trapee]];	  ERROR PortFault};        PortIn: PROC = MACHINE CODE {Mopcodes.zESC, ESCAlpha.aPI};		sourceDest: PrincOpsExtras.SourceDest;        pSourcePort.frame ¬ Frame.MyLocalFrame[];  -- Make me pending on source port        RaisePortFaultRetainingControlTrapsFrame[];	-- At this point, we have been resumed because the dest port has been	-- called by the client; it is connected to the source port	-- and we are pending on the source port.        PortIn[];  -- must be first following port return.        pSourcePort.frame ¬ trapee;  -- put trapee back pending on his port.	sourceDest.source ¬ [frame[trapee]];  -- will retry original port call.        sourceDest.dest ¬ [indirect[port[pSourcePort]]];        STATE ¬ argsForRespondingCoroutine;  -- must be next-to-last.	-- Call source port with original arguments, freeing our frame as we go.	RETURN WITH sourceDest;  -- must be last.        END  --non-RESPONDING port, with arguments--      ELSE  -- No arguments or RESPONDING port. Don't buffer arguments.        BEGIN        -- Signal goes to this proc, then trapee's caller.        -- Frame of trapee stays allocated.        Frame.SetReturnLink[Frame.ReadReturnLink[trapee]];	ERROR PortFault;	END;      END  --was calling out through a port--    ELSE GOTO OrdinaryFault; --caller was NOT calling out through a port--    EXITS      OrdinaryFault =>        BEGIN        IF SDDefs.SD[SDDefs.sSignal] = 0 THEN  -- no signaller yet.          DO --FOREVER--	  ProcessorFace.SpecialSetMP[PilotMP.cEarlyTrap];	  ENDLOOP        ELSE ERROR ControlFault[trapee];	END;    END;  --scope of OrdinaryFault--    END;  --ControlTrap--  DivideCheckTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;    [] ¬ BumpPCOfTrapee[];    SIGNAL DivideCheck;    -- pc is advanced on this trap.    d.state.stkptr ¬ d.state.stkptr - 1;  -- pop range off stack.    STATE ¬ d.state;  -- must be next-to-last.    RETURN;  -- press on.    END;  HardwareErrorTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack.    [] ¬ BumpPCOfTrapee[];    Bug[hardwareError];  -- continuing is not supported.    ERROR ABORTED;   -- If the operator tells debugger to Proceed.    END;  InterruptErrorTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack.    [] ¬ BumpPCOfTrapee[];    Bug[interruptError];  -- continuing is not supported.    ERROR ABORTED;   -- If the operator tells debugger to Proceed.    END;  PointerFaultTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;    [] ¬ BumpPCOfTrapee[];    SIGNAL PointerFault;    -- pc is advanced on this trap.    STATE ¬ d.state;    END;  RescheduleErrorTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack.    [] ¬ BumpPCOfTrapee[];    Bug[rescheduleError];  -- continuing is not supported.    ERROR ABORTED;   -- If the operator tells debugger to Proceed.    END;  StackErrorTrap: PROC =    BEGIN    op, alpha: Environment.Byte;    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack.    [op: op, alpha: alpha] ¬ BumpPCOfTrapee[];    -- Bug[stackError];   continuing is not supported.    IF op = MopcodesExtras.zSTC THEN       Runtime.CallDebugger["Stack Check"]    ELSE       Runtime.CallDebugger["Stack Error"];    d.state.stkptr ¬ 0;    STATE ¬ d.state;    ERROR ABORTED;   -- If the operator tells debugger to Proceed.    END;      UnboundProcedureTrap: PROC =    BEGIN    d: RECORD [  -- keeps state away from trap params.      keepStateAwayFromLocalZero: WORD,      dest: Runtime.ControlLink,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack. Must be first.    d.dest ¬ Trap.LongParameter[];  -- must be second.    [] ¬ BumpPCOfTrapee[];    ERROR UnboundProcedure[d.dest];    END;  ZeroDivisorTrap: PROC =    BEGIN    d: RECORD [  -- keeps state away from local zero.      keepStateAwayFromLocalZero: WORD,      alpha: Environment.Byte,      trapee: PrincOps.LocalFrameHandle,      state: dst PrincOps.StateVector];    d.state ¬ STATE;    d.trapee ¬ Frame.GetReturnFrame[];    --ASSERT: there are no one-byte divide opcodes.    d.alpha ¬ BumpPCOfTrapee[].alpha;    SIGNAL ZeroDivisor;    -- pc is advanced on this trap    d.state.stkptr ¬ d.state.stkptr -  -- pop excess args off stack.      (SELECT d.alpha FROM        ESCAlpha.aLUDIV => 3-1,  -- single¬double/single        ESCAlpha.aSDDIV => 4-2,  -- double¬double/double        ESCAlpha.aUDDIV => 4-2,  -- double¬double/double        ESCAlpha.aSDIV => 2-1,  --single¬single/single        ESCAlpha.aUDIV => 2-1,  --single¬single/single        ENDCASE => ERROR);    STATE ¬ d.state;    END;  -- press on.    BytePointerTrap: PROC =    BEGIN    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;  -- clear the stack.    [] ¬ BumpPCOfTrapee[];    Runtime.CallDebugger["Byte Pointer Trap"];    STATE ¬ d.state;    END;    -- Main body - initialization:  BEGIN  egw: PrincOpsExtras2.ExtraGlobalWord ¬     FrameExtras.GlobalOverhead[FrameExtras.MyGlobalFrame[]].extra;  egw.started ¬ TRUE;  -- mark self started.  FrameExtras.WriteGlobalExtra[lgf: FrameExtras.MyGlobalFrame[], gw: egw];  SDDefs.SD[SDDefs.sBoundsTrap] ¬ LOOPHOLE[BoundsFaultTrap];  SDDefs.SD[SDDefs.sCodeTrap] ¬ LOOPHOLE[CodeTrap];  SDDefs.SD[SDDefs.sControlTrap] ¬ LOOPHOLE[ControlTrap];  SDDefs.SD[SDDefs.sDivCheckTrap] ¬ LOOPHOLE[DivideCheckTrap];  SDDefs.SD[SDDefs.sDivZeroTrap] ¬ LOOPHOLE[ZeroDivisorTrap];  SDDefs.SD[SDDefs.sHardwareError] ¬ LOOPHOLE[HardwareErrorTrap];  SDDefs.SD[SDDefs.sInterruptError] ¬ LOOPHOLE[InterruptErrorTrap];  SDDefs.SD[SDDefs.sPointerTrap] ¬ LOOPHOLE[PointerFaultTrap];  SDDefs.SD[SDDefs.sRescheduleError] ¬ LOOPHOLE[RescheduleErrorTrap];  SDDefs.SD[SDDefs.sRestart] ¬ LOOPHOLE[Restart];  SDDefs.SD[SDDefs.sStackError] ¬ LOOPHOLE[StackErrorTrap];  SDDefs.SD[SDDefs.sStart] ¬ LOOPHOLE[Start];  SDDefs.SD[SDDefs.sStringInit] ¬ LOOPHOLE[StringInit];  SDDefs.SD[SDDefs.sUnboundTrap] ¬ LOOPHOLE[UnboundProcedureTrap];  SDDefs.SD[SDDefs.sNarrowFault] ¬ LOOPHOLE[NarrowFaultCall];  SDDefs.SD[SDDefsExtras.sBytePointerTrap] ¬ LOOPHOLE[BytePointerTrap];  END;    END.LOG  (For earlier entries, please see Mesa 10.0 archive version)17-Nov-81 17:59:42   JGS	Fix StartWithState to not free caller. 8-Dec-81 11:49:44   JGS	Fix StartControlList to check start control module.13-Jan-82 11:28:48   CRF/RXJ        Fix PC advance in various traps.25-Jan-82 17:43:44   CRF   Replaced out of date OpcodeLengths array with new one; added RescheduleErrorTrap   and got rid of WakeUpErrorTrap; fixed ControlTrap to copy Trap.Parameter   early enough and raise LinkageFault correctly (don't push message). 2-Feb-82 15:37:32   JGS   Replace TRANSFER WITH state by RETURN WITH state in ControlTrap.17-Feb-82 11:56:19   AWL      	Turn on our gloabl frame's "started" bit explicitly. 4-Oct-82 10:24:34   WDK        Changed HardwareError, InterruptError, RescheduleError, StackError from SIGNALs into Bug's. 9-Nov-82 14:01:32   WDK        Raise ABORTED if continue after stack error.   Turn off code trap bit when module marked started. 1-Apr-83 14:23:14   AWL      	Add in Sierra implementation of NarrowFault.11-Apr-83 11:26:21   JXP   	No longer use obselete SDExtraExtra interface.13-Jul-83 15:18:32   WDK        Make compatible with new PrincOps. New OpcodeLengths.18-Jul-83 11:46:22   JXP      Update to use new ControlModuleFormat interface. Make StartWithState work with   new form of state vectors. Fix ControlFault to get the right things on the   stack.20-Jul-83 14:39:40   JXP      Get MainBody from RuntimeInternal instead of ControlModuleFormat.28-Jul-83 11:12:49   WDK        GetCodeBytes becomes out-of-line saves 60 code bytes. Start no longer public. Improved documentation. Delete fallacious error check in Start. Ditch blanket OPEN. Bum out xfer to StartControlList if NIL finger. Eliminate unnecessary procedure StartWithState. Complain if startee returns values.  Eliminate sneaky little inline procs with side effects. Eliminate spurious pop in BoundsFaultTrap. CodeTrap forgot to unbump pc at end. Redo/improve/document PortFault logic. ZeroDivisorTrap didn't handle all opcodes. Eliminate redundant code for starting main body. BoundsFaultTrap didn't clean range arg off stack. Use common routine to bump pc of trapee. 9-Aug-83 17:30:26   WDK        Detect use of obsolete global frame (start trap). Arg of Start and Restart is PROGRAM. Use PrincOpsExtras and type converters. Start and Restart now validate gFrame early. 7-Sep-83 10:00:27   WDK     	Don't Frame.Free loaded control lists. 7-Oct-83 10:35:42   WDK        AR 4586: Only pop one word for bounds trap. Eliminate proc only called once. START[NIL] should be no-op.19-Jun-86 10:27:51   MEW  Added bytePointerTrap. Rolled ControlModuleFormat, Frame stuff and PrincOps stuff forward to allow global frames out of the MDS.18-Sep-87  6:58:30   ET  Changed CodeTrap to call FrameExtras.ReadCodeBase directly. 
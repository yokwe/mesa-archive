-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- PilotPerfMonitor.mesa, last edited by-- RSV/AHL      19-Feb-87 13:52:51 Converted to MDS relief.-- AXD    	28-Sep-83 21:26:40DIRECTORY  CPSwapDefs: TYPE USING [    BreakpointHandlerItem, BreakpointHandlerPtr, BreakpointHandlerType,    ExternalStateVector, OperandDesc, PESV, UBBPointer, UserBreakBlock],  DebuggerSwap: TYPE USING [AwaitDebuggerRequest, SetDebuggerFielder],  Environment: TYPE USING [LongNumber],  Frame: TYPE USING [GetReturnFrame, MyLocalFrame, ReadPC],  FrameExtras: TYPE USING [ReadCodebase, ReadGlobalLink],  Inline,  PerformancePrograms: TYPE USING [],  PerfPrivate: TYPE USING [    HistIndex, Histogram, HistSpaceSize, Leg, LegTab, MaxLegs, MaxNodes, Node,    NodeID, NodeIndex, NodeTab, NullHist, NullID, NullNode, PerfControlRecord,    SubLegIndex, SubNodeIndex, VersionID],  PrincOps: TYPE USING [    BYTE, LocalFrameHandle, NullLocalFrame, StateVector],  PrincOpsExtras2: TYPE USING [ControlLink, NullLink],  PrincOpsExtras: TYPE USING [SourceDest],  ProcessOperations: TYPE USING [DisableInterrupts, ReadPSB],  ProcessorFace: TYPE USING [microsecondsPerHundredPulses],  PSB: TYPE USING [NullPsbHandle],  RuntimeInternal: TYPE USING [GetOperand],  SDDefs: TYPE USING [SD, sPerfMonitor],  SpecialSpace: TYPE USING [    MakeGlobalFrameResident, MakeProcedureResident, SpecialError],  System: TYPE USING [GetClockPulses],  XferTrap: TYPE USING [ReadXTS, WriteXTS];  PilotPerfMonitor: PROGRAM   IMPORTS    CPSwapDefs, DebuggerSwap, Frame, FrameExtras, Inline, ProcessOperations,    ProcessorFace, RuntimeInternal, SpecialSpace, System, XferTrap   EXPORTS PerformancePrograms =   BEGIN OPEN PerfPrivate;    BreakBlock: TYPE = MACHINE DEPENDENT RECORD [    count: CARDINAL, blocks: ARRAY [0..MaxNodes) OF CPSwapDefs.UserBreakBlock];  -- ­ should match CPSwapDefs.BBArray    controlRecord: PerfControlRecord ¬ [    version: VersionID, measuringNow: FALSE, newSession: TRUE, addLeg: none,    trackLeg: all, totalBreaks: 0, perfTime: 0, totalTime: 0,    self: PrincOps.NullLocalFrame, saveBreakHandler: PrincOpsExtras2.NullLink,    nextNode: 0, process: PSB.NullPsbHandle, nodeTable: @nodeTab, nextLeg: 0,    legTable: @legTab, lastID: NullNode, histBase: @hists, lastCall: normal,    histFree: HistIndex.FIRST, breakBlocks: LOOPHOLE[@breakBlock],    pulseConversion: ProcessorFace.microsecondsPerHundredPulses,    saveBreakBlocks: NIL];      legTab: LegTab;    nodeTab: NodeTab;    hists: ARRAY [0..HistSpaceSize) OF UNSPECIFIED ¬ ALL[0];    breakBlock: BreakBlock ¬ [    MaxNodes, ALL[      [codeBase: NIL, pc: [0], inst: 0, relation: eq,      leftOperand: [fieldPosition: 0, fieldSize: 1, vp: counter[timesSoFar: 0]],      rightOperand: [        fieldPosition: 0, fieldSize: 1, vp: counter[timesSoFar: 0]]]]];    breakHandler: CPSwapDefs.BreakpointHandlerItem;    -- Initialization and control    InitializePilotPerfMonitor: PUBLIC PROC = {};    ReallyInitialize: PROC = {    esv: LONG POINTER TO CPSwapDefs.ExternalStateVector = CPSwapDefs.PESV[];    df: POINTER TO DebuggerSwap.AwaitDebuggerRequest;    SDDefs.SD[SDDefs.sPerfMonitor] ¬ LOOPHOLE[@controlRecord];    FOR i: SubNodeIndex IN SubNodeIndex DO       nodeTab[i] ¬ [id: NullID, hits: 0, hist: NullHist] ENDLOOP;    FOR i: SubLegIndex IN SubLegIndex DO      legTab[i] ¬ [        start: 0, from: NullNode, to: NullNode, longest: 0,	shortest: LAST[LONG CARDINAL], owner: PSB.NullPsbHandle, hits: 0, sum: 0,	lock: FALSE, someIgnored: FALSE, hist: NullHist];      ENDLOOP;    SpecialSpace.MakeProcedureResident[MonitorBreaks      ! SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE	ELSE REJECT];    SpecialSpace.MakeGlobalFrameResident[PilotPerfMonitor      ! SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE	ELSE REJECT];    controlRecord.saveBreakBlocks ¬ esv.breakBlocks;    esv.breakBlocks ¬ LOOPHOLE[@breakBlock];    MonitorBreaks[];    breakHandler ¬ [      handler: [frame[frame: controlRecord.self]],      type: CPSwapDefs.BreakpointHandlerType[spareA],      next: esv.breakpointHandlers];    esv.breakpointHandlers ¬ @breakHandler;    df ¬ DebuggerSwap.SetDebuggerFielder[NIL];    [] ¬ DebuggerSwap.SetDebuggerFielder[df];    debuggerFielder ¬ LOOPHOLE[LONG[df]]};    -- Break Handler and friends    ReturnLink: PROC RETURNS [PrincOpsExtras2.ControlLink] = INLINE {    RETURN[PrincOpsExtras2.ControlLink[frame[frame: Frame.GetReturnFrame[]]]]};    debuggerFielder: PROCEDURE [LONG POINTER TO CPSwapDefs.ExternalStateVector];  MonitorBreaks: PROC [] RETURNS [] = {    xc: PrincOpsExtras.SourceDest;    state: dst PrincOps.StateVector;    cr: LONG POINTER TO PerfControlRecord;    timeOnEntry: LONG CARDINAL;    lastPerfEntry: LONG CARDINAL;    state ¬ STATE;    xc.dest ¬ LOOPHOLE[ReturnLink[]];    cr ¬ @controlRecord;    cr.self ¬ Frame.MyLocalFrame[];    ProcessOperations.DisableInterrupts[];    DO      lastExit, lastOverhead, lastEntry: LONG CARDINAL;      nodeID: NodeID;      node: LONG POINTER TO Node;      id: NodeIndex;      frame: PrincOps.LocalFrameHandle;      breakType: {perf, normal, other};      ubb: CPSwapDefs.UBBPointer;            IF XferTrap.ReadXTS[] = on THEN XferTrap.WriteXTS[skip1];      lastEntry ¬ timeOnEntry;      lastExit ¬ System.GetClockPulses[];      STATE ¬ state;      TRANSFER WITH xc;      state ¬ STATE;      timeOnEntry ¬ System.GetClockPulses[];      xc.dest ¬ LOOPHOLE[ReturnLink[]];      frame ¬ xc.dest.frame;            IF NOT cr.measuringNow THEN {        lastEntry ¬ lastExit; lastPerfEntry ¬ timeOnEntry};      lastOverhead ¬ lastExit - lastEntry;      lastPerfEntry ¬ lastPerfEntry + lastOverhead;      IF cr.lastCall = perf THEN {        cr.perfTime ¬ cr.perfTime + lastOverhead;	cr.totalTime ¬ cr.totalTime + lastOverhead}      ELSE        FOR leg: LONG POINTER TO Leg ¬ @legTab[0], leg + Leg.SIZE	  UNTIL leg = @legTab[cr.nextLeg] DO	  IF leg.owner # PSB.NullPsbHandle THEN 	    leg.start ¬ leg.start + lastOverhead;	  ENDLOOP;      nodeID ¬ [pc: Frame.ReadPC[frame], gfi: FrameExtras.ReadGlobalLink[frame]];      breakType ¬ normal;      FOR i: CARDINAL IN [0..breakBlock.count) DO	ubb ¬ @breakBlock.blocks[i];	IF ubb.pc = nodeID.pc	AND ubb.codeBase = FrameExtras.ReadCodebase[nodeID.gfi].codebase THEN {	  state.instbyte ¬ ubb.inst;	  node ¬ @nodeTab[0];	  IF cr.process # PSB.NullPsbHandle	  AND cr.process # ProcessOperations.ReadPSB[] THEN GOTO notMe;	  FOR id IN [0..cr.nextNode) DO	    IF nodeID = node.id THEN GOTO foundEntry;	    node ¬ node + Node.SIZE;	    ENDLOOP;	  IF cr.nextNode < MaxNodes THEN {	    id ¬ cr.nextNode;	    cr.nextNode ¬ cr.nextNode.SUCC;	    node­ ¬ [id: nodeID, hits: 0, hist: NullHist];	    GOTO foundEntry}	  ELSE GOTO notMe};	REPEAT	  notMe => breakType ¬ other;	  foundEntry => {	    breakType ¬ perf;	    node.hits ¬ node.hits.SUCC;	    IF node.hist # NullHist AND NOT (ubb.leftOperand.type = counter) THEN 	      UpdateHistogram[	        @cr.histBase[node.hist],		RuntimeInternal.GetOperand[@ubb.leftOperand, frame, @state]]};	ENDLOOP; -- nodes taken care of            IF breakType = perf THEN {        lastLegTime: LONG CARDINAL = timeOnEntry - lastPerfEntry;	cr.totalTime ¬ cr.totalTime + lastLegTime;	IF cr.trackLeg # none THEN {	  stillMustDoLastLeg: BOOLEAN ¬ TRUE;	  FOR leg: LONG POINTER TO Leg ¬ @legTab[0], leg + Leg.SIZE	    UNTIL leg = @legTab[cr.nextLeg] DO	    IF leg.owner # PSB.NullPsbHandle THEN {	      leg.start ¬ leg.start + lastOverhead;	      IF id = leg.to THEN {	        IF leg.owner # ProcessOperations.ReadPSB[] THEN 	          leg.someIgnored ¬ TRUE	        ELSE {	          timeSpent: LONG CARDINAL;	          leg.owner ¬ PSB.NullPsbHandle;		  IF cr.lastID = leg.from THEN stillMustDoLastLeg ¬ FALSE;		  leg.hits ¬ leg.hits.SUCC;		  timeSpent ¬ timeOnEntry - leg.start;		  leg.sum ¬ leg.sum + timeSpent;		  leg.longest ¬ MAX[leg.longest, timeSpent];		  leg.shortest ¬ MIN[leg.shortest, timeSpent];		  IF leg.hist # NullHist THEN		    UpdateHistogram[@cr.histBase[leg.hist], timeSpent]}}	      ELSE IF cr.trackLeg = successor THEN leg.owner ¬ PSB.NullPsbHandle};	    IF id = leg.from THEN {	      leg.start ¬ timeOnEntry;	      IF leg.owner # PSB.NullPsbHandle THEN leg.someIgnored ¬ TRUE;	      leg.owner ¬ ProcessOperations.ReadPSB[]};	    ENDLOOP;	  IF cr.addLeg = successor AND stillMustDoLastLeg AND cr.measuringNow 	    THEN {	    free: BOOLEAN ¬ FALSE;	    leg: LONG POINTER TO Leg;	    FOR leg ¬ @legTab[0], leg + Leg.SIZE	      UNTIL leg = @legTab[cr.nextLeg] DO	      IF NOT leg.lock AND leg.from = NullNode THEN {free ¬ TRUE; EXIT};	      ENDLOOP;	    IF NOT free AND cr.nextLeg < MaxLegs THEN {	      leg ¬ @legTab[cr.nextLeg];	      cr.nextLeg ¬ cr.nextLeg.SUCC;	      free ¬ TRUE};	    IF free THEN {	      leg­ ¬ [	        start: timeOnEntry, from: cr.lastID, to: id, lock: FALSE,		someIgnored: FALSE, longest: lastLegTime, shortest: lastLegTime,		owner: PSB.NullPsbHandle, hits: 1, sum: lastLegTime,		hist: NullHist];	      IF id = cr.lastID THEN leg.owner ¬ ProcessOperations.ReadPSB[];	      stillMustDoLastLeg ¬ FALSE}}}}; -- done processing legs            SELECT breakType FROM        perf => {	  cr.lastID ¬ id;	  cr.measuringNow ¬ TRUE;	  cr.totalBreaks ¬ cr.totalBreaks.SUCC;	  lastPerfEntry ¬ timeOnEntry;	  cr.lastCall ¬ perf};	normal => {	  instByteFromDebugger: PrincOps.BYTE;	  esv: LONG POINTER TO CPSwapDefs.ExternalStateVector =	    CPSwapDefs.PESV[];	  esv.swapData ¬ [	    lFrame: frame, process: TRASH,	    mayCallDebuggee: FALSE, trashWasOnStack: FALSE, fillA: TRASH,	    body: breakpoint[	      sv: @state, instByteReceptacle: @instByteFromDebugger]];	  debuggerFielder[esv];	  state.instbyte ¬ instByteFromDebugger};	ENDCASE => cr.lastCall ¬ normal;      ENDLOOP};    UpdateHistogram: PROC [    hist: LONG POINTER TO Histogram, value: LONG CARDINAL] = {    hist.count ¬ hist.count.SUCC;    hist.sum ¬ hist.sum + value;    IF hist.base > value THEN hist.underflow ¬ hist.underflow.SUCC    ELSE {      longval: Environment.LongNumber;      word: INTEGER;      bucket: CARDINAL;      value ¬ value - hist.base;      longval.lu ¬ Inline.DBITSHIFT[value, -hist.scale];      IF hist.class = log THEN        SELECT TRUE FROM	  (word ¬ longval.highbits) # 0  =>	    FOR bucket DECREASING IN [16..31] DO	      IF word < 0 THEN EXIT; word ¬ word*2; ENDLOOP;	  (word ¬ longval.lowbits) # 0 =>	    FOR bucket DECREASING IN [0..15] DO	      IF word < 0 THEN EXIT; word ¬ word*2; ENDLOOP;	  ENDCASE => bucket ¬ 0      ELSE bucket ¬        IF longval.highbits # 0 THEN hist.nBuckets ELSE longval.lowbits;      IF bucket < hist.nBuckets THEN        hist.buckets[bucket] ¬ hist.buckets[bucket].SUCC      ELSE hist.overflow ¬ hist.overflow.SUCC}};    ReallyInitialize[];    END.
-- Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989  by Xerox Corporation. All rights reserved. -- FileBasics>VolAllocMapImpl.mesa     17-Jan-89 17:11:04 by RSV      -- NOTE: This Module is a MONITOR to protect the space used as a buffer for-- the VAM. The Logical Volume Root Page must be protected by the caller.-- See VolTable for the method of locking the root page.-- TO CONSIDER: The current implementation of MapVamPage assumes that the VAM-- does not cross SV boundaries. This is currently a good assumption, but should-- be fixed in the future. Also, we may want to have multple VAM buffers someday,-- maybe one per online logical volume.DIRECTORY  DataTransfer USING [WriteData],  DiskBackingStore USING [ChannelHandle, Data, Transfer, UnpackFilePageNumber],  DiskChannel USING [goodCompletion, IOStatus],  Environment USING [bitsPerWord, PageCount, PageNumber, wordsPerPage],  File USING [ID, PageCount, PageNumber],  FileBasicsPerf USING [],  FileBasicsPrograms USING [],  FileLock USING [lockingEnabled, nullLockHandle],  Inline USING [LowHalf],  KernelFile USING [Descriptor, FilePtr, PageGroup],  KernelObjAlloc USING [    AllocateAt, AlreadyAllocated, FindBackwardFreeRange, FindFreeRange],  KernelSpaceUsage USING [volumeAllocationMap],  LogicalVolumeFormat USING [    Descriptor, Free, Handle, tVolumeAllocationMap, Vam],  ObjAlloc USING [    AllocFree, AllocPoolDesc, AlreadyFreed, ExpandAllocation,    Free, Interval, ItemCount],  PhysicalVolume USING [PageNumber],  PilotFileTypes USING [tFreePage, tVolumeAllocationMap],  PilotSwitchesExtra7 USING [noWriteOnDelete],  RuntimeInternal USING [Bug],  Space USING [LongPointerFromPage],  StoragePrograms USING [AllocateVM],  System USING [switches],  VM USING [    BackingStoreRuns, ForceOut, Interval, Map, nullInterval, PageCount, Unmap],  VolAllocMap USING [BufferDispostion, BusyFree, PrevState, ReadOnlyGroupPtr],  VolTable USING [FindSV, LVToken, SVDesc],  Volume USING [ID, InsufficientSpace, nullID, PageCount, PageNumber];VolAllocMapImpl: MONITOR  IMPORTS    DataTransfer, DiskBackingStore, FileLock, Inline, KernelObjAlloc,    LogicalVolumeFormat, ObjAlloc, RuntimeInternal, Space, StoragePrograms,    System, VM, VolTable, Volume  EXPORTS FileBasicsPerf, FileBasicsPrograms, VolAllocMap =  BEGIN    -- PARAMETERS:  debug: BOOLEAN ¬ FALSE;  -- controls extra checking.  -- ASSERTION:  -- Many of the support routines assume that there is one bit per allocation  -- item. This is of primary importance in knowing how much of the VAM to map  -- at a time and also must be true so that SearchVamRange can use carry  -- values consistently in conjunction with KernelObjAlloc.FindFreeRange[].  oneBitPerAllocItem: BOOLEAN [TRUE..TRUE] =    (LOOPHOLE[FIRST[ObjAlloc.AllocFree], CARDINAL] = 0)    AND (LOOPHOLE[LAST[ObjAlloc.AllocFree], CARDINAL] = 1);  -- TYPEs:  FilePtr: TYPE = KernelFile.FilePtr;  GroupPtr: TYPE = POINTER TO KernelFile.PageGroup;  LvHandle: TYPE = LogicalVolumeFormat.Handle;  OffsetInWord: TYPE = [0..bitsPerWord);  -- NOTE: The following is a form of implicit LOOPHOLE which relies  -- on the oneBitPerAllocItem assertion stated above.  MultiView: TYPE = RECORD [    SELECT OVERLAID * FROM    array => [arr: PACKED ARRAY OffsetInWord OF ObjAlloc.AllocFree],    word => [wordVal: WORD],    ENDCASE];  AllocationSideType: TYPE = {left, right};  -- Constants:  bitsPerWord: CARDINAL = Environment.bitsPerWord;  wordsPerPage: CARDINAL = Environment.wordsPerPage;  bitsPerPage: CARDINAL = (bitsPerWord * wordsPerPage);  dataError: DiskChannel.IOStatus = [disk[dataCRCError]];  allAllocated: MultiView = [array[ALL[alloc]]];  -- VAM Buffer. It is this buffer and its associated Variables  -- which are protected by the monitor.  buffer: VM.Interval;  bufferPointer: LONG POINTER;  defualtBufferSize: Environment.PageCount = 114;  -- Enough pages for a T300 disk.  -- side to allocate from  side: AllocationSideType ¬ left;  -- The following record describes what is currently in the VAM Buffer.  -- Whenever lvID~=Volume.nullID, the buffer is (being) mapped. Therefore,  -- if the ID is wrong and non-null, one can automatically unmap. See  -- Close[], MapVamPage[].  in: RECORD [  -- Describes what is currently in the buffer.    lvID: Volume.ID,    firstMapped: Volume.PageNumber,    lastMapped: Volume.PageNumber,    wordsMapped: LONG CARDINAL,    allMapped: BOOLEAN];  totalAllocs: PUBLIC LONG CARDINAL ¬ 0;  -- total number of allocate requests through the interface.  totalFrees: PUBLIC LONG CARDINAL ¬ 0;  -- total number of free requests through the interface.  expands: PUBLIC LONG CARDINAL ¬ 0;  -- the number of allocate requests in which the new pages provided  -- were contiguous to the last page group in the file. Note that File  -- Creates never look like expansions. To get a true percentage  -- of contiguous expansions use:  --   % = expands/(totalAllocs - number of File.Creates)   -- ERRORs and BugTypes  BugType: TYPE = {    duplicateSet, impossibleCase, impossibleEndcase, svNotFound,    unexpectedAllocationError, unexpectedError};      --================== Initialization:  InitVolAllocMap: PUBLIC --FileBasicsPrograms.-- PROCEDURE =    -- To change the buffer size from the debugger, simply break point before    -- the storage is allocated and update the value of the local var. bufferSize.    BEGIN    bufferSize: Environment.PageCount ¬ defualtBufferSize;    buffer ¬ [      page: StoragePrograms.AllocateVM[      count: bufferSize, location: hyperspace,      usage: KernelSpaceUsage.volumeAllocationMap,      mapping: partiallyOrSometimesMapped], count: bufferSize];    bufferPointer ¬ Space.LongPointerFromPage[buffer.page];    in ¬ [Volume.nullID, , , , FALSE];    END;  --================== PUBLIC PROCEDUREs:  AllocPageGroup: PUBLIC ENTRY PROCEDURE [    vol: LvHandle, filePtr: FilePtr, groupPtr: GroupPtr, data: VM.Interval,    tok: VolTable.LVToken] =    -- Allocate a group of pages and write labels. The group pointed to by    -- groupPtr is a modifiable hint.    BEGIN OPEN g: groupPtr;    status: DiskChannel.IOStatus;    needed: LONG CARDINAL ¬ g.nextFilePage - g.filePage;    range: ObjAlloc.Interval;    startPage: Volume.PageNumber ¬      IF g.volumePage >= vol.volumeSize THEN 0 ELSE g.volumePage;    IF g.volumePage = startPage AND BitState[vol, startPage] = free THEN      range ¬ ExpandAllocation[vol, startPage, needed]    ELSE  -- There is no hole after the previous page group.      BEGIN      -- initial search on one side or other of middle      range ¬ SearchVamRange[vol: vol, holeSize: needed];      IF range.count < needed THEN        -- now check on the other side of the middle (remember that 	-- SearchVamRanges does a FlipAllocator[])        BEGIN	newRange: ObjAlloc.Interval ¬ SearchVamRange[vol: vol, holeSize: needed];	IF newRange.count > range.count THEN	  BEGIN	  FlipAllocator[vol];  -- have to flip it back	  range ¬ newRange;	  END;        END;      IF range.count = 0 THEN        RETURN WITH ERROR Volume.InsufficientSpace[0, vol.vID];      SetPageGroupInternal[vol, range, busy, mightBeSetAlready];      END;    -- At this point we know that range contains the best interval so the     -- the file size and page group group may be updated, and the labels written.    IF g.volumePage = range.first THEN expands ¬ SUCC[expands];    g.volumePage ¬ range.first;    g.nextFilePage ¬ g.filePage + range.count;  -- side effect    -- set new file size    filePtr.size ¬ g.nextFilePage;    IF data # VM.nullInterval THEN {      status ¬ DataTransfer.WriteData[file: filePtr­, group: g, data: data,        tok: tok, handleErrors: TRUE];      IF status # DiskChannel.goodCompletion THEN Bug[unexpectedError]};    IF in.lvID = vol.vID THEN VM.ForceOut[buffer, wait]    ELSE Bug[impossibleCase];    totalAllocs ¬ SUCC[totalAllocs];    END;  --AllocPageGroup--  RealClose: PUBLIC ENTRY PROCEDURE [    vol: Volume.ID, disposition: VolAllocMap.BufferDispostion] =    -- Force out/deallocate allocation map =    BEGIN    IF in.lvID = vol THEN      IF disposition = unmap THEN {VM.Unmap[buffer.page]; in.lvID ¬ Volume.nullID}      ELSE VM.ForceOut[buffer, wait];    END;  FreePageGroup: PUBLIC ENTRY PROCEDURE [    vol: LvHandle, filePtr: FilePtr, groupPtr: VolAllocMap.ReadOnlyGroupPtr,    tok: VolTable.LVToken] =    -- Free a page group. This operation is closely related to SetSize and     -- Delete in FileImpl, as well as VolFileMap.DeletePageGroup.    BEGIN OPEN grp: groupPtr;  -- NOTE OPEN.    -- Set the size of of the file and Free the space in the pool.    status: DiskChannel.IOStatus;    filePtr.size ¬ grp.filePage;    SetPageGroupInternal[      vol, [grp.volumePage, grp.nextFilePage - grp.filePage],      free, mightBeSetAlready];    -- only write if noWriteOnDelete is NOT specified    IF System.switches[PilotSwitchesExtra7.noWriteOnDelete] # down THEN {      status ¬ DataTransfer.WriteData[        file: filePtr­, group: [grp.volumePage, grp.volumePage,        grp.volumePage + grp.nextFilePage - grp.filePage], data: VM.nullInterval,	tok: tok];      IF status # DiskChannel.goodCompletion THEN Bug[unexpectedError]};    IF in.lvID = vol.vID THEN VM.ForceOut[buffer, wait]    ELSE Bug[impossibleCase];    totalFrees ¬ SUCC[totalFrees];    END;  --FreePageGroup--  PagesForVam: PUBLIC PROCEDURE [volSize: Volume.PageCount]    RETURNS [vamSize: Volume.PageCount] =    -- Given the size of a volume, the procedure returns the number of pages    -- necessary to hold the VAM. No LV need be locked for this operation.    BEGIN RETURN[(volSize + bitsPerPage - 1) / bitsPerPage]; END;  RealSetPageGroup: PUBLIC ENTRY PROCEDURE [    vol: LvHandle, volumePage: Volume.PageNumber, count: Volume.PageCount,    state: VolAllocMap.BusyFree, prevState: VolAllocMap.PrevState] =    {SetPageGroupInternal[vol, [volumePage, count], state, prevState]};  --========== Internal Procedures:  -- The following procedures are private to the implementation and are  -- used to perform a variety of functions. Procedures are listed alphabetically.  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  BitState: INTERNAL PROCEDURE [vol: LvHandle, volumePage: Volume.PageNumber]    RETURNS [state: VolAllocMap.BusyFree] =    BEGIN    pool: ObjAlloc.AllocPoolDesc;    offset: OffsetInWord;    [pool, offset] ¬ GetPool[volumePage, vol];    RETURN[IF pool.allocPool[offset] = free THEN free ELSE busy];    END;  ExpandAllocation: INTERNAL PROCEDURE [    vol: LvHandle, start: Volume.PageNumber, needed: ObjAlloc.ItemCount]    RETURNS [range: ObjAlloc.Interval] =    -- Expands the allocation beginning at 'start'. It expands the allocation    -- a buffer full at a time with repeated calls on ObjAlloc.ExpandAllocation[].    BEGIN    chunkSize: ObjAlloc.ItemCount;    extendedBy: ObjAlloc.ItemCount;    amountAllocated: ObjAlloc.ItemCount ¬ 0;    poolDesc: ObjAlloc.AllocPoolDesc;    offset: OffsetInWord;    UNTIL amountAllocated = needed DO      [poolDesc, offset] ¬ GetPool[start + amountAllocated, vol];      chunkSize ¬ MIN[needed - amountAllocated, poolDesc.poolSize - offset];      extendedBy ¬ ObjAlloc.ExpandAllocation[        pool: poolDesc, where: offset, count: chunkSize, willTakeSmaller: TRUE !	ANY => Bug[unexpectedAllocationError]];      amountAllocated ¬ amountAllocated + extendedBy;      -- exit if we didn't expand by the whole chunkSize (must have found an      -- inuse page) or we have gone off the end of the volume.      IF (extendedBy ~= chunkSize) OR        (start + amountAllocated >= vol.volumeSize) THEN 	EXIT;      ENDLOOP;    range ¬ [start, amountAllocated];    vol.freePageCount ¬ vol.freePageCount - amountAllocated;    END;  --ExpandAllocation--  FlipAllocator: INTERNAL PROCEDURE [vol: LvHandle] = INLINE    {IF side=right THEN side ¬ left ELSE side ¬ right};  FreeDescriptor: PROCEDURE [v: LvHandle] RETURNS [KernelFile.Descriptor] = INLINE    {    RETURN[      [        fileID: LogicalVolumeFormat.Free[v], volumeID: v.vID, temporary: FALSE,        size: v.volumeSize, type: PilotFileTypes.tFreePage]]};  GetBackwardPool: INTERNAL PROCEDURE [stop: Volume.PageNumber, vol: LvHandle]    RETURNS [pool: ObjAlloc.AllocPoolDesc, offset: OffsetInWord] =    -- This procedure does the appropriate remapping of the VAM buffer to    -- create a pool which contains the specified stop page. The ptr. in the    -- pool desc. always points to a word sometime before stop. The pool size is    -- set to the number of bits between the starting position (word aligned) of    -- the buffer and stop.    BEGIN    start: Volume.PageNumber ¬       IF stop <= (buffer.count * bitsPerPage) THEN 0      ELSE stop - ((buffer.count - 1) * bitsPerPage);    start ¬ (start / bitsPerWord) * bitsPerWord;  -- word align it    [pool: pool, offset: offset] ¬ GetPool[start, vol];    pool ¬ [      allocPool: pool.allocPool,      poolSize: MIN[pool.poolSize, stop - start]];    END;  --GetBackwardPool--  GetPool: INTERNAL PROCEDURE [start: Volume.PageNumber, vol: LvHandle]    RETURNS [pool: ObjAlloc.AllocPoolDesc, offset: OffsetInWord] =    -- This procedure does the appropriate remapping of the VAM buffer to    -- create a pool which contains the specified start page. The ptr. in the    -- pool desc. always points to the word containing 'start'. The pool size is    -- set to the number of bits between the starting and the end of the buffer.    BEGIN    vamPage: Volume.PageNumber;  -- Page of VAM containing 'start'    wordOffsetInPage: LONG CARDINAL;  -- Offset to start from beg. of vamPage.    pageOffset: Environment.PageCount;  -- offset in buffer to vamPage.    vamPage ¬ vol.vamStart + start / bitsPerPage;    wordOffsetInPage ¬ (start / bitsPerWord) MOD wordsPerPage;    MapVamPage[vol, vamPage, Vam[vol]];    pageOffset ¬ vamPage - in.firstMapped;    offset ¬ Inline.LowHalf[start MOD bitsPerWord];    pool ¬ [      allocPool: bufferPointer + pageOffset * wordsPerPage + wordOffsetInPage,      poolSize:      MIN[vol.volumeSize, (in.lastMapped - vol.vamStart + 1) * bitsPerPage] -        start + offset];    END;  --GetPool--  MapVamPage: INTERNAL PROCEDURE [    vol: LvHandle, vamPage: Volume.PageNumber, vamID: File.ID] =    BEGIN    found: BOOLEAN;    svDesc: VolTable.SVDesc;    channel: DiskBackingStore.ChannelHandle;    bsRuns: VM.BackingStoreRuns = DESCRIPTOR[@bsRun, 1];    bsRun: RECORD [count: Environment.PageCount, data: DiskBackingStore.Data];    lastVamPage: Volume.PageNumber;    -- The first thing to do is determine what to map, if anything.    IF in.lvID # vol.vID THEN  -- We have to change volumes      BEGIN      IF in.lvID # Volume.nullID THEN VM.Unmap[buffer.page];      in.lvID ¬ vol.vID;  -- and fall through for map...      END    ELSE  -- on same volume      BEGIN      IF in.allMapped THEN RETURN;      IF vamPage IN [in.firstMapped..in.lastMapped] THEN RETURN;      VM.Unmap[buffer.page]      END;    lastVamPage ¬ vol.vamStart + (vol.volumeSize - 1) / bitsPerPage;    IF in.allMapped ¬ (lastVamPage - vol.vamStart) < buffer.count THEN      BEGIN  -- The whole VAM fits in the buffer.      in.firstMapped ¬ vol.vamStart;      in.lastMapped ¬ lastVamPage;      END    ELSE  -- The whole VAM doesn't fit in the buffer.      BEGIN      maxLower: Volume.PageNumber = lastVamPage - buffer.count + 1;      in.firstMapped ¬ MIN[vamPage, maxLower];      in.lastMapped ¬ in.firstMapped + buffer.count - 1;      END;    in.wordsMapped ¬      (in.lastMapped - in.firstMapped) * LONG[wordsPerPage] +        (IF in.lastMapped ~= lastVamPage THEN LONG[wordsPerPage]         ELSE ((vol.volumeSize - 1) / bitsPerWord) MOD wordsPerPage + 1);    -- Fill in the Backing Store Run. Can't use constuctor because of FilePage!    bsRun.count ¬ in.lastMapped - in.firstMapped + 1;    WITH d: bsRun.data SELECT FileLock.lockingEnabled FROM      TRUE => d.lock ¬ FileLock.nullLockHandle;      FALSE => d.file ¬ vamID;      ENDCASE;    bsRun.data.type ¬ PilotFileTypes.tVolumeAllocationMap;    [bsRun.data.filePageLow, bsRun.data.filePageHigh] ¬      DiskBackingStore.UnpackFilePageNumber[in.firstMapped];    bsRun.data.fileAttributes ¬ [temporary: FALSE, readOnly: FALSE];    [found: found, channel: channel] ¬ VolTable.FindSV[      vol.vID, in.firstMapped, @svDesc];    IF ~found THEN Bug[svNotFound];    bsRun.data.channelHandle ¬ channel;    bsRun.data.volumePage ¬ svDesc.pvPageOfSV + in.firstMapped;    -- Finally, do the map...    VM.Map[      interval: [buffer.page, bsRun.count],      transferProc: DiskBackingStore.Transfer, backingStoreRuns: bsRuns,      usage: KernelSpaceUsage.volumeAllocationMap, swapUnits: [uniform[1]]];    END;  SearchVamRange: INTERNAL PROC [    vol: LvHandle, holeSize: LONG CARDINAL]    RETURNS [bestInterval: ObjAlloc.Interval] =    BEGIN    start: Volume.PageNumber ¬ IF side = right THEN (vol.volumeSize / 2)                               ELSE vol.vamStart;    stop: Volume.PageNumber ¬ IF side = right THEN vol.volumeSize                              ELSE (vol.volumeSize / 2);    poolDesc: ObjAlloc.AllocPoolDesc;  -- Descriptor for the pool    carry, nextCarry: ObjAlloc.ItemCount;    newInterval: ObjAlloc.Interval;    offset: ObjAlloc.ItemCount;    maxNatBits: NATURAL = (LAST[NATURAL] / bitsPerWord) * bitsPerWord;    chunkSize: LONG CARDINAL;    -- number of bits to be searched in this buffer full. This is not    -- necessarily equal to the number of bits the buffer.    -- Initialize all of the loop variables    carry ¬ nextCarry ¬ 0;    start ¬ (start / bitsPerWord) * bitsPerWord;  -- word align start    bestInterval ¬ [first: NULL, count: 0];    IF side = right THEN      BEGIN      -- LOOP until we've found a big enough hole or we've exhausted the range.      UNTIL (bestInterval.count >= holeSize) OR (start = stop) DO	[poolDesc, offset] ¬ GetPool[start, vol];	-- NOTE that offset above is always zero, because of mucking with start	chunkSize ¬ MIN[stop - start, poolDesc.poolSize];	[newInterval, nextCarry] ¬ KernelObjAlloc.FindFreeRange[	  pool: poolDesc, count: holeSize, willTakeSmaller: TRUE, carryIn: carry];	IF (newInterval.first = 0)	  AND (newInterval.count > bestInterval.count) THEN	  bestInterval ¬ [first: start - carry, count: newInterval.count]	ELSE	  IF newInterval.count > bestInterval.count THEN	    bestInterval ¬ [	      first: start + newInterval.first, count: newInterval.count];	carry ¬ nextCarry;	start ¬ start + chunkSize;	ENDLOOP;      END    ELSE  --side = left--      BEGIN      -- LOOP until we've found a big enough hole or we've exhausted the range.      UNTIL (bestInterval.count >= holeSize) OR (start = stop) DO        [poolDesc, offset] ¬ GetBackwardPool[stop, vol];	-- NOTE that offset above is always zero, because of GetBackwardPool	chunkSize ¬ MIN[stop - start, poolDesc.poolSize];	[newInterval, nextCarry] ¬ KernelObjAlloc.FindBackwardFreeRange[	  pool: poolDesc, count: holeSize, willTakeSmaller: TRUE, carryIn: carry];	IF newInterval.count > bestInterval.count THEN	  bestInterval ¬ [	    first: start + newInterval.first, count: newInterval.count];	carry ¬ nextCarry;	stop ¬ stop - chunkSize;	ENDLOOP;      END;    FlipAllocator[vol];    END;  --SearchVamRange--  SetPageGroupInternal: INTERNAL PROCEDURE [    vol: LvHandle, interval: ObjAlloc.Interval, state: VolAllocMap.BusyFree,    prevState: VolAllocMap.PrevState] =    -- Sets the entries for interval to state. NO LABELS ARE WRITTEN.    -- prevState is not used at the present instant.    BEGIN    chunkSize: ObjAlloc.ItemCount;    FOR amountSet: ObjAlloc.ItemCount ¬ 0, amountSet + chunkSize      UNTIL amountSet = interval.count DO      validate: BOOLEAN ¬ debug AND prevState = mightBeSetAlready;      poolDesc: ObjAlloc.AllocPoolDesc;      offset: ObjAlloc.ItemCount;      [poolDesc, offset] ¬ GetPool[interval.first + amountSet, vol];      chunkSize ¬ MIN[interval.count - amountSet, poolDesc.poolSize - offset];      SELECT state FROM        busy => {          KernelObjAlloc.AllocateAt[            pool: poolDesc, interval: [offset, chunkSize],	    validate: validate !	    KernelObjAlloc.AlreadyAllocated --[item]-- => {	      Bug[duplicateSet]; validate ¬ FALSE; RETRY}            ];	  vol.freePageCount ¬ vol.freePageCount - chunkSize};        free => 	  BEGIN          ObjAlloc.Free[            pool: poolDesc, interval: [offset, chunkSize],	    validate: <<prevState=mightBeSetAlready>> validate !	    ObjAlloc.AlreadyFreed --[item]-- => {	      Bug[duplicateSet]; validate ¬ FALSE; RETRY}	    ];	  vol.freePageCount ¬ vol.freePageCount + chunkSize;	  END;        ENDCASE => Bug[impossibleEndcase];      ENDLOOP;    END;  --SetPageGroupInternal--  Vam: PROCEDURE [v: LvHandle] RETURNS [File.ID] = INLINE {    RETURN[LogicalVolumeFormat.Vam[v]]};  END.LOG  (For earlier log entries, see Mesa 10.0 archive version)27-Nov-82 17:15:01   JXP      Update to Klamath. Modify DiskChannel related things and use ObjAlloc   to maintain the allocation database. Export FileBasicsPerf and   FileBasicsPrograms. Add data parm to AllocPageGroup[]. No longer export   Error to PhysicalVolume. Track interface change to Close[]. SHARE   VolFileMap, Change names of Close, AllocPageGroup, FreePageGroup, and    SetPageGroup to RealMumble.14-Dec-82 11:21:52   JXP      Style twiddles. Allow the user to change the size of the VAM buffer by   copying the constant into a local var. during initialization.18-Feb-83 14:24:24   JXP      Don't add vol.vamStart to in.firstMapped in MapVamPage. Once firstMapped   is set, it takes vol.vamStart into account. Don't reset the lower bound   past the LV root page. Specify parm to GetPool from FreePageGroup.   ExpandAllocation must decrease freePageCount, Make FreePageGroup use   SetPageGroupInternal. 4-Mar-83 11:12:10   JXP   	Compute the pool size correctly in GetPool. 2-May-83 10:12:43   JXP   	Fix boundary value bug in AllocPageGroup.31-May-83 13:43:50   JXP      Fix definition of MultiView, should be PACKED ARRAY.26-Aug-83 16:08:25   JXP   	Don't catch UNWIND in FreePageGroup.25-Oct-83 15:56:26   AWL      	BackingStore data now has a readOnly field.28-Nov-83 11:19:55   WDK        Add debug check to watch for duplicate frees. 7-Sep-84 13:39:58   CJS       Fixes AR 5522. AllocPageGroup and FreePageGroup call VerifyLabels and don't worry about errors.24-Jan-85 11:23:39   CJS       Twiddled call to VolTable.FindSV per AR 6275.23-Apr-86  9:27:39   RSV   Added slop parameter to AllocPageGroup, modified UpdateLowerBound and SetPageGroupInternal appropriately. 2-May-86 16:56:55   RSV   Made minor twidles to comments, changed slop to Volume.PageCount.  Also changed moving rover when expanding files in AllocPageGroup.  3-May-86 11:47:13   RSV   Twiddled expanding files in AllocPageGroup.13-May-86 10:34:26   RSV   Fixed bug in ExpandAllocation (raising invalidParameters) when vol.lowerBound = vol.volumeSize.  Fix was to change UpdateLowerBound to cycle and also to not allow going off the end of the VAM.  Also, changed UpdateLowerBound to not search for the next free page, and instead just assign to vol.lowerBound.  Finally fixed bug in updating lowerBound in AllocPageGroup before allocating pages. 2-Jun-86 15:56:47   RSV   Backed out of changes from 23-Apr through 13-May except for fixing bug in ExpandAllocation when vol.lowerBound = vol.volumeSize.13-Jun-86 17:44:50   RSV   Force write VAM after allocation and deallocation. Added catch phrase in ExpandAllocation to catch errors from ObjAlloc.  Also added CHANGE comments and code for when change is made.  Added hack to use volume page when using tETable allocations. 7-Jul-86 16:55:47   RSV   Did CHANGE comments in AllocPageGroup and FreePageGroup for labeless.  Deleted hack to use volume page when using tETable (since now labeless).15-Oct-86 14:25:29   RSV   Change test for noWriteOnDelete to #.17-Nov-86 14:40:04   RSV   Changed MapVamPage for file locking changes.20-Oct-87 11:39:27   RSV   Fix AR 11947 (SearchVamRange fixed).30-Jul-88 17:18:29   RSV   Fixes for DiskBackingStore.Data changing for disabling mapped file locking.19-Sep-88 13:28:42   RSV   Turn debugging on.  Change parameters of calls to SetPageGroupInternal to use debug variable.  Added GetBackwardPool and mucked with SearchVamRange and AllocPageGroup to allocate from middle of volume.  Deleted UpdateLowerBound (since lowerBound is really meaningless when allocating from middle).  Got rid of references to setting lowerBound.17-Jan-89 17:11:04  RSV   Turn off debug boolean in preparation of release.
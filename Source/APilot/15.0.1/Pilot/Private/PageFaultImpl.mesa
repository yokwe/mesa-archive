-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- VMDriver>PageFaultImpl.mesa       5-Aug-86 15:06:09 by ET    <<This program implements waiting for page and write faults,dispatching them to be processed, and restarting themwhen the fault is satisfied. It also handles reporting themto the debugger if they represent a programming error.It also implements VM facilities for declaration, etc., of Helper Processes.PROGRAMMING NOTES:Entry procedures exported to VM must protect their state vectorsvia GuardStateVector (can omit if calls no external monitor proceduresand does not do WAIT, NOTIFY, BRODCAST, or Requeue).Procedures exported to PageFault are assumed to only be calledby processes which already have their state vector protected.PACKAGING CONSIDERATIONS:The following procedures may be swappable: AbortFaultedProcess(and RaiseErrorInFaultedProcess), ReportFaultedProcess, catch code.RestartFaultedProcess may be made swappable, but it may bea bad idea because it might be heavily used by a transaction system.THINGS TO BE DONE:Add facility to handle helper table overflow,say by allocating list elements from the ResidentHeap.>>DIRECTORY  CPSwapDefs USING [FaultQueueItem, PESV],  Environment USING [PageNumber],  Frame USING [    Alloc, GetReturnFrame, MyLocalFrame, ReadPC, SetReturnFrame],  FrameExtras USING [ReadGlobalLink],  Inline USING [LongCOPY],  PageFault USING [ProcessType, ReportRestart],  Pinning USING [CreatePinHandle, Pin, PinHandle, Unpin],  PrincOps USING [BytePC, ControlLink, LocalFrameHandle, StateVector],  PrincOpsExtras2 USING [GFTHandle, nullGFH],  ProcessInternal USING [GetCurrent],  Process USING [Detach, DisableAborts, DisableTimeout, Priority],  ProcessOperations USING [    DisableInterrupts, EnableInterrupts, HandleFromProcess, HandleToIndex,    ProcessFromIndex, ReEnter, Requeue, Wait],  PSB USING [    FaultIndex, NoTimeout, NullPsbHandle, PDA, PDABase, PsbHandle, PsbIndex,    qPageFault, Queue, QueueEmpty, qWriteProtectFault],  RuntimeInternal USING [Bug, MakeFsi, ReportFault],  Space USING [PageFromLongPointer],  SpecialRuntime USING [ReraiseError],  VMInternal USING [DoneWithStateVector, GuardStateVector, PageFaultProcess],  VM USING [FaultType, PageNumber, ReturnWait];PageFaultImpl: MONITOR LOCKS faultLock  IMPORTS    CPSwapDefs, Frame, FrameExtras, Inline, Pinning, Process,     ProcessInternal, ProcessOperations, RuntimeInternal, Space --for inlines-- ,     SpecialRuntime --for inlines-- ,    VM, VMInternal  EXPORTS PageFault, VM, VMInternal =  BEGIN  -- PARAMETERS:  maxHelperProcs: CARDINAL = 4;  -- VARIABLES:  faultLock: MONITORLOCK;  -- covers both page and write faults.    declareHelperPin: Pinning.PinHandle; -- handle for DeclareHelperProcess  deleteHelperPin: Pinning.PinHandle; -- handle for DeleteHelperProcess  pageFaultStartedPin: Pinning.PinHandle; -- handle for PageFaultProcessStarted  pda: PSB.PDABase = PSB.PDA;  qPageFault: PSB.FaultIndex = PSB.qPageFault;  qWriteFault: PSB.FaultIndex = PSB.qWriteProtectFault;  pPageFaultCondition: LONG POINTER TO CONDITION = LOOPHOLE[@pda.fault[    qPageFault].condition];      clientPageFaultsAwaitingHandler: CPSwapDefs.FaultQueueItem ¬ [  --    -- (The head of debugger's page fault chain.)     queue: PSB.QueueEmpty, state: awaitingHandler,    next: @pageFaultsBeingProcessed];    pageFaultsBeingProcessed: CPSwapDefs.FaultQueueItem ¬ [    queue: PSB.QueueEmpty, state: beingProcessed,    next: @addressFaultsAwaitingProcessing];    addressFaultsAwaitingProcessing: CPSwapDefs.FaultQueueItem ¬ [    queue: PSB.QueueEmpty, state: errorFaultUnprocessed,    next: @addressFaultsBeingProcessed];    addressFaultsBeingProcessed: CPSwapDefs.FaultQueueItem ¬ [    queue: PSB.QueueEmpty, state: errorFaultBeingProcessed,    next: NIL];    newAddressFaulted: CONDITION;  pWriteFaultCondition: LONG POINTER TO CONDITION ¬  --    LOOPHOLE[@pda.fault[qWriteFault].condition];  writeFaultsBeingProcessed: CPSwapDefs.FaultQueueItem ¬ [    queue: PSB.QueueEmpty, state: beingProcessed,    next: NIL];  -- Data for BackingStore helper processes:  HelperCount: TYPE = [0..maxHelperProcs];  HelperIndex: TYPE = [0..maxHelperProcs);  anyHelperProcesses: PUBLIC BOOLEAN ¬ FALSE;  -- accelerator for rest of VM.  helperHandlersStartedButNotRunning: HelperCount ¬ 0;  helperHandlerStarted: CONDITION;  helperHandlersToDestroy: HelperCount ¬ 0;  helper: ARRAY HelperIndex OF PROCESS ¬ ALL[NIL];  countHelpers: HelperCount ¬ 0;  countPageFaultHandlersWaiting: CARDINAL ¬ 0;  BugType: TYPE = {    funnyCase, helperExpansionNotImplemented, noSuchHelperProcess,    tooManySignalArgs};  --~~~~~~~~~~ Initialization: ~~~~~~~~~~  InitializePageFault: PUBLIC --VMInternal.-- PROCEDURE[] =    BEGIN    -- We assume that all of the PrincOps fault Queues    -- and conditions are initialized by MakeBoot.    Process.DisableAborts[pPageFaultCondition];    Process.DisableAborts[pWriteFaultCondition];    -- (The above two items are actually PSB.Conditions, not CONDITIONs,    --   and they do not have an associated timeout.)    Process.DisableAborts[@newAddressFaulted];    Process.DisableTimeout[@newAddressFaulted];    Process.DisableAborts[@helperHandlerStarted];    Process.DisableTimeout[@helperHandlerStarted];    --initialize pinning handles    declareHelperPin ¬ Pinning.CreatePinHandle[      LOOPHOLE[DeclareHelperProcess], 1];    deleteHelperPin ¬ Pinning.CreatePinHandle[LOOPHOLE[      DeleteHelperProcess], 1];    pageFaultStartedPin ¬ Pinning.CreatePinHandle[LOOPHOLE[      PageFaultProcessStarted], 1];    -- Tell debugger about our queues:    CPSwapDefs.PESV[].faultsBeingProcessed[page] ¬      @clientPageFaultsAwaitingHandler;    CPSwapDefs.PESV[].faultsBeingProcessed[write] ¬      @writeFaultsBeingProcessed;    END;  --~~~~~~~~~~ Management of BackingStore helper processes: ~~~~~~~~~~  DeclareHelperProcess: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [    process: --GENERIC-- PROCESS] =    BEGIN    TallyHelpersStarted: ENTRY PROCEDURE = INLINE {      helperHandlersStartedButNotRunning ¬ SUCC[        helperHandlersStartedButNotRunning]};    FinishDeclareHelperProcess: ENTRY PROCEDURE =      BEGIN      WHILE helperHandlersStartedButNotRunning > 0 DO        WAIT helperHandlerStarted; ENDLOOP;      FOR h: HelperIndex IN HelperIndex DO        IF helper[h] = NIL THEN {helper[h] ¬ process; EXIT};        REPEAT          FINISHED => RuntimeInternal.Bug[BugType[helperExpansionNotImplemented]];        ENDLOOP;      countHelpers ¬ SUCC[countHelpers];      anyHelperProcesses ¬ TRUE;      END;    -- Begin main text of DeclareHelperProcess:    priorityPrev: Process.Priority;    Pinning.Pin[declareHelperPin];    TallyHelpersStarted[];    -- The FORK and Deatch are swappable facilities. Thus at this point    -- we must not have guarded our state vector, else we could page fault    -- while running at a reserved priority.    Process.Detach[FORK VMInternal.PageFaultProcess[]];  -- (swappable facilities)    -- We must wait for the page fault process to guard    -- his state vector and check in with us. Until he does,    -- he may be blocked on state vectors and his services therefore unavailable.    priorityPrev ¬ VMInternal.GuardStateVector[];    FinishDeclareHelperProcess[];    VMInternal.DoneWithStateVector[priorityPrev];    Pinning.Unpin[declareHelperPin];    END;  --DeclareHelperProcess--  DeleteHelperProcess: PUBLIC --VM.-- ENTRY PROCEDURE [    process: --GENERIC-- PROCESS] =    BEGIN    -- No need to GuardStateVector.    Pinning.Pin[deleteHelperPin];    FOR h: HelperIndex IN HelperIndex DO      IF helper[h] = process THEN {        helper[h] ¬ NIL; countHelpers ¬ PRED[countHelpers]; EXIT};      REPEAT FINISHED => RuntimeInternal.Bug[BugType[noSuchHelperProcess]];      ENDLOOP;    anyHelperProcesses ¬ (countHelpers > 0);    helperHandlersToDestroy ¬ SUCC[helperHandlersToDestroy];    -- (gets destroyed when it calls RestartAndAwaitNext)    Pinning.Unpin[deleteHelperPin];    END;  LookUpProcessType: PUBLIC --VMInternal.-- ENTRY PROCEDURE    RETURNS [processType: PageFault.ProcessType] =    BEGIN    -- No need to GuardStateVector.    process: PROCESS ¬ ProcessInternal.GetCurrent[];    -- NOTE: There is a copy of this code in RestartAndAwaitNext!    FOR h: HelperIndex IN HelperIndex DO      IF helper[h] = process THEN RETURN[helper]; ENDLOOP;    RETURN[client];    END;  PageFaultProcessStarted: PUBLIC --PageFault.-- ENTRY PROCEDURE[] =    BEGIN    Pinning.Pin[pageFaultStartedPin];    -- No need to GuardStateVector.    IF helperHandlersStartedButNotRunning = 0 THEN  --      RETURN  -- (e.g. initialization)    ELSE {      helperHandlersStartedButNotRunning ¬ PRED[        helperHandlersStartedButNotRunning];      NOTIFY helperHandlerStarted};    Pinning.Unpin[pageFaultStartedPin];    END;  --~~~~~~~~~~ Fault processing: ~~~~~~~~~~  AbortFaultedProcess: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [    process: --GENERIC-- PROCESS, faultType: VM.FaultType,    error: --GENERIC-- ERROR, errorArgs: LONG DESCRIPTOR FOR ARRAY OF WORD] =    << This procedure is swappable and uses swappable facilities.    It references no monitor data, except using the requeue instruction    which is atomic and thus does not need the protection of the monitor.    If ever it becomes necessary for this procedure to enter the monitor,    it should do it by calling a separate resident procedure    which will do a GuardStateVector, as appropriate.>>    BEGIN    -- The following is a nested procedure only to simplify packaging.    RaiseErrorInFaultedProcess: PROCEDURE [      process: PSB.PsbHandle, error: --GENERIC-- ERROR,      errorArgs: LONG DESCRIPTOR FOR ARRAY OF WORD] RETURNS[] =      -- On return, just requeue the faulted process and the requested      -- signal will be raised (as an error) in it. The faulted process      -- and the signal must be in the same MDS as the caller.      BEGIN      BackToCaller: TYPE = PROCEDURE [        --must match RaiseErrorInFaultedProcess results-- ];      originalReturnFrame: PrincOps.LocalFrameHandle =  --        Frame.GetReturnFrame[];  -- (return frame overwritten below)      stateAtFault: PrincOps.StateVector =  --        pda[pda[process].context.state];  -- for debugging only.      frameHoldingArgs: PrincOps.LocalFrameHandle ¬ Frame.Alloc[        RuntimeInternal.MakeFsi[LENGTH[errorArgs]]];      pfaultersFrameHandle: LONG POINTER TO PrincOps.LocalFrameHandle;      Inline.LongCOPY[        from: BASE[errorArgs], to: frameHoldingArgs, nwords: LENGTH[errorArgs]];      -- Free faulted process's state vector:      ProcessOperations.DisableInterrupts[];      IF ~pda[process].link.permanent THEN        BEGIN        pda[pda[process].context.state].stk[0] ¬ pda.state[          pda[process].link.priority];        pda.state[pda[process].link.priority] ¬ pda[process].context.state;        pda[process].context.frame ¬ pda[pda[process].context.state].frame;	pfaultersFrameHandle ¬ @pda[process].context.frame;	END      ELSE pfaultersFrameHandle ¬ @pda[pda[process].context.state].frame;      pda[process].link.preempted ¬ FALSE;      ProcessOperations.EnableInterrupts[];      Frame.SetReturnFrame[pfaultersFrameHandle­];        -- set my frame to point to faulted frame.      pfaultersFrameHandle­ ¬ Frame.MyLocalFrame[];        -- process will begin executing my frame.      LOOPHOLE[PrincOps.ControlLink[frame[originalReturnFrame]], BackToCaller][];        -- return to caller without freeing our frame.      -- When we get here, we are running in the faulted process.      SpecialRuntime.ReraiseError[frameHoldingArgs, LOOPHOLE[error, SIGNAL]];      END;  --RaiseErrorInFaultedProcess--    -- Begin main text of AbortFaultedProcess:    RaiseErrorInFaultedProcess[      ProcessOperations.HandleFromProcess[process], error, errorArgs];    ProcessOperations.Requeue[      IF faultType = addressFault THEN @addressFaultsBeingProcessed.queue      ELSE @writeFaultsBeingProcessed.queue, @pda.ready,      ProcessOperations.HandleFromProcess[process]];    END;  --AbortFaultedProcess--  AwaitAddressFault: PUBLIC --VM. EXTERNAL-- PROCEDURE[]    RETURNS [process: --GENERIC-- PROCESS, address: LONG POINTER] =    BEGIN    AwaitAddressFaultEntry: ENTRY PROC --RETURNS [process, address]-- = INLINE      BEGIN      WHILE addressFaultsAwaitingProcessing.queue = PSB.QueueEmpty DO        WAIT newAddressFaulted ENDLOOP;      process ¬ ProcessOperations.ProcessFromIndex[  -- walk to tail, then to head.        pda.block[addressFaultsAwaitingProcessing.queue.tail].link.next];      ProcessOperations.Requeue[        @addressFaultsAwaitingProcessing.queue, @addressFaultsBeingProcessed.queue,        ProcessOperations.HandleFromProcess[process]];      address ¬ pda[        pda[ProcessOperations.HandleFromProcess[process]].context.state].memPointer;      END;    priorityPrev: Process.Priority ¬ VMInternal.GuardStateVector[];    --[process, address] ¬-- AwaitAddressFaultEntry[];    VMInternal.DoneWithStateVector[priorityPrev];    END;  --AwaitAddressFault--  AwaitWriteFault: PUBLIC --VM. EXTERNAL-- PROCEDURE[]    RETURNS [process: --GENERIC-- PROCESS, address: LONG POINTER] =    BEGIN    AwaitWriteFaultEntry: ENTRY PROC --RETURNS [process, address]-- = INLINE      BEGIN      WHILE pda.fault[qWriteFault].queue = PSB.QueueEmpty DO        ProcessOperations.Wait[@faultLock, pWriteFaultCondition, PSB.NoTimeout];        UNTIL ProcessOperations.ReEnter[@faultLock, pWriteFaultCondition] DO          NULL ENDLOOP;        ENDLOOP;      process ¬ ProcessOperations.ProcessFromIndex[  -- walk to tail, then to head.        pda.block[pda.fault[qWriteFault].queue.tail].link.next];      ProcessOperations.Requeue[        @pda.fault[qWriteFault].queue, @writeFaultsBeingProcessed.queue,        ProcessOperations.HandleFromProcess[process]];      address ¬ pda[        pda[ProcessOperations.HandleFromProcess[process]].context.state].memPointer;      END;     priorityPrev: Process.Priority ¬ VMInternal.GuardStateVector[];    --[process, address] ¬-- AwaitWriteFaultEntry[];    VMInternal.DoneWithStateVector[priorityPrev];    END;  --AwaitWriteFault--  ReportFaultedProcess: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [    process: --GENERIC-- PROCESS, faultType: VM.FaultType] =    -- This procedure is swappable. It references no monitor data.    BEGIN    RuntimeInternal.ReportFault[      process,      IF faultType = addressFault THEN addressFault      ELSE writeProtectFault ! ABORTED => CONTINUE];    END;  --ReportFaultedProcess--  RestartAndAwaitNext: PUBLIC --PageFault.-- ENTRY PROCEDURE [    restart: --GENERIC-- PROCESS, reportRestart: PageFault.ReportRestart,    returnWait: VM.ReturnWait]    RETURNS [      pageFaulted: Environment.PageNumber, processFaulted: --GENERIC-- PROCESS,      processType: PageFault.ProcessType, selfDestruct: BOOLEAN] =    BEGIN    IF restart ~= NIL THEN      SELECT reportRestart FROM        reportAddressFault => {          ProcessOperations.Requeue[            @pageFaultsBeingProcessed.queue, @addressFaultsAwaitingProcessing.queue,            ProcessOperations.HandleFromProcess[restart]];          NOTIFY newAddressFaulted};        restart =>          ProcessOperations.Requeue[            @pageFaultsBeingProcessed.queue, @pda.ready,            ProcessOperations.HandleFromProcess[restart]];        ENDCASE => RuntimeInternal.Bug[BugType[funnyCase]];    SELECT returnWait FROM      return => RETURN[NULL, NULL, NULL, NULL];  -- results are garbage.      wait =>        BEGIN  --scope of source--        source: LONG POINTER TO PSB.Queue;        BEGIN  --scope of Dispatch--        IF helperHandlersToDestroy > 0 THEN {          helperHandlersToDestroy ¬ PRED[helperHandlersToDestroy];          RETURN[            selfDestruct: TRUE, pageFaulted: NULL, processFaulted: NULL,              processType: NULL]};        selfDestruct ¬ FALSE;        IF countPageFaultHandlersWaiting >= countHelpers          AND clientPageFaultsAwaitingHandler.queue # PSB.QueueEmpty THEN          BEGIN  --process queued client faults--          processType ¬ client;          processFaulted ¬ ProcessOperations.ProcessFromIndex[  -- walk to tail, then to head.            pda.block[clientPageFaultsAwaitingHandler.queue.tail].link.next];          source ¬ @clientPageFaultsAwaitingHandler.queue;          GOTO Dispatch;          END;  --process queued client faults--        DO  --UNTIL helper fault or enough handlers waiting to process client fault          countPageFaultHandlersWaiting ¬ SUCC[countPageFaultHandlersWaiting];          WHILE pda.fault[qPageFault].queue = PSB.QueueEmpty DO            ProcessOperations.Wait[              @faultLock, pPageFaultCondition, PSB.NoTimeout];            UNTIL ProcessOperations.ReEnter[@faultLock, pPageFaultCondition] DO              NULL ENDLOOP;            ENDLOOP;          countPageFaultHandlersWaiting ¬ PRED[countPageFaultHandlersWaiting];	  -- Note: Faults occurring in parallel could cause the processor to	  -- (atomically) add new entries to the list fault[qPageFault] during	  -- the execution of the following statement. The code here	  -- will correctly choose a process from the queue,	  -- although it could possibly fail to be the (new) head of the queue.          processFaulted ¬ ProcessOperations.ProcessFromIndex[  -- walk to tail, then to head.            pda.block[pda.fault[qPageFault].queue.tail].link.next];          source ¬ @pda.fault[qPageFault].queue;          processType ¬ client;  -- assume.          IF anyHelperProcesses THEN            -- NOTE: There is a copy of this code in LookUpProcessType.            FOR h: HelperIndex IN HelperIndex DO              IF helper[h] = processFaulted THEN {                processType ¬ helper; GOTO Dispatch};              ENDLOOP;          -- ASSERT: processType = client.          --UNTIL--          IF countPageFaultHandlersWaiting >= countHelpers THEN GOTO Dispatch;          ProcessOperations.Requeue[            @pda.fault[qPageFault].queue, @clientPageFaultsAwaitingHandler.queue,            ProcessOperations.HandleFromProcess[processFaulted]];          ENDLOOP;  -- must wait for helper faults.        EXITS          Dispatch --[process, processType, source]-- =>            BEGIN            psbFaulted: PSB.PsbHandle ¬ ProcessOperations.HandleFromProcess[              processFaulted];            ProcessOperations.Requeue[              source, @pageFaultsBeingProcessed.queue, psbFaulted];            pageFaulted ¬ Space.PageFromLongPointer[              pda[pda[psbFaulted].context.state].memPointer];            Log[              pageFaulted, pda[pda[psbFaulted].context.state].frame, psbFaulted];            -- REMOVE THIS SOMEDAY!            RETURN;            END;        END;  --scope of Dispatch--        END;  --scope of source--      ENDCASE => RuntimeInternal.Bug[BugType[funnyCase]];    END;  --RestartAndAwaitNext--  RestartFaultedProcess: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [    process: --GENERIC-- PROCESS, faultType: VM.FaultType] =    -- This procedure itself may be swappable. It references    -- no monitor data, except using the requeue instruction which    -- is atomic and thus does not need the protection of the monitor    BEGIN    SELECT faultType FROM      addressFault => [] ¬ RestartAndAwaitNext[process, restart, return];      writeFault =>        ProcessOperations.Requeue[          @writeFaultsBeingProcessed.queue, @pda.ready,	  ProcessOperations.HandleFromProcess[process]];      ENDCASE => RuntimeInternal.Bug[BugType[funnyCase]];    END;  --RestartFaultedProcess--  -- EVENT LOG (for debugging only)  Event: TYPE = RECORD [    page: VM.PageNumber,    process: PSB.PsbHandle,    local: PrincOps.LocalFrameHandle,    global: PrincOpsExtras2.GFTHandle,    pc: PrincOps.BytePC];  IEvent: TYPE = [0..3);  rgEvent: ARRAY IEvent OF Event ¬ ALL[[0, PSB.NullPsbHandle, NIL,     PrincOpsExtras2.nullGFH, [0]]];  pEvent: LONG POINTER TO Event ¬ @rgEvent[FIRST[IEvent]];  Log: INTERNAL PROC [    page: VM.PageNumber, faulter: PrincOps.LocalFrameHandle,    faulterPSB: PSB.PsbHandle] = INLINE    BEGIN    pEvent­ ¬ [      page, faulterPSB, faulter, FrameExtras.ReadGlobalLink[faulter], Frame.ReadPC[      faulter]];    pEvent ¬      IF pEvent = @rgEvent[LAST[IEvent]] THEN @rgEvent[FIRST[IEvent]]      ELSE pEvent + SIZE[Event];    END;  END.LOG   (For previous entries, please see Mesa 8.0 archive version.)Feb 14, 81 5:54 PM   WDK       Move processes being worked on to unused PDA fault queue instead of private queue.28-Oct-81 15:35:20   WDK        New instruction set.10-Feb-82  9:50:07   AWL         Temporarily increase # of page fault events to aid in tracking down wild address fault problems.24-Feb-82 16:05:57   CAJ        Add faulterPSB arg to Log proc. 2-Mar-82 14:44:23   JXP        Change length of event log from 100 to 3.12-Oct-82 10:52:05   WDK        Added write fault and address fault stuff; change per new PageFault.mesa. 9-Nov-82 13:24:29   WDK        Made compatible with new MStore. Deleted AdjustReservedRealMemory (just use MStoreImpl version).21-Dec-82 16:04:53   AWL        NewSpace => Space. 2-Mar-83 15:55:53   WDK        DisableAborts on cond vars. 8-Apr-83 15:48:18   WDK        Handle compiler warning. 2-Jul-83 20:14:23   WDK        Use ReportFault. FaultQueueItems for debugger.15-Jul-83 15:32:49   JXP      Handle perm. state vectors in RaiseErrorInFaultedProcess. 7-Oct-83  8:28:36   WDK        Terminate debugger's page FaultQueueItem chain correctly. AR 4545: RestartFaultedProcess requeued write faulter from wrong source. AR 4182: AwaitAddressFault, AwaitWriteFault, GuardStateVector did not guard its state vector properly.28-Nov-84 14:18:11   KEK       ar 4806: using pinning procs on DeclareHelperProcess, DeleteHelperProcess, PageFaultProcessStarted. 1-Jul-86 13:59:42   MEW	Updated to newest princops. 5-Aug-86 15:06:17   ET		MDS Relief: LONG POINTERs to global variables now instead of just POINTERs.
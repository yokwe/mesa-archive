-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- SOSP83HeapGeneric.mesa    29-Jun-87 16:06:30 by RSV    DIRECTORY  Environment USING [PageCount, wordsPerPage],  File USING [Create, Delete, File, nullFile, Unknown],  FileTypes USING [tUntypedFile],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Attributes, Create, CreateMDS, ErrorType, NWords],  HeapExtras USING [],  SOSP83HeapInternal USING [    Block, Handle, LargeNode, LargeNodeHeader, NodeHeader, NodeLength,    NormalHandle, OwnerHandle, OwnerObject, SegmentHandle, UncountedZoneRep,    UniformHandle],  SOSP83HeapOps USING [    BugType, ExpandNormalHeap, ExpandUniformHeap, FlushNormalHeap,    FlushUniformHeap, IsNormalEmpty, IsUniformEmpty, PruneNormalHeap,    systemMDSZone, systemZone],  KernelPrograms USING [],  KernelSpaceUsage USING [heap],  PilotSwitches USING [heapChecking, heapOwnerChecking],  PilotSwitchesExtras USING [useLargeHeap, useStdHeap, useTinyHeap],  Runtime USING [GetCaller],  Space USING [    Allocate, defaultSwapUnitSize, Error, GetMapUnitAttributes, InsufficientSpace,    Interval, MapAt, MDS, PageCount, PageFromLongPointer, PagesFromWords,    SwapUnitSize, Unmap, virtualMemory],  SpecialHeap USING [],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  System USING [IsUtilityPilot, switches, UpDown, VolumeID],  VM USING [MakeResident, MakeSwappable],  Volume USING [systemID];SOSP83HeapGeneric: MONITOR LOCKS h.lock USING h: SOSP83HeapInternal.Handle  IMPORTS     File, FrameExtras, Heap, SOSP83HeapOps, Runtime, Space,     SpecialRuntimeExtras, System, VM, Volume  EXPORTS Heap, HeapExtras, SOSP83HeapOps, KernelPrograms, SpecialHeap =  BEGIN OPEN SOSP83HeapInternal;  -- Types  NWords: TYPE = Heap.NWords;  -- Constants  minimumNodeSize: PUBLIC --Heap-- NWords ¬ NodeHeader.SIZE - NodeLength.SIZE;  defaultSwapUnit: Space.SwapUnitSize = Space.defaultSwapUnitSize;    -- Bug error    Bug: PUBLIC --SOSP83HeapOps-- ERROR [bugType: SOSP83HeapOps.BugType] = CODE;    -- Non-public to outside world on purpose.  Just a way to get out without    -- anybody catching.    -- Initialization (MiscPrograms)  InitializeHeap: PUBLIC --KernelPrograms-- PROCEDURE =    BEGIN    initial, initialMDS, increment: Environment.PageCount;    largeNodeThreshold: NWords;    IF System.IsUtilityPilot[] THEN {      initial ¬ initialMDS ¬ increment ¬ 1; largeNodeThreshold ¬ 128}    ELSE {      initialMDS ¬ 1;      SELECT System.UpDown[down] FROM -- order of items is important        System.switches[PilotSwitchesExtras.useLargeHeap] => {	  initial ¬ 100; increment ¬ 50; largeNodeThreshold ¬ 260};	System.switches[PilotSwitchesExtras.useStdHeap] => {	  initial ¬ 40; increment ¬ 20; largeNodeThreshold ¬ 260};	System.switches[PilotSwitchesExtras.useTinyHeap] => {	  initial ¬ 4; increment ¬ 4; largeNodeThreshold ¬ 128};	ENDCASE => { -- same as std --	  initial ¬ 40; increment ¬ 20; largeNodeThreshold ¬ 260}};    SOSP83HeapOps.systemMDSZone ¬ Heap.CreateMDS[      initial: initialMDS,      ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down,      checking: System.switches[PilotSwitches.heapChecking] = down];    SOSP83HeapOps.systemZone ¬ Heap.Create[      initial: initial, increment: increment, swapUnitSize: 4,      largeNodeThreshold: largeNodeThreshold,      ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down,      checking: System.switches[PilotSwitches.heapChecking] = down];    END;  -- Generic Heap implementation    Error: PUBLIC --Heap-- ERROR [type: Heap.ErrorType] = CODE;  Delete: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE, checkEmpty: BOOLEAN] =    BEGIN    OPEN rep: LOOPHOLE[z, UncountedZoneRep];    IF checkEmpty THEN {      WITH h: rep.data SELECT FROM        normal  => IF ~SOSP83HeapOps.IsNormalEmpty[	             z, LOOPHOLE[rep.data, NormalHandle]] THEN                     ERROR Error[invalidHeap];	uniform => IF ~SOSP83HeapOps.IsUniformEmpty[		      LOOPHOLE[rep.data, UniformHandle]] THEN		      ERROR Error[invalidHeap];	ENDCASE => ERROR Error[invalidHeap]};    WITH h: rep.data SELECT FROM      normal  => DeleteHeap[rep.data];      uniform => DeleteHeap[rep.data];      ENDCASE => ERROR Error[invalidHeap];    END;  DeleteHeap: PUBLIC --SOSP83HeapOps-- PROCEDURE [h: Handle] =    BEGIN    createdFiles: BOOLEAN = (h.volumeID # Volume.systemID);    EnumerateLargeNodes[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];    EnumerateSegments[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];    END;  Expand: PUBLIC --Heap-- PROCEDURE [    z: UNCOUNTED ZONE, pages: Space.PageCount] = {    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => SOSP83HeapOps.ExpandNormalHeap[z, @h, pages];      uniform => SOSP83HeapOps.ExpandUniformHeap[@h, pages];      ENDCASE => ERROR Error[invalidHeap]};  Flush: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE] = {    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => SOSP83HeapOps.FlushNormalHeap[z, @h];      uniform => SOSP83HeapOps.FlushUniformHeap[@h];      ENDCASE => ERROR Error[invalidHeap]};  Prune: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE] = {    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => SOSP83HeapOps.PruneNormalHeap[z, @h];      uniform => NULL;      ENDCASE => ERROR Error[invalidHeap]};  CheckOwner: PUBLIC --Heap-- PROCEDURE [p: LONG POINTER, z: UNCOUNTED ZONE] = {    IF LOOPHOLE[z, UncountedZoneRep].data.ownerChecking THEN      IF p = NIL THEN ERROR Error[invalidNode]      ELSE {OPEN pp: LOOPHOLE[p - OwnerObject.SIZE, OwnerHandle];      IF pp.frame # FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]]        THEN ERROR Error[invalidOwner]}};  MakeNode: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE, n: NWords] RETURNS [LONG POINTER] = {    Words: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF CARDINAL];    RETURN[z.NEW[Words[n]]]};  MakeMDSNode: PUBLIC --Heap-- PROCEDURE [z: MDSZone, n: NWords] RETURNS [POINTER] = {    Words: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF CARDINAL];    RETURN[z.NEW[Words[n]]]};  FreeNode: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE, p: LONG POINTER] = {    z.FREE[@p]};      FreeMDSNode: PUBLIC --Heap-- PROCEDURE [z: MDSZone, p: POINTER] = {    z.FREE[@p]};    MakeLargeNode: PUBLIC --SOSP83HeapOps-- PROCEDURE [    h: NormalHandle, n: NodeLength] RETURNS [largeNode: LargeNode] =    -- Make a space to hold a large node, and add it to h's largeNodes list.    -- n is the length of the data required.    BEGIN    parent: Space.Interval;    next: LargeNode;    pages: Space.PageCount = Space.PagesFromWords[n + SIZE[LargeNodeHeader]];    oldSize: Space.PageCount = h.currentSize;    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Error[maxSizeExceeded];      END;    WITH hh: h SELECT FROM      hyper => {parent ¬ Space.virtualMemory; next ¬ hh.largeNodes};      mds => {parent ¬ Space.MDS[]; next ¬ hh.largeNodes};      ENDCASE;    largeNode ¬ MakeSpace[      parent, pages, Space.SwapUnitSize[h.swapUnit], h.resident, h.volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    largeNode^ ¬ [      next: next, node: [length: n + NodeLength.SIZE, left: NULL, right: NULL]];    EXITS      InsufficientSpace => ERROR Error[insufficientSpace];    END;  MakeSpace: PUBLIC --SOSP83HeapOps-- PROCEDURE [    parent: Space.Interval, pages: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, resident: BOOLEAN,    volumeID: System.VolumeID] RETURNS [LONG ORDERED POINTER] =    BEGIN    tempFile: File.File =      IF volumeID = Volume.systemID THEN File.nullFile      ELSE File.Create[volumeID, pages, FileTypes.tUntypedFile];    -- Make a data space, and perhaps (one level of) swap units.    sI: Space.Interval = Space.Allocate[count: pages, within: parent];    [] ¬ Space.MapAt[      at: sI, window: [tempFile, 0, pages], usage: KernelSpaceUsage.heap,      class: data, life: dead,      swapUnits:        IF swapUnitSize = defaultSwapUnit OR pages <= 2*swapUnitSize THEN [unitary[]]	ELSE [uniform[swapUnitSize]]];    IF resident THEN      VM.MakeResident[[Space.PageFromLongPointer[sI.pointer], sI.count], wait];    RETURN[LOOPHOLE[sI.pointer]];    END;  OwnerChecking: PUBLIC --Heap-- PROCEDURE [    z: UNCOUNTED ZONE] RETURNS [BOOLEAN] = {    RETURN[LOOPHOLE[z, UncountedZoneRep].data.ownerChecking]};      SetChecking: PUBLIC --Heap-- PROCEDURE [    z: UNCOUNTED ZONE, checking: BOOLEAN] = {    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      uniform, normal => h.checking ¬ checking;      ENDCASE => ERROR Error[invalidHeap]};  MakeResident: PUBLIC --SpecialHeap-- PROCEDURE [z: UNCOUNTED ZONE] = {    MakeResidentHeap[LOOPHOLE[z, UncountedZoneRep].data]};  MakeResidentHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [h: Handle] =    BEGIN    ENABLE UNWIND => NULL;    MakeResident: PROCEDURE [sI: Space.Interval] =      {VM.MakeResident[[Space.PageFromLongPointer[sI.pointer], sI.count], wait]};    EnumerateLargeNodes[h, MakeResident];    EnumerateSegments[h, MakeResident];    h.resident ¬ TRUE;    END;  MakeSwappable: PUBLIC --SpecialHeap-- PROCEDURE [z: UNCOUNTED ZONE] =    {MakeSwappableHeap[LOOPHOLE[z, UncountedZoneRep].data]};  MakeSwappableHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [h: Handle] =    BEGIN    ENABLE UNWIND => NULL;    MakeSwappable: PROCEDURE [sI: Space.Interval] =      BEGIN      VM.MakeSwappable[[Space.PageFromLongPointer[sI.pointer], sI.count]];      END;    EnumerateLargeNodes[h, MakeSwappable];    EnumerateSegments[h, MakeSwappable];    h.resident ¬ FALSE;    END;  EnumerateSegments: PUBLIC --SOSP83HeapOps-- PROCEDURE [    h: Handle, proc: PROCEDURE [sI: Space.Interval]] =    BEGIN    WITH hh: h SELECT FROM      uniform =>        BEGIN        block, next: Block;        FOR block ¬ hh.blocks, next UNTIL block = NIL DO          next ¬ block.next;          proc[sI: LPToInterval[block]];          ENDLOOP;        RETURN;	END;      normal =>        BEGIN        segment, next: SegmentHandle;        FOR segment ¬ hh.segments, next UNTIL segment = NIL DO          next ¬ segment.next;          proc[sI: LPToInterval[segment]];          ENDLOOP;        RETURN;	END;      ENDCASE => ERROR Error[invalidHeap];    END;  EnumerateLargeNodes: PUBLIC --SOSP83HeapOps-- PROCEDURE [    h: Handle, proc: PROCEDURE [sI: Space.Interval]] =    -- Call proc once for each large node    BEGIN    hasSwapUnits: BOOLEAN = (h.swapUnit # defaultSwapUnit);    node, next: LargeNode;    WITH hh: h SELECT FROM      uniform => RETURN;      normal => node ¬ hh.largeNodes;      ENDCASE => RETURN WITH ERROR Error[invalidHeap];    WHILE node # NIL DO        next ¬ node.next;        proc[LPToInterval[node]];        node ¬ next;        ENDLOOP;    END;  NormalAttributes: ENTRY PROCEDURE [h: NormalHandle]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, ownerChecking, checking: BOOLEAN,      volumeID: System.VolumeID, attributes: Heap.Attributes] =    BEGIN ENABLE UNWIND => NULL;    savedType: Heap.ErrorType;      BEGIN      largeNodePages: Space.PageCount ¬ 0;      SpaceSize: PROCEDURE [sI: Space.Interval] =	{largeNodePages ¬ sI.count + largeNodePages};      EnumerateLargeNodes[h, SpaceSize ! Error => {savedType ¬ type; GOTO Error}];      attributes ¬ [normal[largeNodePages: largeNodePages,	threshold: h.threshold, largeNodeThreshold: h.largeNodeThreshold]];      heapPages ¬ h.currentSize;      swapUnitSize ¬ Space.SwapUnitSize[h.swapUnit];      increment ¬ h.increment;      maxSize ¬ h.maxSize;      ownerChecking ¬ h.ownerChecking;      checking ¬ h.checking;      volumeID ¬ h.volumeID;      EXITS 	Error => RETURN WITH ERROR Error[savedType];      END;    END;  UniformAttributes: ENTRY PROCEDURE [h: UniformHandle]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, ownerChecking, checking: BOOLEAN,       volumeID: System.VolumeID, attributes: Heap.Attributes] =    BEGIN ENABLE UNWIND => NULL;    attributes ¬ [uniform[objectSize: h.objectSize]];    heapPages ¬ h.currentSize;    swapUnitSize ¬ Space.SwapUnitSize[h.swapUnit];    increment ¬ h.increment;    maxSize ¬ h.maxSize;    ownerChecking ¬ h.ownerChecking;    checking ¬ h.checking;    volumeID ¬ h.volumeID;    END;      GetAttributes: PUBLIC --Heap-- PROC [z: UNCOUNTED ZONE]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, ownerChecking, checking: BOOLEAN,      attributes: Heap.Attributes] =    BEGIN    [heapPages: heapPages, maxSize: maxSize, increment: increment,      swapUnitSize: swapUnitSize, ownerChecking: ownerChecking,      checking: checking, attributes: attributes] ¬ NewGetAttributes[z];    END;  NewGetAttributes: PUBLIC --HeapExtras-- PROC [z: UNCOUNTED ZONE]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, ownerChecking, checking: BOOLEAN,      volumeID: System.VolumeID, attributes: Heap.Attributes] =    BEGIN    handle: Handle = LOOPHOLE[z, UncountedZoneRep].data;    WITH h: handle SELECT FROM      normal => RETURN NormalAttributes[@h];      uniform => RETURN UniformAttributes[@h];      ENDCASE => ERROR Error[invalidHeap];    END;  PagesForLargeNode: PUBLIC --SOSP83HeapOps-- PROCEDURE [    largeNode: LONG POINTER TO LargeNodeHeader] RETURNS [Space.PageCount] =    BEGIN    RETURN[Space.PagesFromWords[      largeNode.node.length - NodeLength.SIZE + LargeNodeHeader.SIZE]];    END;  LPToInterval: PROCEDURE [p: LONG POINTER] RETURNS [Space.Interval] = INLINE    BEGIN    RETURN [Space.GetMapUnitAttributes[p].interval];    END;  DeleteAndUnmap: PROCEDURE [sI: Space.Interval] =     BEGIN    tempFileID: File.File = Space.GetMapUnitAttributes[sI.pointer].window.file;    [] ¬ Space.Unmap[sI.pointer ! Space.Error => Bug[mappedAreaWentAway]];    File.Delete[tempFileID ! File.Unknown => Bug[fileWeCreatedWentAway]];    END;  Unmap: PROCEDURE [sI: Space.Interval] = {[] ¬ Space.Unmap[sI.pointer]};  END...LOG31-Jan-84  8:58:26 XXJ Created file.30-Jun-86 10:13:52 RSV Added log, changed _ to ¬, changed file name to SOSP83HeapGeneric, added checks for checkEmpty in Delete, implemented ­ switch, and reset currentSize to original size when maxSizeExceeded is raised in MakeLargeNode.18-Mar-87 14:33:27 RSV Can't just use PrincOps.GlobalFrameHandle.  Must use PrincOpsExtras2.GFTHandle.29-Jun-87 16:06:30 RSV Allow specifying volume from which backing store is allocated.
-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- ResidentMemory.mesa     28-Sep-82 11:46:47 by AWL      -- Implementation notes: Some ResidentMemory procedures are involved in recovering from the frame heap becoming exhausted.  Because of this, invoking these procedures must not cause any frame allocations.  This means that these procedures (and any that they call) must be INLINEs or coroutines.  Since there is no such thing as an ENTRY coroutine, it must be simulated by an ENTRY INLINE procedure (which acquires the monitor lock) which itself calls the coroutine.  To have an ENTRY INLINE PROCEDURE, the monitor lock must be available in the DEFINITIONS module.  To allow a coroutine to be called as a public procedure, the procedure descriptor must be bundled into a record to force it to be a procedure variable.   DIRECTORY  Environment USING [PageCount],  ResidentHeap USING [Location];ResidentMemory: DEFINITIONS LOCKS residentMemoryLock =  BEGIN  Location: TYPE = ResidentHeap.Location;  --~~~~~~ Allocation of resident memory for I/O and miscellaneous use:  Allocate: ENTRY PROCEDURE [location: Location, count: Environment.PageCount]    RETURNS [lp: LONG POINTER TO UNSPECIFIED] = INLINE    -- Caller must have his state vector guarded.    -- Guaranteed not to do an ALLOC from the frame heap.    {RETURN[allocateInternal[location, count]]};  Free: ENTRY PROCEDURE [    location: Location, count: Environment.PageCount,    lp: LONG POINTER TO UNSPECIFIED] = INLINE    -- Caller must have his state vector guarded.    -- Guaranteed not to do an ALLOC from the frame heap.    {freeInternal[location, count, lp]};  --~~~~~~ Allocation of resident memory within the MDS:  AllocateMDS: ENTRY PROCEDURE [count: Environment.PageCount]    RETURNS [p: POINTER TO UNSPECIFIED] = INLINE    -- Caller must have his state vector guarded.    -- Guaranteed not to do an ALLOC from the frame heap.    {RETURN[allocateMDSInternal[count]]};  FreeMDS: ENTRY PROCEDURE [    base: POINTER TO UNSPECIFIED, count: Environment.PageCount] = INLINE    -- Caller must have his state vector guarded.    -- Guaranteed not to do an ALLOC from the frame heap.    {freeInternal[mds, count, LONG[base]]};  --~~~~~~ PRIVATE items:  residentMemoryLock: PRIVATE MONITORLOCK;  AllocateInternal: PRIVATE TYPE = RECORD [    proc: PROCEDURE [location: Location, count: Environment.PageCount]      RETURNS [lp: LONG POINTER TO UNSPECIFIED]];  allocateInternal: PRIVATE AllocateInternal;  AllocateMDSInternal: PRIVATE TYPE = RECORD [    proc: PROCEDURE [count: Environment.PageCount]      RETURNS [p: POINTER TO UNSPECIFIED]];  allocateMDSInternal: PRIVATE AllocateMDSInternal;  FreeInternal: PRIVATE TYPE = RECORD [    proc: PROCEDURE [      location: Location, count: Environment.PageCount,      lp: LONG POINTER TO UNSPECIFIED]];  freeInternal: PRIVATE FreeInternal;  END.LOGJune 9, 1978  11:04 AM		HXL     Created file.June 22, 1978  11:38 AM		HXL     Separated allocation from MDS and elsewhere; added FreeMDSPages; moved Pin and Unpin to module "Special".January 25, 1980  2:33 PM	WDK       Named return parameters.April 16, 1980  8:47 AM		WDK       Expanded Location to include MDS.  Added Free.  Renamed to AllocateMDS, FreeMDS.  Added residentMemoryLock, made Allocate, AllocateMDS ENTRY INLINEs.November 5, 1980  10:44 AM	WDK       Made Free, FreeMDS ENTRY INLINEs.15-Sep-82  9:07:09		WDK       Added Location[pda].28-Sep-82 11:46:43		AWL         Moved Location to ResidentHeap.
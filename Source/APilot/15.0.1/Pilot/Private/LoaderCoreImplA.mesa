-- LoaderCoreImplA.mesa     13-Dec-87 14:14:19 by ET-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.<<This module implements the core loader functionality. It does not deal with vm allocation or untrammeled modification of memory. This organization allows it to be used both by Loader and MakeBoot, each of which supplies an implementation of LoadedMem (and LoadState) to provide storage modification functions for their respective environments. For the Loader, serialization is provided by LoadState.LockBcdInfo.Notes:  Several data are constant for the duration of a load operation, and are required by almost every procedure. These are kept as global variables. This reduces parameter passing of "environmental" data, and reflects their global nature to the operation. Exclusive access to these globals is provided by LoadState.LockBcdInfo.  Resident modules (MTRecord.residentFrame = TRUE) are not supported at present.Organization of this module:The major components of this module occur below in the following order:  o  CreateModulesAndBind  (top-level driver)  o  Module Instance Allocation and associated utilities  o  Code Segment Allocation and Mapping and associated utilities  o  Control Modules and associated utilities  o  Import/Export and associated utilities  o  General utilitiesEach major component is delimited by a line containing equal signs ======.TO DO:  Make sure that ModuleInfo.resolved ¬ TRUE when it is completely resolved.  Must pass in LoadedMem.Target address of bcd as well as local one for efficient access in MakeBoot environment.  Can improve efficiency by not demanding that all allocated sequences be exactly the right length.  Deal more effectively with fact that FPRecords and CTRecords are variable length items>>DIRECTORY  BcdDefs USING [    CTIndex, CTNull, CTRecord, FPIndex, FPRecord, FTIndex, FTSelf, GFIndex, Link,    LinkFrag, MTIndex, MTRecord, SGIndex, TMIndex, VersionStamp],  BcdDefsExtras USING [OldMesaModule],  BcdOps USING [    BcdBase, CTHandle, FPHandle, MTHandle, ProcessConfigs, ProcessFrames,    ProcessModules, ProcessSegs, ProcessTypeMap, SGHandle, SPHandle, TMHandle],  BcdOpsExtras USING [    CTBaseFromBcd, GfiFromMti, LFBaseFromBcd, MTBaseFromBcd, MthFromMti,    segmentBaseOrigin, SGBaseFromBcd, SPHandleFromSGHandle, TYPBaseFromBcd],  ControlModuleFormat USING [Finger, Fingers, Item, List, ListHead],  Environment USING [maxPagesInMDS, wordsPerPage],  Heap USING [Create, Delete],  Inline USING [HighHalf, LongNumber, LowHalf],  LoadedMem USING [    Access, AllocateMDSPages, AllocatePages, AllocateMDSWords, AllocateWords,    Content, FreeMDSPages, FreePages, FreeMDSWords, FreeWords, MakeCodeReadOnly,    MapCode, GlobalFrameFromGFTHandle, Long, ReadMDSWord, ReadMDSBlock,    SwapUnitSize, TargetAddress, TargetLongAddress, UnmapCode, WriteCodebase,    WriteGlobalWord, WriteMDSBlock, WriteBlock, WriteExtraGlobalWord, WriteWord],  LoaderCore USING [LinkLoc],  LoaderCoreOps,  LoadState USING [    BcdInfoIndex, EnterGlobalFrame, EnterModuleInfos, ExpandTablesInternal,    LockBcdInfo, LPBcdInfoTable, ModuleInfoIndex, ModuleInfosOfBcd,    ModuleInfoSequence, ModuleInfoSequenceHandle, RemoveModuleInfos, TablesFull,    UnlockBcdInfo, UnresolvedModuleInfosOfBcd],  LoadStateFormat USING [Handle, ModuleInfo],  PilotSwitchesExtra6 USING [useHeapForSmallGlobalFrames],  PrincOps USING [GlobalCodebase],  PrincOpsExtras2 USING [    ImportLink, LongGlobalFrameHandle, GFTIndex, GFTHandle, GFTHandleToIndex,    GlobalOverhead, nullGFH],  Runtime USING [ConfigError],  System USING [switches],  Table USING [Base];LoaderCoreImplA: PROGRAM  IMPORTS    BcdOps, BcdOpsExtras, Heap, Inline, LoadedMem, LoaderCoreOps, LoadState,    PrincOpsExtras2, Runtime, System  EXPORTS LoaderCore, LoaderCoreOps =  BEGIN  -- Parameters:  maxSizeForSmallFramePack: CARDINAL ¬    Environment.wordsPerPage  --      - alignmentModulus - 1  -- for quad aligning      - alignmentModulus  -- for getting off a page boundary,      - 1  -- for heap overhead      - 6;  -- for new segment overhead  maxCharsInErrorNameString: CARDINAL = 40;  -- PUBLIC Items:  WrongVersion: PUBLIC --LoaderCore.-- SIGNAL [module: LONG STRING] = CODE;  -- Copied types and constants:  BcdInfoIndex: TYPE = LoadState.BcdInfoIndex;  LPBcdInfoTable: TYPE = LoadState.LPBcdInfoTable;  GlobalFrameHandle: TYPE = PrincOpsExtras2.LongGlobalFrameHandle;  ModuleInfoIndex: TYPE = LoadState.ModuleInfoIndex;  ERSequenceHandle: TYPE = LoaderCoreOps.ERSequenceHandle;  GFSequenceHandle: TYPE = LoaderCoreOps.GFSequenceHandle;  GFSequence: TYPE = LoaderCoreOps.GFSequence;  WheresTheStorage: TYPE = LoaderCoreOps.WheresTheStorage;  alignmentModulus: CARDINAL = 4;  -- global frames aligned 0 mod 4.  wordsPerPage: CARDINAL = Environment.wordsPerPage;  -- Global variables:  -- WARNING: Globals variables are ONLY VALID during the scope of  -- CreateModulesAndBind. Use of them is serialized by LoadState.LockBcdInfo.  permanentZone: PUBLIC UNCOUNTED ZONE ¬ NIL;  scratch: PUBLIC UNCOUNTED ZONE ¬ NIL;  -- scratch storage for Loader Core.  loadState: PUBLIC LoadStateFormat.Handle;  bcdInfo: PUBLIC LPBcdInfoTable;  exportRecords: PUBLIC ERSequenceHandle ¬ NIL;  bcdExtra: PUBLIC LoaderCoreOps.BcdExtraSequenceHandle ¬ NIL;  inMakeBoot: BOOLEAN;  bcd: PUBLIC BcdOps.BcdBase;  -- the bcd being loaded or unloaded.  loadInfo: PUBLIC LoaderCoreOps.LoadInfoData;  -- describes structures built from bcd being loaded.  Bug: PUBLIC ERROR [type: LoaderCoreOps.BugType] = CODE;  --=========== Type Converters and Inlines: (defined before use) ===========  GetActualLinkLoc: PROC [linkLoc: LoaderCore.LinkLoc, mth: BcdOps.MTHandle]    RETURNS [LoaderCoreOps.ActualLinkLoc] = INLINE {    -- A module uses code links if client asked for them    -- AND module was bound specifying code links (or dontCare)    -- AND module was bound with code copying thus making space for code links.    RETURN[      IF linkLoc = codeIfPossible AND mth.linkLoc # frame AND mth.linkspace THEN      codeLinks ELSE frameLinks]};  MtiFromOrdinal: PROC [ordinal: LoaderCoreOps.ModuleRange]    RETURNS [BcdDefs.MTIndex] = INLINE {    -- Returns BcdDefs.MTIndex given zero-origin ordinal of module in bcd's module table.    -- Not "Index" since BcdDefs uses that term for relative pointers!    RETURN[BcdDefs.MTIndex.FIRST + ordinal * BcdDefs.MTRecord.SIZE]};  NextMultipleOfFour: PROC [n: UNSPECIFIED] RETURNS [UNSPECIFIED] = INLINE {    RETURN[((n + 3) / alignmentModulus) * alignmentModulus]};  NextMultipleOfFourLong: PROC [n: LONG UNSPECIFIED] RETURNS [LONG UNSPECIFIED] = INLINE {    RETURN[((n + 3) / alignmentModulus) * alignmentModulus]};  Order: PROC [p: LONG POINTER] RETURNS [LONG ORDERED POINTER] = INLINE {    RETURN[LOOPHOLE[p]]};  OrdinalFromMti: PROC [mti: BcdDefs.MTIndex]    RETURNS [LoaderCoreOps.ModuleRange] = INLINE {    -- Returns zero-origin index of module in bcd's module table.    -- NOT a BcdDefs "Index" which is a relative pointer!    RETURN[(mti - BcdDefs.MTIndex.FIRST) / BcdDefs.MTRecord.SIZE]};  Where: PROC [mth: BcdOps.MTHandle] RETURNS [WheresTheStorage] = INLINE {    RETURN[IF mth.spare = BcdDefsExtras.OldMesaModule THEN mds ELSE vm]};  --============= LoaderCore Implementation: =============  CreateModulesAndBind: PUBLIC --LoaderCore.-- PROCEDURE [    bcdBase: BcdOps.BcdBase, linkLoc: LoaderCore.LinkLoc,    scratchDuringLoading: UNCOUNTED ZONE, makeboot: BOOLEAN ¬ FALSE]    RETURNS [control: PrincOpsExtras2.LongGlobalFrameHandle] =    BEGIN    newBii: BcdInfoIndex;    modulesBoundToOtherBcds: BOOLEAN ¬ FALSE;    exports: ERSequenceHandle ¬ NIL;    importsAllResolved: BOOLEAN ¬ FALSE;    myModuleInfo: LoadState.ModuleInfoSequenceHandle ¬ NIL;    CleanUp: PROC [whatToFree: WhatToFree] =      BEGIN      IF whatToFree = controlInfoAndObjects AND modulesBoundToOtherBcds THEN        LoaderCoreOps.UnbindBcdFromOthers[newBii, exports];      IF whatToFree = controlInfoAndObjects THEN        BEGIN        -- Also deletes new entry from Bcd Info Table        LoadState.RemoveModuleInfos[newBii];        -- free up frame packs        IF bcdExtra[newBii].framePack # NIL THEN          BEGIN          framePack: LoaderCoreOps.FramePackSequenceHandle = bcdExtra[            newBii].framePack;          FOR k: CARDINAL IN [0..framePack.length) DO            SELECT TRUE FROM              framePack[k].smallFrame AND framePack[k].wheresTheStorage = vm =>                [] ¬ LoadedMem.FreeWords[framePack[k].storage];              framePack[k].smallFrame AND framePack[k].wheresTheStorage = mds =>                [] ¬ LoadedMem.FreeMDSWords[Inline.LowHalf[framePack[k].storage]];              ~framePack[k].smallFrame AND framePack[k].wheresTheStorage = vm =>                [] ¬ LoadedMem.FreePages[framePack[k].storage];              ENDCASE =>                [] ¬ LoadedMem.FreeMDSPages[Inline.LowHalf[framePack[k].storage]];            framePack[k].storage ¬ NIL;            ENDLOOP;          permanentZone.FREE[@LoaderCoreOps.bcdExtra[newBii].framePack];          END;        -- free up unpackaged frames        IF LoaderCoreOps.bcdExtra[newBii].storage.mds # NIL THEN {          [] ¬ LoadedMem.FreeMDSWords[            Inline.LowHalf[bcdExtra[newBii].storage.mds]];          bcdExtra[newBii].storage.mds ¬ NIL};        IF LoaderCoreOps.bcdExtra[newBii].storage.vm # NIL THEN {          [] ¬ LoadedMem.FreeWords[bcdExtra[newBii].storage.vm];          bcdExtra[newBii].storage.vm ¬ NIL};        END;      -- N.B. newBii entry is no longer in bcdInfo      --  but FreeLoadInfo only uses newBii to mess with bcdExtra      FreeLoadInfo[whatToFree: whatToFree, bii: newBii];      IF whatToFree = controlInfoAndObjects THEN        bcdExtra.length ¬ bcdExtra.length - 1; -- since loadstate was decremented      IF myModuleInfo # NIL THEN scratch.FREE[@myModuleInfo];      IF (exports # NIL) AND (exports # exportRecords) THEN {        FOR i: NATURAL DECREASING IN [0..exports.length) DO          permanentZone.FREE[@exports[i].name];          permanentZone.FREE[@exports[i].links];          ENDLOOP;        permanentZone.FREE[@exports]};      scratch ¬ NIL;      LoadState.UnlockBcdInfo[];      END;  --CleanUp    inMakeBoot ¬ makeboot;    [loadState, bcdInfo] ¬  -- save in globals for everybody.      LoadState.LockBcdInfo[];  -- also serializes access to globals    -- Now can safely read and write global variables.    IF bcdExtra = NIL THEN {      ExpandBcdExtra[];      bcdExtra.length ¬ loadState.nBcds;      FOR i: LoaderCoreOps.BcdExtraRange IN [0..loadState.nBcds) DO        temp: ERSequenceHandle;        moduleInfo: LoadState.ModuleInfoSequenceHandle ¬          LoadState.ModuleInfosOfBcd[i, permanentZone];        bcd: BcdOps.BcdBase = bcdInfo[i].base;        frames: GFSequenceHandle ¬ permanentZone.NEW[GFSequence [bcd.firstdummy]];        FOR j: CARDINAL IN [0..moduleInfo.length) DO          frames[moduleInfo[j].cgfi] ¬ moduleInfo[j].gfi; ENDLOOP;        permanentZone.FREE[@moduleInfo];        temp ¬ LoaderCoreOps.BuildExportRecords[bcd, i, frames];        bcdExtra[i] ¬ [bootLoaded: TRUE, storage: [NIL, NIL], frames: frames];        exportRecords ¬ LoaderCoreOps.MergeExportRecords[exportRecords, temp]        ENDLOOP};    bcd ¬ bcdBase;  -- save in globals for everybody.    scratch ¬ scratchDuringLoading;    -- Initialize loadInfo:    loadInfo ¬ [];    -- The various items in loadInfo are allocated when needed.    BEGIN    ENABLE UNWIND => CleanUp[whatToFree: controlInfoAndObjects];    -- Create new Bcd Info entry and enter it in Bcd Info Table:    -- (We do this before making Module Info Table entries    --  so that the debugger sees a consistent state.)    newBii ¬ loadState.nBcds;  -- new bcd goes at end of existing ones.    IF loadState.nBcds >= loadState.maxBcds THEN {      [loadState, bcdInfo] ¬ LoadState.ExpandTablesInternal[        totalBcdsNeeded: loadState.nBcds.SUCC,        totalModulesNeeded: loadState.nModules]};    bcdInfo[newBii] ¬ [      exports: bcdBase.nExports > 0 OR bcdBase.nConfigs = 0,      typeExported: bcdBase.typeExported, pages: bcdBase.nPages, base: bcdBase,      id: loadState.nextID];    IF bcdExtra.length = bcdExtra.maxLength THEN ExpandBcdExtra[];    bcdExtra.length ¬ bcdExtra.length + 1;    loadState.nextID ¬ loadState.nextID.SUCC;    loadState.nBcds ¬ loadState.nBcds.SUCC;    bcdExtra[newBii].storage ¬ [NIL, NIL];    bcdExtra[newBii].frames ¬ NIL;    AllocateModules[bcd, newBii, linkLoc];    bcdExtra[newBii].codeSets ¬ NIL;  -- lest we unwind out of next call    bcdExtra[newBii].codeSets ¬ MapCodeAndSetCodebases[bcd, linkLoc];    [control, bcdExtra[newBii].fingers, bcdExtra[newBii].nFingers] ¬      AssignControlModules[bcd];    myModuleInfo ¬ scratch.NEW[      LoadState .ModuleInfoSequence[loadInfo.module.length]];    myModuleInfo.length ¬ loadInfo.module.length;    FOR k: CARDINAL IN [0..myModuleInfo.length) DO      myModuleInfo[k] ¬ loadInfo.module[k].info; ENDLOOP;    LoadState.EnterModuleInfos[      myModuleInfo !      LoadState.TablesFull --[totalBcdsNeeded, totalModulesNeeded]-- => {        [loadState, bcdInfo] ¬ LoadState.ExpandTablesInternal[          totalBcdsNeeded: totalBcdsNeeded,          totalModulesNeeded: totalModulesNeeded];        RETRY}; ];    exports ¬ LoaderCoreOps.BuildExportRecords[      bcd, newBii, bcdExtra[newBii].frames];    exportRecords ¬ LoaderCoreOps.MergeExportRecords[exportRecords, exports];    LoaderCoreOps.SetLinks[bcd, newBii, exportRecords];    IF linkLoc = codeIfPossible THEN {      codeSets: LoaderCoreOps.CodeSetSequenceHandle = bcdExtra[newBii].codeSets;      FOR cs: LoaderCoreOps.CodeSetRange IN [0..codeSets.length) DO        LoadedMem.MakeCodeReadOnly[codeSets[cs].pointer]; ENDLOOP};    -- Now resolve any links which are imported by the already-loaded bcds    -- and are exported by the bcd being loaded.    -- (If this aborts, we will have to unbind to clean up the damage.)    -- Check for exported type clashes:    IF (bcd.nExports > 0 OR bcd.nConfigs = 0) THEN      BEGIN      modulesBoundToOtherBcds ¬ TRUE;      FOR existingBii: BcdInfoIndex DECREASING IN [0..loadState.nBcds.PRED) DO        existingBcd: BcdOps.BcdBase = bcdInfo[existingBii].base;        unresolvedModuleInfos: LoadState.ModuleInfoSequenceHandle ¬          IF bcdExtra[existingBii].resolved THEN NIL          ELSE LoadState.UnresolvedModuleInfosOfBcd[existingBii, scratch];        IF unresolvedModuleInfos # NIL THEN          BEGIN          ENABLE UNWIND => scratch.FREE[@unresolvedModuleInfos];	  exportsToSend: ERSequenceHandle ¬ exports;          bcdExtra[existingBii].resolved ¬ LoaderCoreOps.BindUnboundIfPossible[            importer: existingBcd, importerBii: existingBii,	    exports: exportsToSend, importerModuleInfo: unresolvedModuleInfos, 	    action: bind !            WrongVersion => {  -- Try again with all the exports --              IF exportsToSend # exportRecords THEN {	        exportsToSend ¬ exportRecords; RETRY }	      ELSE REJECT}]; -- reject the signal the 2nd time          scratch.FREE[@unresolvedModuleInfos];          END;        IF bcd.typeExported AND existingBcd.typeExported THEN          CheckExportedTypes[bcd, existingBcd];        ENDLOOP;      END;    END;  --scope of UNWIND => CleanUp--    CleanUp[whatToFree: controlInfoOnly];    END;  --CreateModulesAndBind--  ExpandBcdExtra: PROC =    BEGIN  -- when called, loadState has already been expanded    newExtra: LoaderCoreOps.BcdExtraSequenceHandle ¬ permanentZone.NEW[      LoaderCoreOps .BcdExtraSequence[loadState.maxBcds]];    firstNew: CARDINAL = IF bcdExtra = NIL THEN 0 ELSE bcdExtra.length;    FOR i: LoaderCoreOps.BcdExtraRange IN [0..firstNew) DO      newExtra[i] ¬ bcdExtra[i]; ENDLOOP;    FOR i: LoaderCoreOps.BcdExtraRange IN [firstNew..newExtra.maxLength) DO      newExtra[i] ¬ []; ENDLOOP;    IF bcdExtra # NIL THEN permanentZone.FREE[@bcdExtra];    bcdExtra ¬ newExtra;    bcdExtra.length ¬ firstNew;    END;  --ExpandBcdExtra  FreeGlobals: PUBLIC -- LoaderCore -- PROCEDURE [] =    BEGIN    -- The FREEs below are omitted since the zone is being deleted anyway.    IF exportRecords # NIL THEN      BEGIN      <<FOR i:CARDINAL IN [0..exportRecords.length) DO	permanentZone.FREE[@exportRecords[i].name];	permanentZone.FREE[@exportRecords[i].links];	ENDLOOP;>>      exportRecords ¬ NIL;      END;    IF bcdExtra # NIL THEN      BEGIN      <<FOR i:CARDINAL IN [0..bcdExtra.length) DO	permanentZone.FREE[@bcdExtra[i].frames];	permanentZone.FREE[@bcdExtra[i].framePack];	permanentZone.FREE[@bcdExtra[i].codeSets];	--FREE[bcdExtra[i].fingers]; and control lists in mds --        ENDLOOP;      permanentZone.FREE[@bcdExtra];>>      bcdExtra ¬ NIL;      END;    IF permanentZone # NIL THEN {      Heap.Delete[z: permanentZone, checkEmpty: FALSE];      permanentZone ¬ NIL};    scratch ¬ NIL;    END;  -- FreeGlobals --  -- This procedure allows MakeBoot initialization to clear the load state  -- of the environment that it is about to create.  InitGlobals: PUBLIC -- LoaderCore -- PROCEDURE [] =    BEGIN    FreeGlobals[];    permanentZone ¬ Heap.Create[      initial: 40, increment: 20, swapUnitSize: 5, largeNodeThreshold: 254];    END;  -- InitGlobals --  --========= Module Instance Creation and associated utilities: =========  AllocateModules: PROCEDURE [    bcd: BcdOps.BcdBase, bii: BcdInfoIndex, linkLoc: LoaderCore.LinkLoc] =    -- Allocates modules (global frames) of bcd, recording results in     -- loadInfo.module.    -- Also initalizes each frame's GlobalWord.    BEGIN    framePack: LoaderCoreOps.FramePackSequenceHandle;  -- (local copy of pointer)    module: LoaderCoreOps.ModuleSequenceHandle;  -- (local copy of pointer)    OrdinalFromFpi: PROC [ofpi: BcdDefs.FPIndex] RETURNS [c: CARDINAL ¬ 0] = {      Count: PROC [fph: BcdOps.FPHandle, fpi: BcdDefs.FPIndex]        RETURNS [quitNow: BOOLEAN] = {        IF fpi = ofpi THEN RETURN[TRUE] ELSE {c ¬ c + 1; RETURN[FALSE]}};      [] ¬ BcdOps.ProcessFrames[bcd, Count]};    AllocAndInitFramePack: PROC [fph: BcdOps.FPHandle, fpi: BcdDefs.FPIndex]      RETURNS [quitNow: BOOLEAN] =      -- Other arguments: linkLoc.      -- Allocates and initializes the modules of a frame pack.      BEGIN      fr: LoaderCoreOps.FramePackRange = OrdinalFromFpi[fpi];      frPack: LONG POINTER TO LoaderCoreOps.FramePackData = @framePack[fr];      mtBase: Table.Base = BcdOpsExtras.MTBaseFromBcd[bcd];      storageForNextFrame: LoadedMem.TargetLongAddress;      framePackSize: CARDINAL ¬ 0;      frPack.wheresTheStorage ¬ vm;  -- vm, unless a module demands mds.      FOR k: CARDINAL IN [0..fph.length) DO  -- find size and loc of frame pack        mth: BcdOps.MTHandle = @mtBase[fph.modules[k]];        [totalWordsNeeded: framePackSize] ¬ AccumulateFramePackSize[          mth: mth, linkLoc: linkLoc, wordsNeededAlready: framePackSize];        IF Where[mth] = mds THEN  -- any mds frame forces whole pack into mds          frPack.wheresTheStorage ¬ mds;        ENDLOOP;      frPack.smallFrame ¬ framePackSize <= maxSizeForSmallFramePack        AND System.switches[PilotSwitchesExtra6.useHeapForSmallGlobalFrames] =          down;      IF frPack.smallFrame THEN        BEGIN  -- allocate in word units        << Word Allocation Note: AccumulateFramePackSize (AFPS) has tallied	storage assuming that the frame pack started on a page boundary, but 	in our case it will generally not do so. AFPS has certainly tallied 	enough to quad align all frames except the first. It may have added a	little extra for those frames which seemed to fall on page 	boundaries. For simplicity, we act as if it had not considered page 	boundaries at all. This will cause an expected waste of at worst 4 	words per page of frame pack or 1.6%. In the worst case, a global 	frame will fall on each page boundary of the frame pack; to handle 	this, we allocate an extra 4 words per page. >>        -- NOTE: There is a copy of this logic in the main body of AllocateModules.        framePackSize ¬  -- to get first frame on quad boundary          framePackSize + alignmentModulus - 1;        framePackSize ¬          framePackSize +  --  so can avoid all possible page boundarys            ((framePackSize + wordsPerPage - 1) / wordsPerPage) *              alignmentModulus;        frPack.storage ¬          SELECT frPack.wheresTheStorage FROM            mds => LoadedMem.Long[              LoadedMem.AllocateMDSWords[framePackSize, framePack]],            vm => AllocWithin64K[framePackSize, wordUnits, framePack],            ENDCASE => ERROR;        END      ELSE  -- allocate in page units        frPack.storage ¬          SELECT frPack.wheresTheStorage FROM            vm => AllocWithin64K[framePackSize, pageUnits, framePack],            mds => LoadedMem.Long[              LoadedMem.AllocateMDSPages[framePackSize, framePack]],            ENDCASE => ERROR;      storageForNextFrame ¬ frPack.storage;      FOR k: CARDINAL IN [0..fph.length) DO        [updatedFrameStorage: storageForNextFrame] ¬ InitFrame[          fph.modules[k], storageForNextFrame];        ENDLOOP;      IF Order[storageForNextFrame] > Order[frPack.storage] + framePackSize THEN        ERROR Bug[badAllocationArithmetic];      RETURN[quitNow: FALSE];      END;  --AllocAndInitFramePack--    unallocatedFramesSize: ARRAY WheresTheStorage OF CARDINAL;    AccumulateSizeOfUnallocated: PROC [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex]      RETURNS [quitNow: BOOLEAN] =      -- Other arguments: linkLoc.      -- Accumulates frame size of modules not yet allocated (unpackaged frames).      BEGIN      mod: LoaderCoreOps.ModuleRange = OrdinalFromMti[mti];      IF module[mod].info.gfi = PrincOpsExtras2.nullGFH THEN {        where: WheresTheStorage = Where[mth];        [totalWordsNeeded: unallocatedFramesSize[where]] ¬          AccumulateFramePackSize[          mth: mth, linkLoc: linkLoc,          wordsNeededAlready: unallocatedFramesSize[where]]};      RETURN[quitNow: FALSE];      END;  --AccumulateSizeOfUnallocated--    updatedFrameStorage: ARRAY WheresTheStorage OF      PrincOpsExtras2.LongGlobalFrameHandle;    InitFramesIfUninitialized: PROC [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex]      RETURNS [quitNow: BOOLEAN] =      -- Other arguments: updatedFrameStorage (which is indeed updated)      -- Initializes modules that are still uninitialized (unpackaged frames)      BEGIN      mod: CARDINAL = OrdinalFromMti[mti];      IF module[mod].info.gfi = PrincOpsExtras2.nullGFH THEN {        where: WheresTheStorage = Where[mth];        [updatedFrameStorage: updatedFrameStorage[where]] ¬ InitFrame[          mti, updatedFrameStorage[where]]};      RETURN[quitNow: FALSE];      END;  --InitFramesIfUninitialized--    nFramePacks: CARDINAL;    CountFramePacks: PROC [fph: BcdOps.FPHandle, fpi: BcdDefs.FPIndex]      RETURNS [quitNow: BOOLEAN] = {      nFramePacks ¬ nFramePacks + 1; RETURN[quitNow: FALSE]};    -- Begin main body of AllocateModules:    loadInfo.module ¬ module ¬ scratch.NEW[      LoaderCoreOps .ModuleSequence[bcd.nModules]];    FOR m: CARDINAL IN [0..module.length) DO      mti: BcdDefs.MTIndex = MtiFromOrdinal[m];      mth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, mti];      gfi: BcdDefs.GFIndex = BcdOpsExtras.GfiFromMti[mti];      module[m] ¬ [        info: [        resolved: (bcd.nImports = 0), cgfi: gfi, index: bii,        globalFrame: newWorld[gfi: PrincOpsExtras2.nullGFH]],        actualLinkLoc: GetActualLinkLoc[linkLoc, mth]];      ENDLOOP;    -- Packaged modules are mentioned in frame packs. Unpackaged modules are    -- not. Thus we must process frame packs first, then see what modules remain.    nFramePacks ¬ 0;    [] ¬ BcdOps.ProcessFrames[bcd, CountFramePacks];    IF nFramePacks > 0 THEN      BEGIN      bcdExtra[bii].framePack ¬ framePack ¬ permanentZone.NEW[        LoaderCoreOps .FramePackSequence[nFramePacks]];      FOR k: CARDINAL IN [0..framePack.length) DO        framePack[k] ¬ [storage: NIL, smallFrame: TRASH, wheresTheStorage: TRASH]        ENDLOOP;      [] ¬ BcdOps.ProcessFrames[bcd, AllocAndInitFramePack];      END;    -- Now process the unpackaged modules:    unallocatedFramesSize ¬ ALL[0];    [] ¬ BcdOps.ProcessModules[bcd, AccumulateSizeOfUnallocated];    updatedFrameStorage ¬ ALL[NIL];    bcdExtra[bii].storage ¬ [mds: NIL, vm: NIL];    FOR where: WheresTheStorage IN WheresTheStorage DO      size: CARDINAL ¬ unallocatedFramesSize[where];      IF size = 0 THEN LOOP;      -- "Word Allocation Note" in AllocAndInitFramePack describes this logic:      size ¬ size + alignmentModulus - 1;      size ¬ size + ((size + wordsPerPage - 1) / wordsPerPage) * alignmentModulus;      SELECT where FROM        mds =>          bcdExtra[bii].storage.mds ¬ updatedFrameStorage[mds] ¬ LoadedMem.Long[            LoadedMem.AllocateMDSWords[size, unpackagedFrame]];        vm =>          bcdExtra[bii].storage.vm ¬ updatedFrameStorage[vm] ¬ AllocWithin64K[            size, wordUnits, unpackagedFrame];        ENDCASE;      unallocatedFramesSize[where] ¬ size;  -- save actual size for oflow check.      ENDLOOP;    [] ¬ BcdOps.ProcessModules[bcd, InitFramesIfUninitialized];    IF Order[updatedFrameStorage[vm]] >      Order[bcdExtra[bii].storage.vm] + unallocatedFramesSize[vm]      OR Order[updatedFrameStorage[mds]] >        Order[bcdExtra[bii].storage.mds] + unallocatedFramesSize[mds] THEN      ERROR Bug[badAllocationArithmetic];    bcdExtra[bii].frames ¬ permanentZone.NEW[GFSequence [bcd.firstdummy]];    FOR i: CARDINAL IN [0..module.length) DO      bcdExtra[bii].frames[module[i].info.cgfi] ¬ module[i].info.gfi; ENDLOOP;    END;  --AllocateModules--  -- Module Instance Creation utilities:  InitFrame: PROCEDURE [mti: BcdDefs.MTIndex, frameStorage: LONG POINTER]    RETURNS [updatedFrameStorage: LONG POINTER] =    -- Derives the globalFrameHandle of the module using storage,    -- records the value in loadInfo.module[*].info.gf,    -- and returns pointer to next available word of storage.    -- Also initalizes frame's GlobalWord.    BEGIN    mth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, mti];    lfBase: Table.Base = BcdOpsExtras.LFBaseFromBcd[bcd];    globalframe: PrincOpsExtras2.LongGlobalFrameHandle;    gFrameOffset: CARDINAL ¬ PrincOpsExtras2.GlobalOverhead.SIZE;    moduleData: LONG POINTER TO LoaderCoreOps.ModuleData = @loadInfo.module[      OrdinalFromMti[mti]];    gfth: PrincOpsExtras2.GFTHandle;    IF moduleData.actualLinkLoc = frameLinks THEN      gFrameOffset ¬        gFrameOffset + lfBase[mth.links].length * PrincOpsExtras2.ImportLink.SIZE;    globalframe ¬ NextMultipleOfFourLong[frameStorage + gFrameOffset];    IF LOOPHOLE[globalframe, LONG CARDINAL] MOD wordsPerPage = 0 THEN      globalframe ¬ globalframe + alignmentModulus;  -- global[0] can't be at page bdy    gfth ¬ LoadState.EnterGlobalFrame[frame: globalframe, codebase:];    moduleData.info.gfi ¬ gfth;    LoadedMem.WriteExtraGlobalWord[      xgw: [      started: mth.tableCompiled, copy: FALSE, copied: TRUE, alloced: FALSE,      shared: FALSE, unused: 0], gf: globalframe];    LoadedMem.WriteGlobalWord[      gw: [      codelinks: moduleData.actualLinkLoc = codeLinks, trapxfers: FALSE,      gfi: PrincOpsExtras2.GFTHandleToIndex[gfth]], gf: globalframe];    -- global codebase is set later in the loading;    -- The links and control module are also set later.    RETURN[updatedFrameStorage: globalframe + (mth.framesize -  --      PrincOpsExtras2.GlobalOverhead.SIZE)];  --mth.framesize includes global overhead    END;  --InitFrame--  AccumulateFramePackSize: PROCEDURE [    mth: BcdOps.MTHandle, linkLoc: LoaderCore.LinkLoc,    wordsNeededAlready: CARDINAL] RETURNS [totalWordsNeeded: CARDINAL] =    -- Adds to wordsNeededAlready the amount needed for this module    --   and returns the total.    -- Assumes frame pack starts on a page boundary (used for    --   global[0] vs page boundary check).    BEGIN    lfBase: Table.Base = BcdOpsExtras.LFBaseFromBcd[bcd];    totalWordsNeeded ¬ wordsNeededAlready + PrincOpsExtras2.GlobalOverhead.SIZE;    IF GetActualLinkLoc[linkLoc, mth] = frameLinks THEN      totalWordsNeeded ¬        totalWordsNeeded +          lfBase[mth.links].length * PrincOpsExtras2.ImportLink.SIZE;    -- At this point, totalWordsNeeded represents the address of the frame.    totalWordsNeeded ¬ NextMultipleOfFour[totalWordsNeeded];    IF totalWordsNeeded MOD wordsPerPage = 0 THEN      totalWordsNeeded ¬ totalWordsNeeded + alignmentModulus;  -- avoid page boundary    totalWordsNeeded ¬      totalWordsNeeded +  --        mth.framesize  -- mth.framesize includes global overhead        - PrincOpsExtras2.GlobalOverhead.SIZE;    END;  --AccumulateFramePackSize--  --============= Code Segment Allocation and Mapping: =============  CreateCodeSegSequence: PROC [bcd: BcdOps.BcdBase, zone: UNCOUNTED ZONE]    RETURNS [codeSeg: LoaderCoreOps.CodeSegSequenceHandle, codeSets: CARDINAL] =    BEGIN    -- Returns a LoaderCoreOps.CodeSegSequence ordered by segment base address    -- NOTE that there other, non-code segments in the bcd's Segment Table.    nCodeSegments: LoaderCoreOps.CodeSegRange;    curSeg: LoaderCoreOps.CodeSegRange;    codeSetPages: CARDINAL ¬ 0;    TallyIfCodeSegment: PROC [sgh: BcdOps.SGHandle, sgi: BcdDefs.SGIndex]      RETURNS [quitNow: BOOLEAN] =      -- Other arguments: nCodeSegments. Other results: nCodeSegments.      BEGIN      IF sgh.class = code THEN {        IF sgh.file # BcdDefs.FTSelf THEN ERROR Runtime.ConfigError[missingCode];        nCodeSegments ¬ nCodeSegments.SUCC};      RETURN[quitNow: FALSE];      END;    RememberCodeSegHandle: PROC [sgh: BcdOps.SGHandle, sgi: BcdDefs.SGIndex]      RETURNS [quitNow: BOOLEAN] =      -- Other arguments: curSeg, codeSeg. Other results: curSeg.      BEGIN      IF sgh.class = code THEN {        codeSeg[curSeg] ¬ [sgh: sgh, address: NIL]; curSeg ¬ curSeg.SUCC};      RETURN[quitNow: FALSE];      END;    nCodeSegments ¬ 0;    [] ¬ BcdOps.ProcessSegs[bcd, TallyIfCodeSegment];    IF nCodeSegments = 0 THEN RETURN[NIL, 0];    codeSeg ¬ zone.NEW[LoaderCoreOps .CodeSegSequence[nCodeSegments]];    -- Get and stash code segment handles:    curSeg ¬ 0;  -- for RememberCodeSegHandle    [] ¬ BcdOps.ProcessSegs[bcd, RememberCodeSegHandle];    -- Sort code segment array by order of increasing segment base address:    FOR n: LoaderCoreOps.CodeSegRange DECREASING IN [1..codeSeg.length / 2] DO      SiftUp[codeSeg, n, codeSeg.length] ENDLOOP;    FOR n: LoaderCoreOps.CodeSegRange DECREASING IN [1..codeSeg.length) DO      sgItem: LoaderCoreOps.CodeSegData = codeSeg[1 - 1];      codeSeg[1 - 1] ¬ codeSeg[n + 1 - 1];      codeSeg[n + 1 - 1] ¬ sgItem;      SiftUp[codeSeg, 1, n];      ENDLOOP;    codeSets ¬ 0;    codeSetPages ¬ LoaderCoreOps.maxPagesInCodeSet;  -- to force overflow    FOR curSeg ¬ 0, curSeg + 1 WHILE curSeg < codeSeg.length DO      sgh: BcdOps.SGHandle = codeSeg[curSeg].sgh;      IF codeSetPages + sgh.pages > LoaderCoreOps.maxPagesInCodeSet THEN {        codeSets ¬ codeSets + 1; codeSetPages ¬ sgh.pages}      ELSE codeSetPages ¬ codeSetPages + sgh.pages;      ENDLOOP;    END;  SiftUp: PROCEDURE [    codeSeg: LoaderCoreOps.CodeSegSequenceHandle, low, high: CARDINAL] =    -- Partial sort of codeSeg by order of increasing segment base address.    BEGIN    k, son, kTimes2: CARDINAL;    sgItem: LoaderCoreOps.CodeSegData;    k ¬ low;    DO      kTimes2 ¬ k * 2;      IF kTimes2 > high THEN EXIT;      IF kTimes2 + 1 > high        OR codeSeg[kTimes2 + 1 - 1].sgh.base < codeSeg[kTimes2 - 1].sgh.base THEN        son ¬ kTimes2      ELSE son ¬ kTimes2 + 1;      IF codeSeg[son - 1].sgh.base < codeSeg[k - 1].sgh.base THEN EXIT;      sgItem ¬ codeSeg[son - 1];      codeSeg[son - 1] ¬ codeSeg[k - 1];      codeSeg[k - 1] ¬ sgItem;      k ¬ son;      ENDLOOP;    END;  --SiftUp--  MapCodeAndSetCodebases: PROCEDURE [    bcd: BcdOps.BcdBase, linkLoc: LoaderCore.LinkLoc]    RETURNS [codeSets: LoaderCoreOps.CodeSetSequenceHandle] =    BEGIN    -- NOTE that there other, non-code segments in the bcd's Segment Table.    codeSeg: LoaderCoreOps.CodeSegSequenceHandle;  -- (local copy of pointer)    nCodeSets: CARDINAL;    SetModuleCodebase: PROC [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex]      RETURNS [quitNow: BOOLEAN] =      -- Initializes codebase of module,       BEGIN      mod: LoaderCoreOps.ModuleRange = OrdinalFromMti[mti];      sgb: Table.Base = BcdOpsExtras.SGBaseFromBcd[bcd];      sgh: BcdOps.SGHandle = @sgb[mth.code.sgi];      codeBase: PrincOps.GlobalCodebase;      -- Search codeSeg array for the code segment containing mth,      -- and get that module's codebase:      FOR k: CARDINAL IN [0..codeSeg.length) DO        IF codeSeg[k].sgh = sgh THEN {          codeBase ¬ LOOPHOLE[codeSeg[k].address + mth.code.offset]; EXIT};        REPEAT FINISHED => Bug[segmentNotFound];        ENDLOOP;      codeBase.out ¬ TRUE;  -- causes start trap.      LoadedMem.WriteCodebase[gf: loadInfo.module[mod].info.gfi, gcb: codeBase];      RETURN[quitNow: FALSE];      END;  --SetModuleCodebase--    -- Begin main text of MapCodeAndSetCodebases:    -- Make sequence of code segments:    [codeSeg, nCodeSets] ¬ CreateCodeSegSequence[bcd, scratch];    loadInfo.codeSeg ¬ codeSeg;    IF codeSeg = NIL THEN ERROR Runtime.ConfigError[ --noCodeSegs-- missingCode];    IF inMakeBoot THEN      codeSets ¬ MakeBootCodeSets[bcd, codeSeg, linkLoc, nCodeSets]    ELSE codeSets ¬ AllocateAndMapCode[bcd, codeSeg, linkLoc, nCodeSets];    [] ¬ BcdOps.ProcessModules[bcd, SetModuleCodebase];    END;  --MapCodeAndSetCodebases--  -- Code Segment Utilities:  MakeBootCodeSets: PROCEDURE [    bcd: BcdOps.BcdBase, codeSeg: LoaderCoreOps.CodeSegSequenceHandle,    linkLoc: LoaderCore.LinkLoc, nCodeSets: CARDINAL]    RETURNS [codeSets: LoaderCoreOps.CodeSetSequenceHandle] = {    codeAccess: LoadedMem.Access =      IF linkLoc = frame THEN readOnly ELSE readWrite;    codeSets ¬ permanentZone.NEW[LoaderCoreOps .CodeSetSequence[codeSeg.length]];    FOR i: CARDINAL IN [0..codeSeg.length) DO      codeSets[i].interval.pages ¬ codeSeg[i].sgh.pages;      codeSeg[i].address ¬ codeSets[i].interval.pointer ¬ LoadedMem.MapCode[        bcd: bcd, swapUnits: NIL, access: codeAccess,        pageOffset: codeSeg[i].sgh.base - BcdOpsExtras.segmentBaseOrigin,        pageCount: codeSets[i].interval.pages];      ENDLOOP;    };  AllocateAndMapCode: PROCEDURE [    bcd: BcdOps.BcdBase, codeSeg: LoaderCoreOps.CodeSegSequenceHandle,    linkLoc: LoaderCore.LinkLoc, nCodeSets: CARDINAL]    RETURNS [codeSets: LoaderCoreOps.CodeSetSequenceHandle] =    BEGIN    maxSwapUnits: CARDINAL =  -- certainly enough since code set <= maxPagesInMDS pages.      Environment.maxPagesInMDS;    setI: CARDINAL ¬ 0;    SwapUnitRange: TYPE = [0..maxSwapUnits);  -- fixed size for simplicity and perf.    SwapUnitArray: TYPE = ARRAY SwapUnitRange OF LoadedMem.SwapUnitSize;    codeSetSwapUnits: LONG POINTER TO SwapUnitArray ¬ scratch.NEW[SwapUnitArray];    curSeg: LoaderCoreOps.CodeSegRange;  -- the segment next to be considered.    codeAccess: LoadedMem.Access =      IF linkLoc = frame THEN readOnly ELSE readWrite;    BEGIN    ENABLE      UNWIND => {scratch.FREE[@codeSetSwapUnits]; permanentZone.FREE[@codeSets]};    <<Within a single bcd, all of the code segments occur contiguously    in the file. The code below makes use of this fact to reduce the number    of mapped spaces, thus reducing the number of map units in Pilot's database.>>    -- DEFINITION: A code set is a sequence of contiguous code segments.    codeSets ¬ permanentZone.NEW[LoaderCoreOps .CodeSetSequence[nCodeSets]];    curSeg ¬ 0;    WHILE curSeg < codeSeg.length DO      codeSetStartSeg: LoaderCoreOps.CodeSegRange ¬ curSeg;      pageOffsetCodeSet: CARDINAL = codeSeg[curSeg].sgh.base;      pageCountCodeSet: CARDINAL ¬ 0;      segAddress: LoadedMem.TargetLongAddress;      -- Accumulate next code set and its swap units:      codeSetSwapUnit: SwapUnitRange ¬ 0;      WHILE curSeg < codeSeg.length DO        sph: BcdOps.SPHandle;        sgh: BcdOps.SGHandle = codeSeg[curSeg].sgh;        newCount: CARDINAL ¬ pageCountCodeSet + sgh.pages;        IF --UNTIL-- newCount > LoaderCoreOps.maxPagesInCodeSet THEN EXIT;        -- We include this code segment in the code set.        IF sgh.base # pageOffsetCodeSet + pageCountCodeSet THEN          ERROR Bug[codeSegsNotContiguous];        sph ¬ BcdOpsExtras.SPHandleFromSGHandle[bcd, sgh];        IF sph = NIL THEN {  -- no swap units within this code seg.          codeSetSwapUnits[codeSetSwapUnit] ¬ sgh.pages;  -- All one swap unit          codeSetSwapUnit ¬ codeSetSwapUnit.SUCC}        ELSE          BEGIN  --explicit swap units within code seg--          suOffset: CARDINAL ¬ 0;          FOR sp: CARDINAL IN [0..sph.length) DO            IF sph.spaces[sp].offset # suOffset THEN              ERROR Bug[swapUnitsOutOfOrder];            codeSetSwapUnits[codeSetSwapUnit] ¬ sph.spaces[sp].pages;            suOffset ¬ codeSetSwapUnits[codeSetSwapUnit] + suOffset;            codeSetSwapUnit ¬ codeSetSwapUnit.SUCC;            ENDLOOP;          END;        pageCountCodeSet ¬ newCount;        curSeg ¬ curSeg.SUCC;        ENDLOOP;  --Adding code seg to code set--      -- Allocate VM and map this code set:      segAddress ¬ LoadedMem.MapCode[        bcd: bcd, swapUnits: DESCRIPTOR[codeSetSwapUnits, codeSetSwapUnit],        pageOffset: pageOffsetCodeSet - BcdOpsExtras.segmentBaseOrigin,        pageCount: pageCountCodeSet, access: codeAccess];      codeSets[setI] ¬ [[pointer: segAddress, pages: pageCountCodeSet]];      setI ¬ setI + 1;      -- Remember address of each code segment:      FOR seg: LoaderCoreOps.CodeSegRange IN [codeSetStartSeg..curSeg) DO        codeSeg[seg].address ¬ segAddress;        segAddress ¬ segAddress + codeSeg[seg].sgh.pages * wordsPerPage;        ENDLOOP;      ENDLOOP;  --Accumulating and mapping code set--    END;  --UNWIND => scratch.FREE[@codeSetSwapUnits]--    scratch.FREE[@codeSetSwapUnits];    END;  --AllocateAndMapCode--  --============= Control Modules and associated utilities: =============  AssignControlModules: PROCEDURE [bcd: BcdOps.BcdBase]    RETURNS [      control: PrincOpsExtras2.LongGlobalFrameHandle,      fingers: ControlModuleFormat.Fingers ¬ NIL, nFingers: CARDINAL ¬ 0] =    -- Creates control list data structures. Returns the control module of the bcd.    BEGIN    ctBase: Table.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    <<mtBase: Table.Base = BcdOpsExtras.MTBaseFromBcd[bcd];  (not used)>>    config: LONG POINTER TO LoaderCoreOps.ConfigSequence;  -- (local copy of pointer)    OrdinalFromCti: PROC [octi: BcdDefs.CTIndex] RETURNS [c: CARDINAL ¬ 0] = {      Count: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex]        RETURNS [quitNow: BOOLEAN] = {        IF cti = octi THEN RETURN[TRUE] ELSE {c ¬ c + 1; RETURN[FALSE]}};      [] ¬ BcdOps.ProcessConfigs[bcd, Count]};    CtiFromOrdinal: PROC [ordinal: LoaderCoreOps.ConfigRange]      RETURNS [BcdDefs.CTIndex] = {      -- Returns BcdDefs.CTIndex given zero-origin ordinal of config in bcd's module table.      -- Not "Index" since BcdDefs uses that term for relative pointers!      k: CARDINAL ¬ 0;      Count: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex]        RETURNS [quitNow: BOOLEAN] = {        IF k = ordinal THEN RETURN[TRUE] ELSE {k ¬ k + 1; RETURN[FALSE]}};      RETURN[BcdOps.ProcessConfigs[bcd, Count].cti]};    CreateControlList: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex]      RETURNS [quitNow: BOOLEAN] =      -- Other arguments: config, nFingers. Other results: nFingers.      -- Locates control config and control list, allocating      -- and initializing ListHeads as needed.      -- Initializes loadInfo.config except for .finger.      -- Tallies nFingers.      BEGIN      ctBase: Table.Base = BcdOpsExtras.CTBaseFromBcd[bcd];      controlCti: BcdDefs.CTIndex;      list: ControlModuleFormat.List;      -- Find control config, allocate list: (set list and controlCti)      IF cth.nControls = 0 THEN        BEGIN  --this config (itself) has no control modules--        list ¬ NIL;        -- Search up through parent configs looking for a control config:        FOR controlCti ¬ cth.config, ctBase[controlCti].config UNTIL controlCti =          BcdDefs.CTNull OR ctBase[controlCti].nControls # 0 DO ENDLOOP;        END      ELSE        BEGIN  --this config (itself) has control modules--        listHead: ControlModuleFormat.ListHead ¬ [          length: cth.nControls, parent: NIL, items:];        nFingers ¬ nFingers.SUCC;        list ¬ LoadedMem.AllocateMDSWords[          size:          SIZE[ControlModuleFormat.ListHead] +            cth.nControls * SIZE[ControlModuleFormat.Item],          content: controlModuleList];        LoadedMem.WriteMDSBlock[          targetAddress: list, localAddress: LONG[@listHead],          size: ControlModuleFormat.ListHead.SIZE, access: readWrite];        controlCti ¬ cti;        END;  --this config (itself) has control modules--      config[OrdinalFromCti[cti]] ¬ [        controlCti: controlCti, list: list, finger: NIL];      RETURN[quitNow: FALSE];      END;  --CreateControlList--    SetControlModuleOfGFrame: PROC [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex]      RETURNS [quitNow: BOOLEAN] =      BEGIN      controlCti: BcdDefs.CTIndex = config[OrdinalFromCti[mth.config]].controlCti;      finger: ControlModuleFormat.Finger ¬        IF controlCti = BcdDefs.CTNull THEN NIL        ELSE config[OrdinalFromCti[controlCti]].finger;      gf: PrincOpsExtras2.LongGlobalFrameHandle =        LoadedMem.GlobalFrameFromGFTHandle[        loadInfo.module[OrdinalFromMti[mti]].info.gfi];      LoadedMem.WriteBlock[        targetAddress: @gf[0], localAddress: LONG[@finger],        size: ControlModuleFormat.Finger.SIZE, access: readWrite];      RETURN[quitNow: FALSE];      END;  --SetControlModuleOfGFrame--    ModuleOfFinger: PROC [finger: ControlModuleFormat.Finger]      RETURNS [gfi: PrincOpsExtras2.GFTHandle] =      BEGIN      list: ControlModuleFormat.List;      length: CARDINAL;      IF finger = NIL THEN RETURN[PrincOpsExtras2.nullGFH];      LoadedMem.ReadMDSBlock[        targetAddress: finger, localAddress: @list,        size: ControlModuleFormat.List.SIZE];      -- BGY      length ¬ LoadedMem.ReadMDSWord[targetAddress: @list.length];      -- Use a direct item if any:       FOR k: CARDINAL IN [0..length) DO        item: ControlModuleFormat.Item;        LoadedMem.ReadMDSBlock[          targetAddress: @list.items[k], localAddress: @item,          size: ControlModuleFormat.Item.SIZE];        WITH it: item SELECT FROM --indirect:-- FALSE => RETURN[it.gfi];          ENDCASE => NULL;        ENDLOOP;      -- No direct items. Use any suitable indirect:      FOR k: CARDINAL IN [0..length) DO        item: ControlModuleFormat.Item;        LoadedMem.ReadMDSBlock[          targetAddress: @list.items[k], localAddress: @item,          size: ControlModuleFormat.Item.SIZE];        WITH it: item SELECT FROM          --indirect:--          TRUE =>            BEGIN            newItem: --indirect:-- FALSE ControlModuleFormat.Item ¬ [              --indirect:-- FALSE[gfi: ModuleOfFinger[it.finger]]];            LoadedMem.WriteMDSBlock[              targetAddress: @list.items[k], localAddress: @newItem,              size: ControlModuleFormat.Item.SIZE, access: readWrite];            RETURN[newItem.gfi];            END;          ENDCASE => NULL;        ENDLOOP;      ERROR Bug[vacuousList];      END;  --ModuleOfFinger--    FillInControlList: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex]      RETURNS [quitNow: BOOLEAN] =      -- Fills in control list for this config.      BEGIN      list: ControlModuleFormat.List;      IF cth.nControls = 0 THEN RETURN[quitNow: FALSE];      list ¬ loadInfo.config[OrdinalFromCti[cti]].list;      FOR ctl: CARDINAL IN [0..cth.nControls) DO        item: ControlModuleFormat.Item ¬          WITH cm: cth.controls[ctl] SELECT FROM            config => [              --indirect:-- TRUE[              finger: loadInfo.config[OrdinalFromCti[cm.cti]].finger]],            module => [              --indirect:-- FALSE[              gfi: loadInfo.module[OrdinalFromMti[cm.mti]].info.gfi]],            ENDCASE => ERROR;        LoadedMem.WriteMDSBlock[          targetAddress: @list.items[ctl], localAddress: LONG[@item],          size: ControlModuleFormat.Item.SIZE, access: readWrite];        ENDLOOP;      IF cth.config # BcdDefs.CTNull THEN        BEGIN        controlCti: BcdDefs.CTIndex = loadInfo.config[          OrdinalFromCti[cth.config]].controlCti;        IF controlCti # BcdDefs.CTNull THEN          LoadedMem.WriteMDSBlock[            targetAddress: @list.parent,            localAddress: @loadInfo.config[OrdinalFromCti[controlCti]].finger,            size: ControlModuleFormat.Finger.SIZE, access: readWrite];        END;      RETURN[quitNow: FALSE];      END;  --FillInControlList--    -- Begin main text of AssignControlModules:    IF bcd.nConfigs = 0 THEN {      control ¬ LoadedMem.GlobalFrameFromGFTHandle[loadInfo.module[0].info.gfi];      LoadedMem.WriteWord[        targetAddress: @control[0], word: ControlModuleFormat.Finger.NIL,        access: readWrite];      RETURN};    loadInfo.config ¬ config ¬ scratch.NEW[      LoaderCoreOps .ConfigSequence[bcd.nConfigs]];    nFingers ¬ 0;    [ --nFingers-- ] ¬ BcdOps.ProcessConfigs[bcd, CreateControlList];    IF nFingers > 0 THEN      BEGIN  -- Allocate and initialize fingers:      f: CARDINAL ¬ 0;      fingers ¬ LoadedMem.AllocateMDSWords[        size: nFingers * ControlModuleFormat.List.SIZE,        content: controlModuleList];      FOR c: LoaderCoreOps.ConfigRange IN [0..config.length) DO        IF config[c].controlCti = CtiFromOrdinal[c] THEN          BEGIN          -- Note that config[*].finger was previously initialized          -- to NIL by CreateControlList.          config[c].finger ¬ @fingers[f];          LoadedMem.WriteMDSBlock[            targetAddress: @fingers[f], localAddress: @config[c].list,            size: ControlModuleFormat.List.SIZE, access: readWrite];          f ¬ f.SUCC;          IF f >= nFingers THEN EXIT;          END;        ENDLOOP;      END;    [] ¬ BcdOps.ProcessConfigs[bcd, FillInControlList];    [] ¬ BcdOps.ProcessModules[bcd, SetControlModuleOfGFrame];    FOR c: LoaderCoreOps.ConfigRange IN [0..config.length) DO      IF ctBase[CtiFromOrdinal[c]].config = BcdDefs.CTNull THEN {        control ¬ LoadedMem.GlobalFrameFromGFTHandle[          ModuleOfFinger[config[c].finger]];        EXIT};      REPEAT FINISHED => ERROR Bug[topControlNotFound];      ENDLOOP;    END;  --AssignControlModules--  -- Control Module Utilities:  --============= Import/Export and associated utilities: =============  CheckExportedTypes: PROCEDURE [bcd1, bcd2: BcdOps.BcdBase] =    BEGIN    -- Raises error if bcd1 and bcd2 export the same type    -- with differing concrete implementations.    typb1: Table.Base = BcdOpsExtras.TYPBaseFromBcd[bcd1];    typb2: Table.Base = BcdOpsExtras.TYPBaseFromBcd[bcd2];    TypeMap1: PROC [tmh1: BcdOps.TMHandle, tmi1: BcdDefs.TMIndex]      RETURNS [quitNow: BOOLEAN] =      BEGIN      TypeMap2: PROC [tmh2: BcdOps.TMHandle, tmi2: BcdDefs.TMIndex]        RETURNS [quitNow: BOOLEAN] =        BEGIN        IF tmh2.offset = tmh1.offset AND tmh2.version = tmh1.version THEN          BEGIN          IF typb1[tmh1.map] # typb2[tmh2.map] THEN            ERROR Runtime.ConfigError[exportedTypeClash];          RETURN[quitNow: TRUE];  -- exported types match.          END        ELSE RETURN[FALSE];  -- not same type.        END;  --TypeMap2--      [] ¬ BcdOps.ProcessTypeMap[bcd2, TypeMap2];      RETURN[FALSE];      END;  --TypeMap1--    [] ¬ BcdOps.ProcessTypeMap[bcd1, TypeMap1];    RETURN    END;  --CheckExportedTypes--  --============= General Utilities: =============  Units: TYPE = {pageUnits, wordUnits};  AllocWithin64K: PROCEDURE [    wordSize: CARDINAL, units: Units, content: LoadedMem.Content]    RETURNS [storage: LONG POINTER] =    -- Allocates a block in vm of given wordSize composed of given units    -- which doesn't cross a 64K boundary.    BEGIN    trialBlock: LONG POINTER =      SELECT units FROM        pageUnits => LoadedMem.AllocatePages[wordSize, content],        wordUnits => LoadedMem.AllocateWords[wordSize, content],        ENDCASE => ERROR;    -- Check 64K boundary:    IF Inline.HighHalf[trialBlock] = Inline.HighHalf[trialBlock + wordSize - 1]      THEN RETURN[storage: trialBlock];    -- trialBlock crosses 64K boundary.     -- In order to assure termination, we hang onto this block so that     -- the next AllocWithin64K will get a different one.    storage ¬ AllocWithin64K[wordSize, units, content];    SELECT units FROM      pageUnits => [] ¬ LoadedMem.FreePages[trialBlock];      wordUnits => [] ¬ LoadedMem.FreeWords[trialBlock];      ENDCASE => ERROR;    END;  --AllocWithin64K  WhatToFree: TYPE = {controlInfoOnly, controlInfoAndObjects};  FreeLoadInfo: PROCEDURE [whatToFree: WhatToFree, bii: BcdInfoIndex] =    -- Deallocates all temp storage of loadInfo.    -- If free = controlInfoAndObjects, also frees the objects themselves.    BEGIN    IF loadInfo.module # NIL THEN scratch.FREE[@loadInfo.module];    IF loadInfo.codeSeg # NIL THEN      BEGIN      codeSeg: LoaderCoreOps.CodeSegSequenceHandle = loadInfo.codeSeg;      IF whatToFree = controlInfoAndObjects THEN {        codeSets: LoaderCoreOps.CodeSetSequenceHandle ¬ bcdExtra[bii].codeSets;        IF codeSets # NIL THEN {          FOR k: CARDINAL IN [0..codeSets.length) DO            [] ¬ LoadedMem.UnmapCode[codeSets[k].pointer]; ENDLOOP;          permanentZone.FREE[@codeSets]};        bcdExtra[bii] ¬ []};      scratch.FREE[@loadInfo.codeSeg];      END;    IF loadInfo.config # NIL THEN      BEGIN      fingersFree: BOOLEAN ¬ FALSE;      config: LoaderCoreOps.ConfigSequenceHandle = loadInfo.config;      IF whatToFree = controlInfoAndObjects THEN        FOR k: CARDINAL IN [0..config.length) DO          IF ~fingersFree AND config[k].finger # NIL THEN {            << fingers are allocated in order of the config sequence, so the	    address of the first one found is the address of the chunk of 	    storage obtained from AllocateMDSWords>>            [] ¬ LoadedMem.FreeMDSWords[config[k].finger]; fingersFree ¬ TRUE};          IF config[k].list # NIL THEN            [] ¬ LoadedMem.FreeMDSWords[config[k].list];          ENDLOOP;      scratch.FREE[@loadInfo.config];      END;    END;  --FreeLoadInfo--  -- MAIN body  InitGlobals[];  END.LOG  (For previous log entries, please see Mesa 10.0 archive version.) 4-Dec-81 11:34:27   WDK   Exported type clash must be a ConfigError, not a VersionMismatch. 4-Jan-82 14:27:30   JGS   Config control module fingers must be stored in even addresses. 7-Sep-83 14:07:55   WDK   Made compatible with new LoadState and new interface LoadedMem. Ditch OPENs. Renamed from PilotLoaderCore to LoaderCoreImpl. Moved utility procs here from PilotLoaderSupport (old name). Desupported resident frames. Eliminated most loopholes. Better names. Eliminated dull one line procs. Dealt with demise of GlobalFrameTable. Fingers no longer have to be on 0 mod 2 boundaries. Quit looking at exporters as soon as module's imports are resolved. Resolve all imports first to avoid leaving a mess if load operaiton aborts. Create/maintain transient data structure describing objects being manipulated; back out cleanly on error. Unnest procs where reasonable. New ControlModuleFormat. Calculate values directly rather than by loops. Existing NEWed module instances were ignored in binding. Wrongly allowed access to all modules of config, not just exported ones. Single-module determination logic was wrong. Reorganize so as to also function as the loader in MakeBoot. Reorganize to make bootstrapping easier. Wasn't mapping whole code sets as a unit. Don't struggle to allocate all control lists in a block. Delete unused strings. Desupported gFrame.word.shared. Added lots of error checking.   19-Sep-83 16:12:05	RES   Moved type declarations into LoaderCoreOps10-Oct-83 16:52:01	RES  Fixed Unloading by not trying to resolve imports of remaining modules that were resolved internally (added dummyLink parameter to Interesting)11-Oct-83 15:35:03	RES  Put modules into loadstate before binding imports since if we export some link (like say a SIGNAL or ERROR) that we also export, it goes to the loadstate to get the global frame address.  It will work better if it can find it there at that point.20-Oct-83 15:56:37   WDK   AR 4715: Load[fileSatifyingPrevFilesFrameLinks] => Write Protect Fault 9-Nov-83 14:47:51   WDK   ExpandTablesInternal now returns new load state address, allowing us to not address fault.17-Nov-83 19:04:00   WDK   AllocAndInitIfUnallocated failed to provide enough slop to account for possibly inadequaterounding up in AccumulateFramePackSize.12-Dec-83 17:39:02   WDK   AR 2381: Mark table compiled modules as already started.16-Feb-84 11:19:07	RES  Initialize codeSets earlier as we were unwinding (and freeing them) beforehand if loading with code links on a readonly volume. 8-Jun-84 15:50:41	RES  Don't test against bcd in ResolveImportedLinks if unbinding. Fixes write protect fault from unloading a module that exported an item to the last thing loaded, if the last thing was loaded with code links. 9-Oct-84 13:46:11       ET   copyrite formatted.31-May-85  8:10:13       JGS & ET   Fix up wasted space when allocating unpackaged global frame space in AllocateModules, (AllocAndInitIfUnallocated split into AccumulateSizeOfUnallocated, InitFramesIfUninitialized). Adds in JGS's changes to include his new procedure SortImportsAndExports. Split LoaderCoreImpl into LoaderCoreImplA and LoaderCoreImplB.Set bcdExtra.length field in ExpandBcdExtra. 3-Jun-85 15:34:34       ET   Fixes FreeLoadInfo to FreeMDSWords for first module of bcd instead of looping through all the modules since AllocateModules now does one big NEW.11-Jun-85 15:54:40       ET   Changed AllocateModules to use bcdExtra[].storage vs module[].storage. Causes heapAllocated boolean in InitFrame to go away too.17-Jul-85 19:18:43       ET   Changed AllocAndInitFramePack to allocate from a heap for small frames under a page.   Moved framePack from loadInfo to bcdExtra.   Changed FreeLoadInfo and CleanUp to deallocate small frame packs.    Changed InitFrame and AccumulateFramePackSize to not add in GlobalOverhead since compiler adds it into module size.15-Apr-86 14:19:42	JGS & ET    Picked up all of JGS's edits. Added a few more. Getting rid of the old way of handling imports and exports to a new way with a table of export records that always stays around. 17-Jun-86 17:07:30      ET   Changed AssignControlModules to return fingers and nFingers so bcdExtra could keep track of storage to deallocateon an unload. AR  757923-Jun-86  7:28:52	ET	PrincOps changes for new and old bcds.30-Jun-86 16:04:00	BGY    Added inMakeBoot boolean.22-Jul-86  8:17:54	ET	Get AllocateModules to compile with new LoadStateFormat. 24-Jul-86 16:43:52	ET	Changed IF stmt in CleanUp code for freeing export storage. 15-Aug-86  9:33:36 	AHL  Deleted wheresTheStorage ¬ mds17-Feb-87 17:25:53	ET   NextMultipleOfSixtyFourK stuff to not let global frames cross 64k boundaries. New procedure, InitGlobals, for makeboot to call before it's first call to CreateModulesAndBind to avoid bogus links being re-used. Possible bug fix: InitFrames was returning globalFrame - 4 + .... I think this was wrong. Could be trampling over the previous global frame space. So I changed it to globalFrame - PrincOpsExtras2.GlobalOverhead.SIZE + ...>>22-Feb-87 16:30:31	ET   Change FreeWords to FreePages in AllocAndInitFramePack.23-Feb-87 20:23:17      ET   Fixed NextMultipleOfSixtyFourKBoundary to not equal itself in given a 64k boundary.12-Jun-87 14:21:27	AHL   Put allocation check near end of AllocateModules. Fixed return value of InitFrame27-Aug-87 10:38:35      WDK   Rewrote allocation algorithms inside AllocAndInitFramePack and in main body of AllocateModules. Simplified AccumulateSizeOfUnallocated and InitFramesIfUninitialized. Moved InitFramesIfUninitialized's loop initialization logic outside of loop. Simplified InitFrame. Restored ET's bug fix of 17-Feb to InitFrame, for this reason: If we compensated here for the compiler bug that overallocates frames by two words, then later when the compiler is fixed, the loader would mysteriously malfunction and the client world would fall apart.  Omitted useless FREEs in InitGlobals. Inlines move to head of module - defined before use. Simplified AccumulateFramePackSize, including stopping double allocating global overhead. Fix incorrect comments. Delete unused code. Renamed poorly named procedures. Deleted dull-seeming overheadInAllocatingFrames. Have main body use InitGlobals, thus reducing redundancy. Added FreeGlobals. Deleted now-unused inlines.11-Sep-87  7:02:38      ET set permanentZone to NIL in FreeGlobals so Makeboot can work again.26-Sep-87 16:58:19      ET Changed re-calling BindUnboundIfPossible in CreateModulesAndBind in call to BindUnboundIfPossible to a RETRY.13-Dec-87 14:13:19	ET Decrement bcdExtra in CleanUp when loadState is, to keep in in synch. (AR 12438)
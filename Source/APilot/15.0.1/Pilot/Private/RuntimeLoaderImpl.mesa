-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- Loader>RuntimeLoaderImpl.mesa      2-Jul-86 11:02:32 by MEW  -- This module provides public access to loading and unloading programs.-- TO DO:---- Rationalize defs: RuntimeInternal, LoadState.-- ConfigError badCode is obsolete.-- Where should GetSwapUnitsFromLoadedBcd go?DIRECTORY  BcdOps USING [BcdBase, MTHandle, SGHandle, SPHandle],  BcdOpsExtras USING [    MTBaseFromBcd, MtiFromGfi, SGBaseFromBcd, SPHandleFromSGHandle],  Environment USING [PageCount, PageFromLongPointer, PageNumber],  File USING [File, PageCount, PageNumber],  FrameExtras USING [GlobalOverhead, LongGFToGFTHandle, ReadCodebase],  LoadState USING [    BcdInfoIndex, GetModuleInfo, LockBcdInfo, LPBcdInfoTable, UnlockBcdInfo],  LoadStateFormat USING [Handle, ModuleInfo],  PrincOpsExtras2 USING [LongGlobalFrameHandle],  Runtime USING [ConfigErrorType, ControlLink],  RuntimeInternal USING [],  RuntimePrograms USING [],  Space USING [Deallocate, Interval, MapAt, nullInterval, UnmapAt, virtualMemory],  SpecialLoader,  SpecialSpace USING [AllocateForCode],  VM USING [GetSwapUnitAttributes, Interval, PageCount, Swappability],  Volume USING [GetAttributes, ReadOnly];RuntimeLoaderImpl: PROGRAM  IMPORTS    BcdOpsExtras, Environment, FrameExtras, LoadState, Space, SpecialLoader,     SpecialSpace, VM, Volume  EXPORTS Runtime, RuntimePrograms, RuntimeInternal --.GetSwapUnitsFromLoadedBcd--  =  BEGIN  -- PUBLIC Items:  ConfigError: PUBLIC --Runtime.-- ERROR [type: Runtime.ConfigErrorType] = CODE;  VersionMismatch: PUBLIC --Runtime.-- SIGNAL [module: LONG STRING] = CODE;  -- Copied types:  BcdInfoIndex: TYPE = LoadState.BcdInfoIndex;  LPBcdInfoTable: TYPE = LoadState.LPBcdInfoTable;      --==============================  -- Initialization:  --==============================  InitializeRuntimeLoader: PUBLIC --RuntimePrograms.-- PROCEDURE [] = {};  --==============================  -- Runtime Implementation:  --==============================  -- PUBLIC PROCS:  NewConfig: PUBLIC --Runtime.-- PROCEDURE [    file: File.File, offset: File.PageCount, codeLinks: BOOLEAN] = {    [] ¬ LoadConfig[file, offset, codeLinks]};  RunConfig: PUBLIC --Runtime.-- PROCEDURE [    file: File.File, offset: File.PageCount, codeLinks: BOOLEAN] = {    control: PROGRAM ¬ LoadConfig[file, offset, codeLinks];    IF control # NIL THEN START control};  LoadConfig: PUBLIC --Runtime.-- PROC [    file: File.File, offset: File.PageCount, codeLinks: BOOLEAN]    RETURNS [control: PROGRAM] =     BEGIN        MapSpace: SpecialLoader.MapProcType =      -- pageOffset, pageCount: CARDINAL,      -- swapUnits: Space.SwapUnits, access: Space.Access]      --RETURNS [mapUnitPtr: LONG POINTER]      BEGIN      interval: Space.Interval ¬ SpecialSpace.AllocateForCode[        pageCount, Space.virtualMemory];      RETURN[        Space.MapAt[          at: interval,          window: [file: file, base: offset + pageOffset, count: pageCount],          class: code, access: access, life: alive, swapUnits: swapUnits !          UNWIND => Space.Deallocate[interval]].mapUnit.pointer];      END;        -- check if volume is readonly    IF codeLinks = TRUE AND Volume.GetAttributes[file.volumeID].readOnly THEN      ERROR Volume.ReadOnly[file.volumeID];        RETURN SpecialLoader.LoadConfig[MapSpace, UnmapSpace, codeLinks];    END;          UnNewConfig: PUBLIC --Runtime-- PROC [link: Runtime.ControlLink] = {    SpecialLoader.UnNewConfig[link, UnmapSpace]};         --============= Loader/Unloader Unmapping CallBackProc: =============            UnmapSpace: SpecialLoader.UnmapProcType =    -- targetAddress: LONG POINTER]     -- RETURNS [mapUnit: Space.Interval]    BEGIN    mapUnit ¬ Space.nullInterval;    IF targetAddress # NIL THEN {      -- UnmapAt/Deallocate (vs. Unmap) done to get mapUnit.count      mapUnit ¬ Space.UnmapAt[targetAddress]; Space.Deallocate[mapUnit]};    END;    --============= RuntimeInternal: =============    -- SHOULD be in LoadState or ...  GetSwapUnitsFromLoadedBcd: PUBLIC --RuntimeInternal.-- PROCEDURE [    gf: PrincOpsExtras2.LongGlobalFrameHandle, page: Environment.PageNumber]    RETURNS [      interval: VM.Interval, swappability: VM.Swappability,      changeableSwappability: BOOLEAN] =    BEGIN    IF page = Environment.PageFromLongPointer[gf] THEN      BEGIN  --looking for swap units of a global frame--      IF FrameExtras.GlobalOverhead[gf].extra.alloced THEN        BEGIN        << NEEDS WORK - Dale >>        interval ¬ [page: page, count: 0];  -- hmmm! by munging around in the AV        -- we could deduce a size for this frame, but the client should not        -- be altering the swappability of this item anyway, so take the easy        -- way out - note that setting changeableSwappability to FALSE will        -- generate an ERROR in the caller anyway (SetSwappability in SpaceImpl)        swappability ¬ resident;        changeableSwappability ¬ FALSE;        END      ELSE        BEGIN  --gFrame exists in boot file        [swapUnit: interval, swappability: swappability] ¬          VM.GetSwapUnitAttributes[page];        changeableSwappability ¬ TRUE;        END;      END  --looking for swap units of a global frame--    ELSE      BEGIN  --looking for swap units of proc, catch code or entry vector--      -- to get at the irregular swap units (if any) that include the      -- given page, we must      -- a) scan the modules of the bcd looking for the one that corresponds      --    to the given global frame      -- b) from the module, get a segment index (sgi) and hence a segment      --    handle (sgh)      -- c) from the sgh try and get a space handle (sph) with SPHandleFromSGHandle      -- d) if none, assume unitary swap units, else scan irregular ones.      loadState: LoadStateFormat.Handle;      bcdInfo: LPBcdInfoTable;      [loadState, bcdInfo] ¬ LoadState.LockBcdInfo[];      BEGIN      ENABLE UNWIND => LoadState.UnlockBcdInfo[];      info: LoadStateFormat.ModuleInfo = LoadState.GetModuleInfo[        FrameExtras.LongGFToGFTHandle[gf]];      BEGIN  --block with local vars--      bcd: BcdOps.BcdBase = bcdInfo[info.index].base;      mth: BcdOps.MTHandle = @BcdOpsExtras.MTBaseFromBcd[bcd][        BcdOpsExtras.MtiFromGfi[info.cgfi]];      sgh: BcdOps.SGHandle = @BcdOpsExtras.SGBaseFromBcd[bcd][mth.code.sgi];      sph: BcdOps.SPHandle = BcdOpsExtras.SPHandleFromSGHandle[bcd, sgh];  -- got there at last!      IF sph # NIL THEN        BEGIN  -- irregular swapunits        base: Environment.PageNumber ¬ Environment.PageFromLongPointer[          FrameExtras.ReadCodebase[FrameExtras.LongGFToGFTHandle[gf]].codebase];        FOR i: CARDINAL IN [0..sph.length) DO          interval ¬ [            page: base + sph.spaces[i].offset, count: sph.spaces[i].pages];          IF page IN [interval.page..interval.page + interval.count) THEN EXIT;          ENDLOOP;        swappability ¬ VM.GetSwapUnitAttributes[page].swappability;        END      ELSE  -- there are no irregular swap units - must be unitary        [swapUnit: interval, swappability: swappability] ¬          VM.GetSwapUnitAttributes[page];      changeableSwappability ¬ TRUE;      END;  --block with local vars--      END;  --scope of UNWIND => UnlockBcdInfo--      LoadState.UnlockBcdInfo[];      END;  --looking for swap units of proc, catch code or entry vector--    END;  --GetSwapUnitsFromLoadedBcd--  END.LOG  (For previous log entries, please see Mesa 10.0 archive version.)20-May-83 14:19:30   JXP   	? 8-Jun-83 14:03:17   JXG    	?19-Aug-83  9:33:06   WDK        Ditch numerous blanket OPENs and blanket PUBLIC. PrincOpsRuntime and RuntimeInternalExtras went away. Clean up style and layout. Reorganize, alphabetize. Delete unnecessary procs Run, ... Eliminated MONITOR. Eliminated private signals and associated procs. Frame packs now allocated in separate space based on size, not on how many frames. Add error cleanup in many many places. Renamed module from PilotLoaderSupport to LoaderImpl. Deal with demise of global frame table. Use BcdOpsExtras. Shuffled most procs to LoaderCoreUtilsImpl.26-Sep-83 14:01:31   RES  	???12-Dec-83 18:10:03   WDK        AR 4814: Should translate Heap.Error[insufficientSpace]   into Space.InsufficientSpace30-Jul-84 15:44:33	EKN     LoaderImpl and RuntimeLoaderImpl equal old LoaderImpl.  LoadConfig makes calls into the new interface SpecialLoader. UnnewConfig added. 2-Jul-86 11:02:40	MEW   Updated to newest princops.
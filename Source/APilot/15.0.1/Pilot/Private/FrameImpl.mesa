-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- ResMemMgr>FrameImpl.mesa       7-Oct-83 10:23:21 by WDK     -- This module implements management of local frames. Its principal job is handling frame faults generated by Frame.Alloc and frame allocations generated by the xfer instructions.-- IMPLEMENTATION RESTRICTIONS: See comments at head of ResMemMgr.config.DIRECTORY  Environment USING [wordsPerPage],  Frame USING [Free],  PrincOps USING [    AV, AVHandle, AVHeapSize, AVItem, FrameSizeIndex,    frameSizeMap, LargeReturnSlot,    LocalFrameHandle, LocalOverhead, maxFrameSize],  Process USING [DisableAborts, Priority],  ProcessInternal USING [GetPriority, SetPriority],  ProcessOperations USING [    DisableInterrupts, EnableInterrupts, Enter, IndexToHandle,    ReEnter, Requeue, Wait],  ProcessPriorities USING [priorityFrameFault],  PSB USING [    FaultIndex, NoTimeout, PDA, PDABase, PsbHandle,    qFrameFault, QueueEmpty],  ResidentMemory USING [AllocateMDS, FreeMDS],  ResMemPerf USING [],  RuntimeInternal USING [Bug],  StoragePrograms USING [];FrameImpl: MONITOR LOCKS frameHeapLock  IMPORTS    Frame, Process, ProcessInternal, ProcessOperations, ResidentMemory,    RuntimeInternal  EXPORTS ResMemPerf, RuntimeInternal, StoragePrograms =  BEGIN    -- PARAMETERS:    largeFrameThresholdFsi: NormalFrameSizeIndex = 12;   -- Frames this size or larger will be allocated in an integral number   -- of pages, and reclaimed when they are freed.  thresholdSmallEnough: BOOLEAN[TRUE..TRUE] =  --    -- (small frames built from single pages)    frameSizeMap[largeFrameThresholdFsi-1] + FrameSegmentHeader.SIZE      <= wordsPerPage;  knownAtCompileTime: BOOLEAN[TRUE..thresholdSmallEnough] = TRUE;       -- Public items:    frameHeapLock: PUBLIC --RuntimeInternal.-- MONITORLOCK;  << This lock protects the local frame heap and associated global variables.  (However, since there is only one process that explicitly updates the frame  heap, this lock is only necessary to allow the frame fault process to have  a monitor to wait from.)>>  -- Performance data:    allFrameFaults: PUBLIC --ResMemPerf.-- CARDINAL ¬ 0;  largeFrameFaults: PUBLIC --ResMemPerf.--  CARDINAL ¬ 0;  currentSmallFramePages: PUBLIC --ResMemPerf.-- CARDINAL ¬ 0;  currentLargeFramePages: PUBLIC --ResMemPerf.-- CARDINAL ¬ 0;  currentLargeFrames: PUBLIC --ResMemPerf.-- CARDINAL ¬ 0;  -- Copied Types and Constants:  AV: PrincOps.AVHandle = PrincOps.AV;  frameSizeMap: ARRAY PrincOps.FrameSizeIndex OF [0..PrincOps.maxFrameSize] =    PrincOps.frameSizeMap;  LargeReturnSlot: CARDINAL = PrincOps.LargeReturnSlot;  pda: PSB.PDABase = PSB.PDA;  qFrameFault: PSB.FaultIndex = PSB.qFrameFault;  pFrameFaultCondition: LONG POINTER TO CONDITION = LOOPHOLE[    @pda.fault[qFrameFault].condition];  wordsPerPage: CARDINAL = Environment.wordsPerPage;  -- Local Types:  AnyFrameSizeIndex: TYPE =  --    -- note that an AnyFrameSizeIndex immediately preceeds a Frame.    CARDINAL [0..PrincOps.AVHeapSize);  NormalFrameSizeIndex: TYPE = PrincOps.FrameSizeIndex;  FsiFrame: TYPE = PrincOps.LocalOverhead;    FrameSegment: TYPE = POINTER TO FrameSegmentHeader;    FrameSegmentHeader: TYPE = MACHINE DEPENDENT RECORD [    next(0): FrameSegment,    pages(1): CARDINAL,  -- PageCount[0..8?]    sizeIfLargeFrame(2):  --      CARDINAL, -- (for debugging only. not used in small frame segment)    prev(3): FrameSegment,    fsiFrame(4):  --      ARRAY [0..0) OF --WORD-- FsiFrame]; -- must be at 0 MOD 4 boundary.  -- Variables:  pNewFsiFrame: POINTER TO --ARRAY [0..0) OF WORD-- FsiFrame;  -- storage available for building new frames.    storageRemaining: CARDINAL ¬ 0;  -- words remaining in pNewFsiFrame­.  largeFrameListHead: FrameSegment ¬ NIL;  -- list of all dynamically-allocated large  -- (and temporary) frame segments (for debugging only).    smallFrameListHead: FrameSegment ¬ NIL;  -- list of all dynamically-allocated small  -- (and permanent) frame segments (for debugging only).    BugType: TYPE = {invalidFSI, wontFitInLocalFrame};  --================== Initialization: ==================    InitializeFrame: PUBLIC --StoragePrograms.-- PROC =    BEGIN    throwAway: PROCESS;    priorityPrev: Process.Priority = ProcessInternal.GetPriority[];    Process.DisableAborts[pFrameFaultCondition];  -- (timeout not significant)    ProcessInternal.SetPriority[ProcessPriorities.priorityFrameFault];    throwAway ¬  --      -- NOTE that FORK (in Processes) will call right back into      -- our procedure FrameSize. This works fine in the current      -- implementation, but could possibly be a surprise      -- in some future implementation.      FORK FrameFaultProcess[];  -- (no profit in detaching.)    ProcessInternal.SetPriority[priorityPrev];    END;  --InitializeFrame--      --================== Procedures: ==================  FrameSize: PUBLIC --RuntimeInternal. EXTERNAL-- PROC [fsi: CARDINAL]    RETURNS [CARDINAL] = {    IF fsi NOT IN PrincOps.FrameSizeIndex THEN      RuntimeInternal.Bug[BugType[invalidFSI]];    RETURN[frameSizeMap[fsi] - PrincOps.LocalOverhead.SIZE]};  MakeFsi: PUBLIC --RuntimeInternal. EXTERNAL-- PROC [words: CARDINAL]    RETURNS [fsi: PrincOps.FrameSizeIndex] =    BEGIN    totalWords: CARDINAL = words + PrincOps.LocalOverhead.SIZE;    FOR fsi IN PrincOps.FrameSizeIndex DO      IF frameSizeMap[fsi] >= totalWords THEN RETURN;      REPEAT FINISHED => RuntimeInternal.Bug[BugType[wontFitInLocalFrame]];      ENDLOOP;    END;  --===================================  -- Frame Allocation Fault Handler  --===================================       FrameFaultProcess: --ENTRY-- PROC [] --LOCKS frameHeapLock-- =    BEGIN    -- "arguments":    process: PSB.PsbHandle;    fsi: NormalFrameSizeIndex;  -- frame size index of frame desired.    -- "results":    pNewFrame: PrincOps.LocalFrameHandle;  -- the frame we will allocate and paste into the AV.    -- "temporary" variables:    frSize: CARDINAL;  -- word size of frame desired, including fsi word.  Guaranteed to be a multiple of 4.    frameSeg: FrameSegment;    UNTIL ProcessOperations.Enter[@frameHeapLock] DO NULL ENDLOOP;    DO  --FOREVER--      WHILE pda.fault[qFrameFault].queue = PSB.QueueEmpty DO        -- await next frame fault..        ProcessOperations.Wait[          @frameHeapLock, pFrameFaultCondition, PSB.NoTimeout];        UNTIL ProcessOperations.ReEnter[@frameHeapLock, pFrameFaultCondition] DO          NULL ENDLOOP;        ENDLOOP;      process ¬ ProcessOperations.IndexToHandle[        pda.block[pda.fault[qFrameFault].queue.tail].link.next];  -- walk to tail, then to head.      fsi ¬ pda[pda[process].context.state].fsi;      IF fsi NOT IN PrincOps.FrameSizeIndex THEN        RuntimeInternal.Bug[BugType[invalidFSI]];      frSize ¬ frameSizeMap[fsi];  -- must be a multiple of 4!      -- First free any unused large frames:      -- (Note that AV[LargeReturnSlot].tag, .frame, and .link are overlaid.)      WHILE AV[LargeReturnSlot].tag = frame DO        -- Atomically remove some large frame from freelist:        ProcessOperations.DisableInterrupts[]; -- so no one frees during list delete.        frameSeg ¬  -- grab addr of large frame and back over overhead stuff          LOOPHOLE[AV[LargeReturnSlot].frame - FrameSegmentHeader.SIZE -	    PrincOps.LocalOverhead.SIZE];        AV[LargeReturnSlot].link ¬ AV[LargeReturnSlot].link­.link;        ProcessOperations.EnableInterrupts[];        IF frameSeg.prev # NIL THEN frameSeg.prev.next ¬ frameSeg.next        ELSE largeFrameListHead ¬ frameSeg.next;        IF frameSeg.next # NIL THEN frameSeg.next.prev ¬ frameSeg.prev;	currentLargeFramePages ¬ currentLargeFramePages - frameSeg.pages;	currentLargeFrames ¬ currentLargeFrames.PRED;        ResidentMemory.FreeMDS[frameSeg, frameSeg.pages];        ENDLOOP;      IF fsi >= largeFrameThresholdFsi THEN        BEGIN --alloc large frame--        largeFramePages: CARDINAL;        frameSeg ¬ ResidentMemory.AllocateMDS[          count: largeFramePages ¬          (frSize + FrameSegmentHeader.SIZE + wordsPerPage -             1)/wordsPerPage];        frameSeg­ ¬ [          next: largeFrameListHead, prev: NIL, pages: largeFramePages, sizeIfLargeFrame: frSize,          fsiFrame: NULL];        frameSeg.fsiFrame[0].word.fsi ¬ LargeReturnSlot;  -- (a fsi never generated by the compiler.)        IF largeFrameListHead # NIL THEN largeFrameListHead.prev ¬ frameSeg;        largeFrameListHead ¬ frameSeg;        pNewFrame ¬ @frameSeg.fsiFrame[0].local;	largeFrameFaults ¬ largeFrameFaults.SUCC;	currentLargeFramePages ¬ currentLargeFramePages + largeFramePages;	currentLargeFrames ¬ currentLargeFrames.SUCC;	END -- alloc large frame      ELSE        BEGIN --alloc small frame--        IF storageRemaining < frSize THEN	  BEGIN --alloc more storage for frame--          -- First use any remaining storage for frames:          FOR extraFsi: NormalFrameSizeIndex DECREASING IN [0..fsi) DO            IF CARDINAL[frameSizeMap[extraFsi] + FrameSegmentHeader.SIZE]	      <= storageRemaining THEN	      BEGIN  -- build a frame from extra              pNewFsiFrame.word.fsi ¬ extraFsi;  -- (uninitialized warning is ok.)              Frame.Free[@pNewFsiFrame.local];  -- atomically paste onto frame heap.              storageRemaining ¬ storageRemaining - frameSizeMap[extraFsi];              pNewFsiFrame ¬ pNewFsiFrame + frameSizeMap[extraFsi];	      END;            ENDLOOP;          -- Allocate a new page from which to build frames:          frameSeg ¬ ResidentMemory.AllocateMDS[count: 1];          frameSeg­ ¬ [            next: smallFrameListHead, prev: NIL, pages: 1, sizeIfLargeFrame: NULL,            fsiFrame: NULL];          smallFrameListHead ¬ frameSeg;          pNewFsiFrame ¬ @frameSeg.fsiFrame[0];  -- must be at 0 MOD 4 boundary.          storageRemaining ¬ wordsPerPage - FrameSegmentHeader.SIZE;	  currentSmallFramePages ¬ currentSmallFramePages + 1;	  END;  --alloc more storage for frame--        -- IF storageRemaining < frSize THEN        --     RuntimeInternal.Bug[BugType[logicError]];        -- Fabricate a new frame:        pNewFsiFrame.word.fsi ¬ fsi;        pNewFrame ¬ @pNewFsiFrame.local;        pNewFsiFrame ¬ pNewFsiFrame + frSize;        storageRemaining ¬ storageRemaining - frSize;	END;  --alloc small frame--      -- Atomically chain the new frame onto the AV:      -- Note that we can not do a Frame.Free[] here because large frames      --    have an fsi different than that of the AV slot we put them in.      ProcessOperations.DisableInterrupts[];  -- so no one frees during the list insert.      LOOPHOLE[pNewFrame, POINTER TO PrincOps.AVItem]­.link ¬ AV[fsi].link;      AV[fsi]. --link-- frame ¬ pNewFrame;      ProcessOperations.EnableInterrupts[];      -- Restart faulted process:      ProcessOperations.Requeue[        @pda.fault[qFrameFault].queue, @pda.ready, process];      allFrameFaults ¬ allFrameFaults.SUCC;      ENDLOOP;    END;  --FrameFaultProcess--  END.LOG   (For earlier log entries, please see Mesa 10.0 archive version.)16-Sep-82  9:29:22   WDK        AR 12283: Keep track of large dynamically-allocated frames. Use ops from   ProcessInternal. AR 7431: Frame creator is not using storage optimally.28-Oct-82 10:36:34   WDK     	Added perf counters.21-Dec-82 15:26:26   AWL      	NewSpace => Space. 8-Feb-83 10:40:55   WDK         FrameSize did not account for frame overhead. MakeFsi failed to detect overflow. Frame segment list maintenance was wrong. 2-Mar-83 16:06:44   WDK     	DisableAborts on cond vars. 8-Aug-83 15:32:58   WDK     	Split out load state stuff into LoadStateImpl. 7-Oct-83 10:22:46   WDK     	Scream if bogus fsi.
-- LoadedMemImpl.mesa        20-Aug-87  9:06:38 by WDK  -- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- This is the run-time implementation of LoadedMem.-- There is another implementation, used by MakeBoot.-- TO BE DONE:-- Allocate*Words: "Storage for the different Content classes should be allocated--    in separate spaces" NOT DONE YET.DIRECTORY  BcdOps USING [BcdBase, MTHandle],  Environment USING [PageCount, PageFromLongPointer, PageNumber, wordsPerPage],  File USING [File, nullFile, PageNumber],  FrameExtras USING [GFTHandleToLongGF, GlobalOverhead, LongGFToGFTHandle,     ReadCodebase, WriteCodebase, WriteGlobalExtra, WriteGlobalWord],  Heap USING [CreateMDS, Create, NWords],  Inline USING [LongCOPY, LowHalf],  KernelSpaceUsage USING [swappableGlobalFrames],  LoadedMem USING [    Access, Content, Interval, SwapUnits, SwapUnitSize, TargetAddress,    TargetLongAddress],  PrincOps USING [GlobalCodebase],  PrincOpsExtras2 USING [ExtraGlobalWord, GFTHandle, GFTHandleToIndex, GFTIndex,     GlobalWord, ImportLink, LongGlobalFrameHandle],  Space USING [    Access, Allocate, Interval, MapAt, MDS, PagesFromWords, Pointer,    SwapUnitOption, SwapUnitSize, Unmap, virtualMemory],  SpaceUsage USING [PilotKernelUsage],  SpecialLoaderInternal USING [MapProc, UnmapProc],  VM USING [GetMapUnitAttributes, MakeReadOnly, MakeWritable,     nullBackingStoreRuns];LoadedMemImpl: PROGRAM  IMPORTS    Environment, FrameExtras, Heap, Inline, PrincOpsExtras2, Space,     SpecialLoaderInternal, VM  EXPORTS LoadedMem  =  BEGIN  -- Parameters:  -- This vm heap contains dynamically-loaded unpackaged global frames  -- and control module data.  -- These parameter values were chosen by looking at VP 2.0b with ELO and   -- Document features (no List Manager, no Spreadsheet, no PCE) in Aug 87.  vmHeapInitial: Environment.PageCount = 20;  vmHeapIncrement: Environment.PageCount = 10;  vmHeapSwapUnitSize: Space.SwapUnitSize =  -- Most of these gFrames    2;  -- are small (~100 words), but a few are  [1..4] pages.  vmHeapLargeNodeThreshold: Heap.NWords =  --    Heap.NWords.LAST;  -- we expect these frames will usually not be freed.  -- Constants and Types:  -- SHOULD BE IN KernelSpaceUsage!  loadedFramesAndControlModuleData: SpaceUsage.PilotKernelUsage =    SpaceUsage.PilotKernelUsage.FIRST + 40;  controlModuleData: SpaceUsage.PilotKernelUsage =    SpaceUsage.PilotKernelUsage.FIRST + 41;  BlockOfWords: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];  wordsPerPage: CARDINAL = Environment.wordsPerPage;  -- Global variables:    -- holds small frame packs and unpackaged frames for old bcds  -- and control module data for both new and old bcds.  smallMDSObjects: MDSZone ¬ NIL;  -- holds small frame packs and unpackaged frames for new bcds.  smallObjects: UNCOUNTED ZONE ¬ NIL;  Bug: PRIVATE ERROR [type: BugType] = CODE;  BugType: TYPE = {didntComeFromMyZone};  -- Note: No initialization proc. Just put in control module list.  -- Storage Allocation:  AllocatePages: PUBLIC PROCEDURE [size: CARDINAL, content: LoadedMem.Content]    RETURNS [targetAddress: LoadedMem.TargetLongAddress] =    BEGIN    mPages: CARDINAL = CARDINAL[Space.PagesFromWords[size]];    interval: Space.Interval =       Space.Allocate[count: mPages, within: Space.virtualMemory];    [] ¬ Space.MapAt[      at: interval, window: [File.nullFile, 0, mPages],      usage:      SELECT content FROM        controlModuleList => --KernelSpaceUsage.-- controlModuleData,        framePack => KernelSpaceUsage.swappableGlobalFrames,        unpackagedFrame => KernelSpaceUsage.swappableGlobalFrames,        ENDCASE => ERROR, class: data, life: dead, swapUnits: [unitary[]]];    targetAddress ¬ interval.pointer;    END;     AllocateMDSPages: PUBLIC PROCEDURE [size: CARDINAL, content: LoadedMem.Content]    RETURNS [targetAddress: LoadedMem.TargetAddress] =    BEGIN    mPages: CARDINAL = CARDINAL[Space.PagesFromWords[size]];    interval: Space.Interval = Space.Allocate[count: mPages, within: Space.MDS[]];    [] ¬ Space.MapAt[      at: interval, window: [File.nullFile, 0, mPages],      usage:      SELECT content FROM        controlModuleList => --KernelSpaceUsage.-- controlModuleData,        framePack => KernelSpaceUsage.swappableGlobalFrames,        unpackagedFrame => KernelSpaceUsage.swappableGlobalFrames,        ENDCASE => ERROR, class: data, life: dead, swapUnits: [unitary[]]];    RETURN Space.Pointer[interval.pointer];    END;  AllocateWords: PUBLIC PROCEDURE [size: CARDINAL, content: LoadedMem.Content]    RETURNS [targetAddress: LoadedMem.TargetLongAddress] =    BEGIN    IF smallObjects = NIL THEN      smallObjects ¬ Heap.Create[        initial: vmHeapInitial, increment: vmHeapIncrement,	swapUnitSize: vmHeapSwapUnitSize, largeNodeThreshold: vmHeapLargeNodeThreshold];    RETURN[smallObjects.NEW[BlockOfWords [size]]];    END;      AllocateMDSWords: PUBLIC PROCEDURE [size: CARDINAL, content: LoadedMem.Content]    RETURNS [targetAddress: LoadedMem.TargetAddress] =    BEGIN    IF smallMDSObjects = NIL THEN  --      -- These heap parms are chosen to conserve MDS space rather than for performance.       smallMDSObjects ¬ Heap.CreateMDS[        initial: 1, increment: 1, swapUnitSize: 1, largeNodeThreshold: wordsPerPage];    RETURN[smallMDSObjects.NEW[BlockOfWords [size]]];    END;  FreePages: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetLongAddress]    RETURNS [nil: LoadedMem.TargetLongAddress] = {    IF targetAddress # NIL THEN [] ¬ Space.Unmap[targetAddress];    RETURN[NIL]};      FreeMDSPages: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetAddress]    RETURNS [nil: LoadedMem.TargetAddress] = {    IF targetAddress # NIL THEN [] ¬ Space.Unmap[targetAddress.LONG];    RETURN[NIL]};  FreeWords: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetLongAddress]    RETURNS [nil: LoadedMem.TargetLongAddress] = {    IF smallObjects = NIL THEN {      IF targetAddress # NIL THEN Bug[didntComeFromMyZone] ELSE NULL}  -- freeing NIL is ok    ELSE smallObjects.FREE[@targetAddress];    RETURN[NIL]};  FreeMDSWords: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetAddress]    RETURNS [nil: LoadedMem.TargetAddress] = {    IF smallMDSObjects = NIL THEN {      IF targetAddress # NIL THEN Bug[didntComeFromMyZone] ELSE NULL}  -- freeing NIL is ok    ELSE smallMDSObjects.FREE[@targetAddress];    RETURN[NIL]};  -- Storage mapping:  MapCode: PUBLIC PROCEDURE [    bcd: BcdOps.BcdBase, pageOffset, pageCount: CARDINAL,    swapUnits: LoadedMem.SwapUnits, access: LoadedMem.Access]    RETURNS [targetAddress: LoadedMem.TargetLongAddress] =    BEGIN    swapUnitsSame: BOOLEAN      [TRUE..Space.SwapUnitSize.LAST = LoadedMem.SwapUnitSize.LAST] = TRUE;    su: Space.SwapUnitOption ¬       IF swapUnits = NIL OR swapUnits.LENGTH = 1         THEN [unitary[]] ELSE [irregular[swapUnits]];    mapUnitPtr: LONG POINTER ¬       SpecialLoaderInternal.MapProc[        pageOffset, pageCount, su,      	IF access = readOnly THEN readOnly ELSE readWrite];    RETURN [mapUnitPtr];    END;  MakeCodeReadOnly: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress] = {    VM.MakeReadOnly[VM.GetMapUnitAttributes[       Environment.PageFromLongPointer[targetAddress],        VM.nullBackingStoreRuns].mapUnit]};  UnmapCode: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetLongAddress]    RETURNS [unmapped: LoadedMem.Interval] = {    int: Space.Interval ¬ [NIL, 0];    IF targetAddress # NIL THEN int ¬ SpecialLoaderInternal.UnmapProc[targetAddress];    RETURN[[pointer: int.pointer, pages: CARDINAL[int.count]]]};  -- Storage reading and writing:    Long: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetAddress]    RETURNS [LoadedMem.TargetLongAddress] = {RETURN[targetAddress.LONG]};  Short: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetLongAddress]    RETURNS [LoadedMem.TargetAddress] = {RETURN[Inline.LowHalf[targetAddress]]};  ReadBlock: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress, localAddress: LONG POINTER,    size: CARDINAL] = {    Inline.LongCOPY[from: targetAddress, to: localAddress, nwords: size]};      ReadMDSBlock: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetAddress, localAddress: LONG POINTER,    size: CARDINAL] = {    Inline.LongCOPY[from: targetAddress.LONG, to: localAddress, nwords: size]};  ReadWord: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetLongAddress]    RETURNS [UNSPECIFIED] = {      RETURN[LOOPHOLE[targetAddress, LONG POINTER TO WORD]­]};        ReadMDSWord: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetAddress]    RETURNS [UNSPECIFIED] = {RETURN[LOOPHOLE[targetAddress, POINTER TO WORD]­]};  WriteBlock: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress, localAddress: LONG POINTER    --TO READONLY UNSPECIFIED-- , size: CARDINAL, access: LoadedMem.Access] =    BEGIN    targetAddressPage: Environment.PageCount ¬ Environment.PageFromLongPointer[targetAddress];    count: Environment.PageCount =      Environment.PageFromLongPointer[targetAddress + size + wordsPerPage - 1] -        targetAddressPage;    IF access = readOnly THEN      VM.MakeWritable[[page: targetAddressPage, count: count]];    Inline.LongCOPY[from: localAddress, to: targetAddress, nwords: size];    IF access = readOnly THEN      VM.MakeReadOnly[[page: targetAddressPage, count: count]];    END;      WriteMDSBlock: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetAddress, localAddress: LONG POINTER    --TO READONLY UNSPECIFIED-- , size: CARDINAL, access: LoadedMem.Access] =    BEGIN    targetAddressPage: Environment.PageCount ¬ Environment.PageFromLongPointer[targetAddress];    count: Environment.PageCount =      Environment.PageFromLongPointer[targetAddress + size + wordsPerPage - 1] -        targetAddressPage;    IF access = readOnly THEN      VM.MakeWritable[[page: targetAddressPage, count: count]];    Inline.LongCOPY[from: localAddress, to: targetAddress.LONG, nwords: size];    IF access = readOnly THEN      VM.MakeReadOnly[[page: targetAddressPage, count: count]];    END;      WriteWord: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress, word: UNSPECIFIED,    access: LoadedMem.Access] = {    targetAddressPage: Environment.PageCount ¬ Environment.PageFromLongPointer[targetAddress];    IF access = readOnly THEN      VM.MakeWritable[[page: targetAddressPage, count: 1]];    LOOPHOLE[targetAddress, LONG POINTER TO WORD]­ ¬ word;    IF access = readOnly THEN      VM.MakeReadOnly[[page: targetAddressPage, count: 1]]};        WriteMDSWord: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetAddress, word: UNSPECIFIED,    access: LoadedMem.Access] = {    targetAddressPage: Environment.PageCount ¬ Environment.PageFromLongPointer[targetAddress];    IF access = readOnly THEN      VM.MakeWritable[[page: targetAddressPage, count: 1]];    LOOPHOLE[targetAddress, POINTER TO WORD]­ ¬ word;    IF access = readOnly THEN      VM.MakeReadOnly[[page: targetAddressPage, count: 1]]};        WriteCodeLinks: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress,    mth: BcdOps.MTHandle,     localAddress: LONG DESCRIPTOR FOR ARRAY OF PrincOpsExtras2.ImportLink,    access: LoadedMem.Access] = {      WriteBlock[        targetAddress: targetAddress, localAddress: BASE[localAddress], 	size: LENGTH[localAddress] * PrincOpsExtras2.ImportLink.SIZE,        access: access]};	  ReadCodeLinks: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress,    mth: BcdOps.MTHandle,     localAddress: LONG DESCRIPTOR FOR ARRAY OF PrincOpsExtras2.ImportLink] = {      ReadBlock[        targetAddress: targetAddress, localAddress: BASE[localAddress], 	size: LENGTH[localAddress] * PrincOpsExtras2.ImportLink.SIZE]};  ReadGlobal: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.GFTIndex] = {      RETURN PrincOpsExtras2.GFTHandleToIndex[FrameExtras.LongGFToGFTHandle[gf]] };  ReadGlobalWord: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.GlobalWord] = {    RETURN [FrameExtras.GlobalOverhead[gf].word]};    ReadExtraGlobalWord: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.ExtraGlobalWord] = {      RETURN [FrameExtras.GlobalOverhead[gf].extra] };  ReadCodebase: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [gcb: PrincOps.GlobalCodebase] = {    RETURN[FrameExtras.ReadCodebase[FrameExtras.LongGFToGFTHandle[gf]]]};  WriteGlobalIndex: PUBLIC PROCEDURE [    gfi: PrincOpsExtras2.GFTIndex, gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    gw: PrincOpsExtras2.GlobalWord ¬ FrameExtras.GlobalOverhead[gf].word;    gw.gfi ¬ gfi;    FrameExtras.WriteGlobalWord[gw: gw, lgf: gf]};  WriteGlobalWord: PUBLIC PROCEDURE [    gw: PrincOpsExtras2.GlobalWord, gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    FrameExtras.WriteGlobalWord[gw: gw, lgf: gf]};  WriteExtraGlobalWord: PUBLIC PROCEDURE [    xgw: PrincOpsExtras2.ExtraGlobalWord,     gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    FrameExtras.WriteGlobalExtra[gw: xgw, lgf: gf] };  WriteCodebase: PUBLIC PROCEDURE [    gcb: PrincOps.GlobalCodebase, gf: PrincOpsExtras2.GFTHandle] = {    FrameExtras.WriteCodebase[cb: gcb, gfi: gf]};    GlobalFrameFromGFTHandle: PUBLIC PROC[gfth: PrincOpsExtras2.GFTHandle]     RETURNS[gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    RETURN[FrameExtras.GFTHandleToLongGF[gfth]] };  GFTHandleFromGlobalFrame: PUBLIC PROC[gf: PrincOpsExtras2.LongGlobalFrameHandle]     RETURNS[gfth: PrincOpsExtras2.GFTHandle] = {    RETURN[FrameExtras.LongGFToGFTHandle[gf]] };  END.LOG5-Sep-83 17:45:49   WDK        Created file. In old PilotLoaderSupport, unitary spaces   were incorrectly mapped with uniform swap units.16-Sep-83 12:06:55	RES    Added Interval return value to UnmapCode12-Dec-83 17:22:24   WDK        FreeMDSWords must check for NIL zone.30-Jul-84 15:47:34	EKN  	   Changed MapCode, UnmapCode to look at CallBackProcs for mapping/unmapping. Changed MakeCodeReadOnly to call into VM instead of Space.18-Feb-86 11:27:11	ET   Convert over to new PrincOps: Change all MDS procedures to virtual memory procedures. Delete Long, WriteMDSBlock, ReadMDSBlock. Change ReadGlobalExtra, WriteGlobalExtra to ReadGlobalIndex, WriteGlobalIndex respectively.18-Jun-86 16:50:44	ET   Converted again to new but cheaper Princops (means support both storage in and out of mds).12-Aug-86 11:51:51	ET  Added WriteCodeLinks for makeboot's LoadedMemImpl.20-Aug-86 19:34:47	ET  Added ReadCodeLinks for makeboot's LoadedMemImpl.20-Aug-87  9:07:12	WDK   Tuned Heap parameters per data from VP 2.0b.
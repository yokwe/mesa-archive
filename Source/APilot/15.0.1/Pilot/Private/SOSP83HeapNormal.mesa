-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- SOSP83HeapNormal.mesa     3-Aug-87 10:00:08 by RSV    DIRECTORY  Environment USING [PageCount, wordsPerPage],  File USING [Delete, File, Unknown],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Error, ErrorType, minimumNodeSize, NWords],  HeapExtras USING [],  Runtime USING [GetCaller],  SOSP83HeapInternal USING [    Data, HyperHandle, LargeNode, maxSegmentPages, NodeHeader, NodeLength,    NodePointer, NormalHandle, OwnerHandle, OwnerObject, Procs, SegmentHandle,    SegmentObject, UncountedZoneObject, UncountedZoneRep],  SOSP83HeapOps USING [    Bug, EnumerateLargeNodes, MakeLargeNode, MakeSpace, PagesForLargeNode],  Space USING [    Error, GetMapUnitAttributes, InsufficientSpace, Interval, MDS, PageCount,    PagesFromWords, SwapUnitSize, Unmap, virtualMemory],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  System USING [VolumeID],  Volume USING [systemID];SOSP83HeapNormal: MONITOR LOCKS    LOOPHOLE[z, SOSP83HeapInternal.UncountedZoneRep].data.lock USING z: UNCOUNTED ZONE  IMPORTS     File, FrameExtras, Heap, SOSP83HeapOps, Runtime, Space,    SpecialRuntimeExtras, Volume  EXPORTS Heap, HeapExtras, SOSP83HeapOps =  BEGIN OPEN SOSP83HeapInternal;  systemZone: PUBLIC --Heap, SOSP83HeapOps-- UNCOUNTED ZONE;    -- initialized in InitializeHeap  NWords: TYPE = CARDINAL;  hyperProcs: Procs ¬ [Make: MakeNormalNode, Free: FreeNormalNode];    hyperOverhead: CARDINAL = Data.normal.hyper.SIZE + SegmentObject.SIZE;  nodeOverhead: CARDINAL = NodeLength.SIZE;  Create: PUBLIC --Heap-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NodeLength,    ownerChecking, checking: BOOLEAN]    RETURNS [UNCOUNTED ZONE] =    BEGIN    RETURN[NewCreate[initial: initial, maxSize: maxSize, increment: increment,      swapUnitSize: swapUnitSize, threshold: threshold,      largeNodeThreshold: largeNodeThreshold, ownerChecking: ownerChecking,      checking: checking, volumeID: Volume.systemID]];    END;  NewCreate: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NodeLength,    ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID]    RETURNS [UNCOUNTED ZONE] =    BEGIN    MyMake: PROCEDURE [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] = {      RETURN[base]};    myProcs: Procs ¬ [Make: MyMake, Free: NULL];    uzo: SOSP83HeapInternal.UncountedZoneObject ¬ [@myProcs, NIL];    myZone: UNCOUNTED ZONE ¬ LOOPHOLE[LONG[@uzo]];    h: HyperHandle;    base: LONG ORDERED POINTER;    extra: Space.PageCount;    segment: SegmentHandle;    IF initial = 0 THEN initial ¬ 1;  -- since not yet ready to extend    IF maxSize < initial THEN ERROR Heap.Error[maxSizeExceeded];    IF initial > maxSegmentPages THEN {      extra ¬ initial - maxSegmentPages; initial ¬ maxSegmentPages}    ELSE extra ¬ 0;    increment ¬ MIN[increment, maxSegmentPages];    threshold ¬ MAX[threshold, Heap.minimumNodeSize];    base ¬ SOSP83HeapOps.MakeSpace[      parent: Space.virtualMemory, pages: initial, swapUnitSize: swapUnitSize,      resident: FALSE, volumeID: volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    segment ¬ base + Data.normal.hyper.SIZE;    segment^ ¬ [      next: NIL,      length: CARDINAL[initial*Environment.wordsPerPage - hyperOverhead],      base: LOOPHOLE[segment + SegmentObject.SIZE],      initial: TRUE];    IF base + hyperOverhead # segment.base THEN ERROR;    segment.base^ ¬ [segment.length, NIL, NIL];    h ¬ myZone.NEW[hyper normal Data ¬ [      ownerChecking: ownerChecking, checking: checking, maxSize: maxSize,      currentSize: initial, increment: increment, swapUnit: swapUnitSize,      volumeID: volumeID,      v1: normal[root: segment.base, segments: segment, threshold: threshold,        largeNodeThreshold: largeNodeThreshold,	v2: hyper[uzo: [procs: @hyperProcs, data: NULL]]]]];    h.uzo.data ¬ h;    WHILE extra # 0 DO      pages: Space.PageCount ¬ MIN[maxSegmentPages, extra];      [] ¬ ExpandNormalHeapInternal[h, pages, TRUE];      extra ¬ extra - pages;      ENDLOOP;    RETURN[LOOPHOLE[@h.uzo]]    EXITS InsufficientSpace => ERROR Heap.Error[insufficientSpace]    END;  ExpandNormalHeapInternal: PROCEDURE [    h: NormalHandle, pages: Space.PageCount, initial: BOOLEAN] =    -- Add a segment of the specified size (or h.increment if that is larger)    -- to h.    BEGIN    extension: SegmentHandle;    oldSize: Space.PageCount = h.currentSize;    IF ~initial THEN pages ¬ MAX[pages, h.increment];    IF pages = 0 THEN GOTO InsufficientSpace;    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Heap.Error[maxSizeExceeded];      END;    extension ¬ SOSP83HeapOps.MakeSpace[      parent: IF h.where = mds THEN Space.MDS[] ELSE Space.virtualMemory,      pages: pages, swapUnitSize: Space.SwapUnitSize[h.swapUnit],      resident: h.resident, volumeID: h.volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    extension^ ¬ [      next: h.segments,      length: CARDINAL[pages*Environment.wordsPerPage - SegmentObject.SIZE],      base: LOOPHOLE[extension + SegmentObject.SIZE],      initial: initial];    h.segments ¬ extension;    extension.base^ ¬ [extension.length, NIL, NIL];    Insert[extension.base, @h.root];     EXITS      InsufficientSpace => Heap.Error[insufficientSpace];    END;    MakeNormalNode: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    z: UNCOUNTED ZONE, n: NodeLength] RETURNS [p: LONG POINTER] =    BEGIN    h: NormalHandle ¬       LOOPHOLE[LOOPHOLE[z, SOSP83HeapInternal.UncountedZoneRep].data];    savedError: Heap.ErrorType;      BEGIN ENABLE {        Heap.Error => {savedError ¬ type; GOTO Error}; UNWIND => NULL};      IF n < h.threshold THEN n ¬ h.threshold;      IF h.ownerChecking THEN n ¬ n + OwnerObject.SIZE;      -- check data size to see if large node      IF n >= h.largeNodeThreshold THEN {        h.largeNodes ¬ SOSP83HeapOps.MakeLargeNode[h, n];        p ¬ @h.largeNodes.node + nodeOverhead}      ELSE {        n ¬ n + nodeOverhead;        IF h.root = NIL OR h.root.length < n THEN	  ExpandNormalHeapInternal[h, Space.PagesFromWords[n + SegmentObject.SIZE], FALSE];	p ¬ BetterFit[@h.root, n] + nodeOverhead};      IF h.checking THEN CheckTree[@h.root];      IF h.ownerChecking THEN	BEGIN OPEN o: LOOPHOLE[p, OwnerHandle];	o.frame ¬ FrameExtras.LongGFToGFTHandle[          SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]];	p ¬ p + OwnerObject.SIZE;	END;      EXITS        Error => RETURN WITH ERROR Heap.Error[savedError];      END;    END;  FreeNormalNode: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    z: UNCOUNTED ZONE, p: NodePointer] =    BEGIN    h: NormalHandle ¬       LOOPHOLE[LOOPHOLE[z, SOSP83HeapInternal.UncountedZoneRep].data];    savedError: Heap.ErrorType;    IF p # NIL THEN      BEGIN ENABLE {        Heap.Error => {savedError ¬ type; GOTO Error}; UNWIND => NULL};      p ¬ p - nodeOverhead;      IF h.ownerChecking THEN p ¬ p - OwnerObject.SIZE;      -- now p really is a NodePointer      IF p.length - nodeOverhead < h.threshold THEN        RETURN WITH ERROR Heap.Error[invalidNode];      -- check data size to see if large node      IF p.length - nodeOverhead >= h.largeNodeThreshold THEN {	prev: LargeNode ¬ NIL;	largeNode: LargeNode ¬ h.largeNodes;	UNTIL largeNode = NIL DO	  IF @largeNode.node = p THEN {	    IF prev = NIL THEN h.largeNodes ¬ largeNode.next	    ELSE prev.next ¬ largeNode.next;	    h.currentSize ¬ 	      h.currentSize - SOSP83HeapOps.PagesForLargeNode[largeNode];	    IF h.volumeID # Volume.systemID THEN  -- delete the files created	      BEGIN	      tempFileID: File.File = Space.GetMapUnitAttributes[p].window.file;	      [] ¬ Space.Unmap[p !	        Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	      File.Delete[tempFileID ! 	        File.Unknown => SOSP83HeapOps.Bug[fileWeCreatedWentAway]];	      END	    ELSE 	      [] ¬ Space.Unmap[p !	        Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	    RETURN};	  prev ¬ largeNode;	  largeNode ¬ largeNode.next;	  REPEAT FINISHED =>	    -- a node might look large but really be a normal node with slop	    -- not big enough for another node but big enough to cross the	    -- largeNodeThreshold.	    IF (p.length - nodeOverhead) - h.largeNodeThreshold >= NodeHeader.SIZE THEN	      RETURN WITH ERROR Heap.Error[invalidNode];	  ENDLOOP};      IF h.checking THEN {	FOR seg: SegmentHandle ¬ h.segments, seg.next UNTIL seg = NIL DO	  IF p IN [seg.base..seg.base+seg.length) AND p + p.length <= seg.base+seg.length THEN EXIT;	  REPEAT FINISHED => RETURN WITH ERROR Heap.Error[invalidNode];	  ENDLOOP};      Release[@h.root, p];      IF h.checking THEN CheckTree[@h.root];      EXITS        Error => RETURN WITH ERROR Heap.Error[savedError];      END;    END;  ExpandNormalHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    z: UNCOUNTED ZONE, h: NormalHandle, pages: Space.PageCount] =    BEGIN    savedType: Heap.ErrorType;    WHILE pages # 0 DO ENABLE        BEGIN	Heap.Error => {savedType ¬ type; GOTO Error};	UNWIND => NULL;	END;      n: CARDINAL ¬ CARDINAL[MIN[pages, maxSegmentPages]];      [] ¬ ExpandNormalHeapInternal[h, n, FALSE];      pages ¬ pages - n;      REPEAT        Error => RETURN WITH ERROR Heap.Error[savedType];      ENDLOOP;    END;  FlushNormalHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    z: UNCOUNTED ZONE, h: NormalHandle] =    BEGIN    savedType: Heap.ErrorType;      BEGIN ENABLE        BEGIN	Heap.Error => {savedType ¬ type; GOTO Error};	UNWIND => NULL;	END;      segment, next, prev: SegmentHandle;      createdFiles: BOOLEAN = (h.volumeID # Volume.systemID);      SOSP83HeapOps.EnumerateLargeNodes[        h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];      prev ¬ NIL;      h.largeNodes ¬ NIL;      h.currentSize ¬ 0;      h.root ¬ NIL;      FOR segment ¬ h.segments, next UNTIL segment = NIL DO        next ¬ segment.next;        IF segment.initial THEN          BEGIN          node: NodePointer = segment.base;	  node^ ¬ [segment.length, NIL, NIL];	  Insert[node, @h.root];	  h.currentSize ¬ h.currentSize + Space.PagesFromWords[segment.length];	  prev ¬ segment;	  END        ELSE          BEGIN          IF prev = NIL THEN h.segments ¬ next ELSE prev.next ¬ next;	  IF h.volumeID # Volume.systemID THEN  -- delete the files created	    BEGIN	    tempFileID: File.File = 	      Space.GetMapUnitAttributes[segment].window.file;	    [] ¬ Space.Unmap[segment !	      Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	    File.Delete[tempFileID !	      File.Unknown => SOSP83HeapOps.Bug[fileWeCreatedWentAway]];	    END	  ELSE	    [] ¬ Space.Unmap[segment !	      Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	  END;        ENDLOOP;      EXITS        Error => RETURN WITH ERROR Heap.Error[savedType];      END;    END;  IsNormalEmpty: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    z: UNCOUNTED ZONE, h: NormalHandle] RETURNS [BOOLEAN] =    BEGIN    IF h.largeNodes # NIL THEN RETURN[FALSE];    FOR segment: SegmentHandle ¬ h.segments, segment.next UNTIL segment = NIL DO      IF segment.base.length = segment.length THEN        BEGIN	-- segment contains a single node;  we need to see if it is free	a: NodePointer = segment.base;	x: NodePointer;        p: RootPointer ¬ @h.root;        UNTIL (x ¬ p^) = a OR x = NIL OR x.length < a.length DO	  IF a < x THEN p ¬ @x.left ELSE p ¬ @x.right;	  ENDLOOP;	IF x # a THEN    -- if it is not found from root, then it is not free	  RETURN[FALSE];	END      ELSE RETURN[FALSE];      ENDLOOP;    RETURN[TRUE];  -- made it though all the segments without returning FALSE    END;  PruneNormalHeap: PUBLIC --SOSP83HeapOps-- ENTRY PROCEDURE [    z: UNCOUNTED ZONE, h: NormalHandle] =    BEGIN    savedType: Heap.ErrorType;      BEGIN ENABLE        BEGIN	Heap.Error => {savedType ¬ type; GOTO Error};	UNWIND => NULL;	END;      next, prev: SegmentHandle ¬ NIL;      FOR segment: SegmentHandle ¬ h.segments, next UNTIL segment = NIL DO        next ¬ segment.next;        IF ~segment.initial AND segment.base.length = segment.length THEN          BEGIN	  -- segment contains a single node; we need to see if it is free.	  a: NodePointer = segment.base;	  x: NodePointer;          p: RootPointer ¬ @h.root;	  UNTIL (x ¬ p^) = a OR x = NIL OR x.length < a.length DO	    IF a < x THEN p ¬ @x.left ELSE p ¬ @x.right;	    ENDLOOP;	  IF x = a THEN { -- found it.	    Delete[p];	    IF prev = NIL THEN h.segments ¬ next ELSE prev.next ¬ next;	    h.currentSize ¬ h.currentSize - Space.PagesFromWords[segment.length];	    IF h.volumeID # Volume.systemID THEN  -- delete the files created	      BEGIN	      tempFileID: File.File = 	        Space.GetMapUnitAttributes[segment].window.file;	      [] ¬ Space.Unmap[segment !	        Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	      File.Delete[tempFileID !	        File.Unknown => SOSP83HeapOps.Bug[fileWeCreatedWentAway]];	      END	    ELSE	      [] ¬ Space.Unmap[segment !	        Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];	    LOOP}; 	  END;	prev ¬ segment;        ENDLOOP;      EXITS        Error => RETURN WITH ERROR Heap.Error[savedType];      END;    END;  DeleteAndUnmap: PROCEDURE [sI: Space.Interval] =     BEGIN    tempFileID: File.File = Space.GetMapUnitAttributes[sI.pointer].window.file;    [] ¬ Space.Unmap[sI.pointer !      Space.Error => SOSP83HeapOps.Bug[mappedAreaWentAway]];    File.Delete[tempFileID !       File.Unknown => SOSP83HeapOps.Bug[fileWeCreatedWentAway]];    END;  --DeleteAndUnmap--  Unmap: PROCEDURE [sI: Space.Interval] = {[] ¬ Space.Unmap[sI.pointer]};  -- Cartesian tree stuff    RootPointer: TYPE = LONG POINTER TO NodePointer;    Insert: PROCEDURE [a: NodePointer, p: RootPointer] =    BEGIN    b: NodeLength = a.length;    leftHook, rightHook: RootPointer;    x: NodePointer ¬ p^;    WHILE x # NIL AND x.length >= b DO -- decend tree to proper level      IF a < x THEN p ¬ @x.left ELSE p ¬ @x.right;      x ¬ p^;      ENDLOOP;    p^ ¬ a; -- attach new node    leftHook ¬ @a.left;    rightHook ¬ @a.right;    WHILE x # NIL DO -- perform root insertion      IF x < a THEN {leftHook^ ¬ x; leftHook ¬ @x.right; x ¬ leftHook^}      ELSE {rightHook^ ¬ x; rightHook ¬ @x.left; x ¬ rightHook^};      ENDLOOP;    leftHook^ ¬ rightHook^ ¬ NIL;    END;    Delete: PROCEDURE [p: RootPointer] =    BEGIN    x: NodePointer ¬ p^;    leftBranch: NodePointer ¬ x.left;    rightBranch: NodePointer ¬ x.right;    WHILE leftBranch # rightBranch DO -- until both are NIL      PromoteLeft: PROC = INLINE {        p^ ¬ leftBranch; p ¬ @leftBranch.right; leftBranch ¬ p^};      PromoteRight: PROC = INLINE {        p^ ¬ rightBranch; p ¬ @rightBranch.left; rightBranch ¬ p^};      SELECT TRUE FROM        rightBranch = NIL => PromoteLeft[];	leftBranch = NIL => PromoteRight[];	leftBranch.length >= rightBranch.length => PromoteLeft[];	ENDCASE => PromoteRight[];      ENDLOOP;    p^ ¬ NIL;    END;    Promote: PROCEDURE [a: NodePointer, p: RootPointer] =    BEGIN    b: NodeLength = a.length;    leftBranch, rightBranch: NodePointer;    leftHook, rightHook: RootPointer;    x: NodePointer ¬ p^;    IF x = a THEN RETURN; -- no promotion necessary    WHILE x # NIL AND x.length >= b DO -- descend tree to proper level      IF a < x THEN p ¬ @x.left ELSE p ¬ @x.right;      x ¬ p^;      IF x = a THEN RETURN; -- no promotion necessary      ENDLOOP;    p^ ¬ a; -- attach node at new home    leftBranch ¬ a.left; -- remember old sons    rightBranch ¬ a.right;    leftHook ¬ @a.left;    rightHook ¬ @a.right;    WHILE x # a DO -- rearrange descendent nodes      IF x < a THEN {leftHook^ ¬ x; leftHook ¬ @x.right; x ¬ leftHook^}      ELSE {rightHook^ ¬ x; rightHook ¬ @x.left; x ¬ rightHook^};      ENDLOOP;    leftHook^ ¬ leftBranch; -- insert old sons of a    rightHook^ ¬ rightBranch;    END;    Demote: PROCEDURE [p: RootPointer] =    BEGIN    x: NodePointer ¬ p^;    xLength: NodeLength = x.length;    leftBranch: NodePointer ¬ x.left;    rightBranch: NodePointer ¬ x.right;    WHILE (leftBranch # NIL AND leftBranch.length > xLength) OR      (rightBranch # NIL AND rightBranch.length > xLength) DO      GoLeft: PROC = INLINE {        p^ ¬ leftBranch; p ¬ @leftBranch.right; leftBranch ¬ p^};      GoRight: PROC = INLINE {        p^ ¬ rightBranch; p ¬ @rightBranch.left; rightBranch ¬ p^};      SELECT TRUE FROM        rightBranch = NIL => GoLeft[];	leftBranch = NIL => GoRight[];	leftBranch.length >= rightBranch.length => GoLeft[];	ENDCASE => GoRight[];      ENDLOOP;    p^ ¬ x;    x.left ¬ leftBranch;    x.right ¬ rightBranch;    END;      Allocate: PROCEDURE [p: RootPointer, b: NodeLength] RETURNS [NodePointer] =    BEGIN    a: NodePointer = p^;    remaining: CARDINAL = a.length - b;    IF remaining < NodeHeader.SIZE THEN Delete[p]    ELSE {      x: NodePointer = a + b;      a.length ¬ b;      x^ ¬ [length: remaining, left: a.left, right: a.right];      p^ ¬ x;      Demote[p]};    RETURN[a]    END;    Release: PROCEDURE [root: RootPointer, a: NodePointer] =    BEGIN    insertLoc: RootPointer ¬ NIL;    parentLength, xparentLength: NodeLength ¬ NodeLength.LAST;    mergeCount: CARDINAL ¬ 0;    p: RootPointer ¬ root;    x: NodePointer;    WHILE(x ¬ p^) # NIL DO      IF insertLoc = NIL AND x.length < a.length THEN {        insertLoc ¬ p; parentLength ¬ xparentLength};      SELECT TRUE FROM        x + x.length = a => {	  x.length ¬ a.length + x.length; a ¬ x; Delete[p];	  IF (mergeCount ¬ mergeCount + 1) = 2 THEN EXIT};	a + a.length = x => {	  a.length ¬ a.length + x.length; Delete[p];	  IF (mergeCount ¬ mergeCount + 1) = 2 THEN EXIT};	ENDCASE => {	  xparentLength ¬ x.length;	  IF a < x THEN p ¬ @x.left	  ELSE IF a = x THEN ERROR Heap.Error[invalidNode]	  ELSE p ¬ @x.right};      ENDLOOP;    IF insertLoc # NIL THEN {      IF a.length <= parentLength THEN Insert[a, insertLoc]      ELSE Insert[a, root]}    ELSE {      IF a.length > xparentLength THEN Insert[a, root]      ELSE Insert[a, p]};    END;  <<  LeftMostFit: PROCEDURE [p: RootPointer, b: NodeLength] RETURNS [NodePointer] =      BEGIN      a: NodePointer ¬ p^;      leftSon: NodePointer ¬ a.left;      WHILE leftSon # NIL AND leftSon.length >= b DO	p ¬ @a.left;	a ¬ p^;	leftSon ¬ a.left;	ENDLOOP;      RETURN[Allocate[p, b]]      END;>>    BetterFit: PROCEDURE [p: RootPointer, b: NodeLength] RETURNS [NodePointer] =    BEGIN    a: NodePointer ¬ p^;    leftSon: NodePointer ¬ a.left;    rightSon: NodePointer ¬ a.right;    WHILE (leftSon # NIL AND leftSon.length >= b) OR      (rightSon # NIL AND rightSon.length >= b) DO      SELECT TRUE FROM        leftSon = NIL => p ¬ @a.right;	rightSon = NIL => p ¬ @a.left;	leftSon.length <= rightSon.length => {          IF leftSon.length >= b THEN p ¬ @a.left ELSE p ¬ @a.right}	ENDCASE => {          IF rightSon.length >= b THEN p ¬ @a.right ELSE p ¬ @a.left};      a ¬ p^;      leftSon ¬ a.left;      rightSon ¬ a.right;      ENDLOOP;    RETURN[Allocate[p, b]]    END;    CheckTree: PROCEDURE [p: RootPointer] =    BEGIN    a: NodePointer ¬ p^;    IF p = NIL OR a = NIL THEN RETURN;    IF a.left # NIL THEN {      IF (a.left.length <= 0) OR (a.left + a.left.length > a) OR        (a.left.length > a.length) THEN        ERROR Heap.Error[otherError]      ELSE CheckTree[@a.left]};    IF a.right # NIL THEN {      IF (a.length <= 0) OR (a.right < a + a.length) OR        (a.right.length > a.length) THEN        ERROR Heap.Error[otherError]      ELSE CheckTree[@a.right]};    END;    END...LOG31-Jan-84  8:59:59 XXJ Created file30-Jun-86  8:58:30 RSV Added log, changed _ to ¬, changed names to SOSP83*, added IsNormalEmpty , and changed ExpandNormalHeapInternal to not increment currentSize when maxSizeExceeded is raised.18-Mar-87 14:43:23 RSV Can't use PrincOps.GlobalFrameHandle.  Must use PrincOps2.GFTHandle.30-Jun-87 10:59:32 RSV Allow specifying volume from which backing store is allocated. 3-Aug-87 10:00:08 RSV AR 11539 (Didn't detect node being freed twice).  Fix done to CheckTree to catch the problem
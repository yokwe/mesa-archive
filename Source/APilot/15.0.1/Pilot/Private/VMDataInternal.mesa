-- Copyright (C) 1984, 1988  by Xerox Corporation. All rights reserved. -- ResMemMgr>VMDataInternal.mesa    12-Oct-88 16:10:21 by RSV    -- Private, internal interface for the VMData implementation.-- The reader should be familiar with the VM implementation description document.DIRECTORY  BackingStore USING [Data, TransferProc],  Environment USING [Base],  MopcodesExtras2 USING [zVMFIND],  Space USING [Class, SwapUnitSize, SwapUnitType, Usage],  VM USING [Interval, PageCount, PageNumber],  VMData USING [State];VMDataInternal: DEFINITIONS =  BEGIN  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Run Data  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Runs  (fixed length data):  Run: TYPE = RECORD [    interval: VM.Interval,    -- Attributes of the map unit containing this Run:    usage: Space.Usage,  -- 11 bits.    class: Space.Class,  -- 5 bits.    transferProcID: TransferProcID,    -- Data for this Run:    startOfMapUnit: BOOLEAN,    maybePartlyIn: BOOLEAN,    endOfMapUnit: BOOLEAN,    backingData: BackingStore.Data,    -- swap unit structure of this Run:    swapUnitData: SELECT swapUnits: Space.SwapUnitType FROM      unitary => [swapUnitState: SwapUnitState],  --data is stored in run entry      uniform => [uniformSwapUnitData: PUniformSwapUnitData],      irregular => [irregularSwapUnitData: PIrregularSwapUnitData],      ENDCASE];  -- Run Table:  countRunPad: CARDINAL = 1;  -- For the convenience of the Find routine, a dummy entry is prepended to, and a "top" entry is appended to the table. The "top" entry has run.interval.page = end of implemented vm.  -- The table layout is as follows:  -- |       |pRunFirst |     |          |  pRunTop  | (offsetFree)  -- | dummy | user run | ... | user run | top entry | <free>  minCountRun: CARDINAL = 3000;  -- VM is allocated for at least this many run table entries.  IndexRun: TYPE = [0..0);  --index of table (grows dynamically)  RunBase: TYPE = LONG BASE POINTER TO ARRAY IndexRun OF Run;  RunTable: TYPE = LONG POINTER TO ARRAY [0..1000 --say-- ] OF Run;  --for debugger  PRun: TYPE = RunBase RELATIVE ORDERED POINTER [0..LAST[CARDINAL]] TO Run;  nilPRun: PRun = LAST[PRun];  runBase: RunBase;  -- base pointer for table  pageRunTable: VM.PageNumber;  -- start page of table   countRunTablePagesMapped: CARDINAL;  -- count currently mapped.  pRunFirst: PRun = FIRST[PRun] + countRunPad*SIZE[Run];  -- first real entry of table  pRunTop: PRun;  -- "top" entry of table (see picture above).  offsetFree: CARDINAL = SIZE[Run];  -- offset of the end of the used part of the table from  -- the "top" entry. Note that this location may not be mapped.  pRunMaxInRealMem: PRun;  -- location immediately following mapped portion of table (points to  -- just beyond limits of real memory currently allocated for table).  pRunMaxInVM: PRun;  --location immediately following table (points to just beyond limits of VM for table)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- SwapUnit Data  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Variable-length data is associated with Runs which contain uniform or irregular swap units. Each of these Runs contains a pointer to swap unit data. These data have the following organization:  UniformSwapUnitData: TYPE = RECORD [    firstSwapUnitSize: Space.SwapUnitSize,    swapUnitSize: Space.SwapUnitSize,    state: PACKED SEQUENCE nSwapUnits: NSwapUnits OF SwapUnitState];  IrregularSwapUnitData: TYPE = RECORD [    sizeAndState: PACKED SEQUENCE nSwapUnits: NSwapUnits OF SwapUnitSizeAndState];  --Note: needs to be a record to keep the compiler happy  NSwapUnits: TYPE = CARDINAL;  SwapUnitSizeAndState: TYPE = RECORD [  -- 8 bits.    size: IrregularSwapUnitSize, state: SwapUnitState];  IrregularSwapUnitSize: TYPE = Space .SwapUnitSize[1..20B];  -- 4 bits. Note nonzero origin.  maxIrregularSwapUnitSize: IrregularSwapUnitSize = LAST[IrregularSwapUnitSize];  SwapUnitState: TYPE = RECORD [  -- 4 bits.    availability: SwapUnitAvailability,    st: VMData.State];  SwapUnitAvailability: TYPE = {available, busy};    IsReservedMemory: PROCEDURE [state: VMData.State]    RETURNS [BOOLEAN] = INLINE {RETURN [    state.swappability = swappable AND state.access = readOnly]};  -- Swap unit table  SwapUnitBase: TYPE = LONG BASE POINTER TO --UNSPECIFIED-- WORD;  PSwapUnitDomain: TYPE = [0..037777B];  PSwapUnit: TYPE = SwapUnitBase RELATIVE ORDERED POINTER --PSwapUnitDomain--    [0..037777B] TO    --UNSPECIFIED-- WORD;  nilPSwapUnit: PSwapUnit = LAST[PSwapUnit];  PUniformSwapUnitData: TYPE = SwapUnitBase RELATIVE ORDERED POINTER    --PSwapUnitDomain-- [0..037777B] TO UniformSwapUnitData;  PIrregularSwapUnitData: TYPE = SwapUnitBase RELATIVE ORDERED POINTER    --PSwapUnitDomain-- [0..037777B] TO IrregularSwapUnitData;  swapUnitBase: SwapUnitBase;  -- base pointer for swap unit table    pageSwapUnitTable: VM.PageNumber;  -- start page of swap unit table   countSwapUnitTablePages: CARDINAL = 80;  --number of pages of VM to allocate for swap unit table data  countSwapUnitTablePagesMapped: VM.PageCount;  --number of pages of swap unit table currently mapped  pSwapUnitNextFree: PSwapUnit;  --next free location in table (may or may not be mapped)  pSwapUnitMaxInRealMem: PSwapUnit;  --location immediately following mapped portion of table (points to just beyond limits of real memory currently allocated for swap unit table)  pSwapUnitMaxInVM: PSwapUnit;  --location immediately following last possible location of table (points to just beyond limits of VM for swap unit table)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- TransferProc data descriptors  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  TransferProcDesc: TYPE = RECORD [    transferProcID: TransferProcID,    referenceCount: TransferProcReferenceCount,  -- one tally per map unit    transferProc: BackingStore.TransferProc,    nextTransferProcDesc: PTransferProcDesc];  TransferProcID: TYPE = [0..256);  TransferProcReferenceCount: TYPE = CARDINAL;  PTransferProcDesc: TYPE = Environment.Base RELATIVE POINTER TO TransferProcDesc;  nilPTransferProcDesc: PTransferProcDesc = LOOPHOLE[0];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Free storage for TransferProcDescs  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  useMeTransferProcDesc: PTransferProcDesc;  -- A free TransferProcDesc, nilPTransferProcDesc if none.  When a TransferProcDesc is required within the VMData monitor, it will be obtained from here. Only procedures outside the VMData monitor can fill this with a free desc.  freeMeTransferProcDesc: PTransferProcDesc;  --A TransferProcDesc to be freed from ouside the VMData monitor, nilPTransferProcDesc if none. Only procedures outside the VMData monitor can empty this of a free desc.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Misc data  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  pageBuffer: VM.PageNumber;  -- Holds real page being MStore.Deallocated.  pageBufferPtr: LONG POINTER;  swapUnitCheckedInOrUnmapped: CONDITION;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeVMDataUtilitiesA: --INTERNAL-- PROCEDURE;  -- Initializes all facilities not depending on ResidentHeap.  -- Called while holding vmDataLock.  InitializeVMDataUtilitiesB: --INTERNAL-- PROCEDURE;  -- Called when ResidentHeap is operational.  -- Called while holding vmDataLock.  InitializeVMDataMapImplA: --INTERNAL-- PROCEDURE;  -- (InitializeVMDataUtilitiesA must have been called first.)  -- Called while holding vmDataLock.    InitializeVMDataMapImplB: PROCEDURE;  -- VM must be operational at this point  -- ***NOT*** called while holding vmDataLock.  -- The procedures in this interface are implemented as coroutines.  -- It is necessary that they be declared in the interface in  -- terms of RECORDs in order that they may be exported.   -- Their client interface is expressed as INLINEs which  -- hides this implementation mechanism.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --  ProcessSwapUnits: Driver Routine for SwapUnitProcessors  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ProcessSwapUnits: VAR PROCEDURE [    interval: VM.Interval, unmappedProcessing: UnmappedProcessing,    runProcessing: RunProcessing, swapUnitProcessor: SwapUnitProcessor,    vacantProcessing: VacantProcessing ¬ processVacant]    RETURNS [nextPage: VM.PageNumber, aborted: BOOLEAN];  RunProcessing: TYPE = {spanRuns, abortWhenSpansRuns, errorIfSpansRuns};    VacantProcessing: TYPE = {skipVacant, processVacant};  UnmappedProcessing: TYPE = {skipUnmapped, errorIfUnmapped};  -- For each swap unit wholly or partially contained in interval, calls swapUnitProcessor.  -- If swapUnitProcessor returns continuation = abortIgnoreNewState or abortUseNewState, ProcessSwapUnits terminates processing and returns [nextPage: pageSwapUnit, aborted: TRUE].  -- If unmappedProcessing = skipUnmapped, unmapped pages in interval will be skipped; If unmappedProcessing = errorIfUnmapped and an unmapped page in interval is encountered, the debugger is called.  -- If runProcessing = spanRuns, processing continues past any Run boundaries.  -- If runProcessing = abortWhenSpansRuns, processing will terminate if and when processing attempts to continue past the end of a Run. In this case, returns aborted = TRUE.  -- If runProcessing = errorIfSpansRuns, the debugger will be called if and when processing attempts to continue past the end of a Run.  -- The returned nextPage is the page following the last page in interval which was either skipped (because it was unmapped) or sucessfully processed by swapUnitProcessor (i.e. it returned continuation = continue or abortUseNewState).  SwapUnitProcessor: TYPE = PROCEDURE [    pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState]    RETURNS [newState: SwapUnitState, continuation: Continuation];  Continuation: TYPE = {continue, abortIgnoreNewState, abortUseNewState};  runBeingProcessed: LONG POINTER TO Run;  -- SwapUnitProcessor processes a swap unit in some arbitrary way. It typically communicates with its client via shared variables.  -- Returns continuation = continue when further swap units should be processed; the state of the swap unit should be set to newState.   -- Returns continuation = abortIgnoreNewState when no further swap units should be processed; the value of newState is TRASH.   -- Returns continuation = abortUseNewState when no further swap units should be processed; the state of the swap unit should be set to newState.   -- The parent run of the swap unit being processed is available to SwapUnitProcessor in runBeingProcessed. Since this information is only rarely of interest, it is made available in this variable rather than being passed as a parameter.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- AdjustSwapUnitTablePointers  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Adds nSwapUnitWords to the swap unit pointers of the runs [pRun..pRunFollowing).  AdjustSwapUnitTablePointers: VAR PROCEDURE [    pRun: PRun, pRunFollowing: PRun, nSwapUnitWords: INTEGER];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- AnyUnavailable  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Returns TRUE if any of the swap units wholly or partially contained in interval are unavailable.  AnyUnavailable: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] = INLINE {    RETURN [      ProcessSwapUnits[        interval: interval, unmappedProcessing: skipUnmapped,        runProcessing: spanRuns,        swapUnitProcessor: AbortIfUnavailable].aborted]};  AbortIfUnavailable: VAR SwapUnitProcessor;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CreateTransferProcID  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Creates and returns the ID for a TransferProc.  --   If the TransferProc is already in the database, increments the reference count associated with it and returns its ID.  --   If the TransferProc is not in the database, creates a TransferProcDesc using useMeTransferProcDesc (which must not be nilPTransferProcDesc), assigns an ID and returns it.  -- On return it may have been set to nilPTransferProcDesc.  CreateTransferProcID: VAR PROCEDURE [    transferProc: BackingStore.TransferProc]    RETURNS [transferProcID: TransferProcID];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Find  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Searches for the Run which contains page.  -- If such a run is found, returns found=TRUE and a pointer to it.  -- If no such a run is found, returns found=FALSE and a pointer  -- to the first run which follows page. This may be end entry,  -- whose interval.page field is StoragePrograms.countVM.  -- page must be < StoragePrograms.countVM.  -- Find: VAR PROCEDURE [page: VM.PageNumber]  --           RETURNS [found: BOOLEAN, pRun: PRun];    Find: PROCEDURE [page: VM.PageNumber, rBase: RunBase, pRunTop: PRun]    RETURNS [found: BOOLEAN, pRun: PRun] = MACHINE CODE {MopcodesExtras2.zVMFIND};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- GetMapUnitBounds  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Given a pointer to a run, GetMapUnitBounds returns pointers to the first and last runs of its containing map unit.  Note that these may be the same run.  GetMapUnitBounds: VAR PROCEDURE [pRun: PRun]    RETURNS [pRunFirstInMapUnit: PRun, pRunLastInMapUnit: PRun];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- GetSwapUnitTablePointers  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Given the runs [pRunFirst..pRunFollowing), returns pointers to the first swap unit data and just beyond the last swap unit data associated with the runs.  If there is no such swap unit data, returns pSwapUnitFirst = pSwapUnitFollowing = nilPSwapUnit.  GetSwapUnitTablePointers: VAR PROCEDURE [    pRunFirst: PRun, pRunFollowing: PRun]    RETURNS [pSwapUnitFirst: PSwapUnit, pSwapUnitFollowing: PSwapUnit];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- GetTransferProc  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Returns the TransferProc associated with a transferProcID.  -- If deleteID = andDeleteID, the reference count for the specified item is decremented.  If the reference count becomes zero, the TransferProcID is deleted and the global freeMeTransferProcDesc is set to point to the storage to be freed; It is the caller's responsibility to free it.  -- At entry, the global freeMeHeapNode must be nilPTransferProcDesc; on return it may be non-nil.  GetTransferProc: VAR PROCEDURE [    transferProcID: TransferProcID, deleteOrRetain: DeleteOrRetain ¬ retainID]    RETURNS [transferProc: BackingStore.TransferProc];  DeleteOrRetain: TYPE = {deleteID, retainID};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- MakeRoomInSwapUnitTable  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Opens up the swap unit table to make room for nSwapUnitWords worth of data  -- at pSwapUnit. Indicates successful allocation via okay, which will be FALSE  -- if okayToAllocateRealMem was FALSE and more real memory was needed.  MakeRoomInSwapUnitTable: VAR PROCEDURE [    pSwapUnit: PSwapUnit, nSwapUnitWords: CARDINAL,      okayToAllocateRealMem: BOOLEAN]    RETURNS [okay: BOOLEAN];  END.  LOG27-Aug-82 15:31:51   LXD         Created file.23-Nov-82 16:45:14   WDK        New names; New types of some proc args. SwapUnitProcessor now gets pageAfterSwapUnit. Replaced GetAvailability with AnyUnavailable. 3-Dec-82 10:25:24   WDK         Maintain pRunTop instead of pRunNextFree.21-Dec-82 10:52:06   AWL         NewSpace => Space.18-Feb-83 20:31:44   WDK        Improved documentation. 1-Mar-83 17:48:10   WDK        Picture for pRunTop was wrong. Start using real BLTLR.17-Mar-83 13:53:44   WDK        Add abortUseNewState option to SwapUnitProcessor. 7-Apr-83 16:57:28   WDK        countRunTablePagesMapped should be CARDINAL.13-Jun-83  9:22:19   AWL         countSwapUnitTablePages = 20 (was 10).  minCountRun = 2000 (was 1500).20-Jun-83  9:13:01   JXG     pp WDK   countSwapUnitTablePages = 40 (was 20) 20-Jun-83  9:13:34   JXG        InitializeVMDataMapImpl => InitializeVMDataMapImplA   add InitializeVMDataMapImplB 4-Aug-83  9:14:42   WDK     	Deleted LongCOPYReverse (now in Inline). 8-Feb-84 16:14:38   EKN        Added VacantProcessing.13-Feb-84 15:50:48   CAJ    MakeRoomInSwapUnitTable checks okayToAllocateRealMem, returns result.18-Jun-84 11:07:20   KEK       Add hint "maybePartlyIn" field to Run: TRUE if there is a page potentially in real memory and FALSE if all pages are known out20-Jun-84 17:32:25   KEK       Add vacantProcessing to end of real ProcessSwapUnits[] return argument list (oops).  9-Jul-84 13:37:52   KEK       use VAR feature in place of fooProc/fooRecord stuff for coroutines. Add IsReservedMemory. Use VMData.State instead of local state record.26-Jan-88 13:30:58   RSV   countSwapUnitTablePages = 80 (was 40)21-Sep-88 11:52:26   TxH	changed the Find definition.12-Oct-88 16:10:33   RSV        use MopcodesExtras2.zVMFIND instead of 277B explicitly.
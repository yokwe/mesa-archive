-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- FloppyLoaderImpl.mesa     24-Jan-85 14:59:11 by EKN  -- This module provides public access to loading and unloading programs off the floppyDIRECTORY  Floppy USING [Error, FileHandle, PageCount],  FloppyChannel USING [GetHandle, Nop, Status],  FloppyLoader,  FloppySpace USING [MapAt, UnmapAt],  Runtime USING [ControlLink],  Space USING [Deallocate, Interval, nullInterval, virtualMemory],  SpecialLoader,  SpecialSpace USING [AllocateForCode];  FloppyLoaderImpl: PROGRAM  IMPORTS Floppy, FloppyChannel, FloppySpace, Space, SpecialLoader, SpecialSpace    EXPORTS FloppyLoader =    BEGIN   -- PUBLIC PROCS:  NewConfig: PUBLIC PROCEDURE [    file: Floppy.FileHandle, offset: Floppy.PageCount, codeLinks: BOOLEAN] = {    [] ¬ LoadConfig[file, offset, codeLinks]};  RunConfig: PUBLIC --FloppyLoader.-- PROCEDURE [    file: Floppy.FileHandle, offset: Floppy.PageCount, codeLinks: BOOLEAN] = {    control: PROGRAM ¬ LoadConfig[file, offset, codeLinks];    IF control # NIL THEN START control};  LoadConfig: PUBLIC --FloppyLoader.-- PROC [    file: Floppy.FileHandle, offset: Floppy.PageCount, codeLinks: BOOLEAN]    RETURNS [control: PROGRAM] =     BEGIN        MapSpace: SpecialLoader.MapProcType =      -- pageOffset, pageCount: CARDINAL,      -- swapUnits: Space.SwapUnits, access: Space.Access]      --RETURNS [mapUnitPtr: LONG POINTER]      BEGIN      interval: Space.Interval ¬ SpecialSpace.AllocateForCode[        pageCount, Space.virtualMemory];      RETURN[        FloppySpace.MapAt[          at: interval,          window: [file: file, base: offset + pageOffset, count: pageCount],          class: code, access: access, life: alive, swapUnits: swapUnits !          UNWIND => Space.Deallocate[interval]].mapUnit.pointer];      END;        -- check if floppy volume is readonly if placing links into code    -- Assumption: drive 0 is the only drive     IF codeLinks AND      FloppyChannel.Nop[FloppyChannel.GetHandle[drive: 0]] = writeFault THEN        ERROR Floppy.Error[writeInhibited];            RETURN SpecialLoader.LoadConfig[MapSpace, UnmapSpace, codeLinks];    END;          UnNewConfig: PUBLIC --FloppyLoader-- PROC [link: Runtime.ControlLink] = {    SpecialLoader.UnNewConfig[link, UnmapSpace]};              UnmapSpace: SpecialLoader.UnmapProcType =    -- targetAddress: LONG POINTER]     -- RETURNS [mapUnit: Space.Interval]    BEGIN    mapUnit ¬ Space.nullInterval;    IF targetAddress # NIL THEN {      -- UnmapAt/Deallocate (vs. Unmap) done to get mapUnit.count      mapUnit ¬ FloppySpace.UnmapAt[targetAddress]; Space.Deallocate[mapUnit]};    END;      END.LOG  30-Oct-84 14:28:07	EKN  	Created file.  24-Jan-85 14:58:18	EKN     Changed writeProtect to writeFault of FloppyChannel.Status.
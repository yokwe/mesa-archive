-- Copyright (C) 1982, 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- DebuggerSubstituteImpl.mesa	last edited: 30-May-86 21:02:25 by CAJ-- The procs in this program run with interrupts disabled; it may call--   only inlines and coroutines.-- Note that only ProcessorFace.SpecialSetMP should be used; ProcessorFace.SetMP--   is a procedure call.DIRECTORY  CPSwapDefs     USING [ExternalStateVector],  DebuggerSubstitute,  DebuggerSwap,  Frame          USING [ReadPC, SetReturnFrame, GetReturnFrame],  FrameExtras USING [ReadGlobalLink],  Inline         USING [DBITSHIFT],  PilotMP        USING [Code],  PilotSwitchesExtras   USING [bypassDebuggerSubstitute],  PrincOps       USING [BytePC, LocalFrameHandle, Port, StateVector],  PrincOpsExtras2 USING [GFTHandle],  ProcessorFace  USING [SpecialSetMP],  ProcessOperations  USING [IndexToHandle],  PSB  		 USING [PDA],  SpecialSpace   USING [MakeProcedureResident, MakeGlobalFrameResident, SpecialError],  System	 USING [switches];    DebuggerSubstituteImpl: PROGRAM   IMPORTS	DebuggerSwap,	Frame, FrameExtras,	Inline,	ProcessorFace,	ProcessOperations,	SpecialSpace, 	System   EXPORTS DebuggerSubstitute = BEGIN    breakpointMP: CARDINAL = 7520;  bugMP: CARDINAL = 7521;  callDebuggerMP: CARDINAL = 7522;  cleanMapLogMP: CARDINAL = 7523;  interruptMP: CARDINAL = 7524;  visitDebuggerMP: CARDINAL = 7525;  returnMP: CARDINAL = 7526;  returnAbortedMP: CARDINAL = 7527;  addressFaultMP: CARDINAL = 7528;  writeProtectFaultMP: CARDINAL = 7529;  uncaughtSignalMP: CARDINAL = 7530;  diskerrorMP: CARDINAL = 7531;  otherMP: CARDINAL = 7539;  realDebuggerSwitch: CHARACTER = 'd;  -- boot switch to enable using real debugger  mpModulus: NAT = 1000;  -- mp only guaranteed to be three digits.  -- an indirect control link to the port  pilotDebuggerFielder: PROC [pEsv: LONG POINTER TO CPSwapDefs.ExternalStateVector];        callRealDebugger, backToClient, kill: BOOLEAN ¬ TRUE;  ConvertToOctal: PROC [d: CARDINAL] RETURNS [o: CARDINAL] = INLINE {    o ¬ d - (d/64)*64; -- mask off all but low 3 octal digits    o ¬ (o/64)*100 + ((o/8) MOD 8)*10 + (o MOD 8)};  ShowDriveNumber: PROC [msg: LONG STRING] = INLINE {    drive: CARDINAL ¬ msg[30] - '0;    ShowCodeInMP[drive]};  ShowPageNumber: PROC [msg: LONG STRING] = INLINE {    page: CARDINAL ¬ 0;    FOR pos: CARDINAL ¬ msg.length-9, pos + 1 UNTIL pos > msg.length-7 DO       page ¬ page*10 + (IF msg[pos] = '  THEN 0 ELSE (msg[pos] - '0));      ENDLOOP;    ShowCodeInMP[page];    page ¬ 0;    FOR pos: CARDINAL ¬ msg.length-6, pos + 1 UNTIL pos > msg.length-4 DO       page ¬ page*10 + (IF msg[pos] = '  THEN 0 ELSE (msg[pos] - '0));      ENDLOOP;    ShowCodeInMP[page];    page ¬ 0;    FOR pos: CARDINAL ¬ msg.length-3, pos + 1 UNTIL pos > msg.length-1 DO       page ¬ page*10 + (IF msg[pos] = '  THEN 0 ELSE (msg[pos] - '0));      ENDLOOP;    ShowCodeInMP[page]};  ShowCardinalInMP: PROC [cardinal: UNSPECIFIED] = INLINE {    ShowCodeInMP[cardinal/mpModulus]; ShowCodeInMP[cardinal MOD mpModulus]};  ShowInMP: PROC [    mpcode: PilotMP.Code, g: PrincOpsExtras2.GFTHandle, p: PrincOps.BytePC];  ShowCodeInMP: PROC [mpCode: PilotMP.Code] = INLINE {    ProcessorFace.SpecialSetMP[mpCode];    FOR delay: LONG CARDINAL IN [0..400000) DO ENDLOOP};  InitializeShowInMP: PROCEDURE RETURNS [--must match PORT args--] =    BEGIN    -- an indirect control link to the PORT.    -- args/results match showInMPInternal (but swapped).    AwaitShowInMPRequest: --RESPONDING-- PORT [] RETURNS [      mpcode: PilotMP.Code, g: PrincOpsExtras2.GFTHandle, p: PrincOps.BytePC];    mpcode: PilotMP.Code;    g: PrincOpsExtras2.GFTHandle;    p: PrincOps.BytePC;    ShowInMP ¬ LOOPHOLE[LONG[@AwaitShowInMPRequest]];    LOOPHOLE[AwaitShowInMPRequest, PrincOps.Port].out ¬ Frame.GetReturnFrame[];    DO  --FOREVER--      -- Await new request;  Process it;      [mpcode, g, p] ¬ AwaitShowInMPRequest[];      Frame.SetReturnFrame[LOOPHOLE[        AwaitShowInMPRequest, PrincOps.Port].dest.frame];  -- for debugger      ShowCodeInMP[mpcode];      ShowCardinalInMP[g];      ShowCardinalInMP[p]      ENDLOOP;    END;  --InitializeShowInMP-- InitializeAwaitDebuggerSubstRequest: PRIVATE PROC = {    awaitDebuggerSubstRequest: DebuggerSwap.AwaitDebuggerRequest;      --PORT RETURNS [LONG POINTER TO CPSwapDefs.ExternalStateVector]--    localFrameRequestingAttention: PrincOps.LocalFrameHandle;    faultAddr: LONG CARDINAL;    globalFrame: PrincOpsExtras2.GFTHandle;    pc: PrincOps.BytePC;    pESV: LONG POINTER TO CPSwapDefs.ExternalStateVector;    LOOPHOLE[awaitDebuggerSubstRequest, PrincOps.Port].out ¬      Frame.GetReturnFrame[];    pilotDebuggerFielder ¬       LOOPHOLE[LONG[DebuggerSwap.SetDebuggerFielder[@awaitDebuggerSubstRequest]]];    DO  --FOREVER--      pESV ¬ awaitDebuggerSubstRequest[];        -- Caller has set the following fields in the      --   external state vector: reason, parameter, state.      Frame.SetReturnFrame[  -- for debugging me        LOOPHOLE[awaitDebuggerSubstRequest, PrincOps.Port].dest.frame];            -- decode the ESV here      WITH sd:pESV.swapData SELECT FROM        storageFault => {faultSV: PrincOps.StateVector = 	   PSB.PDA[	     PSB.PDA[	       ProcessOperations.IndexToHandle[	         sd.faultedProcess]].context.state];	   localFrameRequestingAttention ¬ faultSV.frame;	   faultAddr ¬  LOOPHOLE[faultSV.memPointer]};         ENDCASE => localFrameRequestingAttention ¬ LOOPHOLE[pESV.swapData.lFrame];       globalFrame ¬ FrameExtras.ReadGlobalLink[localFrameRequestingAttention];      pc ¬ Frame.ReadPC[localFrameRequestingAttention];      DO WITH sd:pESV.swapData SELECT FROM	breakpoint =>           -- DO NOT SET BREAKPOINTS IN THIS ARM!	  -- They will be recursively delivered to itself.	  ShowInMP[breakpointMP, globalFrame, pc];	bug => {	  bugIndex: CARDINAL = sd.bugType;	  ShowInMP[bugMP, globalFrame, pc];	  ShowCardinalInMP[bugIndex]}; 	callDebugger => 	  -- (Worry)CallDebugger	  IF sd.message[0] = 'U AND sd.message.length =	    ("Unrecoverable disk error on RDX (Drive X), page XXXXXXXX"L).length	     -- must exactly match message string built in	     --   DiskBackingStoreImpl.ReportErrorToDebugger	     THEN {	     ShowInMP[diskerrorMP, globalFrame, pc];	     ShowDriveNumber[sd.message];	     ShowPageNumber[sd.message]}	  ELSE {	    ShowInMP[callDebuggerMP, globalFrame, pc];	    SELECT TRUE FROM	       sd.message = NIL, sd.message.length = 0 => {	         ShowCodeInMP[0]; ShowCodeInMP[0]};	       sd.message.length > 1 => { 	         ShowCodeInMP[LOOPHOLE[sd.message[0], PilotMP.Code]];	         ShowCodeInMP[LOOPHOLE[sd.message[1], PilotMP.Code]]};	       ENDCASE => {	         ShowCodeInMP[LOOPHOLE[sd.message[0], PilotMP.Code]];	         ShowCodeInMP[0]}};	cleanMapLog => 	  -- Pilot's map log is full.  Cannot happen if proper	  --   boot switches are specified	  ShowInMP[cleanMapLogMP, globalFrame, pc];	interrupt => 	  -- this is generated by Runtime.Interrupt	  ShowInMP[interruptMP, globalFrame, pc];	noOp => 	  -- SpecialRuntime.VisitDebugger	  ShowInMP[visitDebuggerMP, globalFrame, pc]; 	return => 	  -- impossible.  This is used going back to CoPilot after	  -- a call from CoPilot's interpreter	  ShowInMP[returnMP, globalFrame, pc]; 	returnAborted => 	  -- impossible.  This is used going back to CoPilot after	  -- a call from CoPilot's interpreter	  ShowInMP[returnAbortedMP, globalFrame, pc];        storageFault => {	  -- address fault or write protect fault	  numDigits: CARDINAL ¬ 0;	  highDigit: CARDINAL ¬ 0;	  IF sd.type = addressFault THEN ShowInMP[addressFaultMP, globalFrame, pc]	  ELSE ShowInMP[writeProtectFaultMP, globalFrame, pc];	  WHILE faultAddr # 0 DO	    highDigit ¬ CARDINAL[faultAddr MOD 8];	    faultAddr ¬ Inline.DBITSHIFT[value: faultAddr, count: -3];	    numDigits ¬ numDigits + 1;	    ENDLOOP;	  ShowCodeInMP[highDigit*100+numDigits]};	uncaughtSignal => {	  -- localFrameRequestingAttention is the guy raising the uncaught signal	  ShowInMP[uncaughtSignalMP, globalFrame, pc];      	  ShowCardinalInMP[sd.signal.gf];	  ShowCodeInMP[sd.signal.index MOD mpModulus];	  IF sd.signalArgs ~= NIL THEN ShowCodeInMP[	    LOOPHOLE[sd.signalArgs, POINTER TO CARDINAL]­ MOD mpModulus]};  	callDebuggee, kill, proceed, quit, resizeBreakBlockTable,	   resizePatchTable, showScreen, start, debuggerSpareA, debuggerSpareB => 	  -- these reasons are from CoPilot to Client, and 	  -- are impossible here	  ShowInMP[otherMP, globalFrame, pc];        debuggeeSpareA, debuggeeSpareB => ShowInMP[otherMP, globalFrame, pc];        ENDCASE => ShowInMP[otherMP, globalFrame, pc];      -- done decoding the ESV.  	          IF callRealDebugger THEN {pilotDebuggerFielder[pESV]; EXIT};            ENDLOOP;    ENDLOOP};     -- MAIN:   SpecialSpace.MakeGlobalFrameResident[DebuggerSubstituteImpl  ! SpecialSpace.SpecialError => IF error=alreadyResident THEN CONTINUE];    SpecialSpace.MakeProcedureResident[InitializeAwaitDebuggerSubstRequest  ! SpecialSpace.SpecialError => IF error=alreadyResident THEN CONTINUE];  [] ¬ InitializeAwaitDebuggerSubstRequest[];  -- allocate frame, init port  SpecialSpace.MakeProcedureResident[InitializeShowInMP  ! SpecialSpace.SpecialError => IF error=alreadyResident THEN CONTINUE];  [] ¬ InitializeShowInMP[];  -- allocate frame, init port  callRealDebugger ¬     System.switches[PilotSwitchesExtras.bypassDebuggerSubstitute] = down;  END.  16-Feb-82 12:38:40   FXH	Created file. 4-Jan-84 15:56:42   LXR	? 22-May-84 13:50:53  CAJ	Unnamed ERROR no longer attempts to dereference NIL arg pointer. 5-Apr-85 17:17:04   CAJ	Unrecoverable disk error now displays drive also.30-May-86 21:02:16   CAJ	Change in Unrecoverable disk error message, matching change to DiskBackingStoreImpl.  
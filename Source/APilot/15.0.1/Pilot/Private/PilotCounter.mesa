-- Copyright (C) 1983, 1984, 1987, 1988  by Xerox Corporation. All rights reserved. -- PilotCounter.mesa, last edited by-- RSV          16-Dec-88 14:47:21 Fixed AR 13521, calling FrameExtras.LongGFToGFTHandle with passing NIL.-- RSV/AHL      19-Feb-87 13:52:00 Converted to MDS relief-- AXD    	28-Sep-83 23:08:13-- JXP   	16-Sep-83 15:38:47-- DXG    	 4-Jun-84 17:51:03DIRECTORY  CountPrivate: TYPE USING [ControlRecord, GFRec, Table, VersionID],  CPSwapDefs: TYPE USING [    BBHandle, BreakpointHandlerItem, BreakpointHandlerPtr, BreakpointHandlerType,    ExternalStateVector, OperandDesc, PESV, UBBPointer],  DebuggerSwap: TYPE USING [AwaitDebuggerRequest, SetDebuggerFielder],  Environment: TYPE USING [PageFromLongPointer, wordsPerPage],  Frame: TYPE USING [GetReturnFrame, MyLocalFrame, ReadPC],  FrameExtras: TYPE USING [    ReadGlobalLink, ReadCodebase, GFTHandleToLongGF, LongGFToGFTHandle],  GFHash: TYPE USING [Create, Fetch, Insert, MakeResident, Table],  Inline,  LoadState: TYPE USING [LockBcdInfo, UnlockBcdInfo],  PerformancePrograms: TYPE USING [],  PrincOps: TYPE USING [BYTE, LocalFrameHandle, StateVector],  PrincOpsExtras2: TYPE USING [    ControlLink, GFTHandle, LongGlobalFrameHandle, NullLink, nullGFH],   PrincOpsExtras: TYPE USING [SourceDest],  ProcessOperations: TYPE USING [DisableInterrupts, ReadPSB],  ProcessorFace: TYPE USING [microsecondsPerHundredPulses],  PSB: TYPE USING [NullPsbHandle, PsbHandle],  SDDefs: TYPE USING [SD, sXferTrap, sXferTrapMonitor],  Space: TYPE USING [Allocate, PageFromLongPointer],  SpecialSpace: TYPE USING [    MakeGlobalFrameResident, MakeProcedureResident, SpecialError],  System: TYPE USING [GetClockPulses],  VM: TYPE USING [Map],  XferTrap: TYPE USING [WriteXTS];  PilotCounter: PROGRAM  IMPORTS    CPSwapDefs, DebuggerSwap, Frame, FrameExtras, GFHash, Inline,     LoadState, ProcessOperations, ProcessorFace, Space,     SpecialSpace, System, VM, XferTrap  EXPORTS PerformancePrograms =   BEGIN OPEN CountPrivate;    cr: ControlRecord ¬ [    gf: NIL, prevGf: NIL, version: VersionID, saveBreakHandler: PrincOpsExtras2.NullLink,    limit: TRASH, lastIndex: 0, newSession: TRUE, trace: FALSE, counts: NIL,    times: NIL, process: PSB.NullPsbHandle, self: NIL, mode: plain,    newMeasurement: TRUE, ht: TRASH,    pulseConversion: ProcessorFace.microsecondsPerHundredPulses];    -- Initialization and control    breakHandler: CPSwapDefs.BreakpointHandlerItem;    InitializePilotCounter: PUBLIC PROC = {};  ReallyInitialize: PROC [] RETURNS [] = {    df: POINTER TO DebuggerSwap.AwaitDebuggerRequest;    GetLimit: PROC RETURNS [CARDINAL] = {      count: CARDINAL ¬ 0;      BEGIN ENABLE UNWIND => NULL;      count ¬ LoadState.LockBcdInfo[].loadState.maxModules;      LoadState.UnlockBcdInfo[];      END;      RETURN[count + count/2]}; -- a guess...    limit: CARDINAL = GetLimit[];    words: CARDINAL = MAX[Table.plain[limit].SIZE, Table.matrix.SIZE] * 2;    pages: CARDINAL =      (words + Environment.wordsPerPage - 1)/Environment.wordsPerPage;    data: LONG POINTER = Space.Allocate[pages].pointer;    cr.limit ¬ limit;    cr.counts ¬ data;    cr.times ¬ data + MAX[Table.plain[limit].SIZE, Table.matrix.SIZE];    VM.Map[      interval: [Space.PageFromLongPointer[data], pages],      transferProc: NIL, backingStoreRuns: NIL,      class: data, swapUnits: [unitary[]], swappability: resident];    data­ ¬ 0;    Inline.LongCOPY[from: data, to: data + 1, nwords: words - 1];    cr.ht ¬ GFHash.Create[limit, GFRec.SIZE];    LOOPHOLE[cr.ht.Insert[PrincOpsExtras2.nullGFH], LONG POINTER TO GFRec]­ ¬ [index: 0, group: 0];    SDDefs.SD[SDDefs.sXferTrapMonitor] ¬ LOOPHOLE[@cr];    cr.ht.MakeResident[];    SpecialSpace.MakeProcedureResident[LOOPHOLE[HandleTraps]      ! SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE	ELSE REJECT];    SpecialSpace.MakeGlobalFrameResident[PilotCounter      ! SpecialSpace.SpecialError =>        IF error = alreadyResident THEN CONTINUE	ELSE REJECT];    HandleTraps[];    MonitorBreaks[];    breakHandler ¬ [      handler: [frame[frame: cr.self]],      type: CPSwapDefs.BreakpointHandlerType[countTool],      next: CPSwapDefs.PESV[].breakpointHandlers];    CPSwapDefs.PESV[].breakpointHandlers ¬ @breakHandler;    df ¬ DebuggerSwap.SetDebuggerFielder[NIL];    [] ¬ DebuggerSwap.SetDebuggerFielder[df];    debuggerFielder ¬ LOOPHOLE[LONG[df]]};  -- Trap handler    ReturnLink: PROC RETURNS [PrincOpsExtras2.ControlLink] = INLINE {    RETURN[PrincOpsExtras2.ControlLink[frame[frame: Frame.GetReturnFrame[]]]]};  LongGFToGFTHandle: PROCEDURE [h: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.GFTHandle] = INLINE {    IF h = NIL THEN RETURN[PrincOpsExtras2.nullGFH]    ELSE RETURN[FrameExtras.LongGFToGFTHandle[h]]};  AddEntry: PROC [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [rec: LONG POINTER TO GFRec] = INLINE {    rec ¬ cr.ht.Insert[LongGFToGFTHandle[cr.gf]];    IF rec = NIL THEN RETURN[cr.ht.Fetch[PrincOpsExtras2.nullGFH]]    ELSE rec­ ¬ [index: cr.lastIndex ¬ cr.lastIndex.SUCC, group: 0]};      debuggerFielder: PROCEDURE [LONG POINTER TO CPSwapDefs.ExternalStateVector];  HandleTraps: PROC [] RETURNS [] = {    state: PrincOps.StateVector.dst;    xc: PrincOpsExtras.SourceDest;    state ¬ STATE;    xc.dest ¬ LOOPHOLE[ReturnLink[]];    SDDefs.SD[SDDefs.sXferTrap] ¬ LOOPHOLE[      PrincOpsExtras2.ControlLink[frame[frame: Frame.MyLocalFrame[]]]];    ProcessOperations.DisableInterrupts[];    DO      previousProcess: PSB.PsbHandle = ProcessOperations.ReadPSB[];      start, finish, time: LONG CARDINAL;      IF cr.trace THEN XferTrap.WriteXTS[skip1];      start ¬ System.GetClockPulses[];      STATE ¬ state;      TRANSFER WITH xc;      state ¬ STATE;      finish ¬ System.GetClockPulses[];      XferTrap.WriteXTS[off];      time ¬ finish - start;      SELECT TRUE FROM        cr.newMeasurement => {cr.newMeasurement ¬ FALSE; cr.prevGf ¬ NIL};	cr.mode = plain => {	  rec: LONG POINTER TO GFRec ¬ TRASH;	  IF (rec ¬ cr.ht.Fetch[LongGFToGFTHandle[cr.gf]]) = NIL THEN rec ¬ AddEntry[cr.gf];	  cr.times.plain[rec.index] ¬ cr.times.plain[rec.index] + time;	  IF ProcessOperations.ReadPSB[] = previousProcess THEN	    cr.counts.plain[rec.index] ¬ cr.counts.plain[rec.index] + 1	  ELSE time ¬ time};	ENDCASE => {	  to, from: LONG POINTER TO GFRec ¬ TRASH;	  IF (to ¬ cr.ht.Fetch[LongGFToGFTHandle[cr.gf]]) = NIL THEN 	    to ¬ AddEntry[cr.gf];	  IF (from ¬ cr.ht.Fetch[LongGFToGFTHandle[cr.prevGf]]) = NIL THEN 	    from ¬ AddEntry[cr.prevGf];	  cr.prevGf ¬ cr.gf;	  cr.times.matrix[to.group][from.group] ¬ 	    cr.times.matrix[to.group][from.group] + time;	  IF ProcessOperations.ReadPSB[] = previousProcess THEN	    cr.counts.matrix[to.group][from.group] ¬ 	      cr.counts.matrix[to.group][from.group] + 1	  ELSE time ¬ time};      xc.dest ¬ LOOPHOLE[ReturnLink[]];      cr.gf ¬ FrameExtras.GFTHandleToLongGF[FrameExtras.ReadGlobalLink[xc.dest.frame]];      IF cr.process # PSB.NullPsbHandle        AND cr.process # ProcessOperations.ReadPSB[] THEN cr.gf ¬ NIL;      ENDLOOP};  MonitorBreaks: PROC [] RETURNS [] = {    state: PrincOps.StateVector.dst;    xc: PrincOpsExtras.SourceDest;    state ¬ STATE;    cr.self ¬ Frame.MyLocalFrame[];    xc.dest ¬ LOOPHOLE[ReturnLink[]];    ProcessOperations.DisableInterrupts[];    DO      bbHandle: CPSwapDefs.BBHandle;      frame: PrincOps.LocalFrameHandle;      STATE ¬ state;      TRANSFER WITH xc;      state ¬ STATE;      xc.dest ¬ LOOPHOLE[ReturnLink[]];      frame ¬ xc.dest.frame;      bbHandle ¬ CPSwapDefs.PESV[].breakBlocks;      FOR i: CARDINAL IN [0..bbHandle.length) DO        ubb: CPSwapDefs.UBBPointer = @bbHandle.blocks[i];	IF FrameExtras.ReadCodebase[FrameExtras.ReadGlobalLink[frame]].codebase = ubb.codeBase	AND Frame.ReadPC[frame] = ubb.pc THEN {	  WITH ubb.leftOperand SELECT FROM	    counter => WITH ubb.rightOperand SELECT FROM	      switch: CPSwapDefs.OperandDesc.immediate =>		SELECT switch.value FROM		  0 => cr.trace ¬ TRUE;		  1 => cr.trace ¬ NOT cr.trace;		  2 => cr.trace ¬ FALSE;		  ENDCASE;	      ENDCASE;	    ENDCASE;	  state.instbyte ¬ ubb.inst;	  EXIT};	REPEAT FINISHED => {	  instByteFromDebugger: PrincOps.BYTE;	  esv: LONG POINTER TO CPSwapDefs.ExternalStateVector =	    CPSwapDefs.PESV[];	  esv.swapData ¬ [	    lFrame: frame, process: TRASH,	    mayCallDebuggee: FALSE, trashWasOnStack: FALSE, fillA: TRASH,	    body: breakpoint[	      sv: @state, instByteReceptacle: @instByteFromDebugger]];	  debuggerFielder[esv];	  state.instbyte ¬ instByteFromDebugger};	ENDLOOP;      IF cr.trace THEN XferTrap.WriteXTS[skip1]      ELSE {XferTrap.WriteXTS[off]; cr.gf ¬ cr.prevGf ¬ NIL};      ENDLOOP};          StartCounting: PUBLIC PROC = {XferTrap.WriteXTS[skip1]; cr.trace ¬ TRUE};  StopCounting: PUBLIC PROC = {cr.trace ¬ FALSE; cr.gf ¬ cr.prevGf ¬ NIL};    ReallyInitialize[];    END.
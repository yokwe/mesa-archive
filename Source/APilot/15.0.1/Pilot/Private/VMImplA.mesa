-- Copyright (C) 1984, 1985, 1986, 1987, 1989  by Xerox Corporation. All rights reserved. -- VMDriver>VMImplA.mesa  12-Apr-89 12:10:52 by TxH **    -- This program implements the mapping and data transfer operations of the VM interface.-- WARNING WARNING WARNING: THIS FILE IS TOO BIG FOR THE FORMATTER ( > 65535 BYTES). IF YOU GIVE THIS FILE TO THE FORMATTER, IT WILL TRASH IT!-- EXTERNAL REQUIREMENTS:---- One state vector could be allocated at priorityPageFaultLow to allow interpret calls from the debugger when hung on I/O error.-- NOTES TO THE READER:---- The reader should be familiar with the document which describes the VM implementation.---- To understand the VM data transfer procs implemented below, it is important to first read and understand the definition of VMInternal.OpData, and that of ProcessBatches, ProcessBatchProc, and IOTransfer (defined below). Many procedures have an OpData and OpData.checkOutData OPENed. If you don't see a variable declared, that's where it is.-- IMPLEMENTATION NOTES:---- Exclusive access to individual swap units is provided by checking them out. Checking out happens to remove those swap units from available reserved memory.  Exclusive access to the data and referenced and dirty map flags of a page is provided by temporarily moving the page from its normal place in the client's address space to a swap buffer. If it is required or convenient to manipulate the page flags while a page is mapped at its normal address, the implementation must often loop until the flags it sets reflects both its desires and any concurrent reads and writes by clients and microcode. ---- If data is being written out and will remain swapped in at the completion of the output operation, we do not relocate the data to a swap buffer during output because (1) we can't if the data is resident, and (2) there is no harm in letting the client modify the data during the operation (if he wants to!).-- If data is being written out and will become swapped out at the completion of the output operation, we relocate the data to a swap buffer to stop client data modification before writing commences.-- If data is being swapped in, it is read into a swap buffer (1) to prevent the client from seeing the uninitialized real memory pages, and (2) to allow us to apply any patches and set flags=clean before the client gains access to the pages.---- ASSERT: If a swap unit is readOnly, it is alive. This invarient must be carefully maintained when a swap unit changes from writable to readOnly.---- ASSERT: Swappable readOnly pages are clean (that's what reserved memory is). This invarient must be carefully maintained when a swap unit changes from writable to readOnly or from resident to swappable. (Note that resident readonly pages may be dirty.)---- ASSERT: Resident swap units are 100% mapped and swapped in. Resident portions of memory not obeying this rule are "outlaw spaces" and are managed by other software. VM has no knowledge of them, and no operations VM may be applied to them.---- If multiple output operations are piggybacked together where intervening clean swappable pages are included in the ioInterval, the implementation must do a SubtractReserved for the clean pages before starting the I/O.---- No signals may be raised while a process has any swap units checked out (because it might be the swap unit containing the signaller's code, say). No signals may be raised while a process is running at a reserved priority (because we only have one state vector for us there and thus can not take page faults).-- PACKAGING CONSDIERATIONS:---- EnterVM, ExitVM, and all procedures that are called between them must be resident. (That's just about everything.)-- PERFORMANCE TUNING:---- Experiment with number of page fault and swap out processes.-- PROBLEMS:---- Problem 1:  It is possible for VMData.CheckOut to return an interval which is larger than VMPerf.BatchCount. This is a problem for the reservedRequired count, since it may overflow.-- TO BE DONE:---- Handle reserved pages in page fault swap units.-- Handle exports and initialization.-- Add more instrumentation.-- Debugging procedures?-- Look at code listing for poor code. Consider inlines / out-of-line.-- Consider reducing local frame size of PageFaultProcess root frame by putting swap out code in separate procedure. This will cost a call/return per page fault. Ditto SwapOutProcess.-- THINGS TO CONSIDER:---- Consider using BatchCount instead of PageCount where appropriate.-- Consider piggybacking runs together where appropriate. Remember reserved memory considerations. Put boot switch and VMPerf proc to disable feature.-- SUBOPTIMAL ASPECTS OF THE CURRENT IMPLEMENTATION:---- When several subintervals of a dead batch are swapped out, the union of the intervals becomes alive, rather than just the swap units containing pages that were written.DIRECTORY  BackingStore USING [Data, Operation, Result, Run, TransferData, TransferProc],  CPSwapDefs USING [ExternalStateVector, PatchTable, PatchTableEntry, PESV],  Environment USING [LongPointerFromPage, PageCount, PageFromLongPointer, PageNumber],  Inline USING [LowHalf],  MStore USING [    AwaitBelowThreshold, Deallocate, Promise, RelocateAdjustingFlags,    RelocatePCMemory],  PageFault USING [    PageFaultProcessStarted, ReportRestart, RestartAndAwaitNext],  PageMap USING [    ExchangeFlags, Flags, flagsDirty, flagsReadOnly,    flagsReadOnlyDirtyReferenced, flagsVacant, GetState, IsMapped, IsVacant,    maskAll, maskNone, maskNotDirty],  Pinning USING [CreatePinHandle, Pin, PinHandle, Unpin],  Process USING [Detach, Priority],  ProcessInternal USING [GetCurrent, SetPriority],  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  ProcessPriorities USING [priorityClientHigh],  ProcessPrioritiesExtras USING [priorityPageFaultHigh, priorityPageFaultLow],  PSB USING [PDA],  Runtime USING [CallDebugger, GlobalFrame, IsBound],  RuntimeInternal USING [Bug, GetSwapUnitsFromLoadedBcd],  Space USING [    Access, Class, Error, IOError, Life,    SwapUnitOption, SwapUnitSize, Usage],  SpecialRuntime USING [Catch, Code, EntryVector],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  SpecialSpace USING [realMemorySize],  StoragePrograms USING [countVM, EnumerateStartList, startList, StartListProc],  SwapBuffer USING [Allocate, Deallocate, maxBufferSize, SizeRequirement],  System USING [GetClockPulses, Pulses],  VM USING [    BackingStoreRuns, GetMapUnitAttributes,    GetSwapUnitAttributes, Interval, nullInterval, ReturnWait, Swappability],  VMData USING [    CheckInSwapUnits, CheckOutSwapUnits, CreateMapUnit, DeleteMapUnit,    FindDirtyUnreferenced, ProcessType, MapParams, NewState, noStateChange,    ParamsSwapStatus, RelocateMapUnit, swapOutPagesReclaimed],  VMExtras2 USING [DeleteMapUnitPartially], --**  VMInternal USING [    AllocateRealMemory, AwaitNoOverlappingOperations,    DeallocateMStoreIfClean, DoneWithStateVector, ErrorDesc,    GetProcessType, GuardStateVector, InitializePageFault,    InitializeSwapBuffer, InitializeVMUtilities,     InitializeVMDriverB,--**-- IOErrorContinuation, IOErrorHandler,    OpData, --**-- ProcessBatchesOptions, ProcessBatchProc,--**--    EnqueueOperation, ReadDead],  VMPerf USING [BatchCount, TransferWatcher];  VMImplA: --almost not a-- MONITOR LOCKS unmapAndRelocateLock  IMPORTS    CPSwapDefs, Environment, Inline, MStore, PageFault, PageMap,     Pinning, Process, ProcessInternal, ProcessOperations, Runtime,    RuntimeInternal,Space--for signals--, SpecialRuntime,    SpecialRuntimeExtras, SpecialSpace, StoragePrograms, SwapBuffer,    System, VM, VMData, VMInternal, VMExtras2--**  EXPORTS     SpecialRuntime, StoragePrograms,     VM, VMInternal, VMPerf, VMExtras2--**  SHARES PageMap, VMPerf =  BEGIN OPEN VMInternal;  -- Parameters:    defaultInitialPageFaultProcesses: CARDINAL = 2;  -- two for double buffering.  defaultSwapOutProcesses: CARDINAL = 2;  -- two for double buffering.    ratioRealMemSizeToMaxTransferPages: CARDINAL = 10;  -- for setting maxTransferPages.  -- Performance data (exported to VMPerf):  operations: PUBLIC LONG CARDINAL ¬ 0;  maps: PUBLIC CARDINAL ¬ 0;  mapPulses: PUBLIC System.Pulses ¬ [0];  unmaps: PUBLIC CARDINAL ¬ 0;  forceOuts: PUBLIC CARDINAL ¬ 0;  batches: PUBLIC LONG CARDINAL ¬ 0;    pageFaults: PUBLIC LONG CARDINAL ¬ 0;  pageFaultPulses: PUBLIC System.Pulses ¬ [0];  pageFaultInputs: PUBLIC LONG CARDINAL ¬ 0;  pageFaultPagesInput: PUBLIC LONG CARDINAL ¬ 0;    swapOutJobs: PUBLIC LONG CARDINAL ¬ 0;  swapOutJobPulses: PUBLIC System.Pulses ¬ [0];  swapOutOutputs: PUBLIC LONG CARDINAL ¬ 0;  swapOutPagesActuallyOutput: PUBLIC LONG CARDINAL ¬ 0;  clientPageFaultProcesses: PUBLIC CARDINAL ¬ 0;  swapOutProcesses: PUBLIC CARDINAL ¬ 0;  -- Other Public items:    ResidentRunFastCodeHandle: PUBLIC --StoragePrograms.-- PROC [] = {};    -- Common Types and Constants:  maxTransferPages: VMPerf.BatchCount;  -- max number of pages transferred in a single operation for giant e.g. CopyOut.  flagsReadOnly: PageMap.Flags = PageMap.flagsReadOnly;  flagsVacant: PageMap.Flags = PageMap.flagsVacant;  Interval: TYPE = VM.Interval;  maskNone: PageMap.Flags = PageMap.maskNone;  maskAll: PageMap.Flags = PageMap.maskAll;  priorityPageFaultLow: Process.Priority = ProcessPrioritiesExtras.priorityPageFaultLow;  priorityPageFaultHigh: Process.Priority =    ProcessPrioritiesExtras.priorityPageFaultHigh;  PageCount: TYPE = Environment.PageCount;  PageNumber: TYPE = Environment.PageNumber;  BugType: TYPE = {    alreadyGotEnough, cantUndoubleCountReservedMemory, funnyCase,    invalidParameters, logicError, unexpectedSignal, impossibleEndcase};      activatePin: Pinning.PinHandle; -- Activate procedure handle  deactivatePin: Pinning.PinHandle; -- Deactivate procedure handle  forceOutPin: Pinning.PinHandle; -- ForceOut procedure handle  relocatePin: Pinning.PinHandle; -- Relocate procedure handle  setAccessPin: Pinning.PinHandle; -- SetAccess procedure handle  partiallyUnmapPin: Pinning.PinHandle; --**PartiallyUnmap procedure handle      unmapAndRelocateLock: MONITORLOCK;  -- only serializes Unmaps and Relocates (actually, a few other tiny things).  transferWatcher: VMPerf.TransferWatcher ¬ NIL;  BatchCount: TYPE = VMPerf.BatchCount;  -- TEMP    --~~~~~~~~ Initialization, testing, and performance facilities: ~~~~~~~~  InitializeVMDriver: PUBLIC --StoragePrograms.-- PROCEDURE [] =    BEGIN    initialPageFaultProcesses: CARDINAL ¬  -- allows twiddling from debugger.      defaultInitialPageFaultProcesses;    swapOutProcesses: CARDINAL ¬  -- allows twiddling from debugger.      defaultSwapOutProcesses;    VMInternal.InitializeSwapBuffer[];    VMInternal.InitializePageFault[];    VMInternal.InitializeVMUtilities[];    activatePin ¬ Pinning.CreatePinHandle[LOOPHOLE[ActivateSynchronous], 1];    deactivatePin ¬ Pinning.CreatePinHandle[LOOPHOLE[DeactivateSynchronous], 1];    forceOutPin ¬ Pinning.CreatePinHandle[LOOPHOLE[ForceOutSynchronous], 1];    relocatePin ¬ Pinning.CreatePinHandle[LOOPHOLE[Relocate], 1];    setAccessPin ¬ Pinning.CreatePinHandle[LOOPHOLE[SetAccess], 1];    partiallyUnmapPin ¬ --**      Pinning.CreatePinHandle[LOOPHOLE[PartiallyUnmap], 1];        VMInternal.InitializeVMDriverB[]; --**        maxTransferPages ¬ VMPerf.BatchCount[      Inline.LowHalf[	MIN[	  LAST[VMPerf.BatchCount],	  SpecialSpace.realMemorySize/ratioRealMemSizeToMaxTransferPages,	  SwapBuffer.maxBufferSize]]];    THROUGH [1..initialPageFaultProcesses] DO AnotherPageFaultProcess[] ENDLOOP;    THROUGH [1..swapOutProcesses] DO AnotherSwapOutProcess[] ENDLOOP;    END;  AnotherPageFaultProcess: PUBLIC --VMPerf.-- PROCEDURE [] = {    -- We don't make this an ENTRY proc because the expected probability    -- of concurrent access is thought to be infinitesimal    -- and the consequences of such access unimportant.    Process.Detach[FORK PageFaultProcess[]];    clientPageFaultProcesses ¬ clientPageFaultProcesses + 1};  AnotherSwapOutProcess: PUBLIC --VMPerf.-- PROCEDURE [] = {    -- We don't make this an ENTRY proc because the expected probability    -- of concurrent access is thought to be infinitesimal    -- and the consequences of such access unimportant.    throwAway: PROCESS ¬ FORK SwapOutProcess[];  -- (no profit in detaching.)    swapOutProcesses ¬ swapOutProcesses + 1};  InstallTransferWatcher: PUBLIC --VMPerf.-- PROCEDURE [    newTransferWatcher: VMPerf.TransferWatcher]    RETURNS [prevTransferWatcher: VMPerf.TransferWatcher] = {    -- We don't make this an ENTRY proc because the expected probability    -- of concurrent access is thought to be infinitesimal    -- and the consequences of such access unimportant.    prevTransferWatcher ¬ transferWatcher;    transferWatcher ¬ newTransferWatcher};  SetBatchCount: PUBLIC --VMPerf.-- PROCEDURE [batchCount: VMPerf.BatchCount]    RETURNS [oldBatchCount: VMPerf.BatchCount] =    -- We don't make this an ENTRY proc because the expected probability    -- of concurrent access is thought to be infinitesimal    -- and the consequences of such access unimportant.    BEGIN    oldBatchCount ¬ maxTransferPages;    maxTransferPages ¬ VMPerf.BatchCount[      Inline.LowHalf[	MIN[	  LAST[VMPerf.BatchCount], SwapBuffer.maxBufferSize,	  MAX[1, batchCount]]]];    END;  --~~~~~~~~~~~~~~~ SpecialRuntime Operations: ~~~~~~~~~~~~~~~      -- Routines to find the enclosing swapunit for a procedure, global frame etc  -- Note that GetSwapUnitAttributes is not quite correct because Pilot can  -- add swap unit boundaries over and above those specified by the user.  -- Therefore we have to search the start list (in case the object was in  -- the bootfile) and if not found there, try the load state (if the runtime  -- loader is present).    GetSwapUnitsForCatchCode:    PUBLIC --SpecialRuntime-- PROCEDURE [proc: --GENERIC-- PROC]    RETURNS [interval: VM.Interval, swappability:VM.Swappability,       changeableSwappability: BOOLEAN] =    {RETURN GetSwapUnitsInternal[      frame: Runtime.GlobalFrame[LOOPHOLE[proc]],      pointer: SpecialRuntime.Catch[LOOPHOLE[proc]]]};			   GetSwapUnitsForEntryVector:    PUBLIC --SpecialRuntime-- PROCEDURE [proc: --GENERIC-- PROC]    RETURNS [interval: VM.Interval, swappability:VM.Swappability,       changeableSwappability: BOOLEAN] =    {RETURN GetSwapUnitsInternal[      frame: Runtime.GlobalFrame[LOOPHOLE[proc]],       pointer: SpecialRuntime.EntryVector[LOOPHOLE[proc]]]};			   GetSwapUnitsForGlobalFrame:    PUBLIC --SpecialRuntime-- PROCEDURE [frame: --GENERIC-- PROGRAM]    RETURNS [interval: VM.Interval, swappability:VM.Swappability,       changeableSwappability: BOOLEAN] =    {RETURN GetSwapUnitsInternal[      frame: frame, pointer: LOOPHOLE[frame, LONG POINTER]]};    GetSwapUnitsForProcedure:    PUBLIC --SpecialRuntime-- PROCEDURE [proc: --GENERIC-- PROC]    RETURNS [interval: VM.Interval, swappability:VM.Swappability,       changeableSwappability: BOOLEAN] =    {RETURN GetSwapUnitsInternal[      frame: Runtime.GlobalFrame[LOOPHOLE[proc]],       pointer: SpecialRuntime.Code[LOOPHOLE[proc]]]};			   GetSwapUnitsInternal: PROCEDURE [frame: PROGRAM, pointer: LONG POINTER]     RETURNS [interval:VM.Interval, swappability:VM.Swappability,      changeableSwappability: BOOLEAN] =    BEGIN    page:Environment.PageNumber ¬ Environment.PageFromLongPointer[pointer];    found:BOOLEAN;        CheckStartListEntry: StoragePrograms.StartListProc --[pEntry]done-- =      BEGIN      -- other parameter: page;        -- other results:  found, interval, swappability, changeableSwappability      WITH e:pEntry SELECT FROM        swapUnit =>	  BEGIN	  interval ¬ [	    page: StoragePrograms.startList[e.parent].vmpage+e.base,	    count: e.pages];          IF page IN [interval.page..interval.page+interval.count)	  THEN {found ¬ TRUE;	        IF e.info.state=swappable		THEN 		-- Note that GetSwapUnitsFor... might be called		-- before swappable stuff in startlist has been mapped.		-- In this case, we know it must still be swappable because		-- no-one has had a chance to change it yet		     {i: VM.Interval;		      [swapUnit: i, swappability: swappability] ¬ 		      	VM.GetSwapUnitAttributes[page]; 		      IF i=VM.nullInterval THEN swappability ¬ swappable;		      changeableSwappability ¬ TRUE}		ELSE {swappability ¬ resident;		      changeableSwappability ¬ FALSE}};	  END;	space, stop => NULL;	ENDCASE => Bug[impossibleEndcase];      RETURN [done:found];      END;  --CheckStartListEntry--        -- Begin main text of GetSwapUnitsInternal:    found ¬ FALSE;    StoragePrograms.EnumerateStartList[CheckStartListEntry];      IF NOT found THEN      BEGIN      IF Runtime.IsBound[LOOPHOLE[RuntimeInternal.GetSwapUnitsFromLoadedBcd]] THEN         [interval, swappability, changeableSwappability] ¬          RuntimeInternal.GetSwapUnitsFromLoadedBcd[	    SpecialRuntimeExtras.GlobalFrameFromProgram[frame], page]      ELSE {        [swapUnit: interval, swappability: swappability] ¬ 	  VM.GetSwapUnitAttributes[page];        changeableSwappability ¬ TRUE};      END;    END;  --~~~~~~~~~~~~~~~ VM Data Transfer and Mapping Operations: ~~~~~~~~~~~~~~~  -- TYPEs for ProcessBatches:<<  ProcessBatchProc: TYPE = PROCEDURE [pOpData: POINTER TO OpData]    RETURNS [      newState: VMData.NewState ¬ VMData.noStateChange, changeInterval: Interval]; **>>  -- Other parameters in pOpData­: checkOutData especially .activeInterval and .processType.   -- Other results in pOpData­: error, and ioInterval may have been changed.   -- Examines the pages in activeInterval, possibly doing non-I/O things and/or I/O to them.  -- On return, the results are examined in the order given below and processed as described.  --    If pOpData.error # [noError[]], then ProcessBatches will terminate its processing immediately and return to its caller.  --    IoInterval represents the subinterval of activeInterval which has been processed; pages of activeInterval folowing the end of ioInterval still require processing. (Special case: ioInterval.count=0 is a shorthand way of saying ioInterval=activeInterval.) Now there are two cases:  --      If ioInterval.page+ioInterval.count < activeInterval.page+activeInterval.count, then there is more of activeInterval to be processed. If changeInterval.count>0 and newState # noStateChange, ProcessBatches will remember changeInterval and newState as an interval whose status needs to be changed. ProcessBatches will then adjust activeInterval to be just the remainder of activeInterval which follows ioInterval, and immediately call ProcessBatchProc again.  --      Else ioInterval.page+ioInterval.count = activeInterval.page+activeInterval.count. All of activeInterval has been processed. If changeInterval.count>0 and newState # noStateChange, ProcessBatches will remember changeInterval as an interval whose status needs to be changed. The interval checked out will be checked in. If the staus of any interval needs to be changed, the changeInterval is the smallest interval which contains all of the intervals which have been designated to be changed, and the newState is the last newState returned by ProcessBatchProc for which changeInterval.count>0 and newState # noStateChange.  -- Stylistic Note for programming ProcessBatchProc's: Since a ProcessBatchProc has lots of defaulted return parameters, you will generate shorter code by saying {changeInterval ¬ foo; RETURN}, rather than RETURN[changeInterval: foo]. By careful ordering of the code that sets the return values, cross jumping can also be effectively utilized.<<  ProcessBatchesOptions: TYPE = RECORD [    unmappedProcessing: {skipUnmapped, errorIfUnmapped},    intervalOrSwapUnits: {swapUnitsIncludingInterval, exactInterval},    checkInOption: {checkIn, leaveCheckedOut}]; **>>  ProcessBatches: PUBLIC --**VMInternal.**-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval,    options: VMInternal.ProcessBatchesOptions,     processBatchProc: VMInternal.ProcessBatchProc] =    -- Other parameters in pOpData­: checkOutData.processType.    -- Other results in pOpData­: error.    -- Walks through through interval, checking out limited-length subintervals "batches" of its mapped intervals, presenting them to processBatchProc for processing, then checking the subinterval in with any new attributes returned by processBatchProc.    -- See the definitions of ProcessBatchProc for more details, particularly on the fields in pOpData which are available to it.    -- DETAILS AND EXCEPTIONS:    -- If options.intervalOrSwapUnits=exactInterval, the activeInterval passed to processBatchProc will be those pages of the checked out swap units which are also in "interval".    -- If options.intervalOrSwapUnits=swapUnitsIncludingInterval, activeInterval will be = intervalCheckedOut.    -- If options.unmappedProcessing=errorIfUnmapped and an unmapped portion of interval is found, sets error to [spaceError[notMapped]] and exits.    -- If options.checkInOption=leaveCheckedOut, the swap units of each batch will be left checked out at completion of processing of the batch.    BEGIN OPEN pOpData, pOpData.checkOutData;    changeInterval, intervalRequested, totalChangeInterval: Interval;    newState: VMData.NewState;    totalNewState: VMData.NewState;    pageBatch: PageNumber ¬ interval.page;    pageBatchEnd: PageNumber = interval.page + interval.count;    WHILE pageBatch < pageBatchEnd DO      -- Begin processing at new pageBatch:      -- We either find some pages not requiring action and advance past them, or find some requiring action and take that action.      -- Checkout next batch from the remaining mapped portion of interval:      -- Note that limiting the intervalRequested.count here still allows a      --    batch of more than maxTransferPages if swapUnitsIncludingInterval.      intervalRequested ¬ [	pageBatch, MIN[maxTransferPages, pageBatchEnd - pageBatch]];      VMData.CheckOutSwapUnits[	pResult: @checkOutData, interval: intervalRequested];      IF intervalCheckedOut.count = 0 THEN	-- All of intervalRequested is unmapped (& thus not checked out).	SELECT options.unmappedProcessing FROM	  errorIfUnmapped => 	    BEGIN	    error ¬ [spaceError[notMapped]];	    GOTO Error;	    END;	  skipUnmapped =>  -- step pageBatch past it.	    pageBatch ¬ pageBatch + intervalRequested.count;	  ENDCASE => Bug[funnyCase]      ELSE	BEGIN  --intervalCheckedOut.count > 0--	tmpCheckedOutIntervalEnd: Environment.PageNumber; --**	IF intervalCheckedOut.page > pageBatch	  AND options.unmappedProcessing = errorIfUnmapped THEN	  {error ¬ [spaceError[notMapped]]; GOTO Error}	ELSE pageBatch ¬ intervalCheckedOut.page;	tmpCheckedOutIntervalEnd ¬ 	  intervalCheckedOut.page + intervalCheckedOut.count; --**	IF options.intervalOrSwapUnits = swapUnitsIncludingInterval THEN {	  -- NOTE: In this case, pageBatch may be less than activeInterval.page.	  activeInterval ¬ intervalCheckedOut;	  activeIntervalEnd ¬ tmpCheckedOutIntervalEnd} --**	ELSE { --** options.intervalOrSwapUnits = exactInterval	  IF tmpCheckedOutIntervalEnd < pageBatchEnd THEN {	    activeIntervalEnd ¬ tmpCheckedOutIntervalEnd;	    activeInterval.count ¬ activeIntervalEnd - activeInterval.page}};	totalChangeInterval ¬ [page: activeIntervalEnd, count: 0];	totalNewState ¬ VMData.noStateChange;	ioInterval.count ¬ 1; -- to start up the following loop	UNTIL ioInterval.count = 0 OR activeInterval.page >= activeIntervalEnd DO	  [newState, changeInterval] ¬ processBatchProc[pOpData];	  IF newState # VMData.noStateChange AND changeInterval.count > 0 THEN	    BEGIN	    totalNewState ¬ newState;	    totalChangeInterval.page ¬ MIN[	      totalChangeInterval.page, changeInterval.page];	    totalChangeInterval.count ¬	      (changeInterval.page + changeInterval.count) -	      totalChangeInterval.page;	    END;	  IF error # [noError[]] THEN GOTO Error;	  activeInterval.page ¬ ioInterval.page + ioInterval.count;	  -- Note that if ioInterval.count=0 then ioInterval.page is undefined.	  activeInterval.count ¬ activeIntervalEnd - activeInterval.page;	  ENDLOOP;	pageBatch ¬ activeIntervalEnd;	END;  --intervalCheckedOut.count > 0--      batches ¬ batches + 1;      IF options.checkInOption = checkIn THEN	VMData.CheckInSwapUnits[	  pResult: @checkOutData, changeInterval: totalChangeInterval,	  newState: totalNewState, pageReadIn: pageReadIn];      REPEAT  --pageBatch < pageBatchEnd--	Error =>	  VMData.CheckInSwapUnits[  -- ok even if not checked out.	    pResult: @checkOutData, changeInterval: VM.nullInterval, pageReadIn: pageReadIn];      ENDLOOP;  --pageBatch < pageBatchEnd--    END;  --ProcessBatches--  Activate: PUBLIC PROCEDURE [interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    opData: OpData;    EnterVM[@opData, interval];    IF returnWait = return THEN EnqueueOperation[interval, [activate[]]]    ELSE  --returnWait=wait--      ActivateSynchronous[@opData, interval];    ExitVM[@opData];    END;  ActivateSynchronous: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval] =     BEGIN          ActivateBatch: ProcessBatchProc =  --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      BEGIN      pOpData.ioInterval ¬ IntervalRequiringInput[pOpData];      IF pOpData.ioInterval.count = 0 THEN RETURN;      ReadUsingBuffer[pOpData];      END; --ActivateBatch--    Pinning.Pin[activatePin];    ProcessBatches[      pOpData, interval, [skipUnmapped, exactInterval, checkIn],      ActivateBatch];    Pinning.Unpin[activatePin];    END; --Activate--  CopyIn: PUBLIC PROCEDURE [    interval: VM.Interval, transferProc: BackingStore.TransferProc,    run: BackingStore.Run, returnWait: VM.ReturnWait] =    BEGIN    opData: OpData;    IF run.count < interval.count THEN ERROR Space.Error[invalidParameters];    EnterVM[@opData, interval];    IF returnWait = return THEN      EnqueueOperation[interval, [copyIn[transferProc, run.data]]]    ELSE  --returnWait=wait--      CopyInSynchronous[@opData, interval, transferProc, run.data];    ExitVM[@opData];    END;  --CopyIn--  CopyInSynchronous: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval,    transferProcIn: BackingStore.TransferProc, dataIn: BackingStore.Data] =    -- Other parameters in pOpData­: checkOutData.processType.    BEGIN    CopyInBatch: ProcessBatchProc =  --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      -- Other parameters: transferProcIn, dataIn of parent frame.      -- NOTE: Overwrites checkout data in pOpData­!      BEGIN OPEN pOpData, pOpData.checkOutData;      IF state.access = readOnly THEN {error ¬ [spaceError[readOnly]]; RETURN};      ioInterval ¬ activeInterval;      pageRun ¬ interval.page;      backingData ¬ dataIn;      transferProc ¬ transferProcIn;      SELECT state.swappability FROM	resident => {	  -- Note that the microcode marks the pages dirty, which is just what is wanted.	  IOTransfer[pOpData, read, in, unbuffered, unBufferedOrHeadedOut]};	swappable => {	  MStore.Deallocate[ioInterval, notPromised];  -- recover any mem now in interval.	  ReadUsingBuffer[pOpData, andMarkDirty]};	ENDCASE => Bug[funnyCase];      END;  --CopyInBatch--    -- Begin main text of CopyInSynchronous:    ProcessBatches[      pOpData, interval, [errorIfUnmapped, exactInterval, checkIn],      CopyInBatch];    END;  --CopyInSynchronous--  CopyOut: PUBLIC PROCEDURE [    interval: VM.Interval, transferProc: BackingStore.TransferProc,    run: BackingStore.Run, returnWait: VM.ReturnWait] =    BEGIN    opData: OpData;    IF run.count < interval.count THEN ERROR Space.Error[invalidParameters];    EnterVM[@opData, interval];    IF returnWait = return THEN      EnqueueOperation[interval, [copyOut[transferProc, run.data]]]    ELSE  --returnWait=wait--      CopyOutSynchronous[@opData, interval, transferProc, run.data];    ExitVM[@opData];    END;  --CopyOut--  CopyOutSynchronous: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval,    transferProcOut: BackingStore.TransferProc, dataOut: BackingStore.Data] =    -- Other parameters in pOpData­:checkOutData.processType.    BEGIN    CopyOutBatch: ProcessBatchProc =  --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      -- Other parameters: transferProcOut, dataOut of parent frame.      -- NOTE: Overwrites checkout data after all input is finished!      BEGIN OPEN pOpData, pOpData.checkOutData;      -- We don't use ProcessBatches' facilities for looping here because we need to make two passes through activeInterval.            DO -- First make sure all of activeInterval is swapped in.        ioInterval ¬ IntervalRequiringInput[pOpData];        IF ioInterval.count = 0 THEN EXIT        ELSE          BEGIN          << Could write out any swapped in prefix of activeInterval here.             The present implementation uses fewer I/O operations but more memory.             ASSERT: At least the first page of ioInterval is alive             and all of its pages are swapped out.	   >>          ReadUsingBuffer[pOpData]          END;	ENDLOOP;            -- ASSERT: All of activeInterval is swapped in.            ioInterval ¬ activeInterval;      -- (May only overwrite checkout data after all input is finished!)      pageRun ¬ interval.page;      backingData ¬ dataOut;      transferProc ¬ transferProcOut;      IOTransfer[pOpData, write, in, unbuffered, unBufferedOrHeadedOut];      END;  --CopyOutBatch--    -- Begin main text of CopyOutSynchronous:    ProcessBatches[      pOpData, interval, [errorIfUnmapped, exactInterval, checkIn],      CopyOutBatch];    END;  --CopyOutSynchronous--  Deactivate: PUBLIC PROCEDURE [    interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    opData: OpData;    EnterVM[@opData, interval];    IF returnWait = return THEN EnqueueOperation[interval, [deactivate[]]]    ELSE  --returnWait=wait--      DeactivateSynchronous[@opData, interval];    ExitVM[@opData];    END;  DeactivateSynchronous: PUBLIC PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval] =    BEGIN          DeactivateBatch: ProcessBatchProc = --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      {RETURN DeactivateOrUnmapBatch[pOpData, deactivate]};    Pinning.Pin[deactivatePin];    ProcessBatches[      pOpData, interval, [skipUnmapped, exactInterval, checkIn],      DeactivateBatch];    Pinning.Unpin[deactivatePin];    END; --Deactivate--  DeactivateOrUnmapBatch: PROCEDURE [    pOpData: POINTER TO OpData, operation: {deactivate, unmap}]    RETURNS [  --identical to ProcessBatchProc--      newState: VMData.NewState ¬ VMData.noStateChange, changeInterval: Interval] =    BEGIN OPEN pOpData, pOpData.checkOutData;    SELECT operation FROM      deactivate => IF state.swappability = resident THEN { ioInterval.count ¬ 0; RETURN};      unmap      => {        -- Clear possible patches from the interval to be unmapped        ClearPatches[activeInterval.page, VMPerf.BatchCount[activeInterval.count]];	IF transferProc = NIL THEN {	  MStore.Deallocate[activeInterval, notPromised];          ioInterval.count ¬ 0;          RETURN};}      ENDCASE    => Bug[impossibleEndcase];    -- To be polite, we free up any clean memory first.    [] ¬ DeallocateMStoreIfClean[activeInterval];    ioInterval ¬ IntervalRequiringOutput[pOpData, unchangedAccess];    IF ioInterval.count = 0 THEN RETURN    ELSE      BEGIN      -- ASSERT: All of the pages of ioInterval are swapped in and the first (at least) is dirty.      buffer ¬ SwapBuffer.Allocate[ioInterval.count, willTakeLess];      IF buffer.count < ioInterval.count THEN {	-- We mark any excess back to dirty, so that IntervalRequiringOutput	-- will find it so next time around the loop.	[] ¬ MStore.RelocateAdjustingFlags[	  interval: [	  ioInterval.page + buffer.count, ioInterval.count - buffer.count],	  pageDest: ioInterval.page + buffer.count, flagsKeep: PageMap.maskNotDirty,	  flagsAdd: PageMap.flagsDirty];	ioInterval.count ¬ buffer.count};      [] ¬ MStore.RelocateAdjustingFlags[	interval: ioInterval, pageDest: buffer.page,	flagsKeep: maskNone, flagsAdd: flagsReadOnly];      IOTransfer[pOpData, write, out, buffered, unBufferedOrHeadedOut];      SwapBuffer.Deallocate[buffer];      changeInterval ¬ ioInterval;      newState ¬ [newLife: [setTo[alive]]];      RETURN;      END;    END;  --DeactivateOrUnmapBatch--  ForceOut: PUBLIC PROCEDURE [interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    opData: OpData;    EnterVM[@opData, interval];    IF returnWait = return THEN EnqueueOperation[interval, [forceOut[]]]    ELSE  --returnWait=wait--      ForceOutSynchronous[@opData, interval];    ExitVM[@opData];    forceOuts ¬ forceOuts + 1;    END;  ForceOutSynchronous: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval] =    BEGIN          ForceOutBatch: ProcessBatchProc =  --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      BEGIN OPEN pOpData, pOpData.checkOutData;      IF transferProc = NIL THEN ioInterval.count ¬ 0      ELSE        BEGIN        ioInterval ¬ IntervalRequiringOutput[pOpData, unchangedAccess];	IF ioInterval.count # 0 THEN	  BEGIN	  -- Since we mark the pages clean, then write them out, there is a window in which the user can dirty the page before it is written to the disk. In this case the data will be up-to-date on the disk but the page marked dirty; so it will be written again later "spuriously".	  -- ASSERT: All of the pages of ioInterval are swapped in and the first (at least) is dirty.	  IOTransfer[pOpData, write, in, unbuffered, unBufferedOrHeadedOut];	  changeInterval ¬ ioInterval;	  newState ¬ [newLife: [setTo[alive]]];	  END;        END;      END; --ForceOutBatch--    Pinning.Pin[forceOutPin];    ProcessBatches[      pOpData, interval, [skipUnmapped, exactInterval, checkIn],      ForceOutBatch];    Pinning.Unpin[forceOutPin];    END; --ForceOut--  GetSwapUnitAttributes: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [      swapUnit: VM.Interval, access: Space.Access, life: Space.Life,      swappability: VM.Swappability] =    BEGIN    opData: OpData;    EnterVM[@opData, [page, 1]];    VMData.CheckOutSwapUnits[pResult: @opData.checkOutData, interval: [page, 1]];    VMData.CheckInSwapUnits[  -- ok even if intervalCheckedOut.count = 0      pResult: @opData.checkOutData, changeInterval: VM.nullInterval, pageReadIn: opData.pageReadIn];    ExitVM[@opData];    RETURN[      swapUnit: opData.checkOutData.intervalCheckedOut,  -- = VM.nullInterval if not mapped.      access: opData.checkOutData.state.access,      life: opData.checkOutData.state.life,      swappability: opData.checkOutData.state.swappability];    END;  --GetSwapUnitAttributes--  Map: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [    interval: VM.Interval, transferProc: BackingStore.TransferProc,    backingStoreRuns: VM.BackingStoreRuns, usage: Space.Usage, class: Space.Class,    access: Space.Access, swapUnits: Space.SwapUnitOption,    life: Space.Life, swappability: VM.Swappability] =    BEGIN    mapStart: System.Pulses = System.GetClockPulses[];    mapParams: VMData.MapParams;    IF interval.count = 0 OR      (swappability = resident AND transferProc = NIL AND access = readOnly) THEN      ERROR Space.Error[invalidParameters];    IF swappability = swappable AND transferProc = NIL THEN      ERROR Space.Error[noWindow];    mapParams ¬ [      interval, transferProc, backingStoreRuns, usage,      class, access, swapUnits,      IF swappability = resident AND transferProc = NIL THEN dead  -- ASSERT: is readWrite      ELSE IF access = readOnly THEN alive ELSE life];    DO  --until all elements of backingStoreRuns and swapUnits.sizes are swapped in--      priorityPrev: Process.Priority = VMInternal.GuardStateVector[];      paramsSwapStatus: VMData.ParamsSwapStatus = VMData.CreateMapUnit[@mapParams];      VMInternal.DoneWithStateVector[priorityPrev];  -- (page faults allowed again.)      --UNTIL--IF paramsSwapStatus = ok THEN EXIT;      -- Touch all of backingStoreRuns and swapUnits.sizes to get them swapped in:      FOR k: CARDINAL IN [0..LENGTH[backingStoreRuns]) DO	-- IF YOU ADDRESS FAULT HERE, it is because the backingStoreRuns (that you,	-- the caller of VM, passed in) is not entirely mapped storage. Tsk, tsk.	throwAway: BackingStore.Run ¬ backingStoreRuns[k]; ENDLOOP;      WITH s: swapUnits SELECT FROM	irregular =>	  FOR k: CARDINAL IN [0..LENGTH[s.sizes]) DO	    throwAway: Space.SwapUnitSize ¬ s.sizes[k]; ENDLOOP;	ENDCASE => NULL;      ENDLOOP;  --until all swapped in--    -- ASSERT: The map unit has been created.    IF swappability = resident THEN SetSwappability[interval, resident, wait];    maps ¬ maps + 1;    mapPulses ¬ [(System.GetClockPulses[] - mapStart) + mapPulses];    END;  --Map--  PageFaultProcess: PUBLIC --VMInternal.-- PROCEDURE =    BEGIN    -- This logic below depends on the fact that we only read data from a single swap unit.    -- Runs at special priority and so always has state vector guarded.    -- Reserved memory note: If the fault is from a helper process, any reserved memory already present in the swap unit is serving its precise purpose - that of keeping a helper process happy.  [there's a problem here...]    opData: OpData;    BEGIN OPEN opData, opData.checkOutData;    ioErrAction: IOErrorContinuation;    MyIOErrorHandler: IOErrorHandler = {  --[error] RETURNS [continuation]--      -- Other results: ioErrAction of parent frame.      RETURN[ioErrAction ¬ HandleVMIOError[error].continuation]};    pageFaulted: PageNumber;    selfDestruct: BOOLEAN;    jobStart: System.Pulses;    reportRestart: PageFault.ReportRestart ¬ --NULL-- restart;    opData.ioErrorHandler ¬ MyIOErrorHandler;    ProcessInternal.SetPriority[priorityPageFaultLow];    -- State vector is now guarded.    PageFault.PageFaultProcessStarted[];    process ¬ NIL;  -- no faulted process to restart yet.    -- reportRestart ¬ NULL;  ++ value is meaningless when process = NIL.    DO  --UNTIL services no longer required--      [pageFaulted, --processFaulted:-- process, processType, selfDestruct] ¬	PageFault.RestartAndAwaitNext[ --restart:-- process, reportRestart, wait];      --UNTIL-- IF selfDestruct THEN EXIT;  -- goodbye forever.      jobStart ¬ System.GetClockPulses[];      ioErrAction ¬ pressOn;  -- the normal case.      intervalCheckedOut.count ¬ 0;  -- i.e. no interval checked out yet.      BEGIN  --scope of CheckIn--	IF pageFaulted >= StoragePrograms.countVM THEN	  {reportRestart ¬ reportAddressFault; GOTO CheckIn};	VMData.CheckOutSwapUnits[@checkOutData, [pageFaulted, 1]];	buffer.count ¬ 0;  -- no buffer yet.	IF intervalCheckedOut.count = 0 THEN	  {reportRestart ¬ reportAddressFault; GO TO CheckIn}	ELSE	  BEGIN  --mapped page--	    reportRestart ¬ restart;	    IF PageMap.IsMapped[pageFaulted] THEN GO TO CheckIn;  -- came in since fault.	    ioInterval.page ¬ pageFaulted;	    ioInterval.count ¬ 1;	    -- determine which pages adjacent to faulted one are In:	    FOR pageFollowing: PageNumber IN	      (ioInterval.page..intervalCheckedOut.page + intervalCheckedOut.count)	      WHILE ioInterval.count < SwapBuffer.maxBufferSize	      AND PageMap.IsVacant[pageFollowing] DO	      ioInterval.count ¬ ioInterval.count + 1;	      ENDLOOP;	    FOR pagePreceeding: PageNumber DECREASING IN	      [intervalCheckedOut.page..ioInterval.page)	      WHILE ioInterval.count < SwapBuffer.maxBufferSize	      AND PageMap.IsVacant[pagePreceeding] DO	      ioInterval.count ¬ ioInterval.count + 1;	      ioInterval.page ¬ ioInterval.page - 1;	      ENDLOOP;	    -- The faulted page will get read in..	    -- and all adjacent swapped out pages which fit in buffer:	    buffer ¬ SwapBuffer.Allocate[	      ioInterval.count, GetSizeRequirement[processType]];	    IF state.life = dead THEN {ReadDead[@opData, ioInterval]; GOTO FreeBufferAndCheckIn}	    ELSE	      BEGIN  --alive--	      AllocateRealMemory[	        interval: [page: buffer.page, count: ioInterval.count],	        processType: processType, resident: (state.swappability = resident)];	      IOTransfer[  -- may set ioErrAction=hangProcess.	        @opData, read, in, buffered, [	        access: state.access, dirty: FALSE, referenced: FALSE]];	      SwapBuffer.Deallocate[buffer];	      pageFaultInputs ¬ pageFaultInputs + 1;	      pageFaultPagesInput ¬ pageFaultPagesInput + ioInterval.count;	      SELECT ioErrAction FROM	        hangProcess => {process ¬ NIL; GOTO CheckIn};  -- i.e. don't restart faulted process.	        pressOn => GOTO CheckIn;	        ENDCASE => Bug[funnyCase];	      -- ASSERT: Can't get here.	      END;  --alive--	  EXITS	    FreeBufferAndCheckIn => {SwapBuffer.Deallocate[buffer]; GOTO CheckIn};	  END;  --mapped page--      EXITS CheckIn => NULL;      END;  --scope of CheckIn--      VMData.CheckInSwapUnits[  -- (doesn't change status, noop if none checked out)	  pResult: @checkOutData, changeInterval: VM.nullInterval, pageReadIn: pageReadIn];      pageFaults ¬  pageFaults + 1;      pageFaultPulses ¬ [(System.GetClockPulses[] - jobStart) + pageFaultPulses];      ENDLOOP;  --UNTIL services no longer required--    -- Must release state vector since process destruction is a swappable facility.    ProcessInternal.SetPriority[ProcessPriorities.priorityClientHigh];      END;  --OPEN--    END;  --PageFaultProcess--  --(process disappears)  Relocate: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [    from: Environment.PageNumber, to: Environment.PageNumber] =    -- We serialize Unmaps and Relocates because there is    --   a critical region in Unmap which Relocate could interfere with.    -- This calls the entry procedure so the code won't sit and wait    --   for a state vector while holding the monitor lock.    BEGIN          RelocateEntry: ENTRY PROCEDURE [      from: Environment.PageNumber, to: Environment.PageNumber] =      BEGIN ENABLE ANY => Bug[unexpectedSignal];      VMData.RelocateMapUnit[from: from, to: to];      END;    priorityPrev: Process.Priority ¬ GuardStateVector[];    Pinning.Pin[relocatePin];    RelocateEntry[from: from, to: to];    DoneWithStateVector[priorityPrev];    Pinning.Unpin[relocatePin];    END; --Relocate--      SetAccess: PUBLIC PROCEDURE [interval: VM.Interval, access: Space.Access] =    BEGIN    requestedAccess: Space.Access = access;  -- avoid name collision with checkOutData.state.access.    -- Programming Note: Due to the ambiguity between the argument    -- named access and the OPENed opData.checkOutData.access,    -- DO NOT use the simple identifier "access" in this procedure!    SetAccessBatch: ProcessBatchProc =  --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      -- Additional parameters: requestedAccess of parent frame.      BEGIN OPEN pOpData, pOpData.checkOutData;      IF requestedAccess # checkOutData.state.access THEN -- want access changed	SELECT requestedAccess FROM	  readOnly =>	    SELECT state.swappability FROM	      swappable =>		BEGIN  --swappable readWrite going to readOnly--		ioInterval ¬ IntervalRequiringOutput[pOpData, makeReadOnly];		IF ioInterval.count > 0 THEN		  BEGIN		  -- ASSERT: All of the pages of ioInterval are swapped in,		  -- swappable, and the first (at least) is dirty.		  IOTransfer[		    @opData, write, in, unbuffered, unBufferedOrHeadedOut];		  IF ioInterval.page + ioInterval.count < activeIntervalEnd THEN		    RETURN; -- (status is changed when batch completely processed)		  END;		-- ASSERT: Swapped-in pages of intervalCheckedOut are clean and readonly.		newState ¬ [		  newAccess: [setTo[readOnly]], newLife: [setTo[alive]]];		END;  -- swappable readWrite going to readOnly --	      resident =>		BEGIN  -- resident readWrite going to readOnly --		-- In general, we can't write resident intervals out to clean them		-- because their backing storage may be NIL.		FOR page: PageNumber IN [activeInterval.page..activeIntervalEnd)		  DO		  flagsPrev: PageMap.Flags = PageMap.ExchangeFlags[		    page, flagsReadOnly].oldState.flags;		  IF flagsPrev.dirty THEN		    -- For clean, we bypass getting ref'd bit accurate since not swappable anyway.		    [] ¬ PageMap.ExchangeFlags[		      page, PageMap.flagsReadOnlyDirtyReferenced];		  ENDLOOP;		newState ¬ [		  newAccess: [setTo[readOnly]], newLife: [setTo[alive]]];		END;  --resident writable going to readOnly--	      ENDCASE => Bug[funnyCase];	  readWrite =>	    BEGIN  -- readOnly going to readWrite --	    FOR page: PageNumber IN [activeInterval.page..activeIntervalEnd) DO	      IF PageMap.IsMapped[page] THEN		BEGIN  --in--		  flags: PageMap.Flags;		  newFlags: PageMap.Flags ¬ [		    readonly: FALSE, dirty: --must assume--FALSE,		    referenced: --must assume--FALSE];		  -- Clear readonly while maintaining dirty and referenced:		  DO  --UNTIL ref'd and dirty bits are set right--		    flags ¬ PageMap.ExchangeFlags[page, newFlags].oldState.flags;		    --UNTIL-- IF flags = newFlags THEN EXIT;		    newFlags.dirty ¬ newFlags.dirty OR flags.dirty;		    newFlags.referenced ¬ newFlags.referenced OR flags.referenced;		    ENDLOOP;		END;  --in--	      ENDLOOP;	    newState ¬ [newAccess: [setTo[readWrite]], newLife: [unchanged[]]];	    END;  --readOnly going to readWrite--	  ENDCASE => Bug[funnyCase];      changeInterval ¬ intervalCheckedOut;      ioInterval.count ¬ 0;      RETURN;      END;  --SetAccessBatch--    -- Begin main text of SetAccess:    opData: OpData;    Pinning.Pin[setAccessPin];    EnterVM[@opData, interval];    ProcessBatches[      @opData, interval, [skipUnmapped, swapUnitsIncludingInterval, checkIn],      SetAccessBatch];    ExitVM[@opData];    Pinning.Unpin[setAccessPin];    END;  --SetAccess--  SetSwappability: PUBLIC PROCEDURE [    interval: VM.Interval, swappability: VM.Swappability,    returnWait: VM.ReturnWait] =    BEGIN    opData: OpData;    EnterVM[@opData, interval];    IF returnWait = return THEN      EnqueueOperation[interval, [setSwappability[swappability]]]    ELSE  --returnWait=wait--      SetSwappabilitySynchronous[@opData, interval, swappability];    ExitVM[@opData];    END;  SetSwappabilitySynchronous: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: Interval,    requestedSwappability: VM.Swappability] =    -- NOTE: The argument is named requestedSwappability to avoid a name collision with the OPENed checkOutData.state.swappability.    BEGIN    SetSwappabilityBatch: ProcessBatchProc =  --[pOpData]--      -- RETURNS [changeInterval, newState¬noStateChange]      -- Additional parameters: requestedSwappability of parent frame.      BEGIN OPEN pOpData, pOpData.checkOutData;      IF requestedSwappability # checkOutData.state.swappability THEN	SELECT requestedSwappability FROM	  resident =>	    BEGIN  --swappable going to resident--	    ioInterval ¬ IntervalRequiringInput[pOpData];	    IF ioInterval.count > 0 THEN ReadUsingBuffer[pOpData];	    MStore.RelocatePCMemory[activeInterval];	    newState ¬ [newSwappability: [setTo[resident]]];	    changeInterval ¬  -- (status actually changed only when finished with interval.)	      intervalCheckedOut;	    RETURN;	    END;  --swappable going to resident--	  swappable =>	    BEGIN  --resident going to swappable--	    IF transferProc = NIL THEN	      {error ¬ [spaceError[noWindow]]; RETURN};	    IF state.access = readOnly THEN	      BEGIN  --clean any dirty pages--	      ioInterval ¬ IntervalRequiringOutput[pOpData, makeReadOnly];	      IF ioInterval.count > 0 THEN		BEGIN		-- ASSERT: All of the pages of ioInterval are swapped in, swappable, and the first (at least) is dirty.		IOTransfer[pOpData, write, in, unbuffered, unBufferedOrHeadedOut];		IF ioInterval.page + ioInterval.count < activeIntervalEnd THEN		  RETURN; -- status changed when whole batch is clean.		END;	      END;	    newState ¬ [newSwappability: [setTo[swappable]]];	    changeInterval ¬ intervalCheckedOut;	    END;  --resident going to swappable--	  ENDCASE => Bug[funnyCase];      ioInterval.count ¬ 0;      END;  --SetSwappabilityBatch--    -- Begin main text of SetSwappability:    ProcessBatches[      pOpData, interval, [skipUnmapped, swapUnitsIncludingInterval, checkIn],      SetSwappabilityBatch];    END;  --SetSwappability--  SwapOutProcess: PROCEDURE =    BEGIN    -- Priority management: A SwapOutProcess runs at priorityPageFaultLow while it is deciding how much it will swap out; when it decides, it boosts its priority to priorityPageFaultHigh, informs MStore of the amount - which may wake up another SwapOutProcesses (which is running at priorityPageFaultLow), and then gets the output operation started. Its priority is lowered when the I/O completes. This expedites getting the first output operation started as soon as possible - the second SwapOutProcess will compute during the I/O wait time.    -- Runs at special priority and so always has state vector guarded.    opData: OpData;  -- (opData.checkOutData.state.access, .life, and .swappability are garbage.)    BEGIN OPEN opData, opData.checkOutData;    ioErrAction: IOErrorContinuation;    MyIOErrorHandler: IOErrorHandler = {  --[error] RETURNS [continuation]--      -- Other results: ioErrAction of parent frame.      RETURN[ioErrAction ¬ HandleVMIOError[error].continuation]};    pagesNeeded: PageCount;    jobStart: System.Pulses;    ProcessInternal.SetPriority[priorityPageFaultLow];    opData.ioErrorHandler ¬ MyIOErrorHandler;    opData.process ¬ ProcessInternal.GetCurrent[];    DO  --FOREVER--      pagesNeeded ¬ MStore.AwaitBelowThreshold[];  -- wait until memory gets short..      jobStart ¬ System.GetClockPulses[];      VMData.FindDirtyUnreferenced[	pResult: @opData.checkOutData, freeNeeded: pagesNeeded];      IF intervalCheckedOut.count > 0 THEN	BEGIN  --swap victim out--		-- First free any clean real memory checked out and after swapout interval		VMData.swapOutPagesReclaimed ¬ VMData.swapOutPagesReclaimed +                        DeallocateMStoreIfClean[[activeIntervalEnd,                               (intervalCheckedOut.page+intervalCheckedOut.count) -                               activeIntervalEnd]].countDeallocated;		buffer ¬ SwapBuffer.Allocate[activeInterval.count, willTakeLess];        ProcessInternal.SetPriority[  -- a higher priority than the next SwapOutProcess which	  priorityPageFaultHigh];  -- will get woken up by MStore.Promise (inside IOTransfer).	WHILE activeInterval.count # 0 DO	  ioInterval ¬ [	    page: activeInterval.page, count: MIN[activeInterval.count, buffer.count]];	  [] ¬ MStore.RelocateAdjustingFlags[	  interval: ioInterval, pageDest: buffer.page,	  flagsKeep: maskNone, flagsAdd: flagsReadOnly];	  ioErrAction ¬ pressOn;  -- normal case.	  IOTransfer[  -- may set ioErrAction = hangProcess.	  @opData, write, out, buffered, unBufferedOrHeadedOut];	  IF ioErrAction = hangProcess THEN	    EXIT;	  activeInterval.page ¬ activeInterval.page + ioInterval.count;	  activeInterval.count ¬ activeInterval.count - ioInterval.count;        ENDLOOP;	SwapBuffer.Deallocate[buffer];	ProcessInternal.SetPriority[priorityPageFaultLow];  -- back to normal.	SELECT ioErrAction FROM	  hangProcess => NULL;	  pressOn =>	    -- changeInterval is really the subset of intervalCheckedOut,	    -- activeInterval, before it was altered. But, CheckInSwapUnits, will	    -- work on the whole swap unit anyway, so might as send in the biggie.	    VMData.CheckInSwapUnits[	      pResult: @checkOutData, changeInterval: intervalCheckedOut,	      newState: [newLife: [setTo[alive]]], pageReadIn: opData.pageReadIn];	  ENDCASE => Bug[funnyCase];	swapOutOutputs ¬  swapOutOutputs + 1;	swapOutPagesActuallyOutput ¬ swapOutPagesActuallyOutput + ioInterval.count;	END;  --swap victim out--      swapOutJobs ¬ swapOutJobs + 1;      swapOutJobPulses ¬ [(System.GetClockPulses[] - jobStart) + swapOutJobPulses];      ENDLOOP;  --FOREVER--    END;  --OPEN--    END;  --SwapOutProcess--        Unmap: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [page: Environment.PageNumber] =    -- We serialize Unmaps and Relocates because there is a critical region below which another Unmap or Relocate on the same interval could interfere with. The region is from the time that the mapUnit location is obtained until its first swap unit is checked out.    -- This calls the entry procedure so the code won't sit and wait for a state vector while holding the monitor lock.    BEGIN    errorDesc: VMInternal.ErrorDesc;    priorityPrev: Process.Priority;    -- NOTE: There is a near-copy of the following statement in VMUtilities.EnterVM!    IF page >= StoragePrograms.countVM THEN      RETURN WITH ERROR Space.Error[pointerPastEndOfMemory];    priorityPrev ¬ VMInternal.GuardStateVector[];  -- protect monitor lock.    errorDesc ¬ UnmapEntry[page];    DoneWithStateVector[priorityPrev];    -- NOTE: There is a near-copy of the following code in VMUtilities.ExitVM!    WITH e: errorDesc SELECT FROM      ioError => ERROR Space.IOError[e.page];      noError => RETURN;      spaceError => ERROR Space.Error[e.type];      ENDCASE => Bug[funnyCase];    END;        UnmapEntry: ENTRY PROCEDURE [page: Environment.PageNumber]    RETURNS [errorDesc: VMInternal.ErrorDesc ¬ [noError[]]] =    BEGIN ENABLE ANY => Bug[unexpectedSignal];    -- If we get a signal raised in here (by GetMapUnitAttributes, EnterVM, or ExitVM), we will probably deadlock the system. The code below tries to assure that no such signal will be raised.        UnmapBatch: ProcessBatchProc = {  --[pOpData]--    -- RETURNS [changeInterval, newState¬noStateChange]    RETURN DeactivateOrUnmapBatch[pOpData, unmap]};        mapUnit: Interval ¬ VM.GetMapUnitAttributes[page, NIL].mapUnit;    IF mapUnit.count = 0 THEN       RETURN [ [spaceError[notMapped]] ]    ELSE      BEGIN      opData: OpData;      EnterVM[@opData, mapUnit];      ProcessBatches[	@opData, mapUnit,	[errorIfUnmapped, swapUnitsIncludingInterval, leaveCheckedOut],	UnmapBatch];      IF opData.error = [spaceError[notMapped]]      OR VMData.DeleteMapUnit[mapUnit.page].notMapped THEN	Bug[logicError];      errorDesc ¬ opData.error;  -- save error code.      opData.error ¬ [noError[]];  -- so doesn't signal inside my monitor.      ExitVM[@opData];      END;    unmaps ¬ unmaps + 1;    RETURN [errorDesc];    END;  --Unmap---- =============================================================     PartiallyUnmap: PUBLIC --VMExtras2.-- PROCEDURE-- =============================================================     [vm: VM.Interval] =-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    BEGIN    <<*>> PartiallyUnmapEntry: ENTRY PROCEDURE =      BEGIN ENABLE ANY => Bug[unexpectedSignal];      opData: OpData;      EnterVM[@opData, vm];      ProcessBatches[@opData, vm,        [errorIfUnmapped, exactInterval--swapUnitsIncludingInterval--,	  leaveCheckedOut], OnlyFreeRealBatch];      IF opData.error = [spaceError[notMapped]] THEN Bug[logicError];       VMExtras2.DeleteMapUnitPartially[vm];      ExitVM[@opData];      END; --PartiallyUnmapEntry--<<*>> OnlyFreeRealBatch: ProcessBatchProc =       BEGIN OPEN pOpData, pOpData.checkOutData;      ClearPatches[activeInterval.page,         VMPerf.BatchCount[activeInterval.count]];      MStore.Deallocate[activeInterval, notPromised];      ioInterval.count ¬ 0;      END; --OnlyFreeRealBatch--      -- * main line    priorityPrev: Process.Priority ¬ GuardStateVector[];    Pinning.Pin[partiallyUnmapPin];    PartiallyUnmapEntry[];    DoneWithStateVector[priorityPrev];    Pinning.Unpin[partiallyUnmapPin];    END; --PartiallyUnmap--  Wait: PUBLIC --VM.-- PROCEDURE [interval: VM.Interval] = {    opData: OpData;    EnterVM[@opData, interval];  -- (checks for sensible interval)    AwaitNoOverlappingOperations[interval];    ExitVM[@opData]};      --~~~~~~~~~~ Major utility routines: ~~~~~~~~~~  IntervalRequiringInput: PROCEDURE [pOpData: POINTER TO OpData]    RETURNS [requiresInput: Interval] =    -- Other parameters in pOpData­: checkOutData    --   especially .activeInterval and .processType.    -- Returns requiresInput = the first subinterval of activeInterval    --   which is swapped out and requires actual input.    -- Materializes dead pages as required. If all pages of activeInterval    --   are in or dead, returns requiresInput.count = 0.    BEGIN OPEN pOpData, pOpData.checkOutData;    pageNeededIn: PageNumber ¬ activeInterval.page;    WHILE pageNeededIn < activeIntervalEnd DO      -- Find first page needed to be swapped in --      IF PageMap.IsMapped[pageNeededIn] THEN	pageNeededIn ¬ pageNeededIn + 1      ELSE	BEGIN  --out--	-- Accumulate run of swapped out to be read in:	pageNeededInEnd: PageNumber ¬ pageNeededIn + 1;	WHILE pageNeededInEnd < activeIntervalEnd	  AND PageMap.IsVacant[pageNeededInEnd] DO	  pageNeededInEnd ¬ pageNeededInEnd + 1	  ENDLOOP;	requiresInput ¬ [pageNeededIn, pageNeededInEnd - pageNeededIn];	SELECT state.life FROM	  dead =>	    BEGIN	    ReadDead[pOpData, requiresInput];	    pageNeededIn ¬ pageNeededInEnd + 1;  -- (since end page is mapped)	    LOOP;  -- go find next run of swapped out pages.	    END;	  alive =>  --out and alive--	    RETURN;	  ENDCASE => Bug[funnyCase];	END;  --out--      ENDLOOP;  --Find first page needed to be swapped in--    --ASSERT: All were in or (were dead and now are in).    RETURN[requiresInput: VM.nullInterval];    END;  --IntervalRequiringInput--  IntervalRequiringOutput: PROCEDURE [    pOpData: POINTER TO OpData, changeAccess: {unchangedAccess, makeReadOnly}]    RETURNS [requiresOutput: Interval] =    -- Other parameters in pOpData­: activeInterval, activeIntervalEnd, state.access.    -- Returns requiresOutput = the first subinterval of activeInterval which is dirty, marking it clean in the process (Note that this will be a problem for the caller if he allocates a swap buffer that is smaller than requiresOutput). If all pages of activeInterval are clean, returns requiresOutput.count = 0.    -- If changeAccess=makeReadOnly, makes any swapped-in pages up to and including all of requiresOutput to be readOnly.    -- NOTE: To make its life easy, this proc does not accurately maintain the referenced bit of the pages of requiresOutput (dirty pages). This is ok because its clients are either swapping the stuff out or performing output in place and the output operation will mark it referenced anyway.    BEGIN OPEN pOpData, pOpData.checkOutData;    flags: PageMap.Flags;    newReadOnly: BOOLEAN = (state.access = readOnly OR changeAccess = makeReadOnly);    wasDirty: BOOLEAN;    newFlags: PageMap.Flags ¬ [      readonly: newReadOnly, dirty: FALSE, referenced: --assume--FALSE];    pageNeededOut: PageNumber ¬ activeInterval.page;    -- Could exit immediately if swappable and readonly. It doesn't seem worth it.     FOR pageNeededOut: PageNumber IN [activeInterval.page..activeIntervalEnd) DO      --UNTIL dirty run found--      BEGIN  --scope of NextPage--      -- Find if dirty, mark clean, maintain referenced:      wasDirty ¬ FALSE;  -- must assume.      --ASSERT: newFlags.referenced = FALSE.      DO  --UNTIL ref'd bit set right--	flags ¬ PageMap.ExchangeFlags[  -- (flags not changed if was vacant)	  pageNeededOut, newFlags].oldState.flags;	--UNTIL-- IF flags = flagsVacant THEN GOTO NextPage;	wasDirty ¬ wasDirty OR flags.dirty;	--UNTIL-- IF flags.referenced = newFlags.referenced THEN EXIT;	--ASSERT: flags.referenced = TRUE.	newFlags.referenced ¬ TRUE;	ENDLOOP;      -- ASSERT: pageNeededOut is swapped in.      IF wasDirty THEN	BEGIN  --in and dirty--	-- Accumulate run of mapped and dirty to be written:	-- COULD piggyback a suceeding run of clean pages followed by more dirty pages to get more written in one operation. If we do, we should put a limit on clean pages included.	pageNeededOutEnd: PageNumber ¬  pageNeededOut + 1;	WHILE pageNeededOutEnd < activeIntervalEnd DO	  flags ¬ PageMap.GetState[pageNeededOutEnd].state.flags;	  --UNTIL-- IF flags = flagsVacant OR NOT flags.dirty THEN EXIT;	  [] ¬ PageMap.ExchangeFlags[pageNeededOutEnd, newFlags];	  pageNeededOutEnd ¬ pageNeededOutEnd + 1;	  ENDLOOP;	RETURN[requiresOutput: [pageNeededOut, pageNeededOutEnd - pageNeededOut]];	END  --in and dirty--      ELSE NULL;  --in and clean. makeReadOnly was done already.      EXITS NextPage => NULL;      END;  --scope of NextPage--      ENDLOOP;  --pageNeededOut--    requiresOutput.count ¬ 0;  -- all are out or in+clean.    END;  --IntervalRequiringOutput--  ReadUsingBuffer: PROCEDURE [    pOpData: POINTER TO OpData,    cleanliness: {andMarkDirty, andMarkClean} ¬ andMarkClean] =    -- Other parameters in pOpData­: checkOutData, ioInterval.    -- Other results in pOpData­: error, ioInterval.count (may be less than ioInterval.count at entry).    -- Reads in all or part of ioInterval using a swap buffer, marking    -- the pages referenced, and dirty or clean depending on cleanliness.    -- See also IOTransfer.    BEGIN OPEN pOpData, pOpData.checkOutData;    -- ASSERT: ioInterval is checked out, its first and last pages (at least)    -- are alive, and all of its pages are swapped out.    buffer ¬ SwapBuffer.Allocate[      MIN[ioInterval.count, SwapBuffer.maxBufferSize],      GetSizeRequirement[processType]];    ioInterval.count ¬ MIN[ioInterval.count, buffer.count];    AllocateRealMemory[      interval: [page: buffer.page, count: ioInterval.count],      processType: processType, resident: (state.swappability = resident)];    IOTransfer[      pOpData, read, in, buffered, [      access: state.access, dirty: cleanliness=andMarkDirty, referenced: TRUE]];    SwapBuffer.Deallocate[buffer];    END;  --ReadUsingBuffer--  AfterTransfer: TYPE = {    in,  -- after transfer, data will be or remain swapped in.    out};  --  after transfer, data will be swapped out.  BufferOption: TYPE = {    buffered,  -- I/O is performed in a swap buffer.    unbuffered};  -- I/O is performed at the normal client virtual memory address.  BufferedInputFlags: TYPE = RECORD [    -- page flags to be set on completion of buffered input operation.    access: Space.Access, dirty: BOOLEAN, referenced: BOOLEAN];  unBufferedOrHeadedOut: BufferedInputFlags = [NULL, NULL, NULL];  -- i.e. BufferedInputFlags are not significant if not buffered or will be swapped out.  IOTransfer: PROCEDURE [    pOpData: POINTER TO OpData, operation: BackingStore.Operation,    afterTransfer: AfterTransfer, bufferOption: BufferOption,    bufferedInputFlags: BufferedInputFlags] =    << Other parameters in pOpData­:         checkOutData.pageRun, checkOutData.backingData,	 checkOutData.transferProc, ioInterval, buffer,	 ioErrorHandler.       Other results in pOpData­: error.       Initiates I/O of ioInterval, waits for it to complete, then returns.       The sensible combinations of operation, afterTransfer, and         bufferOption are:           read, in, buffered  (reads into swappable intervals)           write, out, buffered  (swap outs)           read, in, unbuffered  (CopyIn onto resident intervals)           write, in, unbuffered  (CopyOut, make clean operations)       The two combinations (afterTransfer = out and bufferOption = buffered) and (operation = read and bufferOption = unbuffered) are both non-sensible, and should not be used.      [The combo *read, in, buffered* causes pOpdata to be marked pageReadIn (since a page is about to be read in fer shure!).]       If afterTransfer = out, does MStore.Promise[ioInterval.count] before start of transfer and Deallocates the memory afterwards.       If bufferOption=buffered and afterTransfer = in, then relocates back to normal client address while setting page flags per BufferedInputFlags. In addition, if operation=read, debugger patches are applied before relocating to client address.       If an I/O error occurs, ioErrorHandler is called (if supplied). If it returns hangProcess, normal finalization actions are skipped, leaving the resources involved inaccessible; If it returns pressOn or if there is no IOErrorHandler, the operation completes "normally" - the client will get bad data; In both cases, IOTransfer returns error ¬ [ioError[page]].       If bufferOption = buffered, buffer.count must be >= ioInterval.count.    >>    BEGIN OPEN pOpData, pOpData.checkOutData, bif: bufferedInputFlags;    result: BackingStore.Result;    transferData: BackingStore.TransferData;    IF operation=read AND afterTransfer=in AND bufferOption=buffered THEN pageReadIn ¬ TRUE;    IF bufferOption = buffered AND buffer.count < ioInterval.count THEN      Bug[invalidParameters];    IF afterTransfer = out THEN MStore.Promise[ioInterval.count];    -- Examine code listing for following statement!    transferData ¬ [      operation: operation,      pageBuffer:        IF bufferOption = buffered THEN buffer.page ELSE ioInterval.page,      countBuffer: ioInterval.count,      pageData: pageRun,      data: backingData,      offsetFromData: ioInterval.page - pageRun,      process: process];    IF transferWatcher # NIL THEN transferWatcher[transferProc, @transferData];    result ¬ transferProc[@transferData];    WITH r: result SELECT FROM      done => NULL;      error => {	error ¬ [	  ioError[	  IF bufferOption = unbuffered THEN r.pageInError	  ELSE (r.pageInError - buffer.page) + ioInterval.page]];	IF ioErrorHandler # NIL AND ioErrorHandler[r].continuation = hangProcess	  THEN RETURN};      ENDCASE => Bug[funnyCase];    SELECT afterTransfer FROM      in =>	SELECT bufferOption FROM	  buffered =>	    BEGIN	    IF operation = read THEN	      ApplyPatches[		pageData: ioInterval.page, pageBuffer: buffer.page,		count: VMPerf.BatchCount[ioInterval.count]];  -- See Problem 1	    [] ¬ MStore.RelocateAdjustingFlags[	      interval: [page: buffer.page, count: ioInterval.count],	      pageDest: ioInterval.page, flagsKeep: maskNone,	      flagsAdd:[		readonly: bif.access = readOnly, dirty: bif.dirty,		referenced: bif.referenced]];	    END;	  unbuffered => NULL;	  ENDCASE => Bug[funnyCase];      out => MStore.Deallocate[buffer, promised];      ENDCASE => Bug[funnyCase];    END;  --IOTransfer--  ApplyPatches: PROCEDURE [    pageData, pageBuffer: PageNumber, count: VMPerf.BatchCount] = INLINE  -- Applies debugger patches to interval [pageData, count], whose real pages are currently located starting at pageBuffer.    BEGIN    esv: LONG POINTER TO CPSwapDefs.ExternalStateVector;    patchTable: LONG POINTER TO CPSwapDefs.PatchTable;    pData, pDataEnd: LONG ORDERED POINTER;    pEntry, pLimit: LONG POINTER TO CPSwapDefs.PatchTableEntry;    ProcessOperations.DisableInterrupts[];  -- get exclusive access to ESV.    esv ¬ CPSwapDefs.PESV[];    patchTable ¬ esv.patchTable;    IF patchTable = NIL OR patchTable.length = 0 THEN      {ProcessOperations.EnableInterrupts[]; RETURN};  -- no patches.    esv.patchTableInUse ¬ TRUE;    ProcessOperations.EnableInterrupts[];    pData ¬ Order[Environment.LongPointerFromPage[pageData]];    pDataEnd ¬ Order[Environment.LongPointerFromPage[pageData + count]];    pLimit ¬ @patchTable.entries[patchTable.length];    FOR pEntry ¬ @patchTable.entries[0], pEntry + CPSwapDefs.PatchTableEntry.SIZE    WHILE pEntry # pLimit DO      IF Order[pEntry.address] IN [pData..pDataEnd) THEN	(Environment.LongPointerFromPage[pageBuffer]	  + (Order[pEntry.address] - pData))­ ¬ pEntry.value;      ENDLOOP;    esv.patchTableInUse ¬ FALSE;  -- (better be an atomic operation.)    END;  ClearPatches: PROCEDURE [pageData: PageNumber, count: VMPerf.BatchCount] = INLINE  -- Clears debugger patches from interval [pageData, count].    BEGIN    esv: LONG POINTER TO CPSwapDefs.ExternalStateVector;    patchTable: LONG POINTER TO CPSwapDefs.PatchTable;    pData, pDataEnd: LONG ORDERED POINTER;    runner: CARDINAL ¬ 0;    ProcessOperations.DisableInterrupts[];  -- get exclusive access to ESV.    esv ¬ CPSwapDefs.PESV[];    patchTable ¬ esv.patchTable;    IF patchTable = NIL OR patchTable.length = 0 THEN      {ProcessOperations.EnableInterrupts[]; RETURN};  -- no patches.    esv.patchTableInUse ¬ TRUE;    ProcessOperations.EnableInterrupts[];    -- get pointer bounds for interval    pData ¬ Order[Environment.LongPointerFromPage[pageData]];    pDataEnd ¬ Order[Environment.LongPointerFromPage[pageData + count]];    WHILE runner < patchTable.length DO      -- if in our range then need to clear that patch      IF Order[patchTable.entries[runner].address] IN [pData..pDataEnd) THEN        BEGIN	patchTable.length ¬ patchTable.length - 1;	-- move all higher index patches down in table	FOR i: CARDINAL ¬ runner, i + 1 WHILE i < patchTable.length DO	  patchTable.entries[i] ¬ patchTable.entries[i + 1];	  ENDLOOP;	END      ELSE        runner ¬ runner + 1;      ENDLOOP;    esv.patchTableInUse ¬ FALSE;  -- (better be an atomic operation.)    END;  --~~~~~~~~~~ State Vector Guard and VM Data Operations Initialization:  EnterVM: PUBLIC --VMInternal.-- PROCEDURE [    pOpData: POINTER TO OpData, interval: VM.Interval] =    BEGIN OPEN pOpData;    -- In order to avoid being deadlocked on a stateVector, we must transiently change the    -- caller's priority to a reserved level and have a state vector allocated for it (in the    -- bootmesa file). The priority must be changed after we begin executing    -- resident code.    -- NOTE: There is a copy of the following statement in VMImplA.Unmap!    IF interval.page >= StoragePrograms.countVM      OR interval.count > StoragePrograms.countVM - interval.page THEN      ERROR Space.Error[pointerPastEndOfMemory];  -- before changing priority!    priorityPrev ¬ GuardStateVector[];    process ¬ ProcessInternal.GetCurrent[];    checkOutData.processType ¬ GetProcessType[];    pageReadIn ¬ FALSE;    -- Note: there is a copy of the following code in VMUtilities.QueuedOperationExecutor.    error ¬ [noError[]];    ioErrorHandler ¬ NIL;    END;  ExitVM: PUBLIC --VMInternal.-- PROCEDURE [pOpData: POINTER TO OpData] =    BEGIN    operations ¬ operations + 1;    DoneWithStateVector[pOpData.priorityPrev];    -- NOTE: There is a near-copy of the following code in VMImplA.Unmap!    WITH e: pOpData.error SELECT FROM      ioError => ERROR Space.IOError[e.page];      noError => RETURN;      spaceError => ERROR Space.Error[e.type];      ENDCASE => Bug[funnyCase];    END;  -- Minor utility routines:  Bug: PROCEDURE [type: BugType] = {RuntimeInternal.Bug[BugType[type]]};  GetSizeRequirement: PROCEDURE [processType: VMData.ProcessType]    RETURNS [SwapBuffer.SizeRequirement] = INLINE {    RETURN[IF processType = client THEN exactSizeRequired ELSE willTakeLess]};  HandleVMIOError: IOErrorHandler --[error] RETURNS [continuation]--  =    <<Calls the debugger informing user of I/O error. For use handling    I/O errors for I/O initiated by a PageFaultProcess or a SwapOutProcess.    The error occurred on virtual page error.page. However, this may actually    be a page in a buffer area. Look up the stack to deduce the client address.    In the debugger, the operator may      (1) Proceed, which leaves the process faulted indefinitely          (but other processes continue). Since the data was in a buffer,          the data will be unavailable to the client.     or      (2) interpret call PressOn[] (from the debugger) then Proceed,          which will finish the swap out as if no data error had taken place.          The operator will take his chances on processing bad data.    error.type MUST be ioError.>>    BEGIN        PressOn: PROCEDURE = {  -- (interpret called from debugger only)      continuation ¬ pressOn};        continuation ¬ hangProcess;  -- normal case.    Runtime.CallDebugger["Asynchronous VM I/O Error"L ! ABORTED => CONTINUE];    END;  Order: PROCEDURE [p: LONG POINTER] RETURNS [LONG ORDERED POINTER] = INLINE {    RETURN[LOOPHOLE[p]]};  END.LOG17-Jun-82 11:37:57   WDK        Created file.29-Sep-82 12:47:33   WDK        Development.15-Oct-82 10:12:27   WDK        Bug fixes, minor improvements.22-Oct-82 14:42:42   WDK        PageFaultProcess overwrote adjacent swapped-in pages.25-Oct-82 10:53:54   WDK        Unmap must process swapUnitsIncludingInterval. 1-Nov-82 15:54:08   WDK        SwapOutProcess failed to Relocate to swap buffer.11-Nov-82  9:22:08   WDK        Make compatible with new MStore. IntervalRequiringInput did not always increment loop counter.23-Dec-82  9:43:20   AWL         NewSpace => Space.17-Jan-83 15:17:10   WDK        Fencepost error in EnterVM.11-Feb-83  9:19:00   WDK        Make compatible with new VMData. MakeReadOnly[swappableReferencedPage] looped.11-Mar-83 14:58:07   WDK        MakeResident and CopyOut could get negative reserve. IntervalRequiringOutput failed to mark noninitial pages clean. Map[readOnly+dead] now raises Error. Kill[resident] now marks dead. Logic error in Kill[pageInSwapUnit]. CopyOut didn't count reserved right. Map[transferProc: NIL, resident, readOnly] now disallowed. Map[readOnly] now supplies alive. MakeReadOnly[notAllSwappedIn] lied about reserved mem. PageFaultProcess leaked swap buffers. CopyIn did not mark pages dirty.23-Mar-83 17:45:47   WDK        Kill[noLeaderNoInteriorNoTrailerChangeInterval] wrongly marked s.u. dead. 8-Apr-83 15:39:54   WDK        Added TransferWatcher.28-Apr-83 11:04:33   WDK        MakeWritable did not (actually) update reserved memory count. 9-May-83 11:05:02   WDK        MakeResident tallied, then untallied reserved mem count.17-Jun-83 17:19:58   JXG     pp WDK        add ENABLE ANY to Relocate and Unmap; new BugType unexpectedSignal21-Jun-83 13:45:14   JXG        move GetSwapUnitsFor...  here from SpaceImpl because of start trap problems there15-Jul-83 16:02:42   JXP   	Make compatible with new defs.20-Jul-83 13:55:20   JXP   	EXPORT SpecialRuntime 4-Aug-83  8:21:17   WDK        Get new patch table address every time. Lock patch table while in use. Improve efficiency of ApplyPatches. Make compatible with new patch table format.19-Sep-83 13:31:54   AWL         Kill: failed to work correctly if the interval being killed did not precisely fall on swap unit boundaries.19-Sep-83 17:44:26   AWL         Removed Kill: now implemented in VMDataImpl.28-Dec-83 16:22:17   AWL         IOTranfer was not setting the process field in the TransferData.13-Jan-84 15:43:46   EKN     Change DeactivateOrUnmapBatch to always call SwapBuffer.Allocate with willTakeLess.  27-Jan-84 12:34:42   AWL         OpData.reserveAlreadyApproved no longer needed (it was the wrong idea).   CopyOut: don't bother to AddReserved as IOTransfer is correctly     compensating for the SubtractReserved that ApproveReserved did.  Changed     comment in IOTransfer appropriately.  Altered the code so that the input and     output phases independently maintain the count of reserved memory correctly.31-Jan-84 10:16:30   AWL         CopyOut: did not handle an interval sufficiently broken between in/out state.24-Feb-84 16:28:11   AWL         ProcessBatches: if need more reserved memory, then must always do the adjust reserved in order to allow the swap out process to run.26-Mar-84 18:02:01   EKN     Took out ioInterval.count ¬ 0 in SetSwappabilityBatch so ProcessBatches correctly makes checkerboarded intervals resident.11-Apr-84 15:53:46   AWL         SetSwappability[...resident]: failed to get reserved memory accounting right if only a subinterval of the interval needed to be read into real memory.  Activate fails to get reserved memory accouting right if the interval is read-only and more than one subinterval is not inreal memory..18-Jun-84 13:42:36   KEK       Add new pageReadIn parameter to all calls to CheckInSwapUnits. Implement new pageReadIn field in OpData.  pass pOpData and interesting interval to ReadDead.11-Jul-84 18:01:36   KEK       Move all reserved memory accounting into CheckOutSwapUnits and CheckInSwapUnits.    Toss memType trash! Pass pResult into CheckInSwapUnits.28-Sep-84 11:41:35   KEK       Add "resident" argument to AllocateRealMemory (for PC emulation); add PC emulation stuff. 3-Dec-84 12:08:04   KEK       PageFaultProcess gets swapBuffer just for ioInterval, not the containing Whole Swap Unit; Make sure SwapBuffer.Allocate is never asked to allocate anything > SwapBuffer.maxBufferSize.  Pinned Activate stuff, Deactivate stuff, ForceOut stuff, Relocate, SetAccess 8-Oct-85 16:17:39   RSV   Added ClearPatches and call to it in DeactivateOrUnmap to clear out patch table on unmaps for AR 7746.16-Oct-85            RRR   Eliminated deallocation of clean referenced pages occurring before the swap interval.  Also added code to write out entire swap interval even if there is no swap buffer sufficiently large.12-Sep-86  7:07:17   et    Change ProcessPriorities to ProcessPrioritiesExtras for priorityPageFaultLow and priorityPageFaultHigh. 8-Dec-86 14:05:31   RSV   Moved deallocation of buffers out of IOTransfer and into the procedures which call it.14-Jan-87 22:35:05   ET	   MDS RELIEF.27-Oct-87  7:34:43   ET    AR 12073 - SwapOutProcess doesn't set entire interval's state to alive from dead. (Changed ioInterval to intervalCheckedOut in call to CheckInSwapUnits. Deleted saveActiveInterval).17-Jan-89 18:40:40   RSV   Deleted debug boolean, since it wasn't being used anyway.20-Jan-89 11:23:16   TxH  changed for consecutive real pages functions. Export ProcessBatches to VMInternal. **12-Apr-89 12:10:49   TxH  Changed VMImpl to VMImplA and VMImplB. The PCEmulation stuff and ConsecutiveRealVMImpl's are moved to VMImplB, and PartiallyUnmap is added. Also InitializeVMDriverB added. Fixed a bug in ProcessBatches. (SS-FX: AR#6, AR#26) 
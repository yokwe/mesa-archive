-- Copyright (C) 1984, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- HeapImpl.mesa    26-Sep-87 17:43:16 by RSV    DIRECTORY  Environment USING [PageCount, wordsPerPage],  File USING [Create, Delete, File, nullFile, Unknown],  FileTypes USING [tUntypedFile],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Attributes, Create, CreateMDS, ErrorType, NWords],  HeapExtras USING [],  HeapInternal,  Inline USING [LowHalf],  KernelPrograms USING [],  KernelSpaceUsage USING [heap],  PilotSwitches USING [heapChecking, heapOwnerChecking],  PilotSwitchesExtras USING [useLargeHeap, useStdHeap, useTinyHeap],  PrincOpsExtras2 USING [GFTHandle],  Runtime USING [GetCaller],  Space USING [    Allocate, defaultSwapUnitSize, Error, GetMapUnitAttributes, InsufficientSpace,    Interval, MapAt, MDS, PageCount, PageFromLongPointer, PagesFromWords,    SwapUnitSize, Unmap, virtualMemory],  SpecialHeap USING [],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  System USING [UpDown, IsUtilityPilot, switches, VolumeID],  VM USING [MakeResident, MakeSwappable],  Volume USING [systemID],  Zone USING [    AddSegment, Base, BlockSize, Create, FreeNode, GetAttributes,    GetSegmentAttributes, Handle, IsZoneEmpty, MakeNode, minimumNodeSize, nullSegment,    RemoveSegment, SegmentHandle, SetChecking, Status],  ZoneInternal USING [NodeHeader, SegmentHeader, TemporaryBlocksize, ZoneHeader];HeapImpl: MONITOR LOCKS h.lock USING h: HeapInternal.Handle  IMPORTS     File, FrameExtras, Heap, Inline, Runtime, Space, SpecialRuntimeExtras,    System, VM, Volume, Zone  EXPORTS Heap, HeapExtras, KernelPrograms, SpecialHeap SHARES Heap =  BEGIN OPEN HeapInternal;  --  -- Types  NWords: TYPE = Heap.NWords;  LongMdsHandle: TYPE = LONG POINTER TO mds Data;  --  -- Constants  wpp: CARDINAL = Environment.wordsPerPage;  maxPPS: CARDINAL = 128; --Max Pages-Per-Segment of heap.  defaultSwapUnit: Space.SwapUnitSize = Space.defaultSwapUnitSize;  nodeOverhead: CARDINAL = SIZE[inuse ZoneInternal.NodeHeader];  zoneOverhead: CARDINAL = SIZE[ZoneInternal.ZoneHeader] + nodeOverhead;  minimumNodeSize: PUBLIC NWords = Zone.minimumNodeSize;  procs: Procs ¬ [Make: MakeNode, Free: FreeNode];  --mdsProcs: MDSProcs ¬ [Make: MakeMDSNode, Free: FreeMDSNode];  systemZone: PUBLIC UNCOUNTED ZONE;  -- initialized in InitializeHeap  systemMDSZone: PUBLIC MDSZone;  -- initialized in InitializeHeap  normalOverhead: CARDINAL = SIZE[normal Data] + SIZE[ZoneObject];  ownerNameSize: CARDINAL = SIZE[PrincOpsExtras2.GFTHandle];  Bug: ERROR [bugType: BugType] = CODE;    -- Non-public on purpose.  Just a way to get out without anybody catching.  BugType: TYPE = {fileWeCreatedWentAway, mappedAreaWentAway};  --  -- Initialization (MiscPrograms)  InitializeHeap: PUBLIC --KernelPrograms-- PROCEDURE =    BEGIN    initial, initialMDS, increment: Environment.PageCount;    largeNodeThreshold: NWords;    IF System.IsUtilityPilot[] THEN {      initial ¬ initialMDS ¬ increment ¬ 1; largeNodeThreshold ¬ 128}    ELSE {      initialMDS ¬ 1;      SELECT System.UpDown[down] FROM -- order of items is important        System.switches[PilotSwitchesExtras.useLargeHeap] => {	  initial ¬ 100; increment ¬ 50; largeNodeThreshold ¬ 260};	System.switches[PilotSwitchesExtras.useStdHeap] => {	  initial ¬ 40; increment ¬ 20; largeNodeThreshold ¬ 260};	System.switches[PilotSwitchesExtras.useTinyHeap] => {	  initial ¬ 4; increment ¬ 4; largeNodeThreshold ¬ 128};	ENDCASE => { -- same as std --	  initial ¬ 40; increment ¬ 20; largeNodeThreshold ¬ 260}};    systemMDSZone ¬ Heap.CreateMDS[      initial: initialMDS,      ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down,      checking: System.switches[PilotSwitches.heapChecking] = down];    systemZone ¬ Heap.Create[      initial: initial, increment: increment, swapUnitSize: 4,      largeNodeThreshold: largeNodeThreshold,      ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down,      checking: System.switches[PilotSwitches.heapChecking] = down];    END;  --  -- Heap implementation  Create: PUBLIC --Heap-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NWords,    ownerChecking, checking: BOOLEAN]    RETURNS [UNCOUNTED ZONE] = {    RETURN[NewCreate[initial, maxSize, increment, swapUnitSize, threshold,      largeNodeThreshold, ownerChecking, checking, Volume.systemID]]};  NewCreate: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NWords,    ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID]    RETURNS [UNCOUNTED ZONE] =    BEGIN    MyMake: PROCEDURE [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] = {      RETURN[base]};    uzo: UncountedZoneObject ¬ [@myProcs, NIL];    myProcs: Procs ¬ [Make: MyMake, Free: NULL];    myZone: UNCOUNTED ZONE ¬ LOOPHOLE[LONG[@uzo]];    h: NormalHandle;    zH: Zone.Handle;    status: Zone.Status;    zoneInfo: ZoneHandle;    base: LONG ORDERED BASE POINTER;    length: Zone.BlockSize;    extra: Space.PageCount;    IF initial = 0 THEN initial ¬ 1;  -- since not yet ready to extend    IF maxSize < initial THEN ERROR Error[maxSizeExceeded];    IF initial > maxPPS THEN {extra ¬ initial - maxPPS; initial ¬ maxPPS}    ELSE extra ¬ 0;    length ¬ CARDINAL[initial*wpp] - normalOverhead;    IF LOOPHOLE[length, CARDINAL] > LAST[ZoneInternal.TemporaryBlocksize] THEN      -- TEMPORARY check if zone is too large to create      ERROR Error[invalidSize];    base ¬ MakeSpace[      parent: Space.virtualMemory, pages: initial, swapUnitSize: swapUnitSize,      resident: FALSE, volumeID: volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    [zH: zH, s: status] ¬ Zone.Create[      storage: base + normalOverhead, length: length,      zoneBase: base, threshold: threshold, checking: checking];    IF status ~= okay THEN ERROR Error[otherError];    zoneInfo ¬ base + SIZE[normal Data];    zoneInfo­ ¬ [next: NIL, base: base, zH: zH, length: length, initial: initialHeap];    h ¬ myZone.NEW[normal Data ¬ [      ownerChecking: ownerChecking, checking: checking, maxSize: maxSize,      currentSize: initial, increment: increment, swapUnit: swapUnitSize,      volumeID: volumeID,      vp: normal[zones: zoneInfo, threshold: threshold,        largeNodeThreshold: largeNodeThreshold,	uzo: [procs: @procs, data: NULL]]]];    h.uzo.data ¬ h;    WHILE extra # 0 DO      pages: Space.PageCount;      IF extra > maxPPS THEN {extra ¬ extra - maxPPS; pages ¬ maxPPS}      ELSE {pages ¬ extra; extra ¬ 0};      [] ¬ ExpandNormalHeapInternal[h, pages, initialExtended];      ENDLOOP;    RETURN[LOOPHOLE[@h.uzo]]    EXITS InsufficientSpace => ERROR Error[insufficientSpace]    END;  --NewCreate--  CreateMDS: PUBLIC --Heap-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NWords,    ownerChecking, checking: BOOLEAN]    RETURNS [MDSZone] = {    RETURN[NewCreateMDS[initial, maxSize, increment, swapUnitSize, threshold,      largeNodeThreshold, ownerChecking, checking, Volume.systemID]]};  NewCreateMDS: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, threshold, largeNodeThreshold: NWords,    ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID]    RETURNS [MDSZone] =    BEGIN    MyMake: PROCEDURE [z: MDSZone, n: CARDINAL] RETURNS [POINTER] = {      RETURN[Narrow[seg]]};    zo: MDSZoneObject ¬ [@myProcs, NIL];    myProcs: MDSProcs ¬ [Make: MyMake, Free: NULL];    myZone: MDSZone ¬ LOOPHOLE[@zo];    h: MdsHandle;    zH: Zone.Handle;    status: Zone.Status;    base: LONG ORDERED BASE POINTER;    zoneSize: LONG CARDINAL;    seg: LONG POINTER;    IF initial = 0 THEN initial ¬ 1;  -- since not yet ready to extend    IF maxSize < initial THEN ERROR Error[maxSizeExceeded];    zoneSize ¬ (initial*wpp) - SIZE[mds Data] - SIZE[MDSProcs];    IF zoneSize NOT IN Zone.BlockSize THEN  --      -- We know there's not enough space since the size of the MDS is the limit.      ERROR Error[insufficientSpace];    IF CARDINAL[zoneSize] > LAST[ZoneInternal.TemporaryBlocksize] THEN      -- TEMPORARY check if zone is too large to create      ERROR Error[invalidSize];    base ¬ LOOPHOLE[Space.MDS[].pointer];    seg ¬ MakeSpace[      parent: Space.MDS[], pages: initial, swapUnitSize: swapUnitSize,       resident: FALSE, volumeID: volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    [zH: zH, s: status] ¬ Zone.Create[      storage: seg + SIZE[mds Data] + SIZE[MDSProcs],      length: Zone.BlockSize[zoneSize],      zoneBase: base, threshold: threshold, checking: checking];    IF status ~= okay THEN ERROR Error[otherError];    h ¬ myZone.NEW[mds Data ¬ [      ownerChecking: ownerChecking, checking: checking, maxSize: maxSize,      currentSize: initial, increment: increment, swapUnit: swapUnitSize,      volumeID: volumeID,      vp: mds[base: base, zH: zH, threshold: threshold,        largeNodeThreshold: largeNodeThreshold,	mzo: [procs: Narrow[seg] + SIZE[mds Data], data: NULL]]]];    h.mzo.procs­ ¬ MDSProcs[Make: MakeMDSNode, Free: FreeMDSNode];    h.mzo.data ¬ h;    RETURN[LOOPHOLE[@h.mzo]]    EXITS InsufficientSpace => ERROR Error[insufficientSpace]    END;  --NewCreateMDS--  CreateUniform: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, objectSize: NWords,    ownerChecking, checking: BOOLEAN]    RETURNS [UNCOUNTED ZONE] = {    RETURN[NewCreateUniform[initial, maxSize, increment, swapUnitSize,       objectSize, ownerChecking, checking, Volume.systemID]]};      NewCreateUniform: PUBLIC --HeapExtras-- PROCEDURE [    initial, maxSize, increment: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, objectSize: NWords,    ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID]    RETURNS [UNCOUNTED ZONE] =    BEGIN    MyMake: PROCEDURE [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] = {      RETURN[seg]};    uzo: UncountedZoneObject ¬ [@myProcs, NIL];    myProcs: Procs ¬ [Make: MyMake, Free: NULL];    myZone: UNCOUNTED ZONE ¬ LOOPHOLE[LONG[@uzo]];    h: UniformHandle;    seg: LONG ORDERED POINTER;    length: Zone.BlockSize;    block: Block;    extra: Space.PageCount;    IF initial = 0 THEN initial ¬ 1;  -- since not yet ready to extend    IF maxSize < initial THEN ERROR Error[maxSizeExceeded];    IF initial > maxPPS THEN {extra ¬ initial - maxPPS; initial ¬ maxPPS}    ELSE extra ¬ 0;    seg ¬ MakeSpace[      parent: Space.virtualMemory, pages: initial, swapUnitSize: swapUnitSize,      resident: FALSE, volumeID: volumeID !         Space.InsufficientSpace => GOTO InsufficientSpace];    length ¬ CARDINAL[initial*wpp] - SIZE[uniform Data] - SIZE[BlockObject];    block ¬ seg + SIZE[uniform Data];    block­ ¬ [next: NIL, length: length, initial: TRUE];    h ¬ myZone.NEW[uniform Data ¬ [      ownerChecking: ownerChecking, checking: checking, maxSize: maxSize,      currentSize: initial, increment: increment, swapUnit: swapUnitSize,      volumeID: volumeID,      vp: uniform[blocks: block, free: NIL, objectSize: objectSize,        uzo: [procs: @procs, data: NULL]]]];    h.uzo.data ¬ h;     InitializeUniformBlock[h, block];    WHILE extra # 0 DO      pages: Space.PageCount;      IF extra > maxPPS THEN {extra ¬ extra - maxPPS; pages ¬ maxPPS}      ELSE {pages ¬ extra; extra ¬ 0};      ExpandUniformHeapInternal[h, pages, TRUE];      ENDLOOP;    RETURN[LOOPHOLE[@h.uzo]]    EXITS InsufficientSpace => ERROR Error[insufficientSpace]    END;  --NewCreateUniform--  Delete: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, checkEmpty: BOOLEAN] = BEGIN    OPEN rep: LOOPHOLE[z, UncountedZoneRep];    IF checkEmpty THEN {      WITH h: rep.data SELECT FROM        normal => IF ~Zone.IsZoneEmpty[h.zones.zH] THEN ERROR Error[invalidHeap];	uniform => IF ~IsUniformEmpty[rep.data] THEN ERROR Error[invalidHeap];	ENDCASE => ERROR Error[invalidHeap]};    WITH h: rep.data SELECT FROM      normal => DeleteHeap[rep.data];      uniform => DeleteHeap[rep.data];      ENDCASE => ERROR Error[invalidHeap]    END;  --Delete--  DeleteMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone, checkEmpty: BOOLEAN] =    BEGIN OPEN rep: LOOPHOLE[z, MDSZoneRep];    IF checkEmpty THEN    IF ~Zone.IsZoneEmpty[rep.data.zH] THEN ERROR Error[invalidHeap];    DeleteHeap[rep.data]    END;  --DeleteMDS--  DeleteHeap: PROCEDURE [h: Handle] =    BEGIN    createdFiles: BOOLEAN = h.volumeID # Volume.systemID;    EnumerateZoneAdditions[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];    EnumerateLargeNodes[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];    EnumerateMajorZones[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];    END;  --DeleteHeap--      IsUniformEmpty: PROCEDURE [hh: Handle] RETURNS [empty: BOOLEAN ¬ TRUE] =    BEGIN    h: UniformHandle = LOOPHOLE[hh, UniformHandle];    freePtr: Node;    segmentPtr: Block;    objectSize: CARDINAL = AllocatedObjectSize[h];    availableNodes: LONG CARDINAL ¬ h.blocks.length/objectSize; --#nodes in initial seg.    freeNodes: LONG CARDINAL ¬ 0;			         --How many free nodes are there?    FOR freePtr ¬ h.free, freePtr.next UNTIL freePtr = NIL DO      freeNodes ¬ freeNodes + 1; ENDLOOP;    --How many nodes total are available?    FOR segmentPtr ¬ h.blocks.next, segmentPtr.next UNTIL segmentPtr = NIL DO      availableNodes ¬ availableNodes + segmentPtr.length/objectSize;      ENDLOOP;    --Are all available nodes on the free list??!    IF freeNodes # availableNodes THEN empty ¬ FALSE;      END;  --IsUniformEmpty--  MakeNode: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE, n: NWords]    RETURNS [p: LONG POINTER] =    BEGIN    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => p ¬ MakeNormalNode[@h, n];      uniform => p ¬ MakeUniformNode[@h, n];      ENDCASE => ERROR Error[invalidHeap];    IF LOOPHOLE[z, UncountedZoneRep].data.ownerChecking THEN      BEGIN      p­ ¬ FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]];      p ¬ p + ownerNameSize;      END;    END;  --MakeNode--  MakeNormalNode: ENTRY PROCEDURE [h: NormalHandle, n: NWords]    RETURNS [p: LONG POINTER] =    BEGIN    savedError: Heap.ErrorType;      BEGIN ENABLE         BEGIN        Error => {savedError ¬ type; GOTO Error};         UNWIND => NULL;	END;      r: Zone.Base RELATIVE POINTER;      status: Zone.Status;      IF h.ownerChecking THEN n ¬ n + ownerNameSize;      IF LOOPHOLE[n, CARDINAL] > LAST[NWords] THEN        -- check for nodes which are too large         RETURN WITH ERROR Error[invalidSize];      IF n >= h.largeNodeThreshold THEN {        h.largeNodes ¬ MakeLargeNode[h, n];        p ¬ @h.largeNodes.node}      ELSE {        zone: ZoneHandle ¬ h.zones;        DO          [node: r, s: status] ¬ Zone.MakeNode[zH: zone.zH, n: n];          SELECT status FROM            okay => BEGIN p ¬ @zone.base[r]; EXIT END;            noRoomInZone =>              IF (zone ¬ zone.next) = NIL THEN                zone ¬ ExpandNormalHeapInternal[h, PagesForNewCreate[n], extension];            ENDCASE => RETURN WITH ERROR Error[invalidHeap];          ENDLOOP};      EXITS        Error => RETURN WITH ERROR Error[savedError];      END;    END;  --MakeNormalNode--  FreeNode: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE, p: LONG POINTER] =    BEGIN    IF p = NIL THEN RETURN;    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => FreeNormalNode[@h, LOOPHOLE[p]];      uniform => FreeUniformNode[@h, LOOPHOLE[p]];      ENDCASE => ERROR Error[invalidHeap];    END;  --FreeNode--  FreeNormalNode: ENTRY PROCEDURE [h: NormalHandle, p: LONG ORDERED POINTER] =    BEGIN    ENABLE UNWIND => NULL;    zones: ZoneHandle;    IF h.ownerChecking THEN p ¬ p - ownerNameSize;    IF NodeSize[p] >= h.largeNodeThreshold THEN {      prev: LargeNode ¬ NIL;      largeNode: LargeNode ¬ h.largeNodes;      DO        IF largeNode = NIL THEN EXIT;        IF @largeNode.node = p THEN {          IF prev = NIL THEN h.largeNodes ¬ largeNode.next          ELSE prev.next ¬ largeNode.next;          h.currentSize ¬ h.currentSize - PagesForLargeNode[largeNode];	  IF h.volumeID # Volume.systemID THEN  -- delete the files created	    BEGIN	    tempFileID: File.File = Space.GetMapUnitAttributes[p].window.file;	    [] ¬ Space.Unmap[p ! Space.Error => Bug[mappedAreaWentAway]];	    File.Delete[tempFileID ! File.Unknown => Bug[fileWeCreatedWentAway]];	    END	  ELSE 	    [] ¬ Space.Unmap[p ! Space.Error => Bug[mappedAreaWentAway]];          RETURN};        prev ¬ largeNode;        largeNode ¬ largeNode.next;        ENDLOOP};    zones ¬ h.zones;    DO      overhead: CARDINAL =        IF zones.initial = initialHeap THEN normalOverhead ELSE SIZE[ZoneObject];      IF p IN         [zones.base + overhead..zones.base + overhead + zones.length)         THEN {        SELECT Zone.FreeNode[zH: zones.zH, p: p] FROM  -- surely regular node          okay => NULL;          invalidNode => RETURN WITH ERROR Error[invalidNode];          ENDCASE => RETURN WITH ERROR Error[invalidHeap];        RETURN};      IF (zones ¬ zones.next) = NIL THEN RETURN WITH ERROR Error[invalidNode];      ENDLOOP;    END;  --FreeNormalNode--  NodeSize: PROCEDURE [    p: LONG POINTER TO ZoneInternal.NodeHeader] RETURNS [CARDINAL] = INLINE {    RETURN[(p - SIZE[inuse ZoneInternal.NodeHeader]).length - nodeOverhead]};  MakeMDSNode: PUBLIC --Heap-- PROCEDURE [z: MDSZone, n: NWords]    RETURNS [p: POINTER] =    BEGIN    p ¬ MakeMdsNode[LOOPHOLE[z, MDSZoneRep].data, n];    IF LOOPHOLE[z, MDSZoneRep].data.ownerChecking THEN      BEGIN      p­ ¬ FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]];      p ¬ p + ownerNameSize;      END;    END;  --MakeMDSNode--  MakeMdsNode: ENTRY PROCEDURE [h: LongMdsHandle, n: NWords]     RETURNS [p: POINTER] =    BEGIN    savedError: Heap.ErrorType;      BEGIN ENABLE        BEGIN        Error => {savedError ¬ type; GOTO Error};        UNWIND => NULL;	END;      status: Zone.Status;      IF h.ownerChecking THEN n ¬ n + ownerNameSize;      IF LOOPHOLE[n, CARDINAL] > LAST[NWords] THEN        -- check for nodes which are too large        RETURN WITH ERROR Error[invalidSize];      -- since we can't delete space in UtilityPilot, treat large as small      IF n >= h.largeNodeThreshold THEN {        h.largeNodes ¬ MakeLargeNode[h, n];        p ¬ Narrow[@h.largeNodes.node]}      ELSE        DO          [node: LOOPHOLE[p, Zone.Base RELATIVE POINTER], s: status] ¬            Zone.MakeNode[zH: h.zH, n: n];          SELECT status FROM            okay => EXIT;            noRoomInZone => ExpandMdsHeapInternal[h, PagesForNewSegment[n]];            ENDCASE => RETURN WITH ERROR Error[invalidHeap]          ENDLOOP;      EXITS        Error => RETURN WITH ERROR Error[savedError];      END;    END;  --MakeMdsNode--  FreeMDSNode: PUBLIC --Heap-- PROCEDURE [z: MDSZone, p: POINTER] =    BEGIN    IF p = NIL THEN RETURN;    FreeMdsNode[LOOPHOLE[z, MDSZoneRep].data, p];    END;  --FreeMDSNode--  FreeMdsNode: ENTRY PROCEDURE [h: LongMdsHandle, p: POINTER] =    BEGIN    ENABLE UNWIND => NULL;    IF h.ownerChecking THEN p ¬ p - ownerNameSize;    IF NodeSize[p] >= h.largeNodeThreshold THEN {      prev: LargeNode ¬ NIL;      largeNode: LargeNode ¬ h.largeNodes;      DO        IF largeNode = NIL THEN EXIT;        IF @largeNode.node = p THEN {          IF prev = NIL THEN h.largeNodes ¬ largeNode.next          ELSE prev.next ¬ largeNode.next;          h.currentSize ¬ h.currentSize - PagesForLargeNode[largeNode];	  IF h.volumeID # Volume.systemID THEN  -- delete file created	    BEGIN	    tempFileID: File.File = Space.GetMapUnitAttributes[p].window.file;	    [] ¬ Space.Unmap[p ! Space.Error => Bug[mappedAreaWentAway]];	    File.Delete[tempFileID ! File.Unknown => Bug[fileWeCreatedWentAway]];	    END	  ELSE	    [] ¬ Space.Unmap[p ! Space.Error => Bug[mappedAreaWentAway]];          RETURN};        prev ¬ largeNode;        largeNode ¬ largeNode.next;        ENDLOOP};    SELECT Zone.FreeNode[zH: h.zH, p: p] FROM      okay => NULL;      invalidNode => RETURN WITH ERROR Error[invalidNode];      ENDCASE => RETURN WITH ERROR Error[invalidHeap]    END;  --FreeMdsNode--  MakeUniformNode: ENTRY PROCEDURE [h: UniformHandle, n: NWords]     RETURNS [p: Node] =    BEGIN    savedType: Heap.ErrorType;      BEGIN ENABLE        BEGIN        Error => {savedType ¬ type; GOTO Error};        UNWIND => NULL;	END;      IF h.objectSize < n THEN RETURN WITH ERROR Error[invalidParameters];      IF h.free = NIL THEN ExpandUniformHeapInternal[h, h.increment, FALSE];      p ¬ h.free;      h.free ¬ p.next;      EXITS        Error => RETURN WITH ERROR Error[savedType];      END;    END;  --MakeUniformNode--  FreeUniformNode: ENTRY PROCEDURE [h: UniformHandle, p: Node] =    BEGIN    ENABLE UNWIND => NULL;    IF h.ownerChecking THEN p ¬ p - ownerNameSize;    IF h.checking THEN {      objectSize: CARDINAL ¬ AllocatedObjectSize[h];      base: Node;      FOR block: Block ¬ h.blocks, block.next DO        IF block = NIL THEN RETURN WITH ERROR Error[invalidNode];	base ¬ LOOPHOLE[block, Node] + SIZE[BlockObject];	IF p IN [base..base + block.length) THEN	  IF (p-base) MOD objectSize # 0 THEN RETURN WITH ERROR Error[invalidNode]          ELSE EXIT;	ENDLOOP};    p.next ¬ h.free;    h.free ¬ p;    END;  --FreeUniformNode--  AllocatedObjectSize: PROCEDURE [h: UniformHandle]     RETURNS [objectSize: CARDINAL] = {    objectSize ¬ h.objectSize;    IF h.ownerChecking THEN objectSize ¬ objectSize + ownerNameSize;    objectSize ¬ MAX[SIZE[Node], objectSize]};  GetAttributes: PUBLIC --Heap-- PROC [z: UNCOUNTED ZONE]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, ownerChecking, checking: BOOLEAN,      attributes: Heap.Attributes] = {    [heapPages: heapPages, maxSize: maxSize, increment: increment,      swapUnitSize: swapUnitSize, ownerChecking: ownerChecking,      checking: checking, attributes: attributes] ¬ NewGetAttributes[z]};  NewGetAttributes: PUBLIC --HeapExtras-- PROC [z: UNCOUNTED ZONE]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize, ownerChecking, checking: BOOLEAN,      volumeID: System.VolumeID, attributes: Heap.Attributes] =    BEGIN    handle: Handle = LOOPHOLE[z, UncountedZoneRep].data;    NormalAttributes: ENTRY PROCEDURE [h: NormalHandle] = INLINE      BEGIN ENABLE UNWIND => NULL;      savedType: Heap.ErrorType;        BEGIN        largeNodePages: Space.PageCount ¬ 0;        SpaceSize: PROCEDURE [sI: Space.Interval] =          {largeNodePages ¬ sI.count + largeNodePages};        EnumerateLargeNodes[h, SpaceSize ! Error => {savedType ¬ type; GOTO Error};];        attributes ¬ [normal[largeNodePages: largeNodePages,          threshold: h.threshold, largeNodeThreshold: h.largeNodeThreshold]];        heapPages ¬ h.currentSize;        swapUnitSize ¬ Space.SwapUnitSize[h.swapUnit];        increment ¬ h.increment;        maxSize ¬ h.maxSize;        ownerChecking ¬ h.ownerChecking;        checking ¬ h.checking;	volumeID ¬ h.volumeID;        EXITS           Error => RETURN WITH ERROR Error[savedType];	END;      END;    UniformAttributes: ENTRY PROCEDURE [h: UniformHandle] = INLINE      BEGIN ENABLE UNWIND => NULL;      attributes ¬ [uniform[objectSize: h.objectSize]];      heapPages ¬ h.currentSize;      swapUnitSize ¬ Space.SwapUnitSize[h.swapUnit];      increment ¬ h.increment;      maxSize ¬ h.maxSize;      ownerChecking ¬ h.ownerChecking;      checking ¬ h.checking;      volumeID ¬ h.volumeID;      END;    WITH h: handle SELECT FROM      normal => NormalAttributes[@h];      uniform => UniformAttributes[@h];      ENDCASE => ERROR Error[invalidHeap];    END;  --NewGetAttributes--     GetAttributesMDS: PUBLIC --Heap-- PROC [z: MDSZone]    RETURNS [      heapPages, largeNodePages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize,      threshold, largeNodeThreshold: Heap.NWords,      ownerChecking, checking: BOOLEAN] = {    [heapPages: heapPages, largeNodePages: largeNodePages, maxSize: maxSize,      increment: increment, swapUnitSize: swapUnitSize, threshold: threshold,      largeNodeThreshold: largeNodeThreshold, ownerChecking: ownerChecking,      checking: checking] ¬ NewGetAttributesMDS[z]};  NewGetAttributesMDS: PUBLIC --HeapExtras-- PROC [z: MDSZone]    RETURNS [      heapPages, largeNodePages, maxSize, increment: Environment.PageCount,      swapUnitSize: Space.SwapUnitSize,      threshold, largeNodeThreshold: Heap.NWords,      ownerChecking, checking: BOOLEAN, volumeID: System.VolumeID] =    BEGIN    MdsAttributes: ENTRY PROCEDURE [h: LongMdsHandle] = INLINE      BEGIN ENABLE UNWIND => NULL;      SpaceSize: PROCEDURE [sI: Space.Interval] =        {largeNodePages ¬ sI.count + largeNodePages};      largeNodePages ¬ 0;      EnumerateLargeNodes[h, SpaceSize !Error => {savedType ¬ type; GOTO Error};];      threshold ¬ h.threshold;      largeNodeThreshold ¬ h.largeNodeThreshold;      heapPages ¬ h.currentSize;      swapUnitSize ¬ Space.SwapUnitSize[h.swapUnit];      increment ¬ h.increment;      maxSize ¬ h.maxSize;      ownerChecking ¬ h.ownerChecking;      checking ¬ h.checking;      volumeID ¬ h.volumeID;      EXITS        Error => RETURN WITH ERROR Error[savedType];      END;    savedType: Heap.ErrorType;    MdsAttributes[LOOPHOLE[z, MDSZoneRep].data];    END;  --NewGetAttributesMDS--  Expand: PUBLIC --Heap-- PROCEDURE [    z: UNCOUNTED ZONE, pages: Space.PageCount] = {    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => ExpandNormalHeap[@h, pages];      uniform => ExpandUniformHeap[@h, pages];      ENDCASE => ERROR Error[invalidHeap]};  ExpandMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone, pages: Space.PageCount] = {    ExpandMdsHeap[LOOPHOLE[z, MDSZoneRep].data, pages]};  ExpandNormalHeap: ENTRY PROCEDURE [    h: NormalHandle, pages: Space.PageCount] = INLINE    BEGIN    ENABLE UNWIND => NULL;    savedType: Heap.ErrorType;    WHILE pages # 0 DO      n: CARDINAL ¬ CARDINAL[MIN[pages, maxPPS]];      [] ¬ ExpandNormalHeapInternal[h, n, extension !        Error => {savedType ¬ type; GOTO Error}];      pages ¬ pages - n;      REPEAT        Error => RETURN WITH ERROR Error[savedType];      ENDLOOP;    END;  --ExpandNormalHeap--  ExpandNormalHeapInternal: PROCEDURE [    h: NormalHandle, pages: Space.PageCount, initial: EnumeratedInitial]    RETURNS [zone: ZoneHandle] =    -- Add a segment of the specified size (or h.increment if that is larger) to h.    BEGIN    status: Zone.Status;    zH: Zone.Handle;    length: CARDINAL;    oldSize: Space.PageCount = h.currentSize;    IF initial = extension THEN pages ¬ MAX[pages, h.increment];    IF pages = 0 THEN GOTO InsufficientSpace;    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Error[maxSizeExceeded];      END;    length ¬ CARDINAL[pages*wpp] - SIZE[ZoneObject];    IF length > LAST[ZoneInternal.TemporaryBlocksize] THEN      -- TEMPORARY check for zones which are too large to create      ERROR Error[invalidSize];    zone ¬ MakeSpace[      Space.virtualMemory, pages, Space.SwapUnitSize[h.swapUnit], h.resident,      h.volumeID !        Space.InsufficientSpace => GOTO InsufficientSpace];    [zH: zH, s: status] ¬ Zone.Create[      storage: zone + SIZE[ZoneObject], length: length, zoneBase: zone,      threshold: h.threshold, checking: h.checking];    IF status ~= okay THEN ERROR Error[otherError];    zone­ ¬ [      next: h.zones.next, base: zone, zH: zH, length: length, initial: initial];    h.zones.next ¬ zone;    EXITS      InsufficientSpace => Error[insufficientSpace];    END;  --ExpandNormalHeapInternal--  ExpandUniformHeap: ENTRY PROCEDURE [    h: UniformHandle, pages: Space.PageCount] = INLINE    BEGIN    ENABLE UNWIND => NULL;    savedType: Heap.ErrorType;    WHILE pages # 0 DO      n: CARDINAL ¬ CARDINAL[MIN[pages, maxPPS]];      ExpandUniformHeapInternal[h, n, FALSE !        Error => {savedType ¬ type; GOTO Error}];      pages ¬ pages - n;      REPEAT        Error => RETURN WITH ERROR Error[savedType];      ENDLOOP;    END;  --ExpandUniformHeap--  ExpandUniformHeapInternal: PROCEDURE [    h: UniformHandle, pages: Space.PageCount, initial: BOOLEAN] =    BEGIN    block: Block;    oldSize: Space.PageCount = h.currentSize;    objectSize: CARDINAL ¬ AllocatedObjectSize[h];    IF ~initial THEN pages ¬ MAX[pages, h.increment];    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Error[maxSizeExceeded];      END;    block ¬ MakeSpace[      parent: Space.virtualMemory, pages: pages,      swapUnitSize: Space.SwapUnitSize[h.swapUnit],      resident: h.resident, volumeID: h.volumeID !         Space.InsufficientSpace => GOTO InsufficientSpace];    block­ ¬ [      next: h.blocks.next, length: CARDINAL[pages*wpp]-SIZE[BlockObject], initial: initial];    h.blocks.next ¬ block;    InitializeUniformBlock[h, block];    EXITS       InsufficientSpace => RETURN WITH ERROR Error[insufficientSpace];    END;  --ExpandUniformHeapInternal--  ExpandMdsHeap: ENTRY PROCEDURE [    h: LongMdsHandle, pages: Space.PageCount] = INLINE    BEGIN    ENABLE UNWIND => NULL;    savedType: Heap.ErrorType;    WHILE pages # 0 DO      n: CARDINAL ¬ CARDINAL[MIN[pages, maxPPS]];      ExpandMdsHeapInternal[h, pages !        Error => {savedType ¬ type; GOTO Error}];      pages ¬ pages - n;      REPEAT        Error => RETURN WITH ERROR Error[savedType];      ENDLOOP;    END;  --ExpandMdsHeap--  ExpandMdsHeapInternal: PROCEDURE [h: LongMdsHandle, pages: Space.PageCount] =    -- Add a segment of the specified size (or h.increment if that is larger) to h.    BEGIN    status: Zone.Status;    length: CARDINAL;    oldSize: Space.PageCount = h.currentSize;    pages ¬ MAX[pages, h.increment];    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Error[maxSizeExceeded];      END;    length ¬ CARDINAL[pages*Environment.wordsPerPage];    IF length > LAST[ZoneInternal.TemporaryBlocksize] THEN      -- TEMPORARY check for additional segments which are too large to make      RETURN WITH ERROR Error[invalidSize];    [sH:, s: status] ¬ Zone.AddSegment[      zH: h.zH,       storage: MakeSpace[Space.MDS[], pages, Space.SwapUnitSize[h.swapUnit],        h.resident, h.volumeID !          Space.InsufficientSpace => GOTO InsufficientSpace],      length: length];    IF status ~= okay THEN RETURN WITH ERROR Error[otherError];    EXITS      InsufficientSpace => RETURN WITH ERROR Error[insufficientSpace];    END;  --ExpandMdsHeapInternal--  Flush: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE] = {    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      normal => FlushNormalHeap[@h];      uniform => FlushUniformHeap[@h];      ENDCASE => ERROR Error[invalidHeap]};  FlushMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone] = {    FlushMdsHeap[LOOPHOLE[z, MDSZoneRep].data]};  FlushNormalHeap: ENTRY PROCEDURE [h: NormalHandle] =    BEGIN ENABLE UNWIND => NULL;    savedType: Heap.ErrorType;      BEGIN      hasSwapUnits: BOOLEAN = (h.swapUnit # defaultSwapUnit);      createdFiles: BOOLEAN = (h.volumeID # Volume.systemID);      status: Zone.Status;      zone, next, prev: ZoneHandle;      EnumerateLargeNodes[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap !        Error => {savedType ¬ type; GOTO Error}];      prev ¬ NIL;      h.largeNodes ¬ NIL;      h.currentSize ¬ 0;      FOR zone ¬ h.zones, next UNTIL zone = NIL DO        next ¬ zone.next;        IF zone.initial # extension THEN          BEGIN          [zH: h.zones.zH, s: status] ¬ Zone.Create[            storage: zone + SIZE[ZoneObject], length: zone.length,	    zoneBase: zone.base, threshold: h.threshold, checking: h.checking];          IF status ~= okay THEN RETURN WITH ERROR Error[otherError];	  h.currentSize ¬ h.currentSize + PagesForWords[zone.length];	  prev ¬ zone;	  END        ELSE          BEGIN          IF prev = NIL THEN h.zones ¬ next ELSE prev.next ¬ next;	  IF createdFiles THEN	    BEGIN	    tempFileID: File.File = Space.GetMapUnitAttributes[zone].window.file;	    [] ¬ Space.Unmap[zone ! Space.Error => Bug[mappedAreaWentAway]];	    File.Delete[tempFileID ! File.Unknown => Bug[fileWeCreatedWentAway]];	    END	  ELSE	    [] ¬ Space.Unmap[zone ! Space.Error => Bug[mappedAreaWentAway]];	  END;        ENDLOOP;      EXITS        Error => RETURN WITH ERROR Error[savedType];      END;    END;  --FlushNormalHeap--  FlushUniformHeap: ENTRY PROCEDURE [h: UniformHandle] =     BEGIN ENABLE UNWIND => NULL;    hasSwapUnits: BOOLEAN = (h.swapUnit # defaultSwapUnit);    createdFiles: BOOLEAN = (h.volumeID # Volume.systemID);    block, next, prev: Block;    prev ¬ NIL;    h.currentSize ¬ 0;    h.free ¬ NIL;    FOR block ¬ h.blocks, next UNTIL block = NIL DO      next ¬ block.next;      IF block.initial THEN        BEGIN        InitializeUniformBlock[h, block];	h.currentSize ¬ h.currentSize + PagesForWords[block.length];	prev ¬ block	END      ELSE        BEGIN        IF prev = NIL THEN h.blocks ¬ next ELSE prev.next ¬ next;	IF createdFiles THEN	  BEGIN	  tempFileID: File.File = Space.GetMapUnitAttributes[block].window.file;	  [] ¬ Space.Unmap[block ! Space.Error => Bug[mappedAreaWentAway]];	  File.Delete[tempFileID ! File.Unknown => Bug[fileWeCreatedWentAway]];	  END	ELSE	  [] ¬ Space.Unmap[block ! Space.Error => Bug[mappedAreaWentAway]];	END;      ENDLOOP;    END;  --FlushUniformHeap--  InitializeUniformBlock: PROCEDURE [h: UniformHandle, block: Block] =    BEGIN    lastNode, p, last: Node;    objectSize: CARDINAL ¬ AllocatedObjectSize[h];    p ¬ LOOPHOLE[block, Node] + SIZE[BlockObject];    lastNode ¬ p + block.length - objectSize;    p.next ¬ h.free;    DO      p ¬ (last ¬ p) + objectSize;      IF p > lastNode THEN EXIT;      p.next ¬ last;      ENDLOOP;    h.free ¬ last;    END;  --InitializeUniformBlock--      FlushMdsHeap: ENTRY PROCEDURE [h: LongMdsHandle] =    BEGIN    savedType: Heap.ErrorType;      BEGIN ENABLE        BEGIN        Error => {savedType ¬ type; GOTO Error};        UNWIND => NULL;	END;      status: Zone.Status;      pages: Space.PageCount = Space.GetMapUnitAttributes[h].interval.count;      createdFiles: BOOLEAN = (h.volumeID # Volume.systemID);      EnumerateLargeNodes[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];      EnumerateZoneAdditions[h, IF createdFiles THEN DeleteAndUnmap ELSE Unmap];      [zH: h.zH, s: status] ¬ Zone.Create[        storage: h + SIZE[mds Data], length: CARDINAL[pages*wpp]-SIZE[mds Data],        zoneBase: Space.MDS[].pointer, threshold: h.threshold,        checking: h.checking];      IF status ~= okay THEN ERROR Error[otherError];      h.largeNodes ¬ NIL;      EXITS        Error => RETURN WITH ERROR Error[savedType];      END;    END;  --FlushMdsHeap--  Prune: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE] = {};  PruneMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone] = {    PruneMdsHeap[LOOPHOLE[z, MDSZoneRep].data]};  PruneMdsHeap: ENTRY PROCEDURE [h: LongMdsHandle] = {    ENABLE UNWIND => NULL;    hasSwapUnits: BOOLEAN = (h.swapUnit # defaultSwapUnit);    createdFiles: BOOLEAN = (h.volumeID # Volume.systemID);    seg: LONG POINTER;    segH, nextSegH: Zone.SegmentHandle;    [next: nextSegH] ¬ Zone.GetAttributes[h.zH];    WHILE nextSegH ~= Zone.nullSegment DO      segH ¬ nextSegH;      [storage: seg, next: nextSegH] ¬ Zone.GetSegmentAttributes[h.zH, segH];      SELECT Zone.RemoveSegment[h.zH, segH].s FROM	okay => IF createdFiles THEN	          BEGIN		  tempFileID: File.File =		    Space.GetMapUnitAttributes[seg].window.file;		  [] ¬ Space.Unmap[seg ! Space.Error => Bug[mappedAreaWentAway]];		  File.Delete[tempFileID !		    File.Unknown => Bug[fileWeCreatedWentAway]];		  END		ELSE		  [] ¬ Space.Unmap[seg ! Space.Error => Bug[mappedAreaWentAway]];	nonEmptySegment => NULL;	ENDCASE => RETURN WITH ERROR Error[invalidHeap];      ENDLOOP};  CheckOwner: PUBLIC --Heap-- PROCEDURE [p: LONG POINTER, z: UNCOUNTED ZONE] = {    IF LOOPHOLE[z, UncountedZoneRep].data.ownerChecking THEN      IF p = NIL THEN ERROR Error[invalidNode]      ELSE IF (p - ownerNameSize)­ ~= FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]]        THEN ERROR Error[invalidOwner]};  CheckOwnerMDS: PUBLIC --Heap-- PROCEDURE [p: POINTER, z: MDSZone] = {    IF LOOPHOLE[z, MDSZoneRep].data.ownerChecking THEN      IF p = NIL THEN ERROR Error[invalidNode]      ELSE IF (p - ownerNameSize)­ ~= FrameExtras.LongGFToGFTHandle[        SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GetCaller[]]]        THEN ERROR Error[invalidOwner]};        OwnerChecking: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE]     RETURNS [BOOLEAN] = {    RETURN[LOOPHOLE[z, UncountedZoneRep].data.ownerChecking]};      OwnerCheckingMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone] RETURNS [BOOLEAN] = {    RETURN[LOOPHOLE[z, MDSZoneRep].data.ownerChecking]};      SetChecking: PUBLIC --Heap-- PROCEDURE [z: UNCOUNTED ZONE, checking: BOOLEAN] =    BEGIN    WITH h: LOOPHOLE[z, UncountedZoneRep].data SELECT FROM      uniform => h.checking ¬ checking;      normal => {        FOR zone: ZoneHandle ¬ h.zones, zone.next UNTIL zone = NIL DO          IF Zone.SetChecking[zH: zone.zH, checking: checking].s ~= okay THEN            ERROR Error[invalidHeap];          ENDLOOP;        h.checking ¬ checking};      ENDCASE => ERROR Error[invalidHeap];    END;  --SetChecking--  SetCheckingMDS: PUBLIC --Heap-- PROCEDURE [z: MDSZone, checking: BOOLEAN] = {    h: MdsHandle = LOOPHOLE[z, MDSZoneRep].data;    h.checking ¬ checking;    IF Zone.SetChecking[zH: h.zH, checking: checking].s ~= okay THEN      ERROR Error[invalidHeap]};  Error: PUBLIC --Heap-- ERROR [type: Heap.ErrorType] = CODE;  MakeResident: PUBLIC --SpecialHeap-- PROCEDURE [z: UNCOUNTED ZONE] = {    MakeResidentHeap[LOOPHOLE[z, UncountedZoneRep].data]};  MakeResidentMDS: PUBLIC --SpecialHeap-- PROCEDURE [z: MDSZone] = {    MakeResidentHeap[LOOPHOLE[z, MDSZoneRep].data]};  MakeResidentHeap: ENTRY PROCEDURE [h: Handle] =    BEGIN    ENABLE UNWIND => NULL;    MakeResident: PROCEDURE [sI: Space.Interval] =      {VM.MakeResident[[Space.PageFromLongPointer[sI.pointer], sI.count], wait]};    EnumerateLargeNodes[h, MakeResident];    EnumerateMajorZones[h, MakeResident];    EnumerateZoneAdditions[h, MakeResident];    h.resident ¬ TRUE;    END;  --MakeResidentHeap--  MakeSwappable: PUBLIC --SpecialHeap-- PROCEDURE [z: UNCOUNTED ZONE] =    {MakeSwappableHeap[LOOPHOLE[z, UncountedZoneRep].data]};  MakeSwappableMDS: PUBLIC --SpecialHeap-- PROCEDURE [z: MDSZone] =    {MakeSwappableHeap[LOOPHOLE[z, MDSZoneRep].data]};  MakeSwappableHeap: ENTRY PROCEDURE [h: Handle] =    BEGIN    ENABLE UNWIND => NULL;    MakeSwappable: PROCEDURE [sI: Space.Interval] =      BEGIN      VM.MakeSwappable[[Space.PageFromLongPointer[sI.pointer], sI.count]];      END;    EnumerateLargeNodes[h, MakeSwappable];    EnumerateMajorZones[h, MakeSwappable];    EnumerateZoneAdditions[h, MakeSwappable];    h.resident ¬ FALSE;    END;  --MakeSwappableHeap--  --  -- Miscellaneous  EnumerateMajorZones: PROCEDURE [    h: Handle, proc: PROCEDURE [sI: Space.Interval]] =    BEGIN    WITH hh: h SELECT FROM      uniform =>        BEGIN        block, next: Block;        FOR block ¬ hh.blocks, next UNTIL block = NIL DO          next ¬ block.next;          proc[sI: LPToInterval[block]];          ENDLOOP;        RETURN;	END;      normal =>        BEGIN        zone, next: ZoneHandle;        FOR zone ¬ hh.zones, next UNTIL zone = NIL DO          next ¬ zone.next;          proc[sI: LPToInterval[zone]];          ENDLOOP;        RETURN;	END;      mds => {proc[LPToInterval[h]]; RETURN};      ENDCASE => ERROR Error[invalidHeap];    END;  --EnumerateMajorZones--  EnumerateLargeNodes: PROCEDURE [    h: Handle, proc: PROCEDURE [sI: Space.Interval]] =    -- Call proc once for each large node    BEGIN    hasSwapUnits: BOOLEAN = (h.swapUnit ~= defaultSwapUnit);    node, next: LargeNode;    WITH hh: h SELECT FROM      uniform => RETURN;      normal => node ¬ hh.largeNodes;      mds => node ¬ hh.largeNodes;      ENDCASE => RETURN WITH ERROR Error[invalidHeap];    WHILE node # NIL DO        next ¬ node.next;        proc[LPToInterval[node]];        node ¬ next;        ENDLOOP;    END;  --EnumerateLargeNodes--  EnumerateZoneAdditions: PROCEDURE [    h: Handle, proc: PROCEDURE [sH: Space.Interval]] =    BEGIN    hasSwapUnits: BOOLEAN = h.swapUnit ~= defaultSwapUnit;    seg: LONG POINTER;    segH, nextSegH: Zone.SegmentHandle;    WITH hh: h SELECT FROM      uniform, normal => RETURN;      mds =>        BEGIN        [next: nextSegH] ¬ Zone.GetAttributes[hh.zH];	WHILE nextSegH ~= Zone.nullSegment DO	  segH ¬ nextSegH;	  [storage: seg, next: nextSegH] ¬ Zone.GetSegmentAttributes[hh.zH, segH];	  proc[LPToInterval[seg]]	  ENDLOOP;	END;      ENDCASE => ERROR Error[invalidHeap];    END;  --EnumerateZoneAdditions--  LPToInterval: PROCEDURE [p: LONG POINTER] RETURNS [Space.Interval] = INLINE    BEGIN    RETURN [Space.GetMapUnitAttributes[p].interval];    END;  --LPToInterval--  MakeLargeNode: PROCEDURE [h: Handle, n: NWords] RETURNS [largeNode: LargeNode] =    -- Make a space to hold a large node, and add it to h's largeNodes list.    BEGIN    parent: Space.Interval;    next: LargeNode;    pages: Space.PageCount = PagesForWords[n + SIZE[LargeNodeHeader]];    oldSize: Space.PageCount = h.currentSize;    IF (h.currentSize ¬ h.currentSize + pages) > h.maxSize THEN      BEGIN      h.currentSize ¬ oldSize;      ERROR Error[maxSizeExceeded];      END;    WITH hh: h SELECT FROM      normal => {parent ¬ Space.virtualMemory; next ¬ hh.largeNodes};      mds => {parent ¬ Space.MDS[]; next ¬ hh.largeNodes};      ENDCASE;    largeNode ¬ MakeSpace[      parent, pages, Space.SwapUnitSize[h.swapUnit], h.resident, h.volumeID !	Space.InsufficientSpace => GOTO InsufficientSpace];    largeNode­ ¬ [      next: next, nodeHeader: [length: n + nodeOverhead, extension: inuse[]],      node: NULL];    EXITS      InsufficientSpace => ERROR Error[insufficientSpace];    END;  --MakeLargeNode--  MakeSpace: PROCEDURE [    parent: Space.Interval, pages: Space.PageCount,    swapUnitSize: Space.SwapUnitSize, resident: BOOLEAN,    volumeID: System.VolumeID] RETURNS [LONG ORDERED POINTER] =    BEGIN    tempFile: File.File =      IF volumeID = Volume.systemID THEN File.nullFile      ELSE File.Create[volumeID, pages, FileTypes.tUntypedFile];      -- may raise Volume.InsufficientSpage, Volume.ReadOnly, and Volume.NotOpen    -- Make a data space, and perhaps (one level of) swap units.    sI: Space.Interval = Space.Allocate[count: pages, within: parent];    [] ¬ Space.MapAt[      at: sI, window: [tempFile, 0, pages], usage: KernelSpaceUsage.heap,      class: data, life: dead,      swapUnits:        IF (swapUnitSize = defaultSwapUnit) OR (pages <= 2*swapUnitSize) THEN	  [unitary[]]	ELSE [uniform[swapUnitSize]]];    IF resident THEN      VM.MakeResident[[Space.PageFromLongPointer[sI.pointer], sI.count], wait];    RETURN[LOOPHOLE[sI.pointer]];    END;  --MakeSpace--  Narrow: PROCEDURE [p: LONG POINTER] RETURNS [POINTER] = INLINE {    -- Convert a long pointer assumed to point into this mds into a short pointer.    -- recall MDS are 64K aligned    RETURN[LOOPHOLE[Inline.LowHalf[p]]]};  PagesForNewCreate: PROCEDURE [n: NWords] RETURNS [Space.PageCount] = INLINE {    RETURN[PagesForWords[SIZE[ZoneObject] + SIZE[ZoneInternal.ZoneHeader] + SIZE[inuse ZoneInternal.NodeHeader] + n + SIZE[free ZoneInternal.NodeHeader] + SIZE[inuse ZoneInternal.NodeHeader]]]};  PagesForNewSegment: PROCEDURE [n: NWords] RETURNS [Space.PageCount] = INLINE {    RETURN[PagesForWords[SIZE[ZoneInternal.SegmentHeader] + SIZE[inuse ZoneInternal.NodeHeader] + n + SIZE[free ZoneInternal.NodeHeader] + SIZE[inuse ZoneInternal.NodeHeader]]]};  PagesForLargeNode: PROCEDURE [    largeNode: LONG POINTER TO LargeNodeHeader] RETURNS [Space.PageCount] = INLINE    BEGIN    RETURN[PagesForWords[      largeNode.nodeHeader.length - nodeOverhead + SIZE[LargeNodeHeader]]];    END;  --PagesForLargeNode--  PagesForWords: PROCEDURE [n: NWords] RETURNS [Environment.PageCount] = INLINE    -- Calculate the number of whole pages to hold n words.    {RETURN[Space.PagesFromWords[n]]};      DeleteAndUnmap: PROCEDURE [sI: Space.Interval] =    BEGIN    tempFileID: File.File = Space.GetMapUnitAttributes[sI.pointer].window.file;    [] ¬ Space.Unmap[sI.pointer ! Space.Error => Bug[mappedAreaWentAway]];    File.Delete[tempFileID ! File.Unknown => Bug[fileWeCreatedWentAway]];    END;  --DeleteAndUnmap--    Unmap: PROCEDURE [sI: Space.Interval] = {[] ¬ Space.Unmap[sI.pointer]};  END.....May 23, 1980  1:45 PM	PXM    	Create fileJune 10, 1980  4:32 PM	PXM    	Convert back to AmargosaJune 11, 1980  2:54 PM	PXM    	Reconvert to Mesa 6June 30, 1980  4:38 PM	PXM    	Identify systemHeap with SystemMDSHeap if UtilityPilotJuly 8, 1980  5:06 PM	PXM    	Don't catch Space.InsufficientSpace in MakeSpaceJuly 19, 1980  3:40 PM	PXM    	New ZONE representation; fix bugs in large node detection and	shortening large node pointer in MakeMDSNode; store large node header	right in large nodeJuly 24, 1980  10:07 AM	PXM    	Identify systemHeap with SystemMDSHeap if UtilityPilot (again!)July  26, 1980  3:24 PM	FXH    	If UtilityPilot treat large MDS nodes same as if smallAugust 4, 1980  6:17 PM	PXM    	Large nodes and expansions of resident heap must be made resident;	EnumerateSpaces must be prepared for deletion of large node space;	repackage Expand for exportAugust 5, 1980  1:54 PM	PXM    	systemZONE=>SystemZone; delete {Make/Free}[MDS]String procedures made	inline in HeapDecember 22, 1980  1:20 PM	RXG   	Add RETURN WITH to ERRORs; remove default for Data.seal; make	systemMDSZone initialization use ¬ instead of = February 11, 1981  10:37 AM	RXG   	Avoid using Space.GetAttributes when not necessary in	SpaceFromLongPointer. February 12, 1981  6:48 PM	PXM    	Avoid using Space.GetAttributes in GetAttributes in UtilityPilot 19-Aug-81 18:32:31	AWL      	Determine "UtilityPilot"-ness from System rather than from switches.22-Aug-81 13:24:53	FXH    	add in '6 switch, add CheckOwnerMDS.	23-Dec-82 18:40:08	AWL      	Roll in Mesa group changes; convert to Klamath.  Their change history was:	JGS		22-Dec-82 13:48:24     	JGS		 7-Oct-82 14:04:22	LXR    		21-Oct-82 10:57:12	AXD    		28-Sep-82 18:18:55	RXJ     	28-Sep-82 10:47:32	RES  		27-Sep-82 15:09:05 4-Jan-83 16:31:59	JXP   Remove dependence on Pilot Type (i.e., IsUtilityPilot). Can Now create hyper heaps and allocate large nodes in UtilityPilot. Also, the systemZone is a hyper heap regardless of Pilot Type. 3-Mar-83  8:14:09	WDK        Handle SOME of the truncation warnings.31-Mar-83 11:34:01	AWL         Roll in the last of the Sierra changes.11-Apr-83 16:14:31	JXP      Fix truncation warnings. Get defaultSwapUnitSize and SwapUnitSize from Space,   not Heap.26-Apr-83 18:11:59	JXP      MakeSpace needs to set window.count when doing a MapAt to a data space.13-Jul-83 12:15:00	AWL         32-bit procedure descriptors - store a global frame handle for owner checking and not a PROGRAM.31-Aug-83 13:50:52	JXP      Get the owner checking stuff consistent - Always use SIZE[GlobalFrameHandle].11-Oct-83 15:22:22	EKN      AR Fixes:  Fix entry procedures so they let go of the monitor lock when an error occurs.  Make CheckOwner and CheckOwnerMDS check for NIL and raise an appropiate error.  Fix MakeSpace so it uses unitary swap units more often.12-Dec-83 14:05:38	AXD       Include support for new pilot switches controlling parameters of system zone.28-Dec-83 12:35:30	EKN     Changed HeapInternal.initial to enumerated type so could fix FreeNormalNode to calculate correct overhead. 3-Feb-84 17:40:08      KEK        Implemented checkEmpty function of Delete and DeleteMDS, including adding IsUniformEmpty.17-Sep-85 16:46:32      RSV    Added procedure PagesForNewCreate to figure overhead for a Zone.Create and changed PagesForNewSegment to only include segment overhead for Zone.AddSegment.  Also added checks in Create, CreateMDS, MakeNormalNode, MakeMdsNode, ExpandNormalHeapInternal, and ExpandMdsHeapInternal for invalidSize to be raised.23-Oct-85 11:25:10      RSV    AR 6178 fix about incrementing the currentSize of a heap even when the operation requested is not performed.30-Jun-86 10:14:24      RSV    Implemented ^ switch.25-Aug-86 17:08:08      RSV    Fixed copyright notice.12-Feb-87 15:00:08      RSV    Converted to MDS relief (changed CreateMDS).18-Mar-87 14:16:36      RSV    Can't just do Runtime.GetCaller.  Must use GFTHandles. 7-Jul-87 16:55:04      RSV    Allow for alternate volumes for creation and getting attributes of heaps (AR 6688).  Loop in Expand*Heap for AR 3627.26-Sep-87 17:43:16      RSV    Fix bug in FlushUniformHeap and FlushMdsHeap (= to #) for AR 12007
-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- ResMemMgr>VMDataImpl.mesa     21-Sep-88 11:58:05 by TxH   --Implements most data base access and maintenance operations for VM. Mapping-related operations are implemented by VMDataMapImpl.<<WARNINGS:Procedure Calls:   Since vmDataLock is required to process a frame fault, it is required that any code which holds this lock may only call coroutines and inline procedures. Furthermore, the coroutines must not have more than 14 words of arguments or results, as this would also cause the allocation of a local frame. If this rule were not followed, we could take a frame fault while holding the lock, and the frame fault process would deadlock waiting for the monitor lock. See also comments in ResMemMgr.config and StateVectorManagement.press.   There are procedures in this module which run inside vmDataLock.  They are implemented as coroutines because it is critical that we never take a frame fault while holding vmDataLock, since it is the VMData implementation itself that is invoked to satisfy a frame fault.  Thus these coroutines themselves must also never call procedures which are not INLINEs or coroutines.  Large argument and results records:   Since no frame allocations may occur when vmDataLock is held, the coroutines must not have more than 14 words of arguments or results, as this would also cause the allocation of a local frame. To determine if there are any such, make a code listing and look for occurrences of the "AF" instruction.If the above two rules were not followed, we could take a frame fault while holding the lock, and the frame fault process would deadlock waiting for the monitor lock. See also comments in ResMemMgr.config and StateVectorManagement.press.WAITs:   It is critical that vmDataLock NEVER be released from a coroutine (by WAITing); otherwise, more than one process could execute within the coroutine's single local frame.>>DIRECTORY  BackingStore USING [Data, TransferProc],  Environment USING [maxPagesInMDS, PageCount, PageNumber, wordsPerPage],  Frame USING [GetReturnFrame, SetReturnFrame],  KernelSpaceUsage USING [runTable, vmDataImplBuffer],  MStore USING [    AddReserved, Allocate, AllocateIfFree, Deallocate, IfReservedLow, SubtractReserved],  PageMap USING [    ExchangeFlags, Flags, flagsVacant, IsMapped, RealPageNumber, SetMapFlags],  PrincOps USING [ControlLink, Port],  Process USING [    DisableAborts, DisableTimeout, MsecToTicks, Priority, SetTimeout],  ProcessPrioritiesExtras USING [priorityPageFaultLow],  ResMemPerf USING [],  RuntimeInternal USING [Bug, WorryCallDebugger],  Space USING [    Access, Life, LongPointerFromPage, PagesFromWords, SwapUnitType,    unknownUsage, Usage],  StoragePrograms USING [AllocateVM, countVM],  VM USING [    AdjustReservedRealMemory, DoneWithStateVector, GuardStateVector, Interval,    nullInterval, nullPage, PageCount, PageNumber, Swappability],  VMData USING [CheckOutData, ProcessType, NewState, State],  VMDataInternal USING [    Continuation, Find, GetTransferProc, InitializeVMDataMapImplA,    InitializeVMDataMapImplB, InitializeVMDataUtilitiesA,    InitializeVMDataUtilitiesB, IsReservedMemory, minCountRun, ProcessSwapUnits,    PRun, pRunFirst, Run, RunBase, runBeingProcessed, RunTable,    SwapUnitProcessor, SwapUnitState, TransferProcID];VMDataImpl: MONITOR LOCKS vmDataLock  IMPORTS    Frame, MStore, PageMap, Process, RuntimeInternal,    Space, StoragePrograms, VM--inlines--, VMDataInternal  EXPORTS ResMemPerf, StoragePrograms, VM, VMData, VMDataInternal  SHARES PageMap, VMData =  BEGIN  OPEN VMDataInternal;  -- PARAMETERS:  maxVictimSearchPasses: CARDINAL = 100;  -- max number of passes through virtual memory looking for something to swap out before we announce that there is none.  reservedMStoreAllocations: PUBLIC --ResMemPerf-- CARDINAL ¬ 0;  vmDataLock: PUBLIC MONITORLOCK;  swapUnitCheckedInOrUnmapped: PUBLIC CONDITION;  pageTop: VM.PageNumber = FIRST[VM.PageNumber] + StoragePrograms.countVM;  --end of VM  DEBUG: BOOLEAN ¬ FALSE;  --for initial debugging    wordsPerPage: CARDINAL = Environment.wordsPerPage;  Bug: PROCEDURE [bugType: BugType] = INLINE {RuntimeInternal.Bug[bugType]};  BugType: TYPE = {    funnyCase, invalidInterval, notEnoughReclaimed, notCheckedOut, noVictim,    processSwapUnitsError, runTableSmashed, somebodyDidntAbort, wasntCheckedOut};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Run Data   (exported to VMDataInternal)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  runBase: PUBLIC RunBase;  RunTable: TYPE = VMDataInternal.RunTable;  --for debugger  pageRunTable: PUBLIC VM.PageNumber;  countRunTablePagesMapped: PUBLIC CARDINAL;  pRunTop: PUBLIC PRun;  pRunMaxInRealMem: PUBLIC PRun;  pRunMaxInVM: PUBLIC PRun;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Temporaries for PageMap manipulation  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The following variables are for short-term temporary use by anybody.  pageFlags: PageMap.Flags;  realPageNumber: PageMap.RealPageNumber;  pageBuffer: PUBLIC --VMDataInternal.-- VM.PageNumber;  -- for MStore.Dealocate'ing.  pageBufferPtr: PUBLIC --VMDataInternal.-- LONG POINTER ¬    Space.LongPointerFromPage[pageBuffer];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --  Variables used to communicate between swap unit processing routines and their callers:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  swapUnitState: SwapUnitState;  swapUnitStatus: VMData.NewState;  changeStatusInterval: VM.Interval;  pageIn: BOOLEAN;  checkOutStartPage: VM.PageNumber;  -- Used by CheckOutSwapUnits, FindDirtyUnreferenced and their swapUnitProcessors  checkOutEndPage: VM.PageNumber;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --Data for FindDirtyUnreferenced and swap unit processors  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- FindDirtyUnreferenced pauses for breath:  aMinuteTime: CARDINAL = 10000; --milliseconds--  --Basic tick of interval timer.  aMinute: CONDITION;  -- an interval timer.  pageNextAged: VM.PageNumber ¬ 0;  -- page next to be aged. Updated by FindDirtyUnreferenced, and DeallocateClean.    swapoutWholeSwapUnit: BOOLEAN ¬ FALSE;  -- TRUE means swap out all of an unreferenced swap unit irregardless of the demand for real memory.  swapOutPagesReclaimed: PUBLIC --ResMemPerf.-- LONG CARDINAL ¬ 0;  -- The following are "arguments" and "results" of FindUnrefdDirtyAndReclaimAndAge  -- WARNING: Only FindDirtyUnreferenced may use these variables  -- because it may release the monitor lock.  freePagesNeeded: VM.PageCount;  pagesReclaimed: VM.PageCount;  swapoutPad: VM.PageCount ¬ 4;  unreferencedInterval: VM.Interval;  twicer: BOOLEAN ¬ TRUE;cleanPagesAfterVictim: Environment.PageCount;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeVMDataA: PUBLIC  --StoragePrograms.    ENTRY --so it can call internal procedures-- PROCEDURE =    -- Initializes all of VMData except those items depending on    -- the ResidentHeap facilities (namely the transferProcTable).    -- On return, AllocateReservedMStore is operational.    BEGIN    --Initializes the databases and backs them with a minimum amount of real memory.    --Initializes all coroutines in this module and calls into VMDataImplPrivate to initialize its coroutines.    bunchOfZeroes: ARRAY [0..SIZE[BackingStore.Data]) OF WORD = [      0, 0, 0, 0, 0, 0, 0];  --[ALL[0]]; ++ TEMP UNTIL AR 12465 is fixed    countRunTablePages: CARDINAL;  --amount of VM allocated for run table      --amount of VM allocated for run table.  Limited to amount addressable via a      -- 16-bit relative pointer    countRunTableRuns: LONG CARDINAL ¬ StoragePrograms.countVM/5;      -- amount of runs allocated for run table.      -- this number is determined experimentally, and is close to 3000 for Pilot 12.0.    -- Initialization for run table:    -- Figure out how many pages of VM are needed; get VM;    --  note re above: [6Jan86] replace use of "countRunPad" with the new    --  "countRunTableRuns", to make size of run table a function    --  of the size of VM.  "countRunPad" is used nowhere else.    -- Back part of it with real memory; get pointer to table;    -- Set limit pointers; and initialize first entry for Find routine    countRunTablePages ¬  MIN[   -- (VM pages not more than 256 pages)      CARDINAL[Space.PagesFromWords[        MAX[LONG[minCountRun], countRunTableRuns]*SIZE[Run]]],      Environment.maxPagesInMDS-1]; -- don't let 16-bit relative pointers overflow!    pageRunTable ¬ StoragePrograms.AllocateVM[      countRunTablePages, hyperspace, KernelSpaceUsage.runTable,      partiallyOrSometimesMapped];    countRunTablePagesMapped ¬ 1;  --number of run table pages currently mapped    MStore.Allocate[      interval: [page: pageRunTable, count: countRunTablePagesMapped],      resident: TRUE];    runBase ¬ Space.LongPointerFromPage[pageRunTable];    pRunMaxInRealMem ¬      FIRST[PRun] + countRunTablePagesMapped*wordsPerPage;    pRunMaxInVM ¬ FIRST[PRun] + countRunTablePages*wordsPerPage;    runBase[pRunFirst - SIZE[Run]] ¬ [  --initialize dummy entry at head of table      interval: VM.nullInterval, usage: Space.unknownUsage, class: unknown,      transferProcID: FIRST[TransferProcID], startOfMapUnit: TRUE, maybePartlyIn: TRUE,      endOfMapUnit: TRUE, backingData: [bunchOfZeroes],      swapUnitData: unitary[[available, [readOnly, alive, swappable]]]];    -- Initialize Top entry:    pRunTop ¬ pRunFirst;    runBase[pRunTop] ¬ [      interval: [pageTop, 0], usage: Space.unknownUsage, class: unknown,      transferProcID: FIRST[TransferProcID], startOfMapUnit: TRUE, maybePartlyIn: TRUE,      endOfMapUnit: TRUE, backingData: [bunchOfZeroes],      swapUnitData: unitary[  -- This entry MUST have no swap unit data (i.e. be unitary).      [available, [readOnly, alive, swappable]]]];    pageBuffer ¬ StoragePrograms.AllocateVM[      1, hyperspace, KernelSpaceUsage.vmDataImplBuffer,      partiallyOrSometimesMapped];          Process.SetTimeout[@aMinute, Process.MsecToTicks[aMinuteTime]];  -- we set the timeout only once so that we do not need to swap in the Process code.    Process.DisableAborts[@aMinute];    Process.DisableAborts[@swapUnitCheckedInOrUnmapped];    Process.DisableTimeout[@swapUnitCheckedInOrUnmapped];    -- Initialization of coroutines:    [] ¬ InitializeApproveReserved[];    [] ¬ InitializeCountReservedMemory[];    [] ¬ InitializeCheckInAndChangeStatus[];    [] ¬ InitializeCheckOutUnlessAlreadyCheckedOut[];    [] ¬ InitializeClearReferencedBitsOfAvailableSwappablePages[];    [] ¬ InitializeDeallocateCleanInSwapUnit[];    [] ¬ InitializeFindUnrefdDirtyAndReclaimAndAge[];    [] ¬ InitializeAllocateReservedMStoreInternal[];    -- Other modules:    InitializeVMDataUtilitiesA[];    InitializeVMDataMapImplA[];  -- InitializeVMDataUtilitiesA must preceed (exported variables).    END;  InitializeVMDataB: PUBLIC --StoragePrograms.-- PROCEDURE = {    InitializeVMDataUtilitiesB[]};      InitializeVMDataC: --NOT ENTRY-- PUBLIC --StoragePrograms.-- PROCEDURE = {    InitializeVMDataMapImplB[]};<<-- commented out 15-Nov-84 14:41:45 since it seems to cause more harm than good.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- AgingProcess  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The AgingProcess runs in bursts, triggered by agingTicks.  It scans  -- all of virtual memory, resetting the referenced-bits of the page flags  -- of swappable vm.  It divides vm into a number of "chunks",  -- where a chunk is the amount of vm it processes each time it wakes up.    -- globals.  priorityAgingProcess: Process.Priority = ProcessPrioritiesExtras.priorityPageFaultLow;  stopAgingProcess: BOOLEAN ¬ FALSE;  -- TRUE means suspend aging process (for debugging)  swapperDidAging: BOOLEAN ¬ FALSE;  -- TRUE when FindDirtyUnreferenced is called. AgingProcess will reset and not age if TRUE  agingTickTime: CARDINAL = 10000; --milliseconds--  --Basic tick of the Aging process timer.  chunksPerPass: CARDINAL = 32;  -- a pass through the table is broken into chunks.  The purpose is to spread the computational overhead out over time, and to limit the time that the table is locked.    -- --Initialization for AgingProcess: (code in InitializeVMDataA)  -- throwAway: PROCESS;  --used in FORKing AgingProcess  -- myPriority: Process.Priority;  --used for FORKing of AgingProcess  -- Process.SetTimeout[@agingTick, Process.MsecToTicks[agingTickTime]];  -- IF System.switches[  --   PilotSwitchesExtraExtraExtras.forkAgingProcess] = down THEN  --     BEGIN  --     Process.DisableAborts[@agingTick];  --     myPriority ¬ Process.GetPriority[];  --     Process.SetPriority[priorityAgingProcess];  --     throwAway ¬ FORK AgingProcess[];  -- no profit in detaching.  --     Process.SetPriority[myPriority];  --     END;  AgingProcess: ENTRY PROCEDURE[] =    BEGIN    pageLastAged: VM.PageNumber;  --where the current aging scan stops    pRun: PRun;    found: BOOLEAN;    DO      --FOREVER-- WAIT agingTick;      IF swapperDidAging THEN {swapperDidAging ¬ FALSE; LOOP};      IF stopAgingProcess OR runBase[pRunFirst].interval.page = pageTop THEN LOOP;  -- (run table empty)      -- Process next chunk:      DO  --UNTIL pageNextAged is in a mapped run        IF pageNextAged >= pageTop THEN pageNextAged ¬ FIRST[VM.PageNumber];        [found, pRun] ¬ Find[pageNextAged, runBase, pRunTop];        IF NOT found THEN pageNextAged ¬ runBase[pRun].interval.page;        --UNTIL-- IF pRun < pRunTop THEN EXIT;        ENDLOOP;      -- Find out where we stop on this scan:      pageLastAged ¬ runBase[        MIN[        pRunTop,  -- not past top entry        pRun +          MAX[            1,  -- do one chunk's worth of runs (at least one run)            (pRunTop - pRunFirst)/(SIZE[Run]*chunksPerPass)]*SIZE[            Run]]].interval.page;      pageNextAged ¬ ProcessSwapUnits[        [page: pageNextAged, count: pageLastAged - pageNextAged], skipUnmapped,        spanRuns, ClearReferencedBitsOfAvailableSwappablePages, skipVacant].nextPage;      ENDLOOP;  --FOREVER--    END;  --AgingProcess--    >>  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- AllocateReservedMStoreInternal  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AllocateReservedMStoreInternal: PUBLIC --VMData PRIVATE-- PROCEDURE [    interval: VM.Interval, resident: BOOLEAN];      -- an indirect control link to the PORT is set in InitializeAllocateReservedMStoreInternal  InitializeAllocateReservedMStoreInternal: INTERNAL PROCEDURE =    BEGIN        AwaitAllocateReservedMStoreInternalRequest: --RESPONDING-- PORT      RETURNS [interval: VM.Interval, resident: BOOLEAN];      -- args/results match AllocateReservedMStoreInternal (but swapped).          --arguments:    intervalRemaining: VM.Interval;    resident: BOOLEAN;    countAllocated: VM.PageCount;    passes: CARDINAL;    pRun: PRun;    someDeallocated: BOOLEAN;    AllocateReservedMStoreInternal ¬      LOOPHOLE[LONG[@AwaitAllocateReservedMStoreInternalRequest]];    -- set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitAllocateReservedMStoreInternalRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return;  Await new request;  Process it;      [intervalRemaining, resident] ¬ AwaitAllocateReservedMStoreInternalRequest[];      Frame.SetReturnFrame[  -- for debugger        LOOPHOLE[AwaitAllocateReservedMStoreInternalRequest, PrincOps.Port].dest.frame];      -- Loops on alternating requests to MStore.AllocateIfFree      -- to allocate real memory and to DeallocateCleanInSwapUnit      -- until it has obtained enough real memory.      DO  --UNTIL whole interval allocated--        countAllocated ¬ MStore.AllocateIfFree[	  interval: intervalRemaining, resident: resident];        intervalRemaining ¬ [          page: intervalRemaining.page + countAllocated,          count: intervalRemaining.count - countAllocated];        --UNTIL-- IF intervalRemaining.count = 0 THEN EXIT;        -- Deallocation of clean memory is needed.        -- We resume where aging last left off, or first page        -- following it if it is now unmapped:        IF pageNextAged >= pageTop THEN pageNextAged ¬ FIRST[VM.PageNumber];        DO          pRun ¬ Find[pageNextAged, runBase, pRunTop].pRun;          --UNTIL-- IF pRun < pRunTop THEN EXIT;          pageNextAged ¬ FIRST[VM.PageNumber];          ENDLOOP;        passes ¬ 0;        DO  --until deallocated some pages          [aborted: someDeallocated] ¬ ProcessSwapUnits[            [page: pageNextAged, count: pageTop - pageNextAged], skipUnmapped,            spanRuns, DeallocateCleanInSwapUnit];          -- (DeallocateCleanInSwapUnit updates pageNextAged.)          IF someDeallocated THEN EXIT;          --ASSERT: Processed all the way to the end of memory.          pageNextAged ¬ runBase[pRunFirst].interval.page;          IF (passes ¬ passes.SUCC) > 2 THEN            -- Implementation note: strings used here are kept in the            -- global frame so we can better see where storage is            -- being spent. (The local frames are resident anyway,            -- so putting them there wouldn't save anything.)            RuntimeInternal.WorryCallDebugger[              "All memory pinned, busy, or dirty"G];          ENDLOOP;        ENDLOOP;  --UNTIL whole interval allocated--      reservedMStoreAllocations ¬ reservedMStoreAllocations.SUCC;      ENDLOOP;  --FOREVER--    END;  --InitializeAllocateReservedMStoreInternal--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CheckInSwapUnits  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --Implementation note. CheckInSwapUnits uses global "temporaries" swapUnitStatus and changeStatusInterval and pageIn.  It doesn't check to see that swapUnits are checked out: it assumes that the caller knows what he's doing.   The monitor lock is held for duration of the operation: therefore, the use of shared global variables is safe.  -- An AddReserved is done at the end to pick up the new reserved memory count after all is said and done.  CheckInSwapUnits: PUBLIC ENTRY PROCEDURE [    pResult: POINTER TO VMData.CheckOutData, changeInterval: VM.Interval,    newState: VMData.NewState, pageReadIn: BOOLEAN] =    BEGIN    interval: VM.Interval = pResult.intervalCheckedOut;    aborted: BOOLEAN;    pageRemaining: VM.PageNumber;    pageIn ¬ pageReadIn;    IF interval.count = 0 THEN RETURN;    IF changeInterval.count # 0 AND changeInterval.page < interval.page      OR changeInterval.page + changeInterval.count >        interval.page + interval.count THEN Bug[invalidInterval];    --set globals which need to be accessed by the swapUnitProcessor      swapUnitStatus ¬ newState;    changeStatusInterval ¬ changeInterval;    [pageRemaining, aborted] ¬ ProcessSwapUnits[      interval, errorIfUnmapped, errorIfSpansRuns, CheckInAndChangeStatus];    IF DEBUG AND (aborted OR pageRemaining < interval.page + interval.count) THEN      Bug[processSwapUnitsError];  --"aborted" should never be TRUE; in DEBUG mode we check for this.    pResult.state ¬ swapUnitState.st;    MStore.AddReserved[CountReservedMemory[pResult.state, interval]];       BROADCAST swapUnitCheckedInOrUnmapped;    END;  --CheckInSwapUnits   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CheckInAndChangeStatus: SwapUnitProcessor  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Other actual arguments: changeStatusInterval, swapUnitStatus, swapUnitState.  -- Checks the given swap unit into the database.  -- If the swap unit is wholly or partially contained  -- in changeStatusInterval, also sets the swap unit's state  -- to swapUnitStatus.    CheckInAndChangeStatus: SwapUnitProcessor;  -- indirect control link to port is set in InitializeCheckInAndChangeStatus  InitializeCheckInAndChangeStatus: INTERNAL PROCEDURE    RETURNS [state: SwapUnitState, continuation: Continuation] =    BEGIN    pageSwapUnit, pageAfterSwapUnit: VM.PageNumber;        AwaitCheckInAndChangeStatusRequest: --RESPONDING-- PORT [      newState: SwapUnitState, continuation: Continuation]      RETURNS [        pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];      --args/results match CheckInAndChangeStatus (but swapped)      CheckInAndChangeStatus ¬ LOOPHOLE[LONG[@AwaitCheckInAndChangeStatusRequest]];    LOOPHOLE[AwaitCheckInAndChangeStatusRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    --set my PORT call to return to my caller on call below    DO  --FOREVER--      -- Return results; Await new request; Process it      [pageSwapUnit, pageAfterSwapUnit, state] ¬        AwaitCheckInAndChangeStatusRequest[        newState: state, continuation: continue];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitCheckInAndChangeStatusRequest, PrincOps.Port].dest.frame];      IF state.availability # busy THEN Bug[notCheckedOut];      state.availability ¬ available;      VMDataInternal.runBeingProcessed.maybePartlyIn ¬         VMDataInternal.runBeingProcessed.maybePartlyIn OR pageIn;      IF (changeStatusInterval.count # 0)        AND          (pageSwapUnit < changeStatusInterval.page + changeStatusInterval.count)        AND (pageAfterSwapUnit > changeStatusInterval.page) THEN        BEGIN        WITH a: swapUnitStatus.newAccess SELECT FROM          unchanged => NULL;          setTo => state.st.access ¬ a.access;          ENDCASE => Bug[funnyCase];        WITH s: swapUnitStatus.newSwappability SELECT FROM          unchanged => NULL;          setTo => state.st.swappability ¬ s.swappability;          ENDCASE => Bug[funnyCase];        WITH l: swapUnitStatus.newLife SELECT FROM          unchanged => NULL;          setTo => state.st.life ¬ l.life;          ENDCASE => Bug[funnyCase];        END;      swapUnitState ¬ state;      ENDLOOP;  --DO FOREVER--    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CheckOutSwapUnits  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CheckOutSwapUnits bumps up the reserved memory pool until CheckOutSwapUnitsInternal says it is big enough, and then CheckOutSwapUnitsInternal does the thing:  -- Checking out swap units *removes them from the reserved memory pool*.  -- NOTE:  If in the course of checking out swap units,it is found that a swap unit is busy, a WAIT on swapUnitCheckedInOrUnmapped will be performed and the monitor lock released.  In order that the system not deadlock, before releasing the monitor lock, it is necessary to re-mark those swap units just checked out as available.  -- Implementation note: an alternative here would have been to do a preliminary scan to insure that the entire sub-interval was available before setting the status bits to busy.  This was not adopted in view of the fact that the expected case is that the interval will not contain busy swap units and that the method of backing out is therefore the more efficient solution.    CheckOutSwapUnits: PUBLIC PROCEDURE [    pResult: POINTER TO VMData.CheckOutData, interval: VM.Interval] =    BEGIN    retry: BOOLEAN;    reservedRequired: Environment.PageCount;    [retry, reservedRequired] ¬ CheckOutSwapUnitsInternal[pResult, interval];    WHILE retry DO      IF reservedRequired > 0 THEN       {VM.AdjustReservedRealMemory[reservedRequired, add];        VM.AdjustReservedRealMemory[reservedRequired, subtract]};      [retry, reservedRequired] ¬ CheckOutSwapUnitsInternal[pResult, interval];      ENDLOOP;    END; --CheckOutSwapUnits--  CheckOutSwapUnitsInternal: PUBLIC ENTRY PROCEDURE [    pResult: POINTER TO VMData.CheckOutData, interval: VM.Interval]    RETURNS [retry: BOOLEAN ¬ FALSE, reservedRequired: Environment.PageCount ¬ 0] =    BEGIN    --global "temporaries" used:  swapUnitState, checkOutStartPage, checkOutEndPage    pRun: PRun;    found: BOOLEAN;    checkedOutInterval: VM.Interval;    IF interval.count = 0 THEN GOTO NoSuchSwapUnits;       DO  -- until all required swap units are available for processing      [found, pRun] ¬ Find[interval.page, runBase, pRunTop];      IF NOT found        AND runBase[pRun].interval.page >= interval.page + interval.count THEN        GOTO NoSuchSwapUnits;      checkOutStartPage ¬ VM.nullPage;      [] ¬ ProcessSwapUnits[        interval, skipUnmapped, abortWhenSpansRuns,        CheckOutUnlessAlreadyCheckedOut];      checkedOutInterval ¬ [        page: checkOutStartPage, count: checkOutEndPage - checkOutStartPage];      IF checkOutStartPage # VM.nullPage    --we're done        AND swapUnitState.availability = available THEN	BEGIN --try to remove it from the reserved pool	reservedRequired ¬ CountReservedMemory[swapUnitState.st, checkedOutInterval];        IF NOT ApproveReserved[pResult.processType, reservedRequired] THEN retry ¬ TRUE        ELSE EXIT; --we're ~really~ done	END;      -- we need to back out and try again...      -- Check-in everybody who was checked-out      IF checkOutStartPage # VM.nullPage OR retry THEN        [] ¬ ProcessSwapUnits[          checkedOutInterval, skipUnmapped, errorIfSpansRuns, CheckInAndChangeStatus];      IF retry THEN RETURN;      WAIT swapUnitCheckedInOrUnmapped;      ENDLOOP;    BEGIN    activeIntervalPage: VM.PageNumber ¬ MAX[checkOutStartPage, interval.page];    activeIntervalEndPage: VM.PageNumber ¬ MIN[      checkOutEndPage, interval.page + interval.count];    pResult­ ¬ [      activeInterval: [        page: activeIntervalPage,        count: activeIntervalEndPage - activeIntervalPage],      activeIntervalEnd: activeIntervalEndPage,      intervalCheckedOut: checkedOutInterval,      state: [        access: swapUnitState.st.access,        life: swapUnitState.st.life,        swappability: swapUnitState.st.swappability],      processType: pResult.processType,      pageRun: runBase[pRun].interval.page,      backingData: runBase[pRun].backingData,      transferProc: GetTransferProc[runBase[pRun].transferProcID]];    END;    EXITS NoSuchSwapUnits => pResult.intervalCheckedOut ¬ VM.nullInterval;    END;  --CheckOutSwapUnitsInternal--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CheckOutUnlessAlreadyCheckedOut  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Other actual arguments:  -- checkOutStartPage: if VM.nullPage on entry, it means this is the first swap unit to be checked out  -- other actual results:  -- checkOutStartPage: if VM.nullPage on return, no swap units were checked out, and the value returned for checkOutEndPage is meaningless; otherwise it is the first page of the first swap unit checked out.  -- checkOutEndPage: page following last swap unit checked out  -- swapUnitState: state of all swap units checked out.  If processing was aborted because of a busy swap unit, swapUnitState.availability will = busy.  -- Checks out swap unit if not already checked out and same state as previous ones checked out.  -- If the swap unit is already checked out, returns ABORT ¬ TRUE.  CheckOutUnlessAlreadyCheckedOut: SwapUnitProcessor;  -- indirect control link to port is set in InitializeCheckOutUnlessAlreadyCheckedOut  InitializeCheckOutUnlessAlreadyCheckedOut: INTERNAL PROCEDURE    RETURNS [state: SwapUnitState, continuation: Continuation] =    BEGIN    pageSwapUnit, pageAfterSwapUnit: VM.PageNumber;  --"arguments"        AwaitCheckOutUnlessAlreadyCheckedOutRequest: --RESPONDING-- PORT [      newState: SwapUnitState, continuation: Continuation]      RETURNS [	pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];      -- args/results must match CheckOutUnlessAlreadyCheckedOut (but swapped)     CheckOutUnlessAlreadyCheckedOut ¬       LOOPHOLE[LONG[@AwaitCheckOutUnlessAlreadyCheckedOutRequest]];    LOOPHOLE[AwaitCheckOutUnlessAlreadyCheckedOutRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    --set my PORT call to return to my caller on call below    DO  --FOREVER--      --return; await new request; process it      [pageSwapUnit, pageAfterSwapUnit, state] ¬        AwaitCheckOutUnlessAlreadyCheckedOutRequest[        newState: state, continuation: continuation];      Frame.SetReturnFrame[        LOOPHOLE[AwaitCheckOutUnlessAlreadyCheckedOutRequest,        PrincOps.Port].dest.frame];      IF state.availability = busy THEN {        swapUnitState.availability ¬ busy; continuation ¬ abortIgnoreNewState}      ELSE        BEGIN  --available--        IF checkOutStartPage = VM.nullPage THEN          BEGIN          checkOutStartPage ¬ pageSwapUnit;          swapUnitState ¬ state;  --and available          END;        IF state = swapUnitState THEN          BEGIN          checkOutEndPage ¬ pageAfterSwapUnit;          state.availability ¬ busy;          continuation ¬ continue;          END        ELSE continuation ¬ abortIgnoreNewState;  -- ended by different state        END;  --available--      ENDLOOP;  --DO FOREVER--    END;  --CheckOutUnlessAlreadyCheckedOut      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- ApproveReserved  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- reserveRequired is the number of pages that must be SubtractReserved'd before starting an I/O op.  -- Based on processType, this proc asks or demands the pages from the reserved pool.  --    If okay=TRUE is returned, the reserved pool will have been decremented by reserveRequired.  --    If okay=FALSE, no additional reserved pages will have been SubtractReserved'd (the client should not check out these pages).  -- Used by CheckOutSwapUnits; inited by InitializeVMDataA.    ApproveReserved: PROCEDURE [    processType: VMData.ProcessType, reservedRequired: Environment.PageCount]    RETURNS [okay: BOOLEAN];  -- an indirect control link to the port is set in InitializeApproveReserved      InitializeApproveReserved: INTERNAL PROCEDURE RETURNS [okay: BOOLEAN] =    BEGIN    --"arguments"    processType: VMData.ProcessType;    reservedRequired: Environment.PageCount;        AwaitApproveReservedRequest: --RESPONDING-- PORT [okay: BOOLEAN]      RETURNS [      processType: VMData.ProcessType, reservedRequired: Environment.PageCount];      --args/results match ApproveReserved (but swapped)        ifReservedLow: MStore.IfReservedLow;    ApproveReserved ¬ LOOPHOLE[LONG[@AwaitApproveReservedRequest]];    LOOPHOLE[AwaitApproveReservedRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    --set my PORT call to return to my caller on call below    DO  --FOREVER--      -- Return results; Await new request; Process it      [processType, reservedRequired] ¬        AwaitApproveReservedRequest[okay];      Frame.SetReturnFrame[  -- for debugger.      LOOPHOLE[AwaitApproveReservedRequest, PrincOps.Port].dest.frame];      SELECT processType FROM        client => ifReservedLow ¬ returnIfLow;        helper => ifReservedLow ¬ doAnyway;        ENDCASE => Bug[funnyCase];      okay ¬ MStore.SubtractReserved[reservedRequired, ifReservedLow].ok;    ENDLOOP; --DO FOREVER--    END;  --ApproveReserved--   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- CountReservedMemory  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Returns the number of reserved pages in interval.  -- Used by CheckInSwapUnits; inited by InitializeVMDataA.    CountReservedMemory: PROCEDURE [state: VMData.State, interval: VM.Interval]    RETURNS [reservedRequired: Environment.PageCount];  -- an indirect control link to the port is set in InitializeCountReservedMemory      InitializeCountReservedMemory: INTERNAL PROCEDURE    RETURNS [reservedRequired: Environment.PageCount] =    BEGIN    --"arguments"    state: VMData.State;    interval: VM.Interval;    -- local variables    page: Environment.PageNumber;        AwaitCountReservedMemoryRequest:      --RESPONDING-- PORT [reservedRequired: Environment.PageCount]      RETURNS [state: VMData.State, interval: VM.Interval];      --args/results match CountReservedMemory (but swapped)          CountReservedMemory ¬ LOOPHOLE[LONG[@AwaitCountReservedMemoryRequest]];    LOOPHOLE[AwaitCountReservedMemoryRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    --set my PORT call to return to my caller on call below    DO  --FOREVER--      -- Return results; Await new request; Process it      [state, interval] ¬        AwaitCountReservedMemoryRequest[reservedRequired];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitCountReservedMemoryRequest, PrincOps.Port].dest.frame];            reservedRequired ¬ 0;      IF IsReservedMemory[state] THEN          FOR page IN [interval.page..interval.page+interval.count) DO            IF PageMap.IsMapped[page] THEN            -- DANGER OF OVERFLOW HERE!              reservedRequired ¬ SUCC[reservedRequired];            ENDLOOP;      ENDLOOP; --DO FOREVER--    END;  --CountReservedMemory--   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- ClearReferenceBitsOfAvailableSwappablePages  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Resets the referenced bits on all pages of available swappable swap units.  -- SwapUnitProcessor for the AgingProcess  ClearReferencedBitsOfAvailableSwappablePages: SwapUnitProcessor;  -- an indirect control link to the port is set in   -- InitializeClearReferencedBitsOfAvailableSwappablePages  InitializeClearReferencedBitsOfAvailableSwappablePages: INTERNAL PROCEDURE    RETURNS [state: SwapUnitState, continuation: Continuation] =    BEGIN    pageSwapUnit, pageAfterSwapUnit: VM.PageNumber;  --"arguments"        AwaitClearReferencedBitsOfAvailableSwappablePagesRequest: --RESPONDING-- PORT [      newState: SwapUnitState, continuation: Continuation]      RETURNS [        pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];      --args/results match ClearReferencedBitsOfAvailableSwappablePages (but swapped)    ClearReferencedBitsOfAvailableSwappablePages ¬      LOOPHOLE[LONG[@AwaitClearReferencedBitsOfAvailableSwappablePagesRequest]];    LOOPHOLE[AwaitClearReferencedBitsOfAvailableSwappablePagesRequest,      PrincOps.Port].dest ¬ PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    --set my PORT call to return to my caller on call below    DO  --FOREVER--      --return; await new request; process it      [pageSwapUnit, pageAfterSwapUnit, state] ¬        AwaitClearReferencedBitsOfAvailableSwappablePagesRequest[        newState: state, continuation: continue];      Frame.SetReturnFrame[        LOOPHOLE[AwaitClearReferencedBitsOfAvailableSwappablePagesRequest,        PrincOps.Port].dest.frame];      IF state.availability = available AND state.st.swappability = swappable THEN        BEGIN        assert: BOOLEAN [TRUE..TRUE] = (PageMap.flagsVacant.referenced = FALSE);        -- This code assumes that resetting the referenced of a vacant page        -- still result in flagsVacant if the page was vacant.        -- This code also assumes that NO value of PageMap.Flags will become        -- flagsVacant when its referenced bit is reset.  This is not the case        -- if flags = [writeProtected, dirty, referenced].  Therefore, no        -- swappable pages may be both readOnly and dirty (or this code        -- would make such pages mysteriously become vacant).        FOR page: VM.PageNumber IN [pageSwapUnit..pageAfterSwapUnit) DO          [oldState: [flags: pageFlags], real: realPageNumber] ¬            PageMap.ExchangeFlags[page, PageMap.flagsVacant];  --(momentarily unmaps)          pageFlags.referenced ¬ FALSE;          PageMap.SetMapFlags[            virtual: page, real: realPageNumber, flags: pageFlags];          ENDLOOP;        END;      ENDLOOP;  --FOREVER--    END;  --ClearReferencedBitsOfAvailableSwappablePages   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- DeallocateCleanInSwapUnit: SwapUnitProcessor  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- If any pages of the swap unit are available, swappable, and clean, then deallocates their real memory and aborts; otherwise just returns.  -- Updates the global pageNextAged as it processes.  DeallocateCleanInSwapUnit: SwapUnitProcessor;  -- an indirect control link to the port is set in InitializeDeallocateCleanInSwapUnit  InitializeDeallocateCleanInSwapUnit: INTERNAL PROCEDURE    RETURNS --matches port args-- [      state: SwapUnitState, continuation: Continuation] =    BEGIN        AwaitDeallocateCleanInSwapUnitRequest: --RESPONDING-- PORT [      newState: SwapUnitState, continuation: Continuation]      RETURNS [        pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];      -- args/results match DeallocateCleanInSwapUnit but reversed          --"arguments" to SwapUnitProcessor:    pageSwapUnit, pageAfterSwapUnit: VM.PageNumber;    --local variables:    page: VM.PageNumber;    reservedCounter: CARDINAL;     DeallocateCleanInSwapUnit ¬ LOOPHOLE[LONG[@AwaitDeallocateCleanInSwapUnitRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitDeallocateCleanInSwapUnitRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      --Return;  Await new request;  Process it      [pageSwapUnit, pageAfterSwapUnit, state] ¬        AwaitDeallocateCleanInSwapUnitRequest[state, continuation];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitDeallocateCleanInSwapUnitRequest, PrincOps.Port].dest.frame];      continuation ¬ continue;  -- assume.      reservedCounter ¬ 0;      IF state.availability = available AND state.st.swappability = swappable THEN  --look for clean pages        FOR page IN [pageSwapUnit..pageAfterSwapUnit) DO 	  [oldState: [flags: pageFlags], real: realPageNumber] ¬            PageMap.ExchangeFlags[page, PageMap.flagsVacant];          IF pageFlags # PageMap.flagsVacant THEN            BEGIN            IF NOT pageFlags.dirty THEN              BEGIN  --deallocate it              PageMap.SetMapFlags[                virtual: pageBuffer, real: realPageNumber, flags: pageFlags];              MStore.Deallocate[[page: pageBuffer, count: 1], notPromised];	      --keep track of reserved stuff Deallocate removes!	      IF IsReservedMemory[state.st] THEN reservedCounter ¬ reservedCounter + 1;              continuation ¬ abortIgnoreNewState;              END            ELSE              BEGIN  --just continue work of aging process              pageFlags.referenced ¬ FALSE;              PageMap.SetMapFlags[                virtual: page, real: realPageNumber, flags: pageFlags];              END;            END;          ENDLOOP;      [] ¬ MStore.SubtractReserved[reservedCounter, doAnyway];      pageNextAged ¬ pageAfterSwapUnit;  -- Always, since swap unit was aged.      ENDLOOP;  --FOREVER--    END;  --InitializeDeallocateCleanInSwapUnit  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- FindDirtyUnreferenced  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  FindDirtyUnreferenced: PUBLIC ENTRY PROCEDURE [    pResult: POINTER TO VMData.CheckOutData, freeNeeded: Environment.PageCount] =    BEGIN    waitPasses: CARDINAL = 2;    pagesReclaimedForMe: VM.PageCount ¬ 0;    pass: CARDINAL ¬ 0;    cleanPagesAfterVictim ¬ 0;    DO  --until enough mem reclaimed or dirtyUnref'd is found--      aborted: BOOLEAN;      nextPage: VM.PageNumber;      IF pageNextAged >= pageTop THEN         BEGIN        pageNextAged ¬ FIRST[VM.PageNumber];	twicer ¬ ~twicer;	END;      -- Set "arguments" of FindUnrefdDirtyAndReclaimAndAge:      freePagesNeeded ¬ freeNeeded;      unreferencedInterval.count ¬ 0;      pagesReclaimed ¬ 0;      [nextPage, aborted] ¬ ProcessSwapUnits[        [page: pageNextAged, count: pageTop - pageNextAged], skipUnmapped,        spanRuns, FindUnrefdDirtyAndReclaimAndAge, skipVacant];      swapOutPagesReclaimed ¬ swapOutPagesReclaimed + pagesReclaimed;      pagesReclaimedForMe ¬ pagesReclaimedForMe + pagesReclaimed;      IF --UNTIL-- pagesReclaimedForMe >= freeNeeded + swapoutPad        OR unreferencedInterval.count > 0 THEN EXIT;      --ASSERT: Processed all the way to the end of vm (to pageTop).      IF DEBUG AND nextPage # pageTop THEN Bug[processSwapUnitsError];      pageNextAged ¬ FIRST[VM.PageNumber];  -- wrap around to start.      twicer ¬ ~twicer;      pass ¬ pass + 1;      IF (pass MOD waitPasses) = 0 THEN        BEGIN        -- There may be some swap units that are checked out but        -- waiting to be checked in. We go to sleep for a while        -- to allow them a chance to get checked in.         WAIT aMinute;        IF pass >= maxVictimSearchPasses THEN          RuntimeInternal.WorryCallDebugger[            "Insufficient swappable memory" --G-- ];        END;      ENDLOOP;  -- until enough mem reclaimed or dirtyUnref'd is found--    --ASSERT: pagesReclaimedForMe >= freeNeeded AND/OR unreferencedInterval.count > 0.    IF unreferencedInterval.count = 0 THEN {      IF DEBUG AND pagesReclaimedForMe < freeNeeded THEN Bug[notEnoughReclaimed];      pResult­.intervalCheckedOut.count ¬ 0}  -- Reclaimed enough.    ELSE      BEGIN  --unreferencedInterval.count > 0      pRun: PRun;      found: BOOLEAN;      [found, pRun] ¬ Find[unreferencedInterval.page, runBase, pRunTop];      IF DEBUG AND NOT found THEN Bug[runTableSmashed];      IF DEBUG THEN        BEGIN  --check that really checked out--        VerifyCheckedOut: SwapUnitProcessor = {          --[pageSwapUnit, pageAfterSwapUnit, state] RETURNS [newState, continuation]          -- A real proc since just a bear trap.          IF state.availability # busy THEN Bug[wasntCheckedOut];          RETURN[newState: state, continuation: continue]};        [] ¬ ProcessSwapUnits[          unreferencedInterval, errorIfUnmapped, spanRuns, VerifyCheckedOut];        END;  --check that really checked out--      pResult­ ¬ [        activeInterval: unreferencedInterval,        activeIntervalEnd: unreferencedInterval.page + unreferencedInterval.count,        intervalCheckedOut: [          page: checkOutStartPage,	  count: checkOutEndPage - checkOutStartPage],        state: [	  access: readWrite,          swappability: swappable,          life: alive],	processType: pResult.processType,        pageRun: runBase[pRun].interval.page,        backingData: runBase[pRun].backingData,        transferProc: GetTransferProc[runBase[pRun].transferProcID]];      END;    END;  --FindDirtyUnreferenced  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- FindUnrefdDirtyAndReclaimAndAge  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  <<  Other actual arguments:  freePagesNeeded,    unreferencedInterval.count (client-initialized to 0),    pagesReclaimed (client-initialized to 0).  Other actual results: unreferencedInterval, pagesReclaimed,    checkOutStartPage, checkOutEndPage.  Scans swap units for runs of available swappable dirty unreferenced pages,    reclaiming available swappable unreferenced clean pages and    continuing aging (and updating pageNextAged) as it does.  If available swappable unreferenced dirty pages are found,    their containing swap units are checked out and processing aborts.    The returned unreferencedInterval, checkOutStartPage, and checkOutEndPage    describes them (unreferencedInterval.count > 0).    NOTE: Processing will not be aborted if unreferencedInterval    is the last interval in vm; therefore, the returned value    of aborted is not useful to the caller.  If available swappable unreferenced clean pages are found,    they are deallocated and pagesReclaimed is tallied.    If pagesReclaimed becomes >= freePagesNeeded, processing aborts.    NOTE: Even though pagesReclaimed is >= freePagesNeeded,    unreferencedInterval.count may be > 0. This interval must be processed    by the caller even though there was enough memory reclaimed..  >>  FindUnrefdDirtyAndReclaimAndAge: SwapUnitProcessor;  -- (indirect control link to port)  InitializeFindUnrefdDirtyAndReclaimAndAge: INTERNAL PROCEDURE    RETURNS [state: SwapUnitState, continuation: Continuation] =    BEGIN        AwaitFindUnrefdDirtyAndReclaimAndAgeRequest:  --RESPONDING--      PORT [newState: SwapUnitState, continuation: Continuation]      RETURNS [        pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];      --args/results match FindUnrefdDirtyAndReclaimAndAge (but swapped)        --"arguments"      pageSwapUnit, pageAfterSwapUnit: VM.PageNumber;  -- local variables          unreferencedIntervalsRun: LONG POINTER TO Run;        FindUnrefdDirtyAndReclaimAndAge ¬       LOOPHOLE[LONG[@AwaitFindUnrefdDirtyAndReclaimAndAgeRequest]];    -- Set my PORT call to return to my caller on call below:    LOOPHOLE[AwaitFindUnrefdDirtyAndReclaimAndAgeRequest, PrincOps.Port].dest ¬      PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];    DO  --FOREVER--      -- Return; await new request; process it:      [pageSwapUnit, pageAfterSwapUnit, state] ¬        AwaitFindUnrefdDirtyAndReclaimAndAgeRequest[        newState: state, continuation: continuation];      Frame.SetReturnFrame[  -- for debugger.        LOOPHOLE[AwaitFindUnrefdDirtyAndReclaimAndAgeRequest,        PrincOps.Port].dest.frame];      continuation ¬ continue;  -- assume.      IF state.availability = busy OR state.st.swappability = resident        OR          (unreferencedInterval.count > 0            AND VMDataInternal.runBeingProcessed # unreferencedIntervalsRun) THEN        BEGIN        IF unreferencedInterval.count > 0 THEN  --          continuation ¬ abortIgnoreNewState  -- leave aging of s.u. till next time.        ELSE pageNextAged ¬ pageAfterSwapUnit;        END      ELSE        BEGIN  --available AND swappable--        -- Note: This procedure wants to resume at the page        -- last processed, but ProcessSwapUnits passes to it the swap unit        -- CONTAINING this page. If we want to avoid reprocessing a page just        -- examined, we need this test. It is, of course, possible that        -- ProcessSwapUnits handle this case, but more efficient to handle it at        -- as low a level as possible. (Similar issue arises in the AgingProcess,        -- but because of the large size of the "chunks" processed at a time,        -- relative to the small size of swap units, this isn't so critical).        FOR page: VM.PageNumber IN          [MAX[pageSwapUnit, pageNextAged]..pageAfterSwapUnit) DO          [oldState: [flags: pageFlags], real: realPageNumber] ¬            PageMap.ExchangeFlags[page, PageMap.flagsVacant];  --(no-op if already vacant)           BEGIN  --scope of TerminateIfCollecting--          -- RULE: Every path through the logic below must either add to          --   the run of dirty unreferenced or go to TerminateIfCollecting.          SELECT TRUE FROM            pageFlags = PageMap.flagsVacant => GO TO TerminateIfCollecting;            pageFlags.referenced =>  -- referenced page              BEGIN  --continue work of the AgingProcess              pageFlags.referenced ¬ FALSE;              PageMap.SetMapFlags[                virtual: page, real: realPageNumber, flags: pageFlags];              GO TO TerminateIfCollecting;              END;            pageFlags.dirty =>  -- dirty unreferenced page              BEGIN              PageMap.SetMapFlags[                virtual: page, real: realPageNumber, flags: pageFlags];	      IF twicer THEN GO TO TerminateIfCollecting;              IF DEBUG AND unreferencedInterval.count > 0                AND page # unreferencedInterval.page + unreferencedInterval.count                THEN Bug[somebodyDidntAbort];              -- page begins or continues the existing unreferencedInterval.              state.availability ¬ busy;              checkOutEndPage ¬ pageAfterSwapUnit;              IF unreferencedInterval.count = 0 THEN                BEGIN  -- start collecting dirty unreferenced pages                unreferencedInterval ¬ [page, 0];                unreferencedIntervalsRun ¬ VMDataInternal.runBeingProcessed;                checkOutStartPage ¬ pageSwapUnit;                END;              -- Add to run of dirty unreferenced pages:	      unreferencedInterval.count ¬ page - unreferencedInterval.page + 1;              cleanPagesAfterVictim ¬ 0;              IF unreferencedInterval.count >= LAST[Environment.PageCount]		OR ((NOT swapoutWholeSwapUnit)		AND unreferencedInterval.count + pagesReclaimed		  >= freePagesNeeded + swapoutPad)	        THEN GO TO TerminateIfCollecting;		pageNextAged ¬ page + 1;              END;            ENDCASE =>  -- clean unreferenced page              BEGIN	      IF unreferencedInterval.count = 0 THEN	        BEGIN		PageMap.SetMapFlags[                virtual: pageBuffer, real: realPageNumber, flags: pageFlags];	      	MStore.Deallocate[[page:pageBuffer, count:1], notPromised];	        IF IsReservedMemory[state.st] THEN [] ¬ MStore.SubtractReserved[		  countSubtracted: 1, ifReservedLow: doAnyway]; --as per Deallocate!                pagesReclaimed ¬ pagesReclaimed + 1;		GO TO TerminateIfCollecting;		END;	      PageMap.SetMapFlags[                virtual: page, real: realPageNumber, flags: pageFlags];	      cleanPagesAfterVictim ¬ cleanPagesAfterVictim + 1;	      state.availability ¬ busy;              checkOutEndPage ¬ pageAfterSwapUnit;	      IF pagesReclaimed + cleanPagesAfterVictim + unreferencedInterval.count >= freePagesNeeded + swapoutPad THEN                GO TO TerminateIfCollecting;              END;          EXITS            TerminateIfCollecting =>              BEGIN              pageNextAged ¬ page + 1;	      IF unreferencedInterval.count > 0 THEN	        BEGIN		continuation ¬ abortUseNewState;		EXIT;		END;	      IF pagesReclaimed + cleanPagesAfterVictim >= freePagesNeeded + swapoutPad THEN {                continuation ¬ abortUseNewState; EXIT};              END;  --available AND swappable--          END;  --scope of TerminateIfCollecting--          ENDLOOP;  --pages of swap unit--        END;  --available AND swappable--      ENDLOOP;  --FOREVER--    END;  --FindUnrefdDirtyAndReclaimAndAge  Kill: PUBLIC --VM.-- --EXTERNAL-- PROCEDURE [interval: VM.Interval] =    BEGIN    KillAndReclaim: SwapUnitProcessor =      --[pageSwapUnit, pageAfterSwapUnit, state] RETURNS [newState, continuation]      LOOPHOLE[LONG[@AwaitKillAndReclaimRequest]];        -- (indirect control link to port)      AwaitKillAndReclaimRequest:  --RESPONDING--      PORT [newState: SwapUnitState, continuation: Continuation]      RETURNS [        pageSwapUnit, pageAfterSwapUnit: VM.PageNumber, state: SwapUnitState];        --args/results match KillAndReclaim (but swapped)        InitializeAwaitKillAndReclaimRequest: -- INTERNAL -- PROCEDURE      RETURNS [state: SwapUnitState, continuation: Continuation] =      BEGIN      pageSwapUnit, pageAfterSwapUnit: VM.PageNumber ¬ TRASH;  --"arguments"      thisIsLeader, thisIsTrailer: BOOLEAN ¬ TRASH;      LOOPHOLE[AwaitKillAndReclaimRequest, PrincOps.Port].dest ¬        PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]];      DO  --UNTIL Done--        -- Return; await new request; process it:	[pageSwapUnit, pageAfterSwapUnit, state] ¬          AwaitKillAndReclaimRequest[	    newState: state, continuation: continuation];	Frame.SetReturnFrame[  -- for debugger.          LOOPHOLE[AwaitKillAndReclaimRequest,          PrincOps.Port].dest.frame];	IF lastCall THEN RETURN; -- reclaiming our frame!	continuation ¬ continue; -- Assume	IF state.availability = busy THEN -- checked out so abort and try again	  {continuation ¬ abortIgnoreNewState; LOOP};	thisIsLeader ¬ (pageSwapUnit < interval.page);	thisIsTrailer ¬ (pageAfterSwapUnit > intervalEnd);	IF state.st.swappability = swappable THEN	  BEGIN	  deallocateInterval: VM.Interval;	  deallocateInterval.page ¬ MAX[interval.page, pageSwapUnit];	  deallocateInterval.count ¬	    MIN[intervalEnd, pageAfterSwapUnit] - deallocateInterval.page;	  [] ¬ MStore.SubtractReserved[ --becuz about to Deallocate!	    CountReservedMemory[state.st, deallocateInterval], doAnyway];	  MStore.Deallocate[deallocateInterval,notPromised];	  END;	IF (NOT thisIsLeader) AND	   (NOT thisIsTrailer) AND	   (state.st.access = readWrite) THEN	  --interior, writable swapUnit--	  state.st.life ¬ dead;        ENDLOOP;  --UNTIL Done--      END;  --InitializeAwaitKillAndReclaimRequest--    KillEntry: ENTRY PROCEDURE =      BEGIN      WHILE currentPage < intervalEnd DO	aborted: BOOLEAN ¬ TRASH; -- TRUE only if a swap unit was checked out	[nextPage: currentPage, aborted: aborted] ¬	  ProcessSwapUnits[	    [page: currentPage, count: intervalEnd-currentPage],	    skipUnmapped, spanRuns, KillAndReclaim];	IF aborted THEN WAIT swapUnitCheckedInOrUnmapped;	ENDLOOP;      lastCall ¬ TRUE;      [] ¬ KillAndReclaim[TRASH, TRASH, TRASH]; -- get back the port's frame      END;    intervalEnd: Environment.PageNumber = interval.page+interval.count;    lastCall: BOOLEAN ¬ FALSE;    currentPage: Environment.PageNumber ¬ interval.page;    priorityPrev: Process.Priority;    [] ¬ InitializeAwaitKillAndReclaimRequest[]; -- alloc frame, initialize PORT    priorityPrev ¬ VM.GuardStateVector[ProcessPrioritiesExtras.priorityPageFaultLow];    KillEntry[]; -- acquire monitor to actually do the work    VM.DoneWithStateVector[priorityPrev];    END;  END.LOG 7-Sep-82 21:52:04   LXD      	Created file for Klamath.28-Oct-82 14:14:46   WDK     	Made compatible with new PageMap. 8-Nov-82 11:16:20   WDK        Put no progress detector in FindUnreferenced. FindUnrefdDirtyAndReclaimAndAge needed to span runs. Misc small improvements.24-Nov-82 13:38:23   WDK        AgingProcess computed end of batch wrong. GetAvailability disappears. AbortIfCheckedOut renamed to AbortIfUnavailableRecord and moved to VMDataUtilities. FindUnrefdDirtyAndReclaimAndAge didn't abort when dirty run was last in vm, confusing FindDirtyUnreferenced. FindUnrefdDirtyAndReclaimAndAge must terminate run of unref'd dirty on hitting new run. FindUnrefdDirtyAndReclaimAndAge can terminate by finding victim AND freeing enough mem, confusing FindDirtyUnreferenced. 3-Dec-82 11:02:07   WDK     	Made compatible with new VMDataInternal.22-Dec-82 16:22:40   AWL         NewSpace => Space, PilotSpaceUsage => KernelSpaceUsage.  Long page numbers.14-Jan-83 14:57:05   WDK     	Map wouldn't grow run table. 4-Mar-83 10:00:38   WDK         AllocateReservedMStoreInternal fails to check for wraparound early enough.DeallocateCleanInSwapUnit no longer a nested coroutine. AllocateReservedMStoreInternal looped if no swap units in chosen interval. Make CheckOutSwapUnits[interval.count=0] faster. 7-Apr-83 16:46:18   WDK        FindUnrefdDirty didn't always check out the last dirty swap unit. Use new abortUseNewState option to fix it. Add reservedMStoreAllocations.28-Apr-83 13:41:11   WDK     	Export perf variables to ResMemPerf.20-Jun-83  9:19:36   JXG    	Add InitializeVMDataC12-Jul-83 17:16:16   JXP   	Fix up the port stuff.19-Sep-83 17:41:12   AWL      	Implement VM.Kill using swap unit processors.20-Sep-83  9:07:17   AWL      	Kill should take note of checked out things. 7-Oct-83 15:12:46   WDK     	Kill must guard state vector. 8-Oct-83 15:57:44   CXH   	Kill should not be ENTRY.  8-Feb-84 16:10:40  EKN  	Add skipVacant to call on ProcessSwapUnits in AgingProcess.  Change DEBUG to FALSE (otherwise system deadlocks with a procedure call) in FindDirtyUnreferenced.   14-May-84 16:47:17  KAM     	InitializeFindUnrefdDirtyAndReclaimAndAge was collecting for swap out any run of dirty unreferenced pages regardless of the number of pages needed. Changed to terminate run when have enough reclaimed pages.   15-May-84 16:34:31  KAM     	Added support for Pilot switch doNotForkAgingProcess. FindDirtyUnreferenced now stops AgingProcess for one chunk.   16-May-84 11:37:30  KAM     	Changed sense of switch to forkAgingProcess. Added BOOLEANs stopAgingProcess and swapoutWholeSwapUnit (defaults to both FALSE).   18-Jun-84 13:30:34  KEK    	Added pageReadIn argument to CheckInSwapUnits. Added pageIn global to CheckInAndChangeStatus.   26-Jul-84 13:31:01  KEK    	Moved in ApproveReserved and CountReservedMemory (aka CountReservedTails) from VMUtilities.  Made CheckInSwapUnits and CheckOutSwapUnits do all the reserved memory messing.  Use processType now in VMData.CheckOutData. remove memType from Deallocate.  Kludge in calls to SubtractReserved after non-checked-out Deallocates. Update swapUnitState in CheckInAndChangeStatus.   Also moved Process.SetTime ~outside~ of the AgingProcess init-IF (fixes some AR or other...)   17-Aug-84 11:10:24  KEK    	add "resident" argument to MStore.Allocate and AllocateReservedMStore (for PC emulation) .    4-Jun-85 17:53:12  AWL    	KillEntry called a procedure (InitializeAwaitKillAndReclaimRequest) from inside the monitor - a violation of the monitor invariant.    16-Oct-85  RRR  Modified FindDirtyUnreferenced and FindUnrefdDirtyAndReclaimAndAge to allow clean unreferenced pages within the swap interval.  Also added a hysteresis pad.    6-Jan-86 14:38:29  KEK	add countRunTableRuns to make size of run table a function of the size of VM.  countRunPad is now obsoleted, and can be removed from the interface.   19-Feb-86 10:14:35  KEK	enforce 256-page limit size in run table, which the previous fix allowed exceeded.  The 256page limit is cuz the run table is pointed to by short pointers.   20-Feb-86 10:30:05  KEK	make the new 256 page limit on the runtable really be 255.10-Jul-86 17:36:21	ET	move PORTS out of global frames into local frames. 14-Jan-87 23:20:20	ET	Change ProcessPriorities to ProcessPrioritiesExtras.21-Sep-88 11:58:05     TxH	made changes for microcoded Find
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- UserTerminalImpl.mesa   27-Aug-85 17:31:18 by CAJ    -- This is currently crocked to use CreateForCode instead of Create to avoid a bug in the CSL display microcode that can't cross 64K boundaries!!-- The monitor of this module covers most operations.  Since Beep shares no data with the rest of the implementation here, it has its own monitor lock and its own monitor data.DIRECTORY  BeepFace,  BitBlt USING [BBTable],  DisplayFace,  DriverStartChain USING [Start],  Environment USING [BitAddress, PageCount, PageNumber],  File USING [nullFile],  KernelSpaceUsage USING [displayBitmap],  KeyboardFace,  MouseFace,  Process USING [EnableAborts, MsecToTicks, Priority, SetTimeout],  ProcessInternal USING [GetPriority, SetPriority],  ProcessPriorities USING [priorityPageFaultIO],  PSB USING [ConditionVariable],  ResidentHeap USING [MakeNode],  Runtime USING [CallDebugger],  Space USING [    Allocate, Error, Interval, MapAt, nullInterval, PageFromLongPointer,    Unmap, virtualMemory],  SpecialRuntime USING [AllocateNakedCondition],  SpecialSpace USING [    AllocateForCode, MakeProcedureResident, MakeProcedureSwappable],  System USING [    CreateIntervalTimer, GetIntervalTime, IsUtilityPilot, Microseconds,    TimerHandle],  UserTerminal,  UserTerminalExtras,  UserTerminalExtras2,  VM USING [MakeResident, MakeSwappable],  Zone USING [Base, Status];UserTerminalImpl: MONITOR  IMPORTS    BeepFace, DisplayFace, OtherDrivers: DriverStartChain, KeyboardFace,    MouseFace, Process, ProcessInternal, ResidentHeap, Runtime, Space,    SpecialSpace, SpecialRuntime, System, VM  EXPORTS DriverStartChain, UserTerminal, UserTerminalExtras, UserTerminalExtras2   SHARES UserTerminal =  BEGIN OPEN UserTerminal, UserTerminalExtras;  -- Constants (modulo display hardware and processor)  pixelsPerInch: PUBLIC CARDINAL ¬ DisplayFace.pixelsPerInch;  screenHeight:  PUBLIC CARDINAL [0..32767] ¬ DisplayFace.height;  screenWidth:   PUBLIC CARDINAL [0..32767] ¬ DisplayFace.width;  scrollingInhibitsCursor: PUBLIC BOOLEAN ¬ DisplayFace.scrollingInhibitsCursor;  scrollXQuantum: PUBLIC CARDINAL ¬ DisplayFace.scrollXQuantum;  scrollYQuantum: PUBLIC CARDINAL ¬ DisplayFace.scrollYQuantum;  Error:         PUBLIC SIGNAL[ErrorType] = CODE;  mouse:     PUBLIC LONG POINTER TO READONLY Coordinate ¬    LOOPHOLE[MouseFace.position];  cursor:    PUBLIC LONG POINTER TO READONLY Coordinate ¬    LOOPHOLE[DisplayFace.cursorPosition];  keyboard:  PUBLIC LONG POINTER TO READONLY ARRAY OF WORD ¬    LOOPHOLE[KeyboardFace.keyboard];  keyboardType: PUBLIC UserTerminalExtras2.KeyboardType ¬ LOOPHOLE[KeyboardFace.keyboardType];  hasBorder: PUBLIC BOOLEAN ¬ DisplayFace.hasBorder;    BitmapIsDisconnected: PUBLIC ERROR = CODE;  -- Main module monitor data:  state: State ¬ disconnected;  background: UserTerminal.Background ¬ white;  -- Beep monitor data:  -- This data is the monitor data covered by beepLock, not by the main module monitor.    beepLock: MONITORLOCK;  beepRequestedTime: CONDITION;    GetBackground: PUBLIC ENTRY PROC RETURNS [UserTerminal.Background] =    {RETURN[background]};  GetBitBltTable: PUBLIC ENTRY PROC RETURNS [BitBlt.BBTable] =    BEGIN    IF state = disconnected THEN RETURN WITH ERROR BitmapIsDisconnected;    RETURN[DisplayFace.GetBitBltTable[]]    END;    GetState: PUBLIC ENTRY PROC RETURNS [State] = {RETURN[state]};  SetMousePosition:  PUBLIC ENTRY PROC [newMousePosition: Coordinate] = {    MouseFace.SetPosition[[newMousePosition.x, newMousePosition.y]]};  SetCursorPosition: PUBLIC ENTRY PROC [newCursorPosition: Coordinate] = {    DisplayFace.SetCursorPosition[[newCursorPosition.x, newCursorPosition.y]]};  saveCursor: ARRAY [0..16) OF WORD ¬ ALL[0];  GetCursorPattern: PUBLIC ENTRY PROC RETURNS [cursorPattern: CursorArray] = {    RETURN[saveCursor]};  SetCursorPattern: PUBLIC ENTRY PROC [cursorPattern: CursorArray] = {    saveCursor ¬ cursorPattern; DisplayFace.SetCursorPattern[@saveCursor]};  SetBorder: PUBLIC PROCEDURE [oddPairs, evenPairs: [0..377B]] = {    DisplayFace.SetBorderPattern[oddPairs, evenPairs]};  SetBackground: PUBLIC ENTRY PROC [new: UserTerminal.Background]    RETURNS [old: UserTerminal.Background] =    BEGIN    IF (old ¬ background) = new THEN RETURN;    DisplayFace.SetBackground[      IF (background ¬ new) = white THEN white ELSE black];    END;  bitmapSpace: Space.Interval ¬ Space.nullInterval;  SetState: PUBLIC ENTRY PROC [new: State] RETURNS [old: State] =    BEGIN    IF (old ¬ state) = new THEN RETURN;    IF old = disconnected THEN      BEGIN      swapUnitSize: CARDINAL = 50;      bitmapSpace ¬ SpecialSpace.AllocateForCode[        count: DisplayFace.pagesForBitmap, within: Space.virtualMemory	! Space.Error => IF type = invalidParameters THEN	  {bitmapSpace ¬  Space.Allocate[             count: DisplayFace.pagesForBitmap, within: Space.virtualMemory];	   CONTINUE} ELSE REJECT	];      IF ~DisplayFace.hasBuffer THEN        [] ¬	  Space.MapAt[	    at: bitmapSpace, window: [File.nullFile, 0, bitmapSpace.count],	    usage: KernelSpaceUsage.displayBitmap, class: pilotResident,	    life: dead,	    swapUnits:	      IF System.IsUtilityPilot[] THEN [unitary[]]	      ELSE [uniform[swapUnitSize]]];      DisplayFace.Connect[Space.PageFromLongPointer[bitmapSpace.pointer]];      IF new = (state ¬ off) THEN RETURN;      END;    -- assert state = on or off, and state#new     SELECT new FROM      on =>        BEGIN        IF ~DisplayFace.hasBuffer THEN	  VM.MakeResident[	    [Space.PageFromLongPointer[bitmapSpace.pointer], bitmapSpace.count],	    wait];        DisplayFace.TurnOn[];	END;      off, disconnected =>        BEGIN        DisplayFace.TurnOff[];        WaitForVerticalRetrace[]; WaitForVerticalRetrace[];        IF ~DisplayFace.hasBuffer AND (old = on) THEN	  VM.MakeSwappable[	    [Space.PageFromLongPointer[bitmapSpace.pointer], bitmapSpace.count]];	END;      ENDCASE => ERROR;    IF new = disconnected THEN      BEGIN      DisplayFace.Disconnect[];      [] ¬ Space.Unmap[bitmapSpace.pointer];      bitmapSpace ¬ Space.nullInterval      END;    state ¬ new;    END;  hardwareVerticalRetrace:    LONG POINTER TO CONDITION;  verticalRetrace, blinkTime: CONDITION;  meFirst:                    BOOLEAN ¬ TRUE;  microsecondsPerScanLine:    CARDINAL = 14;  -- should be in terms of DisplayFace  BlinkDisplay: PUBLIC ENTRY PROCEDURE =    BEGIN    DisplayFace.SetBackground[  -- invert display      IF background = white THEN black ELSE white];    WAIT blinkTime;    DisplayFace.SetBackground[  -- put it back      IF background = white THEN DisplayFace.Background[white]      ELSE DisplayFace.Background[black]];    END;        -- Miscellaneous  WaitForScanLine: PUBLIC PROCEDURE [scanLine: INTEGER] =    BEGIN    WaitForScanLineZero: ENTRY PROCEDURE = INLINE {WaitForVerticalRetrace[]};    WaitForScanLineZero[];    IF scanLine = 0 OR CARDINAL[scanLine] > screenHeight THEN NULL    ELSE      BEGIN OPEN System;      timer: TimerHandle = CreateIntervalTimer[];      interval: Microseconds = scanLine*microsecondsPerScanLine;      UNTIL GetIntervalTime[timer] >= interval DO ENDLOOP      END    END;  WaitForVerticalRetrace: INTERNAL PROCEDURE =    BEGIN    IF meFirst THEN      BEGIN      meFirst ¬ FALSE;      WAIT hardwareVerticalRetrace;      BROADCAST verticalRetrace;      meFirst ¬ TRUE      END    ELSE WAIT verticalRetrace    END;  Beep: PUBLIC --ENTRY-- PROC [frequency: CARDINAL, duration: CARDINAL] =    -- This procedure references no data of interest to the other routines in this module.    -- It has its own lock to serialize the use of the beeper.    -- Beep wants to run at a high priority, so it can accurately time    -- the duration of the beep.  Since it runs at priorityPageFaultIO,    -- its priority should have an extra    -- state vector, or Beep's code (and local and global frame) must be pinned.    BEGIN    aborted:  BOOLEAN ¬ FALSE;    priorityPrev: Process.Priority = ProcessInternal.GetPriority[];    WHILE ~ProcessOperations.Enter[@beepLock] DO NULL ENDLOOP;    --scope of ABORTED--      BEGIN ENABLE ABORTED => GO TO Aborted;      Process.SetTimeout[@beepRequestedTime, Process.MsecToTicks[duration]];      ProcessInternal.SetPriority[  -- now that we're in the monitor.        MAX[ProcessPriorities.priorityPageFaultIO, priorityPrev]];      BeepFace.BeepOn[frequency];      ProcessOperations.Wait[        @beepLock, @beepRequestedTime,        LOOPHOLE[beepRequestedTime, PSB.ConditionVariable].timeout];      WHILE ~ProcessOperations.ReEnter[@beepLock, @beepRequestedTime] DO NULL ENDLOOP;      EXITS Aborted => aborted ¬ TRUE;      END;    BeepFace.BeepOff[];    ProcessOperations.Exit[@beepLock];  -- must not fault until priority reset!    ProcessInternal.SetPriority[priorityPrev];    IF aborted THEN ERROR ABORTED;    END;    -- Smooth Scrolling  scrollWindowCreated: BOOLEAN ¬ FALSE;  CreateScrollWindow: PUBLIC ENTRY PROCEDURE[    locn: Coordinate, width: CARDINAL, height: CARDINAL] =    BEGIN    -- This procedure defines an area in the bitmap that can be  scrolled up or down.      --Only one ScrollWindow may be defined at any one time.    IF scrollWindowCreated THEN RETURN WITH ERROR Error[multipleWindows];    -- width and locn.x must be multiples of scrollXQuantun.    IF width MOD DisplayFace.scrollXQuantum # 0 THEN       RETURN WITH ERROR Error[xQuantumError];    IF locn.x MOD LOOPHOLE[DisplayFace.scrollXQuantum, INTEGER] # 0 THEN       RETURN WITH ERROR Error[xQuantumError];    IF locn.y MOD LOOPHOLE[DisplayFace.scrollYQuantum, INTEGER] # 0 THEN       RETURN WITH ERROR Error[yQuantumError];    IF height MOD DisplayFace.scrollYQuantum # 0 THEN       RETURN WITH ERROR Error[yQuantumError];    SpecialSpace.MakeProcedureResident[LOOPHOLE[Scroll]];    SpecialSpace.MakeProcedureResident[LOOPHOLE[DisplayFace.Scroll]];    DisplayFace.CreateScrollWindow[      locn: [locn.x, locn.y], w: width, h: height];    scrollWindowCreated ¬ TRUE;    END;  -- of CreateScrollWindow  DeleteScrollWindow: PUBLIC ENTRY PROC = {    IF ~scrollWindowCreated THEN RETURN WITH ERROR Error[noScrollWindow];    scrollWindowCreated ¬ FALSE;    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[Scroll]];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[DisplayFace.Scroll]];    DisplayFace.DeleteScrollWindow[]};  Scroll: PUBLIC PROCEDURE [line:  Environment.BitAddress, lineCount:  CARDINAL, increment: INTEGER] =  BEGIN    -- This procedure causes the display to scroll up (increment>0) or down (increment<0) lineCount lines.     -- lineCount must be a multiple of DisplayFace.scrollYQuantum.   -- "line" points to the first line that will be added to the top or the bottom of the display   -- increment is added to line to get the address of each successive line after the first.  IF ~scrollWindowCreated THEN      ERROR Error[noScrollWindow];  IF lineCount MOD DisplayFace.scrollYQuantum # 0 THEN      ERROR Error[lineCountError];  DisplayFace.Scroll[line: line, lineCount: lineCount, increment: increment];  END;  -- of Scroll  -- Initialization  Start: PUBLIC PROCEDURE =    BEGIN    mask:        WORD;    headGlobalP: Zone.Base RELATIVE POINTER;    s:           Zone.Status;     [headGlobalP, s] ¬ ResidentHeap.MakeNode[DisplayFace.globalStateSize, a16];    IF s # okay THEN Runtime.CallDebugger["Zone error in UserTerminalImpl"L];    [cv: hardwareVerticalRetrace, mask: mask] ¬ SpecialRuntime.AllocateNakedCondition[];    DisplayFace.Initialize[headGlobalP, mask];    DisplayFace.InitializeCleanup[];    Process.SetTimeout[@blinkTime, Process.MsecToTicks[100]];    OtherDrivers.Start[];    Process.EnableAborts[@beepRequestedTime];    END;  END.LOGJuly 31, 1980  9:54 AM   PXM       Use pagesForBitmap, GetBitBltTable from DisplayFaceAugust 28, 1980  11:44 AM   PXM       Convert to ProcessInternal.AllocateNakedCondition14-Aug-81 20:15:10   FXH       Convert to pilot 7.0a, use of beepFace4-Nov-81 13:53:46   Jim JXF        Add Smooth Scrolling18-Nov-81 10:13:54   FXH       8.0e build, MONITOR smoothScrolling stuff, fix AR 798718-Nov-81 10:43:46   WDK       Make it compile.  Use GetPriority from ProcessInternal.19-Nov-81 17:30:36   WDK       Export scrollXQuantum, scrollYQuantum, scrollingInhibitsCursor.7-Dec-81 10:32:19   Jim JXF        Change SmoothScrolling to use BitAddress.10-Dec-81 21:20:54   WDK       Beep gets its own monitor lock so as not to block cursor tracking, etc.11-Dec-81 10:28:23   WDK       beepLock must be a global, silly!23-Dec-82 17:35:23   AWL         Convert to Klamath11-Apr-83 15:08:43   JXP         Get rid of truncation warning.12-Jul-83 15:16:39   AWL         SetState calls mapAt with wrong window.count 5-Feb-85 11:39:33   CJS      Add instantiation of keyboardType for new KeyboardFace. 27-Aug-85 17:23:44   CAJ      Allow creation of bitmaps > 64K. 
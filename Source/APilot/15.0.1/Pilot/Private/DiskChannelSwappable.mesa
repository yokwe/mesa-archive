-- Copyright (C) 1983, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- DiskChannelSwappable.mesa     7-Apr-87 11:12:35 by CAJ-- This monitor contains all of the procedures that ARE NOT on the page fault path.-- This code may swap. The public procedures implemented here are:--	DiskChannel.AwaitStateChange--	DiskScheduler.Change--	DiskChannel.Create--	DiskChannel.GetDriveTag--	DiskChannel.GetNextDrive--	DiskChannel.GetPageAddress--	DiskChannel.GetPageNumber--	DiskChannel.InspectDiskShape--	DiskChannel.IsReady--	DiskChannel.SetDriveState--	DiskChannel.SetDriveTag--  This implementation does not change change counts nor does it know whether a--  drive is ready (it assumes a drive is always ready).DIRECTORY  Device USING [Type],  DiskChannel USING [    ChannelStatus, DiskPageCount, DiskPageNumber, DoIO, Drive, DriveObject,    DriveState, DriveStatus, Handle, IORequest, IOStatus],  DiskChannelInternal USING [    countDrives, CalculatePageAddress, ChangeDriveState, ChangeDriveType,    ChangeScheduler, Drive, DriveDataArray, DriveObject, firstDrive, scheduler,    Handle],  DiskScheduler USING [DriveData, Scheduler],  Environment USING [    Base, first64K, PageFromLongPointer, PageNumber, wordsPerPage],  Frame USING [MyLocalFrame],  PhysicalVolume USING [PageNumber],  PhysicalVolumeFormat USING [rootPageNumber],  PilotDiskFace USING [    DetermineDiskShape, DeterminationMode, DiskAddress, GetDeviceAttributes,    GetDeviceType, Operation, OperationPtr, operationSize, Status],  Process USING [InitializeCondition, MsecToTicks],  ResidentHeap USING [FreeNode, MakeNode],  RuntimeInternal USING [Bug],  Zone USING [Status];DiskChannelSwappable: MONITOR  IMPORTS    DiskChannel, DiskChannelInternal, Environment, Frame, PilotDiskFace,    Process, ResidentHeap, RuntimeInternal  EXPORTS DiskChannel, DiskScheduler =  BEGIN  -- Channels:  Handle: PUBLIC TYPE = DiskChannelInternal.Handle;  -- Drives:  Drive: TYPE = LONG POINTER TO DriveObject;  nullDrive: Drive = NIL;  DriveObject: PUBLIC TYPE = DiskChannelInternal.DriveObject;  -- Global types and variables:  aBit: CONDITION;    BugType: TYPE = {cantDetermineDiskStatus, impossibleEndcase, residentHeapError, unexpectedChannelError};    -- Initilization:  InitGlobals: PROCEDURE =    BEGIN Process.InitializeCondition[@aBit, Process.MsecToTicks[5000]]; END;  -- PUBLIC ENTRY Procedures  --  DiskChannel.  AwaitStateChange: PUBLIC ENTRY PROCEDURE [count: CARDINAL, drive: Drive]    RETURNS [currentChangeCount: CARDINAL] =    BEGIN    SumCC: INTERNAL PROCEDURE RETURNS [sum: CARDINAL] =      BEGIN      sum ¬ 0;      FOR d: Drive ¬ DiskChannelInternal.firstDrive, d.next UNTIL d = nullDrive DO        sum ¬ sum + d.changeCount ENDLOOP;      END;    UNTIL count <= (IF drive # nullDrive THEN drive.changeCount ELSE SumCC[]) DO      WAIT aBit ENDLOOP;    RETURN[drive.changeCount]    END;  -- DiskScheduler.  Change: PUBLIC ENTRY PROCEDURE [new: DiskScheduler.Scheduler]    RETURNS [old: DiskScheduler.Scheduler] =    BEGIN    -- This procedure calls the new scheduler's transition procedure and    -- drive procedures. It then passes the new scheduler's procedures    -- and new drive data to DiskChannelResident. DiskChannelResident will    -- "copy" the requests from the old scheduler's queues to the new    -- scheduler's queues and change the value of DiskChannelInternal.scheduler.    -- This procedure then calls the old scheduler's drives and transition     -- procedures.    rp: Environment.Base RELATIVE POINTER TO DiskChannelInternal.DriveDataArray;    status: Zone.Status;    dd: LONG POINTER TO DiskChannelInternal.DriveDataArray;    base: Environment.Base = Environment.first64K;    old ¬ DiskChannelInternal.scheduler;    [rp, status] ¬ ResidentHeap.MakeNode[      n: DiskChannelInternal.countDrives*SIZE[DiskScheduler.DriveData]];    IF status ~= okay THEN Bug[residentHeapError];    dd ¬ @base[rp];    FOR i: CARDINAL IN [0..DiskChannelInternal.countDrives) DO dd[i] ¬ 0 ENDLOOP;    IF new.transitionProc # NIL THEN new.transitionProc[start];    IF new.driveProc # NIL THEN      BEGIN      i: CARDINAL ¬ 0;      FOR d: Drive ¬ DiskChannelInternal.firstDrive, d.next UNTIL d = nullDrive DO        new.driveProc[@dd[i], start, d]; i ¬ SUCC[i]; ENDLOOP;      END;    DiskChannelInternal.ChangeScheduler[new, dd];    IF old.driveProc # NIL THEN      BEGIN      i: CARDINAL ¬ 0;      FOR d: Drive ¬ DiskChannelInternal.firstDrive, d.next UNTIL d = nullDrive DO        old.driveProc[@dd[i], stop, d]; i ¬ SUCC[i]; ENDLOOP;      END;    IF old.transitionProc # NIL THEN old.transitionProc[stop];    IF ResidentHeap.FreeNode[rp] # okay THEN Bug[residentHeapError];    END;  -- DiskChannel.  Create: PUBLIC ENTRY PROCEDURE [drive: Drive] RETURNS [Handle] = {    RETURN CreateInternal[drive]};      CreateInternal: INTERNAL PROCEDURE [drive: Drive] RETURNS [Handle] = {    RETURN[[drive: drive, changeCount: drive.changeCount]]};  -- DiskChannel.  IsReady: PUBLIC ENTRY PROCEDURE [drive: Drive] RETURNS [ready: BOOLEAN] =    BEGIN    pvrDataPage: Environment.PageNumber;  -- memory page for data    -- We're going to [v,v,v] the disk to see if it reports notReady.    -- The PV rootpage is a good page to peek at.    req: DiskChannel.IORequest;    ioStatus: DiskChannel.IOStatus;    channel: DiskChannel.Handle ¬ CreateInternal[drive];    retry: BOOLEAN ¬ TRUE;    -- Getting scratch resident page for data.    pvrP: POINTER ¬ Frame.MyLocalFrame[];    pvrDataPage ¬ Environment.PageFromLongPointer[LONG[pvrP]];    req ¬ [      command: verify,      diskPage: PhysicalVolumeFormat.rootPageNumber, memoryPage: pvrDataPage,      tries: 1, useSamePage: TRUE, count: 1];    ready ¬ FALSE;    THROUGH [0..3) WHILE retry DO      ioStatus ¬ DiskChannel.DoIO[channel, @req].status;      WITH ioS: ioStatus SELECT FROM	invalidChannel => Bug[unexpectedChannelError];	invalidDriveState => Bug[cantDetermineDiskStatus];        disk => SELECT ioS.status FROM	    notReady => {ready ¬ FALSE; retry ¬ FALSE;};	    goodCompletion, headerCRCError, dataCRCError,              headerNotFound, dataVerifyError,                overrunError, writeFault, otherError =>		  {ready ¬ TRUE; retry ¬ FALSE;};	    operationReset => retry ¬ TRUE;	    memoryError, memoryFault, clientError => retry ¬ TRUE;	    ENDCASE => retry ¬ TRUE; -- why not? better than crashing!        ENDCASE => Bug[impossibleEndcase];      ENDLOOP;    IF retry THEN Bug[cantDetermineDiskStatus];    END;  -- DiskChannel.  GetDriveTag: PUBLIC ENTRY PROCEDURE [drive: Drive] RETURNS [tag: CARDINAL] = {    RETURN[drive.tag]};  -- DiskChannel.  GetNextDrive: PUBLIC ENTRY PROCEDURE [prev: Drive] RETURNS [Drive] = {    RETURN[IF prev = nullDrive THEN DiskChannelInternal.firstDrive ELSE prev.next]};  -- DiskChannel.  GetPageAddress: PUBLIC ENTRY PROCEDURE [    drive: Drive, page: DiskChannel.DiskPageNumber]    RETURNS [PilotDiskFace.DiskAddress] = {    RETURN[DiskChannelInternal.CalculatePageAddress[drive, page]]};  -- DiskChannel.  GetPageNumber: PUBLIC ENTRY PROCEDURE [    drive: Drive, page: PilotDiskFace.DiskAddress]    RETURNS [DiskChannel.DiskPageNumber] = {    RETURN[      page.sector +        drive.sectorsPerTrack*LONG[page.head + drive.movingHeads*page.cylinder]]};  -- DiskChannel.  InspectDiskShape: PUBLIC ENTRY PROCEDURE [    drive: Drive, mode: PilotDiskFace.DeterminationMode]    RETURNS [knownType: BOOLEAN] =    BEGIN    base: Environment.Base = Environment.first64K;    cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL;    IF ~drive.diskTypeKnown THEN      BEGIN  -- disk's shape has not yet been determined      operation: PilotDiskFace.OperationPtr;      nodeHeaderFudgeConstant: CARDINAL = 16; -- size of largeNodeHeader      pageBuffer: LONG POINTER;      rpBuf: Environment.Base RELATIVE POINTER;      rpOp: Environment.Base RELATIVE POINTER TO PilotDiskFace.Operation;      status: Zone.Status;      [rpOp, status] ¬ ResidentHeap.MakeNode[        n: PilotDiskFace.operationSize, alignment: a16];      IF status ~= okay THEN Bug[residentHeapError];      operation ¬ @base[rpOp];      -- The following egregious hack acquires a page-aligned page buffer in      -- this environment, where mapping is not proper.      [rpBuf, status] ¬ ResidentHeap.MakeNode[        n: Environment.wordsPerPage*2 - nodeHeaderFudgeConstant, alignment: a16];      IF status ~= okay THEN Bug[residentHeapError];      pageBuffer ¬ @base[rpBuf] + (Environment.wordsPerPage        - (LOOPHOLE[rpBuf, CARDINAL] MOD Environment.wordsPerPage));      IF PilotDiskFace.DetermineDiskShape[        device: drive.handle, operation: operation, mode: mode,	buffer: pageBuffer] THEN          BEGIN          [cylinders: cylinders, movingHeads: movingHeads, fixedHeads: fixedHeads,            sectorsPerTrack: sectorsPerTrack] ¬	      PilotDiskFace.GetDeviceAttributes[drive.handle];          DiskChannelInternal.ChangeDriveType[            drive: drive, type: PilotDiskFace.GetDeviceType[drive.handle],            cylinders: cylinders, movingHeads: movingHeads,	    fixedHeads: fixedHeads, sectorsPerTrack: sectorsPerTrack]          END;      IF ResidentHeap.FreeNode[rpOp] # okay        OR ResidentHeap.FreeNode[rpBuf] # okay THEN Bug[residentHeapError];      END;    knownType ¬ drive.diskTypeKnown;    END;  -- DiskChannel.  SetDriveState: PUBLIC ENTRY PROCEDURE [    drive: Drive, changeCount: CARDINAL, state: DiskChannel.DriveState]    RETURNS [s: DiskChannel.DriveStatus] =    BEGIN    SELECT TRUE FROM      changeCount # 0 AND changeCount # drive.changeCount =>        RETURN[wrongChangeCount];      state # inactive AND drive.state # inactive => RETURN[illegalState];      ENDCASE => {DiskChannelInternal.ChangeDriveState[drive, state]; RETURN[ok]};    END;  -- DiskChannel.  SetDriveTag: PUBLIC ENTRY PROCEDURE [drive: Drive, tag: CARDINAL] = {    drive.tag ¬ tag};  -- This can be done directly since DiskChannelResident does not use drive tags  -- PRIVATE procedures  Bug: PROCEDURE [type: BugType] = {RuntimeInternal.Bug[type]};      -- MAIN:  InitGlobals[];  END.LOG21-Jun-82  8:53:45   KAM     Major rewrite for Klamath. Roughly supplies function of Trinity DiskChannelImpl.23-Nov-82 10:05:38   WDK     Made compatible with new DiskChannelInternal.11-Jan-83 14:31:14   KAM     Made compatible with new DiskScheduler.14-Mar-85 14:11:51   CJS     GetDriveAttributes actually tries [v,v,v] to disk to detect notReady.  13-Jun-85 15:38:16   AWL     Wire ready TRUE in GetDriveAttributes.  Implement DiskChannelExtras.IsReady.27-Aug-85 10:08:25   RSV     Moved GetDrive and GetDriveAttributes to DiskChannelResident.mesa. 7-Jul-86  9:02:36   RSV     Deleted references to labels and converted to new PilotDiskFace.Command version. 5-Oct-86 12:12:47   CAJ     DiskChannelExtras.IsReady now exported to DiskChannel. 7-Apr-87 11:06:43   CAJ     Provide real buffer for DetermineDiskShape. (Merged in from Horizon version: 13-Mar-87 12:54:49   CAJ)
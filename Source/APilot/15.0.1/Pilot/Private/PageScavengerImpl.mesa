-- Copyright (C) 1983, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. -- PageScavengerImpl.mesa     6-Jan-88 15:37:44 by RSV      DIRECTORY  CompatibilityDiskFace USING [     Command, Label, OldInitiate, SetLabelFilePage, zeroLabel],  DiskChannel USING [     Create, defaultTries, DirectOperation, DiskChannelPrivate,     diskOpWordAlignment, DiskPageCount, DoDirectIO, DoIO, Drive,     DriveState, GetDriveAttributes, GetNextDrive, GetPageAddress,     goodCompletion, Handle, IORequest, IOStatus, nullDrive,     operationSize, SetDriveState],  Environment USING [Base],  File USING [nullFile],  LogicalVolumeFormat USING [rootPageSize],  PageScavenger USING [Action, DiskStatus, DeviceIndex, ErrorType, PageNumber],  PhysicalVolume USING [PageCount, PageNumber],  PhysicalVolumeExtras USING [GetDuplicatePVRootLocation, MarkDataLostPage],  PhysicalVolumeFormat USING [     currentVersion, Handle, markerPageSize, rootPageNumber, rootPageSize,     seal],  PilotDiskFace USING [Command, Status],  ResidentHeap USING [first64K, FreeNode, MakeNode],  Runtime USING [IsBound],  Space USING [Interval, Map, nullInterval, PageFromLongPointer, Unmap],  VM USING [MakeResident, MakeSwappable, ReturnWait],  Zone USING [Status];PageScavengerImpl: MONITOR   IMPORTS      CompatibilityDiskFace, DiskChannel, PhysicalVolumeExtras, ResidentHeap,     Runtime, Space, VM   EXPORTS PageScavenger =  BEGIN  Error: PUBLIC ERROR [errorType: PageScavenger.ErrorType] = CODE;    Bug: ERROR [bugType: BugType] = CODE;    BugType: TYPE = {    DiskChannelImplementationBroken, impossibleSelectError, problemWithDrive,    unexpectedFreeNodeError, unexpectedMakeNodeError};    Scavenge: PUBLIC ENTRY PROCEDURE [    device: PageScavenger.DeviceIndex, diskPage: PageScavenger.PageNumber,    overwrite: BOOLEAN]    RETURNS [      action: PageScavenger.Action, contentsReliable: BOOLEAN,      diskStatus: PageScavenger.DiskStatus] =    BEGIN        channel: DiskChannel.Handle;    drive: DiskChannel.Drive;    drivePageCount: DiskChannel.DiskPageCount;    deviceOrdinal: CARDINAL;    req: DiskChannel.IORequest;    bufferSpace: Space.Interval ¬ Space.nullInterval;    buffer: LONG POINTER ¬ NIL;    diskLabelSpace: Space.Interval ¬ Space.nullInterval;    diskLabel: LONG POINTER TO CompatibilityDiskFace.Label ¬ NIL;    rootPageSpace: Space.Interval ¬ Space.nullInterval;    rootPage: PhysicalVolumeFormat.Handle ¬ NIL;    op: LONG POINTER TO DiskChannel.DirectOperation ¬ NIL;    opStorage: Environment.Base RELATIVE POINTER;    labels: BOOLEAN;  -- Does this particular machine have labels?    rootPageValid: BOOLEAN;    oldState: DiskChannel.DriveState;    changeCount: CARDINAL;    dataOkay: BOOLEAN;    labelOkay: BOOLEAN ¬ TRUE;    status: DiskChannel.IOStatus;    currentCommand: PilotDiskFace.Command;    pageScavStatusFromDiskStatus: ARRAY PilotDiskFace.Status OF PageScavenger.DiskStatus;    CleanUp: PROCEDURE [] =       BEGIN       IF bufferSpace.pointer # NIL THEN         BEGIN         VM.MakeSwappable[	   [page: Space.PageFromLongPointer[bufferSpace.pointer],	   count: bufferSpace.count]];         bufferSpace.pointer ¬ Space.Unmap[bufferSpace.pointer];	 END;       IF diskLabelSpace.pointer # NIL THEN         BEGIN	 VM.MakeSwappable[	   [page: Space.PageFromLongPointer[diskLabelSpace.pointer],	   count: diskLabelSpace.count]];	 diskLabelSpace.pointer ¬ Space.Unmap[diskLabelSpace.pointer];	 END;       IF rootPageSpace.pointer # NIL THEN         BEGIN	 VM.MakeSwappable[	   [page: Space.PageFromLongPointer[rootPageSpace.pointer],	   count: rootPageSpace.count]];	 rootPageSpace.pointer ¬ Space.Unmap[rootPageSpace.pointer];	 END;       IF op # NIL THEN FreeDirectOperation[opStorage];       IF drive # DiskChannel.nullDrive AND oldState = inactive THEN          [] ¬ DiskChannel.SetDriveState[drive, changeCount, oldState];       END;           IsPartOfMainOrDuplicatePVArea: PROCEDURE [      diskPage: PageScavenger.PageNumber, driveIndex: PageScavenger.DeviceIndex]      RETURNS [BOOLEAN] =      BEGIN      duplicateStart: PhysicalVolume.PageNumber;      duplicateSize: PhysicalVolume.PageCount;      IF diskPage IN        [PhysicalVolumeFormat.rootPageNumber..PhysicalVolumeFormat.rootPageNumber        + PhysicalVolumeFormat.rootPageSize) THEN        RETURN [TRUE];      [duplicateStart, duplicateSize] ¬        PhysicalVolumeExtras.GetDuplicatePVRootLocation[driveIndex];      IF diskPage IN [duplicateStart..duplicateStart + duplicateSize) THEN        RETURN [TRUE];      RETURN [FALSE];      END;          IsMarkerOrLVRoot: PROCEDURE [      diskPage: PageScavenger.PageNumber, rootPage: PhysicalVolumeFormat.Handle]      RETURNS [BOOLEAN] =      BEGIN      -- The following assumes that LV Root and Marker Pages are only one page      -- long.  Also assumes that rootPage is pointing to a valid root page.      FOR i: CARDINAL IN [0..rootPage.subVolumeCount) DO        OPEN desc: rootPage.subVolumes[i];	IF diskPage IN 	     [desc.pvPage..desc.pvPage + LogicalVolumeFormat.rootPageSize) OR	   diskPage IN	     [desc.pvPage + desc.nPages..desc.pvPage + desc.nPages +	      PhysicalVolumeFormat.markerPageSize) THEN	   RETURN [TRUE];	 ENDLOOP;      RETURN [FALSE];      END;          AllocateDirectOperation: PROCEDURE [] RETURNS [	pOp: LONG POINTER TO DiskChannel.DirectOperation,	pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] = INLINE      -- pOp will be aligned per requirements of DoDirectIO.      -- pStorage should be used when freeing.      BEGIN      rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;      status: Zone.Status;      [pStorage, status] ¬ ResidentHeap.MakeNode[	n: DiskChannel.operationSize + DiskChannel.diskOpWordAlignment - 1,	alignment: a1];      IF status ~= okay THEN ERROR Bug[unexpectedMakeNodeError];      rpDirOp ¬ pStorage;      pOp ¬ @ResidentHeap.first64K[rpDirOp];      pOp ¬ LOOPHOLE[((LOOPHOLE[pOp, LONG CARDINAL] +	SIZE[DiskChannel.DiskChannelPrivate] + DiskChannel.diskOpWordAlignment-1)	  / DiskChannel.diskOpWordAlignment) * DiskChannel.diskOpWordAlignment	    - SIZE[DiskChannel.DiskChannelPrivate]];      END;  --AllocateDirectOperation      FreeDirectOperation: PROCEDURE [      pStorage: Environment.Base RELATIVE POINTER] = INLINE      BEGIN      status: Zone.Status ¬ ResidentHeap.FreeNode[pStorage];      IF status ~= okay THEN ERROR Bug[unexpectedFreeNodeError];      END;          LabelToNoLabelCommand: PROCEDURE [cmd: CompatibilityDiskFace.Command]      RETURNS [PilotDiskFace.Command] = INLINE      {RETURN[LOOPHOLE[cmd]]};    pageScavStatusFromDiskStatus ¬ ALL[hardwareError];  -- just in case we miss one. Should be "other".    pageScavStatusFromDiskStatus[inProgress] ¬ hardwareError;  --  (What else???)    pageScavStatusFromDiskStatus[goodCompletion] ¬ goodCompletion;    pageScavStatusFromDiskStatus[notReady] ¬ notReady;    pageScavStatusFromDiskStatus[recalibrateError] ¬ hardwareError;    pageScavStatusFromDiskStatus[seekTimeout] ¬ seekFailed;    pageScavStatusFromDiskStatus[headerCRCError] ¬ hardwareError;    pageScavStatusFromDiskStatus[reserved6] ¬ hardwareError; --labelCRCError--    pageScavStatusFromDiskStatus[dataCRCError] ¬ dataError;    pageScavStatusFromDiskStatus[headerNotFound] ¬ hardwareError;    pageScavStatusFromDiskStatus[reserved9] ¬ hardwareError; --labelVerifyError--    pageScavStatusFromDiskStatus[dataVerifyError] ¬ checkError;    pageScavStatusFromDiskStatus[overrunError] ¬ hardwareError;    pageScavStatusFromDiskStatus[writeFault] ¬ hardwareError;    pageScavStatusFromDiskStatus[memoryError] ¬ hardwareError;    pageScavStatusFromDiskStatus[memoryFault] ¬ hardwareError;    pageScavStatusFromDiskStatus[clientError] ¬ hardwareError;    pageScavStatusFromDiskStatus[operationReset] ¬ hardwareError;    pageScavStatusFromDiskStatus[otherError] ¬ hardwareError;  -- (What else???)    -- Find the drive    -- First find the affected drive    FOR drive ¬ DiskChannel.GetNextDrive[DiskChannel.nullDrive],      DiskChannel.GetNextDrive[drive] WHILE drive ~= DiskChannel.nullDrive DO      [deviceOrdinal: deviceOrdinal, nPages: drivePageCount, state: oldState,        changeCount: changeCount] ¬ DiskChannel.GetDriveAttributes[drive];      IF--UNTIL-- deviceOrdinal = device THEN EXIT;      REPEAT      FINISHED => RETURN WITH ERROR Error[unknownDrive];      ENDLOOP;    IF diskPage >= drivePageCount THEN RETURN WITH ERROR Error[invalidPageNumber];    SELECT oldState FROM       direct => RETURN WITH ERROR Error[driveNotAvailable];       inactive => [] ¬ DiskChannel.SetDriveState[drive, changeCount, channel];       channel => NULL;       ENDCASE => ERROR Bug[impossibleSelectError];    -- From here on, MUST do CleanUp[] before returning.    -- Now set up to do all of the required I/O    channel ¬ DiskChannel.Create[drive];    labels ¬ Runtime.IsBound[LOOPHOLE[CompatibilityDiskFace.OldInitiate]];    bufferSpace ¬ Space.Map[[File.nullFile, 0, 1]];    buffer ¬ bufferSpace.pointer;    VM.MakeResident[      [page: Space.PageFromLongPointer[bufferSpace.pointer],      count: bufferSpace.count], wait];          IF labels THEN      BEGIN      diskLabelSpace ¬ Space.Map[[File.nullFile, 0, 1]];      diskLabel ¬ diskLabelSpace.pointer;      VM.MakeResident[	[page: Space.PageFromLongPointer[diskLabelSpace.pointer],	count: diskLabelSpace.count], wait];      END;          rootPageSpace ¬ Space.Map[[File.nullFile, 0, 1]];    rootPage ¬ rootPageSpace.pointer;    VM.MakeResident[      [page: Space.PageFromLongPointer[rootPageSpace.pointer],       count: rootPageSpace.count], wait];          [op, opStorage] ¬ AllocateDirectOperation[];    -- First read in the pv root page (if it is readable) to use later.    -- No need to try reading duplicate if we can't read main (since a PV Scavenge    -- will be required anyway).    req.diskPage ¬ PhysicalVolumeFormat.rootPageNumber;    req.memoryPage ¬ Space.PageFromLongPointer[rootPage];    req.tries ¬ DiskChannel.defaultTries;    req.useSamePage ¬ TRUE;    req.count ¬ 1;    req.command ¬ read;    status ¬ DiskChannel.DoIO[channel, @req].status;    WITH ioStatus: status SELECT FROM      invalidChannel, invalidDriveState =>        ERROR Bug[DiskChannelImplementationBroken];      disk =>         BEGIN	diskStatus ¬ pageScavStatusFromDiskStatus[ioStatus.status];	IF ioStatus.status = goodCompletion AND 	  rootPage.seal = PhysicalVolumeFormat.seal AND	  rootPage.version = PhysicalVolumeFormat.currentVersion THEN	    rootPageValid ¬ TRUE	ELSE rootPageValid ¬ FALSE;	END;      ENDCASE => ERROR Bug[impossibleSelectError];        -- Don't worry about reading in PV root page twice, it's OK to do this.        -- For the page to fix, first fill in operaton     currentCommand ¬ IF labels THEN LabelToNoLabelCommand[[verify, read, read]]      ELSE PilotDiskFace.Command[read];    op.diskOp ¬ [      clientHeader: DiskChannel.GetPageAddress[drive, diskPage],      reserved1--(label)--: diskLabel,      dataPtr: buffer, pageCount: 1, incrementDataPtr: FALSE,      command: currentCommand, tries: DiskChannel.defaultTries,      device: DiskChannel.GetDriveAttributes[drive].deviceHandle];        status ¬ DiskChannel.DoDirectIO[op, channelException].status;    WITH ioStatus: status SELECT FROM       invalidChannel, invalidDriveState =>          ERROR Bug[DiskChannelImplementationBroken];       disk =>        BEGIN        diskStatus ¬ pageScavStatusFromDiskStatus[ioStatus.status];        SELECT ioStatus.status FROM         reserved9 --labelVerifyError--, inProgress =>            ERROR Bug[DiskChannelImplementationBroken];         notReady => {CleanUp[]; RETURN WITH ERROR Error[driveNotReady];};         dataVerifyError, seekTimeout, recalibrateError, headerCRCError,	   headerNotFound, overrunError, writeFault, memoryError, memoryFault,	   clientError, operationReset, otherError =>            BEGIN	    CleanUp[];	    RETURN[fixHardware, FALSE, diskStatus];	    END;         goodCompletion => {contentsReliable ¬ TRUE; dataOkay ¬ TRUE;};         dataCRCError => -- data CRC error --            BEGIN	    contentsReliable ¬ FALSE;	    op.diskOp.tries ¬ 250; -- Now try real hard	    dataOkay ¬ (DiskChannel.DoDirectIO[op, channelException].status =	      DiskChannel.goodCompletion);	    END;	  reserved6 --labelCRCError-- =>     	    BEGIN	    -- status only relevant for labelled hardware	    IF ~labels THEN ERROR Bug[DiskChannelImplementationBroken];	    contentsReliable ¬ FALSE;	    dataOkay ¬ FALSE; -- actually don't know if data is okay so stay safe	    labelOkay ¬ FALSE;	    op.diskOp.reserved1 --(label)-- ¬ NIL;  -- can't trust label	    labels ¬ FALSE;  	      -- note that if you don't supply a label, then the heads supply	      -- a correctly formed label to write on the next write.	    END; --reserved6--	 ENDCASE  => ERROR Bug[impossibleSelectError];	END;       ENDCASE => ERROR Bug[impossibleSelectError];        IF IsPartOfMainOrDuplicatePVArea[diskPage, device] THEN {      IF ~(dataOkay AND contentsReliable) THEN        {action ¬ pvScavenge; CleanUp[]; RETURN}      ELSE        action ¬ boot}	    ELSE IF ~rootPageValid THEN    -- need root page for next test      {action ¬ fixPVRootPageFirst; CleanUp[]; RETURN}	    ELSE IF IsMarkerOrLVRoot[diskPage, rootPage] THEN {      IF ~(dataOkay AND contentsReliable) THEN        {action ¬ pvScavenge; CleanUp[]; RETURN}      ELSE        action ¬ boot}	    -- the label on the page may be broken and overwrite is not allowed    ELSE IF (~labelOkay) AND (~overwrite) THEN      {action ¬ fixLabelCRCErrorFirst; CleanUp[]; RETURN}        -- could be a client page (or some "unimportant" Pilot page) so don't fix     -- it unless allowed to or fix is safe (have data in hand).    ELSE IF (~dataOkay) AND (~contentsReliable) AND (~overwrite) THEN      {action ¬ fixDataCRCError; CleanUp[]; RETURN}    ELSE      BEGIN      action ¬ lvScavenge;      IF ~(dataOkay AND contentsReliable) THEN        BEGIN        IF oldState = inactive THEN	  [] ¬ DiskChannel.SetDriveState[drive, changeCount, inactive];	  -- cause we are currently in a strange state...are channel but the	  -- drive itself isn't online!        PhysicalVolumeExtras.MarkDataLostPage[deviceOrdinal, diskPage];        IF oldState = inactive THEN	  [] ¬ DiskChannel.SetDriveState[drive, changeCount, channel];	  -- okay, back to the way we were	END;      END;    -- We can now rewrite the data in so do it to fix CRC error        -- first make sure label fields except for page and boot chain links are 0.    IF op.diskOp.reserved1 # NIL THEN      BEGIN   -- Note that diskLabel points to what op.diskOp.reserved1 points to      bootChainLinks: ARRAY [0..2) OF WORD ¬ diskLabel.dontCare;      diskLabel­ ¬ LOOPHOLE[CompatibilityDiskFace.zeroLabel];      diskLabel.dontCare ¬ bootChainLinks;      CompatibilityDiskFace.SetLabelFilePage[diskLabel, diskPage];      END;        op.diskOp.command ¬      IF labels THEN LabelToNoLabelCommand[[verify, write, write]]        ELSE PilotDiskFace.Command[write];    op.diskOp.tries ¬ DiskChannel.defaultTries;    op.diskOp.clientHeader ¬ DiskChannel.GetPageAddress[drive, diskPage];    op.diskOp.pageCount ¬ 1;    status ¬ DiskChannel.DoDirectIO[op, channelException].status;    WITH ioStatus: status SELECT FROM       invalidChannel, invalidDriveState  =>          ERROR Bug[DiskChannelImplementationBroken];       disk => SELECT ioStatus.status FROM         notReady => {CleanUp[]; RETURN WITH ERROR Error[driveNotReady];};         dataVerifyError, dataCRCError, reserved6 --labelCRCError--,	   reserved9 --labelVerifyError--, seekTimeout, recalibrateError,	   headerCRCError, headerNotFound, overrunError, writeFault, memoryError,	   memoryFault, clientError, operationReset, otherError =>             {CleanUp[]; action ¬ fixHardware; RETURN};         goodCompletion => NULL;         inProgress => ERROR Bug[DiskChannelImplementationBroken];	 ENDCASE => ERROR Bug[impossibleSelectError];       ENDCASE => ERROR Bug[impossibleSelectError];           op.diskOp.command ¬      IF labels THEN LabelToNoLabelCommand[[verify, verify, read]]        ELSE PilotDiskFace.Command[read];    op.diskOp.clientHeader ¬ DiskChannel.GetPageAddress[drive, diskPage];    op.diskOp.pageCount ¬ 1;    IF op.diskOp.reserved1 # NIL THEN      BEGIN   -- Note that diskLabel points to what op.diskOp.reserved1 points to      bootChainLinks: ARRAY [0..2) OF WORD ¬ diskLabel.dontCare;      diskLabel­ ¬ LOOPHOLE[CompatibilityDiskFace.zeroLabel];      diskLabel.dontCare ¬ bootChainLinks;      CompatibilityDiskFace.SetLabelFilePage[diskLabel, diskPage];      END;    status ¬ DiskChannel.DoDirectIO[op, channelException].status;    WITH ioStatus: status SELECT FROM       invalidChannel, invalidDriveState  =>          ERROR Bug[DiskChannelImplementationBroken];       disk => SELECT ioStatus.status FROM         notReady => {CleanUp[]; RETURN WITH ERROR Error[driveNotReady];};         dataVerifyError, dataCRCError, seekTimeout, recalibrateError,	   headerCRCError, headerNotFound, reserved6 --labelCRCError--,	   reserved9 --labelVerifyError--, overrunError, writeFault,	   memoryError, memoryFault, clientError, operationReset, otherError =>             {CleanUp[]; action ¬ fixHardware; RETURN};         goodCompletion => NULL;	 inProgress => ERROR Bug[DiskChannelImplementationBroken];         ENDCASE => ERROR Bug[impossibleSelectError];       ENDCASE => ERROR Bug[impossibleSelectError];    CleanUp[];    END;    END.LOG10-Feb-82 17:17:55   AWL      	Created file.4-Mar-82  9:55:36   AWL         Fix storage leak: make completionHandle a global protected by a monitor.20-Apr-83 10:25:37   EKN   	Update to Klamath. 6-Jul-83  9:46:52   WDK        Must use channel I/O, not direct I/O. Make cleanup smarter. pageScavStatusFromDiskStatus now constructed more reliably. 7-Oct-83 15:33:36   AWL         ... and channel I/O requires channel access.15-Nov-85 15:34:27   RSV   added CleanUp[] in ENDCASE of Scavenge.  (AR 5535)29-Sep-86 13:25:00   RSV   Changed to labelless implementation.13-Nov-86 12:29:04   RSV   Made changes involving getting labels correct when overwriting a page (due to boot chain links).  Have to do DoDirectIO instead of DoIO, plus check to see if labels need to be worried about by doing IsBound on CompatiblityDiskFace.19-Nov-86 16:59:47   RSV   Save bootChainLinks in the label, but nothing else. 6-Dec-86 22:03:58   RSV   Always reset clientHeader and pageCount of operation after each operation request.  Also do a [v,v,r] on check of written information instead of [v,r,r] for extra safety.30-Mar-87 23:18:16   RSV   Changed MarkDataLostPage to take a drive index. 6-Jan-88 15:37:44   RSV   New definition of PhysicalVolumeExtras.GetDuplicatePVRootLocation.  Before calling MarkDataLostPage, set state to inactive, and set back to channel afterwards.
-- Copyright (C) 1986, 1987, 1988 by Xerox Corporation. All rights reserved. --        9-Oct-89 10:27:06 by KTDIRECTORY  Environment USING [wordsPerPage],  ETable USING [Error, ETableHandle, ETableHeader, LVBucketInfo, PageGroup],  ETableInternal USING [AcquireLVBucketInfo, DoBucketIO, DoOverflowIO, overflowBufferSize, ReleaseLVBucketInfo],  File USING [nullID, PageNumber],  Scavenger USING [    currentLogVersion, FileEntry, Header, LogFormat, LogSeal, noneDeleted],  Space USING [LongPointerFromPage],  System USING [GetGreenwichMeanTime],  VolTable USING [LVToken],  VM USING [Interval];    ETableImplC: PROGRAM  IMPORTS ETable, ETableInternal, Space, System  EXPORTS ETable =  BEGIN  GetETableSize: PROCEDURE [eTable: ETable.ETableHandle] RETURNS [CARDINAL] =    INLINE {    RETURN[CARDINAL[      SIZE[ETable.ETableHeader] +       SIZE[ETable.PageGroup] * eTable.header.howManyGroups]] };  MakeFileList: PUBLIC PROCEDURE [token: VolTable.LVToken, log: VM.Interval] =    BEGIN    lvBucketInfo: ETable.LVBucketInfo ¬ ETableInternal.AcquireLVBucketInfo[token];    MakeFileListInternal[lvBucketInfo, log !      ETable.Error =>        lvBucketInfo ¬ ETableInternal.ReleaseLVBucketInfo[lvBucketInfo]];    lvBucketInfo ¬ ETableInternal.ReleaseLVBucketInfo[lvBucketInfo];    END;  --MakeFileList--        MakeFileListInternal: PROCEDURE [lvBucketInfo: ETable.LVBucketInfo,    log: VM.Interval] =    BEGIN    logFormat: LONG POINTER TO Scavenger.LogFormat ¬       LOOPHOLE[Space.LongPointerFromPage[log.page]];    numFiles: --LONG-- CARDINAL ¬ 0;    stopHere: LONG POINTER;    currentETable: ETable.ETableHandle;    firstFree: LONG CARDINAL;    alreadyLookedAt: LONG CARDINAL ¬ 0;    exhaustedOverflow: BOOLEAN ¬ FALSE;    blockSize: CARDINAL =       ETableInternal.overflowBufferSize * Environment.wordsPerPage;    maxFiles: LONG CARDINAL =       ((log.count * Environment.wordsPerPage) - SIZE[Scavenger.Header]) /      SIZE[Scavenger.FileEntry];    logFormat.header.seal ¬ Scavenger.LogSeal;    logFormat.header.version ¬ Scavenger.currentLogVersion;    logFormat.header.volume ¬ lvBucketInfo.lvHandle.vID;    logFormat.header.date ¬ System.GetGreenwichMeanTime[];    logFormat.header.repairMode ¬ checkOnly;    logFormat.header.incomplete ¬ FALSE;  -- assume completeness    logFormat.header.repaired ¬ FALSE;    logFormat.header.bootFilesDeleted ¬ Scavenger.noneDeleted;    logFormat.header.pad ¬ 0;    --logFormat.header.numberOfFiles ¬ lvBucketInfo.lvHandle.numberOfFile;    --not true because numberOfFile is >= to the actual number of files    --on the volume since we aren't always forcing out the root page.    logFormat.header.logEntries ¬ 0;    -- do buckets first    FOR bucketPage: File.PageNumber IN [lvBucketInfo.firstBucketPage..      lvBucketInfo.firstBucketPage + lvBucketInfo.hash) DO      lvBucketInfo.currentBucketPage ¬ bucketPage;      ETableInternal.DoBucketIO[lvBucketInfo, read];      currentETable ¬ @lvBucketInfo.bucketHandle.eTables[0];      stopHere ¬         @lvBucketInfo.bucketHandle[lvBucketInfo.bucketHandle.header.firstFree];      UNTIL (currentETable = stopHere) DO        IF numFiles < maxFiles THEN	  -- only add in if we have room	  logFormat.files[numFiles] ¬	    [file: currentETable.header.fileID,	     sortKey: currentETable.pageGroups[0].volumePage,	     numberOfProblems: 0,	     problems: TRASH];	numFiles ¬ numFiles + 1;	currentETable ¬ currentETable + GetETableSize[currentETable];	ENDLOOP;      ENDLOOP;    -- now do overflow    IF lvBucketInfo.currentOverflowPage # lvBucketInfo.firstOverflowPage THEN       BEGIN      lvBucketInfo.currentOverflowPage ¬ lvBucketInfo.firstOverflowPage;      ETableInternal.DoOverflowIO[lvBucketInfo, read];      END;    firstFree ¬ LOOPHOLE[lvBucketInfo.overflowHandle.header.freeSpace];    currentETable ¬ @lvBucketInfo.overflowHandle.eTables[0];    stopHere ¬ lvBucketInfo.overflowHandle + blockSize;    DO  -- first  block was read in already, just set it up for search      alreadyLookedAt ¬ alreadyLookedAt + ETableInternal.overflowBufferSize;      IF (alreadyLookedAt * Environment.wordsPerPage > firstFree) THEN         BEGIN	stopHere ¬ lvBucketInfo.overflowHandle + (firstFree MOD blockSize);	exhaustedOverflow ¬ TRUE;	END;      UNTIL (currentETable = stopHere) DO        IF currentETable.header.fileID = File.nullID THEN	  currentETable ¬ currentETable + currentETable.header.length	ELSE	  BEGIN	  IF numFiles < maxFiles THEN	    logFormat.files[numFiles] ¬ 	      [file: currentETable.header.fileID,	       sortKey: currentETable.pageGroups[0].volumePage,	       numberOfProblems: 0,	       problems: TRASH];	  numFiles ¬ numFiles + 1;	  currentETable ¬ currentETable + GetETableSize[currentETable];	  END;	ENDLOOP;      IF exhaustedOverflow THEN EXIT;      currentETable ¬ LOOPHOLE[lvBucketInfo.overflowHandle]; -- for nonfirst block      lvBucketInfo.currentOverflowPage ¬         lvBucketInfo.currentOverflowPage + ETableInternal.overflowBufferSize;      ETableInternal.DoOverflowIO[lvBucketInfo, read];      ENDLOOP;    logFormat.header.logEntries ¬ MIN[numFiles, maxFiles];    logFormat.header.numberOfFiles ¬ numFiles;    IF numFiles > maxFiles THEN logFormat.header.incomplete ¬ TRUE;    END;  -- MakeFileListInternal --     END...LOG. 2-Sep-86  9:39:02   RSV  Created file. 4-Jan-87 17:10:32   RSV  Changed logFormat to LONG POINTER.  Set volume and date in header of log. 6-Jan-87 18:24:52   RSV  Fixed infinite loop problem when enumerating overflow.29-Jan-87 18:54:20   RSV  Changed MakeFileList to OldMakeFileList.  Added a new implementation of MakeFileList. 6-Feb-87 16:07:32   RSV  Deleted OldMakeFileList. 6-Jul-88 18:01:55   RSV  Fix MakeFileList to work even though numberOfFile in root page is wrong (since changing flag isn't being set for some operations which update this number).  One assumption is that numberOfFile is ALWAYS larger or equal to the actual number of files on the volume. 9-Oct-89 10:26:58   KT   Fixed the bug in MakeFileListInternal procedure, that when the nember of files JUST equal to maxFiles, incomplete flag in file header becomes FALSE. (It is okey that the nember of files Just equal maxFiles because the log file has enough space for store the all file information.)
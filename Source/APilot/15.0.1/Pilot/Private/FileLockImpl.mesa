-- Copyright (C) 1986, 1987, 1988, 1989  by Xerox Corporation and Fuji Xerox Co., Ltd. All rights reserved. -- FileLockImpl.mesa         16-May-89  1:24:48 by TxH --   DIRECTORY  Environment         USING [PageNumber, LongPointerFromPage],  File                USING [File, ID, nullID, PageCount, PageNumber],    FileLock            USING [ErrorType, LockState, LockType,                              nullLockHandle, SearchLocation],  MapLog              USING [WriteLog],	       PilotSwitchesExtra9 USING [disableMappedFileLocking],  RuntimeInternal     USING [Bug],  Space               USING [Interval, Deallocate],  SpacePerfExtras     USING [],  SpaceInternal       USING [DeallocateStorage],  System              USING [switches],  VM                  USING [Interval, PageCount, Unmap],  VMExtras2           USING [GetVMIntervalWithLockHandle, PartiallyUnmap],  VolTable            USING [GetVolumeIndex];FileLockImpl: MONITOR  IMPORTS Environment, MapLog, RuntimeInternal,           Space, SpaceInternal, System,          VM, VMExtras2, VolTable  EXPORTS FileLock, SpacePerfExtras =  BEGIN    -- Types    LockHandle: PUBLIC TYPE = LONG POINTER TO FileLockNode;  FileLockNode: TYPE = MACHINE DEPENDENT RECORD [    fileID(0): File.ID,    volumeIndex(2): CARDINAL,    firstPage(3): File.PageNumber,    mappedCount(5): File.PageCount,    lockType(7): FileLock.LockType,    mapUnitIndex(8): LONG CARDINAL, -- 0 = null. normally [1..xx].    next(10): LockHandle];    TrushedSpace: TYPE = RECORD[    mapUnit: LONG CARDINAL,     begin, after: Environment.PageNumber];              -- Constants    numberOfBuckets: CARDINAL = 100;  fileLockNodeSize: PUBLIC CARDINAL ¬ SIZE[FileLockNode];  nullLockHandle: LockHandle = FileLock.nullLockHandle;  lockingEnabled: PUBLIC BOOLEAN ¬    System.switches[PilotSwitchesExtra9.disableMappedFileLocking] = up;    -- if the switch is down, locking is disabled....if the switch is up, locking    -- is enabled.  debug: BOOLEAN = FALSE;  -- extra checking done when this is set to true    -- Global variables    fileLockTable: ARRAY [0..numberOfBuckets) OF LockHandle ¬    ALL[nullLockHandle];    nullTrushedSpace: TrushedSpace = [0, 0, 0];  maxTrushes: CARDINAL = 8;    trushedSpaceList: ARRAY [0..maxTrushes) OF TrushedSpace ¬    ALL[nullTrushedSpace];    trushedSpaceCount: CARDINAL ¬ 0;        -- Performance variables (exported to SpacePerfExtras)    numberOfDeletes: PUBLIC LONG CARDINAL ¬ 0;  numberOfDeleteSearches: PUBLIC LONG CARDINAL ¬ 0;  numberOfGetLocks: PUBLIC LONG CARDINAL ¬ 0;  numberOfGetLockHandleFromFileID: PUBLIC LONG CARDINAL ¬ 0;  numberOfGetLockHandleFromFileIDSearches: PUBLIC LONG CARDINAL ¬ 0;  numberOfIsLocked: PUBLIC LONG CARDINAL ¬ 0;  numberOfIsLockedSearches: PUBLIC LONG CARDINAL ¬ 0;    -- ERRORs and BugTypes    BugType: TYPE = {    impossibleEndcase, insufficientStorageSupplied, logicError, notImplemented, zeroLockedPage, soManyTrushes, strangeSpace, strangeTrush};      Error: PUBLIC ERROR [type: FileLock.ErrorType] = CODE;      -- Procedures    Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};    CheckBucket: INTERNAL PROCEDURE [index: CARDINAL] =    BEGIN    runner: LockHandle;    runner ¬ fileLockTable[index];    WHILE runner # nullLockHandle DO      IF Hash[runner.fileID] # index THEN Bug[logicError];      IF runner = runner.next THEN Bug[logicError];      runner ¬ runner.next;      ENDLOOP;    END;  --CheckBucket--    DeleteLock: PUBLIC ENTRY PROCEDURE [lock: LockHandle]    RETURNS [storage: LONG POINTER, count: CARDINAL] = {    [storage: storage, count: count] ¬       DeleteLockInternal[lock]}; --DeleteLock--          DeleteLockInternal: INTERNAL PROCEDURE [lock: LockHandle]    RETURNS [storage: LONG POINTER, count: CARDINAL] =    -- Deletes the specified lock out of the fileLockTable and returns the     -- storage the locked used along with a count indicating the size of the     -- storage returned.    BEGIN    index: CARDINAL = Hash[lock.fileID];    runner: LockHandle;    IF ~lockingEnabled THEN Bug[logicError];    numberOfDeletes ¬ numberOfDeletes.SUCC;    numberOfDeleteSearches ¬ numberOfDeleteSearches.SUCC;    IF fileLockTable[index] = nullLockHandle THEN      BEGIN      RETURN WITH ERROR Error[notLocked];      END    ELSE IF fileLockTable[index] = lock THEN      BEGIN      fileLockTable[index] ¬ fileLockTable[index].next;      IF debug THEN CheckBucket[index];      RETURN[LockHandleToLP[lock], SIZE[FileLockNode]];      END    ELSE      BEGIN      runner ¬ fileLockTable[index];      WHILE runner.next # nullLockHandle DO        numberOfDeleteSearches ¬ numberOfDeleteSearches.SUCC;        IF runner.next # lock THEN	  runner ¬ runner.next	ELSE	  BEGIN	  runner.next ¬ runner.next.next;	  IF debug THEN CheckBucket[index];	  RETURN[LockHandleToLP[lock], SIZE[FileLockNode]];	  END;	ENDLOOP;      RETURN WITH ERROR Error[notLocked];      END;    END;  --DeleteLockInternal--      FileLockInit: PUBLIC ENTRY PROCEDURE =    -- In future, may want to create fileLockTable and sets all pointers in     -- it to nullLockHandle instead of getting it from global frame.    BEGIN    END;      GetFileIDFromLock: PUBLIC PROCEDURE [    lock: LockHandle] RETURNS [fileID: File.ID] =    -- Returns the fileID for the given lock (needed since only place fileID is    -- stored is in the lock itself.    BEGIN    IF ~lockingEnabled THEN Bug[logicError];    RETURN[IF (lock = nullLockHandle) THEN File.nullID ELSE lock.fileID];    END; --GetFileIDFromLock--      GetLock: PUBLIC ENTRY PROCEDURE [    storage: LONG POINTER, file: File.File, firstPage: File.PageNumber,    mappedCount: VM.PageCount ¬ 0, lockType: FileLock.LockType,    mapUnitIndex: LONG CARDINAL]    RETURNS [lock: LockHandle] =    -- Obtains a lock of the specified type on file using the storage passed    -- in.    BEGIN    index: CARDINAL = Hash[file.fileID];    IF ~lockingEnabled THEN Bug[logicError];    IF mappedCount = 0 THEN Bug[zeroLockedPage];    numberOfGetLocks ¬ numberOfGetLocks.SUCC;    lock ¬ LOOPHOLE[storage, LockHandle];    lock­ ¬ [fileID: file.fileID,       volumeIndex: VolTable.GetVolumeIndex[file.volumeID],      firstPage: firstPage, mappedCount: mappedCount, lockType: lockType,      mapUnitIndex: mapUnitIndex, next: fileLockTable[index]];    fileLockTable[index] ¬ lock;    IF debug THEN CheckBucket[index];    RETURN[lock];    END;  --GetLock--      GetLockHandleFromFileID: PUBLIC ENTRY PROCEDURE [    file: File.File, page: File.PageNumber]    RETURNS [lock: LockHandle] =    -- Returns a lock handle associated with the given fileID and page number.    BEGIN    runner: LockHandle ¬ fileLockTable[Hash[file.fileID]];    volumeIndex: CARDINAL = VolTable.GetVolumeIndex[file.volumeID];    IF ~lockingEnabled THEN Bug[logicError];    numberOfGetLockHandleFromFileID ¬ numberOfGetLockHandleFromFileID.SUCC;    WHILE runner # nullLockHandle DO      numberOfGetLockHandleFromFileIDSearches ¬        numberOfGetLockHandleFromFileIDSearches.SUCC;      IF (file.fileID = runner.fileID) AND (volumeIndex = runner.volumeIndex) THEN        RETURN[runner];      runner ¬ runner.next;      ENDLOOP;    RETURN[nullLockHandle];    END;  --GetLockHandleFromFileID--          Hash: PROCEDURE [fileID: File.ID] RETURNS [CARDINAL] = INLINE {    RETURN[CARDINAL[LOOPHOLE[fileID, LONG CARDINAL] MOD numberOfBuckets]]};      IsLocked: PUBLIC ENTRY PROCEDURE [file: File.File, page: File.PageNumber,    searchLocation: FileLock.SearchLocation]    RETURNS [lockState: FileLock.LockState] =    -- checks to see if the specified file page is in any locked region of a     -- file or is below the beginning of any locked region of the file and    -- returns the result.    BEGIN    runner: LockHandle ¬ fileLockTable[Hash[file.fileID]];    volumeIndex: CARDINAL = VolTable.GetVolumeIndex[file.volumeID];    IF ~lockingEnabled THEN RETURN[notLocked];      -- note that it is OK to enter this proc (and this proc only) with      -- mapped file locking disabled    numberOfIsLocked ¬ numberOfIsLocked.SUCC;    IF searchLocation = checkOnlyPage THEN Bug[notImplemented];    lockState ¬ notLocked;    WHILE runner # nullLockHandle DO      numberOfIsLockedSearches ¬ numberOfIsLockedSearches.SUCC;      IF runner.mappedCount = 0 THEN Bug[zeroLockedPage];      IF (file.fileID = runner.fileID) AND (volumeIndex = runner.volumeIndex) AND        (page < runner.firstPage + runner.mappedCount) THEN	BEGIN	lockState ¬ runner.lockType;	EXIT;	END;      runner ¬ runner.next;      ENDLOOP;    IF debug THEN CheckBucket[Hash[file.fileID]];    RETURN[lockState];    END;  --IsLocked--        LockHandleToLP: PROCEDURE [lock: LockHandle]    RETURNS [LONG POINTER] = INLINE {    RETURN[LOOPHOLE[lock, LONG POINTER]]};        -- ==============================================   IsOkToDeleteFile: PUBLIC ENTRY PROCEDURE -- ==============================================    [file: File.File] RETURNS [ok: BOOLEAN ¬ TRUE]= {-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     mapUnitIndex: LONG CARDINAL;    runner: LockHandle;    prevNextAddr: LONG POINTER TO LockHandle;    vm: VM.Interval;    volumeIndex: CARDINAL = VolTable.GetVolumeIndex[file.volumeID];        IF ~lockingEnabled THEN RETURN[TRUE];    prevNextAddr ¬ @fileLockTable[Hash[file.fileID]];    runner ¬ prevNextAddr­;        WHILE runner # nullLockHandle DO          IF (file.fileID = runner.fileID) AND          (volumeIndex = runner.volumeIndex) THEN {	 	 mapUnitIndex ¬ runner.mapUnitIndex;	 vm ¬ VMExtras2.GetVMIntervalWithLockHandle[runner];	 IF vm.count = 0 --VM.nullInterval-- THEN RETURN[FALSE];	 DeleteWholeMapUnit[vm];	 -- * note: first do null-checking.	 	 UNTIL runner = nullLockHandle OR	       runner.mapUnitIndex # mapUnitIndex DO {	       	   next: LockHandle;	   storage: LONG POINTER;	   count: CARDINAL;	       	   next ¬ runner.next;	   [storage: storage, count: count] ¬ DeleteLockInternal[runner];	   [] ¬ SpaceInternal.DeallocateStorage[storage, count];	   runner ¬ next	   	   }	 ENDLOOP;	 	 runner ¬ prevNextAddr­;	 	 LOOP;	 };            prevNextAddr ¬ @runner.next;        runner ¬ runner.next;      ENDLOOP}; --IsOkToDeleteFile---- ==============================================   DiscardLockAndVMData: PUBLIC ENTRY PROCEDURE -- ==============================================    [file: File.File, size: File.PageCount] RETURNS [BOOLEAN]= {-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     mapUnitIndex: LONG CARDINAL ¬ 0; -- null    fullMapUnitUnmapped: BOOLEAN ¬ TRUE;    trushedStart: LONG CARDINAL ¬ LAST[LONG CARDINAL];    trushedEndPlusOne: LONG CARDINAL ¬ 0;    emptyIndex: CARDINAL ¬ maxTrushes;    runner: LockHandle ¬ fileLockTable[Hash[file.fileID]];    node: LockHandle ¬ runner;    volumeIndex: CARDINAL = VolTable.GetVolumeIndex[file.volumeID];        IF ~lockingEnabled THEN Bug[logicError];    IF trushedSpaceCount = maxTrushes THEN RETURN[FALSE];    -- * pre-scan file nodes and checks to see if the given file backs only one mapUnit.-- * we assume that lock nodes with a same mapUnitIndex exist consecutively in groups.       WHILE runner # nullLockHandle DO          IF (file.fileID = runner.fileID)      AND          (volumeIndex = runner.volumeIndex) AND        ((size <= runner.firstPage)         OR	 (size IN [node.firstPage..node.firstPage + node.mappedCount))) THEN {	 	   IF mapUnitIndex = 0 --null-- THEN 	     mapUnitIndex ¬ runner.mapUnitIndex	   ELSE 	     IF mapUnitIndex # runner.mapUnitIndex THEN 	       RETURN[FALSE]};	           runner ¬ runner.next;    ENDLOOP;-- * no file lock found, then return FALSE. But it's impossible case.   --    IF mapUnitIndex = 0 (null) THEN RETURN[FALSE];<<** GetVMIntervalAndDeleteLock: PROCEDURE   *	     [node        : LockHandle,   *	      mapUnitIndex: LONG CARDINAL,   *	      size        : File.PageCount]   *  RETURNS [vmStart     : LONG CARDINAL ¬ LAST[LONG CARDINAL],  *	      vmEndPlusOne: LONG CARDINAL ¬ 0] = INLINE { >>    WHILE node # nullLockHandle DO      IF mapUnitIndex = node.mapUnitIndex THEN { --=mapUnitIndex--	tmp: LONG CARDINAL;	thisInterval: VM.Interval;	-- * note that firstPage is 0-origin.	SELECT TRUE FROM	<<skip>>  size >= (node.firstPage + node.mappedCount) => {	    node ¬ node.next;	    fullMapUnitUnmapped ¬ FALSE;	    LOOP};	    <<del>>	  size <= node.firstPage => {	    storage: LONG POINTER;	    count: CARDINAL;	    next: LockHandle ¬ node.next;	    thisInterval ¬ 	      VMExtras2.GetVMIntervalWithLockHandle[node];	    IF thisInterval.count = 0 --VM.nullInterval-- THEN               Bug[strangeSpace];	    [storage: storage, count: count] ¬ DeleteLockInternal[node];	    [] ¬ SpaceInternal.DeallocateStorage[storage, count]; 	    node ¬ next};<<shrnk>> size IN [node.firstPage..            node.firstPage + node.mappedCount) => {	    fullMapUnitUnmapped ¬ FALSE;	    thisInterval ¬ 	      VMExtras2.GetVMIntervalWithLockHandle[node];	    IF thisInterval.count = 0 --VM.nullInterval-- THEN               Bug[strangeSpace];	    node.mappedCount ¬ size - node.firstPage;	    thisInterval.page ¬ thisInterval.page + node.mappedCount;	    thisInterval.count ¬ thisInterval.count - node.mappedCount;	    node ¬ node.next};	    <<4>>	 ENDCASE => Bug[logicError];	 	IF thisInterval.page < trushedStart THEN 	  trushedStart ¬ thisInterval.page;	IF (tmp ¬ thisInterval.page+thisInterval.count) 	     > trushedEndPlusOne THEN trushedEndPlusOne ¬ tmp;	     	} --=mapUnitIndex--      ELSE node ¬ node.next;    ENDLOOP; <<}; --GetVMIntervalAndDeleteLock-- >>-- * check the trushed vm interval. Here, the following case is impossible. --    IF trushedStart = LAST[LONG CARDINAL] AND--       trushedEndPlusOne = 0 THEN ERROR;       -- * the vm interval trashedVM is going to be unmapped partially.    -- * partially or entirely unmap the vm    IF fullMapUnitUnmapped THEN {      DeleteWholeMapUnit[        [page: trushedStart, count: trushedEndPlusOne - trushedStart]];      RETURN[TRUE]}    ELSE      VMExtras2.PartiallyUnmap[ --trashedVM--	[page: trushedStart, count: trushedEndPlusOne - trushedStart]];    -- * put the space [trushedStart..trushedEndPlusOne) into trushedSpaceList.-- * first, check to see if the trashed spaces with the same mapUnitIndex are listed.    IF trushedSpaceCount # 0 THEN {      FOR i: CARDINAL IN [0..maxTrushes) DO 	IF (mapUnitIndex = trushedSpaceList[i].mapUnit) AND	   (trushedEndPlusOne = trushedSpaceList[i].begin) THEN {	     trushedSpaceList[i].begin ¬ trushedStart;	     RETURN[TRUE]}	 ELSE 	   IF emptyIndex = maxTrushes AND	      trushedSpaceList[i].mapUnit = 0 THEN emptyIndex ¬ i;      ENDLOOP}    ELSE emptyIndex ¬ 0;-- * trushedSpaceList is exhausted. currently no backup. (impossible case)--  IF emptyIndex = maxTrushes THEN Bug[logicError];-- * put the new entry in.        trushedSpaceList[emptyIndex] ¬ [      mapUnitIndex, trushedStart, trushedEndPlusOne];    trushedSpaceCount ¬ SUCC[trushedSpaceCount];    RETURN[TRUE]        }; --DiscardLockAndVMData---- ==============================================    AnyTrashedSpace: PUBLIC ENTRY PROCEDURE -- ==============================================    [sp: VM.Interval] RETURNS [newSpace: VM.Interval]= {-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- * no trushed space.        IF trushedSpaceCount = 0 THEN RETURN[sp];    newSpace ¬ AnyTrashedSpaceInternal[sp]}; --AnyTrasuedSpace--    -- ==============================================    AnyTrashedSpaceInternal: INTERNAL PROCEDURE -- ==============================================    [sp: VM.Interval] RETURNS [VM.Interval] = {-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     endPlusOne: Environment.PageNumber;    -- * note that trushed space only exists consecutively after the given vm.    endPlusOne ¬ sp.page + sp.count;        FOR i: CARDINAL IN [0..maxTrushes) DO      IF (trushedSpaceList[i].mapUnit # 0 --null--) AND         (endPlusOne = trushedSpaceList[i].begin) THEN {	   sp.count ¬ trushedSpaceList[i].after - sp.page;	   trushedSpaceList[i] ¬ nullTrushedSpace;	   trushedSpaceCount ¬ PRED[trushedSpaceCount];	   RETURN[sp]}    ENDLOOP;-- * no trushed space found for sp.    RETURN[sp];        }; --AnyTrashedSpaceInternal---- ==============================================    DeleteWholeMapUnit: INTERNAL PROCEDURE -- ==============================================    [vm: VM.Interval] = INLINE {-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     VM.Unmap[vm.page];    IF trushedSpaceCount # 0 THEN      vm ¬ AnyTrashedSpaceInternal[vm];    MapLog.WriteLog[vm, readWrite, NIL, NIL];    Space.Deallocate[      [Environment.LongPointerFromPage[vm.page], vm.count]];    }; --DeleteWholeMapUnit--    END.  LOG.22-Jul-86 15:51:35  RSV  Created File.18-Sep-86 10:47:16  RSV  Fixed bug in running through locks in DeleteLock and IsLocked.21-Oct-86 10:32:32  RSV  Bug fixes in DeleteLock for table containing nullLockHandle and IsLocked for correct range checking. 3-Nov-86 10:39:11  RSV  Implemented GetLockHandleFromFileID.17-Nov-86 15:05:47  RSV  Implemented Error.21-Nov-86 16:09:22  RSV  Made Errors RETURN WITH ERROR. 1-Dec-86 16:48:40  RSV  Changed GetLockHandleFromFileID to ENTRY.18-Dec-86 17:52:36  RSV  Added CheckBucket procedure and debug BOOLEAN. 3-Feb-87 11:02:52  RSV  Added Performance variables (exported to FileBasicsPerf), changed debug to FALSE. 4-Aug-88 13:35:28  RSV  Adding lockingEnabled for disabling mapped file locking.17-Jan-89 18:01:22  RSV  Export to SpacePerfExtras, not SpacePerf.27-Mar-89 18:08:32  TXT  Add mappedCount in FileLockNode.11-Apr-89 11:51:07  TxH  Added DiscardLockAndVMData and AnyTrashedSpace. Made a lot of other related changes. (SS-FX: AR#6, AR#26)16-May-89  1:24:44  TxH  Added IsOkToDeleteFile and made some other changes.
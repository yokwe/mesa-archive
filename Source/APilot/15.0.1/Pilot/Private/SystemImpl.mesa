-- File: SystemImpl.mesa - last edit:-- AOF                 29-Oct-87 18:51:56-- RSV                 24-Mar-87 11:07:58-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved. -- THINGS TO DO:-- 1) Get rid of call to TemporarySetGMT.SetGMT if ever through with gmt clock simulationDIRECTORY  DeviceCleanup USING [Await, Item, Reason],  Environment USING [Long],  Inline USING [BITAND, LongDiv, LongDivMod, LongMult, LowHalf],  KernelPhysicalVolume USING [    GetSavedLocalTimeParameters, SetSavedLocalTimeParameters],  KernelPrograms USING [],  PilotSwitchesExtraExtraExtraExtras USING [ignoreClockFailures],  Process USING [DisableAborts, MsecToTicks, SetTimeout],  ProcessorFace USING [    GetGreenwichMeanTime, gmtEpoch, GreenwichMeanTime,    microsecondsPerHundredPulses, PowerOff, processorID,    ResetAutomaticPowerOn, SetAutomaticPowerOn, SetGreenwichMeanTime],  Runtime USING [CallDebugger, GetBuildTime],  SpecialSystem USING [HostNumber, ProcessorID, SocketNumber],  System USING [    BootDevice, GetClockPulses, GreenwichMeanTime, LocalTimeParameters,     Microseconds, MicrosecondsToPulses, PhysicalVolumeID, Pulses, Switches,     TimerHandle, UniversalID],  SystemExtras USING [],  SystemInternal USING [UniversalID],  TemporarySetGMT USING [SetGMT, TimeZoneDirection],  Volume USING [Close, GetNext, ID, nullID];SystemImpl: MONITOR  IMPORTS    DeviceCleanup, KernelPhysicalVolume, Inline, Process, ProcessorFace,    Runtime, System, TemporarySetGMT, Volume  EXPORTS KernelPrograms, System, SystemExtras, SpecialSystem =  BEGIN OPEN System;  HostNumber: PUBLIC --System.-- TYPE = SpecialSystem.HostNumber;  SocketNumber: PUBLIC --System.-- TYPE = SpecialSystem.SocketNumber;  UniversalID: PUBLIC --System.-- TYPE = SystemInternal.UniversalID;  -- Exported variables:  isDiagnosticPilot: PUBLIC --System.-- BOOLEAN;  isUtilityPilot: PUBLIC --SpecialSystem.-- BOOLEAN;  switches: PUBLIC --System., SpecialSystem.-- System.Switches;  systemBootDevice: PUBLIC --System.-- System.BootDevice;  -- Due to export name conflicts, System.nullNetworkAddress is exported and initialized by PilotControl.  localHostNumber: PUBLIC --System.-- HostNumber ¬ GetProcessorID[];  timeBooted: PUBLIC --SpecialSystem.-- System.GreenwichMeanTime;    ClockFailed: PUBLIC --SystemExtras.-- SIGNAL = CODE;  LocalTimeParametersUnknown: PUBLIC --System.-- ERROR = CODE;  Overflow: PUBLIC --System.-- ERROR = CODE;  -- for interval timer  Unimplemented: PUBLIC --SpecialSystem.-- ERROR = CODE;    oneSecond: CONDITION;  uidCounter: LONG CARDINAL;  -- always <= SecondsSinceEpoch[GetGreenwichMeanTime[]]  uidCounterValid: BOOLEAN ¬ FALSE;  Bug: PRIVATE ERROR = CODE;      --~~~~~~~~~~ Initialization: ~~~~~~~~~~    InitializeSystemA: PUBLIC --ControlPrograms.-- PROCEDURE [    pSw: LONG POINTER TO System.Switches, bootDev: System.BootDevice] = {    switches ¬ pSw­;    systemBootDevice ¬ bootDev };    InitializeSystemB: PUBLIC --ControlPrograms.-- PROCEDURE [    isUtilPilot, isDiagPilot: BOOLEAN] =    BEGIN    isUtilityPilot ¬ isUtilPilot;    isDiagnosticPilot ¬ isDiagPilot;    Process.DisableAborts[@oneSecond];    Process.SetTimeout[@oneSecond, Process.MsecToTicks[1000]];    IF ~isUtilityPilot AND ~isDiagnosticPilot THEN      InitializeLocalTimeParameters[];  -- may set GMT from Ethernet too    InitializeGMTCleanup[];    InitializeUIDCleanup[];    END;  InitializeLocalTimeParameters: PROC = INLINE    BEGIN    valid: BOOLEAN;    zoneDirection: TemporarySetGMT.TimeZoneDirection;    [paramsValid: valid, zoneDirection: zoneDirection,     zone: ltp.zone, zoneMinutes: ltp.zoneMinutes,     beginDST: ltp.beginDST, endDST: ltp.endDST] ¬ TemporarySetGMT.SetGMT[      earliestAcceptableTime: Runtime.GetBuildTime[],      latestAcceptableTime:   --default to ProcessorFace.gmtEpoch for now--];    ltp.direction ¬ IF zoneDirection=west THEN west ELSE east;    IF valid THEN ltpState ¬ known;    timeBooted ¬ GetGreenwichMeanTime[];    END;  --~~~~~~~~~~ Implementation: ~~~~~~~~~~    GetIntervalTime: PUBLIC PROC [t: TimerHandle] RETURNS [Microseconds] = {    RETURN[PulsesToMicroseconds[[GetClockPulses[] - LOOPHOLE[t, Pulses]]]]};  PulsesToMicroseconds: PUBLIC PROC [p: Pulses] RETURNS [Microseconds] = {    -- (p*msPerHp)/(100units/hundred)     RETURN[MultThenDiv[p, ProcessorFace.microsecondsPerHundredPulses, 100]]};  MicrosecondsToPulses: PUBLIC PROC [m: Microseconds] RETURNS [Pulses] = {    -- (microseconds*100units/hundred)/microsecondsPerHundredPulses    RETURN[[MultThenDiv[m, 100, ProcessorFace.microsecondsPerHundredPulses]]]};  MultThenDiv: PROC [m1: LONG CARDINAL, m2: CARDINAL, dv: CARDINAL]    RETURNS [result: LONG CARDINAL] = {    OPEN Inline, mm1: LOOPHOLE[m1, num Environment.Long];    t: MACHINE DEPENDENT RECORD [      SELECT OVERLAID * FROM      separate => [low, mid, high: CARDINAL],      lower =>    [lowlong: LONG CARDINAL, junk: CARDINAL],      higher =>   [junk: CARDINAL, highlong: LONG CARDINAL],      ENDCASE];    t.lowlong ¬ LongMult[mm1.lowbits, m2];    IF mm1.highbits # 0 THEN {      t.highlong ¬ LongMult[mm1.highbits, m2] + t.mid;      IF t.high # 0 THEN {        OPEN q: LOOPHOLE[result, num Environment.Long];        -- have to do triple divide        IF t.high >= dv THEN t.high ¬ t.high MOD dv;  -- overflow; lowbits will be right        [quotient: q.highbits, remainder: t.mid] ¬ LongDivMod[t.highlong, dv];        q.lowbits ¬ LongDiv[t.lowlong, dv];        RETURN}};    -- t.high is 0, so let mesa do the work...    RETURN[t.lowlong/LONG[dv]]};  --~~~~~~~~~~ GMT: ~~~~~~~~~~    maximumSetBack: PUBLIC CARDINAL ¬ 4*60*60;  -- four hours  SetBackTooFar: PUBLIC ERROR = CODE;  clockSlipping: PUBLIC BOOLEAN ¬ FALSE;   --equivalent to (timeSlipLeft # 0) AOF  timeLastSet: ProcessorFace.GreenwichMeanTime ¬    ProcessorFace.GetGreenwichMeanTime[];    worldSwapped: BOOLEAN ¬ FALSE;  timeSlip: LONG CARDINAL ¬ 0;  -- Time slipped back  timeSlipLeft: LONG CARDINAL ¬ 0;  -- Time left to consume  lastRead: ProcessorFace.GreenwichMeanTime ¬ timeLastSet;  pulsesLastRollover: System.Pulses ¬ System.GetClockPulses[];  excessPulses: LONG CARDINAL = System.MicrosecondsToPulses[6D7];    GetGreenwichMeanTime: PUBLIC ENTRY PROC RETURNS [GreenwichMeanTime] =    BEGIN ENABLE UNWIND => NULL;    intPulses: System.Pulses ¬ GetClockPulses[];    intGmt: ProcessorFace.GreenwichMeanTime ¬      ProcessorFace.GetGreenwichMeanTime[];    IF worldSwapped THEN       BEGIN      worldSwapped ¬ FALSE;      <<IF lastRead > intGmt THEN << {        IF NOT >> ProcessorFace.SetGreenwichMeanTime[lastRead]     -- THEN ClockFailure[]} -->>      IF lastRead > intGmt THEN ProcessorFace.SetGreenwichMeanTime[lastRead]      ELSE lastRead ¬ intGmt;      pulsesLastRollover ¬ GetClockPulses[];      clockSlipping ¬ ((timeSlipLeft ¬ timeSlip) # 0);  --AOF      RETURN[[lastRead]]      END;    IF intGmt - lastRead = 0 THEN {      IF intPulses - pulsesLastRollover > excessPulses THEN ClockFailure[]}    ELSE pulsesLastRollover ¬ GetClockPulses[];    IF timeSlip = 0 THEN lastRead ¬ intGmt      ELSE BEGIN      << Apply the amount of time that has passed since last called to the time       we are slipping back, and (perhaps) one second to the time progressed. >>       delta: LONG CARDINAL = intGmt - lastRead;      lastRead ¬ intGmt;      SELECT delta FROM	= 0 => intGmt ¬ intGmt - timeSlip + timeSlipLeft;	>= timeSlipLeft => 	  BEGIN	  SetClock[- timeSlip];	  lastRead ¬ intGmt ¬ intGmt - timeSlip;	  timeSlip ¬ timeSlipLeft ¬ 0;	  pulsesLastRollover ¬ GetClockPulses[];	  END;	ENDCASE =>  -- IN [1.. timeSlipLeft)	  BEGIN	  timeSlipLeft ¬	    timeSlipLeft - delta + Inline.BITAND[1, Inline.LowHalf[intGmt]];	  intGmt ¬ intGmt - timeSlip + timeSlipLeft;	  END;      END;    clockSlipping ¬ (timeSlipLeft # 0);  --AOF    RETURN[[intGmt]]    END;      AdjustClock: PUBLIC ENTRY PROC [delta: LONG INTEGER] =     BEGIN ENABLE UNWIND => NULL;    SELECT TRUE FROM      delta = 0 => timeLastSet ¬ ProcessorFace.GetGreenwichMeanTime[];      delta > 0 =>         BEGIN -- immediately set the clock ahead        timeSlip ¬ timeSlipLeft ¬ 0;	SetClock[delta];	END;      - delta IN [1..maximumSetBack] =>         BEGIN --  start to slip the clock back	timeSlip ¬ timeSlipLeft ¬  - delta;	lastRead ¬ ProcessorFace.GetGreenwichMeanTime[];	pulsesLastRollover ¬ System.GetClockPulses[];	END;      - delta > maximumSetBack =>  --  attempted to set back too far!        RETURN WITH ERROR SetBackTooFar;      ENDCASE;    clockSlipping ¬ (timeSlipLeft # 0);    RETURN    END;    ClockFailure: INTERNAL PROCEDURE = {    IF switches[      PilotSwitchesExtraExtraExtraExtras.ignoreClockFailures] = up    THEN SIGNAL ClockFailed};    SetClock: INTERNAL PROC [delta: LONG INTEGER] =    BEGIN    time, oldTime: ProcessorFace.GreenwichMeanTime;    startPulses: System.Pulses ¬ GetClockPulses[];    time ¬ oldTime ¬ ProcessorFace.GetGreenwichMeanTime[];    DO      oldTime ¬ time;      time ¬ ProcessorFace.GetGreenwichMeanTime[];      IF time = oldTime THEN EXIT;      IF GetClockPulses[] - startPulses > excessPulses THEN {        ClockFailure[]; EXIT};      ENDLOOP;    -- IF NOT -- ProcessorFace.SetGreenwichMeanTime[time+delta] -- THEN ClockFailure[] --;    lastRead ¬ timeLastSet ¬ time + delta;    pulsesLastRollover ¬ System.GetClockPulses[];    END;    TimeLastSet: PUBLIC ENTRY PROCEDURE RETURNS[System.GreenwichMeanTime] =    {RETURN[[timeLastSet]]};  InitializeGMTCleanup: PROC =    BEGIN OPEN DeviceCleanup;    item: Item;    DO      reason: Reason = Await[@item];      SELECT reason FROM turnOff => worldSwapped ¬ TRUE; ENDCASE;      ENDLOOP;    END;  ltpState: {    unknown,        -- => ltp undefined    known,          -- => ltp defined, but may not be saved on nonvolatile storage    knownAndSaved}  -- ltp defined and saved on nonvolatile storage--  ¬ unknown;  ltp: LocalTimeParameters;  -- (InitializeLocalTimeParameters is up with the other initialization code.)    GetLocalTimeParameters: PUBLIC ENTRY PROC [pvID: PhysicalVolumeID]    RETURNS [LocalTimeParameters] = {    ENABLE UNWIND => NULL;    valid: BOOLEAN;    SELECT ltpState FROM      unknown => { -- try to read them from nonvolatile storage        [valid, ltp] ¬ KernelPhysicalVolume.GetSavedLocalTimeParameters[pvID];        IF valid THEN ltpState ¬ knownAndSaved        ELSE RETURN WITH ERROR LocalTimeParametersUnknown};      known =>  --  (try to) make sure they are saved on nonvolatile storage        SetSavedLTP[pvID];      ENDCASE;    RETURN[ltp]};  SetLocalTimeParameters: PUBLIC ENTRY PROC [    params: LocalTimeParameters, pvID: PhysicalVolumeID] = {    ENABLE UNWIND => NULL;    SELECT TRUE FROM      ltpState = knownAndSaved AND ltp = params => NULL;      ENDCASE => {ltp ¬ params; ltpState ¬ known; SetSavedLTP[pvID]}};  -- Write local time parameters to nonvolatile storage, if they are different.  SetSavedLTP: INTERNAL PROC [pvID: PhysicalVolumeID] ={    OPEN KernelPhysicalVolume;    valid: BOOLEAN;    savedltp: LocalTimeParameters;    [valid, savedltp] ¬ GetSavedLocalTimeParameters[pvID];    IF ~valid OR savedltp ~= ltp THEN      IF NOT SetSavedLocalTimeParameters[params: ltp, pvID: pvID].updated THEN GOTO NotSaved;    ltpState ¬ knownAndSaved;  -- (unless pvID=nullID and isUtilityPilot)    EXITS NotSaved => NULL};  --~~~~~~~~~~ Universal identifiers: ~~~~~~~~~~  -- Generate new universalID from the processorID and universal id counter.  -- Sequence field of resultant value always less than  --  SecondsSinceEpoch[GetGreenwichMeanTime].  GetProcessorID:  PUBLIC PROC RETURNS [SpecialSystem.ProcessorID] = {    RETURN[LOOPHOLE[ProcessorFace.processorID]]};  GetUniversalID: PUBLIC ENTRY PROC RETURNS [UniversalID] = {    secondsSinceEpoch: LONG CARDINAL;    nextUID: SystemInternal.UniversalID;    -- If clock isn't set, GetGreenwichMeanTime returns gmtEpoch, so uidCounter=0    DO      secondsSinceEpoch ¬        ProcessorFace.GetGreenwichMeanTime[] - ProcessorFace.gmtEpoch;      IF secondsSinceEpoch = 0 THEN        Runtime.CallDebugger["GetUniversalID: GMT clock not set"L];      IF ~uidCounterValid THEN {  -- clock set after initialization        uidCounter ¬ secondsSinceEpoch; uidCounterValid ¬ TRUE};      IF uidCounter < secondsSinceEpoch THEN EXIT;      WAIT oneSecond;      ENDLOOP;    nextUID ¬ [processor: LOOPHOLE[ProcessorFace.processorID], sequence: uidCounter];    uidCounter ¬ uidCounter + 1;    RETURN[nextUID]};  InitializeUIDCleanup: PROC =    BEGIN OPEN DeviceCleanup;    item: Item;    DO      reason: Reason = Await[@item];      SELECT reason FROM turnOff => uidCounterValid ¬ FALSE; ENDCASE;      ENDLOOP;    END;  --~~~~~~~~~~ System Power Control: ~~~~~~~~~~  PowerOff: PUBLIC PROC = {    vID: Volume.ID ¬ Volume.nullID;    UNTIL (vID ¬ Volume.GetNext[vID]) = Volume.nullID DO      Volume.Close[vID] ENDLOOP;    ProcessorFace.PowerOff[]};  ResetAutomaticPowerOn: PUBLIC PROC = {ProcessorFace.ResetAutomaticPowerOn[]};  SetAutomaticPowerOn: PUBLIC PROC [    time: GreenwichMeanTime, externalEvent: BOOLEAN] = {    ProcessorFace.SetAutomaticPowerOn[time, externalEvent]};  END.LOG(For earlier log entries, please see Mesa 8.0 archive version.)February 14, 1981  6:34 PM	PXM       Set ltpState at least to known in SetLocalTimeParameters19-Aug-81 18:58:19	AWL         Deleted export of SystemInternal.24-Aug-81 15:30:49	FXH       export NetworkNumber, nullNetworkNumber; lose GetProcessorID to PilotControl.8-Nov-81 21:24:20	AWL         Added is{diagnostic UtilityPilot}: PUBLIC BOOLEAN17-Nov-81 11:09:39   WDK       Use StoragePrograms.WhichPilot. Main body code moved to InitializeSystem.  System.nullNetworkAddress moved to PilotControl.  GetProcessorID moved here from PilotControl. 7-Dec-81  8:12:21   AWL         Deleted export of NetworkAddress - it is now concrete in System. 7-Dec-81 15:06:05   KAM        Added AdjustClock, maximumSetBack, SetBackTooFar, clockSlipping, TimeLastSet, InitializeGMTCleanup and changed GetGreenwichMeanTime to handle changable clocks.17-Nov-81 11:09:39   WDK       KernelPrograms replaces ControlPrograms. InitializeLocalTimeParameters becomes INLINE. DisableAborts. 1-Apr-83 13:42:47   AWL         Implement localHostNumber.15-Jul-83 11:42:27   AWL         Delete gmt parameter to AdjustClock.11-Dec-83 16:36:49   EKN     Implement timeBooted.10-Apr-84  9:31:00   KAM        Fixed AR 5879 (clock goes backwards) in GetGreenwichMeanTime. 2-Aug-84 16:53:11   KAM        Fixed AR 6390 (early setting of timeBooted) and added clock fault detection 1-May-85 10:04:19   ET   Export SystemExtras. 1-Oct-85 17:40:44   ET/KAM   Fix AR 8093. Changed GetGreenwichMeanTime to initialize intPulses before intGmt and set pulsesLastRollover ¬ GetClockPulses.27-Feb-86 15:03:06   RSV   Changed raising ClockFailed timeout from 5 seconds to 60 seconds.24-Mar-87 11:08:10   RSV   Added UNWINDs to GetLocalTimeParameters and SetLocalTimeParameters per AR 10447.29-Oct-87 18:49:57   AOF   AR#12149 - Clock Slipping State Incorrectly Maintained
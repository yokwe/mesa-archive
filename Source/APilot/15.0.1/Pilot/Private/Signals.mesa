-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- MesaRuntime>Signals.mesa         1-Jul-86 13:55:59 by MEW  DIRECTORY  CatchFormat USING [    CallCatch, CatchAction, CatchEV, CatchEVBody, CatchFrameHandle,    CatchIndex, CatchNull, Codebase, defaultFsi, EnableHandle, EnableItem,    EnableTable, EnableTableBody],  CPSwapDefs USING [SignalError],  Environment USING [Byte],  ESCAlpha USING [aPI],  Frame USING [    Alloc, Free, GetReturnFrame, MyLocalFrame, ReadLocalWord,     ReadPC, ReadReturnLink, SetReturnLink, WritePC, WriteReturnLink],  FrameExtras USING [MyGFTHandle, ReadCodebase, ReadGlobalLink, WriteGlobalLink],  Inline USING [COPY],  Mopcodes USING [zCATCH, zESC, zJ2],  PrincOps USING [    BytePC, ControlLink, frameSizeMap, LocalFrameHandle, LocalOverhead,    nullLocalFrame, ShortControlLink, stackDepth, StateVector],  RuntimeInternal USING [ProcessUncaught],  RuntimePrograms USING [],  SDDefs USING [    SD, sError, sErrorList, sReturnError, sReturnErrorList, sSignal, sSignalList,    sUnnamedError],  SpecialRuntime USING [];Signals: PROGRAM  IMPORTS Frame, FrameExtras, Inline, RuntimeInternal  EXPORTS RuntimePrograms, SpecialRuntime =  BEGIN  -- Public items:    GetCurrentSignal: PUBLIC --SpecialRuntime.-- SIGNAL RETURNS [    signal: --GENERIC-- SIGNAL, signalArgs: PrincOps.LocalFrameHandle] = CODE;  ResumeError: PUBLIC --SpecialRuntime.-- SIGNAL = CODE;  -- Private items:    unnamedError: SIGNAL ¬ LOOPHOLE[LONG[-1]];  -- SHOULD be in PrincOps!    Byte: TYPE = Environment.Byte;  LocalFrameHandle: TYPE = PrincOps.LocalFrameHandle;  BytePC: TYPE = PrincOps.BytePC;  Codebase: TYPE = CatchFormat.Codebase;  CatchIndex: TYPE = CatchFormat.CatchIndex;  CatchNull: CatchIndex = CatchFormat.CatchNull;  CatchEV: TYPE = CatchFormat.CatchEV;  CatchContinue: TYPE = PROCEDURE;  CodeBytes: PROCEDURE [cb: Codebase]    RETURNS [LONG POINTER TO PACKED ARRAY [0..0) OF Byte] = INLINE    {RETURN[LOOPHOLE[cb]]};    signalHandlerPCWhenCallingCatch: BytePC;  << This is the pc of the SignalHandler procedure at the point  at which it has called a catch phrase. This is used by SignalHandler  to find other instances of itself in the call stack. >>  SmashedLink: PRIVATE ERROR = CODE;  InitializeSignals: PUBLIC --RuntimePrograms.-- PROCEDURE [] =    BEGIN OPEN SDDefs;    DiscoverPC: SIGNAL = CODE;    SD[sSignalList] ¬ LOOPHOLE[SignalList];    SD[sSignal] ¬ LOOPHOLE[Signal];    SD[sErrorList] ¬ LOOPHOLE[ErrorList];    SD[sError] ¬ LOOPHOLE[Error];    SD[sReturnErrorList] ¬ LOOPHOLE[ReturnErrorList];    SD[sReturnError] ¬ LOOPHOLE[ReturnError];    SD[sUnnamedError] ¬ LOOPHOLE[UnnamedError];    << The following bizzare code records the pc of the SignalHandler    procedure at the point at which it has called a catch phrase,    for later use by SignalHandler. >>    signalHandlerPCWhenCallingCatch ¬ [0];    SIGNAL DiscoverPC[ ! DiscoverPC => {      signalHandlerPCWhenCallingCatch ¬ Frame.ReadPC[Frame.GetReturnFrame[]]; RESUME}];    END;  -- Signaller "public" procs:  (invoked via the SD)    Error: PROCEDURE [sig: SIGNAL] = {    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;    SignalHandler[error, sig, @d.state, argsInStateVector, Frame.GetReturnFrame[]];    ERROR ResumeError};  ErrorList: PROCEDURE [signalArgs: PrincOps.LocalFrameHandle, sig: SIGNAL] = {    SignalHandler[error, sig, signalArgs, argsInFrame, Frame.GetReturnFrame[] !      UNWIND => Frame.Free[signalArgs]];    Frame.Free[signalArgs];    ERROR ResumeError};  ReturnError: PROCEDURE [sig: SIGNAL] = {    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..2) OF WORD,      raiser: LocalFrameHandle,      state: dst PrincOps.StateVector];    d.state ¬ STATE;    d.raiser ¬ Frame.GetReturnFrame[];    Frame.SetReturnLink[ -- patch return path around frame being freed      Frame.ReadReturnLink[d.raiser]];    SignalHandler[error, sig, @d.state, argsInStateVector, d.raiser !      UNWIND => Frame.Free[d.raiser]];    Frame.Free[d.raiser];    ERROR ResumeError};  ReturnErrorList: PROCEDURE [signalArgs: PrincOps.LocalFrameHandle, sig: SIGNAL] = {    raiser: LocalFrameHandle;    raiser ¬ Frame.GetReturnFrame[];    Frame.SetReturnLink[ -- patch return path around frame being freed      Frame.ReadReturnLink[raiser]];    SignalHandler[error, sig, signalArgs, argsInFrame, raiser !      UNWIND => {Frame.Free[raiser]; Frame.Free[signalArgs]}];    Frame.Free[raiser];    Frame.Free[signalArgs];    ERROR ResumeError};  Signal: PROCEDURE [sig: SIGNAL] = {    d: RECORD [      keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD,      state: dst PrincOps.StateVector];    d.state ¬ STATE;    SignalHandler[signal, sig, @d.state, argsInStateVector, Frame.GetReturnFrame[]]};  SignalList: PROCEDURE [signalArgs: PrincOps.LocalFrameHandle, sig: SIGNAL] = {    SignalHandler[signal, sig, signalArgs, argsInFrame, Frame.GetReturnFrame[] !      UNWIND => Frame.Free[signalArgs]];    Frame.Free[signalArgs]};  UnnamedError: PROCEDURE = {    SignalHandler[error, unnamedError, NIL, argsInStateVector, Frame.GetReturnFrame[]];    ERROR ResumeError};  -- The signal handler proper:  SignalHandler: PROCEDURE [    signalError: CPSwapDefs.SignalError,    sig: SIGNAL,  -- not "signal", to avoid aliasing with GetCurrentSignal arg.    sigArgs: POINTER,  -- not "signalArgs", to avoid aliasing with GetCurrentSignal arg.    argsLoc: {argsInFrame, argsInStateVector},    raiser: PrincOps.LocalFrameHandle] =    -- Note that raiser will not be on call stack for RETURN WITH ERROR.    -- Only frames on the call stack should get a shot at the signal.    BEGIN    SignalFrame: TYPE = POINTER TO FRAME[SignalHandler];    frame, nextFrame: LocalFrameHandle;    target, nextTarget: LocalFrameHandle;    start, catchFrame: LocalFrameHandle;    action: CatchFormat.CatchAction;    signalToSend: SIGNAL ¬ sig;    unwinding: BOOLEAN;    catchIndex: CatchIndex;    targetIndex: CatchIndex ¬ CatchNull;    catchPC, exitPC: BytePC;    catchState: dst PrincOps.StateVector;    codebase: Codebase;    catchEV: CatchEV;    self: LocalFrameHandle = Frame.MyLocalFrame[];    unwinding ¬ FALSE;    start ¬ GetFrame[Frame.ReadReturnLink[self]];    target ¬ PrincOps.nullLocalFrame;    DO      nextFrame ¬ start;      UNTIL nextFrame = target AND targetIndex = CatchNull DO        frame ¬ nextFrame;        IF FrameExtras.ReadGlobalLink[frame] = FrameExtras.MyGFTHandle[] AND	  Frame.ReadPC[frame] = signalHandlerPCWhenCallingCatch THEN          BEGIN OPEN thisSignaller: LOOPHOLE[frame, SignalFrame];          IF unwinding THEN            BEGIN            IF sig = thisSignaller.sig THEN              nextTarget ¬                IF thisSignaller.unwinding THEN thisSignaller.nextTarget                ELSE thisSignaller.nextFrame;            IF thisSignaller.unwinding THEN              BEGIN              IF thisSignaller.frame = Frame.ReadReturnLink[frame].frame THEN                Frame.WriteReturnLink[		  lf: frame, cl: [frame[thisSignaller.nextFrame]]];              Frame.Free[thisSignaller.frame];              END;            nextFrame ¬ GetFrame[Frame.ReadReturnLink[frame]];            END          ELSE            nextFrame ¬              IF sig # thisSignaller.sig THEN              IF thisSignaller.unwinding THEN thisSignaller.nextFrame              ELSE GetFrame[Frame.ReadReturnLink[frame]]              ELSE                IF thisSignaller.unwinding THEN thisSignaller.nextTarget                ELSE thisSignaller.nextFrame;          END        ELSE nextFrame ¬ GetFrame[Frame.ReadReturnLink[frame]];        IF unwinding AND nextTarget = frame THEN nextTarget ¬ nextFrame;        codebase ¬ LOOPHOLE[FrameExtras.ReadCodebase[	  FrameExtras.ReadGlobalLink[frame]]];        catchEV ¬ LOOPHOLE[codebase.header.catchCode/2];	catchIndex ¬ CheckCatch[catchEV, codebase, frame];        WHILE catchIndex # CatchNull DO	  IF frame = target AND targetIndex = catchIndex THEN GOTO StopUnwind;	  catchPC ¬ codebase[catchEV][catchIndex];	  catchFrame ¬ Frame.Alloc[IF CodeBytes[codebase][catchPC] = Mopcodes.zJ2	    THEN CodeBytes[codebase][catchPC+1] ELSE CatchFormat.defaultFsi];          FrameExtras.WriteGlobalLink[lf: catchFrame, 	    gftH: FrameExtras.ReadGlobalLink[frame]];          Frame.WriteReturnLink[lf: catchFrame, cl: [frame[self]]];          Frame.WritePC[lf: catchFrame, pc: catchPC];	  LOOPHOLE[catchFrame, CatchFormat.CatchFrameHandle].staticLink ¬ frame;          LOOPHOLE[catchFrame, CatchFormat.CatchFrameHandle].signal ¬ signalToSend;          LOOPHOLE[catchFrame, CatchFormat.CatchFrameHandle].message ¬ sigArgs;          action ¬ LOOPHOLE[LONG[catchFrame], CatchFormat.CallCatch][ !            GetCurrentSignal--RETURNS[signal, signalArgs]-- =>	      BEGIN	      copy: POINTER;	      IF sigArgs # NIL THEN	        BEGIN	        fsiForStack: CARDINAL = 4;		fsiForStackOK: BOOLEAN[		  PrincOps.frameSizeMap[fsiForStack] >		    PrincOps.stackDepth + SIZE[PrincOps.LocalOverhead]..TRUE] = TRUE;		sigArgsFsi: CARDINAL =		  IF argsLoc = argsInFrame THEN Frame.ReadLocalWord[sigArgs].fsi		  ELSE fsiForStack;		wordsToCopy: CARDINAL = IF argsLoc = argsInFrame THEN		   PrincOps.frameSizeMap[sigArgsFsi] -		    SIZE[PrincOps.LocalOverhead]		  ELSE PrincOps.stackDepth;		Inline.COPY[		  from: sigArgs,		  to: copy ¬ Frame.Alloc[sigArgsFsi],		  nwords: wordsToCopy];	        END	      ELSE copy ¬ NIL;	      RESUME[signal: signalToSend, signalArgs: copy];	      END	    ];          catchState ¬ STATE;          SELECT action FROM            reject => EXIT;            resume =>              IF unwinding THEN ERROR ResumeError              ELSE {STATE ¬ catchState; RETURN};            exit =>	      BEGIN              T: TYPE = RECORD [target: LocalFrameHandle, exitPC: BytePC];	      [target: target, exitPC: exitPC] ¬	        LOOPHOLE[@catchState.stk[catchState.stkptr-2], POINTER TO T]­;              targetIndex ¬ IF target = frame THEN catchIndex ELSE CatchNull;	      nextTarget ¬ nextFrame;              signalToSend ¬ LOOPHOLE[UNWIND];	      unwinding ¬ TRUE;              sigArgs ¬ NIL;              GO TO StartUnwind;	      END;            enable =>	      catchIndex ¬ catchState.stk[catchState.stkptr-1];            ENDCASE;          ENDLOOP;        IF unwinding THEN          BEGIN          IF frame = start THEN start ¬ nextFrame;          IF frame = Frame.ReadReturnLink[self].frame THEN            Frame.WriteReturnLink[lf: self, cl: [frame[nextFrame]]];          Frame.Free[frame];          END;        REPEAT StartUnwind => NULL; FINISHED => EXIT        ENDLOOP;      REPEAT StopUnwind => NULL;      ENDLOOP;    IF unwinding THEN Frame.WritePC[lf: target, pc: exitPC]    ELSE      RuntimeInternal.ProcessUncaught[        signal: sig, signalArgs: sigArgs, signalError: signalError,        raiser: raiser, root: frame];    END;  --SignalHandler--  CheckCatch: PROCEDURE [    catchEV: CatchEV, codebase: Codebase, frame: LocalFrameHandle]    RETURNS [catchIndex: CatchFormat.CatchIndex] =    BEGIN OPEN CatchFormat;    pc: BytePC;    catchIndex ¬ CatchNull;    IF catchEV = LOOPHOLE[0] THEN RETURN;    pc ¬ Frame.ReadPC[frame];    DO      SELECT CodeBytes[codebase][pc] FROM        Mopcodes.zCATCH => {catchIndex ¬ CodeBytes[codebase][pc+1]; EXIT};        Mopcodes.zESC =>	  IF CodeBytes[codebase][pc+1] = ESCAlpha.aPI THEN pc ¬ [pc + 2]	  ELSE EXIT;        ENDCASE => EXIT;      ENDLOOP;    IF catchIndex = CatchNull THEN      BEGIN      et: EnableTable =        LOOPHOLE[catchEV + SIZE[CatchEVBody[codebase[catchEV].count]]];      eh: EnableHandle ¬ @codebase[et];      ei: LONG POINTER TO EnableItem;      i, l, u: CARDINAL;      pc ¬ [pc-1]; -- since the pc is advanced from the range in the table      DO        l ¬ 1;        u ¬ eh.count;        DO          IF u < l THEN EXIT;	  i ¬ (l + u)/2;	  SELECT eh[i-1].start FROM	    < pc => l ¬ i + 1;	    > pc => u ¬ i - 1;	    ENDCASE => {u ¬ i; EXIT};	  ENDLOOP;        ei ¬ @eh[u-1];	IF u = 0 OR pc >= ei.start + ei.length THEN EXIT;        catchIndex ¬ ei.index;	IF ei.alsoNested THEN eh ¬ eh + SIZE[EnableTableBody[eh.count]]	ELSE EXIT;	ENDLOOP;      END;    END;  -- Utility routines:    GetFrame: PROCEDURE [shortLink: PrincOps.ShortControlLink] RETURNS [LocalFrameHandle] =    -- Returns nullLocalFrame if proc link encountered.    BEGIN    IF shortLink.proc THEN ERROR SmashedLink;    IF NOT shortLink.indirect THEN --frame link-- RETURN[shortLink.frame];    --ASSERT: link is a short indirect link.    FOR longLink: PrincOps.ControlLink ¬ shortLink.link­, longLink.link­ DO      IF longLink.proc THEN RETURN[PrincOps.nullLocalFrame];      IF NOT longLink.indirect THEN --frame link-- RETURN[longLink.frame];      ENDLOOP;    END;  END.LOGAug 7, 78  8:57 AM   JGS       Got Codebase from RuntimeInternal instead of CodebaseDefs.Aug 30, 78 2:06 PM   JGS    	Removed TrapDefs and PuntMesa.Mar 13, 79 3:15 PM   PXM    	Mesa 5.Apr 4, 79 11:02 AM   PXM    	Added (conditional) BytePC logic.Sep 21, 79 2:37 PM   PXM    	Removed (conditional) BytePC logic.May 3, 80 11:07 AM   FXH    	Mesa 6.0 Conversion.Jan 15, 81 4:09 PM   WDK    	InitizeSignals[].Feb 4, 81  1:05 PM   WDK    	PrincOps fields changed names.20-Aug-81 11:14:43   AWL      	Export SpecialRuntime instead of RuntimeInternal.26-Aug-81 10:52:27   AWL      	Codebase now in  SpecialRuntime20-Oct-81 20:00:22   JGS	Convert to new catch format and new instruction set17-Nov-81 15:05:24   JGS	Change SendMsgSignal to GetCurrentSignal.17-Nov-81 17:53:36   WDK    	Made GetCurrentSignal PUBLIC. 9-Dec-81 15:47:32   WDK    	Use ProcessUncaught.10-Dec-81 16:47:53   WDK    	Make it compile.27-Jan-82 14:00:04   RES  	Make enable interval test (] instead of [].28-Jan-82  9:22:03   CRF	Put brackets around pc-1 to satisfy compiler.14-Jul-83 12:02:40   RXJ        New pc test for finding other SignalHandlers; new CatchFrame format.18-Aug-83 13:08:42   WDK        Make compatible with new ProcessUncaught. CodeBytes becomes inline rather than machine code. GetFrame now hollers if proc link. Rewrote GetFrame. use dst StateVector. Redefined SignalHandler.argsLoc to be enumerated. ReturnErrorList freed rubbish, smashing frame heap. Pass raiser frame and signalError to SignalHandler, thence to debugger.22-Aug-83 15:10:44   WDK     	Must avoid aliasing signalArgs in GetCurrentSignal. 1-Dec-83 14:39:01	JXG       change = to ¬ in declaration of unnamedError, for CXH     CXH     9-Jan-84 14:04:28	RES  	Copy only stackDepth words when handling GetCurrentSignal for parameters in state vector 1-Jul-86 13:45:35	MEW	Updated to newest princops.
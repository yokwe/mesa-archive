-- Copyright (C) 1983, 1986, 1987  by Xerox Corporation. All rights reserved. -- PilotPrivate>PhysicalVolumeFormat.mesa  15-Jun-87 16:10:14 by RSV   DIRECTORY  Boot USING [DiskFileID, PVBootFiles],  Environment USING [PageCount, wordsPerPage],  Inline USING [BITXOR],  LogicalVolumeFormat USING [LogicalSubvolumeMarker],  PhysicalVolume USING [PageCount, PageNumber],  PilotDisk USING [nullFileID],  SystemInternal USING [MarkerID],  System USING [LocalTimeParameters, nullID, PhysicalVolumeID, VolumeID];PhysicalVolumeFormat: DEFINITIONS IMPORTS Inline =  BEGIN    -- BEWARE: The descriptors defined below cannot be reformatted without invalidating ALL outstanding Pilot volumes.  Remember also that non-reconstructable information added to the physical volume root page descriptor must also be added to the subvolume end marker page descriptor below.    -- PHYSICAL VOLUME ROOT PAGE  Handle: TYPE = LONG POINTER TO Descriptor;    DuplicateHandle: TYPE = LONG POINTER TO DuplicateDescriptor;  seal, Seal: CARDINAL = 121212B;  -- word zero of a valid physical volume descriptor (root page)  currentVersion: CARDINAL = 7;  -- increment each time Descriptor below is reformatted    MarkerID: TYPE = SystemInternal.MarkerID;    PageCount: TYPE = PhysicalVolume.PageCount;    PageNumber: TYPE = PhysicalVolume.PageNumber;  Descriptor: TYPE = MACHINE DEPENDENT RECORD [    -- the following information is relatively static    seal(0): CARDINAL ¬ Seal,  -- must be 1st field    version(1): CARDINAL ¬ currentVersion,  -- must be 2nd field    labelLength(2): CARDINAL [0..physicalVolumeLabelLength] ¬ 0,    pvID(3): System.PhysicalVolumeID,    bootingInfo(10B): Boot.PVBootFiles ¬ nullPVBootFiles,    -- must be at this offset as the microcode knows where to find it.    label(54B): LabelArray ¬ nullLabel | NULL,    subVolumeCount(100B): CARDINAL [0..maxSubVols],    subVolumeMarkerID(101B): MarkerID ¬ [System.nullID],    badPageCount(106B): PageCount ¬ 0,    maxBadPages(110B): PageCount ¬ maxNumberBadPages,    dataLostPageCount(112B): PageCount ¬ 0,    maxDataLostPages(114B): PageCount ¬ maxNumberDataLostPages,    onLineCount(116B): CARDINAL ¬ 0,  -- TEMPORARILY unused.    subVolumes(117B): ARRAY [0..maxSubVols) OF SubVolumeDesc,    fill1(321B): ARRAY [0..374B - 321B) OF WORD ¬ ALL[0],  -- fill to whole page    localTimeParametersValid(374B:0..15): BOOLEAN ¬ FALSE,    localTimeParameters(375B): System.LocalTimeParameters ¬ LOOPHOLE[LONG[0]],    checksum(377B): CARDINAL ¬ 0,  -- MUST be the last field of this page    -- followed, on immediately following pages, by a BadPageList with maxBadPages entries    badPageList(400B): BadPageListArray];  DuplicateDescriptor: TYPE = MACHINE DEPENDENT RECORD [    -- the following information is relatively static    seal(0): CARDINAL ¬ Seal,  -- must be 1st field    version(1): CARDINAL ¬ currentVersion,  -- must be 2nd field    labelLength(2): CARDINAL [0..physicalVolumeLabelLength] ¬ 0,    pvID(3): System.PhysicalVolumeID,    bootingInfo(10B): Boot.PVBootFiles ¬ nullPVBootFiles,    -- must be at this offset as the microcode knows where to find it.    label(54B): LabelArray ¬ nullLabel | NULL,    subVolumeCount(100B): CARDINAL [0..maxSubVols],    subVolumeMarkerID(101B): MarkerID ¬ [System.nullID],    badPageCount(106B): PageCount ¬ 0,    maxBadPages(110B): PageCount ¬ maxNumberBadPages,    dataLostPageCount(112B): PageCount ¬ 0,    maxDataLostPages(114B): PageCount ¬ maxNumberDataLostPages,    onLineCount(116B): CARDINAL ¬ 0,  -- TEMPORARILY unused.    subVolumes(117B): ARRAY [0..maxSubVols) OF SubVolumeDesc,    fill1(321B): ARRAY [0..374B - 321B) OF WORD ¬ ALL[0],  -- fill to whole page    localTimeParametersValid(374B:0..15): BOOLEAN ¬ FALSE,    localTimeParameters(375B): System.LocalTimeParameters ¬ LOOPHOLE[LONG[0]],    checksum(377B): CARDINAL ¬ 0,  -- MUST be the last field of this page        -- followed, on immediately following pages, by a DataLostPageList with maxDataLostPages entries        dataLostPageList(400B): DataLostPageListArray];  -- Placing the bad page table within Descriptor is a temporary hack to get  -- the bad page list out of the root page.  Eventually, it will be a separate  -- entity.  However, this requires that much code be changed.  Whenever the  -- change is made, the following must be maintained: the bad page list must  -- have the same ID and type as the root page and they must immediately follow  -- the root page on the physical volume.  -- The following describes the bad page table  BadPageList: TYPE = LONG POINTER TO BadPageListArray;  BadPageListArray: TYPE = ARRAY [0..maxNumberBadPages) OF PageNumber;    -- actual length is Descriptor.maxBadPages  maxNumberBadPages: CARDINAL = CARDINAL[(rootPageSize - 1)] *    (Environment.wordsPerPage / SIZE[PageNumber]);    -- current maximum number of bad pages permitted on a volume.  This number    -- may only be increased and never decreased.    -- NOT called maxBadPages due to compiler problem  -- Placing the data lost page table within DuplicateDescriptor is a temporary   -- hack to get the data lost page list out of the duplicate root page.   -- Eventually, it will be a separate entity.  However, this requires  -- that much code be changed.  Whenever the change is made, the following must  -- be maintained: the data lost page list must have the same ID and type  -- as the duplicate root page and they must immediately follow the duplicate  -- root page on the physical volume.  -- The following describes the bad page table  DataLostPageList: TYPE = LONG POINTER TO DataLostPageListArray;  DataLostPageHeader: TYPE = MACHINE DEPENDENT RECORD [    countPages(0): PageCount ¬ 0,    maxEntries(2): PageCount ¬ maxNumberDataLostPages];  DataLostPageListArray: TYPE = MACHINE DEPENDENT RECORD [    header(0): DataLostPageHeader,    pages(SIZE[DataLostPageHeader]):      ARRAY [0..maxNumberDataLostPages) OF PageNumber];    -- actual length is Descriptor.maxDataLostPages  maxNumberDataLostPages: CARDINAL = (CARDINAL[(duplicateRootPageSize - 1)] *    Environment.wordsPerPage - SIZE[DataLostPageHeader])/ SIZE[PageNumber];    -- current maximum number of data lost pages permitted on a volume.    -- This number may only be increased and never decreased.    -- NOT called maxDataLostPages due to compiler problem  -- SubVolumeDesc as stored on disk in physical volume root page and in  -- marker pages.  SubVolumeDesc: TYPE = MACHINE DEPENDENT RECORD [    lvID(0): System.VolumeID,    lvSize(5): PageCount,    lvPage(7): PageNumber,    pvPage(11B): PageNumber,    nPages(13B): PageCount];    maxSubVols: CARDINAL [10..10] = 10;    -- maximum subvolumes on a physical volume.  Because the subVolumes array    -- is just before the Fill area in the Descriptor, it is possible to    -- increment this field so that the subVolumes array effectively grows into    -- the Fill area.    nullBadPage: PageNumber = 0;  nullDataLostPage: PageNumber = 0;  nullDiskFileID: Boot.DiskFileID =  -- (only file ID is significant)    [PilotDisk.nullFileID, 0, LOOPHOLE[LONG[0]]];  nullLabel: LabelArray = ALL[0C];  nullPVBootFiles: Boot.PVBootFiles = ALL[nullDiskFileID];    physicalVolumeLabelLength: CARDINAL = 40;    LabelArray: TYPE = PACKED ARRAY [0..physicalVolumeLabelLength) OF CHARACTER;    rootPageNumber: PageNumber = 0;    rootPageSize: PageCount = 5;    «duplicateRootPageNumber: PageNumber ???; depends upon the disk type»    duplicateRootPageSize: PageCount = 5;    -- OTHER TRACK 0 RESERVED PAGES    sddPage: PageNumber= 14;         -- self describing disk page  diagnosticsPage: PageNumber= 15; -- diags blast this page to check reading cyl 0    -- MARKER PAGE    MarkerHandle: TYPE = LONG POINTER TO SubVolumeMarkerPage;    -- SubVolumeMarkerPage is set up to occupy a full page.    SubVolumeMarkerPage: TYPE = MACHINE DEPENDENT RECORD [    logical: LogicalVolumeFormat.LogicalSubvolumeMarker,    fill1: ARRAY SubVolumeFill1 OF WORD ¬ ALL[0]];    markerPageSize: Environment.PageCount = 1;    SubVolumeFill1: TYPE = [SIZE[    LogicalVolumeFormat.LogicalSubvolumeMarker]..Environment.wordsPerPage - 1);        IDCheckSum: PROCEDURE [pvID: System.PhysicalVolumeID] RETURNS [CARDINAL] =    INLINE    BEGIN OPEN LOOPHOLE[pvID, RECORD [a, b, c, d, e: WORD]], Inline;    RETURN[BITXOR[BITXOR[BITXOR[BITXOR[a, b], c], d], e]]    END;      -- THE FOLOWING ARE PRIVATE AND ARE COMPILE TIME VALIDITY CHECKS    descriptorSizeCheck: PRIVATE BOOLEAN =    rootPageSize*Environment.wordsPerPage = SIZE[Descriptor];    SubVolumeMarkerSizeCheck: PRIVATE BOOLEAN =    Environment.wordsPerPage*markerPageSize = SIZE[SubVolumeMarkerPage];  END.LOGMarch 14, 1979  2:59 PM		DXR      Create fileMarch 18, 1979  2:08 PM		DXR      Reformat descriptor; make machine dependentJuly 24, 1979  3:35 PM		FXH       Add physical volume names, volume type, swattee, debugger, etc; make ID a typeJuly 27, 1979  3:51 PM		FXH       Move most of last change to LogicalVolumeAugust 17, 1979  1:33 PM	DXR      Separate declarations of offline and online SubVolume Descriptors; add VolumeIDCheckSumSeptember 18, 1979  11:41 AM	CRF   Add badPageList, boot file IDs (microcode, germ, pilot), and checksum to root page descriptor; add subvolume end marker page descriptorSeptember 18, 1979  2:23 PM	FXH       Split off part of subvolumeEndMarker and moved to LogicalVolume; rename and mess with lots of minor thingsSeptember 18, 1979  3:44 PM	FXH       Change to use PVBootFilesSeptember 19, 1979  8:22 AM	FXH       Add a couple of comments to MarkerSeptember 19, 1979  1:42 PM	FXH       Add many default fieldsSeptember 20, 1979  10:42 AM	FXH       Change [1..n]'s to [0..n)'sJanuary 25, 1980  7:29 PM	FXH       Equate ID to SpecialVolume.PhyscialVolumeIDJanuary 27, 1980  7:43 AM	FXH       Delete nullID and UniversalID from USING of SystemMay 20, 1980  2:46 PM		AWL         PhysicalVolume=>PhysicalVolumeFormat; use ALL's in initializationsJune 16, 1980  10:32 AM	PXM       Changes to accommodate 48-bit processor ids, including additional XOR in IDCheckSum!September 17, 1980  2:18 PM	AWL         Changes to move bad page list off of the root pageJanuary 30, 1981  11:56 AM	PXM       Add LocalTimeParameters field to DescriptorJanuary 30, 1981  11:56 AM	PXM       SystemExtras=>System21-Oct-81 10:17:16		WDK       nullDiskFileID moved here from Boot.15-Sep-82 11:12:29	AWL         Changed types of Descriptor.(labelLength subVolumeCount) to have a closed end-of-interval. 6-Oct-82 13:42:22	AWL         Changed type of Descriptor.subVolumeMarkerID to SystemInternal.MarkerID.  Changed nullDiskFileID to get info from PilotDisk.  Added definition of MarkerPage.20-Oct-82  9:22:57	AWL         Added LabelArray, rootPageSize, SubmarkerHandle.  Made descriptorSizeCheck a BOOLEAN.15-Nov-82 12:07:40	AWL         Increase maxSubvols to 10. 8-Feb-83  9:44:03	JXP      Add a boolean, lvShouldBeScavenged, to the PhysicalSubVolume Marker.15-May-86 17:02:27      RSV   Changed length of PV Root Page to 5 pages (from 2) and incremented current version of PV root page to 7.  Changed name of maxBadPages constant to maxNumberBadPages.  Added DuplicateDescriptor, DuplicateHandle, etc... to reflect duplicating PV root page.29-Sep-86 15:05:20      RSV   Added DataLostTable to DuplicateDescriptor.  Added dataLostPageCount, maxDataLostPages to both PV descriptors.  Added DataLostPageListArray, DataLostPageList, and maxNumberDataLostPages.  Added maxDataLostPages to PhysicalSubvolumeMarker (and incremented PSMCurrentVersion).15-Dec-86 11:21:01      RSV   Commented out duplicateRootPageNumber since this is now disk type dependent.18-Jan-87 17:16:09      RSV   Changed definition of DataLostTable to include count internally.18-Feb-87 18:30:21      RSV   Added maxEntries and DataLostPageHeader11-Mar-87 15:02:16      RRR   Removed all references to physical volume marker.15-Jun-87 16:10:27      RSV   Added sddPage and diagnosticsPage definitions per AR 11037.
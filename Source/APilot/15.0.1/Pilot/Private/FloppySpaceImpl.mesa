-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved.-- FloppySpaceImpl.mesa     4-Feb-85 20:23:33 by EKN  DIRECTORY   BackingStore USING [Data, Run, TransferProc],   Environment USING [LongPointerFromPage, PageCount, PageNumber, wordsPerPage],   File USING [nullID],   Floppy USING [      Density, FileID, firstPageCount, GetAttributes, GetFileAttributes,       lastPageCount, nullVolumeHandle, Open, PageCount, VolumeHandle],   FloppyChannel USING [      Attributes, Context, DiskAddress, GetDeviceAttributes,      GetHandle, Handle, InterpretHandle, SetContext, Status],   FloppyDiskFace USING [GetDeviceAttributes],   FloppyExtrasExtras USING [GetDrive],   FloppyFormat USING [      dataContext, DiskAddressToSector, Sector, SectorToDiskAddress],   FloppySpace,   Runtime USING [GlobalFrame],   RuntimeInternal USING [Bug],   Space USING [      Access, Allocate, Class, Deallocate, Error, Interval, Life,      LongPointerFromPage, nullInterval, PageFromLongPointer, ReturnWait,      SwapUnitOption, Usage, virtualMemory],   SpecialFloppyChannel USING [ReadSectorsWithContext, WriteSectorsWithContext],   SpecialSpace USING [      MakeEntryVectorResident, MakeEntryVectorSwappable, MakeGlobalFrameResident,      MakeGlobalFrameSwappable, MakeProcedureResident, MakeProcedureSwappable,      SpecialError],   SpecialSpaceExtras USING [IsAllocated],   SpecialFloppy USING [GetDiskAddress, GetFileAtDiskAddress],   VM USING [      BackingStoreRuns, FindMapUnit, GetMapUnitAttributes, Interval, Map, Unmap];FloppySpaceImpl: MONITOR   IMPORTS      Floppy, FloppyChannel, FloppyDiskFace, FloppyExtrasExtras, FloppyFormat,      Runtime, RuntimeInternal, Space, SpecialFloppyChannel, SpecialSpace,       SpecialSpaceExtras, SpecialFloppy, VM   EXPORTS FloppySpace =   BEGIN   -- PRIVATE parameters, types and variables   -- Data structure passed to VM which defines a run of backing storage.   -- This record must be the same length as a BackingStore.Data, since it is    -- in effect an implementation of the "opaque type" BackingStore.Data.   Data: TYPE = MACHINE DEPENDENT RECORD [      channelHandle(0): FloppyChannel.Handle,      sector(2): FloppyFormat.Sector,      cylinders(3): CARDINAL,      tracksPerCylinder(4): CARDINAL,      sectorsPerTrack(5): CARDINAL,      density(6): Floppy.Density];   dataSizeCheck: PRIVATE BOOLEAN [TRUE..TRUE] =      (SIZE[Data] = SIZE[BackingStore.Data]);      countOfMappedSpaces: LONG CARDINAL ¬ 0;  --monitored data   defaultWindow: FloppySpace.Window = [      [Floppy.nullVolumeHandle, LOOPHOLE[File.nullID, Floppy.FileID]], 0, 0];   BugType: TYPE = {impossibleEndcase, wrongContext};   Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};   Error: ERROR [error: ErrorType] = CODE;   ErrorType: TYPE = {notMyMappedSpace};   -- PROCEDURES, in alphabetical order, of this module   GetMapUnitAttributes: PUBLIC PROCEDURE [pointer: LONG POINTER]      RETURNS [         interval: Space.Interval, window: FloppySpace.Window, usage: Space.Usage,         class: Space.Class, swapUnits: Space.SwapUnitOption] =      BEGIN      page: Environment.PageNumber = Space.PageFromLongPointer[pointer];      runs: ARRAY [0..1) OF BackingStore.Run;      backingStoreRuns: VM.BackingStoreRuns;      mapUnit: VM.Interval;      transferProc: BackingStore.TransferProc;      [mapUnit: mapUnit, transferProc: transferProc,         backingStoreRuns: backingStoreRuns, usage: usage, class: class,         swapUnits: swapUnits] ¬ VM.GetMapUnitAttributes[page, DESCRIPTOR[runs]];      interval ¬ [         pointer: Space.LongPointerFromPage[mapUnit.page], count: mapUnit.count];      IF mapUnit.count = 0 OR LENGTH[backingStoreRuns] = 0 THEN         BEGIN  -- unmapped memory or resident data map unit         window ¬ defaultWindow;         END      ELSE  -- actually mapped to some file         BEGIN         diskAddress: FloppyChannel.DiskAddress;         volumeHandle: Floppy.VolumeHandle;         fData: Data ¬ LOOPHOLE[runs[0].data, Data];         IF transferProc # Transfer THEN Error[notMyMappedSpace];         diskAddress ¬ FloppyFormat.SectorToDiskAddress[            fData.sector, fData.cylinders, fData.tracksPerCylinder,            fData.sectorsPerTrack];         volumeHandle ¬ Floppy.Open[            FloppyChannel.InterpretHandle[fData.channelHandle]];         [window.file, window.base] ¬ SpecialFloppy.GetFileAtDiskAddress[            volumeHandle, diskAddress];         window.count ¬ mapUnit.count         END;      END;   MakeCodeResident: ENTRY PROCEDURE RETURNS [ok: BOOLEAN ¬ FALSE] = {      IF countOfMappedSpaces = 0 THEN ok ¬ TRUE;      countOfMappedSpaces ¬ countOfMappedSpaces + 1};   MakeCodeSwappable: ENTRY PROCEDURE RETURNS [ok: BOOLEAN ¬ FALSE] = {      countOfMappedSpaces ¬ countOfMappedSpaces - 1;      IF countOfMappedSpaces = 0 THEN ok ¬ TRUE};   MakeTransferProcResident: PROCEDURE [] =      BEGIN      -- Note: if the floppyChannel procedures are ever in more than one code pack      -- this procedure will need reevaluating      SpecialSpace.MakeGlobalFrameResident[         FloppySpaceImpl !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeProcedureResident[         LOOPHOLE[Transfer] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeEntryVectorResident[         LOOPHOLE[Transfer] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeProcedureResident[         LOOPHOLE[SpecialFloppyChannel.ReadSectorsWithContext] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeGlobalFrameResident[         Runtime.GlobalFrame[LOOPHOLE[SpecialFloppyChannel.ReadSectorsWithContext]] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeGlobalFrameResident[         Runtime.GlobalFrame[LOOPHOLE[FloppyDiskFace.GetDeviceAttributes]] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeProcedureResident[         LOOPHOLE[FloppyDiskFace.GetDeviceAttributes] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      SpecialSpace.MakeEntryVectorResident[         LOOPHOLE[FloppyDiskFace.GetDeviceAttributes] !         SpecialSpace.SpecialError =>            IF error = alreadyResident THEN CONTINUE ELSE REJECT];      END;   MakeTransferProcSwappable: PROCEDURE [] =      BEGIN      -- Note: if the floppyChannel procedures are ever in more than one code pack      -- this procedure will need reevaluating      SpecialSpace.MakeGlobalFrameSwappable[         FloppySpaceImpl !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeProcedureSwappable[         LOOPHOLE[Transfer] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeEntryVectorSwappable[         LOOPHOLE[Transfer] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeProcedureSwappable[         LOOPHOLE[SpecialFloppyChannel.ReadSectorsWithContext] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeGlobalFrameSwappable[         Runtime.GlobalFrame[LOOPHOLE[SpecialFloppyChannel.ReadSectorsWithContext]] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeGlobalFrameSwappable[         Runtime.GlobalFrame[LOOPHOLE[FloppyDiskFace.GetDeviceAttributes]] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeProcedureSwappable[         LOOPHOLE[FloppyDiskFace.GetDeviceAttributes] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      SpecialSpace.MakeEntryVectorSwappable[         LOOPHOLE[FloppyDiskFace.GetDeviceAttributes] !         SpecialSpace.SpecialError =>            SELECT error FROM               alreadySwappable, fixedSwappability => CONTINUE               ENDCASE => REJECT];      END;   Map: PUBLIC PROCEDURE [      window: FloppySpace.Window, usage: Space.Usage, class: Space.Class,      access: Space.Access, life: Space.Life, swapUnits: Space.SwapUnitOption]      RETURNS [interval: Space.Interval] =      BEGIN      interval ¬ MapAtInternal[         Space.nullInterval, window, usage, class, access, life, swapUnits];      END;   MapAt: PUBLIC PROCEDURE [      at: Space.Interval, window: FloppySpace.Window, usage: Space.Usage,      class: Space.Class, access: Space.Access, life: Space.Life,      swapUnits: Space.SwapUnitOption] RETURNS [interval: Space.Interval] =      BEGIN      atPage: Environment.PageNumber ¬ Space.PageFromLongPointer[at.pointer];      mapUnit: VM.Interval ¬ VM.FindMapUnit[atPage];      IF at.count = 0 THEN ERROR Space.Error[invalidParameters];      IF atPage IN [mapUnit.page..mapUnit.page + mapUnit.count)         OR mapUnit.page IN [atPage..atPage + at.count) THEN         ERROR Space.Error[stillMapped];      IF ~SpecialSpaceExtras.IsAllocated[at] THEN ERROR Space.Error[notAllocated];      interval ¬ MapAtInternal[at, window, usage, class, access, life, swapUnits];      END;   MapAtInternal: PROCEDURE [      at: Space.Interval, window: FloppySpace.Window, usage: Space.Usage,      class: Space.Class, access: Space.Access, life: Space.Life,      swapUnits: Space.SwapUnitOption] RETURNS [interval: Space.Interval] =      BEGIN      attributes: FloppyChannel.Attributes;      diskAddress: FloppyChannel.DiskAddress;      fileSize: Floppy.PageCount;      floppyData: Data;      mapUnit: VM.Interval;      runs: ARRAY [0..1) OF BackingStore.Run;            --Note if at.count = 0 then must allocate memory      IF window.base ~IN [Floppy.firstPageCount..Floppy.lastPageCount) THEN         ERROR Space.Error[invalidWindow];      fileSize ¬ Floppy.GetFileAttributes[window.file].size;      IF window.base >= fileSize THEN ERROR Space.Error[noWindow];      mapUnit.count ¬ MIN[window.count, fileSize - window.base];      IF at.count > 0 AND mapUnit.count > at.count THEN         ERROR Space.Error[invalidParameters];  -- Not enough VM supplied.      interval ¬ [         pointer:         IF at.count = 0 THEN Space.Allocate[mapUnit.count].interval.pointer         ELSE at.pointer, count: mapUnit.count];      mapUnit.page ¬ Space.PageFromLongPointer[interval.pointer];      WITH sus: swapUnits SELECT FROM         unitary => NULL;         uniform => NULL;         irregular =>            BEGIN            suCount: Environment.PageCount ¬ 0;            FOR i: CARDINAL IN [0..LENGTH[sus.sizes]) DO               thisSize: Environment.PageCount = sus.sizes[i];               IF thisSize = 0 THEN ERROR Space.Error[invalidSwapUnitSize];               suCount ¬ suCount + thisSize;               ENDLOOP;            IF suCount < mapUnit.count THEN ERROR Space.Error[incompleteSwapUnits];            END;         ENDCASE => Bug[impossibleEndcase];      -- Begin calculating backingstore data      floppyData.channelHandle ¬         FloppyChannel.GetHandle[FloppyExtrasExtras.GetDrive[window.file.volume]];      floppyData.density ¬ Floppy.GetAttributes[window.file.volume, NIL].density;            IF ~FloppyChannel.SetContext[        floppyData.channelHandle, FloppyFormat.dataContext[floppyData.density]] 	THEN Bug[wrongContext];      attributes ¬          FloppyChannel.GetDeviceAttributes[floppyData.channelHandle].attributes;            floppyData.sectorsPerTrack ¬ attributes.maxSectorsPerTrack;      floppyData.cylinders ¬ attributes.numberOfCylinders;      floppyData.tracksPerCylinder ¬ attributes.numberOfHeads;      diskAddress ¬ SpecialFloppy.GetDiskAddress[window.file, window.base];      floppyData.sector ¬ FloppyFormat.DiskAddressToSector[         diskAddress, floppyData.cylinders, floppyData.tracksPerCylinder, 	 floppyData.sectorsPerTrack];            -- NOTE: I am also assumming there is only one run      runs[0].data ¬ LOOPHOLE[floppyData, BackingStore.Data];      runs[0].count ¬ mapUnit.count;      IF MakeCodeResident[] THEN MakeTransferProcResident[];      VM.Map[         mapUnit, Transfer, DESCRIPTOR[runs], usage, class, access, swapUnits,         life, swappable];      END;  --MapAtInternal--   Unmap: PUBLIC PROCEDURE [pointer: LONG POINTER, returnWait: Space.ReturnWait]      RETURNS [nil: LONG POINTER] =      BEGIN      interval: Space.Interval ¬ UnmapAt[pointer, returnWait];      Space.Deallocate[interval];      RETURN[NIL];      END;   UnmapAt: PUBLIC PROCEDURE [pointer: LONG POINTER, returnWait: Space.ReturnWait]      RETURNS [interval: Space.Interval] =      BEGIN      --returnWait treated as wait      run: ARRAY [0..1) OF BackingStore.Run;      page: Environment.PageNumber = Space.PageFromLongPointer[pointer];      mapUnit: VM.Interval ¬ VM.GetMapUnitAttributes[         page, DESCRIPTOR[run]].mapUnit;      VM.Unmap[mapUnit.page];      IF MakeCodeSwappable[] THEN MakeTransferProcSwappable[];      RETURN[[Space.LongPointerFromPage[mapUnit.page], mapUnit.count]];      END;   Transfer: BackingStore.TransferProc =      -- transData: LONG POINTER TO BackingStore.TransferData]       -- RETURNS [result: Result]      BEGIN      status: FloppyChannel.Status;      countDone: CARDINAL;      floppyData: Data ¬ LOOPHOLE[transData.data, Data];      context: FloppyChannel.Context ¬ FloppyFormat.dataContext[         IF floppyData.density = single THEN single ELSE double];      diskAddress: FloppyChannel.DiskAddress ¬ FloppyFormat.SectorToDiskAddress[         CARDINAL[floppyData.sector + transData.offsetFromData],         floppyData.cylinders, floppyData.tracksPerCylinder,         floppyData.sectorsPerTrack];      [status, countDone] ¬         (SELECT transData.operation FROM             read => SpecialFloppyChannel.ReadSectorsWithContext,             write => SpecialFloppyChannel.WriteSectorsWithContext,             ENDCASE => ERROR)[         floppyData.channelHandle, diskAddress, Environment.LongPointerFromPage[         transData.pageBuffer], CARDINAL[transData.countBuffer], TRUE, context];      IF status = goodCompletion THEN RETURN[[done[]]]      ELSE RETURN[[error[transData.pageBuffer + countDone]]];      END;   END.LOG 3-Aug-83 13:38:55	AWL        Created file from Space.mesa of 29-Apr-82 12:29:26. 1-Oct-84 12:04:38     EKN     Implemented each of the procedures. 4-Feb-85 20:23:29	EKN      Convert over to new FloppyChannel, FloppyFormat. Use FloppyExtrasExtras.GetDrive.
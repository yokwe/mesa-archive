-- Copyright (C) 1987, 1988  by Xerox Corporation.  All rights reserved. -- FloppyTapeImplA.mesa          3-Jun-88 11:44:15 by RSVDIRECTORY  DeviceTypesExtras4 USING [FloppyTape],  Environment USING [    bytesPerPage, bytesPerWord, PageFromLongPointer, wordsPerPage],  File USING [File, Type],  FloppyChannel USING [    Attributes, Context, DiskAddress, Error, FormatTracks, GetDeviceAttributes,    GetHandle, GetNextDrive, Handle, Nop, nullDrive, nullHandle, SetContext,    Status, WriteSectors],  FloppyDiskFace USING [DeviceHandle, Status],  FloppyTape USING [    ByteCount, ByteOffset, Drive, ErrorType, FeedBackPtr, FileHandle, localDrive,    maxBytesInName, NotifyClientProc, nullSectorNumber, SectorNumber, VolumeName],  FloppyTapeFormat USING [    BadSectorList, badSectorListSize, BadSectorType, BootPageDiskAddress,     BootPageFormat, DiskAddressToSector, eraseWord, firstDataAddress,     firstSector, floppyTapeContext, FloppyTapeSeal, FloppyTapeVersion,    InitialMicrocodeDiskAddress, MarkerPage, MarkerSeal, MarkerPageVersion,    maxNumberBadSectors, PackBadSectorNumber, RootPage, rootPageSector,    SectorToDiskAddress, UnpackBadSectorNumber],  FloppyTapeInternal USING [    buffer, bufferLock, BytesToPages, CheckBadSectorList, CheckMarkerPage,    CheckRootPage, CloseVolumeInternal, ConvertDiskAddressToFileID,    ConvertFileIDToSector, ConvertSectorToFileID, CreateBuffer,    CreateResidentBuffer, DoOperation, FilterStatus, ForceOutBuffers,     GetCountDone, IsPageBad, InitBadSectors, IsItABadPageError, minNumTicks,    myIocb, operationLock, OperationProc, ReadMarkerPage,    ReadRootAndBadSectorList, RealFileIDLoc, residentBufferSize,    SearchOurBufferForFile, SetBlock, ValidateHandle, ValidDrive,     verifyBufferSize, VolumeDesc, VolumeDescObject, WordsToPages,    WriteBadSectorList, WriteFloppyTape, WriteMarkerPage, WriteRootPage,    WriteWithSameData],  Heap USING [systemZone],  Inline USING [LongMult],  PilotFileTypes USING [tAnonymousFile],  Process USING [Pause],  RuntimeInternal USING [Bug],  Space USING [    CopyIn, Deallocate, Error, Interval, Kill, nullInterval, PageCount, Unmap],  SpecialFloppyChannel USING [DoDirectIO],  SpecialFloppyChannelExtras USING [GetDeviceHandle, Retention],  SpecialFloppyTape USING [BootFilePointer],  SpecialFloppyTapeFace USING [GetTapeParameters, Parameters],  System USING [GetGreenwichMeanTime, isUtilityPilot],  VM USING [Unmap];FloppyTapeImplA: MONITOR LOCKS ml USING ml: LONG POINTER TO MONITORLOCK  IMPORTS     Environment, FloppyChannel, FloppyTapeFormat, FloppyTapeInternal,    Heap, Inline, Process, RuntimeInternal, Space, SpecialFloppyChannel,    SpecialFloppyChannelExtras, SpecialFloppyTapeFace, System, VM  EXPORTS FloppyTape, FloppyTapeInternal, SpecialFloppyTape =  BEGIN   «NOTES   1) WHAT ABOUT changeCount and EXCLUSIVE ACCESS?   2) Anything that does GetHandle must do a SetContext before actually       writing or reading floppy tape»  -- globals --    markerByteSize: CARDINAL =     SIZE[FloppyTapeFormat.MarkerPage] * Environment.bytesPerWord;  markerPageSize: CARDINAL =    CARDINAL[FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.MarkerPage]]];  FileID: PUBLIC TYPE = FloppyChannel.DiskAddress;  --?  nullFileID: PUBLIC FileID ¬ [cylinder: 0, head: 0, sector: 0];  VolumeHandle: PUBLIC TYPE = RECORD [    deviceIndex: FloppyTape.Drive, changeCount: CARDINAL];    -- must be the same as FloppyTapeImplB$VolumeHandleInternal  nullVolumeHandle: PUBLIC VolumeHandle ¬ [LAST[CARDINAL], 0];    nullBootFilePointer: PUBLIC SpecialFloppyTape.BootFilePointer =     [file: nullFileID, offset: 0];      nullDiskAddress: FloppyChannel.DiskAddress = [0,0,0];    volumeDesc: PUBLIC -- FloppyTapeInternal -- FloppyTapeInternal.VolumeDesc ¬ NIL;  volumeDescLock: PUBLIC -- FloppyTapeInternal -- MONITORLOCK;      MaxBufferSize: Space.PageCount ¬ IF System.isUtilityPilot THEN 16 ELSE 32;  z: UNCOUNTED ZONE = Heap.systemZone;    -- public errors - exported to FloppyTape --  AlreadyFormatted: PUBLIC SIGNAL [name: LONG STRING] = CODE;  IOError: PUBLIC ERROR [    file: FloppyTape.FileHandle, byte: FloppyTape.ByteOffset,    firstHole: FloppyTape.SectorNumber, howManyHoles: CARDINAL] = CODE;  Error: PUBLIC ERROR [error: FloppyTape.ErrorType] = CODE;  -- public signals - exported to FloppyTape --  ChangeTapeNow: PUBLIC SIGNAL [drive: FloppyTape.Drive] = CODE;    -- private signals - exported to FloppyTapeInternal --    BadSector: PUBLIC SIGNAL [sector: FloppyTape.SectorNumber] = CODE;  DiskChanged: PUBLIC ERROR = CODE;  InternalIOError: PUBLIC ERROR [countDone: FloppyTape.ByteCount] = CODE;  BugType: TYPE = {outOfVM, unexpectedErrorStatus};  Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};    -- procedures --    CloseVolume: PUBLIC PROCEDURE [volume: VolumeHandle] =    BEGIN    -- force out root page and bad page table    -- unmap all buffers and scratch storage        CheckChangeCount: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]       RETURNS [ok: BOOLEAN] =      BEGIN       IF volume.changeCount > volumeDesc.changeCount THEN RETURN[FALSE]      ELSE RETURN[TRUE];      END;  --CheckChangeCount--    IsVolumeOpenAndCloseIt: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]      RETURNS [isOpen: BOOLEAN] =       BEGIN      isOpen ¬ volumeDesc.open;      volumeDesc.open ¬ FALSE;      END;  --IsVolumeOpenAndCloseIt--    CloseVolumeEntry: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE        BEGIN        InternalIOError => {savedError ¬ badTape; GO TO otherError};	DiskChanged => {savedError ¬ invalidVolumeHandle; GO TO otherError};	END;      -- volumeDesc.open is already FALSE by here      volumeDesc.rootPage.changing ¬ FALSE;        IF ~volumeDesc.writeProtected THEN        BEGIN        FloppyTapeInternal.WriteBadSectorList[ !	  Error => {savedError ¬ error; GO TO otherError}];        FloppyTapeInternal.WriteRootPage[ !	  Error => {savedError ¬ error; GO TO otherError}];	END;      FloppyTapeInternal.CloseVolumeInternal[];      EXITS        otherError => RETURN WITH ERROR Error[savedError];      END;      END;  --CloseVolumeEntry--    CloseVolumeMain: FloppyTapeInternal.OperationProc =      BEGIN      currentVolume: BOOLEAN ¬ TRUE;      FloppyTapeInternal.ValidateHandle[volume !        Error => IF error = invalidVolumeHandle THEN	           {currentVolume ¬ FALSE; CONTINUE}		 ELSE REJECT];      IF ~currentVolume THEN        BEGIN	IF ~FloppyTapeInternal.ValidDrive[volume.deviceIndex] THEN	  ERROR Error[invalidVolumeHandle];	IF ~CheckChangeCount[@volumeDescLock] THEN	  ERROR Error[invalidVolumeHandle];	RETURN; -- if here, are trying to close an old volumeHandle, so OK.	END;      IF ~IsVolumeOpenAndCloseIt[@volumeDescLock] THEN RETURN;      FloppyTapeInternal.ForceOutBuffers[@FloppyTapeInternal.bufferLock];      CloseVolumeEntry[@volumeDescLock];      END;  --CloseVolumeMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, CloseVolumeMain, closeVolume];    END;  --CloseVolume--  CreateFileInternal: INTERNAL PROCEDURE [    size: FloppyTape.ByteCount,    type: File.Type, startSector: FloppyTape.SectorNumber, file: File.File]    RETURNS [floppyTapeFileID: FileID] =    -- we probably want to make this DoDirectIO or something better than what    -- it currently does??    BEGIN ENABLE UNWIND => NULL;        CleanUp: PROCEDURE [] = {      buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE]};          -- must have monitor lock to operate in here    buffer: Space.Interval ¬ Space.nullInterval;    requestedSize: Space.PageCount;    marker: LONG POINTER TO FloppyTapeFormat.MarkerPage;    badSector: FloppyTape.SectorNumber;    BEGIN    ENABLE      BEGIN      FloppyChannel.Error => IF type = invalidHandle THEN 			       {CleanUp[]; GO TO diskChanged};      DiskChanged     => {CleanUp[]; GO TO diskChanged};      InternalIOError => {CleanUp[]; GO TO ioError};      UNWIND          => CleanUp[];      END;    IF startSector + FloppyTapeInternal.BytesToPages[size] + markerPageSize >=         FloppyTapeInternal.BytesToPages[volumeDesc.size] THEN 	  ERROR Error[insufficientSpace];    --IF size # File.GetSize[file] THEN ERROR Error[invalidByteOffset];       -- this appears to be a bogus check (since the File.File may have header       -- pages, etc... and the client may only want to write out the real date       -- furthermore, have to worry about getting rid of these leader pages       -- somehow.??        FOR i: FloppyTape.SectorNumber IN [startSector..startSector +      FloppyTapeInternal.BytesToPages[size] + markerPageSize) DO      IF FloppyTapeInternal.IsPageBad[i] THEN ERROR BadSector[i];      ENDLOOP;    requestedSize ¬ MAX[markerPageSize, MaxBufferSize];    buffer ¬ FloppyTapeInternal.CreateBuffer[requestedSize];    IF buffer.count # requestedSize THEN ERROR;    marker ¬ LOOPHOLE[buffer.pointer];    marker.seal ¬ FloppyTapeFormat.MarkerSeal;    marker.version ¬ FloppyTapeFormat.MarkerPageVersion;    marker.file ¬ floppyTapeFileID ¬       FloppyTapeInternal.ConvertSectorToFileID[startSector];    startSector ¬ startSector + 1;      -- since special files only, this is okay.    marker.type ¬ type;    marker.logicalSize ¬ size + markerPageSize;    marker.timeStamp ¬ System.GetGreenwichMeanTime[];    marker.markerPageType ¬ file;    marker.pad ¬ ALL[0];    FloppyTapeInternal.WriteMarkerPage[marker, floppyTapeFileID];    -- now reuse buffer for creating file!        FOR filePageNumber: CARDINAL ¬ 0, filePageNumber + CARDINAL[buffer.count]       WHILE filePageNumber < FloppyTapeInternal.BytesToPages[size] DO BEGIN      count: CARDINAL;      diskAddress: FloppyChannel.DiskAddress ¬         FloppyTapeFormat.SectorToDiskAddress[	  startSector + filePageNumber,	  volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.numberOfTracks,	  volumeDesc.rootPage.sectorsPerTrack];      status: FloppyChannel.Status;      countDone: CARDINAL;      Space.Kill[buffer];      count ¬ CARDINAL[MIN[        buffer.count, FloppyTapeInternal.BytesToPages[size] - filePageNumber]];      [] ¬         Space.CopyIn[buffer.pointer, [file, filePageNumber, count]];      FOR i: CARDINAL IN [0..2) DO  -- if retention required, just try once	[status, countDone] ¬ FloppyChannel.WriteSectors[	  volumeDesc.fcHandle, diskAddress, buffer.pointer, count, TRUE];	SELECT status FROM	  goodCompletion => EXIT;	  diskChange, notReady => ERROR Error[notReady];	  cylinderError => ERROR Error[notFormatted];	  writeFault => ERROR Error[writeInhibited];	  otherError  => 	    BEGIN	    IF i = 0 THEN	      BEGIN	      IF volumeDesc.notifyClientOnRetention # NIL THEN	        volumeDesc.notifyClientOnRetention[volumeDesc.drive, start];	      status ¬ SpecialFloppyChannelExtras.Retention[volumeDesc.fcHandle];	      IF volumeDesc.notifyClientOnRetention # NIL THEN	        volumeDesc.notifyClientOnRetention[volumeDesc.drive, stop];	      END;	    IF status # goodCompletion THEN ERROR Error[hardwareError];	      -- will do this if i # 0 or retention returns bad status	    END;	  deletedData, dataLost => ERROR Error[needsScavenging];	  headerError, dataError, recordNotFound => ERROR InternalIOError[	                                              (filePageNumber + countDone)	                                              * Environment.bytesPerPage];	  ENDCASE => ERROR;	ENDLOOP;  --FOR i: CARDINAL--      END;      ENDLOOP; --FOR filePageNumber: CARDINAL--       buffer.pointer ¬ Space.Unmap[buffer.pointer];    EXITS      diskChanged => ERROR Error[invalidVolumeHandle];      ioError     => ERROR BadSector[badSector];    END;  --ENABLE--    END;  --CreateFileInternal--  CreateInitialMicrocodeFile: PUBLIC --SpecialFloppyTape-- PROCEDURE [    volume: VolumeHandle, initial: File.File,    size: FloppyTape.ByteCount, type: File.Type,    startingOffset: FloppyTape.ByteOffset] =    BEGIN        CreateInitialMicrocodeInternal: ENTRY PROCEDURE[      ml: LONG POINTER TO MONITORLOCK, size: FloppyTape.ByteCount,      type: File.Type, startingOffset: FloppyTape.ByteOffset, initial: File.File] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE        BEGIN        InternalIOError => {savedError ¬ badTape; GO TO otherError};	DiskChanged => {savedError ¬ invalidVolumeHandle; GO TO otherError};	END;      file: FileID;      alignmentSector, startSector: FloppyTape.SectorNumber;	--physical pages for file      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[invalidVolumeHandle];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      IF startingOffset >= size OR 	(startingOffset MOD Environment.bytesPerPage) # 0 THEN 	RETURN WITH ERROR Error[invalidByteOffset];      alignmentSector ¬	FloppyTapeFormat.DiskAddressToSector[	  FloppyTapeFormat.InitialMicrocodeDiskAddress,	  volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.numberOfTracks,	  volumeDesc.rootPage.sectorsPerTrack];	        -- check to see if file is too large before offset      IF alignmentSector < FloppyTapeInternal.BytesToPages[startingOffset] +	markerPageSize +	FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.RootPage]] +	FloppyTapeFormat.badSectorListSize + FloppyTapeFormat.rootPageSector THEN	RETURN WITH ERROR Error[invalidByteOffset];	      -- line up file so specified page resides at hard-wired location on disk      startSector ¬         alignmentSector - FloppyTapeInternal.BytesToPages[startingOffset] -        markerPageSize;            -- check to see if file too large after offset (does it run into BootPage?)      IF startSector + FloppyTapeInternal.BytesToPages[size] + markerPageSize >        FloppyTapeFormat.DiskAddressToSector[	  FloppyTapeFormat.BootPageDiskAddress,	  volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.numberOfTracks,	  volumeDesc.rootPage.sectorsPerTrack] THEN	RETURN WITH ERROR Error[invalidByteOffset];      file ¬	CreateFileInternal[size, type, startSector, initial !	   BadSector => 	     {savedError ¬ badSectors; GO TO otherError}].floppyTapeFileID;      volumeDesc.rootPage.initialMicrocode ¬ [file, startingOffset];      FloppyTapeInternal.WriteRootPage[ !        Error => {savedError ¬ error; GO TO otherError}];      EXITS        otherError => RETURN WITH ERROR Error[savedError];      END;      END;  --CreateInitialMicrocodeInternal--    CreateInitialMicrocodeFileMain: FloppyTapeInternal.OperationProc =      BEGIN      FloppyTapeInternal.ValidateHandle[volume];      CreateInitialMicrocodeInternal[	@volumeDescLock, size, type, startingOffset, initial];      END;  --CreateInitialMicrocodeFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, CreateInitialMicrocodeFileMain,      createInitialMicrocodeFile];    END;  --CreateInitialMicrocodeFile--  Erase: PUBLIC PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive,    newName: FloppyTape.VolumeName, clientWord: UNSPECIFIED ¬ 0,    securityErase: BOOLEAN ¬ FALSE] =    BEGIN    -- resets root page information and some globals    EraseInternal: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      attributes: FloppyChannel.Attributes;      status: FloppyChannel.Status;      savedError: FloppyTape.ErrorType;      buffer: Space.Interval ¬ Space.nullInterval;      requestedSize: Space.PageCount = MAX[1,        FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.BootPageFormat]]];        -- 1 is the size that WriteWithSameData takes.      BEGIN      ENABLE        BEGIN	FloppyChannel.Error => IF type = invalidHandle THEN	                         {savedError ¬ notReady; GO TO otherError};	InternalIOError => {savedError ¬ badTape; GO TO otherError};	ABORTED => GO TO aborted;	UNWIND  => buffer.pointer ¬ Space.Unmap[buffer.pointer !	             Space.Error => CONTINUE];	END;	      IF volumeDesc.open THEN RETURN WITH ERROR Error[volumeOpen];      volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];      attributes ¬        FloppyChannel.GetDeviceAttributes[volumeDesc.fcHandle].attributes;      FOR i: CARDINAL IN [0..2) DO -- must try again if retention required	status ¬ FloppyChannel.Nop[volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR Error[notReady];	  writeFault     => RETURN WITH ERROR Error[writeInhibited];	  otherError     => 	    BEGIN	    IF i = 0 THEN 	      status ¬ SpecialFloppyChannelExtras.Retention[volumeDesc.fcHandle];	    IF status # goodCompletion THEN 	      RETURN WITH ERROR Error[hardwareError];	      -- either second time through loop or retention failed	    END;	  ENDCASE        => RETURN WITH ERROR Error[hardwareError];	ENDLOOP;  --FOR i: CARDINAL--      IF ~FloppyChannel.SetContext[        volumeDesc.fcHandle, FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR Error[badTape];      volumeDesc.open ¬ FALSE;      volumeDesc.writeProtected ¬ FALSE;      volumeDesc.size ¬ attributes.numberOfHeads *         Inline.LongMult[	  attributes.numberOfCylinders, attributes.maxSectorsPerTrack] *	Environment.bytesPerPage;      FloppyTapeInternal.ReadRootAndBadSectorList[ !        Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.CheckRootPage[volumeDesc.rootPage !        Error => IF error = needsScavenging THEN CONTINUE                 ELSE {savedError ¬ error; GO TO otherError}];        -- what about errors here?      FloppyTapeInternal.CheckBadSectorList[volumeDesc.badSectorList,        volumeDesc.rootPage.numberOfBadPages,	FloppyTapeInternal.BytesToPages[volumeDesc.size] !          Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.InitBadSectors[0, beforeFileWritten];      volumeDesc.rootPage.seal ¬ FloppyTapeFormat.FloppyTapeSeal;      volumeDesc.rootPage.version ¬ FloppyTapeFormat.FloppyTapeVersion;      volumeDesc.rootPage.numberOfStreams ¬ attributes.numberOfCylinders;      volumeDesc.rootPage.numberOfTracks ¬ attributes.numberOfHeads;      volumeDesc.rootPage.sectorsPerTrack ¬ attributes.maxSectorsPerTrack;      volumeDesc.rootPage.initialMicrocode ¬ nullBootFilePointer;      volumeDesc.rootPage.pilotMicrocode ¬ nullBootFilePointer;      volumeDesc.rootPage.diagnosticMicrocode ¬ nullBootFilePointer;      volumeDesc.rootPage.germ ¬ nullBootFilePointer;      volumeDesc.rootPage.pilotBootFile ¬ nullBootFilePointer;      volumeDesc.rootPage.clientWord ¬ clientWord;      volumeDesc.rootPage.currentEOT ¬         FloppyTapeFormat.DiskAddressToSector[	  FloppyTapeFormat.firstDataAddress,	  volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.numberOfTracks,	  volumeDesc.rootPage.sectorsPerTrack];      volumeDesc.rootPage.lastFileID ¬ nullFileID;  -- these are wrong?      volumeDesc.rootPage.nextUnusedFileID ¬ FloppyTapeFormat.firstDataAddress;      --volumeDesc.rootPage.numberOfBadPages ¬ just trust it??;      volumeDesc.rootPage.changing ¬ FALSE;      volumeDesc.rootPage.pad ¬ 0;      volumeDesc.rootPage.rootFile ¬ nullFileID;      volumeDesc.rootPage.spare ¬ ALL[0];      IF newName # NIL THEN  -- keep old name if no new name specified        BEGIN	volumeDesc.rootPage.labelSize ¬ 	  MIN[FloppyTape.maxBytesInName, newName.length];	FOR i: CARDINAL IN [0..volumeDesc.rootPage.labelSize) DO	  volumeDesc.rootPage.label[i] ¬ newName[i];	  ENDLOOP;	FOR i: CARDINAL IN	  [volumeDesc.rootPage.labelSize..FloppyTape.maxBytesInName) DO          volumeDesc.rootPage.label[i] ¬ ' ;	  ENDLOOP;	END;      -- allocate a buffer to use for securityErase (if requested) and zeroing      -- out boot page)      buffer ¬ FloppyTapeInternal.CreateBuffer[requestedSize];      IF buffer.count # requestedSize THEN ERROR;      IF securityErase THEN        BEGIN	-- the following is for write the entire tape with a known value.	FloppyTapeInternal.SetBlock[	  buffer.pointer, CARDINAL[requestedSize * Environment.wordsPerPage],	  FloppyTapeFormat.eraseWord];	-- now write all sectors with this data	FloppyTapeInternal.WriteWithSameData[	  buffer.pointer,	  FloppyTapeFormat.SectorToDiskAddress[  --one page past bad sector list	    (FloppyTapeFormat.rootPageSector +	      FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.RootPage]] +	      FloppyTapeFormat.badSectorListSize),	    volumeDesc.rootPage.numberOfStreams,	    volumeDesc.rootPage.numberOfTracks,	    volumeDesc.rootPage.sectorsPerTrack],	  (volumeDesc.size -                     --rest of the tape after bad list	    ((FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.RootPage]] +	    FloppyTapeFormat.badSectorListSize) * Environment.bytesPerPage))];	END;  --IF securityErase--      -- now reuse this buffer to do boot page stuff, and then delete it      LOOPHOLE[buffer.pointer,	LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF CARDINAL]­ ¬	ALL[0];      FloppyTapeInternal.WriteFloppyTape[        buffer.pointer, FloppyTapeFormat.BootPageDiskAddress, 	(SIZE[FloppyTapeFormat.BootPageFormat] * Environment.bytesPerWord) !	  Error => {savedError ¬ error; GO TO otherError};	  InternalIOError => {savedError ¬ badTape; GO TO otherError}];      buffer.pointer ¬ Space.Unmap[buffer.pointer];      FloppyTapeInternal.WriteBadSectorList[ !        Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.WriteRootPage[ !        Error => {savedError ¬ error; GO TO otherError}];	      EXITS	otherError =>	  BEGIN	  volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	  RETURN WITH ERROR Error[savedError];	  END;	aborted =>	  BEGIN	  volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	  RETURN WITH ERROR ABORTED;	  END;      END;  --ENABLE--      END;  --EraseInternal--    EraseMain: FloppyTapeInternal.OperationProc =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN ERROR Error[noSuchDrive];      EraseInternal[@volumeDescLock ! DiskChanged => GO TO diskChanged];      EXITS        diskChanged => ERROR Error[notReady];      END;  --EraseMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, EraseMain, erase];    END;  --Erase--  FileHandleFromID: PUBLIC PROCEDURE [    fileId: FileID, volume: VolumeHandle] RETURNS [file: FloppyTape.FileHandle] =    {RETURN[[volume, fileId]]};  Format: PUBLIC PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive, name: FloppyTape.VolumeName,    clientWord: UNSPECIFIED, feedBack: FloppyTape.FeedBackPtr] =    BEGIN    -- writes all eot patterns (?) on every client available sector    -- builds bad page table and writes it to tape    -- creates root page information and writes it    -- creates empty zero size file at first data place for GetNextFile to work.    -- resumable signal AlreadyFormatted[label]        FormatInternal: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;            CleanUp: PROCEDURE [] = {        volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;        buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	IF feedBack # NIL THEN feedBack­ ¬ none};	      attributes: FloppyChannel.Attributes;      countBadSectors: CARDINAL;      status: FloppyChannel.Status;      temp: FloppyTape.SectorNumber;      requestedSize: Space.PageCount;      buffer: Space.Interval ¬ Space.nullInterval;      alreadyFormatted: BOOLEAN ¬ TRUE;  -- assume tape is already formatted      parameters: SpecialFloppyTapeFace.Parameters;      deviceHandle: FloppyDiskFace.DeviceHandle;       BEGIN      ENABLE        BEGIN	FloppyChannel.Error => IF type = invalidHandle THEN GO TO notReady;	InternalIOError => GO TO dataError;	ABORTED => GO TO aborted;	UNWIND  => CleanUp[];	END;	      -- reset feedback      IF feedBack # NIL THEN feedBack­ ¬ none;      IF volumeDesc.open THEN        RETURN WITH ERROR Error[volumeOpen];      volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];      attributes ¬         FloppyChannel.GetDeviceAttributes[volumeDesc.fcHandle].attributes;      FOR i: CARDINAL IN [0..2) DO  -- twice through if retention required max	status ¬ FloppyChannel.Nop[volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR Error[notReady];	  writeFault     => RETURN WITH ERROR Error[writeInhibited];	  otherError     =>	    BEGIN	    IF i = 0 THEN BEGIN	      IF feedBack # NIL THEN feedBack­ ¬ retentionPass;	      status ¬ SpecialFloppyChannelExtras.Retention[volumeDesc.fcHandle];	      END;	    IF status # goodCompletion THEN 	      RETURN WITH ERROR Error[hardwareError];	      -- either second time through loop or retention failed	    END;	  ENDCASE        => RETURN WITH ERROR Error[hardwareError];	ENDLOOP;  --FOR i: CARDINAL--	      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow abort            IF ~FloppyChannel.SetContext[        volumeDesc.fcHandle, FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR Error[badTape];      -- check if the tape is already formatted (at least the root page/bad       -- sector list)      FloppyTapeInternal.ReadRootAndBadSectorList[ !         Error, InternalIOError => {alreadyFormatted ¬ FALSE; CONTINUE}];      IF alreadyFormatted THEN        FloppyTapeInternal.CheckRootPage[volumeDesc.rootPage !          Error => IF error = notFormatted THEN	             {alreadyFormatted ¬ FALSE; CONTINUE}	           ELSE IF error = needsScavenging THEN CONTINUE];      IF alreadyFormatted THEN        FloppyTapeInternal.CheckBadSectorList[volumeDesc.badSectorList,	  volumeDesc.rootPage.numberOfBadPages,	  attributes.numberOfHeads * Inline.LongMult[	    attributes.numberOfCylinders, attributes.maxSectorsPerTrack] !	    Error => IF error = notFormatted THEN	               {alreadyFormatted ¬ FALSE; CONTINUE}];      IF alreadyFormatted THEN         BEGIN	label: STRING ¬ [FloppyTape.maxBytesInName];	label.length ¬ volumeDesc.rootPage.labelSize;	FOR i: CARDINAL IN [0..label.length) DO	  label[i] ¬ volumeDesc.rootPage.label[i];	  ENDLOOP;	SIGNAL AlreadyFormatted[label];	END;	      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow abort            IF feedBack # NIL THEN feedBack­ ¬ retentionPass;      status ¬ SpecialFloppyChannelExtras.Retention[volumeDesc.fcHandle];      IF status # goodCompletion THEN RETURN WITH ERROR Error[hardwareError];      -- initialize volumeDesc      volumeDesc.open ¬ FALSE;      volumeDesc.writeProtected ¬ FALSE;      volumeDesc.size ¬ attributes.numberOfCylinders * attributes.numberOfHeads *         Inline.LongMult[attributes.maxSectorsPerTrack, Environment.bytesPerPage];      volumeDesc.changeCount ¬ 0;      -- Don't need to set currentPosition and       -- cachedFile becauses this will be set by Open code.      volumeDesc.rootPage.seal ¬ FloppyTapeFormat.FloppyTapeSeal;      volumeDesc.rootPage.version ¬ FloppyTapeFormat.FloppyTapeVersion;      volumeDesc.rootPage.numberOfStreams ¬ attributes.numberOfCylinders;      volumeDesc.rootPage.numberOfTracks ¬ attributes.numberOfHeads;      volumeDesc.rootPage.sectorsPerTrack ¬ attributes.maxSectorsPerTrack;      volumeDesc.rootPage.initialMicrocode ¬ nullBootFilePointer;      volumeDesc.rootPage.pilotMicrocode ¬ nullBootFilePointer;      volumeDesc.rootPage.diagnosticMicrocode ¬ nullBootFilePointer;      volumeDesc.rootPage.germ ¬ nullBootFilePointer;      volumeDesc.rootPage.pilotBootFile ¬ nullBootFilePointer;      volumeDesc.rootPage.clientWord ¬ clientWord;      volumeDesc.rootPage.currentEOT ¬         FloppyTapeFormat.DiskAddressToSector[	  FloppyTapeFormat.firstDataAddress,	  volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.numberOfTracks,	  volumeDesc.rootPage.sectorsPerTrack];      volumeDesc.rootPage.lastFileID ¬ FloppyTapeFormat.firstDataAddress;      volumeDesc.rootPage.nextUnusedFileID ¬ FloppyTapeFormat.firstDataAddress;      volumeDesc.rootPage.numberOfBadPages ¬ 0;       volumeDesc.rootPage.changing ¬ FALSE;      volumeDesc.rootPage.pad ¬ 0;      volumeDesc.rootPage.rootFile ¬ nullFileID;      volumeDesc.rootPage.spare ¬ ALL[0];      IF name # NIL THEN        volumeDesc.rootPage.labelSize ¬	  MIN[FloppyTape.maxBytesInName, name.length]      ELSE        volumeDesc.rootPage.labelSize ¬ 0;      FOR i: CARDINAL IN [0..volumeDesc.rootPage.labelSize) DO	volumeDesc.rootPage.label[i] ¬ name[i];	ENDLOOP;      FOR i: CARDINAL IN 	[volumeDesc.rootPage.labelSize..FloppyTape.maxBytesInName) DO	volumeDesc.rootPage.label[i] ¬ ' ;	ENDLOOP;      -- volume root page is completely initialized      -- tell client we are formatting      IF feedBack # NIL THEN feedBack­ ¬ formatPass;            -- now format one stream at a time.      deviceHandle ¬ SpecialFloppyChannelExtras.GetDeviceHandle[        volumeDesc.fcHandle];      parameters ¬        SpecialFloppyTapeFace.GetTapeParameters[deviceHandle].parameters;      FOR i: CARDINAL IN [0..parameters.numberOfStreams) DO        Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts        IF FloppyChannel.FormatTracks[volumeDesc.fcHandle,	  FloppyTapeFormat.SectorToDiskAddress[	    FloppyTapeFormat.firstSector + Inline.LongMult[	      (i * parameters.maxTracksPerStream), attributes.maxSectorsPerTrack],	    attributes.numberOfCylinders, attributes.numberOfHeads, 	    attributes.maxSectorsPerTrack],	  parameters.maxTracksPerStream].countDone # 	  parameters.maxTracksPerStream THEN RETURN WITH ERROR Error[badTape];	ENDLOOP;            -- floppy tape is now formatted, but lets find the bad sectors       countBadSectors ¬ 0;      FOR i: CARDINAL IN [0..FloppyTapeFormat.maxNumberBadSectors) DO        [volumeDesc.badSectorList[i].badSectorLow, 	volumeDesc.badSectorList[i].badSectorHigh] ¬ 	  FloppyTapeFormat.UnpackBadSectorNumber[FloppyTape.nullSectorNumber];	ENDLOOP;      requestedSize ¬ 1;      buffer ¬ FloppyTapeInternal.CreateResidentBuffer[requestedSize];      IF buffer.count # requestedSize THEN ERROR;	        -- tell client we are verifying      IF feedBack # NIL THEN feedBack­ ¬ verifyPass;            ScanFloppyTape[        buffer.pointer, FloppyTapeInternal.BytesToPages[volumeDesc.size] !	BadSector =>	  BEGIN	  badSector: FloppyTape.SectorNumber;	  Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts	  FOR i: CARDINAL IN [0..countBadSectors) DO	    badSector ¬ FloppyTapeFormat.PackBadSectorNumber[	      volumeDesc.badSectorList[i].badSectorLow,	      volumeDesc.badSectorList[i].badSectorHigh];	    IF badSector = sector THEN RESUME;	    IF badSector < sector THEN LOOP;	    temp ¬ badSector;	    badSector ¬ sector;	    sector ¬ temp;	    ENDLOOP;	  IF countBadSectors >= FloppyTapeFormat.maxNumberBadSectors THEN	    GO TO tooManyBadSectors;	  [volumeDesc.badSectorList[countBadSectors].badSectorLow,	  volumeDesc.badSectorList[countBadSectors].badSectorHigh] ¬	    FloppyTapeFormat.UnpackBadSectorNumber[sector];	  volumeDesc.badSectorList[countBadSectors].typeOfBadPage ¬	    beforeFileWritten;	  countBadSectors ¬ countBadSectors + 1;	  RESUME;	  END];      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts      volumeDesc.rootPage.numberOfBadPages ¬ countBadSectors;      FloppyTapeInternal.WriteBadSectorList[];      FloppyTapeInternal.WriteRootPage[];      -- tell client we are done      IF feedBack # NIL THEN feedBack­ ¬ none;            buffer.pointer ¬ Space.Unmap[buffer.pointer];            EXITS        notReady => {CleanUp[]; RETURN WITH ERROR Error[notReady]};        tooManyBadSectors, dataError =>	  {CleanUp[]; RETURN WITH ERROR Error[badTape]};	aborted => {CleanUp[]; RETURN WITH ERROR ABORTED};      END;  --ENABLE--      END;  --FormatInternal--    FormatMain: FloppyTapeInternal.OperationProc =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN ERROR Error[noSuchDrive];      FormatInternal[@volumeDescLock !	DiskChanged => GO TO diskChanged;	AlreadyFormatted => {SIGNAL AlreadyFormatted[name]; RESUME  --??--}];      EXITS        diskChanged => ERROR Error[notReady];      END;  --FormatMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, FormatMain, format];    END;  --Format--      GetFileAttributes: PUBLIC PROCEDURE [file: FloppyTape.FileHandle]    RETURNS [size: FloppyTape.ByteCount, type: File.Type] =    BEGIN    GetFileAttributesMain: FloppyTapeInternal.OperationProc =      BEGIN      volume: VolumeHandle = file.volume;      FloppyTapeInternal.ValidateHandle[volume];      [size, type] ¬ GetFileAttributesEntry[@volumeDescLock, file];      END;  --GetFileAttributesMain--          FloppyTapeInternal.DoOperation[@FloppyTapeInternal.operationLock,      GetFileAttributesMain, getFileAttributes];    END;  --GetFileAttributes--  GetFileAttributesEntry: PUBLIC --FloppyTapeInternal-- ENTRY PROCEDURE [    ml: LONG POINTER TO MONITORLOCK, file: FloppyTape.FileHandle]    RETURNS [size: FloppyTape.ByteCount, type: File.Type] =    -- test file with cachedFile. If equal pass back cached attributes.    -- Otherwise, either try our buffers or position to tape file's marker page,     -- equal to file position, and read in attributes from marker page    BEGIN ENABLE UNWIND => NULL;    inBuffer: BOOLEAN ¬ FALSE;    buffer: Space.Interval ¬ Space.nullInterval;    savedError: FloppyTape.ErrorType;    BEGIN      ENABLE       BEGIN      InternalIOError => {savedError ¬ needsScavenging; GO TO otherError};      DiskChanged => {savedError ¬ invalidVolumeHandle; GO TO otherError};      UNWIND =>	buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];      END;    IF ~volumeDesc.open THEN RETURN WITH ERROR Error[invalidVolumeHandle];    IF file.file = nullFileID THEN RETURN WITH ERROR Error[fileNotFound];    SELECT TRUE FROM      (file.file = volumeDesc.cachedFile.id) =>	BEGIN	size ¬ volumeDesc.cachedFile.size - markerByteSize;	type ¬ volumeDesc.cachedFile.type;	RETURN;	END;     (FloppyTapeInternal.ConvertFileIDToSector[file.file] >=	volumeDesc.lastEOTonTape) =>	BEGIN	-- not on tape yet, check the buffer	[size, type] ¬ FloppyTapeInternal.SearchOurBufferForFile[file.file];	IF size = 0 THEN RETURN WITH ERROR Error[fileNotFound];	END;      ENDCASE => 	-- okay, we gotta look on tape for the marker page	BEGIN	buffer ¬ FloppyTapeInternal.CreateBuffer[markerPageSize];	IF markerPageSize # buffer.count THEN Bug[outOfVM];	FloppyTapeInternal.ReadMarkerPage[buffer.pointer, file.file !	  Error => {savedError ¬ error; GO TO otherError}];	FloppyTapeInternal.CheckMarkerPage[buffer.pointer, file.file !	  Error => {savedError ¬ fileNotFound; GO TO otherError}];	size ¬ LOOPHOLE[buffer.pointer,	  LONG POINTER TO FloppyTapeFormat.MarkerPage].logicalSize;	type ¬ LOOPHOLE[	  buffer.pointer, LONG POINTER TO FloppyTapeFormat.MarkerPage].type;	buffer.pointer ¬ Space.Unmap[buffer.pointer];	END;    -- finally we got it    volumeDesc.cachedFile ¬ [      file.file, FloppyTapeInternal.RealFileIDLoc[file.file].da, size, type];    size ¬ size - markerByteSize;    EXITS      otherError => {	buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	RETURN WITH ERROR Error[savedError] };    END;  --ENABLE--    END;  --GetFileAttributesEntry--  GetNextFile: PUBLIC PROCEDURE [previousFile: FloppyTape.FileHandle]     RETURNS [nextFile: FloppyTape.FileHandle] =    BEGIN    volume: VolumeHandle;    -- stateless enumerator scanning the tape (and/or buffer) for the next file,    -- given the current file position    -- cache the attributes, just in case a GetFileAttributes is done next        GetNextFileInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      buffer: Space.Interval ¬ Space.nullInterval;      inBuffer: BOOLEAN ¬ FALSE;      nextFIDSector: FloppyTape.SectorNumber;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE        BEGIN	InternalIOError => {savedError ¬ needsScavenging; GO TO otherError};	DiskChanged => {savedError ¬ invalidVolumeHandle; GO TO otherError};	UNWIND => 	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];        END;	        IF ~volumeDesc.open THEN ERROR Error[invalidVolumeHandle];      buffer ¬ FloppyTapeInternal.CreateBuffer[markerPageSize];      IF markerPageSize # buffer.count THEN Bug[outOfVM];            SELECT TRUE FROM        (previousFile.file = nullFileID) =>	  BEGIN          nextFile.file ¬ FloppyTapeInternal.ConvertDiskAddressToFileID[	    FloppyTapeFormat.firstDataAddress];	  END;        (previousFile.file = volumeDesc.cachedFile.id) =>	  BEGIN	  nextFile.file ¬ FloppyTapeInternal.ConvertSectorToFileID[	    FloppyTapeInternal.ConvertFileIDToSector[volumeDesc.cachedFile.id] +	    FloppyTapeInternal.BytesToPages[volumeDesc.cachedFile.size]];	  END;	(FloppyTapeInternal.ConvertFileIDToSector[previousFile.file] >=           volumeDesc.lastEOTonTape) =>	  BEGIN	  -- not on tape yet, check the buffer	  size: FloppyTape.ByteCount ¬ 	    FloppyTapeInternal.SearchOurBufferForFile[previousFile.file].size;	  IF size = 0 THEN RETURN WITH ERROR Error[fileNotFound];	  nextFile.file ¬ 	    FloppyTapeInternal.ConvertSectorToFileID[	      FloppyTapeInternal.ConvertFileIDToSector[previousFile.file] + 	      FloppyTapeInternal.BytesToPages[size]];	  END;        ENDCASE => 	  BEGIN --okay, gotta look on tape now	  logicalSize: FloppyTape.ByteCount;	  FloppyTapeInternal.ReadMarkerPage[buffer.pointer, previousFile.file !	    Error => {savedError ¬ error; GO TO otherError}];	  FloppyTapeInternal.CheckMarkerPage[buffer.pointer, previousFile.file !	    Error => {savedError ¬ error; GO TO otherError}];	  logicalSize ¬ LOOPHOLE[buffer.pointer,	    LONG POINTER TO FloppyTapeFormat.MarkerPage].logicalSize;	  nextFile.file ¬ 	    FloppyTapeInternal.ConvertSectorToFileID[	      FloppyTapeInternal.ConvertFileIDToSector[previousFile.file] + 	    FloppyTapeInternal.BytesToPages[logicalSize]]	  END;	        -- we better have nextFile set up by now.        nextFIDSector ¬ FloppyTapeInternal.ConvertFileIDToSector[nextFile.file];      SELECT TRUE FROM        (nextFIDSector >= volumeDesc.rootPage.currentEOT) =>	  BEGIN	  volumeDesc.cachedFile ¬ [	    nullFileID, nullDiskAddress, 0, PilotFileTypes.tAnonymousFile];	  nextFile ¬ [volume, nullFileID];	  buffer.pointer ¬ Space.Unmap[buffer.pointer];	  RETURN;	  END;        (nextFIDSector >= volumeDesc.lastEOTonTape) =>	  BEGIN	  -- not on tape yet, check the buffer	  [volumeDesc.cachedFile.size, volumeDesc.cachedFile.type] ¬ 	    FloppyTapeInternal.SearchOurBufferForFile[nextFile.file];	  IF volumeDesc.cachedFile.size = 0 THEN 	    RETURN WITH ERROR Error[fileNotFound];	  END;	ENDCASE => 	  BEGIN 	  --okay, gotta look on tape now	  FloppyTapeInternal.ReadMarkerPage[buffer.pointer, nextFile.file !	    Error => {savedError ¬ error; GO TO otherError}];	  FloppyTapeInternal.CheckMarkerPage[buffer.pointer, nextFile.file ! 	    Error => {savedError ¬ error; GO TO otherError}];	  volumeDesc.cachedFile.size ¬ LOOPHOLE[buffer.pointer,	    LONG POINTER TO FloppyTapeFormat.MarkerPage].logicalSize;          volumeDesc.cachedFile.type ¬ LOOPHOLE[	    buffer.pointer, LONG POINTER TO FloppyTapeFormat.MarkerPage].type;	  END;      nextFile.volume ¬ volume;      volumeDesc.cachedFile.id ¬ nextFile.file;      volumeDesc.cachedFile.da ¬        FloppyTapeInternal.RealFileIDLoc[nextFile.file].da;      buffer.pointer ¬ Space.Unmap[buffer.pointer];	      EXITS        otherError =>	  BEGIN	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	  RETURN WITH ERROR Error[savedError];	  END;      END;  --ENABLE--      END;  --GetNextFileInternal--    GetNextFileMain: FloppyTapeInternal.OperationProc =      BEGIN      volume ¬ previousFile.volume;      FloppyTapeInternal.ValidateHandle[volume];      GetNextFileInternal[@volumeDescLock];      END;  --GetNextFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, GetNextFileMain, getNextFile];    END;  --GetNextFile--  GetVolumeAttributes: PUBLIC PROCEDURE [volume: VolumeHandle, name: LONG STRING]    RETURNS [freeSpace, usedSpace: FloppyTape.ByteCount,    rootFile: FileID, clientWord: UNSPECIFIED, drive: FloppyTape.Drive,    numberOfBadSectors: CARDINAL] =    BEGIN    -- look in root page cache (Don't need to look at first page since    -- things are always cached when you have a volumeHandle)    -- calculate free sectors left (total - bad pages ahead - sectorsPassed)    GetVolumeAttributesInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN      badSector: FloppyTape.SectorNumber;      badPagesNotYetReached: CARDINAL ¬ 0;      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[invalidVolumeHandle];      numberOfBadSectors ¬ volumeDesc.rootPage.numberOfBadPages;      usedSpace ¬ Environment.bytesPerPage * (volumeDesc.rootPage.currentEOT - 1);      FOR i: CARDINAL IN [0..numberOfBadSectors) DO        badSector ¬ FloppyTapeFormat.PackBadSectorNumber[	  volumeDesc.badSectorList[i].badSectorLow,	  volumeDesc.badSectorList[i].badSectorHigh];        IF badSector > (usedSpace / Environment.bytesPerPage) THEN {	  badPagesNotYetReached ¬ numberOfBadSectors - i;	  EXIT };	ENDLOOP;      freeSpace ¬ volumeDesc.size - usedSpace -        (badPagesNotYetReached * Environment.bytesPerPage);      usedSpace ¬ volumeDesc.size - freeSpace;        -- this now takes into account bad pages not yet reached.      rootFile ¬ volumeDesc.rootPage.rootFile;      clientWord ¬ volumeDesc.rootPage.clientWord;      drive ¬ volume.deviceIndex;      IF name # NIL THEN        BEGIN	name.length ¬ 0;        FOR i: CARDINAL IN 	  [0..MIN[volumeDesc.rootPage.labelSize, name.maxlength]) DO	  name[name.length] ¬ volumeDesc.rootPage.label[i];	  name.length ¬ name.length + 1;	  ENDLOOP;	END;      END;  --GetVolumeAttributesInternal--    GetVolumeAttributesMain: FloppyTapeInternal.OperationProc =      BEGIN      FloppyTapeInternal.ValidateHandle[volume];      GetVolumeAttributesInternal[@volumeDescLock];      END;  --GetVolumeAttributesMain--    FloppyTapeInternal.DoOperation[@FloppyTapeInternal.operationLock,      GetVolumeAttributesMain, getVolumeAttributes];    END;  --GetVolumeAttributes--  OpenVolume: PUBLIC PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive, readOnly: BOOLEAN,    notifyClientOnRetention: FloppyTape.NotifyClientProc ¬ NIL]    RETURNS [volume: VolumeHandle] =    BEGIN    -- if readOnly is FALSE, sets changing flag to TRUE    -- retention if readOnly is FALSE    buffer1, buffer2, buffer3: Space.Interval ¬ Space.nullInterval;    OpenVolumeInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK]       RETURNS [volume: VolumeHandle] =      BEGIN ENABLE UNWIND => NULL;            CleanUp: PROCEDURE [] = {        VM.Unmap[Environment.PageFromLongPointer[buffer1.pointer] !	  Space.Error => CONTINUE];	VM.Unmap[Environment.PageFromLongPointer[buffer2.pointer] !	  Space.Error => CONTINUE];	VM.Unmap[Environment.PageFromLongPointer[buffer3.pointer] !	  Space.Error => CONTINUE];	Space.Deallocate[buffer1 ! Space.Error => CONTINUE];	Space.Deallocate[buffer2 ! Space.Error => CONTINUE];	Space.Deallocate[buffer3 ! Space.Error => CONTINUE]};	      savedError: FloppyTape.ErrorType;      attributes: FloppyChannel.Attributes;      status: FloppyChannel.Status;      BEGIN      ENABLE        BEGIN	FloppyChannel.Error => IF type = invalidHandle THEN	                         {savedError ¬ notReady; GO TO otherError};	InternalIOError => {savedError ¬ needsScavenging; GO TO otherError};	UNWIND => IF ~readOnly THEN CleanUp[];	END;      IF volumeDesc.open THEN RETURN WITH ERROR Error[volumeOpen];            volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];        attributes ¬         FloppyChannel.GetDeviceAttributes[volumeDesc.fcHandle].attributes;	      FOR i: CARDINAL IN [0..2) DO  --if readOnly and requires retention, do twice	status ¬ FloppyChannel.Nop[volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR Error[notReady];	  writeFault     => EXIT;  -- just writeProtected, not an error	  otherError     => IF readOnly AND (i = 0) THEN 			      BEGIN			      IF notifyClientOnRetention # NIL THEN 				notifyClientOnRetention[drive, start];			      status ¬ SpecialFloppyChannelExtras.Retention[				volumeDesc.fcHandle];			      IF status # goodCompletion THEN				RETURN WITH ERROR Error[hardwareError];			      IF notifyClientOnRetention # NIL THEN 				notifyClientOnRetention[drive, stop];			      END			    ELSE RETURN WITH ERROR Error[hardwareError];	  ENDCASE        => RETURN WITH ERROR Error[hardwareError];	ENDLOOP;            volumeDesc.writeProtected ¬ (status = writeFault) OR readOnly;      IF volumeDesc.writeProtected AND ~readOnly THEN        RETURN WITH ERROR Error[writeInhibited];	-- is this a proper error?      IF ~volumeDesc.writeProtected THEN         BEGIN	IF notifyClientOnRetention # NIL THEN 	  notifyClientOnRetention[drive, start];	status ¬ SpecialFloppyChannelExtras.Retention[volumeDesc.fcHandle];	IF status # goodCompletion THEN RETURN WITH ERROR Error[hardwareError];	IF notifyClientOnRetention # NIL THEN	  notifyClientOnRetention[drive, stop];	END;      IF ~FloppyChannel.SetContext[        volumeDesc.fcHandle, FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR Error[badTape];      -- need to set notifyClientOnRetention now since following may use it.      volumeDesc.notifyClientOnRetention ¬ notifyClientOnRetention;      FloppyTapeInternal.ReadRootAndBadSectorList[ !        Error => {savedError ¬ error; GO TO otherError}];        -- may raise Error[notReady]      FloppyTapeInternal.CheckRootPage[volumeDesc.rootPage !        Error => {savedError ¬ error; GO TO otherError}];      volumeDesc.size ¬        Environment.bytesPerPage * volumeDesc.rootPage.numberOfTracks * 	Inline.LongMult[	  volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.sectorsPerTrack];      FloppyTapeInternal.CheckBadSectorList[volumeDesc.badSectorList,        volumeDesc.rootPage.numberOfBadPages,        Inline.LongMult[attributes.numberOfCylinders, 	  attributes.maxSectorsPerTrack] * attributes.numberOfHeads !          Error => {savedError ¬ error; GO TO otherError}];      -- if writeable, then allocate resident buffers, set changing flag, and      -- write out root page.  If we ever decide to use resident buffers for       -- reading, we must move the creation of them out of this IF statement.      IF ~volumeDesc.writeProtected THEN        BEGIN	buffer1 ¬ FloppyTapeInternal.CreateResidentBuffer[	  FloppyTapeInternal.residentBufferSize];	IF FloppyTapeInternal.residentBufferSize # buffer1.count THEN	  RETURN WITH ERROR Error[insufficientSpace];	  -- Insufficient VM to operate in	buffer2 ¬ FloppyTapeInternal.CreateResidentBuffer[	  FloppyTapeInternal.residentBufferSize];	IF FloppyTapeInternal.residentBufferSize # buffer2.count THEN	  RETURN WITH ERROR Error[insufficientSpace];	  -- Insufficient VM to operate in	volumeDesc.residentBuffer1 ¬ LOOPHOLE[buffer1.pointer];	volumeDesc.residentBuffer2 ¬ LOOPHOLE[buffer2.pointer];	FloppyTapeInternal.buffer ¬ volumeDesc.residentBuffer1;		buffer3 ¬ FloppyTapeInternal.CreateResidentBuffer[	  FloppyTapeInternal.verifyBufferSize];	IF FloppyTapeInternal.verifyBufferSize # buffer3.count THEN	  RETURN WITH ERROR Error[insufficientSpace];	  -- Insufficient VM to operate in	volumeDesc.verifyBuffer ¬ buffer3.pointer;	volumeDesc.rootPage.changing ¬ TRUE;        FloppyTapeInternal.WriteRootPage[ !	  Error => {savedError ¬ error; GO TO otherError}];	END;  --IF ~volumeDesc.writeProtected--      volumeDesc.currentPosition ¬ volumeDesc.rootPage.currentEOT;      volumeDesc.lastEOTonTape ¬ volumeDesc.rootPage.currentEOT;      volumeDesc.cachedFile ¬         [id: nullFileID, da: nullDiskAddress, size: 0, 	type: PilotFileTypes.tAnonymousFile];      volumeDesc.sectorsPerStream ¬ SpecialFloppyTapeFace.GetTapeParameters[	SpecialFloppyChannelExtras.GetDeviceHandle[	  volumeDesc.fcHandle]].parameters.maxTracksPerStream *	volumeDesc.rootPage.sectorsPerTrack;	-- usually 245 * 12 which is < LAST[CARDINAL]      volumeDesc.verifyAfterWrite ¬ TRUE;      volumeDesc.changeCount ¬ volumeDesc.changeCount + 1;      volumeDesc.open ¬ TRUE;      RETURN[[drive, volumeDesc.changeCount]];      EXITS	otherError => {	  IF ~readOnly THEN CleanUp[];	  RETURN WITH ERROR Error[savedError]};      END;  --ENABLE--      END;  --OpenVolumeInternal--    OpenVolumeMain: FloppyTapeInternal.OperationProc =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN ERROR Error[noSuchDrive];      volume ¬ OpenVolumeInternal[@volumeDescLock !        DiskChanged => GO TO diskChanged];      EXITS        diskChanged => ERROR Error[notReady];      END;  --OpenVolumeMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, OpenVolumeMain, openVolume];    END;  --OpenVolume--  ScanFloppyTape: PROCEDURE [buffer: LONG POINTER, sectorCount: LONG CARDINAL] =    BEGIN    -- NOTE: Caller MUST catch FloppyChannel.Error[invalidHandle]!    count: LONG CARDINAL;    currentSector: FloppyTape.SectorNumber ¬ FloppyTapeFormat.firstSector;    result: FloppyDiskFace.Status;    status: FloppyChannel.Status;    deviceHandle: FloppyDiskFace.DeviceHandle =      SpecialFloppyChannelExtras.GetDeviceHandle[volumeDesc.fcHandle];          -- we don't need to write out the information, since format wrote stuff    -- however, it would be better if format wrote a pattern like 6C, but no luck    DO      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts      count ¬ MIN[sectorCount, LAST[CARDINAL]];      FloppyTapeInternal.myIocb­ ¬  [        device:   deviceHandle,        function: readSector,        address:  LOOPHOLE[FloppyTapeFormat.SectorToDiskAddress[	  currentSector, volumeDesc.rootPage.numberOfStreams,	  volumeDesc.rootPage.numberOfTracks,	  volumeDesc.rootPage.sectorsPerTrack]],        dataPtr:  buffer,        incrementDataPointer: FALSE,        tries:    1, -- we don't want it to retry while building the BPT        count:    CARDINAL[count]];      [result,,] ¬ SpecialFloppyChannel.DoDirectIO[FloppyTapeInternal.myIocb];            -- temporary hack for Daybreak Tapes due to a bug in the head.      «-- myIocb got updated by head/handler      count ¬ count - FloppyTapeInternal.myIocb.count;»      IF (result # goodCompletion) THEN         count ¬ FloppyTapeInternal.GetCountDone[	  currentSector, FloppyTapeInternal.myIocb]      ELSE        count ¬ count - FloppyTapeInternal.myIocb.count;            IF (sectorCount ¬ sectorCount - count) = 0 THEN EXIT;      currentSector ¬ currentSector + count;      IF (count = LAST[CARDINAL]) AND (result = goodCompletion) THEN LOOP;      IF result = otherError THEN        BEGIN	status ¬ SpecialFloppyChannelExtras.Retention[volumeDesc.fcHandle];	IF status # goodCompletion THEN ERROR Error[hardwareError];	currentSector ¬ currentSector - count;  -- reset for redo of operation	LOOP;	END;      -- so if we are here, there must be bad pages somewhere      IF NOT FloppyTapeInternal.IsItABadPageError[        FloppyTapeInternal.FilterStatus[result]] THEN Bug[unexpectedErrorStatus];      SIGNAL BadSector[currentSector];      currentSector ¬ currentSector + 1;      sectorCount ¬ sectorCount - 1;      ENDLOOP;    END;  -- ScanFloppyTape--  SetRootFile: PUBLIC --FloppyTape-- PROCEDURE [    fileID: FileID, volumeHandle: VolumeHandle] =    BEGIN    SetRootFileInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN      ENABLE        BEGIN	DiskChanged => {savedError ¬ invalidVolumeHandle; GO TO otherError};	InternalIOError => {savedError ¬ needsScavenging; GO TO otherError};	END;      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[invalidVolumeHandle];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      -- Just trust the fileID.  If we do ever decide to check for the      -- existence of the file, then we must allow nullID's through so that      -- clients may clear their entry.      -- note that if we don't ReadMarkerPage[], CheckMarkerPage[], then we      -- don't raise fileNotFound?      volumeDesc.rootPage.rootFile ¬ fileID;      FloppyTapeInternal.WriteRootPage[ !        Error => {savedError ¬ error; GO TO otherError};	InternalIOError => {savedError ¬ badTape; GO TO otherError}];      EXITS        otherError => RETURN WITH ERROR Error[savedError];      END;  --ENABLE--      END;  --SetRootFileInternal--    SetRootFileMain: FloppyTapeInternal.OperationProc =      BEGIN      FloppyTapeInternal.ValidateHandle[volumeHandle];      SetRootFileInternal[@volumeDescLock];      END;  --SetRootFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, SetRootFileMain, setRootFile];    END;  --SetRootFile--  SetVerifyAfterWrite: PUBLIC --FloppyTape-- PROCEDURE [    volumeHandle: VolumeHandle, verifyAfterWrite: BOOLEAN ¬ TRUE] =    BEGIN    SetVerifyAfterWriteInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[invalidVolumeHandle];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      volumeDesc.verifyAfterWrite ¬ verifyAfterWrite;      END;    SetVerifyAfterWriteMain: FloppyTapeInternal.OperationProc =      BEGIN      FloppyTapeInternal.ValidateHandle[volumeHandle];      SetVerifyAfterWriteInternal[@volumeDescLock];      END;  --SetVerifyAfterWriteMain--    FloppyTapeInternal.DoOperation[@FloppyTapeInternal.operationLock,      SetVerifyAfterWriteMain, setVerifyAfterWrite];    END;  --SetVerifyAfterWrite--  -- Module initialization  -- Find all of the floppyTape drives out there and initialize the volume table  -- Note that you can't change floppyTape drive location once this loop has  -- executed.  FOR i: FloppyTape.Drive ¬ FloppyChannel.GetNextDrive[FloppyChannel.nullDrive],    FloppyChannel.GetNextDrive[i] UNTIL i = FloppyChannel.nullDrive DO    -- look at each, set up if there    IF LOOPHOLE[FloppyChannel.GetDeviceAttributes[      FloppyChannel.GetHandle[i]].attributes.deviceType, CARDINAL]        NOT IN DeviceTypesExtras4.FloppyTape THEN LOOP;    volumeDesc ¬ z.NEW[FloppyTapeInternal.VolumeDescObject];    volumeDesc.open ¬ FALSE;    volumeDesc.drive ¬ i;    volumeDesc.changeCount ¬ 0;    volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;    volumeDesc.rootPage ¬ FloppyTapeInternal.CreateBuffer[      FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.RootPage]] +      FloppyTapeFormat.badSectorListSize].pointer;    volumeDesc.badSectorList ¬ LOOPHOLE[      volumeDesc.rootPage + SIZE[FloppyTapeFormat.RootPage], LONG POINTER];    volumeDesc.notifyClientOnRetention ¬ NIL;    EXIT; --only one drive at the moment    ENDLOOP;  --END mainline code--  END...LOG22-Jan-87 12:47:21  RSV  Created FileJAN - MAR	  ET/RSV Many bug fixes to prep up for system test.16-Mar-87 18:55:29  RSV  CreateFileInternal was calling FloppyChannel.WriteSectors with buffer.count instead of count.  Format was calling CheckBadSectorList with an overflow number of bytes instead of a legal number of sectors.21-Mar-87 22:24:33  RSV  SetBootFiles now checks for bad pages in the bootfiles, and also the actual existence of these files.  Check for too large pages when marking a sector bad.  Also allow pages beyond diagnostic cylinders by the CheckBadSectorList calls.  Moved CloseVolumeInternal to FloppyTapeImplB.25-Mar-87 17:56:44  RSV/ET  Don't allow InternalIOError from propogating out. defualt OpenVolume notifyClientOnRetention to NIL, so it's not called it if it is NIL.27-Mar-87 11:03:14  RSV/ET  Fix MarkSectorBadInternal so that it doesn't write same page number to the table n times. Added ForceOutBuffers to SetBootFiles. Trimed log. 5-May-87 16:12:02  RSV     Use ReadRootAndBadSectorList instead of ReadRootPage and ReadBadSectorList.  Cache bad pages for GetNextBadSector.20-May-87 12:43:34  ET	    Added numberOfBadSectors to GetVolumeAttributes.19-Jun-87 14:08:58  RSV     Changed around OpenVolume to allow auto retentioning.  Put in auto retentioning through rest of module.  Added writeTapeWithZeros parameter to Erase.  Added abortable formats.  Catch FloppyChannel.Error[invalidHandle].24-Jun-87 17:20:42  RSV     writeTapeWithZeros ¬ securityErase in Erase procedure.27-Jun-87 15:37:50  RSV     Format only 1 stream at a time and abort between each. 2-Jul-87 17:55:56  RSV     Initialize volumeDesc.fcHandle to FloppyChannel.nullHandle. 9-Jul-87 15:54:38  RSV     Implement securityErase.  Added SetVerifyAfterWrite procedure.14-Jul-87 22:18:18  RSV     Added DoOperation stuff.21-Jul-87 10:43:50  RSV     Moved ChangeVolume to FloppyTapeImplD.  Moved around setting volumeDesc.notifyClientOnRetention to before it could be used.23-Jul-87 11:28:15  RSV     Implemented volumeDesc.verifyAfterWrite.27-Jul-87 17:28:29  RSV     Catch DiskChanged where needed.30-Jul-87 16:55:44  RSV     Fix up CloseVolume to work with already closed volumes (AR 11482).  Do a little work on DoOperation main procedures (catch erros and do GOTO's)23-Sep-87 15:15:10  RSV     Fix AR 11699 on zeroing out boot page on Erase.25-Sep-87 11:08:15  RSV     CreateFileInternal shouldn't raise notFormatted on recordNotFound.  Support non-zero drives. 7-Oct-87 16:30:12  RSV     SpecialFloppyChannelExtras.GetDeviceHandle instead of FloppyTapeInternal.GetDeviceHandle.  Get only FloppyTapes.  Exit loops for retentioning if goodCompletion.19-Nov-87  0:02:37  RSV     Set volumeDesc.sectorsPerStream in OpenVolume.30-Nov-87 16:34:08  RSV     Set volumeDesc.verifyBuffer. 3-Jun-88 11:44:15  RSV     Added code in ScanFloppyTape for temporary hack for Daybreak Tape problems resulting from AR 13249 against the Daybreak heads.
-- Copyright (C) 1984 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- ScavengerUtilitiesImpl.mesa      14-Mar-88  8:56:03 by RSV    -- This module implements the ScavengerUtilities Interface which provides-- functions to both the Logical and Physical Volume Scavengers.DIRECTORY  DiskChannel USING [    defaultTries, DiskPageCount, DiskPageNumber, DoIO, Handle, IORequest,    IOStatus, Tries],  Environment USING [Base, maxPagesInMDS, PageCount, PageNumber, wordsPerPage],  File USING [ID, nullID, Type],  Inline USING [LowHalf],  LogicalVolumeFormat USING [    currentVersion, Handle, LSMCurrentVersion, LSMSeal,    maxLogicalVolumeLabelLength, lvRootSeal],  PhysicalVolume USING [ID, nullID, PageNumber],  PhysicalVolumeFormat USING [    Handle, MarkerHandle, markerPageSize, PageNumber, rootPageSize],  PilotDiskFace USING [Command, Status],  PilotFileTypes USING [tFreePage, tVolumeAllocationMap, tVolumeFileMap],  ResidentHeap USING [first64K, FreeNode, MakeNode],  RuntimeInternal USING [Bug],  ScavengerUtilities USING [Direction, SVInfo, TryMode],  Space USING [    Allocate, Deallocate, Interval, LongPointerFromPage, PageFromLongPointer,    PagesFromWords],  VM USING [Interval, Map, MakeResident, MakeSwappable, Unmap],  VolTable USING [    GetNextSV, GetSVToken, LVToken, MapMarkerPage, MapPVRootPage, nullSVDesc,    PVAccess, PVAccessProc, SVDesc, UnmapMarkerPage, UnmapPVRootPage],  Volume USING [ID, PageNumber, Type],  Zone USING [Status];ScavengerUtilitiesImpl: PROGRAM  IMPORTS DiskChannel, Inline, ResidentHeap, RuntimeInternal, Space, VM, VolTable  EXPORTS ScavengerUtilities =  BEGIN  OPEN LVF: LogicalVolumeFormat, PVF: PhysicalVolumeFormat,    SU: ScavengerUtilities;  -- TYPEs  RelativePtr: TYPE = Environment.Base RELATIVE POINTER;  Command: TYPE = {read, write};  -- CONSTANTS  first64KPage: Environment.PageNumber = Space.PageFromLongPointer[    LOOPHOLE[LONG[1], LONG POINTER]];  -- Bugs and Errors  BugType: TYPE = {    impossibleEndcase, invalidChannel, invalidDriveState, lvChangedSize,    pageThatWasGoodWentBad, pointerNotInFirst64K, residentHeapFreeNodeFailure,    residentHeapMakeNodeFailure};  -- PUBLIC PROCEDUREs  CheckLVConsistency: PUBLIC PROCEDURE [    vol: LVF.Handle, subvolumes: LONG DESCRIPTOR FOR ARRAY OF SU.SVInfo]    RETURNS [consistent: BOOLEAN] =    BEGIN    IF ~ValidLVRootPage[vol] THEN RETURN[FALSE];    RETURN LVRootAndMarkersConsistent[vol: vol, sv: subvolumes];    END;  FreeLVBadPages: PUBLIC PROCEDURE [    badPages: LONG DESCRIPTOR FOR ARRAY OF Volume.PageNumber] =    BEGIN    pageCount: Environment.PageCount =      (LENGTH[badPages] * SIZE[Volume.PageNumber] + Environment.wordsPerPage - 1)        / Environment.wordsPerPage;    VM.Unmap[Space.PageFromLongPointer[BASE[badPages]]];    Space.Deallocate[[BASE[badPages], pageCount]];    END;  FreeLVMarkerPages: PUBLIC PROCEDURE [    subvolumes: LONG DESCRIPTOR FOR ARRAY OF SU.SVInfo] =    BEGIN    IF subvolumes # NIL THEN      BEGIN      numSubvolumes: CARDINAL = LENGTH[subvolumes];      markerPageInterval: Space.Interval ¬ [subvolumes[0].marker, numSubvolumes];      FOR index: CARDINAL IN [0..numSubvolumes) DO        VolTable.UnmapMarkerPage[          subvolumes[index].svTok, subvolumes[index].marker];        ENDLOOP;      Space.Deallocate[markerPageInterval];      IF ResidentHeap.FreeNode[GetRelativePointer[BASE[subvolumes]]] ~= okay THEN        Bug[residentHeapFreeNodeFailure];      END;    END;  GatherLVBadPages: PUBLIC PROCEDURE [tok: VolTable.LVToken, lv: Volume.ID]    RETURNS [badPages: LONG DESCRIPTOR FOR ARRAY OF Volume.PageNumber] =    BEGIN    sorted: BOOLEAN;    svDesc: VolTable.SVDesc;    badPagesSpace: Space.Interval;    lastPVID: PhysicalVolume.ID;    countCollected: CARDINAL ¬ 0;    pv: PVF.Handle ¬ Space.Allocate[PVF.rootPageSize].pointer;    numBadPages: CARDINAL ¬ 0;  -- ASSERT less than LAST[CARDINAL] bad pages.    CountBadPages: VolTable.PVAccessProc =      --[tok: PVToken, rootPageLoc: PhysicalVolume.PageNumber]      --Other parms from parent's frame: svDesc      BEGIN      VolTable.MapPVRootPage[tok, pv];      FOR i: CARDINAL IN [0..CARDINAL[pv.badPageCount]) DO        IF pv.badPageList[i] IN          [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength) THEN          numBadPages ¬ numBadPages + 1;        ENDLOOP;      VolTable.UnmapPVRootPage[tok, pv];      END;    GetBadPages: VolTable.PVAccessProc =      --[tok: PVToken, rootPageLoc: PhysicalVolume.PageNumber]      --Other parms from parent's frame: svDesc      BEGIN      VolTable.MapPVRootPage[tok, pv];      FOR i: CARDINAL IN [0..CARDINAL[pv.badPageCount]) DO        IF pv.badPageList[i] IN          [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength) THEN          BEGIN          badPages[countCollected] ¬            pv.badPageList[i] - svDesc.pvPageOfSV;          countCollected ¬ countCollected + 1;          END;        ENDLOOP;      VolTable.UnmapPVRootPage[tok, pv];      END;    lastPVID ¬ PhysicalVolume.nullID;    VolTable.GetNextSV[[byLV[lv, [first[]]]], @svDesc];    UNTIL svDesc = VolTable.nullSVDesc DO BEGIN      IF svDesc.pvID = lastPVID THEN GO TO enumNextSV;  -- Multiple SVs of an LV on a PV.      lastPVID ¬ svDesc.pvID;      VolTable.PVAccess[pvID: lastPVID, proc: CountBadPages, lock: read];      GO TO enumNextSV;      EXITS        enumNextSV => VolTable.GetNextSV[[byLV[lv, [next[svDesc.lvPageOfSV]]]], @svDesc];      END;      ENDLOOP;    badPagesSpace ¬ Space.Allocate[      MAX[Space.PagesFromWords[numBadPages * SIZE[Volume.PageNumber]], 1]];    ResidentMap[      mapUnit: [      Space.PageFromLongPointer[badPagesSpace.pointer], badPagesSpace.count]];    badPages ¬ DESCRIPTOR[badPagesSpace.pointer, numBadPages];    IF numBadPages = 0 THEN RETURN;    -- Actually collect the list of bad pages from each of the physical volumes.    lastPVID ¬ PhysicalVolume.nullID;    VolTable.GetNextSV[[byLV[lv, [first[]]]], @svDesc];    UNTIL svDesc = VolTable.nullSVDesc DO BEGIN      IF svDesc.pvID = lastPVID THEN GO TO enumNextSV;  -- Multiple SVs of an LV on a PV.      lastPVID ¬ svDesc.pvID;      VolTable.PVAccess[pvID: lastPVID, proc: GetBadPages, lock: read];      GO TO enumNextSV;      EXITS        enumNextSV => VolTable.GetNextSV[[byLV[lv, [next[svDesc.lvPageOfSV]]]], @svDesc];      END;      ENDLOOP;    IF countCollected ~= numBadPages THEN Bug[lvChangedSize];    -- Sort the bad page list into ascending order.    sorted ¬ FALSE;    WHILE ~sorted DO  -- sort the bad page list into ascending order      sorted ¬ TRUE;      FOR i: CARDINAL IN [0..LENGTH[badPages] - 1) DO        IF badPages[i] > badPages[i + 1] THEN          BEGIN          temp: Volume.PageNumber;          sorted ¬ FALSE;          temp ¬ badPages[i];          badPages[i] ¬ badPages[i + 1];          badPages[i + 1] ¬ temp;          END;        ENDLOOP;      ENDLOOP;    END;  GatherLVMarkerPages: PUBLIC PROCEDURE [tok: VolTable.LVToken, lv: Volume.ID]    RETURNS [subvolumes: LONG DESCRIPTOR FOR ARRAY OF SU.SVInfo] =    BEGIN    index: CARDINAL;    status: Zone.Status;    markerSpace: Space.Interval;    numSubvolumes: CARDINAL ¬ 0;    subvolumesInfoNode: RelativePtr;    svDesc: VolTable.SVDesc;    VolTable.GetNextSV[[byLV[lv, [first[]]]], @svDesc];      UNTIL svDesc = VolTable.nullSVDesc DO       numSubvolumes ¬ numSubvolumes + 1;      VolTable.GetNextSV[[byLV[lv, [next[svDesc.lvPageOfSV]]]], @svDesc];      ENDLOOP;    [subvolumesInfoNode, status] ¬ ResidentHeap.MakeNode[      numSubvolumes * SIZE[SU.SVInfo]];    IF status ~= okay THEN Bug[residentHeapMakeNodeFailure];    subvolumes ¬ DESCRIPTOR[      @ResidentHeap.first64K[subvolumesInfoNode], numSubvolumes];    markerSpace ¬ Space.Allocate[numSubvolumes * PVF.markerPageSize];    index ¬ 0;    VolTable.GetNextSV[[byLV[lv, [first[]]]], @svDesc];    UNTIL svDesc = VolTable.nullSVDesc DO      subvolumes[index] ¬ [        TRUE, VolTable.GetSVToken[tok, svDesc.lvPageOfSV], svDesc,        markerSpace.pointer + index * PVF.markerPageSize];      VolTable.MapMarkerPage[subvolumes[index].svTok, subvolumes[index].marker];      index ¬ index + 1;      VolTable.GetNextSV[[byLV[lv, [next[svDesc.lvPageOfSV]]]], @svDesc];      ENDLOOP;    IF index ~= numSubvolumes THEN Bug[lvChangedSize];    END;          MovePages: PUBLIC PROCEDURE [    firstPage: DiskChannel.DiskPageNumber, count: DiskChannel.DiskPageCount,    direction: ScavengerUtilities.Direction,    diskChannel: DiskChannel.Handle,    badPages: LONG DESCRIPTOR FOR ARRAY OF PhysicalVolume.PageNumber,    maxMove: DiskChannel.DiskPageCount]    RETURNS [okay: BOOLEAN, countMoved: DiskChannel.DiskPageCount] =    BEGIN    badPageFound: BOOLEAN;    b: PhysicalVolume.PageNumber;    status: disk DiskChannel.IOStatus;    countValid: DiskChannel.DiskPageCount;    scratchPagePtr: LONG POINTER ¬ Space.Allocate[1].pointer;    found: BOOLEAN ¬ FALSE;  -- Was a new set of pages found?    pageDest: PhysicalVolume.PageNumber;  -- Starting Page of new group.    lastPageToTry: PhysicalVolume.PageNumber;    PageAsArray: TYPE = LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF      WORD;    GetContainedBadPage: PROCEDURE [      p: PhysicalVolume.PageNumber, count: DiskChannel.DiskPageCount]      RETURNS [badPage: PhysicalVolume.PageNumber, found: BOOLEAN] =      BEGIN      page: PhysicalVolume.PageNumber;      lastPage: PhysicalVolume.PageNumber = p + count;      FOR i: CARDINAL IN [0..LENGTH[badPages]) DO        IF badPages[i] > lastPage THEN RETURN[lastPage, FALSE];        IF badPages[i] IN [p..lastPage) THEN	  BEGIN          IF direction = forward THEN            BEGIN  -- Look for bad pages further in the run.            [page, found] ¬ GetContainedBadPage[              badPages[i] + 1, lastPage - badPages[i] + 1];            RETURN[badPage: IF found THEN page ELSE badPages[i], found: TRUE];            END	  ELSE --IF direction = backward THEN--	    RETURN[badPage: badPages[i], found: TRUE];	  END; --badPages[i] IN [p..lastPage)--        ENDLOOP;      RETURN[lastPage, FALSE];      END;  --GetContainedBadPage--    MoreToDo: PROCEDURE RETURNS [BOOLEAN] = INLINE {      RETURN[        IF direction = forward THEN pageDest <= lastPageToTry        ELSE pageDest >= lastPageToTry]};	    TestOfDataVerifies: PROCEDURE        [pageToTest: PhysicalVolume.PageNumber] RETURNS [pageIsUsable: BOOLEAN] =      BEGIN      scratchReadPagePtr: LONG POINTER ¬ Space.Allocate[1].pointer;      ResidentMap[[page: Space.PageFromLongPointer[scratchReadPagePtr], count: 1]];      LOOPHOLE[scratchPagePtr, PageAsArray]­ ¬ ALL[125252B];      [] ¬ WritePages[scratchPagePtr, pageToTest, 1, diskChannel, normalRetry];      LOOPHOLE[scratchReadPagePtr, PageAsArray]­ ¬ ALL[0];      status ¬ ReadPages[scratchReadPagePtr, pageToTest, 1, diskChannel, normalRetry];      IF status.status = goodCompletion AND       LOOPHOLE[scratchPagePtr, PageAsArray]­ = LOOPHOLE[scratchReadPagePtr, PageAsArray]­        THEN pageIsUsable ¬ TRUE      	ELSE pageIsUsable ¬ FALSE;      VM.Unmap[Space.PageFromLongPointer[scratchReadPagePtr]];      Space.Deallocate[[scratchReadPagePtr, 1]];      END;    -- Begin main text of MovePages:    ResidentMap[[page: Space.PageFromLongPointer[scratchPagePtr], count: 1]];    lastPageToTry ¬      IF direction = forward THEN firstPage + maxMove ELSE firstPage - maxMove;    pageDest ¬ IF direction = forward THEN firstPage + count ELSE firstPage - count;    WHILE MoreToDo[] DO      [b, badPageFound] ¬ GetContainedBadPage[pageDest, count];      IF badPageFound THEN        pageDest ¬ IF direction = forward THEN b + 1 ELSE b - count      ELSE  -- No pages marked as bad, but try reading them anyway...        BEGIN        [status, countValid] ¬ TransferPageRun[          pageDest, read, scratchPagePtr, count, diskChannel, normalRetry];        IF status.status = goodCompletion THEN {found ¬ TRUE; EXIT};	-- the page is not in the bad page table and is also not successfuly 	-- completing a read. try writing test data to check if page is usable 	IF NOT TestOfDataVerifies[pageDest+countValid] THEN	  -- skip the page that didn't verify and continue to find some good contiguous pages, else try this group again (since a successful write/read was done)          pageDest ¬            IF direction = forward THEN pageDest + countValid + 1            ELSE pageDest + countValid - count;        END;      ENDLOOP;    IF ~found THEN  -- No replacement page group could be found.      BEGIN      VM.Unmap[Space.PageFromLongPointer[scratchPagePtr]];      Space.Deallocate[[scratchPagePtr, 1]];      RETURN[okay: FALSE, countMoved: 0];      END;    -- Okay, we've got the pages, Try and copy the data from old to new...    FOR k: DiskChannel.DiskPageCount IN [0..count) DO      status ¬ ReadPages[        scratchPagePtr, firstPage + k, 1, diskChannel, normalRetry].status;      IF status.status ~= goodCompletion THEN  -- Old Page no good, supply zeroes.        LOOPHOLE[scratchPagePtr, PageAsArray]­ ¬ ALL[0];      status ¬ WritePages[        scratchPagePtr, pageDest + k, 1, diskChannel, normalRetry];      IF status.status ~= goodCompletion THEN Bug[pageThatWasGoodWentBad];      ENDLOOP;    VM.Unmap[Space.PageFromLongPointer[scratchPagePtr]];    Space.Deallocate[[scratchPagePtr, 1]];    countMoved ¬ IF direction = forward       THEN pageDest - firstPage ELSE firstPage - pageDest;    RETURN[okay: TRUE, countMoved: countMoved];    END;  -- MovePages    ReadPages: PUBLIC PROCEDURE [    data: LONG POINTER, firstPage: DiskChannel.DiskPageNumber,    count: DiskChannel.DiskPageCount, diskChannel: DiskChannel.Handle,    try: SU.TryMode] RETURNS [status: disk DiskChannel.IOStatus] =  --    -- Doesn't the caller want the returned countValid? -WDK    {    RETURN[      TransferPageRun[        firstPage, read, data, count, diskChannel, try].status]};  WritePages: PUBLIC PROCEDURE [    data: LONG POINTER, firstPage: DiskChannel.DiskPageNumber,    count: DiskChannel.DiskPageCount, diskChannel: DiskChannel.Handle,    try: SU.TryMode] RETURNS [status: disk DiskChannel.IOStatus] =    BEGIN    RETURN[      TransferPageRun[        firstPage, write, data, count, diskChannel, try].status];    END;  -- WritePages  -- PRIVATE PROCEDURES  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  GetRelativePointer: PROCEDURE [pointer: LONG POINTER] RETURNS [RelativePtr] =    BEGIN    IF Space.PageFromLongPointer[pointer] ~IN      [first64KPage..first64KPage + Environment.maxPagesInMDS) THEN      Bug[pointerNotInFirst64K];    RETURN[Inline.LowHalf[pointer - Space.LongPointerFromPage[first64KPage]]]    END;  ResidentMap: PROCEDURE [mapUnit: VM.Interval] =    BEGIN    VM.Map[      interval: mapUnit, transferProc: NIL, backingStoreRuns: NIL,      swapUnits: [unitary[]], life: dead, swappability: resident];    END;  LVRootAndMarkersConsistent: PROCEDURE [    vol: LVF.Handle, sv: LONG DESCRIPTOR FOR ARRAY OF SU.SVInfo]    RETURNS [mutuallyConsistent: BOOLEAN] =    -- Checks for mutual consistency between a LV RootPage and    -- its subvolume marker pages.     BEGIN    allMarkersValid: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..LENGTH[sv]) DO      sv[i].valid ¬ ValidateLVMarkerPage[sv[i].marker];      allMarkersValid ¬ allMarkersValid AND sv[i].valid;      ENDLOOP;    IF ~allMarkersValid THEN RETURN[FALSE];    -- Check that root page is consistent with the first marker.    BEGIN OPEN lsm: sv[0].marker.logical;    mutuallyConsistent ¬ lsm.labelLength = vol.labelLength AND lsm.type = vol.type      AND lsm.label = vol.label AND lsm.bootingInfo = vol.bootingInfo      AND lsm.volumeRootDirectory = vol.volumeRootDirectory      AND lsm.primaryETableStartPage = vol.primaryETableStartPage      AND lsm.copyETableStartPage = vol.copyETableStartPage      AND lsm.statusPrimaryETableFile = vol.statusPrimaryETableFile      AND lsm.statusCopyETableFile = vol.statusCopyETableFile;    END;  -- lsm scope.    IF ~mutuallyConsistent THEN RETURN[FALSE];    -- Now check the first marker against the rest.    FOR i: CARDINAL IN [0..LENGTH[sv] - 1) DO      OPEN currentLSM: sv[i].marker.logical, nextLSM: sv[i + 1].marker.logical;      mutuallyConsistent ¬ currentLSM.labelLength = nextLSM.labelLength        AND currentLSM.type = nextLSM.type AND currentLSM.label = nextLSM.label        AND currentLSM.bootingInfo = nextLSM.bootingInfo        AND currentLSM.volumeRootDirectory = nextLSM.volumeRootDirectory	AND currentLSM.primaryETableStartPage = nextLSM.primaryETableStartPage	AND currentLSM.copyETableStartPage = nextLSM.copyETableStartPage	AND currentLSM.statusPrimaryETableFile = nextLSM.statusPrimaryETableFile	AND currentLSM.statusCopyETableFile = nextLSM.statusCopyETableFile;      IF ~mutuallyConsistent THEN EXIT;      ENDLOOP;    END;  -- LVRootAndMarkersConsistent  TransferPageRun: PROCEDURE [    page: PhysicalVolume.PageNumber, command: Command, data: LONG POINTER,    count: DiskChannel.DiskPageCount, channel: DiskChannel.Handle,    try: SU.TryMode]    RETURNS [      status: disk DiskChannel.IOStatus, countValid: DiskChannel.DiskPageCount] =    BEGIN    ioStatus: DiskChannel.IOStatus;    request: DiskChannel.IORequest;    diskCommand: PilotDiskFace.Command;    SELECT command FROM      write => diskCommand ¬ write;      read => diskCommand ¬ read;      ENDCASE => Bug[impossibleEndcase];    request ¬ [      diskPage: page, memoryPage: Space.PageFromLongPointer[data],      useSamePage: FALSE, count: count, command: diskCommand,      tries:      IF try = tryRealHard THEN DiskChannel.Tries.LAST      ELSE DiskChannel.defaultTries];    VM.MakeResident[[page: request.memoryPage, count: count], wait];    [ioStatus, countValid] ¬ DiskChannel.DoIO[channel, @request];    VM.MakeSwappable[[page: request.memoryPage, count: count]];    WITH diskStatus: ioStatus SELECT FROM      invalidChannel => Bug[invalidChannel];      invalidDriveState => Bug[invalidDriveState];      disk => status ¬ diskStatus;      ENDCASE => Bug[impossibleEndcase];    END;  -- TransferPageRun  ValidateLVMarkerPage: PROCEDURE [marker: PVF.MarkerHandle]    RETURNS [valid: BOOLEAN] =    BEGIN OPEN lsm: marker.logical;    RETURN[      lsm.seal = LVF.LSMSeal AND       lsm.version = LVF.LSMCurrentVersion AND       lsm.labelLength IN [0..LVF.maxLogicalVolumeLabelLength] AND       lsm.type IN Volume.Type];    END;  -- ValidateLVMarkerPage  ValidLVRootPage: PROCEDURE [vol: LVF.Handle]    RETURNS [lvSelfConsistent: BOOLEAN] =    BEGIN    lvSelfConsistent ¬ vol.seal = LVF.lvRootSeal      AND vol.version = LVF.currentVersion      AND vol.labelLength IN [0..LVF.maxLogicalVolumeLabelLength]      AND vol.type IN Volume.Type AND vol.freePageCount < vol.volumeSize      AND vol.vamStart > 0 AND vol.vamStart < vol.volumeSize      AND vol.primaryETableStartPage < vol.volumeSize      AND vol.copyETableStartPage < vol.volumeSize       AND vol.lowerBound <= vol.volumeSize      AND vol.checksum = 0      AND ValidVolumeRootFiles[vol];    END;  -- ValidateLVRootPage  ValidVolumeRootFiles: PROCEDURE [v: LVF.Handle] RETURNS [okay: BOOLEAN] =    BEGIN OPEN PFT: PilotFileTypes;    RETURN[      v.rootFileID[PFT.tFreePage] # File.nullID        AND v.rootFileID[PFT.tVolumeAllocationMap] # File.nullID        AND v.rootFileID[PFT.tVolumeFileMap] # File.nullID        AND v.rootFileID[PFT.tFreePage] # v.rootFileID[PFT.tVolumeAllocationMap]        AND v.rootFileID[PFT.tFreePage] # v.rootFileID[PFT.tVolumeFileMap]        AND v.rootFileID[PFT.tVolumeAllocationMap] # 	   v.rootFileID[PFT.tVolumeFileMap]];    END;  -- ValidVolumeRootFiles  END.LOG20-Dec-82 11:10:55   JXP      Created File. Modify MovePages to move the pages in a specified direction. 8-Feb-83 16:45:09   JXP      Fix GatherLVBadPages, enumerate SV's by LV NOT by PV.22-Mar-83 11:32:49   JXP   	LVF.Seal => LVF.lvRootSeal. 3-May-83 15:07:32   JXP      Remember to map the badPageSpace in GatherLVBadPages. 4-May-83 10:45:01   JXP      Collect only bad pages in the current LV in GatherLVBadPages.31-Oct-83 11:21:48   WDK        AR4746: PageAsArray should be [). MovePages.countMoved was wrong.   change MovePages to use callback proc to generate labels. 6-Dec-83 11:30:50   WDK        FreeLVMarkerPages didn't handle NIL.13-Dec-83 17:49:21   WDK        Use Tries.LAST, not factor.   ValidLVRootPage should not reject lowerBound of 0. 3-Feb-84 17:10:17   CAJ    Remove checking of fill and pad fields.13-Jul-84 10:49:54   EKN     Fix AR 5431: pvSubmarker.lvshouldbescavenged should not be ignored (Change made to ValidateLVMarkerPage)   Fix AR 5057: MovePages changed to further test a page if it is not in the bad page table and doesn't do a read successfully, before skipping over it.23-Jan-85 21:20:02   CJS       Twiddled calls to VolTable.GetNextSV per AR 6275.15-Feb-85  9:21:30   CJS       Fix my infinite loop waiting to happen in GetBadPages.      10-Jul-86 15:58:08   RSV   Changed vfmStart to eTableFileStart, deleted references to labels29-Sep-86 17:49:14   RSV   Fixed LVRootAndMarkersConsistent to check new ETable marker page fields.13-Nov-86 16:26:43   RSV   Got rid of last CHANGE comments.  No functional changes. 9-Jan-87 14:24:54   RRR   Changes to enable moving of lv root page.12-Mar-87 10:47:36   RRR   Remove references to PhysicalVolume Marker pages.14-Mar-88  8:56:03   RSV   Fixed bug in MovePages to help move marker page over more than one bad page.
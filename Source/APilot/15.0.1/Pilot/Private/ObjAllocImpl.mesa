-- Copyright (C) 1983, 1986, 1988  by Xerox Corporation. All rights reserved. -- ObjAllocImpl.mesa (last edited by: RSV    on   2-Nov-88 16:15:32)-- Note: All of the exported procedures are documented in the defs fileDIRECTORY  ObjAlloc USING [    AllocFree, AllocationPool, AllocPoolDesc, ErrorType, Interval, ItemCount,    ItemIndex, Error, AlreadyFreed],  Environment USING [bitsPerWord, Byte, Word, bitsPerByte],  Inline USING [    HighByte, LongCOPY, LowByte, BITNOT, BITAND, BITOR, BITSHIFT, UDDivMod],  KernelObjAlloc USING [AlreadyAllocated];ObjAllocImpl: PROGRAM  IMPORTS ObjAlloc, Inline, KernelObjAlloc  EXPORTS KernelObjAlloc, ObjAlloc =  BEGIN  ByteArray: TYPE = PACKED ARRAY [0..0) OF Environment.Byte;  WordArray: TYPE = ARRAY [0..0) OF Environment.Word;  allOnes: Environment.Word = 177777B;  allZeros: Environment.Word = 000000B;  AlreadyAllocated: PUBLIC ERROR [item: ObjAlloc.ItemIndex] = CODE;  AlreadyFreed: PUBLIC ERROR [item: ObjAlloc.ItemIndex] = CODE;  Error: PUBLIC ERROR [error: ObjAlloc.ErrorType] = CODE;  allocValCheck: BOOLEAN [TRUE..TRUE] =    ((LOOPHOLE[ObjAlloc.AllocFree[free], CARDINAL] = 0)      AND (LOOPHOLE[ObjAlloc.AllocFree[alloc], CARDINAL] = 1));  -- if 'alloc' and 'free' are defined differently the compiler will catch it      -- first, the PUBLIC procedures, in amphibolical order  Allocate: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, count: ObjAlloc.ItemCount,    willTakeSmaller: BOOLEAN] RETURNS [interval: ObjAlloc.Interval] =    BEGIN    carryOut: ObjAlloc.ItemCount;    IF count = 0 THEN ERROR ObjAlloc.Error[invalidParameters];    [interval, carryOut] ¬ FindFreeRange[pool, 0, count, willTakeSmaller, 0];      --Note: If willTakeSmaller is false, and not enough space is found,      --FindFreeRange raises insufficientSpace.  Otherwise, if willTakeSmaller is true,      --FindFreeRange returns, and a check must be done here for insufficientSpace.      --(i.e. no free interval)    IF interval.count = 0 THEN ERROR ObjAlloc.Error[insufficientSpace]    ELSE      BEGIN      --word align the interval by:      --calculating the first and last words that the interval is contained in      --calculating the offset from the beginning of the word      --calculating how many trailing bits are in last word      --looking at the bit array as a word array      firstWord: LONG CARDINAL ¬ interval.first/Environment.bitsPerWord;      wordStart: ObjAlloc.ItemIndex ¬ firstWord*Environment.bitsPerWord;          --wordStart is the index to the first bit of the firstWord      bitOffset: CARDINAL ¬ CARDINAL[interval.first - wordStart];      a: LONG POINTER TO WordArray ¬ LOOPHOLE[pool.allocPool];      lastWord: ObjAlloc.ItemIndex ¬        (wordStart + interval.count + bitOffset)/Environment.bitsPerWord;      extra: CARDINAL ¬ CARDINAL[        (interval.count + bitOffset) MOD Environment.bitsPerWord];      --mark the interval as allocated (this may be smaller than count objects)      MarkInterval[a, firstWord, lastWord, bitOffset, interval.count, extra, TRUE];      END;    END;  AllocateAt: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, interval: ObjAlloc.Interval, validate: BOOLEAN] =        BEGIN    --word align the interval with the following calculations    firstWord: ObjAlloc.ItemIndex ¬ interval.first/Environment.bitsPerWord;    wordStart: ObjAlloc.ItemIndex ¬ firstWord*Environment.bitsPerWord;      --wordStart is the index to the first bit of the firstWord    bitOffset: CARDINAL ¬ CARDINAL[interval.first - wordStart];    lastWord: ObjAlloc.ItemIndex ¬      (wordStart + interval.count + bitOffset)/Environment.bitsPerWord;    extra: CARDINAL ¬ CARDINAL[      (interval.count + bitOffset) MOD Environment.bitsPerWord];    a: LONG POINTER TO WordArray ¬ LOOPHOLE[pool.allocPool];    --check if interval is within bounds    IF pool.poolSize < interval.first + interval.count THEN      ERROR ObjAlloc.Error[invalidParameters];    IF validate THEN      BEGIN      valid: BOOLEAN;      firstAlloc: ObjAlloc.ItemIndex;      --check to see if the interval has any allocated objects      [valid, firstAlloc] ¬ ValidateInterval[        a, firstWord, lastWord, bitOffset, interval.count, extra, FALSE];      IF ~valid THEN ERROR KernelObjAlloc.AlreadyAllocated[firstAlloc];      END;    --mark interval as allocated    MarkInterval[a, firstWord, lastWord, bitOffset, interval.count, extra, TRUE];    END;          AllSameState: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, interval: ObjAlloc.Interval,     desiredState: ObjAlloc.AllocFree]    RETURNS [allSame:BOOLEAN, firstDifferent:ObjAlloc.ItemIndex] =    BEGIN    firstWord: ObjAlloc.ItemIndex ¬ interval.first/Environment.bitsPerWord;    wordStart: ObjAlloc.ItemIndex ¬ firstWord*Environment.bitsPerWord;      --wordStart is the index to the first bit of the firstWord    bitOffset: CARDINAL ¬ CARDINAL[interval.first - wordStart];    lastWord: ObjAlloc.ItemIndex ¬      (wordStart + interval.count + bitOffset)/Environment.bitsPerWord;    extra: CARDINAL ¬ CARDINAL[      (interval.count + bitOffset) MOD Environment.bitsPerWord];    a: LONG POINTER TO WordArray ¬ LOOPHOLE[pool.allocPool];    --check if interval is within bounds    IF pool.poolSize < interval.first + interval.count THEN      ERROR ObjAlloc.Error[invalidParameters];    SELECT desiredState FROM      alloc =>         [allSame, firstDifferent] ¬ 	  ValidateInterval[a, firstWord, lastWord, bitOffset, interval.count, extra, TRUE];      free =>        [allSame, firstDifferent] ¬ 	  ValidateInterval[a, firstWord, lastWord, bitOffset, interval.count, extra, FALSE];      ENDCASE;          END;  FindBackwardFreeRange: PUBLIC --KernelObjAlloc-- PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, offset: ObjAlloc.ItemCount,    count: ObjAlloc.ItemCount, willTakeSmaller: BOOLEAN,     carryIn: ObjAlloc.ItemCount]    RETURNS [interval: ObjAlloc.Interval, carryOut: ObjAlloc.ItemCount] =    BEGIN    chunkSize: ObjAlloc.ItemCount;    currentSize: ObjAlloc.ItemCount;    holeOffset: LONG INTEGER;    sizeLeft: ObjAlloc.ItemCount;    --portion of array that hans't already been indexed by FindHoleInBitArray    wordIndex: LONG CARDINAL;  --word to start checking next chunk from    longBitOffset: LONG CARDINAL;    bitOffset: CARDINAL;    poolPtr: LONG POINTER TO ObjAlloc.AllocationPool;    maxNatBits: NATURAL =      (LAST[NATURAL]/Environment.bitsPerWord)*Environment.bitsPerWord;    nullInterval: ObjAlloc.Interval = [0, 0];    IF (count = 0) THEN ERROR ObjAlloc.Error[invalidParameters];    interval ¬ nullInterval;    carryOut ¬ carryIn;    sizeLeft ¬ pool.poolSize - offset;  -- ignore bits after client offset        WHILE sizeLeft > 0 DO      [quotient: wordIndex, remainder: longBitOffset] ¬         Inline.UDDivMod[num: sizeLeft, den: Environment.bitsPerWord];      bitOffset ¬ CARDINAL[longBitOffset];      chunkSize ¬        MIN[sizeLeft, maxNatBits - Environment.bitsPerWord + bitOffset];      sizeLeft ¬ sizeLeft - chunkSize;      poolPtr ¬ pool.allocPool + (sizeLeft / Environment.bitsPerWord);            [bestOffset: holeOffset, bestSize: currentSize, carryOut: carryOut] ¬        FindHoleBackwardInBitArray[          a: LOOPHOLE[poolPtr, LONG POINTER TO ByteArray], bitOffset: bitOffset,           bitCount: CARDINAL[chunkSize], holeSize: count,          carryIn: carryOut];	        IF currentSize > interval.count THEN        BEGIN	-- in the following expression, note that:	-- holeOffset is relative to the beginning of the interval checked	-- while sizeLeft is the amount that hasn't been checked yet	interval.count ¬ MIN[currentSize, count];	interval.first ¬ holeOffset + sizeLeft;        IF interval.count = count THEN RETURN;        END;      ENDLOOP;    -- count objects have not been found, so raise an error if willTakeSmaller is    -- false     IF ~willTakeSmaller THEN ERROR ObjAlloc.Error[insufficientSpace];    END;  FindFreeRange: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, offset:ObjAlloc.ItemCount,    count: ObjAlloc.ItemCount, willTakeSmaller: BOOLEAN,     carryIn: ObjAlloc.ItemCount]    RETURNS [interval: ObjAlloc.Interval, carryOut: ObjAlloc.ItemCount] =    BEGIN    chunkSize: ObjAlloc.ItemCount;    currentSize: ObjAlloc.ItemCount;    holeOffset: LONG INTEGER;    sizeChecked: ObjAlloc.ItemCount;    --portion of array that is  already indexed by FindHoleInBitArray    wordIndex: LONG CARDINAL;  --word to start checking next chunk from    longBitOffset: LONG CARDINAL;  bitOffset:CARDINAL;    poolPtr: LONG POINTER TO ObjAlloc.AllocationPool;    maxNatBits: NATURAL =      (LAST[NATURAL]/Environment.bitsPerWord)*Environment.bitsPerWord;    nullInterval: ObjAlloc.Interval = [0, 0];    IF count=0 THEN ERROR ObjAlloc.Error[invalidParameters];    interval ¬ nullInterval;    carryOut ¬ carryIn;    sizeChecked ¬ offset;  -- ignore bits before client offset        WHILE sizeChecked < pool.poolSize DO      [quotient:wordIndex, remainder:longBitOffset] ¬         Inline.UDDivMod[num:sizeChecked, den:Environment.bitsPerWord];      bitOffset ¬ CARDINAL[longBitOffset];      poolPtr ¬ pool.allocPool + wordIndex;      chunkSize ¬ MIN[pool.poolSize-sizeChecked, maxNatBits-bitOffset];            [bestOffset: holeOffset, bestSize: currentSize, carryOut: carryOut] ¬        FindHoleInBitArray[          a: LOOPHOLE[poolPtr, LONG POINTER TO ByteArray], bitOffset:bitOffset,           bitCount: CARDINAL[chunkSize], holeSize: count,          carryIn: carryOut];	        IF currentSize > interval.count THEN        BEGIN        interval.count ¬ MIN[currentSize, count];        IF (sizeChecked = offset) AND (holeOffset < bitOffset) THEN interval.first ¬ offset        ELSE 	  -- in the following expression, note that:	  -- holeOffset is relative to the beginning of word wordIndex	  -- but that sizeChecked points bitOffset bits into that word	   interval.first ¬ holeOffset + sizeChecked - bitOffset;         IF interval.count = count THEN RETURN;        END;      sizeChecked ¬ sizeChecked + chunkSize;      ENDLOOP;    -- count objects have not been found, so raise an error if willTakeSmaller is false     IF ~willTakeSmaller THEN ERROR ObjAlloc.Error[insufficientSpace];    END;  ExpandAllocation: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, where: ObjAlloc.ItemIndex,    count: ObjAlloc.ItemCount, willTakeSmaller: BOOLEAN]    RETURNS [extendedBy: ObjAlloc.ItemCount] =    BEGIN    --word align the interval by the following calculations    word: CARDINAL ¬ CARDINAL[where/Environment.bitsPerWord];    wordStart: ObjAlloc.ItemIndex ¬ word*Environment.bitsPerWord;      --wordStart is the index to the first bit of the firstWord    bitOffset: CARDINAL ¬ CARDINAL[where - wordStart];    a: LONG POINTER TO WordArray ¬ LOOPHOLE[pool.allocPool];    lastWord: ObjAlloc.ItemIndex ¬      (wordStart + count + bitOffset)/Environment.bitsPerWord;    extra: CARDINAL ¬ CARDINAL[      (count + bitOffset) MOD Environment.bitsPerWord];    valid: BOOLEAN;    firstAlloc: ObjAlloc.ItemIndex;    newCount: ObjAlloc.ItemCount ¬ count;    IF ((count = 0) OR (where >= pool.poolSize))       OR ((where + count > pool.poolSize) AND (~willTakeSmaller))  THEN      ERROR ObjAlloc.Error[invalidParameters];    IF (where + count > pool.poolSize) AND willTakeSmaller THEN      BEGIN      count ¬ pool.poolSize - where;      lastWord ¬ (wordStart + count + bitOffset)/Environment.bitsPerWord;      extra ¬ CARDINAL[(count + bitOffset) MOD Environment.bitsPerWord];      newCount ¬ count;      END;    [valid, firstAlloc] ¬ ValidateInterval[      a: a, firstWord: word, lastWord: lastWord, bitOffset: bitOffset,      count: count, extra: extra, allocFree: FALSE];    IF ~valid THEN newCount ¬ firstAlloc - where;    IF ((firstAlloc = where) AND (~valid))      OR ((count > newCount) AND (~willTakeSmaller)) THEN extendedBy ¬ 0    ELSE      BEGIN      IF willTakeSmaller AND (~valid) THEN {        lastWord ¬ firstAlloc/Environment.bitsPerWord;        extra ¬ CARDINAL[(firstAlloc) MOD Environment.bitsPerWord];        count ¬ newCount;        };      --mark items as allocated      MarkInterval[a, word, lastWord, bitOffset, count, extra, TRUE];      extendedBy ¬ count;      END;    END;  Free: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, interval: ObjAlloc.Interval, validate: BOOLEAN] =    BEGIN    --word align the interval by the following calculations    firstWord: ObjAlloc.ItemIndex ¬ interval.first/Environment.bitsPerWord;    wordStart: ObjAlloc.ItemIndex ¬ firstWord*Environment.bitsPerWord;      --wordStart is the index to the first bit of the firstWord    bitOffset: CARDINAL ¬ CARDINAL[interval.first - wordStart];    lastWord: ObjAlloc.ItemIndex ¬      (wordStart + interval.count + bitOffset)/Environment.bitsPerWord;    extra: CARDINAL ¬ CARDINAL[      (interval.count + bitOffset) MOD Environment.bitsPerWord];    a: LONG POINTER TO WordArray ¬ LOOPHOLE[pool.allocPool];    --check if interval is within bounds    IF pool.poolSize < interval.first + interval.count THEN      ERROR ObjAlloc.Error[invalidParameters]    ELSE      BEGIN      IF validate THEN        BEGIN        valid: BOOLEAN;        firstFree: ObjAlloc.ItemIndex;        --check to see if any items in interval are already free        [valid, firstFree] ¬ ValidateInterval[          a, firstWord, lastWord, bitOffset, interval.count, extra, TRUE];        IF ~valid THEN ERROR ObjAlloc.AlreadyFreed[firstFree];        END;      --free up interval      MarkInterval[a, firstWord, lastWord, bitOffset, interval.count, extra, FALSE];      END;    END;  InitializePool: PUBLIC PROCEDURE [    pool: ObjAlloc.AllocPoolDesc, initialState: ObjAlloc.AllocFree] =    BEGIN    --initialize array to free or alloc a word at a time(assume array begins at 0)    lastWord: ObjAlloc.ItemIndex ¬ pool.poolSize/Environment.bitsPerWord;    extra: CARDINAL ¬ CARDINAL[pool.poolSize MOD Environment.bitsPerWord];    a: LONG POINTER TO WordArray ¬ LOOPHOLE[pool.allocPool];    IF initialState = alloc THEN      MarkInterval[        a: a, firstWord: 0, lastWord: lastWord, bitOffset: 0, count: pool.poolSize,        extra: extra, allocFree: TRUE]    ELSE      MarkInterval[        a: a, firstWord: 0, lastWord: lastWord, bitOffset: 0, count: pool.poolSize,        extra: extra, allocFree: FALSE];    END;-- private procedures in amphibolical order  FindHoleBackwardInBitArray: PROCEDURE [    a: LONG POINTER TO ByteArray, bitOffset: CARDINAL, bitCount: NATURAL,     holeSize: ObjAlloc.ItemCount, carryIn: ObjAlloc.ItemCount]    RETURNS [bestOffset: LONG INTEGER, bestSize, carryOut: ObjAlloc.ItemCount] =    BEGIN        OffsetOfInnerHole:       PROCEDURE [i: CARDINAL, b: Environment.Byte, holeSize: CARDINAL]      RETURNS [offset: CARDINAL] =      BEGIN      ab: PACKED ARRAY [0..8) OF [0..1] = LOOPHOLE[b];      size: CARDINAL ¬ 0;      FOR j: CARDINAL DECREASING IN [0..bitsPerByte) DO        IF ab[j] = 0 THEN size ¬ size + 1 ELSE size ¬ 0;        IF size = holeSize THEN RETURN [i*bitsPerByte + j];        ENDLOOP;      END;    -- Finds the first hole (going backwards) of size holeSize, returning the    --   offset from the beginning of the byte array.    -- The hole is at least "bestSize" big.  If on return, bestSize < holeSize,     --   then it is the largest hole in the whole array.    -- Assume that carryIn < holeSize.    -- NOTE: this procedure assumes the bits are ordered from     --   0(msb)..15(lsb) in a word.    -- NOTE: also assume that a is at most LAST[NATURAL] bits long    -- NOTE: also assumes that range begins (lowest bit begins) on a word    --   boundary.    bitsPerByte: CARDINAL = Environment.bitsPerByte;    allOnes: Environment.Byte = 377B;    allZeroes: Environment.Byte = 0;        i: CARDINAL;    maxI: CARDINAL = (bitCount - 1) / bitsPerByte;    thisHoleSize: LONG CARDINAL;    bitsAfterI: LONG INTEGER;	    iAtStartOfInterval: CARDINAL = 0;    b: Environment.Byte;        trailingBitsToIgnore: LONG INTEGER ¬      Environment.bitsPerWord - (bitOffset + carryIn);    clearMask: ARRAY [0..Environment.bitsPerWord) OF Environment.Byte =       [377B, 200B, 300B, 340B, 360B, 370B, 374B, 376B,       377B, 200B, 300B, 340B, 360B, 370B, 374B, 376B];    bitMask: ARRAY [1..Environment.bitsPerByte] OF Environment.Byte =      [1B, 3B, 7B, 17B, 37B, 77B, 177B, 377B];          bestSize ¬ 0;    -- note that we must not use bitOffset as the argument of this SELECT    -- because in the case of bitOffset#holeSize and carryIn#0 we do not want    -- to zap the bits that might be used in the carryIn.    -- NOTE: this assumes that if bitOffset#holeSize and carryIn#0 then the     --       carryIn is contiguous with a (or at any rate, the first few bits of    --       the carryIn are).    IF (bitOffset > 0) AND (bitOffset <= Environment.bitsPerByte) THEN      trailingBitsToIgnore ¬ trailingBitsToIgnore - Environment.bitsPerByte    ELSE IF bitOffset = 0 THEN      trailingBitsToIgnore ¬ trailingBitsToIgnore - Environment.bitsPerWord;    SELECT trailingBitsToIgnore FROM      >=8     => {i ¬ maxI; b ¬ Inline.BITAND[clearMask[bitOffset], a[maxI]]};      >0      => {i ¬ maxI;                  b ¬ Inline.BITOR[bitMask[CARDINAL[trailingBitsToIgnore]],		        Inline.BITAND[clearMask[bitOffset], a[maxI]]]};      ENDCASE => {i ¬ maxI; b ¬ Inline.BITAND[clearMask[bitOffset], a[maxI]]};    -- moan - have to treat one byte arrays specially    IF i = iAtStartOfInterval THEN      BEGIN      bitsAfterI ¬ MAX [0, - trailingBitsToIgnore];  --????????      END    ELSE      BEGIN      -- NOTE that the use of bitsAfterI and the organization of the      -- loop is very carefully organized to get the case right where      -- carryIn#0 and is used for part of the hole      bitsAfterI ¬ - trailingBitsToIgnore;      WHILE i > iAtStartOfInterval DO -- and until we find hole and RETURN --            SELECT bitsAfterI FROM          = 0 =>   -- skip to find the beginning of a hole            BEGIN            WHILE a[i]=allOnes DO              i ¬ i - 1;	      IF i = iAtStartOfInterval THEN {bitsAfterI ¬ 0; GO TO ExitMainLoop}	      ENDLOOP;	    IF i # maxI THEN b ¬ a[i];	    END;	  > 0 => 	    BEGIN	    -- the next byte had some empty bits at the left hand end -	    -- so skip empty bytes until we find the beginning of this hole	    iAtEndOfHole: CARDINAL ¬ i;	    iAtStartOfHole: LONG CARDINAL ¬ 	      i + (holeSize - bitsAfterI - 1) / bitsPerByte;	    iAtStartOfHoleOrInterval: CARDINAL ¬ 	      CARDINAL[MIN[iAtStartOfHole, iAtStartOfInterval]];	    thisHoleSize: ObjAlloc.ItemCount;		    WHILE i > iAtStartOfHoleOrInterval AND a[i] = allZeroes DO 	      i ¬ i - 1 ENDLOOP;	    bitsAfterI ¬ bitsAfterI + (iAtEndOfHole - i) * bitsPerByte;  	    IF i = iAtStartOfInterval THEN GO TO ExitMainLoop;  	    b ¬ a[i];	    SELECT (thisHoleSize ¬ bitsAfterI + RightHole[b]) FROM	      >= holeSize => RETURN[((i + 1) * bitsPerByte) + bitsAfterI - holeSize, holeSize, 0];	      >  bestSize => {bestSize ¬ thisHoleSize;			      bestOffset ¬ ((i + 1) * bitsPerByte) + bitsAfterI - thisHoleSize};	    ENDCASE;	    END;	  < 0 =>  -- not necessarily in the middle of a run at all 		-- (only occurs at startup)	    NULL;	  ENDCASE;              IF bestSize < bitsPerByte  -- saves us computing MaxHole if possible        THEN          SELECT (thisHoleSize ¬ MaxHole[b])          FROM           >= holeSize =>                 RETURN[OffsetOfInnerHole[i, b, CARDINAL[holeSize]], holeSize, 0];           >  bestSize => 	        {bestSize ¬ thisHoleSize; 	         bestOffset ¬ OffsetOfInnerHole[i, b, CARDINAL[thisHoleSize]]};          ENDCASE;        bitsAfterI ¬ LeftHole[b];            i ¬ i - 1;        REPEAT ExitMainLoop => NULL;        ENDLOOP;      b ¬ a[iAtStartOfInterval];      END;    -- check for end of a hole across the byte's right hand end    SELECT (thisHoleSize ¬ bitsAfterI + RightHole[b]) FROM      >= holeSize => RETURN [((i + 1) * bitsPerByte) + bitsAfterI - holeSize, holeSize, 0];      > bestSize  => {bestSize ¬ thisHoleSize;		      bestOffset ¬ ((i + 1) * bitsPerByte) + bitsAfterI - thisHoleSize};      ENDCASE;        -- check for an embedded hole    SELECT (thisHoleSize ¬ MaxHole[b]) FROM      >= holeSize => RETURN[OffsetOfInnerHole[i, b, CARDINAL[holeSize]], holeSize, 0];      > bestSize  => {bestSize ¬ thisHoleSize;		      bestOffset ¬ OffsetOfInnerHole[i, b, CARDINAL[thisHoleSize]]};      ENDCASE;          -- and if all else fails, return the best hole we have found,    -- giving the number of beginnning bits in case the client is going    -- to carry on searching    IF b = allZeroes THEN carryOut ¬ bitsAfterI + bitsPerByte    ELSE carryOut ¬ LeftHole[b];        RETURN [bestOffset, bestSize, carryOut];    END;  FindHoleInBitArray: PROCEDURE [    a: LONG POINTER TO ByteArray, bitOffset:CARDINAL, bitCount: NATURAL,     holeSize: ObjAlloc.ItemCount, carryIn: ObjAlloc.ItemCount]    RETURNS [bestOffset: LONG INTEGER, bestSize, carryOut: ObjAlloc.ItemCount] =    BEGIN        OffsetOfInnerHole:       PROCEDURE [i:CARDINAL, b:Environment.Byte, holeSize:CARDINAL]      RETURNS [offset:CARDINAL] =      BEGIN      ab: PACKED ARRAY [0..8) OF [0..1] = LOOPHOLE[b];      size:CARDINAL ¬ 0;      j:CARDINAL;      FOR j IN [0..bitsPerByte) DO        IF ab[j] = 0 THEN size ¬ size + 1 ELSE size ¬ 0;        IF size = holeSize THEN RETURN [i*bitsPerByte + j - size + 1];         ENDLOOP;      END;    -- Finds the first hole of size holeSize, returning the offset     -- from the beginning of the byte array    -- The hole is at least "bestSize" big.  If on return, bestSize < holeSize,     -- then it is the largest hole in the whole array.    -- Assume that carryIn < holeSize    -- NOTE: this procedure assumes the bits are ordered from     -- 0(msb)..15(lsb) in a word.    -- NOTE: also assume that a is at most LAST[NATURAL] bits long    bitsPerByte: CARDINAL = Environment.bitsPerByte;    allOnes: Environment.Byte = 377B;    allZeroes: Environment.Byte = 0;        i, extra:CARDINAL;	    thisHoleSize: LONG CARDINAL;    bitsBeforeI: LONG INTEGER;	    iAtEndOfInterval:CARDINAL = (bitCount+bitOffset - 1)/bitsPerByte;    b:Environment.Byte;        leadingBitsToIgnore: LONG INTEGER ¬ bitOffset-carryIn;    bitMask: ARRAY [1..Environment.bitsPerByte] OF Environment.Byte =       [200B, 300B, 340B, 360B, 370B, 374B, 376B, 377B];          bestSize ¬ 0;    -- note that we must not use bitOffset as the argument of this SELECT    -- because in the case of bitOffset#0 and carryIn#0 we do not want    -- to zap the bits that might be used in the carryIn.    -- NOTE: this assumes that if bitOffset#0 and carryIn#0 then the carryIn    --       is contiguous with a (or at any rate, the last few bits of the     --	     carryIn are).        SELECT leadingBitsToIgnore     FROM      >8 => {i ¬ 1; b ¬ Inline.BITOR[bitMask[CARDINAL[leadingBitsToIgnore-8]], a[1]]};      =8 => {i ¬ 1; b ¬ a[1]};      >0 => {i ¬ 0; b ¬ Inline.BITOR[bitMask[CARDINAL[leadingBitsToIgnore]], a[0]]};      ENDCASE => {i ¬ 0; b ¬ a[0]};                         -- a note about the SELECT statement in the main loop:    -- Normally, bitsBeforeI will be set to RightHole[b] and so will    -- be either    --   +ve:  meaning there are empty bits at the end of the previous byte and so    --         it is worth scanning for empty bytes looking for a bigger hole    -- or  0:  meaning there are no empty bits at the end of the previous byte and    --         so it is worth scanning for full bytes looking for the beginning of    --         a new hole    -- However, in the initial condition, bitsBeforeI= carryIn-bitOffset    -- and so can be:    --   +ve:  carryIn>bitsBeforeI so we can assume there are free bits before the    --         array and so we can scan for zero bytes as above    --   -ve:  carryIn<bitOffset so the start of the area to look at begins in    --         this byte.  We must be careful NOT to use the skip ones loop    --         and drop out immediately (as we do usually when looking for a hole)    --         because b has been carefully fudged above to hide the bits we    --         mustn't consider - therefore we mustn't pick up a[i] again -    --         and so the SELECT statement allows us to drop straight through     --	       to checking this byte for embedded holes; we are then in the    --	       normal case    --     0:  carryIn=bitOffset, this is similar to the -ve case above:    --	       we are looking for the beginning of a hole. Luckily, though,    --	       because bitsBeforeI=0 and hence leadingBitsToIgnore=0 it is OK    --	       to use the =0 arm of the SELECT because  b=a[i]    -- Luckily the two cases are compatible!        IF i=iAtEndOfInterval -- moan - have to treat one byte arrays specially    THEN      BEGIN      bitsBeforeI ¬ MAX [0, - leadingBitsToIgnore]      END    ELSE      BEGIN      -- NOTE that the use of bitsBeforeI and the organisation of the      -- loop is very carefully organised to get the case right where      -- carryIn#0 and is used for part of the hole;  in this case,      -- bestOffset must end up being negative, since it always gives      -- a result relative to the first bit of the ByteArray, a.      bitsBeforeI ¬ - leadingBitsToIgnore;      WHILE i<iAtEndOfInterval  -- and until we find hole and RETURN --        DO             SELECT bitsBeforeI        FROM        = 0 =>   -- skip to find the beginning of a hole          BEGIN          WHILE a[i]=allOnes DO            i ¬ i+1;	    IF i = iAtEndOfInterval THEN {bitsBeforeI ¬ 0; GO TO ExitMainLoop}	    ENDLOOP;          b ¬ a[i]          END;        > 0 =>           BEGIN          -- the previous byte had some empty bits at the right hand end -          -- so skip empty bytes until we find the end of this hole          iAtStartOfHole:CARDINAL ¬ i;          iAtEndOfHole:LONG CARDINAL ¬ i + (holeSize-bitsBeforeI-1)/bitsPerByte;          iAtEndOfHoleOrInterval:CARDINAL ¬         		    CARDINAL[MIN[iAtEndOfHole, iAtEndOfInterval]];          thisHoleSize:ObjAlloc.ItemCount;                WHILE i<iAtEndOfHoleOrInterval AND a[i]=allZeroes DO i ¬ i+1 ENDLOOP;          bitsBeforeI ¬ bitsBeforeI + (i-iAtStartOfHole)*bitsPerByte;                IF i=iAtEndOfInterval THEN GO TO ExitMainLoop;                  b ¬ a[i];          SELECT (thisHoleSize ¬ bitsBeforeI + LeftHole[b])          FROM           >= holeSize => RETURN [i*bitsPerByte-bitsBeforeI, holeSize, 0];           >  bestSize =>                {bestSize ¬ thisHoleSize; bestOffset ¬ i*bitsPerByte-bitsBeforeI};          ENDCASE;          END;        < 0 =>  -- not necessarily in the middle of a run at all               -- (only occurs at startup)          NULL;        ENDCASE;              IF bestSize<bitsPerByte  -- saves us computing MaxHole if possible        THEN          SELECT (thisHoleSize ¬ MaxHole[b])          FROM           >= holeSize =>                 RETURN [OffsetOfInnerHole[i, b, CARDINAL[holeSize]], holeSize, 0];           >  bestSize => 	        {bestSize ¬ thisHoleSize; 	         bestOffset ¬ OffsetOfInnerHole[i, b, CARDINAL[thisHoleSize]]};          ENDCASE;        bitsBeforeI ¬ RightHole[b];            i ¬ i+1;        REPEAT ExitMainLoop => NULL;        ENDLOOP;      b ¬ a[iAtEndOfInterval];      END;                      -- the end game ...    -- we have reached the last byte, which must be treated specially    -- because not all bits in it might be for us to look at.    -- Unfortunately, this is rarely the case, but it is not worth the    -- extra test in the main loop above, so some code is duplicated here.        -- flatten bits that are not for use    extra ¬ 1 + (bitCount+bitOffset-1) MOD 8;    b ¬ Inline.BITOR[Inline.BITSHIFT[377B, -extra], b];        -- check for end of a hole across the byte's left hand end    SELECT (thisHoleSize ¬ bitsBeforeI + LeftHole[b])    FROM     >= holeSize => RETURN [i*bitsPerByte-bitsBeforeI, holeSize, 0];     >  bestSize => 	 {bestSize ¬ thisHoleSize; bestOffset ¬ i*bitsPerByte-bitsBeforeI};    ENDCASE;        -- check for an embedded hole    SELECT (thisHoleSize ¬ MaxHole[b])    FROM     >= holeSize =>           RETURN [OffsetOfInnerHole[i, b, CARDINAL[holeSize]], holeSize, 0];     >  bestSize => 	  {bestSize ¬ thisHoleSize; 	   bestOffset ¬ OffsetOfInnerHole[i, b, CARDINAL[thisHoleSize]]};    ENDCASE;        -- and if all else fails, return the best hole we have found,    -- giving the number of trailing empty bits in case the client is going    -- to carry on searching    IF LeftHole[b]=extra    THEN carryOut ¬ bitsBeforeI + extra    ELSE carryOut ¬ RightHole[Inline.BITSHIFT[b, -(bitsPerByte-extra)]];        RETURN [bestOffset, bestSize, carryOut];    END;              MaskEdgesAndMarkMiddle: PROCEDURE [    leftEdgeAmtToMask, rtEdgeAmtToMask: CARDINAL, word: Environment.Word,     allocFree: BOOLEAN] RETURNS [Environment.Word] =         BEGIN    mask: Environment.Word ¬         Inline.BITSHIFT[Inline.BITSHIFT[-1, -(leftEdgeAmtToMask + rtEdgeAmtToMask)], rtEdgeAmtToMask];    IF allocFree THEN       RETURN [Inline.BITOR[mask, word]]    ELSE RETURN [Inline.BITAND[Inline.BITNOT[mask], word]];    END;  MarkInterval: PROCEDURE [    a: LONG POINTER TO WordArray, firstWord: ObjAlloc.ItemIndex,    lastWord: ObjAlloc.ItemIndex, bitOffset: CARDINAL,     count: ObjAlloc.ItemCount, extra: CARDINAL, allocFree: BOOLEAN] =    BEGIN    --mark the interval word by word starting from the firstWord to the lastWord,    --masking out preceding and trailing bits determined by bitOffset and extra.    --If allocFree is TRUE mark interval as allocated, otherwise mark as free    i: CARDINAL ¬ CARDINAL[firstWord];    IF lastWord = firstWord THEN      BEGIN      shift: CARDINAL ¬ CARDINAL[        Environment.bitsPerWord - count - bitOffset];      a[i] ¬ MaskEdgesAndMarkMiddle[bitOffset, shift, a[i], allocFree];      END    ELSE      BEGIN      IF bitOffset # 0 THEN {        a[i] ¬ MaskEdgesAndMarkMiddle[bitOffset, 0, a[i], allocFree];        i ¬ i + 1 };      IF i # CARDINAL[lastWord] THEN {        a[i] ¬ IF allocFree THEN allOnes ELSE allZeros;        Inline.LongCOPY[          from: @a[i], nwords: CARDINAL[lastWord - i] - 1, to: @a[i + 1]];        };      IF extra # 0 THEN {        i ¬ CARDINAL[lastWord];        a[i] ¬ MaskEdgesAndMarkMiddle[0, (Environment.bitsPerWord - extra), a[i], allocFree] };      END;    END;    ValidateInterval: PROCEDURE [    a: LONG POINTER TO WordArray, firstWord: ObjAlloc.ItemIndex,    lastWord: ObjAlloc.ItemIndex, bitOffset: CARDINAL,    count: ObjAlloc.ItemCount, extra: CARDINAL, allocFree: BOOLEAN]     RETURNS [valid: BOOLEAN, firstFree: ObjAlloc.ItemIndex] =    BEGIN    --checks to see if all items in the specified interval are allocated (or free)    --if not, the first free (allocated) item is returned, and a flag valid is set to false    --all checking is done by picking up a word at a time    i: CARDINAL ¬ CARDINAL[firstWord];    tempWord: Environment.Word;    testByte: Environment.Byte;    offset: CARDINAL;    allOnesOrAllZeros: CARDINAL ¬ IF allocFree THEN allOnes ELSE allZeros;    valid ¬ TRUE;    firstFree ¬ 0;    IF firstWord = lastWord THEN {      -- mask out any items not in interval       shift: CARDINAL ¬ CARDINAL[Environment.bitsPerWord - bitOffset - count];      mask: Environment.Word ¬ Inline.BITSHIFT[Inline.BITSHIFT[-1, -(bitOffset + shift)], shift];      tempWord ¬         IF allocFree THEN 	  Inline.BITOR[Inline.BITNOT[mask], a[i]]	ELSE Inline.BITAND[mask, a[i]];      IF tempWord # allOnesOrAllZeros THEN valid ¬ FALSE }    ELSE      BEGIN      IF bitOffset # 0 THEN {        --mask out leading items of a word not in interval           tempWord ¬ MaskEdgesAndMarkMiddle[0, (Environment.bitsPerWord - bitOffset), a[i], allocFree];        IF tempWord # allOnesOrAllZeros THEN valid ¬ FALSE ELSE i ¬ i + 1 };      UNTIL (i >= lastWord) OR ~valid DO        --look at a word at a time (no need to mask)        IF a[i] # allOnesOrAllZeros THEN {valid ¬ FALSE; tempWord ¬ a[i]}	ELSE i ¬ i + 1;        ENDLOOP;      IF (extra # 0) AND valid THEN {        --mask items following the interval but contained in the lastword        tempWord ¬ MaskEdgesAndMarkMiddle[extra, 0, a[i], allocFree];        IF tempWord # allOnesOrAllZeros THEN valid ¬ FALSE };      END;    IF ~valid THEN      BEGIN      --use Lefthole, by complementing the word, and then detecting where the first      --allocated (free) item is.      --to use this, a byte must be picked up at a time      IF allocFree THEN tempWord ¬ Inline.BITNOT[tempWord];      testByte ¬ Inline.HighByte[tempWord];      offset ¬ LeftHole[testByte];      IF offset = Environment.bitsPerByte THEN {        testByte ¬ Inline.LowByte[tempWord];        offset ¬ LeftHole[testByte] + Environment.bitsPerByte };      firstFree ¬ (i*Environment.bitsPerWord) + offset;      END;    END;  MaxHole: PACKED ARRAY [0..256) OF [0..8] = [    8, 7, 6, 6, 5, 5, 5, 5,  -- 0..7    4, 4, 4, 4, 4, 4, 4, 4,  -- 10B..17B    4, 3, 3, 3, 3, 3, 3, 3,  -- 20B..27B    3, 3, 3, 3, 3, 3, 3, 3,  -- 30B..37B    5, 4, 3, 3, 2, 2, 2, 2,  -- 40B..47B    3, 2, 2, 2, 2, 2, 2, 2,  -- 50B..57B    4, 3, 2, 2, 2, 2, 2, 2,  -- 60B..67B    3, 2, 2, 2, 2, 2, 2, 2,  -- 70B..77B    6, 5, 4, 4, 3, 3, 3, 3,  -- 100B..107B    3, 2, 2, 2, 2, 2, 2, 2,  -- 110B..117B    4, 3, 2, 2, 2, 1, 1, 1,  -- 120B..127B    3, 2, 1, 1, 2, 1, 1, 1,  -- 130B..137B    5, 4, 3, 3, 2, 2, 2, 2,  -- 140B..147B    3, 2, 1, 1, 2, 1, 1, 1,  -- 150B..157B    4, 3, 2, 2, 2, 1, 1, 1,  -- 160B..167B    3, 2, 1, 1, 2, 1, 1, 1,  -- 170B..177B    7, 6, 5, 5, 4, 4, 4, 4,  -- 200B..207B    3, 3, 3, 3, 3, 3, 3, 3,  -- 210B..217B    4, 3, 2, 2, 2, 2, 2, 2,  -- 220B..227B    3, 2, 2, 2, 2, 2, 2, 2,  -- 230B..237B    5, 4, 3, 3, 2, 2, 2, 2,  -- 240B..247B    3, 2, 1, 1, 2, 1, 1, 1,  -- 250B..257B    4, 3, 2, 2, 2, 1, 1, 1,  -- 260B..267B    3, 2, 1, 1, 2, 1, 1, 1,  -- 270B..277B    6, 5, 4, 4, 3, 3, 3, 3,  -- 300B..307B    3, 2, 2, 2, 2, 2, 2, 2,  -- 310B..317B    4, 3, 2, 2, 2, 1, 1, 1,  -- 320B..327B    3, 2, 1, 1, 2, 1, 1, 1,  -- 330B..337B    5, 4, 3, 3, 2, 2, 2, 2,  -- 340B..347B    3, 2, 1, 1, 2, 1, 1, 1,  -- 350B..357B    4, 3, 2, 2, 2, 1, 1, 1,  -- 360B..367B    3, 2, 1, 1, 2, 1, 1, 0];  -- 370B..377B  LeftHole: PACKED ARRAY [0..256) OF [0..8] = [    8, 7, 6, 6, 5, 5, 5, 5,  -- 0..7    4, 4, 4, 4, 4, 4, 4, 4,  -- 10B..17B    3, 3, 3, 3, 3, 3, 3, 3,  -- 20B..27B    3, 3, 3, 3, 3, 3, 3, 3,  -- 30B..37B    2, 2, 2, 2, 2, 2, 2, 2,  -- 40B..47B    2, 2, 2, 2, 2, 2, 2, 2,  -- 50B..57B    2, 2, 2, 2, 2, 2, 2, 2,  -- 60B..67B    2, 2, 2, 2, 2, 2, 2, 2,  -- 70B..77B    1, 1, 1, 1, 1, 1, 1, 1,  -- 100B..107B    1, 1, 1, 1, 1, 1, 1, 1,  -- 110B..117B    1, 1, 1, 1, 1, 1, 1, 1,  -- 120B..127B    1, 1, 1, 1, 1, 1, 1, 1,  -- 130B..137B    1, 1, 1, 1, 1, 1, 1, 1,  -- 140B..147B    1, 1, 1, 1, 1, 1, 1, 1,  -- 150B..157B    1, 1, 1, 1, 1, 1, 1, 1,  -- 160B..167B    1, 1, 1, 1, 1, 1, 1, 1,  -- 170B..177B    0, 0, 0, 0, 0, 0, 0, 0,  -- 200B..207B    0, 0, 0, 0, 0, 0, 0, 0,  -- 210B..217B    0, 0, 0, 0, 0, 0, 0, 0,  -- 220B..227B    0, 0, 0, 0, 0, 0, 0, 0,  -- 230B..237B    0, 0, 0, 0, 0, 0, 0, 0,  -- 240B..247B    0, 0, 0, 0, 0, 0, 0, 0,  -- 250B..257B    0, 0, 0, 0, 0, 0, 0, 0,  -- 260B..267B    0, 0, 0, 0, 0, 0, 0, 0,  -- 270B..277B    0, 0, 0, 0, 0, 0, 0, 0,  -- 300B..307B    0, 0, 0, 0, 0, 0, 0, 0,  -- 310B..317B    0, 0, 0, 0, 0, 0, 0, 0,  -- 320B..327B    0, 0, 0, 0, 0, 0, 0, 0,  -- 330B..337B    0, 0, 0, 0, 0, 0, 0, 0,  -- 340B..347B    0, 0, 0, 0, 0, 0, 0, 0,  -- 350B..357B    0, 0, 0, 0, 0, 0, 0, 0,  -- 360B..367B    0, 0, 0, 0, 0, 0, 0, 0];  -- 370B..377B  RightHole: PACKED ARRAY [0..256) OF [0..8] = [    8, 0, 1, 0, 2, 0, 1, 0,  -- 0..7    3, 0, 1, 0, 2, 0, 1, 0,  -- 10B..17B    4, 0, 1, 0, 2, 0, 1, 0,  -- 20B..27B    3, 0, 1, 0, 2, 0, 1, 0,  -- 30B..37B    5, 0, 1, 0, 2, 0, 1, 0,  -- 40B..47B    3, 0, 1, 0, 2, 0, 1, 0,  -- 50B..57B    4, 0, 1, 0, 2, 0, 1, 0,  -- 60B..67B    3, 0, 1, 0, 2, 0, 1, 0,  -- 70B..77B    6, 0, 1, 0, 2, 0, 1, 0,  -- 100B..107B    3, 0, 1, 0, 2, 0, 1, 0,  -- 110B..117B    4, 0, 1, 0, 2, 0, 1, 0,  -- 120B..127B    3, 0, 1, 0, 2, 0, 1, 0,  -- 130B..137B    5, 0, 1, 0, 2, 0, 1, 0,  -- 140B..147B    3, 0, 1, 0, 2, 0, 1, 0,  -- 150B..157B    4, 0, 1, 0, 2, 0, 1, 0,  -- 160B..167B    3, 0, 1, 0, 2, 0, 1, 0,  -- 170B..177B    7, 0, 1, 0, 2, 0, 1, 0,  -- 200B..207B    3, 0, 1, 0, 2, 0, 1, 0,  -- 210B..217B    4, 0, 1, 0, 2, 0, 1, 0,  -- 220B..227B    3, 0, 1, 0, 2, 0, 1, 0,  -- 230B..237B    5, 0, 1, 0, 2, 0, 1, 0,  -- 240B..247B    3, 0, 1, 0, 2, 0, 1, 0,  -- 250B..257B    4, 0, 1, 0, 2, 0, 1, 0,  -- 260B..267B    3, 0, 1, 0, 2, 0, 1, 0,  -- 270B..277B    6, 0, 1, 0, 2, 0, 1, 0,  -- 300B..307B    3, 0, 1, 0, 2, 0, 1, 0,  -- 310B..317B    4, 0, 1, 0, 2, 0, 1, 0,  -- 320B..327B    3, 0, 1, 0, 2, 0, 1, 0,  -- 330B..337B    5, 0, 1, 0, 2, 0, 1, 0,  -- 340B..347B    3, 0, 1, 0, 2, 0, 1, 0,  -- 350B..357B    4, 0, 1, 0, 2, 0, 1, 0,  -- 360B..367B    3, 0, 1, 0, 2, 0, 1, 0];  -- 370B..377B  END.           LOG   8-Oct-82 10:45:38 	EKN   	Created File (The procedures FindFreeRange and FindHoleInBitArray are modified	versions of the same procedures in VolAllocMapImpl of the 8.0 release)18-Mar-83 16:33:23	JXG                  	Altered FindFreeRange to have offset parameter	Added procedure AllSameState12-May-83 18:12:36	JXG    	corrected initialisation inside FindHoleInBitArray and fixed bug causing fragmentation of bit arrays; also check holeOffset better in FindFreeRange16-May-83 13:39:36	JXG    	complete rewrite of FindHoleInBitArray19-May-83 13:42:35	JXG    	minor twiddles in FindHoleInBitArray;  lots of comments added,	procedures sorted into public and private sections, 	each in alphabetical order20-May-83 16:04:05	JXG    	bug fix in FindHoleInBitArray - stop i running of end of arrary23-May-83 19:49:23	JXG    	Make FindHoleInBitArray work for very small arrays. 26-May-83 13:45:29	EKN   	Combined MarkAllocated and MarkFree to form MarkInterval.  Combined ValidateAlloc and ValidateFree to form ValidateInterval.  Created MaskEdgesAndMarkInterval with the leftovers. Replaced Inline.LowHalf uses with CARDINAL types. 7-Dec-83 13:28:22	EKN    	Changed MaskEdgesAndMarkMiddle[-(Environment.bitsPerWord - bitOffset), 0, a[i], allocFree] to MaskEdgesAndMarkMiddle[0, (Environment.bitsPerWord - bitOffset), a[i], allocFree].  Not a bug, just a modularity problem.12-May-86 17:29:10      RSV        Changed ExpandAllocation determination of lastWord when program must take a smaller allocation.12-Sep-88 11:29:23      RSV        Added FindBackwardFreeRange and FindHoleBackwardInBitArray to search backwards in a pool. 2-Nov-88 16:15:56      RSV        Fixed calculation of chunkSize in FindBackwardFreeRange.
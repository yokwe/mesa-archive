-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- LogFileImpl.mesa (last edited by: EKN    on: 23-Sep-83 10:57:44)<< This code has been fixed so that reading procedures don't read when Reset is being done.  But this means every procedure is an entry procedure, so only one read procedure can be done at a time.  Hmmmm. >>DIRECTORY  File USING [File, GetSize, PageNumber],  Log USING [Index, Level, nullIndex],  LogFile USING [],  LogInternal USING [    commonLength, Entry, Header, Restart, startIndex, Type, versionNo],  System USING [GreenwichMeanTime],  Space USING [Access, GetMapUnitAttributes, MakeWritable, Map, Unmap, PageCount];LogFileImpl: MONITOR  IMPORTS File, Space EXPORTS LogFile =  BEGIN  -- ERRORs  DifferentType: PUBLIC ERROR = CODE;  IllegalEnumerate: PUBLIC ERROR = CODE;  InvalidFile: PUBLIC ERROR = CODE;  Inconsistent: PUBLIC ERROR = CODE;  -- PUBLIC PROCEDUREs  GetAttributes: PUBLIC ENTRY PROCEDURE [    file: File.File, current: Log.Index, firstPageNumber: File.PageNumber]    RETURNS [      time: System.GreenwichMeanTime, type: LogInternal.Type, level: Log.Level,      size: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    logPointer: LONG POINTER ¬ MapWholeLog[file, firstPageNumber];    pHeader: LONG POINTER TO LogInternal.Header ¬ logPointer;    pEntry: LONG POINTER TO LogInternal.Entry ¬ LOOPHOLE[pHeader + current];       time ¬ pEntry.time;    type ¬ pEntry.type;    level ¬ pEntry.level;    size ¬ pEntry.length;    logPointer ¬ Space.Unmap[logPointer];    END;  GetBlock: PUBLIC ENTRY PROCEDURE [    file: File.File, current: Log.Index, place: LONG POINTER,    firstPageNumber: File.PageNumber] =    BEGIN ENABLE UNWIND => NULL;    entryPointer: LONG POINTER TO UNSPECIFIED;    rep, cntbody: CARDINAL;    logPointer: LONG POINTER ¬ MapWholeLog[file, firstPageNumber];    pHeader: LONG POINTER TO LogInternal.Header ¬ logPointer;    pEntry: LONG POINTER TO LogInternal.Entry ¬ LOOPHOLE[pHeader + current];        IF pEntry.type # block THEN RETURN WITH ERROR DifferentType;    entryPointer ¬ LOOPHOLE[pHeader + current + LogInternal.commonLength];    cntbody ¬ current + LogInternal.commonLength;    FOR rep IN [0..pEntry.length) DO      IF cntbody > pHeader.end THEN {        cntbody ¬ LogInternal.startIndex;        entryPointer ¬ LOOPHOLE[pHeader + LogInternal.startIndex];        };      place­ ¬ entryPointer­;      place ¬ place + 1;      entryPointer ¬ entryPointer + 1;      cntbody ¬ cntbody + 1;      ENDLOOP;    logPointer ¬ Space.Unmap[logPointer];    END;  GetCount: PUBLIC ENTRY PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber]    RETURNS [count: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    logPointer: LONG POINTER ¬ MapHeader[file, firstPageNumber];    count ¬ LOOPHOLE[logPointer, LONG POINTER TO LogInternal.Header].count;    logPointer ¬ Space.Unmap[logPointer];    END;  GetLost: PUBLIC ENTRY PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber]    RETURNS [lost: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    logPointer: LONG POINTER ¬ MapHeader[file, firstPageNumber];    lost ¬ LOOPHOLE[logPointer, LONG POINTER TO LogInternal.Header].lost;    logPointer ¬ Space.Unmap[logPointer];    END;  GetNext: PUBLIC ENTRY PROCEDURE [    file: File.File, current: Log.Index, firstPageNumber: File.PageNumber]    RETURNS [next: Log.Index] =    BEGIN ENABLE UNWIND => NULL;    headersize: CARDINAL = LogInternal.startIndex - 1;    logPointer: LONG POINTER ¬ MapWholeLog[file, firstPageNumber];    pHeader: LONG POINTER TO LogInternal.Header ¬ logPointer;    pEntry: LONG POINTER TO LogInternal.Entry;        IF current = pHeader.last OR pHeader.count = 0 THEN {      next ¬ Log.nullIndex;      logPointer ¬ Space.Unmap[logPointer];      RETURN;      };    IF current = Log.nullIndex THEN next ¬ pHeader.first    ELSE      BEGIN      pEntry ¬ LOOPHOLE[pHeader + current];      next ¬ current + pEntry.length + LogInternal.commonLength;      IF next > pHeader.end THEN next ¬ next - pHeader.end + headersize      ELSE        IF pHeader.end - next + 1 < LogInternal.commonLength THEN          next ¬ LogInternal.startIndex;      END;    pEntry ¬ LOOPHOLE[pHeader + next];    IF pEntry.index # next THEN {      logPointer ¬ Space.Unmap[logPointer]; RETURN WITH ERROR Inconsistent; };    logPointer ¬ Space.Unmap[logPointer];    END;  GetRestart: PUBLIC ENTRY PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber]    RETURNS [restart: LogInternal.Restart] =    BEGIN ENABLE UNWIND => NULL;    logPointer: LONG POINTER ¬ MapHeader[file, firstPageNumber];    restart ¬ LOOPHOLE[logPointer, LONG POINTER TO LogInternal.Header].restart;    logPointer ¬ Space.Unmap[logPointer];    END;  GetString: PUBLIC ENTRY PROCEDURE [    file: File.File, current: Log.Index, place: LONG STRING,    firstPageNumber: File.PageNumber] =    BEGIN ENABLE UNWIND => NULL;    entryPointer: LONG POINTER TO UNSPECIFIED;    rep, cntbody: CARDINAL;    logPointer: LONG POINTER ¬ MapWholeLog[file, firstPageNumber];    pHeader: LONG POINTER TO LogInternal.Header ¬ logPointer;    pEntry: LONG POINTER TO LogInternal.Entry ¬ LOOPHOLE[pHeader + current];    entryPointer ¬ LOOPHOLE[pHeader + current + LogInternal.commonLength];        IF pEntry.type # string THEN RETURN WITH ERROR DifferentType;    cntbody ¬ current + LogInternal.commonLength;    FOR rep IN [0..pEntry.length) DO      IF cntbody > pHeader.end THEN {        cntbody ¬ LogInternal.startIndex;        entryPointer ¬ LOOPHOLE[pHeader + LogInternal.startIndex];        };      place[rep] ¬ entryPointer­;      entryPointer ¬ entryPointer + 1;      cntbody ¬ cntbody + 1;      ENDLOOP;    place.length ¬ pEntry.length;    logPointer ¬ Space.Unmap[logPointer];    END;  Reset: PUBLIC ENTRY PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber] =    BEGIN ENABLE UNWIND => NULL;    logPointer: LONG POINTER ¬ MapHeader[file, firstPageNumber];    pHeader: LONG POINTER TO LogInternal.Header ¬ logPointer;    Space.MakeWritable[Space.GetMapUnitAttributes[logPointer].interval];        pHeader.count ¬ pHeader.lost ¬ 0;    pHeader.next ¬ pHeader.curIndex ¬ LogInternal.startIndex;    pHeader.first ¬ pHeader.last ¬ Log.nullIndex;    pHeader.state ¬ error;    pHeader.overflowAction ¬ wrap;    pHeader.overflowed ¬ FALSE;    logPointer ¬ Space.Unmap[logPointer];    END;  -- SetRestart: PUBLIC ENTRY PROCEDURE[file: File.File, message: Log.RestartMessage] =  -- BEGIN ENABLE UNWIND => NULL;  -- logPointer: LONG POINTER ¬ MapHeader[file];  -- pHeader: LONG POINTER TO LogInternal.Header ¬ logPointer;  -- pHeader.restart ¬ [message: message, time: System.GetGreenwichMeanTime[]];  -- logPointer ¬ Space.Unmap[logPointer];  -- END;  -- PRIVATE PROCEDUREs  MapHeader: INTERNAL PROCEDURE [file: File.File, firstPageNumber: File.PageNumber] RETURNS [logPointer: LONG POINTER] =    BEGIN    access: Space.Access ¬ readOnly;    pHeader: LONG POINTER TO LogInternal.Header;    -- IF file = Log.logCap THEN ERROR IllegalEnumerate;    logPointer ¬ Space.Map[window: [file, firstPageNumber, 1], access: access].pointer;    pHeader ¬ logPointer;    IF pHeader.version # LogInternal.versionNo THEN {      logPointer ¬ Space.Unmap[logPointer]; ERROR InvalidFile; };    END;  MapWholeLog: INTERNAL PROCEDURE [    file: File.File, firstPageNumber: File.PageNumber] RETURNS [logPointer: LONG POINTER] =    BEGIN    access: Space.Access ¬ readOnly;    pHeader: LONG POINTER TO LogInternal.Header;    logSize: Space.PageCount;    maxLogSize: Space.PageCount = 256;        -- IF file = Log.logCap THEN ERROR IllegalEnumerate;    IF File.GetSize[file] > maxLogSize THEN logSize ¬ maxLogSize    ELSE logSize ¬ File.GetSize[file];    logPointer ¬ Space.Map[window: [file, firstPageNumber, logSize - firstPageNumber], access: access].pointer;    pHeader ¬ logPointer;    IF pHeader.version # LogInternal.versionNo THEN {      logPointer ¬ Space.Unmap[logPointer]; ERROR InvalidFile; };    END;  END.LOGTime: October 8, 1980  4:07 PM	By: SXY   	Action: Created fileTime: November 11, 1980  9:30 AM	By: SXY    Action: Added a returned value ErrorType to GetNextTime: November 18, 1980  3:33 PM	By: SXY    Action: Removed a returned value ErrorType from GetNext, the first page of a log file is not used anymore, LogInternal is includedTime: November 26, 1980  11:31 AM	By: SXY    Action: Added first page parameter to every procedure, Log.Restart and Log.Type are replaced by LogInternal.Restart and LogInternal.Type are replaced by LogInternal.Restart and LogInternal.TypeTime: 27-Jul-81 12:04:18	By: SXY    Action: Bug fix in GetString: set place.length to the length of the logged stringTime: 20-Aug-81 17:19:09	By: SXY    Action: logCap is not imported anymore, related check code is commented outTime:  5-Feb-82 10:35:34	By: LXR     Action: make POINTER and STRING long, remove backstopvolume codeTime: 20-Apr-83 14:38:13	By: EKN     Action: Update To KlamathTime: 23-Sep-83 10:57:54	By: EKN     Action: Make Space.Map intervals in MapHeader and MapWholeLog readOnly.  Fix up structure of program, by getting rid of all those global variables and monitorizing everything to synchoronize the writing (Reset) with all the rest of the procedures.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- VMDriver and ResMemMgr>VMData.mesa       8-Oct-84 16:09:16 by EKN  <<This interface provides access to the VM data base. Operations are provided for operating both on Map Units and on Swap Units.An operation is also provided for allocating main storage from the reserved real memory pool.Additionally, some VM operations which require no I/O are implemented within the VMData monitor.This interface is a private interface for use only within the VirtualMemory and ResidentMemory configurations.Each process calling into this interface MUST have a reserved state vector.Implementation notes:Some VMData procedures are involved in recovering from the frame heap becoming exhausted.  Because of this, invoking these procedures must not cause any frame allocations.  This means that these procedures (and any that they call) must be INLINEs or coroutines.  Since there is no such thing as an ENTRY coroutine, it must be simulated by an ENTRY INLINE procedure (which acquires the monitor lock) which itself calls the coroutine.  To have an ENTRY INLINE PROCEDURE, the monitor lock must be available in the DEFINITIONS module.  To allow a coroutine to be called as a public procedure, the procedure descriptor must be bundled into a record to force it to be a procedure variable.>>DIRECTORY  BackingStore USING [Data, TransferProc],  Environment USING [PageCount, PageNumber],  Space USING [Access, Class, Life, SwapUnitOption, Usage],  VM USING [BackingStoreRuns, Interval, Swappability];VMData: DEFINITIONS LOCKS vmDataLock =  BEGIN  -- OPERATIONS ON MAP UNITS:  CreateMapUnit: PROCEDURE [mapParams: POINTER TO READONLY MapParams]    RETURNS [paramsSwapStatus: ParamsSwapStatus];  <<  Creates the data structures which represent a map unit. Does not  allocate storage for data map units.    See VMFunSpec on VM.Map for bulk of client semantics. The swap units  are created with initial swappability = swappable.    If mapParams.access = readOnly, any real pages that are in  mapParams.interval will be added to the reserved memory tally.     Note that transferProc and/or backingStoreRuns may be NIL.    If any of the of the required items of backingStoreRuns­ or  swapUnits.sizes­ are not swapped in, returns $parametersNotSwappedIn; the  client should touch all of these items and try again.    If interval.count = 0, the debugger is called.    If backingStoreRuns is not NIL and the sum of the counts of the  elements of backingStoreRuns is less than interval.count,  the debugger is called.    If interval overlaps any other map unit, the debugger is called.    If swapUnits.swapUnitType=irregular and the sum of all of the elements  of swapUnits.sizes is less than interval.count, the debugger is called.    All pages of interval MUST be contained within the vm implemented  by the processor.>>  MapParams: TYPE = RECORD [    interval: VM.Interval, transferProc: BackingStore.TransferProc,    backingStoreRuns: VM.BackingStoreRuns, usage: Space.Usage, class: Space.Class,    access: Space.Access, swapUnits: Space.SwapUnitOption,    initialLife: Space.Life];  ParamsSwapStatus: TYPE = {ok, parametersNotSwappedIn};  RelocateMapUnit: PROCEDURE [    from: Environment.PageNumber, to: Environment.PageNumber];  -- Same semantics as VM.Relocate.  -- Caller must have state vector guarded.  DeleteMapUnit: PROCEDURE [page: Environment.PageNumber] RETURNS [notMapped: BOOLEAN];  <<  Deletes the data structures which represent a map unit.  If "page" is not contained in a map unit, returns notMapped=TRUE.  The caller is expected to have all swap units of the map unit checked out.  page" must be contained within the vm implemented by the processor.>>  -- OPERATIONS ON SWAP UNITS:  CheckInSwapUnits: PROCEDURE [    pResult: POINTER TO VMData.CheckOutData, changeInterval: VM.Interval,    newState: NewState ¬ noStateChange, pageReadIn: BOOLEAN ¬ FALSE];  <<  parameters used in pResult­ are intervalCheckedOut.    Checks in all swap units of interval, terminating caller's  exclusive access to them and making sure that any reserved memory   reclaimed from within them is added back into the pool count.    interval must begin and end on a swap unit boundary.    (If interval.count=0, does nothing. Thus {CheckOut; CheckIn} is always fine,  even if the CheckOut actually checked out no swap units.)    Sets the state, as specified, of all swap units which are wholly or partially  contained in changeInterval. (If changeInterval.count=0, does nothing.)    pageReadIn is FALSE if no contained page has been read into real memory yet.  pageReadIn is TRUE if a page has been read in (by IOTransfer or ReadDead).    changeInterval must be wholly contained within interval.    If interval is not entirely contained within a single Run, the debugger is called.>>  NewAccess: TYPE = RECORD [    SELECT action: * FROM    unchanged => [], setTo => [access: Space.Access], ENDCASE];  NewLife: TYPE = RECORD [    SELECT action: * FROM unchanged => [], setTo => [life: Space.Life], ENDCASE];  NewSwappability: TYPE = RECORD [    SELECT action: * FROM    unchanged => [], setTo => [swappability: VM.Swappability], ENDCASE];  NewState: TYPE = RECORD [    newAccess: VMData.NewAccess ¬ [unchanged[]] | NULL,    newLife: VMData.NewLife ¬ [unchanged[]] | NULL,    newSwappability: VMData.NewSwappability ¬ [unchanged[]] | NULL];  noStateChange: NewState = [[unchanged[]], [unchanged[]], [unchanged[]]];  CheckOutSwapUnits: PROCEDURE [    pResult: POINTER TO CheckOutData, interval: VM.Interval];  <<  The results of this procedure are returned in pResult­.    First, selects a Run, as follows: Select the Run  which includes interval.page; if no Run includes interval.page,  select the first Run in interval; if none, returns intervalCheckedOut =  VM.nullInterval = [0,0] (and no swap units are checked out).    Checks out the first swap unit of the run selected and all  succeeding swap units which are (1) wholly or partially contained  in interval, and (2) have the same access, data state, and swappability  as the first swap unit. The returned intervalCheckedOut is the interval  that those swap units compose. The returned activeInterval  is those pages of the checked out swap units which are also in "interval".  Also returns summary data on all of the swap units checked out.    Note that intervalCheckedOut may start before interval  and may end after interval.    If interval.count=0, returns with intervalCheckedOut.count=0.    If a Run is selected (intervalCheckedOut.count>0), the starting  vm page of the Run, the backing storage data, and the backing storage  transfer proc are returned in pageRun, backingData, and transferProc.    When checked out, the client has exclusive access to the swap units.    Note that this access lock only provides exclusive access  to VM's data which describes the swap unit, and gives the lock owner  the exclusive permission to perform software manipulations  on the page map entries of the swap unit's pages; it does not provide  exclusive access to the contents of the described pages  or their page map flags because client processes and microcode  may access their data at any time; thus clients may asynchronously  modify the data and page map flags of a checked-out page  by referencing or writing into the page. Exclusive access  to the contents of the client pages and page map flags  of a swap unit may be obtained either by temporarily  relocating the client pages to some other address in memory.    activeIntervalEnd is a redundant result which is the first page  following activeInterval. It is always equal to  activeInterval.page+activeInterval.count. It is provided  for the convenience of the caller.    All pages of interval MUST be contained within the vm implemented by the processor.>>  CheckOutData: TYPE = RECORD [    activeInterval: VM.Interval,    activeIntervalEnd: Environment.PageNumber,    intervalCheckedOut: VM.Interval,    state: State,    processType: ProcessType,    pageRun: Environment.PageNumber,  -- starting vm page of Run which includes intervalCheckedOut.    backingData: BackingStore.Data,  -- backing data for Run.    transferProc: BackingStore.TransferProc];  -- transfer proc for Run.      State: TYPE = RECORD [    access: Space.Access,    life: Space.Life,    swappability: VM.Swappability];      ProcessType: TYPE = {client, helper};  FindDirtyUnreferenced: PROCEDURE [    pResult: POINTER TO CheckOutData, freeNeeded: Environment.PageCount];  <<  The results of this procedure are returned in pResult­.    The purpose of this routine is to make freeNeeded pages  of real memory available to the real memory manager.    This procedure either    (1) finds freeNeeded not-recently-referenced clean    swapped-in swappable pages, reclaims their real memory    and returns intervalCheckedOut.count=0; in this case,    the other fields of pResult­ are unspecified.  or    (2) finds and returns activeInterval = a dirty    not-recently-referenced swapped-in swappable interval    of a Run. The swap units which contain activeInterval    "intervalCheckedOut" are checked out. The fields access,    life, and swappability of pResult­ are unspecified.    The caller should swap activeInterval out, and check intervalCheckedOut    in. activeInterval.count must not exceed LAST[VMPerf.BatchCount].      If intervalCheckedOut.count>0, the entire amount of  requested free memory may not have been made available.    This is for use by the SwapOutProcess. The heart of the  SwapOutProcess logic is entirely within this procedure.>>  -- MAIN STORAGE OPERATIONS:  AllocateReservedMStore: ENTRY PROCEDURE [interval: VM.Interval, resident: BOOLEAN] = INLINE    BEGIN AllocateReservedMStoreInternal[interval, resident] END;  <<  Allocates and maps real memory to all of the specified interval.  Memory is obtained from the reserved real memory pool if necessary.  The pages are marked clean, unreferenced, and writable.  The memory allocated is counted as ordinary memory.  If any page of the interval is mapped at entry, the debugger is called.  This operation allocates without performing any local frame allocations  and without writing anything out. It is for use only by code which  is not allowed to allocate main store in the normal way (e.g. code  involved in allocating local frames, VM helper processes).  All pages of interval must be contained within the vm  implemented by the processor.>>  -- PERF DATA:    swapOutPagesReclaimed: LONG CARDINAL;  -- writable copy of same item in VMPerf.  --~~~~~~~~~~~~~~~ PRIVATE ITEMS: ~~~~~~~~~~~~~~~  vmDataLock: PRIVATE MONITORLOCK;  AllocateReservedMStoreInternal: PRIVATE VAR PROCEDURE [    interval: VM.Interval, resident: BOOLEAN];  END.LOG30-Jun-82 12:00:00   WDK       Created file.24-Aug-82 10:42:14   WDK       Twiddles.16-Sep-82 10:15:00   WDK       Added RelocateInternal, new names MapInternal, UnmapInternal. Changed results of FindUnreferenced. Deleted AwaitNotCheckedOut. Added writable copy of VMPerf.swapOutPagesReclaimed.15-Oct-82 15:39:13   WDK        Documented restrictions. 8-Nov-82 18:31:44   JXP        Use Space rather than NewSpace.11-Feb-83  9:06:34   WDK        Deleted MapResult[vacuousInterval]. MapInternal renamed to CreateMapUnit, MapResult to ParamsSwapStatus, UnmapInternal to DeleteMapUnit, RelocateInternal to RelocateMapUnit. 4-Mar-83 10:19:51   WDK        Add MapParams. 3-May-83 16:19:47   WDK        Doc: CreateMapUnit adjusts reserved memory.18-Jun-84 12:52:10   KEK        Add pageReadIn parameter to CheckInSwapUnits (TRUE means POSSIBLY).11-Jul-84 18:09:00   KEK        Move VMInternal.OpData.processType to CheckOutData.processType, change CheckInSwapUnits to get a pResult instead of just an intervalCheckedOut.  Add VMData.State.16-Aug-84 19:09:14   KEK        add "resident" argument to AllocateReservedMStore (for PC emulation).  8-Oct-84 16:09:34   EKN        Copyrite formatted.
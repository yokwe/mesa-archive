-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- VMDriver and ResMemMgr> MStore.mesa        27-Sep-84 16:09:10 by KEK    -- This interface provides facilities for managing real memory.-- The caller of any procedure in this interface must have his state vector guarded.-- All virtual memory pages passed to procedures in this interface must lie within the virtual memory of the processor.-- This is a private interface for use only within the RealMemory and VirtualMemory configurations.-- Implementation note: Some MStore procedures are involved in recovering from the frame heap becoming exhausted. Because of this, invoking these procedures must not cause any frame allocations. This means that these procedures (and any that they call) must be INLINEs or coroutines. Since there is no such thing as an ENTRY coroutine, it must be simulated by an ENTRY INLINE procedure (which acquires the monitor lock) which itself calls the coroutine. To have an ENTRY INLINE PROCEDURE, the monitor lock must be available in the DEFINITIONS module. To allow a coroutine to be called as a public procedure, the procedure descriptor must be bundled into a record to force it to be a procedure variable.  DIRECTORY  Environment USING [PageCount, PageNumber],  PageMap USING [Flags, RealPageNumber],  VM USING [Interval],  VMExtras USING [SwitchType];MStore: DEFINITIONS LOCKS mStoreLock =  BEGIN  AddReserved: ENTRY PROCEDURE [countAdded: Environment.PageCount] = INLINE  -- Increases by countAdded the number of reserved pages currently available.  -- This operation should be done *after* any BackingStore.TransferProc action has completed.   BEGIN   IF countAdded > 0 THEN AddReservedInternal[countAdded];   END;  Allocate: PROCEDURE [interval: VM.Interval, resident: BOOLEAN];  -- Allocates and maps real memory to all of the specified interval.  -- The memory allocated is counted as ordinary memory.  -- The pages are marked clean, unreferenced, and writable.  -- If any page of the interval is mapped at entry, the debugger is called.  --"resident" is TRUE if the interval to be allocated is intended to be resident.  AllocateIfFree: ENTRY PROCEDURE [interval: VM.Interval, resident: BOOLEAN]    RETURNS [countAllocated: Environment.PageCount] = INLINE    -- Allocates and maps real memory to as much of the specified interval as available real memory allows. Resident is TRUE if the interval is to be resident.    -- The pages are marked clean, unreferenced, and writable.    -- Guaranteed not to do an ALLOC from the frame heap.    BEGIN RETURN[AllocateIfFreeInternal[interval, resident]] END;          AwaitBelowThreshold: PROCEDURE    RETURNS [countNeeded: Environment.PageCount];  -- AwaitBelowThreshold returns when the amount of free plus MStore.Promise'd real memory is less than the amount being requested (by Allocate) plus the current swapOut threshold (see VMPerf.SetSwapOutThreshold). When AwaitBelowThreshold returns, the process which called it becomes the "designated swap out process"; no other processes waiting inside AwaitBelowThreshold will return until either (a) the designated swap out process once again calls AwaitBelowThreshold, or (b) the designated swap out process calls MStore.Promise. When either of these two conditions occurs, the process ceases to be the designated swap out process, and some other process waiting inside AwaitBelowThreshold will be allowed to return (if the other condions are also satisfied).  -- See also SubtractReserved and VM.AdjustReservedRealMemory.  -- The desired number of free pages is returned.  Deallocate: ENTRY PROCEDURE [    interval: VM.Interval, vow: Vow] = INLINE    -- Frees any real memory currently mapped to pages of the specified virtual memory interval.    -- vow=promised indicates that the real pages in the interval had previously been MStore.Promise'd.    -- Guaranteed not to do an ALLOC from the frame heap.    BEGIN DeallocateInternal[interval, vow] END;  Vow: TYPE = {notPromised, promised};  Promise: PROCEDURE [count: Environment.PageCount];  -- Increases the amount of promised real memory by count pages.   -- Promised memory is memory that is being delivered to a BackingStore.TransferProc for swapping out, and will be deallocated soon.  -- See AwaitBelowThreshold.  RelocateAdjustingFlags: PROCEDURE [    interval: VM.Interval, pageDest: Environment.PageNumber,    flagsKeep, flagsAdd: PageMap.Flags]    RETURNS [flags: PageMap.Flags, anyVacant: BOOLEAN];  -- For each mapped page in interval, clears those flags not in flagsKeep (a bit mask), then sets those flags in flagsAdd, and then relocates the (real) pages in interval to their corresponding spots in the interval [pageDest, interval.count].  -- The flags returned are the logical OR of the flags of all mapped pages in the interval. If there are no mapped pages, returns flags=PageMap.flagsNone.  -- If there are any vacant pages in interval, returns anyVacant=TRUE.  -- NOTE: The implementation of RelocateAdjustingFlags may make the affected pages temporarily "vacant". The only case in which it does not is when the interval is not being moved (pageDest=interval.page) and the old flags are being totally overwritten (flagsKeep = flagsNone). In particular, this is the only case in which it can be applied to resident pages.  SubtractReserved: ENTRY PROCEDURE [    countSubtracted: Environment.PageCount, ifReservedLow: IfReservedLow]    RETURNS [ok: BOOLEAN] = INLINE  -- IF the reserved pool is depleted already or subtracting the given pages would require depleting the reserved pool (i.e. the number of free pages + the number of reserved pages available < the reserved requirement + countSubtracted) AND ifReservedLow=returnIfLow, returns ok=FALSE immediately;  -- ELSE (returnWait IN [waitTillEnough..doAnyway] or the reserved pool is sufficient)  --    BEGIN  --    IF ifReservedLow=waitTillEnough, then waits until the above free page condition is true;  --    Decreases the count of reserved pages currently available by countSubtracted and returns ok=TRUE.  --    END  -- This operation should be done *before* the pages are passed to a BackingStore.TransferProc.    BEGIN    IF countSubtracted > 0 THEN      RETURN [SubtractReservedInternal[countSubtracted, ifReservedLow]]    ELSE RETURN [TRUE];    END;  IfReservedLow: TYPE = {returnIfLow, waitTillEnough, doAnyway};       RelocatePCMemory: PROCEDURE [interval: VM.Interval];   -- Checks each page of interval for real memory in the PC emulation area.  -- Every page must be non-Vacant!  -- If a resident VM page is found in the PC bank, then it is "relocated"  -- outside of it. Becuz:  --   PC real memory must always be filled with only free pages or swappable  --   pages, so that when PC emulation is started up, I can (at the drop of a  --   hat) swap everything out of the PC bank to make it available to the  --   emulation.  MStoreEmulatePC: PROCEDURE [    switch: VMExtras.SwitchType, interval: VM.Interval];  -- This is called by VMImpl.EmulatePC to do the dirty work of exchanging free  -- pages in the PC bank with free pages outside of the PC bank.  It also has  -- the very important duty of turning on the system PCMode indicator,  -- that keeps the system from touching PC pages during PC emulation mode  -- (becuz of this it must be called first thing from VMImpl.EmulatePC...)  -- Switch indicates whether PCE is turning ON or OFF.  -- Interval is exactly [PCstart..PCend) vm pages to map to  -- the PC bank (so it will survive RecoverMStore).    IsPeeCee: PROCEDURE [realPage: PageMap.RealPageNumber] RETURNS [BOOLEAN];  -- Returns TRUE if the given realPage is within the PC memory bank.        --~~~~~~~~~~ PRIVATE items:  mStoreLock: PRIVATE MONITORLOCK;  AddReservedInternal: PRIVATE VAR PROCEDURE [countAdded: Environment.PageCount];    SubtractReservedInternal: PRIVATE VAR PROCEDURE [    countSubtracted: Environment.PageCount, ifReservedLow: IfReservedLow]    RETURNS [ok: BOOLEAN];  AllocateIfFreeInternal: PRIVATE VAR PROCEDURE [    interval: VM.Interval, resident: BOOLEAN]    RETURNS [countAllocated: Environment.PageCount];  DeallocateInternal: PRIVATE VAR PROCEDURE [    interval: VM.Interval, vow: Vow];      END.LOGMarch 30, 1978  12:00 AM   PXM       Created file.September 5, 1978  3:40 PM   DXR      Added anyVacant result to RelocateSeptember 26, 1979  3:32 PM   WDK       Added GetState, documentationOctober 25, 1979  1:32 PM   PXM       AR2449: Added Recover (; add AllocateIfFree)November 8, 1979  11:56 AM   PXM       AR2768: Allocated must not wait in fixed frameMarch 20, 1980  9:35 AM   WDK       Made Deallocate, GetState ENTRY INLINEs. Added newCycle to AwaitBelowThreshold. Recover moved to StoragePrograms.December 2, 1980  9:37 AM   WDK       Retired GetState.27-Oct-81  8:47:34   WDK       Improved documentation.23-Jul-82 11:12:21   WDK       Added *Reserved; memType args added. SetThreshold moved to VMPerf.25-Oct-82 11:26:02   WDK        Twiddles.4-Nov-82  9:04:34   WDK        ChangeReservedRequirement superseded by VM.AdjustReservedRealMemory. Relocate renamed to RelocateAdjustingFlags due to [censored] export conflict. 2-May-83 15:49:49   WDK        AddReserved now doesn't actually call if count = 0.10-Jul-84 19:53:51   KEK        use VAR for AllocateIfFree & Deallocate (instead of RECORDs). Make AddReservedInternal and SubtractReservedInternal VAR PROCS to be coroutines, also. Toss SubtractReservedOrReclaim; Toss memType!!27-Sep-84 16:10:24   KEK        add "resident" parameter to Allocate* for PC emulation, and RelocatePCMemory[] and IsPeeCee[] and MStoreEmulatePC[]..
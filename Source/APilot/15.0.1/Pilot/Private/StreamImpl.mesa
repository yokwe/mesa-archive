-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- StreamImpl.mesa	18-Jul-83 12:05:56 by AWL      -- ByteBlt overlaps need efficiency work; the implementation is really low rent.-- it seems that BitBlt can be used, but problems have to be solved regarding-- disjoint and disjoint linesDIRECTORY  -- BitBlt USING [AlignedBBTable, BITBLT, BBptr, BBTableSpace],  ByteBlt USING [OverLapOption],  Environment USING [--bitsPerWord, bitsPerByte,-- Block, Byte, bytesPerWord],  ESCAlpha USING [aBYTBLT, aBYTBLTR],  -- Inline USING [LongCOPY],  KernelPrograms USING [],  Mopcodes USING [zESC],  Stream,  SpecialSystem USING [Unimplemented];StreamImpl: PROGRAM  IMPORTS --Inline, BitBlt,-- SpecialSystem  EXPORTS ByteBlt, KernelPrograms, Stream =  BEGIN OPEN ByteBlt;  Block:            TYPE = Stream.Block;  Byte:             TYPE = Stream.Byte;  Word:             TYPE = Stream.Word;  Handle:           TYPE = Stream.Handle;  SubSequenceType:  TYPE = Stream.SubSequenceType;    StartIndexGreaterThanStopIndexPlusOne: PUBLIC ERROR = CODE;  Attention:	    PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  EndOfStream:      PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  EndRecord:	    PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  LongBlock:        PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  ShortBlock:       PUBLIC ERROR = CODE;  SSTChange:        PUBLIC SIGNAL [sst: SubSequenceType, nextIndex: CARDINAL] = CODE;  TimeOut:          PUBLIC SIGNAL [nextIndex: CARDINAL] = CODE;  InvalidOperation: PUBLIC ERROR = CODE;  LeftAndRight: TYPE = MACHINE DEPENDENT RECORD [    left(0:0..7), right(0:8..15): Environment.Byte];  InitializeStream: PUBLIC --KernelPrograms.-- PROCEDURE = {};  --~~~~~~~~~~~~~~~ Stream implementation (defaults):    defaultObject: PUBLIC Stream.Object ¬ [    options: Stream.defaultInputOptions,    getByte: DefaultGetByte, putByte: DefaultPutByte,    getWord: DefaultGetWord, putWord: DefaultPutWord,    get: DefaultGet, put: DefaultPut,    setSST: DefaultSetSST, getSST: DefaultGetSST,    sendAttention: DefaultSendAttention, waitAttention: DefaultWaitAttention,    delete: DefaultDelete,    getPosition: DefaultGetPosition, setPosition: DefaultSetPosition,    sendNow: DefaultSendNow,    clientData: NIL,    getTimeout: DefaultGetTimeout, setTimeout: DefaultSetTimeout];  DefaultGetByte: PROCEDURE [sH: Handle] RETURNS [byte: Byte] =    -- Get one byte, using GetBlock on a one-byte block    BEGIN    array:   PACKED ARRAY [0..1] OF Byte;    options: Stream.InputOptions = [FALSE, FALSE, FALSE, TRUE, TRUE, FALSE];    IF sH.get = DefaultGet THEN ERROR SpecialSystem.Unimplemented;    [] ¬ sH.get[sH, Block[@array, 1, 2], options];    RETURN[array[1]]  -- right-justify the byte    END;  DefaultGetWord: PROCEDURE [sH: Handle] RETURNS [word: Word] =    -- Get one word using GetBlock on a two-byte block    BEGIN OPEN w: LOOPHOLE[word, LeftAndRight];    options: Stream.InputOptions = [FALSE, FALSE, FALSE, TRUE, TRUE, FALSE];    SELECT TRUE FROM      sH.getByte ~= DefaultGetByte => {        w.left ¬ sH.getByte[sH]; w.right ¬ sH.getByte[sH]};      sH.get ~= DefaultGet =>        [] ¬ sH.get[sH, Block[LOOPHOLE[LONG[@word]], 0, 2], options];      ENDCASE => ERROR SpecialSystem.Unimplemented;    END;  DefaultGet: PROCEDURE [sH: Handle, block: Stream.Block, options: Stream.InputOptions]    RETURNS [      bytesTransferred: CARDINAL, why: Stream.CompletionCode,      sst: SubSequenceType] =    -- Get block, using GetByte repeatedly    BEGIN    i: CARDINAL;    sstNew: SubSequenceType;    IF sH.getByte = DefaultGetByte OR options.terminateOnEndRecord      OR options.signalLongBlock OR options.signalShortBlock THEN ERROR;    why ¬ normal; i ¬ block.startIndex;    WHILE i < block.stopIndexPlusOne DO      block.blockPointer[i] ¬ sH.getByte[sH !        SSTChange =>          IF ~options.signalSSTChange THEN {sstNew ¬ sst; GO TO PostSSTChange}          ELSE {SIGNAL SSTChange[sst: sst, nextIndex: i]; RESUME};        EndOfStream =>          IF ~options.signalEndOfStream THEN GO TO PostEndOfStream          ELSE {SIGNAL EndOfStream[nextIndex: i]; RESUME -- why is this useful? --}];      i ¬ i + 1;      REPEAT        PostSSTChange => why ¬ sstChange;	PostEndOfStream => why ¬ endOfStream;      ENDLOOP;    bytesTransferred ¬ i - block.startIndex; sst ¬ sstNew    END;  DefaultPutByte: PROCEDURE [sH: Handle, byte: Byte] =    -- Put one byte, using PutBlock on a one-byte block    BEGIN    array: PACKED ARRAY [0..1] OF Byte ¬ [0, byte];    IF sH.put = DefaultPut THEN ERROR SpecialSystem.Unimplemented;    sH.put[sH, Block[@array, 1, 2], FALSE];    END;  DefaultPutWord: PROCEDURE [sH: Handle, word: Word] =    -- Put one word, using PutBlock on a one-byte block    BEGIN OPEN w: LOOPHOLE[word, LeftAndRight];    SELECT TRUE FROM      sH.putByte ~= DefaultPutByte =>        {sH.putByte[sH, w.left]; sH.putByte[sH, w.right]};      sH.put ~= DefaultPut => sH.put[sH, Block[LOOPHOLE[LONG[@word]], 0, 2], FALSE];      ENDCASE => ERROR SpecialSystem.Unimplemented;    END;  DefaultPut: PROC [sH: Handle, block: Block, endRecord: BOOLEAN] =    -- Put block, using PutByte repeatedly    BEGIN    IF sH.putByte = DefaultPutByte OR endRecord THEN      ERROR SpecialSystem.Unimplemented;    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO      sH.putByte[sH, block.blockPointer[i]] ENDLOOP;    END;  DefaultGetPosition: Stream.GetPositionProcedure = {ERROR InvalidOperation};  DefaultSetPosition: Stream.SetPositionProcedure = {ERROR InvalidOperation};    DefaultGetSST: Stream.GetSSTProcedure = {ERROR InvalidOperation};  DefaultSetSST: Stream.SetSSTProcedure = {ERROR InvalidOperation};    DefaultSendAttention: Stream.SendAttentionProcedure = {ERROR InvalidOperation};  DefaultWaitAttention: Stream.WaitAttentionProcedure = {ERROR InvalidOperation};    DefaultDelete: Stream.DeleteProcedure = {ERROR InvalidOperation};    DefaultGetTimeout: Stream.GetTimeoutProcedure = {ERROR InvalidOperation};  DefaultSetTimeout: Stream.SetTimeoutProcedure = {ERROR InvalidOperation};  DefaultSendNow: Stream.SendNowProcedure =    -- This funny implementation is for compatibility with pre 8.0F streams    BEGIN    sH.put[sH, Stream.Block[NIL, 0, 0], TRUE];    END;  --~~~~~~~~~~~~~~~ ByteBlt implementation:    -- cases:  -- 1) identical   => return  -- 2) disjoint    => do it  -- 3) ffffffbbbbbttttt   (from overlaps to); moves must go backwards    -- 4) ttttbbbbbfffffff   (to overlaps from); moves must go forwards  -- ripples always forward    ByteBlt: PUBLIC PROCEDURE [to, from: Environment.Block, overLap: OverLapOption ¬ ripple]    RETURNS [nBytes: CARDINAL] =    BEGIN    -- Note: to & from are RECORDs, not POINTERs to RECORDs, so we can update them    -- Check block and adjust so startIndex is IN [0..bytesPerWd).    bytesPerWd: CARDINAL = Environment.bytesPerWord;        AdjustAndCheck: PROC [bp: POINTER TO Environment.Block]      RETURNS[bytesToMove: CARDINAL] = INLINE      BEGIN      temp: CARDINAL;      IF bp.startIndex > bp.stopIndexPlusOne THEN         ERROR StartIndexGreaterThanStopIndexPlusOne;      bytesToMove ¬ bp.stopIndexPlusOne - bp.startIndex;      temp ¬ bp.startIndex/bytesPerWd;      bp.blockPointer ¬ bp.blockPointer + temp;      bp.startIndex ¬ bp.startIndex - (temp*bytesPerWd);      -- bp.stopIndexPlusOne ¬ bp.stopIndexPlusOne - (temp*bytesPerWd);  ++ never looked at again      END;          InBlock: PROCEDURE RETURNS [BOOLEAN] =       BEGIN       -- Tests to see if the destination block begins in the source block       -- Assumes that to and from are normalized (i.e., AdjustAndCheck has       --    been called on to and from)       LP: PROCEDURE [l: LONG POINTER] RETURNS [LONG ORDERED POINTER] = INLINE          {RETURN[LOOPHOLE[l]]};       IF LP[to.blockPointer] < LP[from.blockPointer] THEN RETURN [FALSE];       IF to.blockPointer = from.blockPointer AND          to.startIndex IN [from.startIndex..from.startIndex+nBytes) THEN          RETURN [TRUE];       -- Now we know that to.blockPointer > from.blockPointer       -- The following multiply may overlap but this okay - it will say they       -- overlap which will simply cause a reverse move when a forward move       -- would possibly be more efficient       RETURN [ -- See if the byte index of "to" is in the "from" field         ((to.blockPointer-from.blockPointer)*bytesPerWd + to.startIndex)         IN [from.startIndex..from.startIndex+nBytes)];       END;           -- MACHINE CODE Procs to do the BLTing    ByteBltInternal: PROC[      destBase: LONG POINTER, destIndex, count: CARDINAL, sourceBase: LONG POINTER,      sourceIndex: CARDINAL] =          MACHINE CODE {Mopcodes.zESC, ESCAlpha.aBYTBLT};        ByteBltRInternal: PROC[      destBase: LONG POINTER, destIndex, count: CARDINAL, sourceBase: LONG POINTER,      sourceIndex: CARDINAL] =         MACHINE CODE {Mopcodes.zESC, ESCAlpha.aBYTBLTR};	     -- Begin main text of ByteBlt:    IF (nBytes ¬ MIN[AdjustAndCheck[@to], AdjustAndCheck[@from]]) = 0       OR ((to.blockPointer = from.blockPointer) AND          (to.startIndex = from.startIndex)) THEN RETURN;    IF overLap=move AND InBlock[]       -- Move backwards only if we are moving and the destination is in the       -- source block      THEN -- move backwards         ByteBltRInternal[to.blockPointer, to.startIndex, nBytes,                         from.blockPointer, from.startIndex]    ELSE -- move forwards        ByteBltInternal[to.blockPointer, to.startIndex, nBytes,                        from.blockPointer, from.startIndex];    RETURN;    END;  END.LOG(For earlier log entries, please see Mesa 8.0 archive version.)26-Jan-82 17:00:12   JXP      Make ByteBlt more efficient by using the ByteBlt machine instruction.29-Jan-82  9:09:46   CRF   In ByteBlt, use ByteBltInternal for forward move instead of ByteBltRInternal.15-Feb-82 13:14:02   AWL         In ByteBlt, added inBlock handle moving overlapping fields correctly (added InBlock).15-Sep-82 12:17:35   WDK        MiscPrograms becomes KernelPrograms.22-Dec-82 15:41:54   AWL         Initialize defaultObject.clientData.1-Apr-83 13:37:14   AWL         Add signal EndRecord.18-Jul-83 12:06:00   AWL         defaultObject: all unimplemented opn's raise InvaldiOperation.
-- Copyright (C) 1984, 1985, 1986. 1987  by Xerox Corporation. All rights reserved. -- Loader>UnloaderCoreImpl.mesa      2-Nov-87 16:59:58 by ET  DIRECTORY  BcdDefs USING [MTIndex, MTRecord],  BcdOps USING [BcdBase],  Environment USING [wordsPerPage],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Create, Delete],  LoadedMem USING [    FreeMDSPages, FreePages, FreeMDSWords, FreeWords, Short, UnmapCode],  LoaderCore USING [WrongVersion],  LoaderCoreOps,  LoadState USING [    BcdInfoIndex, GetModuleInfo, LockBcdInfo, ModuleInfoSequenceHandle,    RemoveGlobalFrame, RemoveModuleInfos, ModuleInfosOfBcd, UnlockBcdInfo],  LoadStateFormat USING [ModuleInfo],  PrincOpsExtras2 USING [GFT, LongGlobalFrameHandle],  Runtime USING [ControlLink, GlobalFrame],  SpecialLoader USING [UnmapProcType],  SpecialLoaderInternal USING [UnmapProc],  SpecialRuntimeExtras USING [GlobalFrameFromProgram];UnloaderCoreImpl: PROGRAM  IMPORTS    FrameExtras, Heap, LoadedMem, LoaderCore, LoadState, LoaderCoreOps,    Runtime, SpecialLoaderInternal, SpecialRuntimeExtras  EXPORTS LoaderCoreOps, SpecialLoader =  BEGIN  << To do:    free control lists for unstarted modules    complain when unloading something not loaded by loader  >>  -- Copied types and constants:  BcdInfoIndex: TYPE = LoadState.BcdInfoIndex;  -- copied from LoaderCoreImpl  MtiFromOrdinal: PROC [ordinal: LoaderCoreOps.ModuleRange]    RETURNS [BcdDefs.MTIndex] = INLINE {    -- Returns BcdDefs.MTIndex given zero-origin ordinal of module in bcd's module table.    -- Not "Index" since BcdDefs uses that term for relative pointers!    RETURN[BcdDefs.MTIndex.FIRST + ordinal * BcdDefs.MTRecord.SIZE]};  OrdinalFromMti: PROC [mti: BcdDefs.MTIndex]    RETURNS [LoaderCoreOps.ModuleRange] = INLINE {    -- Returns zero-origin index of module in bcd's module table.    -- NOT a BcdDefs "Index" which is a relative pointer!    RETURN[(mti - BcdDefs.MTIndex.FIRST) / BcdDefs.MTRecord.SIZE]};  UnNewConfig: PUBLIC -- SpecialLoader-- PROC [    link: Runtime.ControlLink, unmapProc: SpecialLoader.UnmapProcType] =    BEGIN    bii: LoadState.BcdInfoIndex;    bcd: BcdOps.BcdBase;    info: LoadStateFormat.ModuleInfo;    exports: LoaderCoreOps.ERSequenceHandle ¬ NIL;    frame: PrincOpsExtras2.LongGlobalFrameHandle;    codeSets: LoaderCoreOps.CodeSetSequenceHandle;    moduleInfo: LoadState.ModuleInfoSequenceHandle;    rebuilding: LoaderCoreOps.ERIndexSequenceHandle;    frame ¬ SpecialRuntimeExtras.GlobalFrameFromProgram[Runtime.GlobalFrame[link]];    [LoaderCoreOps.loadState, LoaderCoreOps.bcdInfo] ¬  -- save in globals for everybody.      LoadState.LockBcdInfo[];  -- also serializes access to globals    info ¬ LoadState.GetModuleInfo[FrameExtras.LongGFToGFTHandle[frame]];    bii ¬ info.index;    bcd ¬ LoaderCoreOps.bcdInfo[bii].base;    LoaderCoreOps.scratch ¬ Heap.Create[      initial: 5, increment: 10, swapUnitSize: 20,      largeNodeThreshold: 50 * Environment.wordsPerPage];    BEGIN    ENABLE      UNWIND => {        Heap.Delete[z: LoaderCoreOps.scratch, checkEmpty: FALSE];        LoaderCoreOps.scratch ¬ NIL;        LoadState.UnlockBcdInfo[]};	    -- the fingers are long gone (after Traps starttrapped the bcd)    -- might as well get rid of the mds storage its taking up.    IF LoaderCoreOps.bcdExtra[bii].fingers # NIL THEN       BEGIN      -- destroy the control lists      FOR i:CARDINAL IN [0..LoaderCoreOps.bcdExtra[bii].nFingers) DO        LoaderCoreOps.bcdExtra[bii].fingers[i] ¬ 	  LoadedMem.FreeMDSWords[LoaderCoreOps.bcdExtra[bii].fingers[i]];	ENDLOOP;      -- destroy the finger list      LoaderCoreOps.bcdExtra[bii].fingers ¬        LoadedMem.FreeMDSWords[LoaderCoreOps.bcdExtra[bii].fingers];      END;    -- unbind modules    IF LoaderCoreOps.bcdInfo[bii].exports THEN {      exports ¬ LoaderCoreOps.BuildExportRecords[        bcd, bii, LoaderCoreOps.bcdExtra[bii].frames];      UnbindBcdFromOthers[bii, exports! LoaderCore.WrongVersion => RESUME]};    -- unmap code    codeSets ¬ LoaderCoreOps.bcdExtra[bii].codeSets;    IF codeSets # NIL THEN {      SpecialLoaderInternal.UnmapProc ¬ unmapProc; --provide hook for unmapping      FOR k: CARDINAL IN [0..codeSets.length) DO        [] ¬ LoadedMem.UnmapCode[codeSets[k].pointer]; ENDLOOP;      LoaderCoreOps.permanentZone.FREE[@codeSets]};          -- free exports            IF LoaderCoreOps.bcdInfo[bii].exports THEN       BEGIN      -- RemoveExportRecords will FREE name and links nodes from permanentZone       -- if the entry doesn't need to be rebuilt, i.e., no multiple exporters      rebuilding ¬ 	LoaderCoreOps.RemoveExportRecords[LoaderCoreOps.exportRecords, exports];      FOR i: LoaderCoreOps.BcdExtraRange IN [0..LoaderCoreOps.loadState.nBcds) DO        otherBcd: BcdOps.BcdBase = LoaderCoreOps.bcdInfo[i].base;	IF otherBcd = bcd THEN LOOP;	LoaderCoreOps.RebuildExportRecords[	  otherBcd, LoaderCoreOps.exportRecords, rebuilding, 	  LoaderCoreOps.bcdExtra[i].frames]	ENDLOOP;      -- BuildExportRecords NEWed names and links for export in the bcd      FOR i: NATURAL DECREASING IN [0..exports.length) DO	LoaderCoreOps.permanentZone.FREE[@exports[i].name];	LoaderCoreOps.permanentZone.FREE[@exports[i].links];	ENDLOOP;      LoaderCoreOps.permanentZone.FREE[@exports]; -- and it NEWed this too       LoaderCoreOps.scratch.FREE[@rebuilding];  -- RemoveExportRecords NEWed it      END;            -- take it out of GFT    moduleInfo ¬ LoadState.ModuleInfosOfBcd[bii, LoaderCoreOps.scratch];    FOR j: CARDINAL IN [0..moduleInfo.length) DO      frameToRemove: PrincOpsExtras2.LongGlobalFrameHandle ¬         PrincOpsExtras2.GFT[moduleInfo[j].gfi].globalFrame;      LoadState.RemoveGlobalFrame[frameToRemove];      ENDLOOP;    LoaderCoreOps.scratch.FREE[@moduleInfo];            -- remove from LoadState    LoadState.RemoveModuleInfos[bii];    FreeGlobalFrames[bcd, bii];    IF LoaderCoreOps.bcdExtra[bii].frames # NIL THEN       LoaderCoreOps.permanentZone.FREE[@LoaderCoreOps.bcdExtra[bii].frames];        -- clean out bcdExtra entry    FOR mbi: BcdInfoIndex IN (bii..LoaderCoreOps.bcdExtra.length) DO      LoaderCoreOps.bcdExtra[mbi - 1] ¬ LoaderCoreOps.bcdExtra[mbi]; ENDLOOP;    LoaderCoreOps.bcdExtra.length ¬ LoaderCoreOps.bcdExtra.length -1;    LoaderCoreOps.bcdExtra[LoaderCoreOps.bcdExtra.length] ¬ [];        -- unmap bcd    bcd ¬ unmapProc[bcd].pointer;    END;  -- ENABLE    Heap.Delete[z: LoaderCoreOps.scratch, checkEmpty: FALSE];    LoaderCoreOps.scratch ¬ NIL;    LoadState.UnlockBcdInfo[];    RETURN    END;  UnbindBcdFromOthers: PUBLIC PROC [    disappearingBii: BcdInfoIndex, exports: LoaderCoreOps.ERSequenceHandle] =    BEGIN    disappearingBcd: BcdOps.BcdBase = LoaderCoreOps.bcdInfo[disappearingBii].base;    IF disappearingBcd.nExports = 0 AND disappearingBcd.nConfigs # 0 THEN RETURN;    FOR otherBii: BcdInfoIndex IN [0..LoaderCoreOps.loadState.nBcds) DO      IF otherBii # disappearingBii THEN        BEGIN        otherBcd: BcdOps.BcdBase = LoaderCoreOps.bcdInfo[otherBii].base;        otherModuleInfos: LoadState.ModuleInfoSequenceHandle ¬          LoadState.ModuleInfosOfBcd[otherBii, LoaderCoreOps.scratch];        IF otherModuleInfos # NIL THEN          BEGIN          ENABLE UNWIND => LoaderCoreOps.scratch.FREE[@otherModuleInfos];          LoaderCoreOps.bcdExtra[otherBii].resolved ¬ 	    LoaderCoreOps.BindUnboundIfPossible[importer: otherBcd, 	      importerBii: otherBii, exports: exports, 	      importerModuleInfo: otherModuleInfos, action: unbind];          LoaderCoreOps.scratch.FREE[@otherModuleInfos];          END;        END;      ENDLOOP;    END;      FreeGlobalFrames: PROC [    bcd: BcdOps.BcdBase, bii: LoadState.BcdInfoIndex] =    BEGIN    -- free up packaged frames    IF LoaderCoreOps.bcdExtra[bii].framePack # NIL THEN      BEGIN      framePack: LoaderCoreOps.FramePackSequenceHandle = LoaderCoreOps.bcdExtra[bii].framePack;      FOR k: CARDINAL IN [0..framePack.length) DO        framePack[k].storage ¬	  SELECT TRUE FROM 	    framePack[k].smallFrame AND framePack[k].wheresTheStorage = vm =>	      LoadedMem.FreeWords[framePack[k].storage],	    framePack[k].smallFrame AND framePack[k].wheresTheStorage = mds =>	      LoadedMem.FreeMDSWords[LoadedMem.Short[framePack[k].storage]],	    ~framePack[k].smallFrame AND framePack[k].wheresTheStorage = vm =>	      LoadedMem.FreePages[framePack[k].storage],	    ENDCASE => 	      LoadedMem.FreeMDSPages[LoadedMem.Short[framePack[k].storage]];        ENDLOOP;      LoaderCoreOps.permanentZone.FREE[@LoaderCoreOps.bcdExtra[bii].framePack];      END;    -- free up unpackaged frames        IF LoaderCoreOps.bcdExtra[bii].storage.mds # NIL THEN           [] ¬ LoadedMem.FreeMDSWords[LoadedMem.Short[	    LoaderCoreOps.bcdExtra[bii].storage.mds]];    IF LoaderCoreOps.bcdExtra[bii].storage.vm # NIL THEN 	 [] ¬ LoadedMem.FreeWords[LoaderCoreOps.bcdExtra[bii].storage.vm];    END;  END.LOG19-Apr-83 18:23:13   JXP   	Convert to Klamath.23-Aug-83 10:04:17   WDK        Renamed from PilotUnLoader to UnloaderCoreImpl. Deleted spurious entry point "Unload".26-Sep-83 17:01:45   RES  	???12-Dec-83 17:59:59   WDK        Must catch VersionMismatch.25-Jul-84 17:16:29   EKN  	UnNewConfig now exported to SpecialLoader which contains hook for LoadedMem.UnmapCode. 1-Apr-85 11:21:34   EKN  	UnNewConfig unmaps bcd.31-May-85  8:11:35   ET         FreeGlobalFrames only once, instead of looping. Add in JGS changes to call to LoaderCoreOps.FindExportsMatchingImports in UnbindFromOthers. Undate bcdExtra.length field in UnNewConfig13-Jun-85 20:08:21   ET         Change FreeGlobalFrames to use bcdExtra[].storage instead of module[0].storage. Changed RecreateModuleTable to not pay attention to storage and actualLinkLoc. Clean out bcdExtra entry after FreeGlobalFrames.   19-Jun-85  9:14:37   ET         Changed FreeFramePack to free small frame packs from heap. Got rid of RecreateModuleTable30-Jul-85 16:48:39   ET         FIX AR 7761: VersionMismatch raised in unloading. Changed UnbindBcdFromOthers to catch LoaderCore.WrongVersion. 7-Apr-86 19:04:12   ET		Changed UnbindBcdFromOthers and UnNewConfig to deal with export records. JGS's new idea. 18-Jun-86 11:16:20   ET		Free up bcdExtra[bii].frames. Free up export names and links built by BuildExportRecords. Fix AR 7579: free up fingers and control lists.22-Jun-86 12:12:58   ET         Convert to new and old princops.26-Aug-86 13:54:55   ET         12.3 fix: Fixed up call to LoaderCoreOps.RebuildExportRecords to use really do the loop through the loadstate instead of the same bcd over and over. dumb dumb me. 4-Mar-87 16:29:35   ET         RemoveGlobalFrame now does all global frames for the bcd, instead of just the frame for the one bcd. 2-Nov-87 16:59:01   ET         Let's have RebuildExportRecords not be called on the bcd being unloaded. It makes bogus links in the exports data structure.
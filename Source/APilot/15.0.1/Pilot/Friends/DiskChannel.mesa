-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- DiskChannel.mesa    3-Oct-86 13:18:14 by CAJ     -- This Friends interface supplies operations on drives and-- for synchronous disk I/O.-- Two styles of performing I/O on a drive are provided:--   ==>  "channel", in which the I/O to be performed is associated--           with a particular instance of an online (or offline) disk pack.--   ==>  "direct", in which the I/O to be performed is done regardless--           of packs coming online or offline.-- All disk controllers are "owned" by the disk channel implementation,--   so all disk I/O MUST go through this interface.DIRECTORY  Environment USING [PageNumber],  Device USING [Type],  PilotDisk USING [Handle],  PilotDiskFace USING [    Command, DeterminationMode, DiskAddress, Operation, Status];DiskChannel: DEFINITIONS =  BEGIN  -- Operations on Drives:    -- The client must ensure that all drives supplied to the following procedures  -- are valid drives.  Drive: TYPE = LONG POINTER TO DriveObject;  DriveObject: TYPE;  nullDrive: Drive = NIL;  DiskPageCount: TYPE = LONG CARDINAL;  DiskPageNumber: TYPE = LONG CARDINAL;  GetNextDrive: PROCEDURE [prev: Drive] RETURNS [Drive];  -- Stateless enumeration of drives, beginning and ending with nullDrive.  DriveState: TYPE = {inactive, direct, channel};  -- An inactive drive may be accessed for reading only.  -- A direct drive may be accessed for reading and writing only by Direct I/O.  -- A channel drive may be accessed for reading and writing only by Channel I/O.  DriveStatus: TYPE = {illegalState, wrongChangeCount, ok};  SetDriveState: PROCEDURE [    drive: Drive, changeCount: CARDINAL, state: DriveState] RETURNS [DriveStatus];  -- Changes the drive state of a drive with a given change count.  -- If changeCount is not zero and not the same as the drive's current change  -- count, this procedure will return with wrongChangeCount.  -- Legal transitions are inactive to non-inactive and non-inactive to inactive.  -- Other transitions will return a drive status of illegalState.  InspectDiskShape: PROCEDURE [    drive: Drive, mode: PilotDiskFace.DeterminationMode]    RETURNS [knownType: BOOLEAN];  -- Ascertains and remembers characteristics of drive and currently mounted  -- pack (if any), and returns TRUE. If determination requires pack to be  -- ready and one is not, or if can not be determined per mode, returns FALSE.  -- See PilotDiskFace memo for more info.  GetDriveAttributes: PROCEDURE [drive: Drive]    RETURNS [      deviceType: Device.Type, deviceHandle: PilotDisk.Handle,      deviceOrdinal: CARDINAL, nPages: DiskPageCount, ready: BOOLEAN,      state: DriveState, changeCount: CARDINAL];  -- If nPages is returned as zero, the actual number is unknown.  -- To get the actual number, you must do an InspectDiskShape  -- which returns knownType=TRUE and try again.  GetDriveTag: PROCEDURE [drive: Drive] RETURNS [tag: CARDINAL];  SetDriveTag: PROCEDURE [drive: Drive, tag: CARDINAL];  -- One word of client data may be associated with each drive.  AwaitStateChange: PROCEDURE [count: CARDINAL, drive: Drive]    RETURNS [currentChangeCount: CARDINAL];  -- Waits until the drive's change count is greater than or equal to count.  -- If drive is nullDrive, waits until the sum of the change counts  -- of all drives is greater than or equal to count.  IsReady: PROCEDURE [drive: Drive] RETURNS [ready: BOOLEAN];  -- Page address translation:    -- The drive must have been inspected for these to work correctly.    GetPageAddress: PROCEDURE [drive: Drive, page: DiskPageNumber]    RETURNS [PilotDiskFace.DiskAddress];      GetPageNumber: PROCEDURE [drive: Drive, page: PilotDiskFace.DiskAddress]    RETURNS [DiskPageNumber];  -- Channel I/O:  -- A channel is an access path to a drive valid as long as the change count  -- does not change. The client must ensure that the channels that are passed  -- in to these procedures are actually channels created by Create.    Handle: TYPE [3];  ThreeWords: PRIVATE TYPE = ARRAY [0..3) OF WORD;  nullHandle: Handle = LOOPHOLE[ThreeWords[0, 0, 0]];  Create: PROCEDURE [drive: Drive] RETURNS [Handle];  -- Creates a channel to the drive using the drive's current change count.  -- There is no Delete operation. Just stop using the Handle.  GetDrive: PROCEDURE [channel: Handle] RETURNS [drive: Drive];  IORequestHandle: TYPE = LONG POINTER TO IORequest;    IORequest: TYPE = RECORD [    command: PilotDiskFace.Command,    diskPage: DiskPageNumber,  -- first disk page of run    memoryPage: Environment.PageNumber,  -- first memory page of run    tries: Tries,    useSamePage: BOOLEAN ¬ FALSE,    count: DiskPageCount];  ChannelStatus: TYPE = MACHINE DEPENDENT{    invalidChannel, invalidDriveState, disk, (7)};  -- IOStatus is the union of PilotDiskFace.Status and errors which  -- arise out of the disk channel implementation. The value "goodCompletion"  -- indicates that the DoIO was successful.  IOStatus: TYPE = RECORD [    SELECT type: ChannelStatus FROM    invalidChannel => NULL,  -- channel change count # drive current change count    invalidDriveState => NULL,  -- operation illegal with this drive state    disk => [status: PilotDiskFace.Status],  -- status from PilotDiskFace    ENDCASE];  goodCompletion: IOStatus = [disk[goodCompletion]];  Tries: TYPE = NATURAL;  defaultTries: READONLY Tries;  -- Indicates how hard to try if errors occur, such that the actual  -- number of retries increases monotonically with the value  -- of DiskChannel.Tries. A request with tries = defaultTries  -- will use the "default retry algorithm" for the drive.  DoIO: PROCEDURE [channel: Handle, req: IORequestHandle]    RETURNS [status: IOStatus, countDone: DiskPageCount];  -- Performs the requested operation, waits for completion, then returns.  -- countDone is the number of pages sucessfully transferred.  -- status describes the first page in error (if any).  -- Direct I/O:    DirectOperation: TYPE = RECORD [ -- actual size of this record is operationSize    diskChannelPrivate: DiskChannelPrivate,    diskOp: PilotDiskFace.Operation];    DiskChannelPrivate: TYPE[5];  Mode: TYPE = {normal, channelException};  operationSize: READONLY CARDINAL;  diskOpWordAlignment: READONLY CARDINAL;  DoDirectIO: PROCEDURE [    operation: LONG POINTER TO DirectOperation, mode: Mode ¬ normal]    RETURNS [status: IOStatus, retryCount: CARDINAL];  -- Submits the operation directly and immediately to the disk face,  -- waits for completion, returns the status with no extra error recovery.  -- The parameter "operation" must be operationSize words long  -- (which is longer than PilotDiskFace.operationSize), resident  -- in memory, and the field "diskOp" must be diskOpWordAlignment aligned.  -- For example, if pMem is a pointer to a block of memory of size  -- operationSize + diskOpWordAlignment - 1, then the following expression will  -- yield a pointer to a correctly-aligned DirectOperation:  -- LOOPHOLE[  --   ((LOOPHOLE[pMem, LONG CARDINAL] + SIZE[DiskChannelPrivate] +  --     diskOpWordAlignment - 1)/diskOpWordAlignment)  --       *diskOpWordAlignment - SIZE[DiskChannelPrivate]];  -- See PilotDiskFace memo for more information.  -- The parameter "mode" should normally be "normal".  "channelException" is  -- for the special class of actions that require DoDirectIO on a Pilot disk.  END.LOG  (For earlier log entries see Mesa 8.0 archive version.)11-Jun-82 17:51:35   KAM        Major redesign.24-Nov-82 16:04:20   WDK        Clients no longer need to guard state vector.11-Jan-83 13:39:48   KAM        DoDirectIO now returns IOStatus. Added comments on alignment of operation supplied to DoDirectIO. 5-Aug-86 14:20:57   CAJ        Removed label from IORequest, made diskOpWordAlignment use face version.12-Sep-86 12:23:51   CAJ        Added mode arg to DoDirectIO. 3-Oct-86 13:17:22   CAJ        Folded in DiskChannelExtras.
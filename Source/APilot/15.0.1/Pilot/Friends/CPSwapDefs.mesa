-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- CPSwapDefs.mesa       9-Jul-86 11:24:56   MEW   -- Data structures for debugger <=> debuggee communication.-- Design Note:  DO NOT use complex built-in Mesa types here (e.g. PROC, SIGNAL, PROCESS). Everything should be expressed in terms of PrincOps data structures. To do otherwise makes building a cross-version debugger impossible.DIRECTORY  Environment USING [PageCount],  LoadStateFormat USING [Object],  PrincOps USING [BYTE, BytePC, LocalFrameHandle, PrefixHandle, stackDepth, StateVector],  PrincOpsExtras2 USING [ControlLink, GFTHandle, NewSignalDesc],  PSB USING [PDA, PsbIndex, qFrameFault, qPageFault, Queue, qWriteProtectFault],  VMMapLog USING [Descriptor],  Volume USING [ID];CPSwapDefs: DEFINITIONS =  BEGIN  oldVersion: CARDINAL = 01054;  currentVersion: CARDINAL = 01055;  -- IF YOU MAKE AN INCOMPATIBLE CHANGE, INCREMENT THE VERSION!  SwapInfo: TYPE = MACHINE DEPENDENT RECORD [    -- This is the actual usage of PSB.PDA.available.    externalStateVector(0): LONG POINTER TO ExternalStateVector,    availableC(2), availableD(3), availableE(4): WORD];    PESV: PROCEDURE[] RETURNS [LONG POINTER TO ExternalStateVector] = INLINE {    RETURN[LOOPHOLE[PSB.PDA.available, SwapInfo].externalStateVector]};  ProcessState: TYPE = MACHINE DEPENDENT RECORD [    -- This is the actual usage for the PSB.PsbFlags.available field.    state(0:0..1): ProcState,    detached(0:2..2): BOOLEAN];  ProcState: TYPE = MACHINE DEPENDENT{    frameReady(0),  -- child process ready to be JOINed (or Detached).    frameTaken(1),  -- parent process has recorded child's frameHandle.    dead(2),  -- child process has finished all cleanup, and is dead.    alive(3)};  -- normal state of running process.  ExternalStateVector: TYPE = MACHINE DEPENDENT RECORD [    -- Items describing the boot session in general:    version(0): CARDINAL,  -- version of CPSwapDefs. MUST BE FIRST.    bootSession(1): LONG CARDINAL,  -- random number identifying boot session.    loadState(3): LONG POINTER TO LoadStateFormat.Object,    mapLog(5): LONG POINTER TO VMMapLog.Descriptor,    patchTable(7): LONG POINTER TO PatchTable,    breakBlocks(9): LONG POINTER TO BBArray,    breakpointHandlers(11): LONG POINTER TO BreakpointHandlerItem,    mds(13): CARDINAL,  -- MDS of *all* processes.    faultsBeingProcessed(14): ARRAY FaultType OF FaultQueuePtr,    systemVolumeID(20): Volume.ID,  -- (nullID if none or not known yet)    virtualMemoryCount(25): Environment.PageCount,    patchTableInUse(27:0..12): BOOLEAN,  -- (in use by debuggee)    breakBlocksInUse(27:13..13): BOOLEAN,  -- (in use by debuggee)    loadStateChanging(27:14..14): BOOLEAN,    loadStateDirty(27:15..15): BOOLEAN,  -- set by debuggee, reset by debugger    -- Items describing the current trip to or from the debugger:    swapData(28): SwapData,    spareA(48): WORD,    spareB(49): WORD];    nullBootSession: LONG CARDINAL = 0;      SwapReason: TYPE = MACHINE DEPENDENT{  --      -- Generated by debugger, handled by debuggee:    callDebuggee(0),  -- Call a procedure.    kill(1),  -- Terminate debuggee boot session.    proceed(2),  -- Continue execution. Resume a SIGNAL.    quit(3),  -- Raise ABORTED.    resizeBreakBlockTable(4),  -- grow or shrink break block table.    resizePatchTable(5),  -- grow or shrink patch table.    showScreen(6),  -- Show display screen for a while and return.    start(7),  -- Start or restart a module.    resume(8), -- resume a signal (with return values)    debuggerSpareA(9),    debuggerSpareB(10),    -- Generated by debuggee, handled by debugger:    breakpoint(11),    bug(12),  -- RuntimeInternal.Bug called.    callDebugger(13),  -- Runtime.CallDebugger or WorryCallDebugger called.    cleanMapLog(14),    interrupt(15),  -- Runtime.Interrupt called.    noOp(16),  -- Do nothing; just return to debuggee.    return(17),  -- return from SwapReason[callDebuggee, resizeBreakBlockTable,                 -- resizePatchTable, showScreen, or start].    returnAborted(18),  -- return from SwapReason[callDebuggee, etc] due to ABORTED signal.    storageFault(19),    uncaughtSignal(20),    debuggeeSpareA(21),    debuggeeSpareB(22)};    DebuggerReason: TYPE = SwapReason[callDebuggee..debuggerSpareB];  DebuggeeReason: TYPE = SwapReason[breakpoint..debuggeeSpareB];    SwapData: TYPE = MACHINE DEPENDENT RECORD [    -- Information describing the current transfer between debuggee and debugger.    lFrame(0):  -- client frame that invoked debugger. TRASH for DebuggerReasons.      PrincOps.LocalFrameHandle,    process(1): PSB.PsbIndex,  -- process that invoked debugger. TRASH for DebuggerReasons.    mayCallDebuggee(2:0..0):  --      -- FALSE => callDebuggee, resize* and start disallowed. (showScreen always allowed).      BOOLEAN,    trashWasOnStack(2:1..1): BOOLEAN,  -- was excess stuff on stack when debugger called.    fillA(2:2..10): [0..1],    body(2:11..287): SELECT reason(2:11..15): SwapReason FROM      callDebuggee => [        proc(3): PrincOpsExtras2.ControlLink, 	sv(5): dst PrincOps.StateVector],      kill => [],      proceed => [],      quit => [],      resizeBreakBlockTable => [newSize(3): CARDINAL],      resizePatchTable => [newSize(3): CARDINAL],      showScreen => [],      start => [        gFrame(3): PrincOpsExtras2.GFTHandle, 	sv(4): dst PrincOps.StateVector],      resume => [sv(3): dst PrincOps.StateVector],      debuggerSpareA, debuggerSpareB => [        data(3): ARRAY[0..SIZE[dst PrincOps.StateVector]) OF WORD],            breakpoint => [  -- (debugger fills in instByteReceptacle­)        instByteReceptacle(3): POINTER TO PrincOps.BYTE, 	sv(4): LONG POINTER TO dst PrincOps.StateVector],      bug => [bugType(3): CARDINAL],      callDebugger => [message(3): LONG STRING],      cleanMapLog => [],      interrupt => [],      noOp => [],      return => [  --        -- For callDebuggee, start: result record on stack.	-- For resizeBreakBlockTable, resizePatchTable, showScreen: TRASH.        sv(3): LONG POINTER TO dst PrincOps.StateVector],      returnAborted => [],      storageFault => [type(3): StorageFaultType, faultedProcess(4): PSB.PsbIndex],      uncaughtSignal => [        signalError(3): SignalError,	signalArgs(4): PrincOps.LocalFrameHandle,	signal(5): PrincOpsExtras2.NewSignalDesc],  -- could be an old signal too      debuggeeSpareA, debuggeeSpareB => [        data(3): ARRAY[0..SIZE[dst PrincOps.StateVector]) OF WORD],      ENDCASE];    StorageFaultType: TYPE = MACHINE DEPENDENT {addressFault(0), writeProtectFault(1)};  SignalError: TYPE = MACHINE DEPENDENT {signal(0), error(1)};  CallDebuggeeSD: TYPE = LONG POINTER TO callDebuggee SwapData;  KillSD: TYPE = LONG POINTER TO kill SwapData;  ProceedSD: TYPE = LONG POINTER TO proceed SwapData;  QuitSD: TYPE = LONG POINTER TO quit SwapData;  ResizeBreakBlockTableSD: TYPE = LONG POINTER TO resizeBreakBlockTable SwapData;  ResizePatchTableSD: TYPE = LONG POINTER TO resizePatchTable SwapData;  ShowScreenSD: TYPE = LONG POINTER TO showScreen SwapData;  StartSD: TYPE = LONG POINTER TO start SwapData;  BreakpointSD: TYPE = LONG POINTER TO breakpoint SwapData;  BugSD: TYPE = LONG POINTER TO bug SwapData;  CallDebuggerSD: TYPE = LONG POINTER TO callDebugger SwapData;  CleanMapLogSD: TYPE = LONG POINTER TO cleanMapLog SwapData;  InterruptSD: TYPE = LONG POINTER TO interrupt SwapData;  NoOpSD: TYPE = LONG POINTER TO noOp SwapData;  ReturnSD: TYPE = LONG POINTER TO return SwapData;  ReturnAbortedSD: TYPE = LONG POINTER TO returnAborted SwapData;  StorageFaultSD: TYPE = LONG POINTER TO storageFault SwapData;  UncaughtSignalSD: TYPE = LONG POINTER TO uncaughtSignal SwapData;  -- BREAKPOINT HANDLERS:  BreakpointHandlerType: TYPE = MACHINE DEPENDENT {    standard(0), noAlloc(1), countTool(2), topoGiggio(3), spareA(4), spareB(5), spareC(6)};  BreakpointHandlerItem: TYPE = MACHINE DEPENDENT RECORD[    handler(0): PrincOpsExtras2.ControlLink,    type(2): BreakpointHandlerType,  -- stage of fault processing    next(3): BreakpointHandlerPtr];    BreakpointHandlerPtr:TYPE = LONG POINTER TO BreakpointHandlerItem;  -- CONDITIONAL BREAKPOINTS:  BBArray: TYPE = MACHINE DEPENDENT RECORD [    length(0): CARDINAL, blocks(1): ARRAY [0..0) OF UserBreakBlock];  BBHandle: TYPE = LONG POINTER TO BBArray;  UserBreakBlock: TYPE = MACHINE DEPENDENT RECORD [    codeBase(0): PrincOps.PrefixHandle,  -- NIL if block unused.    pc(2): PrincOps.BytePC,    inst(3:0..7): PrincOps.BYTE,  -- original first byte of breakpointed instruction    relation(3:8..15): Relations,  --  Condition is: leftOperand <relation> rightOperand.    leftOperand(4), rightOperand(8): OperandDesc];    OperandType: TYPE = MACHINE DEPENDENT {    counter(0), immediate(1), localVariable(2), stack(3), memory(4),     localIndirect(5), localIndirectShort(6),    stackIndirect(7), stackIndirectShort(8),    memoryIndirect(9), memoryIndirectShort(10)};    ShortOrLong: TYPE = MACHINE DEPENDENT RECORD [    body (0): SELECT OVERLAID * FROM      short => [short (0): CARDINAL],      long => [long (0): LONG CARDINAL]      ENDCASE];  OperandDesc: TYPE = MACHINE DEPENDENT RECORD [    fieldPosition(0:0..3): FieldPosition,  -- starting bit position of left operand    fieldSize(0:4..8): FieldSize,  -- bit size of right operand    vp(0:9..63): SELECT type(0:9..15): OperandType FROM      counter => [timesSoFar(1): LONG CARDINAL],      immediate => [value(1): LONG CARDINAL],      -- NOTE: For localVariable, stack, memory,       -- memoryIndirect, memoryIndirectShort,      -- localIndirect, localIndirectShort,      -- stackIndirect, and stackIndirectShort,      --   operand is CARDINAL or LONG CARDINAL, depending on fieldSize.      localVariable => [index(1): CARDINAL],      stack => [index(1): StackIndex],      memory => [address(1): LONG POINTER TO ShortOrLong],      localIndirect => [  -- operand is ((lf+index)­+offset)­        index(1): CARDINAL, offset(2): CARDINAL],      localIndirectShort => [  -- operand is ((lf+index)­+offset)­        index(1): CARDINAL, offset(2): CARDINAL],      stackIndirect => [  -- operand is (sv[index]­+offset)­        index(1): StackIndex, offset(2): CARDINAL],      stackIndirectShort => [  -- operand is (sv[index]­+offset)­        index(1): StackIndex, offset(2): CARDINAL],      memoryIndirect => [  -- operand is (addressOfPointer­+offset)­        addressOfPointer(1): LONG POINTER TO LONG POINTER TO ShortOrLong,        offset(3): CARDINAL],      memoryIndirectShort => [  -- operand is (addressOfPointer­+offset)­        addressOfPointer(1): LONG POINTER TO POINTER TO ShortOrLong,        offset(3): CARDINAL],      ENDCASE];  FieldPosition: TYPE = [0..16);  -- Should be in PrincOps!  FieldSize: TYPE = [1..32];  -- must be IN [0..16) or = 32. No word boundary crossings allowed.  StackIndex: TYPE = [0..PrincOps.stackDepth);        Relations: TYPE = MACHINE DEPENDENT {eq(0), ne(1), lt(2), ge(3), gt(4), le(5)};  UBBPointer: TYPE = LONG POINTER TO UserBreakBlock;  -- PATCH TABLE:  -- Debugger-placed patches to (writeProtected) code segments.  PatchTable: TYPE = MACHINE DEPENDENT RECORD [    length(0): CARDINAL,  -- number of current entries    maxlength(1): CARDINAL,  -- max number of entries    entries(2): ARRAY [0..0) OF PatchTableEntry];  -- Note: If several entries specify the same address, the last such is used.  PatchTableEntry: TYPE = MACHINE DEPENDENT RECORD [    address(0): LONG POINTER, value(2): UNSPECIFIED];  -- FAULT DATA:    FaultType: TYPE = MACHINE DEPENDENT {    frame(PSB.qFrameFault), page(PSB.qPageFault), write(PSB.qWriteProtectFault)};  FaultQueueItem: TYPE = MACHINE DEPENDENT RECORD[    queue(0): PSB.Queue,  -- faulted processes    state(1): FaultProcessingStage,  -- stage of fault processing    next(2): FaultQueuePtr];    FaultQueuePtr:TYPE = LONG POINTER TO FaultQueueItem;  FaultProcessingStage: TYPE = MACHINE DEPENDENT{  -- in the order of processing stages    awaitingHandler(0), beingProcessed(1), errorFaultUnprocessed(2),    errorFaultBeingProcessed(3), spareA(4), other(5), last(7)};  -- Unprocessed faults will be found on the PDA fault queues. errorFaultUnprocessed  -- and errorFaultBeingProcessed only occur for page and write faults.    END.LOG   3-Aug-81 13:19:00	WDK       Added SwapReason[uncaughtError, resizePatchTable, resizeBreakBlockTable].  Field positions and values specified for machine dependent records.  loadStatePage now a PageNumber, lsPages a PageCount.  Deleted SwapReason[punt].  Changed capitalization.  Eliminated page from addressfault DebugParameter.24-Nov-82  8:42:17	AWL         Changed spare1 to returnAborted in SwapReason and added spare4.  Added faultQueues to ExternalStateVector and the new type FaultQueue.  Added types PageNumber and PageCount as interim fix until CoPilot can be rolled forward and the ESV can be changed to use the corresponding types from Environment. 6-Jul-83 13:16:15   WDK        Rearranged SwapInfo. PageNumber and PageCount become LONG. Incremented VersionID. Name changes. break block now keyed on code base rather than global frame. Added bootSession, systemVolumeID, FaultProcessingStage, FaultQueueItem, FaultType. Eliminated giant filler. Load state info now plain pointer, no page count. Moved patch table defs here from VMMapLog; pointer to patch table now right in esv. Redid DebugParameter and renamed to SwapData. Deleted SwapReason[install, cascade, worryBreak, worryCall]. Removed loopholes. Deleted level. Longified and generalized break blocks. Added breakBlocksInUse, loadStateChanging, loadStateDirty, breakpointHandlers, virtualMemoryCount, noOp. Improved documentation. Make compatible with new PrincOps.12-Jul-83 18:03:15   WDK        Added PESV. state vectors just stack only. callDebuggee gets proc. Incremented version. 4-Aug-83  8:42:14   WDK        callDebuggee.proc must be ControlLink, signalArgs.signal must be SignalDesc. Add patchTableInUse. patch table gets length rather than funny relative pointers. 5-Jan-84 16:49:25   CXH      sv in Swap data must be long pointer, not State Vector, so Debugger can change it.  Incremented VersionID.  Added localIndirect,  localIndirectShort, stackIndirect, and stackIndirectShort.  added resume swap reason, added state vector to start.30-Jun-86 15:28:29   MEW   Upgraded to new princops.
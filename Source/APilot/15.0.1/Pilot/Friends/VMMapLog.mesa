-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMMapLog.mesa     23-Jun-83 10:59:36 by WDK     -- The Map Log: Pilot-to-debugger communication of virtual memory backing storage binding.DIRECTORY  Environment USING [PageNumber],  Space USING [Interval];VMMapLog: DEFINITIONS =  BEGIN  currentVersion: CARDINAL = 62383;  -- IF YOU CHANGE THE FORMAT of Descriptor or Entry, change the version!  -- (and the one in VMMapLogInternal too.)  Descriptor: TYPE = MACHINE DEPENDENT RECORD [    -- must be allocated in permanently resident memory    version(0): CARDINAL,  -- version of format of Descriptor and Entry, both.    self(1): Entry,  -- description of virtual memory containing log    writer(8): EntryPointer,  -- next entry Pilot will write    reader(9): EntryPointer,  -- next entry debugger will examine    limit(10): EntryPointer];  -- entry following last word of ring buffer];  -- Above writer, reader, and limit fields are relative to  -- LOOPHOLE[LongPointerFromPage[self.page], EntryBasePointer]  EntryBasePointer: TYPE = LONG BASE POINTER TO ARRAY [0..0) OF Entry;  -- The actual pointer is passed in CPSwapDefs.ExternalStateVector.  EntryPointer: TYPE = EntryBasePointer RELATIVE POINTER [0..177777B] TO Entry;  Entry: TYPE [7];  -- Procedures used by CoPilot to access and manipulate log entries:  LogDesc: TYPE = RECORD[    count: CARDINAL,  -- number of entries currently in log    limit: CARDINAL,  -- maximum number of entries in log    entries: LONG POINTER TO ARRAY [0..0) OF Entry];  Log: TYPE = LONG POINTER TO LogDesc;    EntryHandle: TYPE = LONG POINTER TO Entry;    nullEntry: READONLY Entry; -- used at the end of a log as a place holder  SeeEntry: PROCEDURE [entry: EntryHandle]    RETURNS [page: Environment.PageNumber, count: [1..4096]];  IsWriteProtected: PROCEDURE [entry: EntryHandle] RETURNS [BOOLEAN];  -- NOTE: The value returned is only a hint.  -- (The truth is not available in the map log.)    Operation: TYPE = {read, write};  MovePages: PROCEDURE [    op: Operation, clientVMPage: Environment.PageNumber, entry: EntryHandle,    buffer: Space.Interval, count: Environment.PageNumber ¬ 1];  << Reads or writes a buffer to or from the specified client VM pages.  buffer must be page aligned. log must be sorted by Insert.  If clientVMPage+i not in [entry.page..entry.page+entry.count)    for i IN [0..count), InvalidPageNumber is raised.  If the page is readOnly, WriteProtected is raised.  If the page is unmapped, Unmapped is raised.  If the page could not be read/written, DiskError is raised.>>  InsertEntry: PROCEDURE [entry: EntryHandle, log: Log];  << Updates log to include the information in entry.  Updates the count field in the log  This operation may reorder the entries in log.  If there is no room in log to hold the new information, LogFull is raised.>>  InEntry: PROCEDURE [page: Environment.PageNumber, entry: EntryHandle]    RETURNS [BOOLEAN];  -- Returns TRUE if and only if page in described in entry.    FindEntry: PROCEDURE [     vmPage: Environment.PageNumber, log: Log, specialLookup: SpecialLookup ¬ NIL]     RETURNS [entry: EntryHandle];  << Returns an EntryHandle for the specified page by looking in log  for the needed information. specialLookup is provided so that  the client need not have the log all mapped in vm at once.  Raises Unmapped if no entry appears in the log for that page.>>    SpecialLookup: TYPE = PROCEDURE [log: Log, index: CARDINAL]     RETURNS [entry: EntryHandle];   -- a returned value of NIL indicates a failure to read the specified entry    FindFirstForInsert: PROCEDURE [log: Log] RETURNS [index: CARDINAL];  << Returns the index of the first entry in log that needs to be Inserted  into the log.  If index = log­.limit, then no calls on Insert are  needed.  That is, to sort a log in place, one should write code of the form:  FOR i: CARDINAL IN [FindFirstForInsert[log]..LENGTH[log]) DO    InsertEntry[@log[i], log];    ENDLOOP;  >>  InvalidPageNumber: ERROR;  LogFull: ERROR;  Unmapped: ERROR;  WriteProtected: ERROR;  DiskError: ERROR [error: DiskErrorType];  DiskErrorType: TYPE = {    labelDoesNotMatch, illegalAddress, unreadablePage, hardwareError,    notAPilotVolume};  END.LOGJun 23, 78 8:43 AM   PXM    	Created file.Jul 12, 78 3:39 PM   RXJ     	Counter proposal.Aug  1, 78 4:52 PM   PXM    	Refinements to BASE-RELATIVE types.Aug 28, 78 10:08 AM  PXM    	Added patch table.Aug 16, 79 10:42 PM  PXM    	Added writeProtected, disk variant to Entry.9-Jul-81 11:50:49    AWL         Made disk address portion of an Entry opague.  Added procedures to permit   reading/writing the disk based upon a map log entry.  Added a procedure to   "clean" a map log. 8-Aug-81 13:54:30   WDK       Temporarily added OldEntry.  Made more machine dependent.25-Sep-81 19:19:12   AWL         Added explicit types for the CoPilot interface.  Made Read/Write Page   work on runs of pages.  Added FindEntry, FindFirstForInsert and Unmapped.8-Oct-81             JXP      Made Entry an exported type. Combined read and write pages into MovePages.   Added InEntry and removed the old definition of Entry (OldEntry). Added   procedures which allow access to certain fields of an Entry. 7-Dec-81 11:54:31   AWL      	Removed incorrect comment on MovePages. 8-Nov-82 18:21:13   JXP   	Change Space.Handle to Space.Interval in MovePages.23-Jun-83 11:02:26   WDK        Doc: IsWriteProtected only a hint. Added version. Entry size increases. Patch table stuff moves to CPSwapDefs. 
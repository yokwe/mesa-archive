-- Copyright (C) 1983, 1986, 1987  by Xerox Corporation. All rights reserved. -- Boot.mesa         21-Sep-87  7:36:09 by CAJ     -- This module defines TYPEs and constants used for invoking the Germ and passing parameters to it.  It also has constants used for building Germs.-- Since the initial microcode is the primeval invoker of the germ, many of the items defined here are known to the initial microcode; thus changes to this interfaces will require corresponding changes to the initial microcode.DIRECTORY  BootFile USING [InLoadMode, MDSIndex],  Device USING [Type],  Environment USING [Long, PageCount, PageNumber, wordsPerPage],  HostNumbers USING [HostNumber, nullHostNumber],  PilotDisk USING [FileID, FilePageNumber, nullFileID],  PilotDiskFace USING [DiskAddress],  PrincOps USING [ControlLink],  SDDefs USING [sBoot, SD, sFirstGermRequest, sGermCount --,sLastPilot--],  StartList USING [Base],  System USING [defaultSwitches, NetworkAddress, Switches],  Volume USING [Type];Boot: DEFINITIONS =  BEGIN    -- SOME ITEMS DEFINED HERE ARE KNOWN TO THE INITIAL MICROCODE.  CHANGING THEM WILL REQUIRE CORRESPONDING CHANGES TO IT.  --~~~~~~~~~~ Attributes of the Germ: ~~~~~~~~~~  mdsiGerm: BootFile.MDSIndex = 0;  -- the MDS of the Germ, as defned in the PrincOps.  Known to the initial microcode.    pageGerm: Environment.PageNumber = 1;  --  Page where Germ's image starts (within Germ's MDS).  Known to the initial microcode.    countGermVM: Environment.PageCount = 96 - pageGerm;  -- Amount of virtual memory reserved for Germ and its buffers.  --~~~~~~~~~~ Arguments for the Germ, and returned results: ~~~~~~~~~~  -- Version numbers for the format of a Request:    currentRequestBasicVersion: CARDINAL = 3456B;    currentRequestExtensionVersion: CARDINAL = 7654B;    Request: TYPE = MACHINE DEPENDENT RECORD [      -- Basic portion of Request: (format known by the initial microcode)    -- IF YOU CHANGE THE FORMAT OF THIS PORTION, YOU MUST INCREMENT currentRequestBasicVersion AND GENERATE NEW INITIAL MICROCODE!    requestBasicVersion (0B): CARDINAL ¬ currentRequestBasicVersion,    action (1B): Action,    location (2B): Location,    switches (16B): System.Switches ¬ System.defaultSwitches,  -- When calling OutLoad, these are the default switches to be used for system when InLoaded later.  When calling InLoad, these are switches to be used for system being InLoaded; defaultSwitches means use the ones built into the boot file.  When returning from InLoad, these are the switches passed from caller of InLoad or, if he passed defaultSwitches, the switches built into the boot file.        -- Extension portion of Request: (not used by the initial microcode)    requestExtensionVersion (15B): CARDINAL ¬ currentRequestExtensionVersion,         -- Extensions for InLoad - "results":    pStartListHeader  (36B): StartList.Base,  -- only valid after inload of virgin boot file.       -- Extensions for OutLoad - "arguments":    inLoadMode (40B): BootFile.InLoadMode,  -- real page numbers significant?    -- As a side-effect of the cross-mds call mechanism, the entry point of the system being outLoaded is stored in pInitialLink­ in the caller's mds and the mds of the system being outLoaded is passed to the Germ.    -- Extensions for OutLoad - "results":    session (41B): Session ];  -- just finished OutLoad, or InLoaded later?  Action: TYPE = MACHINE DEPENDENT RECORD [act(0): CARDINAL];    inLoad: Action = [0];  -- restore volatile processor state from BootFile-format snapshot.    outLoad: Action = [1];  -- save volatile processor state in BootFile-format snapshot.    bootPhysicalVolume: Action = [2];  -- do inLoad using Location specified indirectly in pilot entry of PVBootFiles array of physical volume root page of disk specified by accompanying Location.  Value known by the initial microcode.    teledebug: Action = [3];  -- speak to Ethernet as Teledebug Server.  Return when commanded to.    noOp: Action = [4];  -- simply enter and exit the Germ.  Session: TYPE = {continuingAfterOutLoad, newSession};  Location: TYPE = MACHINE DEPENDENT RECORD [  -- format known by the initial microcode.    -- Description of boot file location:    deviceType (0): Device.Type,  -- e.g. sa4000, ethernet    deviceOrdinal (1): CARDINAL,  -- position of device within all those of same type    vp (2): SELECT OVERLAID * FROM      disk => [diskFileID (2): DiskFileID],      ethernetOne => [bootFileNumber (2): CARDINAL, net (3), host (4): CARDINAL ¬ 0],      ethernet => [ethernetRequest (2): EthernetRequest],      any => [a (2), b (3), c (4), d (5), e (6), f (7), g (10B), h (11B): UNSPECIFIED],      ENDCASE];  -- Disk Location Data:    DiskFileID: TYPE = MACHINE DEPENDENT RECORD [    fID (0): PilotDisk.FileID,    firstPage (5): PilotDisk.FilePageNumber,    da (7): PilotDiskFace.DiskAddress];  -- Convention: a DiskFileID is null if its fID is null:  NullDiskFileID: PROCEDURE [diskFileID: DiskFileID] RETURNS [BOOLEAN] = INLINE    { RETURN[diskFileID.fID = PilotDisk.nullFileID] };    -- Ethernet Location Data:  EthernetRequest: TYPE = MACHINE DEPENDENT RECORD [    bfn(0): EthernetBootFileNumber, address(3): System.NetworkAddress];    EthernetBootFileNumber: TYPE = RECORD [HostNumbers.HostNumber];  -- Ethernet boot file numbers are allocated from the same name space as  -- HostNumbers. Of course, these numbers do not represent hosts.  nullEthernetBootFileNumber: EthernetBootFileNumber = [HostNumbers.nullHostNumber]; --~~~~~~~~~~ Booting information for the Germ and microcode: ~~~~~~~~~~  -- Types of boot files pointed to from root pages of physical and logical  -- volumes, and delivered by boot servers:  -- The following cannot be changed without invalidating all Pilot volumes.  -- Known to the initial microcode.  BootFileType: TYPE = MACHINE DEPENDENT{    hardMicrocode (0), softMicrocode (1), germ (2), pilot (3), debugger (4),    debuggee (5), initialMicrocode (6)};  PVBootFiles: TYPE = ARRAY BootFileType [hardMicrocode..pilot] OF DiskFileID;  -- format known to the initial microcode.  LVBootFiles: TYPE = ARRAY BootFileType [hardMicrocode..debuggee] OF DiskFileID;  VolumeType: TYPE = Volume.Type;  -- for compatibility.  bootPhysicalVolumeDiskAddress: PilotDiskFace.DiskAddress = LOOPHOLE[LONG[0]];  -- (It would be cleaner if this was defined using PilotDiskFace.)  -- Bootfile descriptor information  -- This is used to identify the set of disk page runs which comprise a  -- bootfile, for microcode and germ which don't know anything about files.  DiskBootChainLink: TYPE = PilotDiskFace.DiskAddress;  nullDiskBootChainLink: DiskBootChainLink = LOOPHOLE[LONG[0]];  -- For compatibility  -- This is written in the boot chain link field of all  --   but the last page of each disk run of the bootable portion of a file.  -- A valid disk address is written in the last page of each interior disk run  --   of the bootable portion of a file.  eofDiskBootChainLink: DiskBootChainLink = LOOPHOLE[LAST[LONG CARDINAL]];  -- For compatibility  -- "End of file". This must be written in the boot chain link field of the last  --   page of the bootable portion of a file which is loaded by the microcode  --   (hard microcode, soft microcode, diagnostic microcode, germ).  --   It is required to delimit the end of the file to the microcode.  eofDescriptorLink: PilotDiskFace.DiskAddress = LOOPHOLE[LAST[LONG CARDINAL]];  -- End of BootFileDescriptor page links.  This is written in the link field of  -- the last descriptor page of a bootfile.  DiskAddress: TYPE = PilotDiskFace.DiskAddress;  -- for compatibility.  BootFileDescriptorHeader: TYPE = MACHINE DEPENDENT RECORD [    seal(0): LONG CARDINAL ¬ BootFileDescriptorPageSeal,    version(2:0..5): [0..64) ¬ BootFileDescriptorPageVersion,    bootFileType(2:6..8): BootFileType ¬ pilot,    pageRunsCount(2:9..15): [0..128) ¬ 0,  -- runs in THIS page    nextPage(3): PilotDiskFace.DiskAddress ¬ eofDescriptorLink,    thisDescriptorPages(5): CARDINAL ¬ 0,    totalDescriptorPages(6): CARDINAL ¬ 0];  BootFileDescriptorPage: TYPE = MACHINE DEPENDENT RECORD [    header: BootFileDescriptorHeader,    pageRuns: ARRAY [0..maxPageRunsPerPage) OF PageRun];  BootFileDescriptorPageHandle: TYPE = LONG POINTER TO BootFileDescriptorPage;  PageRun: TYPE = MACHINE DEPENDENT RECORD [    da(0): PilotDiskFace.DiskAddress,    count(2): CARDINAL];  BootFileDescriptorPageSeal: LONG CARDINAL = 27272727272B;  BootFileDescriptorPageVersion: CARDINAL = 1;  maxPageRunsPerPage: CARDINAL =    (Environment.wordsPerPage - SIZE[BootFileDescriptorHeader])/SIZE[PageRun]; --~~~~~~~~~~ Reserved Memory Locations for the Germ and Pilot: ~~~~~~~~~~  pInitialLink: indirect PrincOps.ControlLink =    -- The entry point to the system (the Germ or Pilot) which is rooted    -- in the MDS containing pInitialLink.  Is automatically set as a    -- side-effect of the cross-mds linkage mechanism.    -- pInitialLink­ itself is a control link within the mds containing it.    -- NOTE: The value of pInitialLink is defined by the PrincOps.    [indirect[link[link: LOOPHOLE[LOOPHOLE[SDDefs.SD, CARDINAL] +      SDDefs.sBoot * SIZE[LONG UNSPECIFIED]], fill: 0]]];    -- Previous replaces following until compiler, broken in 11.1, is again    -- able to handle expressions of "@externalConstantAddress[constantOffset]".    --[indirect[link[link: LOOPHOLE[@SDDefs.SD[SDDefs.sBoot]], fill: 0]]];  << TEMP omitted until compiler can evaluate constant pointer expressions     at compile time.  initialLinkAlignedRight: PRIVATE BOOLEAN[TRUE..TRUE] =    (LOOPHOLE[pInitialLink, PrincOps.ControlLink].indirect AND    NOT LOOPHOLE[pInitialLink, PrincOps.ControlLink].proc);>>  pCountGerm: LONG POINTER TO CARDINAL =    -- The number of pages occupied by the germ.  Set by MakeBoot.    -- This data is allocated in the Germ's MDS.    -- Excludes dynamically allocated pages (buffers, etc).    -- Location known to initial microcode.    LOOPHOLE[ Environment.Long[ any[      low: LOOPHOLE[SDDefs.SD, CARDINAL]+SDDefs.sGermCount*SIZE[LONG UNSPECIFIED],      high: mdsiGerm]]];    -- Previous replaces following for same reason as above.    --LOOPHOLE[ Environment.Long[ any[    --  low: @SDDefs.SD[SDDefs.sGermCount], high: mdsiGerm]]];  pRequest: LONG POINTER TO Request =    -- The job to be done by the Germ.    -- This data is allocated in the Germ's MDS.    -- NOTE: pRequest and the address of pRequest­.action and pRequest­.location    -- are known by the initial microcode, and MesaNetExec.    LOOPHOLE[ Environment.Long[ any[      low: LOOPHOLE[SDDefs.SD, CARDINAL] + SDDefs.sFirstGermRequest         * SIZE[LONG UNSPECIFIED], high: mdsiGerm]]];    -- Previous replaces following for same reason as above.    --LOOPHOLE[ Environment.Long[ any[    --  low: @SDDefs.SD[SDDefs.sFirstGermRequest], high: mdsiGerm]]];  -- (The allocation of SD[sFirstPilot] .. SD[sLastPilot] is defined in GermOps.)  END.LOGSeptember 13, 1979  6:03 PM   PXM       Create fileJanuary 25, 1980  4:22 PM   PXM       Add bootPhysicalVolume and noOp Request's and ethernet LocationJanuary 25, 1980  6:37 PM   PXM       Replace Location.device with Location.deviceType and .deviceOrdinalApril 17, 1980  12:41 AM   FXH       Added teledebugApril 17, 1980  10:39 AM   AWL         Added net and host to Location.ethernetJuly 15, 1980  10:09 PM   FXH       Add NoOp; refer to Volume.Type11-Aug-81 15:26:19   AWL         Location.ethernet => Location.ethernetOne.  Added Location.ethernet forr 10MB ethernet.   Made ReadMDS an INLINE.13-Aug-81 15:28:05 WDK      Switches prepended to Request; address decremented 20B to 1340B.  Un-loopholed pInitialLink.  Added pCrossMdsFrames and assertions.  Made more machine dependent.21-Aug-81  8:51:40   WDK       pInitialLink changed to be an indirect ControlLink.22-Oct-81 12:04:31   WDK       New instruction set and SDDefs. Changed value of pInitialLink and pRequest.  Moved mdsiGerm, countSkip, pCountGerm, here from BootSwap and made most LONG.  Added pageGerm, countGermVM, currentVersions, bootPhysicalVolumeDiskAddress.  Improved documentation. 5-Oct-82 10:05:45   AWL         Modified DiskFileID to use PilotDisk.FileID and not File.ID.12-Nov-82 11:59:00    LXD         DiskAddress changed from opaque type to PilotDisk.Address.28-Mar-83 15:33:43   WDK        ..and thence to PilotDiskFace.DiskAddress (which is what it actually is). Added EthernetRequest, BootServerPacket, and EthernetBootFileNumber. Made Location.ethernet use them. Added DiskBootChainLink, etc. 5-Apr-83 18:00:47   WDK        Moved BootServerPacket to BootServerDefs. 6-Jul-83 13:22:36   WDK        Added nullEthernetBootFileNumber. Made compatible with new PrincOps, SDDefs. Remove compiler bug workarounds. 5-Aug-86 15:48:59   CAJ        Added BootFileDescriptorPage definitions.  Added value initialMicrocode to BootFileType and added range to LVBootFiles to retain the values excluding initialMicrocode.  Altered pInitialLink, pCountGerm, and pRequest to form compiler will process.21-Sep-87  7:35:01   CAJ        Changed constant in coungGermVM from 64 to 96.  As a result, changed currentRequestExtensionVersion from 7123B to 7654B
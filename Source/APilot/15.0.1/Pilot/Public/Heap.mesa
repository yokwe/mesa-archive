-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- Heap.mesa     4-Apr-83 11:08:53 by WDK     DIRECTORY  Environment USING [lastPageCount, PageCount, wordsPerPage],  Space USING [defaultSwapUnitSize, SwapUnitSize];Heap: DEFINITIONS =  BEGIN  -- Dynamic storage allocation: support for Mesa uncounted zones.  -- This interface allows the creation and management of an arbitrary number of heaps, or  --   dynamic storage allocation pools, each corresponding to a Mesa uncounted zone.  --   A heap may be in hyperspace or in the MDS.  -- It is intended that Mesa's NEW and FREE be used to allocate and deallocate nodes from  --   a heap (although for compatibility with existing code, explicit procedures for this  --   purpose are also provided).  -- Types  NWords: TYPE = [0..32766);  -- limit on node size  -- Constants  unlimitedSize: Environment.PageCount = Environment.lastPageCount;  minimumNodeSize: READONLY NWords;  -- implementation limit on threshold  systemZone: READONLY UNCOUNTED ZONE;  systemMDSZone: READONLY MDSZone;  Type: TYPE = {normal, uniform, mds};  -- Creating and deleting heaps  Create: PROC [    initial: Environment.PageCount, maxSize: Environment.PageCount ¬ unlimitedSize,    increment: Environment.PageCount ¬ 4, swapUnitSize: Space.SwapUnitSize ¬ Space.defaultSwapUnitSize,    threshold: NWords ¬ minimumNodeSize,  -- smaller allocation request round up to this size    largeNodeThreshold: NWords ¬ Environment.wordsPerPage/2,  -- larger nodes in separate spaces    ownerChecking: BOOLEAN ¬ FALSE, checking: BOOLEAN ¬ FALSE]    RETURNS [UNCOUNTED ZONE];      CreateUniform: PROC [    initial: Environment.PageCount, maxSize: Environment.PageCount ¬ unlimitedSize,    increment: Environment.PageCount ¬ 4, swapUnitSize: Space.SwapUnitSize ¬ Space.defaultSwapUnitSize,    objectSize: NWords, ownerChecking: BOOLEAN ¬ FALSE, checking: BOOLEAN ¬ FALSE]    RETURNS [UNCOUNTED ZONE];      CreateMDS: PROC [    initial: Environment.PageCount, maxSize: Environment.PageCount ¬ unlimitedSize,    increment: Environment.PageCount ¬ 4, swapUnitSize: Space.SwapUnitSize ¬ Space.defaultSwapUnitSize,    threshold: NWords ¬ minimumNodeSize,  -- smaller allocation request round up to this size    largeNodeThreshold: NWords ¬ Environment.wordsPerPage/2,  -- larger nodes in separate spaces    ownerChecking: BOOLEAN ¬ FALSE, checking: BOOLEAN ¬ FALSE] RETURNS [MDSZone];      Delete: PROC [z: UNCOUNTED ZONE, checkEmpty: BOOLEAN ¬ FALSE];    DeleteMDS: PROC [z: MDSZone, checkEmpty: BOOLEAN ¬ FALSE];  -- Miscellaneous  Attributes: TYPE = RECORD [    SELECT tag: Type FROM    normal => [      largeNodePages: Environment.PageCount,      threshold, largeNodeThreshold: NWords],    uniform => [objectSize: NWords],    ENDCASE];  GetAttributes: PROC [z: UNCOUNTED ZONE]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount, swapUnitSize: Space.SwapUnitSize,      ownerChecking, checking: BOOLEAN, attributes: Attributes];        GetAttributesMDS: PROC [z: MDSZone]    RETURNS [      heapPages, largeNodePages, maxSize, increment: Environment.PageCount, swapUnitSize: Space.SwapUnitSize,      threshold, largeNodeThreshold: NWords, ownerChecking, checking: BOOLEAN];        Expand: PROC [z: UNCOUNTED ZONE, pages: Environment.PageCount];  ExpandMDS: PROC [z: MDSZone, pages: Environment.PageCount];  Flush: PROC [z: UNCOUNTED ZONE];  FlushMDS: PROC [z: MDSZone];  OwnerChecking: PROC [z: UNCOUNTED ZONE] RETURNS [BOOLEAN];  OwnerCheckingMDS: PROC [z: MDSZone] RETURNS [BOOLEAN];  Prune: PROC [z: UNCOUNTED ZONE];  PruneMDS: PROC [z: MDSZone];  CheckOwner: PROC [p: LONG POINTER, z: UNCOUNTED ZONE];  CheckOwnerMDS: PROC [p: POINTER, z: MDSZone];  SetChecking: PROC [z: UNCOUNTED ZONE, checking: BOOLEAN];  SetCheckingMDS: PROC [z: MDSZone, checking: BOOLEAN];  -- Errors    Error: ERROR [type: ErrorType];    ErrorType: TYPE = {    insufficientSpace, invalidHeap, invalidNode, invalidZone,    invalidOwner, otherError, invalidSize, invalidParameters, maxSizeExceeded};  -- Retained for Compatibility    Handle:    TYPE = UNCOUNTED ZONE;  MDSHandle: TYPE = MDSZone;  MakeNode: PROC [z: UNCOUNTED ZONE ¬ systemZone, n: NWords] RETURNS [p: LONG POINTER];  MakeMDSNode: PROC [z: MDSZone ¬ systemMDSZone, n: NWords] RETURNS [p: POINTER];  FreeNode: PROC [z: UNCOUNTED ZONE ¬ systemZone, p: LONG POINTER];  FreeMDSNode: PROC [z: MDSZone ¬ systemMDSZone, p: POINTER];  END.--LOGMay 23 80 1:14 PM   McJones   Created fileJuly 8 80 5:15 PM   McJones   Adapted for new-style uncounted zonesAug 5, 80 1:59 PM   McJones   Added Expand[MDS]; systemZONE=>systemZone; invalidZONE=>invalidZone;   converted {Make,Free}[MDS]String to INLINE; added [MDS]Handle synonyms;   decreased LAST[NWords]12-Aug-81  9:09:04   Forrest   Changed CheckOwner, added CheckOwnerMDS11-Nov-81 11:02:31   Luniewski   Added ErrorType[invalidSize]. 9-Sep-82 11:10:58   JGS   Added CreateUniform.  Changed GetAttributes.   Deleted {Make|Free}{MDS}{Node|String}.29-Sep-82 14:33:12   RKJ   Added {Make|Free}{MDS}Node. 4-Apr-83 11:10:46   WDK        Arg type of GetAttributes were wrong.   Get types from Space and Environment interface.
-- File: CourierInternal.mesa - last edit:-- AOF                 27-Oct-87 14:59:09-- SMA                 10-Jan-85 14:45:17-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Courier USING [    Handle, Parameters, Dispatcher, ErrorCode, Object, VersionRange],  CourierProtocol USING [    dataSST, MessageObject, Protocol, ProtocolRange, pvHigh, pvLow],  Environment USING [Block],  Mopcodes USING [zEXCH],  NetworkStream USING [ClassOfService],  Stream USING [Byte, CompletionCode, GetProcedure, InputOptions, Object,    SubSequenceType],  System USING [GreenwichMeanTime, NetworkAddress];CourierInternal: DEFINITIONS =  BEGIN  startTime: READONLY System.GreenwichMeanTime;  --when Courier was first started   longZone: READONLY UNCOUNTED ZONE;  --long zone used by internally Courier   maxStreamsAllowed: CARDINAL;  --max number of connections by server  numberOfStreams: CARDINAL;  --current number active at server  localSystemElement: System.NetworkAddress;  --of this system element    --timeout values used to control various aspects of the transport.  streamDefaultWaitTime: CARDINAL = 60000;  --(msecs)  serverIdleTimeout: WaitTime;  --(msecs) defaulted to 3 minutes  userIdleTimeout: CARDINAL;  --(seconds) defaulted to 30 seconds  dallyTimeout: CARDINAL;  --(seconds) defaulted to 10 seconds    inputOptions: Stream.InputOptions = [TRUE, FALSE, FALSE, FALSE, FALSE, FALSE];    --The augmented stream.  AugmentedStream: TYPE = LONG POINTER TO AugmentedObj;  AugmentedObj: TYPE = RECORD [    object: Stream.Object,    --our stream.    back: ConnectionHandle,   --pointer to the parent courier connection.    context: SEQUENCE COMPUTED CARDINAL OF WORD];  --stream dependent state info.  ConnectionHandle: TYPE = LONG POINTER TO ConnectionObject;  UserConnection: TYPE = LONG POINTER TO user ConnectionObject;  ServerConnection: TYPE = LONG POINTER TO server ConnectionObject;  ConnectionType: TYPE = {user, server, client};  StreamState: TYPE = {idle, busy, out, dally};  ConnectionObject: TYPE = RECORD[    object: Courier.Object,  --this portion is visable to the client    link: ConnectionHandle ¬ NIL,  --to next object in list    owner: PROCESS ¬ NIL,  --that requested the connection    endRecord: BOOLEAN ¬ FALSE,  --has been seen by 'GetBlock'    lastSST: Stream.SubSequenceType ¬ CourierProtocol.dataSST,    transFilter: AugmentedStream ¬ NIL,  --closest courier gets to the transport.    bulkFilter: AugmentedObj,  --stream for bulk data clients.    createTransport: Creator ¬ NIL, --Create transport.    transportType: TransportType ¬ 0,  --for caching.    body: SELECT type: ConnectionType FROM      user, server => [        versExchProc: VersExchProcType ¬ NIL,  --to exchange version numbers        protocolRange: CourierProtocol.ProtocolRange,  --range of Courier Protocol	message: CourierProtocol.MessageObject,  --last message sent/received	streamState: StreamState ¬ idle,  --state of the transport mechanism	clock: System.GreenwichMeanTime ¬ NULL,  --used to kill idle lines	redirected: Redirect ¬ NIL,  --used to capture Courier data	seal: Seal],  --just to sanity check, etc      client => [],      ENDCASE];    Redirect: TYPE = LONG POINTER TO RedirectedObject;  RedirectedObject: TYPE = RECORD[    directGet: Stream.GetProcedure,  --from direct stream (ch.transFilter.get)    why: Stream.CompletionCode,  --status of get completion on direct sH    sst: Stream.SubSequenceType,  --sst observed from direct sH    connection: UserConnection,  --and the owning connection object    block: Environment.Block,  --describing the captured data    text: PACKED SEQUENCE COMPUTED CARDINAL OF Stream.Byte];  VersExchProcType: TYPE = PROC[ch: ConnectionHandle]    RETURNS[code: Courier.ErrorCode];  Seal: TYPE = PACKED ARRAY CARDINAL[0..2) OF Stream.Byte;  seal: Seal = [141B, 157B];      ExportHandle: TYPE = LONG POINTER TO ExportObject;  ExportObject: TYPE = RECORD[    link: ExportHandle,    dispatcher: Courier.Dispatcher,  --actual service implementor    programNumber: LONG CARDINAL,  --well known value    versionRange: Courier.VersionRange,  --supported by client implementation    zone: UNCOUNTED ZONE,  --client zone    classOfService: NetworkStream.ClassOfService,  --of transport desired    exportTime: System.GreenwichMeanTime,  --when exported    serviceName: PACKED SEQUENCE length: CARDINAL OF CHARACTER];          -- statistics  doStats: BOOLEAN = TRUE;  --collect stats flag  stats: ARRAY StatType OF LONG CARDINAL;  StatType: TYPE = {    stackPagesMapped, stackPagesUnmapped, stackPagesGot, stackPagesPut,    bytesReceived, bytesTransmitted, bytesFlushed,    callsReceived, localCallsReceived, rejectsTransmitted, returnsTransmitted,    abortsTransmitted, callsTransmitted, localCallsTransmitted, rejectsReceived,    returnsReceived, abortsReceived, callRetry, zoneAllocated,    zoneFreed, streamsAcquired, streamsCreated, streamsDeleted};        -- Create your own transport  Creator: TYPE = PROC[ch: ConnectionHandle]    RETURNS [aH: AugmentedStream, protocolRange: CourierProtocol.ProtocolRange,    connectionless: BOOLEAN];  Listener: TYPE = PROC;    -- Register/unregister your transports.  (NIL chooses default)  TransportType: TYPE = CARDINAL;  AssignTransportType: PROC RETURNS [t: TransportType];  RegisterTransport: PROC[cH: Courier.Handle, transportProc: Creator ¬ NIL,    transportType: TransportType];  RegisterListener: PROC[listener: Listener ¬ NIL];    --The default transport.  CreateDefaultStream: Creator;  DefaultListener: Listener;  ttDefault: TransportType = 0;    Receiver: PROC [aH: AugmentedStream,    remote: System.NetworkAddress, myPv: CourierProtocol.ProtocolRange,    connectionless: BOOLEAN];  Closed: ERROR;  --close protocol observed by 'GetBlock' filter    --timeout values used to control various aspects of the transport.  WaitTime: TYPE = LONG CARDINAL;  --msecs  createTimeout: WaitTime;  --(msecs) t X hop weight (f({} * 1)  activeTimeout: WaitTime;  --(msecs) t X hop weight (20 * 1)  hopWeight: CARDINAL;  --multiplied times above timeouts    --Utilities  CreateNewStream: PROC RETURNS[BOOLEAN];  --okay to create new stream?  NewStreamFailed: PROC;  --the create failed        --Misc utilities  streamClass: NetworkStream.ClassOfService;  --hint as to what type of stream    --streams exported by CourierImplF  SetBulkStream: PROC [ch: ConnectionHandle];    RangesIntersect: PROC[    range: CourierProtocol.ProtocolRange] RETURNS[BOOLEAN] = INLINE    {RETURN[range.low IN[CourierProtocol.pvLow..CourierProtocol.pvHigh]      OR range.high IN[CourierProtocol.pvLow..CourierProtocol.pvHigh]]};  SetMessageProtocolVersion: PROC[ch: LONG POINTER TO user ConnectionObject,    protocol: CourierProtocol.Protocol] = INLINE    BEGIN    pv: LONG POINTER TO CourierProtocol.Protocol ¬       LOOPHOLE[@ch.message.messageObject];    pv­ ¬ protocol;    END;      ExchWords: PROC[LONG UNSPECIFIED] RETURNS[LONG UNSPECIFIED] =    MACHINE CODE {Mopcodes.zEXCH};     END.... -- of CourierInternal.mesa (DEFINITIONS)LOG 8-Dec-81 15:53:44  AOF  Trimmed back for Trinity11-Jan-82  8:41:10  AOF  Courier (protocol version 2&3)25-Jan-82 13:46:37  AOF  Caching streams, etc18-Feb-82 10:40:06  AOF  Exchanging words in long numbers 4-Mar-82 13:40:31  AOF  Stream accounting and remove CommFlags.10-Mar-82  8:48:19  AOF  Exported variables for stream timeouts. 7-Apr-82 15:23:19  AOF  Exported variable for max node alloc.21-Jul-82 11:14:35  AOF  Mods for bulk data xfer. 5-Aug-82  9:57:53  AOF  Add start and export times.18-Aug-82 10:17:41  AOF  Capture Courier data consumed by client.28-Mar-83 15:17:57  AOF  Capture Courier data consumed by client. 6-Apr-83 10:36:29  AOF  Remove ref to Space.29-Jun-83 12:26:57  AOF  NoteBlock.29-Jun-84 10:21:21  SMA  Factor Courier from NetworkStreams.20-Jul-84 11:04:43  SMA  Moved createTiemout, activeTimeout, hopWeight to SpecialCourier. 9-Oct-84 12:26:24  SMA  Removed dependency on NSTypes.WaitTime.26-Nov-84 16:06:09  SMA  Protocol version arbitration back into Courier.19-Dec-84 15:18:50  SMA  Augmented stream objects. 7-Jan-85 10:29:48  SMA  Take out TransportHandle.10-Jan-85 14:44:57  SMA  bulkFilter back in connection object.27-Oct-87  8:55:37  AOF  Add versExchProc to connection object.
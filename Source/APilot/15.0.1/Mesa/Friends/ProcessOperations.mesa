-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- ProcessOperations.mesa 10-Jun-83 15:12:56 by RXJ     DIRECTORY  ESCAlpha USING [    aBC, aDI, aEI, aMR, aMW, aNC, aREQ, aRRMDS, aRRPSB, aRRPTC,    aRRWDC, aWRMDS, aWRPSB, aWRPTC, aWRWDC],  Mopcodes USING [zESC, zME, zMX],  PSB USING [    ProcessStateBlock, PsbHandle, PsbIndex, Queue, QueueHandle, Ticks];ProcessOperations: DEFINITIONS =  BEGIN OPEN PSB;  QueueHandle: TYPE = PSB.QueueHandle;  Enter: PROCEDURE [LONG POINTER TO MONITORLOCK] RETURNS [success: BOOLEAN] = MACHINE    CODE BEGIN Mopcodes.zME END;  Exit: PROCEDURE [LONG POINTER TO MONITORLOCK] = MACHINE CODE    BEGIN Mopcodes.zMX END;  Wait: PROCEDURE [    LONG POINTER TO MONITORLOCK, LONG POINTER TO CONDITION,    --timeout:-- CARDINAL] = MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aMW END;  ReEnter: PROCEDURE [LONG POINTER TO MONITORLOCK, LONG POINTER TO CONDITION]    RETURNS [success: BOOLEAN] = MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aMR END;  Notify: PROCEDURE [LONG POINTER TO CONDITION] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aNC END;  Broadcast: PROCEDURE [LONG POINTER TO CONDITION] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aBC END;  Requeue: PROCEDURE [    from: LONG POINTER TO Queue, to: LONG POINTER TO Queue, p: PsbHandle] =    MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aREQ END;  ReadPSB: PROCEDURE RETURNS [currentProcess: PsbHandle] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aRRPSB END;  WritePSB: PROCEDURE [currentProcess: PsbHandle] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aWRPSB END;  DisableInterrupts: PROCEDURE = MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aDI END;  -- Should only be called by resident code.  If you take a frame, page or write fault  -- while interrupts are disabled, a deadlock will probably ensue!  EnableInterrupts: PROCEDURE = MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aEI END;  ReadPTC: PROCEDURE RETURNS [time: Ticks] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aRRPTC END;  WritePTC: PROCEDURE [time: Ticks] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aWRPTC END;  ReadWDC: PROCEDURE RETURNS [countDisabled: CARDINAL] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aRRWDC END;  WriteWDC: PROCEDURE [countDisabled: CARDINAL] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aWRWDC END;  ReadMDS: PROCEDURE RETURNS [mds: CARDINAL] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aRRMDS END;  WriteMDS: PROCEDURE [mds: CARDINAL] = MACHINE CODE    BEGIN Mopcodes.zESC, ESCAlpha.aWRMDS END;  -- TYPE converters    HandleToIndex, IndexFromHandle: PROCEDURE [handle: PsbHandle] RETURNS [PsbIndex] = INLINE {    RETURN[LOOPHOLE[handle, CARDINAL]/SIZE[ProcessStateBlock]]};  IndexToHandle, HandleFromIndex: PROCEDURE [index: PsbIndex] RETURNS [PsbHandle] = INLINE {    RETURN[LOOPHOLE[index*SIZE[ProcessStateBlock]]]};  IndexFromProcess: PROCEDURE [process: PROCESS] RETURNS [PSB.PsbIndex] = INLINE {    RETURN[LOOPHOLE[process]]};  ProcessFromIndex: PROCEDURE [index: PSB.PsbIndex] RETURNS [PROCESS] = INLINE {    RETURN[LOOPHOLE[index]]};  HandleFromProcess: PROCEDURE [process: PROCESS] RETURNS [PSB.PsbHandle] = INLINE {    RETURN[HandleFromIndex[IndexFromProcess[process]]]};  ProcessFromHandle: PROCEDURE [handle: PSB.PsbHandle] RETURNS [PROCESS] = INLINE {    RETURN[ProcessFromIndex[HandleToIndex[handle]]]};  END.  LOG Time:	11-Aug-81 10:39:24	By: WDK    /AWL          Added LongNakedNotify, DisableInterrupts, EnableInterrupts, ReadMDS and WriteMDS. Time:	 2-Nov-81 11:41:33	By: JGS    convert to new instruction set. Time:	30-Mar-83 11:48:26	By: RXJ         Add conversion procedures to/from PROCESS
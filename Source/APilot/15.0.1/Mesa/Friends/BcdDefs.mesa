-- Copyright (C) 1981, 1983  by Xerox Corporation. All rights reserved. -- BcdDefs.Mesa  Edited by--   JGS	 9-Dec-81 10:19:41--   RES  	10-Jun-83 10:41:22--   RXJ     	13-Jun-83 10:59:26DIRECTORY  PrincOps: TYPE USING [BytePC, MaxFrameSize],  Table: TYPE USING [Base, <<Limit, >> Selector],  TimeStamp: TYPE USING [Null, Stamp];BcdDefs: DEFINITIONS = {  Base: TYPE = Table.Base;  -- allocation codes for the binder  BinderNTables: CARDINAL = 20;  treetype: Table.Selector = 0; -- trees  httype: Table.Selector = 1; -- hash table  sstype: Table.Selector = 2; -- (packed) string table  cttype: Table.Selector = 3; -- config table  mttype: Table.Selector = 4; -- module table  imptype: Table.Selector = 5; -- import table  exptype: Table.Selector = 6; -- export table  sgtype: Table.Selector = 7; -- segment table  fttype: Table.Selector = 8; -- file table  sttype: Table.Selector = 9; -- semantic table  cxtype: Table.Selector = 10; -- context table  nttype: Table.Selector = 11; -- name table  entype: Table.Selector = 12; -- entry table  sptype: Table.Selector = 13; -- space table  fptype: Table.Selector = 14; -- frame pack table  typtype: Table.Selector = 15; -- type table  tmtype: Table.Selector = 16; -- type table  lftype: Table.Selector = 17; -- link fragment table  attype: Table.Selector = 18; -- atom table  aptype: Table.Selector = 19; -- atom printname (packed string)    -- version identification  VersionStamp: TYPE = TimeStamp.Stamp;  NullVersion: TimeStamp.Stamp = TimeStamp.Null;  -- BCD Header  VersionID: CARDINAL = 6103;    tLimit: CARDINAL = 177777B; -- was Table.Limit-1;  BCD: TYPE = RECORD [    versionIdent: CARDINAL,    version: VersionStamp,    creator: VersionStamp,    sourceFile: FTIndex,    unpackagedFile: FTIndex,    nConfigs, nModules: CARDINAL,    nImports, nExports: CARDINAL,    nPages: [0..256),    definitions, repackaged, typeExported, tableCompiled: BOOLEAN,    spare: PACKED ARRAY [0..4) OF BOOLEAN,    firstdummy: GFIndex,    nDummies: CARDINAL,    ssOffset: CARDINAL, -- string table    ssLimit: CARDINAL,    ctOffset: CARDINAL, -- config table    ctLimit: CTIndex,    mtOffset: CARDINAL, -- module table    mtLimit: MTIndex,    impOffset: CARDINAL, -- import table    impLimit: IMPIndex,    expOffset: CARDINAL, -- export table    expLimit: EXPIndex,    enOffset: CARDINAL, -- entry table    enLimit: ENIndex,    sgOffset: CARDINAL, -- segment table    sgLimit: SGIndex,    ftOffset: CARDINAL, -- file table    ftLimit: FTIndex,    spOffset: CARDINAL, -- space table    spLimit: SPIndex,    ntOffset: CARDINAL, -- name table    ntLimit: NTIndex,    typOffset: CARDINAL, -- type table    typLimit: TYPIndex,    tmOffset: CARDINAL, -- type map table    tmLimit: TMIndex,    fpOffset: CARDINAL, -- frame pack table    fpLimit: FPIndex,    lfOffset: CARDINAL, -- link fragment table    lfLimit: LFIndex,    atOffset: CARDINAL, -- atom table    atLimit: ATIndex,    apOffset: CARDINAL, -- atom printname table    apLimit: CARDINAL];  -- Portable Type  Portable: TYPE = {module, interface};  -- Name Table  PackedString: TYPE = MACHINE DEPENDENT RECORD [    SELECT OVERLAID * FROM      string => [string: StringBody],      size => [size: PACKED ARRAY [-3..-3) OF [0..256)]      ENDCASE];  NameRecord: TYPE = RECORD [CARDINAL];  NullName: NameRecord = [1];  NTRecord: TYPE = RECORD [name: NameRecord, item: Namee];  Namee: TYPE = RECORD [    SELECT type: * FROM      config => [cti: CTIndex],      module => [mti: MTIndex],      import => [impi: IMPIndex],      export => [expi: EXPIndex]      ENDCASE];  NTIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO NTRecord;  NTNull: NTIndex = LAST[NTIndex];  -- Configuration Table  CTRecord: TYPE = --MACHINE DEPENDENT-- RECORD [    name: NameRecord,    file: FTIndex,    config: CTIndex,    namedInstance: BOOLEAN,    nControls: NATURAL,    controls: ARRAY [0..0) OF Namee];  -- only config or module are valid  CTIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO CTRecord;  CTNull: CTIndex = LAST[CTIndex];  -- Module Table  LinkLocation: TYPE = {frame, code, dontcare};  MTRecord: TYPE = --MACHINE DEPENDENT-- RECORD [    name: NameRecord,    file: FTIndex,    config: CTIndex,    code: CodeDesc,    sseg: SGIndex,    links: LFIndex,    linkLoc: LinkLocation,    namedInstance, initial: BOOLEAN,     boundsChecks, nilChecks: BOOLEAN,    tableCompiled, residentFrame, crossJumped, packageable: BOOLEAN,    packed: BOOLEAN, linkspace: BOOLEAN,    spare: PACKED ARRAY [0..4) OF BOOLEAN,    framesize: [0..PrincOps.MaxFrameSize),    entries: ENIndex,    atoms: ATIndex];  CodeDesc: TYPE = RECORD [    sgi: SGIndex, offset, length: CARDINAL];  MTIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO MTRecord;  MTNull: MTIndex = LAST[MTIndex];  -- Import Table  IMPRecord: TYPE = RECORD [    name: NameRecord,    port: Portable,    namedInstance: BOOLEAN,    file: FTIndex,    gfi: GFIndex];  IMPIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO IMPRecord;  IMPNull: IMPIndex = LAST[IMPIndex];  -- Export Table  EXPRecord: TYPE = --MACHINE DEPENDENT-- RECORD [    name: NameRecord,    size: [0..377b],    port: Portable,    namedInstance, typeExported: BOOLEAN,    file: FTIndex,    links: ARRAY [0..0) OF Link];  EXPIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO EXPRecord;  EXPNull: EXPIndex = LAST[EXPIndex];  -- Entry Vector Table  ENRecord: TYPE = RECORD [     nEntries: CARDINAL, initialPC: ARRAY [0..0) OF PrincOps.BytePC];  ENIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO ENRecord;  ENNull: ENIndex = LAST[ENIndex];  -- Segment Table  SegClass: TYPE = {code, symbols, acMap, other};  SGRecord: TYPE = RECORD [    file: FTIndex, base: CARDINAL,     pages: [0..256), extraPages: [0..64), class: SegClass];  SGIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO SGRecord;  SGNull: SGIndex = LAST[SGIndex];  -- File Table  FTRecord: TYPE = RECORD [name: NameRecord, version: VersionStamp];  FTIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO FTRecord;  FTNull: FTIndex = LAST[FTIndex];  FTSelf: FTIndex = LAST[FTIndex] - 1;  -- Space Table  SPRecord: TYPE = --MACHINE DEPENDENT-- RECORD [    seg: SGIndex,    name: NameRecord,    length: CARDINAL, spaces: ARRAY [0..0) OF SpaceID];  SpaceID: TYPE = RECORD [    name: NameRecord, resident: BOOLEAN, offset: [0..256), pages: [1..128]];  SPIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO SPRecord;  SPNull: SPIndex = LAST[SPIndex];  -- Frame Pack Table  FPRecord: TYPE = --MACHINE DEPENDENT-- RECORD [    name: NameRecord, length: CARDINAL, modules: ARRAY [0..0) OF MTIndex];  FPIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO FPRecord;  FPNull: FPIndex = LAST[FPIndex];  -- Type Table  TYPRecord: TYPE = RECORD [version: VersionStamp, id: RECORD [UNSPECIFIED]];  TYPIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO TYPRecord;  TYPNull: TYPIndex = LAST[TYPIndex];  -- Type Map Table  TMRecord: TYPE = RECORD [    version: VersionStamp, offset: CARDINAL, map: TYPIndex];  TMIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO TMRecord;  TMNull: TMIndex = LAST[TMIndex];  -- Links  LinkTag: TYPE = {procedure, signal, variable, type};    GFIndex: TYPE = [0..37777B];  Link: TYPE = MACHINE DEPENDENT RECORD [    rep(0): SELECT tag(0:0..1): LinkTag FROM      procedure => [gfi(0:2..15): GFIndex, ep(1): CARDINAL],      signal => [gfi(0:2..15): GFIndex, index(1): CARDINAL],      variable => [gfi(0:2..15): GFIndex, offset(1): CARDINAL],      type => [fill(0:2..15): [0..37777B], typeID(1): TYPIndex],      ENDCASE];  LinkFrag: TYPE = RECORD [frag: SEQUENCE length: NAT OF Link];  NullLink, nullLink: Link = [procedure[0, 0]];  UnboundLink, unboundLink: Link = [variable[0, 0]];  LFIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO LinkFrag;  LFNull: LFIndex = LAST[LFIndex];  -- Atoms  ATRecord: TYPE = MACHINE DEPENDENT RECORD [    offset: CARDINAL, -- in global frame    atom: SEQUENCE nAtoms: CARDINAL OF NameRecord]; -- in Atom Printname table      ATIndex: TYPE = Table.Base RELATIVE POINTER [0..tLimit] TO ATRecord;  ATNull: ATIndex = LAST[ATIndex];  }.
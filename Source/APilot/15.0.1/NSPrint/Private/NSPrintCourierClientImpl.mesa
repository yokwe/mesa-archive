-- File: NSPrintCourierClientImpl.mesa - last edit:-- AOF                 27-Jul-87 17:35:42-- Beeley              15-Nov-82 17:46:51-- Johnsson            19-Apr-83 17:59:28-- Courier client stub.-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Courier USING [    Arguments, Call, Create, Delete, Error, ErrorCode, Handle,    RemoteErrorSignalled, SystemElement, VersionMismatch],  NSDataStream USING [    AnnounceStream, CancelTicket, Handle, OperateOnSource,    Source, SourceStream, Ticket,    Register],  Stream USING [Handle],  NSPrint USING [    PrintAttribute, PrintAttributes, PrinterProperties, PrinterStatus,    PrintOptions, RequestID, RequestStatus, Error, ErrorRecord, ErrorType,    UndefinedProblem, ConnectionProblem, TransferProblem],  NSPrintCourier USING [    DescribePrintArguments, DescribePrintResults, PrintArguments, ProcedureType,    DescribePrinterPropertiesResults, DescribePrinterStatusResults,    DescribePrintRequestStatusArguments, DescribePrintRequestStatusResults,    DescribeUndefinedError, DescribeConnectionError, DescribeTransferError,    ErrorIndex, programNumber, versionNumber, zone],  System USING [NetworkAddress];NSPrintCourierClientImpl: PROGRAM  IMPORTS Courier, NSDataStream, NSPrint, NSPrintCourier  EXPORTS NSPrint =  BEGIN    Error: PUBLIC ERROR [why: NSPrint.ErrorRecord] = CODE;    xlateProc: PROC[p: NSPrintCourier.ProcedureType] RETURNS[CARDINAL] = INLINE    {RETURN[LOOPHOLE[p]]};  xlateError: ARRAY NSPrintCourier.ErrorIndex OF NSPrint.ErrorType = [    busy, insufficientSpoolSpace, invalidPrintParameters, masterTooLarge,    mediumUnavailable, serviceUnavailable, spoolingDisabled, spoolingQueueFull,    systemError, tooManyClients, undefinedError, connectionError, transferError];  --IMPLEMENT THE INTERFACE      GetPrinterProperties: PUBLIC PROC[server: System.NetworkAddress]       RETURNS [properties: NSPrint.PrinterProperties]=    BEGIN    getPrinterProperties: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: xlateProc[getPrinterProperties],        results: [@properties, NSPrintCourier.DescribePrinterPropertiesResults]];      END;    SignalCatcher[server, getPrinterProperties];    END; --GetPrinterProperties    GetPrintRequestStatus: PUBLIC PROC [    printRequestID: NSPrint.RequestID, systemElement: System.NetworkAddress]    RETURNS [status: NSPrint.RequestStatus] =    BEGIN    getPrintRequestStatus: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: xlateProc[getPrintRequestStatus],	arguments: [	  @printRequestID, NSPrintCourier.DescribePrintRequestStatusArguments],        results: [@status, NSPrintCourier.DescribePrintRequestStatusResults]];      END;    SignalCatcher[systemElement, getPrintRequestStatus];    END; --GetPrintRequestStatus    GetPrinterStatus: PUBLIC PROC[server: System.NetworkAddress]    RETURNS [status: NSPrint.PrinterStatus] =    BEGIN    getPrinterStatus: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: xlateProc[getPrinterStatus],        results: [@status, NSPrintCourier.DescribePrinterStatusResults]];      END;    SignalCatcher[server, getPrinterStatus];    END; --PrinterStatus  Print: PUBLIC PROCEDURE [    master: NSDataStream.Source,    printAttributes: NSPrint.PrintAttributes,    printOptions: NSPrint.PrintOptions,    systemElement: System.NetworkAddress]    RETURNS [printRequestID: NSPrint.RequestID] =    BEGIN    SourceProc: PROC [source: NSDataStream.SourceStream] =      BEGIN      ENABLE	BEGIN	Courier.RemoteErrorSignalled =>	  BEGIN	  nsPrintError ¬ ProcessRemoteError[errorNumber, arguments];	  errored ¬ TRUE;	  CONTINUE;	  END;	Courier.Error =>	  BEGIN	  errored ¬ TRUE;	  nsPrintError ¬ [courier[errorCode]];	  NSDataStream.CancelTicket[arguments.master, cH];	  CONTINUE;	  END;	END;      arguments ¬ [        NSDataStream.Register[source, systemElement, cH],	printAttributes, printOptions];      [] ¬ Courier.Call[	cH: cH, procedureNumber: xlateProc[print],	arguments: [@arguments, NSPrintCourier.DescribePrintArguments],	results: [@printRequestID, NSPrintCourier.DescribePrintResults],	streamCheckoutProc: NSDataStream.AnnounceStream];      END;  --SourceProc    PrintProc: PROC[ch: Courier.Handle] = {      cH ¬ ch; NSDataStream.OperateOnSource[master, SourceProc]};    cH: Courier.Handle;    nsPrintError: NSPrint.ErrorRecord;    arguments: NSPrintCourier.PrintArguments;    errored: BOOLEAN ¬ FALSE;    SignalCatcher[systemElement, PrintProc];    IF errored THEN ERROR NSPrint.Error[nsPrintError];    END;  --Print      ProcessRemoteError: PROC [errorNumber: CARDINAL, arguments: Courier.Arguments]    RETURNS [error: NSPrint.ErrorRecord] =    BEGIN    errorType: NSPrint.ErrorType;    IF errorNumber ~IN NSPrintCourier.ErrorIndex THEN ERROR;    errorType ¬ xlateError[errorNumber];    SELECT errorType FROM      busy => error ¬ [busy[]];      insufficientSpoolSpace => error ¬ [insufficientSpoolSpace[]];      invalidPrintParameters => error ¬ [invalidPrintParameters[]];      masterTooLarge => error ¬ [masterTooLarge[]];      mediumUnavailable => error ¬ [mediumUnavailable[]];      serviceUnavailable => error ¬ [serviceUnavailable[]];      spoolingDisabled => error ¬ [spoolingDisabled[]];      spoolingQueueFull => error ¬ [spoolingQueueFull[]];      systemError => error ¬ [systemError[]];      tooManyClients => error ¬ [tooManyClients[]];      undefinedError =>        BEGIN	undefined: NSPrint.UndefinedProblem;	arguments[[@undefined, NSPrintCourier.DescribeUndefinedError]];	error ¬ [undefinedError[undefined]];	END;      connectionError =>        BEGIN	connection: NSPrint.ConnectionProblem;	arguments[[@connection, NSPrintCourier.DescribeConnectionError]];	error ¬ [connectionError[connection]]; 	END;      transferError =>        BEGIN	transfer: NSPrint.TransferProblem;	arguments[[@transfer, NSPrintCourier.DescribeTransferError]];	error ¬ [transferError[transfer]];	END;      ENDCASE;    END;  --ProcessRemoteError    SignalCatcher: PROC [    server: Courier.SystemElement, proc: PROC[cH: Courier.Handle]] =    BEGIN    error: NSPrint.ErrorRecord;    cH: Courier.Handle ¬ Courier.Create[      remote: server,      programNumber: NSPrintCourier.programNumber,      versionNumber: NSPrintCourier.versionNumber,      zone: NSPrintCourier.zone,      classOfService: transactional];    BEGIN    ENABLE      BEGIN      Courier.VersionMismatch =>        {error ¬ [courier[noSuchProgramExport]]; GOTO delete};      Courier.Error => {error ¬ [courier[errorCode]]; GOTO delete};      UNWIND => REJECT;  --don't do anything with that here      Courier.RemoteErrorSignalled => {        error ¬ ProcessRemoteError[errorNumber, arguments]; GOTO delete};      END;    proc[cH];    Courier.Delete[cH];    EXITS    delete => {Courier.Delete[cH]; ERROR NSPrint.Error[error]};    END;    END;  --SignalCatcher     END.... -- NSPrintCourierClientImpl    LOG16-Sep-82 10:59:50 - AOF - Created file.20-Sep-82 11:17:39 - AOF - Process remote signals.22-Sep-82 15:08:45 - AOF - Correct code in PrintStream and removed PrintFile.30-Sep-82  8:18:46 - Alfvin - Renamed and removed PrintStream.14-Oct-82 23:27:58 - Beeley - Added Error=CODE.19-Oct-82 20:36:59 - Beeley - Corrected PROGRAM name, was NSPrintClientImpl 4-Nov-82 11:16:11 - Beeley - Added catch and rename for Courier.VersionMismatch in SignalCatcher.15-Nov-82 17:47:36 - Beeley - Changed Courier.Call.timeoutInSeconds to use timeout variable (set to 40).15-Nov-82 17:47:36 - NS - Changed Courier.Call.timeoutInSeconds to use timeout variable (set to LAST[CARD]).27-Jul-87 17:34:45 - AOF - Disabled Courier timeouts entirely.
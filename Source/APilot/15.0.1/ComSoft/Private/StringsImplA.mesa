-- Copyright (C) 1981, 1982, 1983, 1986, 1987  by Xerox Corporation. All rights reserved. -- StringsImplA.mesa  Edited by:--   SXW   ,	13-Jul-81 14:57:17--   JGS    ,	11-Jan-83 16:15:14--   MXS     ,	May 8, 1980  4:04 PM--   FXH    ,	October 16, 1980  3:45 PM--   LXR    ,	 3-Nov-82 10:22:04--   PXK    	 3-Oct-82 16:26:40--   CXH   	 27-Dec-82 17:03:35--   RXJ     	  6-Jul-83 23:37:31--   KEK	24-Jan-86 12:54:22 Misc AR fixes, primarily error checking. actually, back out of all but "IF from = NIL THEN RETURN" in AppendStringAndGrow... Sigh!--   CAJ     	 7-Feb-87 12:03:24  Comment out owner checking.--   RSV        23-Mar-87 10:56:05  Just fixed up commented out parts to do ownerChecking correct for MDS relief if we ever uncomment them.DIRECTORY  Ascii USING [SP, TAB],  ByteBlt USING [ByteBlt],  FrameExtras USING [LongGFToGFTHandle],--  Heap USING [OwnerChecking],  Inline USING [BITOR, LongCOPY],  PrincOpsExtras2 USING [GFTHandle],--  Runtime USING [GetCaller],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  String USING [EmptyString, FreeString, MakeString, SubString];StringsImplA: PROGRAM  IMPORTS ByteBlt, FrameExtras, Inline, «Runtime,» SpecialRuntimeExtras, String   EXPORTS String = PUBLIC  BEGIN OPEN String;  StringBoundsFault: SIGNAL [s: LONG STRING] RETURNS [ns: LONG STRING] = CODE;  AppendChar: PROCEDURE [s: LONG STRING, c: CHARACTER] =    BEGIN    IF s = NIL THEN RETURN;    UNTIL s.length < s.maxlength DO       temp: LONG STRING ¬ SIGNAL StringBoundsFault[s];       IF temp = NIL THEN RETURN;      s ¬ temp;      ENDLOOP;    s[s.length] ¬ c;    s.length ¬ s.length + 1;    RETURN    END;  AppendString: PROCEDURE [to: LONG STRING, from: LONG STRING] =    BEGIN    n: CARDINAL;    IF to = NIL OR from = NIL THEN RETURN;    WHILE from.length + to.length > to.maxlength DO      temp: LONG STRING ¬ SIGNAL StringBoundsFault[to];       IF temp = NIL THEN EXIT; -- just fill in as much as fits      to ¬ temp;      ENDLOOP;    n ¬ MIN[from.length, LOOPHOLE[to.maxlength - to.length, CARDINAL]];    IF to.length MOD 2 = 0 THEN      Inline.LongCOPY[        from: @from.text,	to: to + SIZE[StringBody[to.length]],	nwords: SIZE[StringBody[n]]-SIZE[StringBody[0]]]    ELSE [] ¬ ByteBlt.ByteBlt[      from: [        blockPointer: LOOPHOLE[@from.text], 	startIndex: 0,	stopIndexPlusOne: n],      to: [        blockPointer: LOOPHOLE[@to.text], 	startIndex: to.length, 	stopIndexPlusOne: to.length + n]];    to.length ¬ to.length + n;    RETURN    END;  Equal: PROCEDURE [s1, s2: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    i: CARDINAL;    IF s1 = NIL AND s2 = NIL THEN RETURN[TRUE];    IF s1 = NIL OR s2 = NIL OR s1.length # s2.length THEN RETURN[FALSE];    FOR i IN [0..s1.length) DO IF s1[i] # s2[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE]    END;  Equivalent: PROCEDURE [s1, s2: LONG STRING]    RETURNS [BOOLEAN] =    BEGIN OPEN Inline;    i: CARDINAL;    casebit: WORD = 40B;    IF s1 = NIL AND s2 = NIL THEN RETURN[TRUE];    IF s1 = NIL OR s2 = NIL OR s1.length # s2.length THEN RETURN[FALSE];    FOR i IN [0..s1.length) DO      IF BITOR[s1[i], casebit] # BITOR[s2[i], casebit] THEN RETURN[FALSE];      ENDLOOP;    RETURN[TRUE]    END;  AppendSubString: PROCEDURE [to: LONG STRING, from: SubString] =    BEGIN    i, j, n: CARDINAL;    s: LONG STRING ¬ from.base;    IF to = NIL OR s = NIL THEN RETURN;    WHILE from.length + to.length > to.maxlength DO      temp: LONG STRING ¬ SIGNAL StringBoundsFault[to];       IF temp = NIL THEN EXIT; -- just fill in as much as fits      to ¬ temp;      ENDLOOP;    i ¬ to.length;    j ¬ from.offset;    n ¬ MIN[from.length, LOOPHOLE[to.maxlength - to.length, CARDINAL]];    WHILE n > 0 DO to[i] ¬ s[j]; i ¬ i + 1; j ¬ j + 1; n ¬ n - 1; ENDLOOP;    to.length ¬ i;    RETURN    END;  EqualSubString: PROCEDURE [s1, s2: SubString]    RETURNS [BOOLEAN] =    BEGIN    i1, i2, n: CARDINAL;    b1, b2: LONG STRING;    IF s1.length # s2.length THEN RETURN[FALSE];    b1 ¬ s1.base;    i1 ¬ s1.offset;    b2 ¬ s2.base;    i2 ¬ s2.offset;    FOR n ¬ s1.length, n - 1 WHILE n > 0 DO      IF b1[i1] # b2[i2] THEN RETURN[FALSE]; i1 ¬ i1 + 1; i2 ¬ i2 + 1; ENDLOOP;    RETURN[TRUE]    END;  EquivalentSubString: PROCEDURE [s1, s2: SubString]    RETURNS [BOOLEAN] =    BEGIN OPEN Inline;    casebit: WORD = 40B;    i1, i2, n: CARDINAL;    b1, b2: LONG STRING;    IF s1.length # s2.length THEN RETURN[FALSE];    b1 ¬ s1.base;    i1 ¬ s1.offset;    b2 ¬ s2.base;    i2 ¬ s2.offset;    FOR n ¬ s1.length, n - 1 WHILE n > 0 DO      IF BITOR[b1[i1], casebit] # BITOR[b2[i2], casebit] THEN RETURN[FALSE];      i1 ¬ i1 + 1;      i2 ¬ i2 + 1;      ENDLOOP;    RETURN[TRUE]    END;  Copy: PROCEDURE [to, from: LONG STRING] = {    n: CARDINAL;    IF to = NIL OR from = NIL THEN RETURN;    WHILE from.length > to.maxlength DO      temp: LONG STRING ¬ SIGNAL StringBoundsFault[to];       IF temp = NIL THEN EXIT; -- just fill in as much as fits      to ¬ temp;      ENDLOOP;    n ¬ MIN[from.length, to.maxlength];    Inline.LongCOPY[      from: @from.text,      to: @to.text,      nwords: SIZE[StringBody[n]]-SIZE[StringBody[0]]];    to.length ¬ n;    RETURN};  DeleteSubString: PROCEDURE [s: SubString] =    BEGIN    b: LONG STRING = s.base;    i: CARDINAL ¬ s.offset;    j: CARDINAL ¬ i + s.length;    WHILE j < b.length DO b[i] ¬ b[j]; i ¬ i + 1; j ¬ j + 1; ENDLOOP;    b.length ¬ i;    RETURN    END;  AppendCharAndGrow: PROCEDURE [    to: LONG POINTER TO LONG STRING, c: CHARACTER, z: UNCOUNTED ZONE] =     BEGIN    extra: CARDINAL ¬ 6;    temp: LONG STRING ¬ to­;    IF temp = NIL OR temp.length = temp.maxlength THEN {      temp ¬ CopyToNewString[temp, z, extra];      FreeString[z, to­];      to­ ¬ temp};--    IF Heap.OwnerChecking[z] THEN SetOwner[temp, GetGF[Runtime.GetCaller[]]]};    temp[temp.length] ¬ c;    temp.length ¬ temp.length + 1;    END;      AppendExtensionIfNeeded: PROCEDURE [    to: LONG POINTER TO LONG STRING, extension: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [done: BOOLEAN] =    BEGIN    i, nCharsToAdd: CARDINAL;    temp: LONG STRING ¬ to­;    done ¬ FALSE;    IF EmptyString[temp] THEN RETURN[FALSE];    FOR i DECREASING IN [1..temp.length) DO      SELECT temp[i] FROM        '., Ascii.SP, Ascii.TAB => temp.length ¬ temp.length - 1;        ENDCASE => EXIT;      ENDLOOP;    FOR i DECREASING IN [0..temp.length) DO      IF temp[i] = '. THEN RETURN[FALSE];      ENDLOOP;    nCharsToAdd ¬ extension.length + (IF extension[0] # '. THEN 1 ELSE 0);    IF temp.length + nCharsToAdd > temp.maxlength THEN  {      temp ¬ CopyToNewString[temp, z, nCharsToAdd];      FreeString[z, to­];      to­ ¬ temp};--    IF Heap.OwnerChecking[z] THEN SetOwner[temp, GetGF[Runtime.GetCaller[]]]};    IF extension[0] # '. THEN AppendChar[temp, '.];    AppendString[temp, extension];    done ¬ TRUE;    END;      AppendStringAndGrow: PROCEDURE [    to: LONG POINTER TO LONG STRING, from: LONG STRING, z: UNCOUNTED ZONE,    extra: CARDINAL ¬ 0] =    BEGIN    temp: LONG STRING ¬ to­;    IF from = NIL THEN RETURN;    IF temp = NIL OR temp.length + from.length >= temp.maxlength THEN {      temp ¬ CopyToNewString[temp, z, from.length + extra];      FreeString[z, to­];      to­ ¬ temp};--    IF Heap.OwnerChecking[z] THEN SetOwner[temp, GetGF[Runtime.GetCaller[]]]};    AppendString[to: temp, from: from];    END;      Replace: PROCEDURE [    to: LONG POINTER TO LONG STRING, from: LONG STRING, z: UNCOUNTED ZONE] =    BEGIN    IF to = NIL THEN RETURN[];    IF to­ # NIL THEN {FreeString[z, to­]; to­ ¬ NIL};    IF from # NIL THEN to­ ¬ CopyToNewString[from, z];--  IF Heap.OwnerChecking[z] THEN SetOwner[to­, GetGF[Runtime.GetCaller[]]];    RETURN    END;  CopyToNewString: PROCEDURE [    s: LONG STRING, z: UNCOUNTED ZONE, longer: CARDINAL ¬ 0]    RETURNS [newS: LONG STRING] =    BEGIN    l: CARDINAL = (IF s = NIL THEN 0 ELSE s.length);    IF s = NIL AND longer = 0 THEN RETURN[NIL];    newS ¬ MakeString[z, l + longer];    Inline.LongCOPY[      from: @s.text,      to: @newS.text,      nwords: SIZE[StringBody[l]]-SIZE[StringBody[0]]];    newS.length ¬ l;--  IF Heap.OwnerChecking[z] THEN--    LOOPHOLE[(newS - 1), LONG POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    END;      ExpandString: PROCEDURE [    s: LONG POINTER TO LONG STRING, longer: CARDINAL, z: UNCOUNTED ZONE] =        BEGIN    newS: LONG STRING ¬ CopyToNewString[      s­, z, longer + (IF s­ = NIL THEN 0 ELSE s.maxlength - s.length)];    FreeString[z, s­];    s­ ¬ newS;--  IF Heap.OwnerChecking[z] THEN--    LOOPHOLE[(newS - 1), LONG POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    END;      GetGF: PRIVATE PROCEDURE [p: PROGRAM]    RETURNS [PrincOpsExtras2.GFTHandle] = INLINE {    RETURN[FrameExtras.LongGFToGFTHandle[      SpecialRuntimeExtras.GlobalFrameFromProgram[p]]]};  SetOwner: PRIVATE PROCEDURE [    node: LONG STRING, owner: UNSPECIFIED] = INLINE {    IF node # NIL THEN LOOPHOLE[node - 1, LONG POINTER]­ ¬ owner};  END....
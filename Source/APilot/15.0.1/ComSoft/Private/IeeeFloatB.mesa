-- Copyright (C) 1980, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- IeeeFloatB.mesa-- Last Modified:  7-Jul-83  0:02:06-- Mesa implementation of floating point opsDIRECTORY  Ieee,  Inline USING [BITAND, BITOR, LowHalf],  Mopcodes USING [zDCMP],  Real,  RealOps;IeeeFloatB: PROGRAM IMPORTS Ieee, Inline, Real EXPORTS Ieee, RealOps =  BEGIN OPEN Ieee, Real, RealOps;  FComp: PUBLIC PROC [a, b: REAL, m: Mode] RETURNS [INTEGER] = {    x, y: Ieee.Ext;    {    fpmode ¬ m;    thisTimeExceptions ¬ Real.NoExceptions;    x ¬ Ieee.Unpack[a];    y ¬ Ieee.Unpack[b];    IF Ieee.BitOn[funny, Inline.BITOR[x.det, y.det]] THEN      SELECT TRUE FROM	x.det.type = nan => GOTO InvX;	y.det.type = nan => GOTO InvY;	x.det.type # infinity AND y.det.type # infinity => NULL;	x.det.type = infinity AND y.det.type = infinity =>	  IF fpmode.im = projective OR x.det.sign = y.det.sign THEN GOTO Equal	  ELSE GOTO XSign;	fpmode.im = projective => GOTO InvX;	x.det.type = infinity => GOTO XSign;	y.det.type = infinity => GOTO YSign;	ENDCASE => ERROR    ELSE      SELECT Ieee.NormalType[x.det, y.det] FROM	TNnn => NULL;	TNnz => GOTO XSign;	TNzn => GOTO YSign;	TNzz => GOTO Equal;	ENDCASE => ERROR;    IF x.det.sign # y.det.sign THEN GOTO XSign;    IF x.det.sign THEN      BEGIN      LOOPHOLE[a, LONG INTEGER] ¬ MagicLI - LN[a].li;      LOOPHOLE[b, LONG INTEGER] ¬ MagicLI - LN[b].li;      END;    EXITS      XSign => RETURN[IF x.det.sign THEN -1 ELSE 1];      YSign => RETURN[IF y.det.sign THEN 1 ELSE -1];      Equal => RETURN[0];      InvX => InvalidAndDie[@x];      InvY => InvalidAndDie[@y];    };    RETURN[zFComp[a, b]];    };  zFComp: PROC [a, b: REAL] RETURNS [INTEGER] = MACHINE CODE {Mopcodes.zDCMP; };    Float: PUBLIC PROC [a: LONG INTEGER, m: RealOps.Mode] RETURNS [REAL] = {      x: Ieee.Ext;      fpmode ¬ m;      thisTimeExceptions ¬ Real.NoExceptions;      IF a = 0 THEN RETURN[PlusZero];      x.det.sign ¬ a < 0;      x.frac.li ¬ IF x.det.sign THEN -a ELSE a;      x.det.sticky ¬ FALSE;      x.det.type ¬ normal;      x.exp ¬ 31;      Ieee.PostNormalize[@x];      Ieee.Round[@x];      RETURN[Ieee.Pack[@x]];      };    RoundLI: PUBLIC PROC [a: REAL, m: RealOps.Mode] RETURNS [LONG INTEGER] = {      x: Ieee.Ext;      fli: LONG INTEGER;      inv, ov: BOOLEAN;      fpmode ¬ m;      thisTimeExceptions ¬ Real.NoExceptions;      x ¬ Unpack[a];      [v: fli, invalid: inv, overflow: ov] ¬ FixExtended[x, fpmode.round];      IF inv THEN InvalidAndDie[@x];      IF ov THEN {	Ieee.SetFixOverflow[];	IF fpmode.traps[fixOverflow] THEN {	  p: LONG POINTER TO Extended;	  Ieee.CVExtended[@x];	  p ¬ SIGNAL Real.RealException[thisTimeExceptions, @myExtended];	  IF p # NIL THEN RETURN[LOOPHOLE[p­.frac, LONG INTEGER]];	  };	};      RETURN[fli];      };    FixExtended: PUBLIC PROC [z: Ieee.Ext, rmode: RealOps.RoundingMode]      RETURNS [v: LONG INTEGER, invalid, overflow: BOOLEAN] = {      grs: INTEGER;      {      SELECT z.det.type FROM	nan => GOTO Invalid;	infinity => GOTO Invalid;	zero => GOTO Zero;	normal => NULL;	ENDCASE => ERROR;      IF z.exp > 30 THEN GOTO Overflow;      {      IF z.exp = 30 THEN {	grs ¬ IF Ieee.BitOn[z.frac.lowbits, 1] THEN 4 ELSE 0;	z.frac.lc ¬ Ieee.RShift[z.frac.lc];	}      ELSE {	Ieee.DeNormalize[@z, z.exp - 29];	grs ¬ Inline.BITAND[z.frac.lowbits, 3B];	grs ¬ grs + grs;	z.frac.lc ¬ Ieee.LongShift[z.frac.lc, -2];	};      IF z.det.sticky THEN grs ¬ grs + 1;      SELECT rmode FROM	rn => {	  IF grs > 4 OR (grs = 4 AND Ieee.BitOn[z.frac.lowbits, 1]) THEN	    GOTO Plus1;	  };	rz => NULL;	rm => IF z.det.sign THEN GOTO Plus1;	rp => IF NOT z.det.sign THEN GOTO Plus1;	ENDCASE => ERROR;      EXITS	Plus1 => {	  z.frac.lc ¬ z.frac.lc + 1;	  IF Ieee.BitOn[z.frac.highbits, HiBit] THEN GOTO Overflow;	  };      };      EXITS	Overflow => {	  IF z.det.sign AND z.frac.li = MagicLI THEN	    RETURN[v: MagicLI, invalid: FALSE, overflow: FALSE];	  -- returns positive without looking at sign	  z.frac.li ¬ Ieee.LongShift[z.frac.li, z.exp - 30];	  z.frac.highbits ¬ Inline.BITAND[NotHiBit, z.frac.highbits];	  RETURN[v: z.frac.li, invalid: FALSE, overflow: TRUE];	  };	Invalid => RETURN[v: z.frac.li, invalid: TRUE, overflow: FALSE];	Zero => RETURN[v: 0, invalid: FALSE, overflow: FALSE];      };      IF z.det.sign THEN z.frac.li ¬ -z.frac.li;      RETURN[v: z.frac.li, invalid: FALSE, overflow: FALSE];      };    InvalidAndDie: PUBLIC PROC [z: POINTER TO Ieee.Ext] = {      Ieee.SetInvalidOperation[];      Ieee.CVExtended[z];      [] ¬ SIGNAL Real.RealException[thisTimeExceptions, @myExtended];      ERROR Real.RealError;      };    RoundI: PUBLIC PROC [a: REAL, m: RealOps.Mode] RETURNS [INTEGER] = {      x: Ieee.Ext;      fli: LONG INTEGER;      fi: INTEGER;      inv, ov: BOOLEAN;      fpmode ¬ m;      thisTimeExceptions ¬ NoExceptions;      x ¬ Ieee.Unpack[a];      [v: fli, invalid: inv, overflow: ov] ¬ FixExtended[x, fpmode.round];      IF inv THEN InvalidAndDie[@x];      IF ov OR fli NOT IN [FIRST[INTEGER]..LAST[INTEGER]] THEN {	Ieee.SetFixOverflow[];	IF fpmode.traps[fixOverflow] THEN {	  p: LONG POINTER TO Real.Extended;	  Ieee.CVExtended[@x];	  p ¬ SIGNAL Real.RealException[thisTimeExceptions, @myExtended];	  IF p # NIL THEN RETURN[Inline.LowHalf[p­.frac]];	  }; -- FixExtended returns low 31 bits of integer part of fraction	IF NOT ov AND x.det.sign THEN fli ¬ -fli;	fi ¬ Inline.BITAND[NotHiBit, Inline.LowHalf[fli]];	}      ELSE fi ¬ Inline.LowHalf[fli];      RETURN[fi];      };    RoundC: PUBLIC PROC [a: REAL, m: RealOps.Mode] RETURNS [CARDINAL] = {      x: Ieee.Ext;      fli: LONG INTEGER;      fc: CARDINAL;      inv, ov: BOOLEAN;      fpmode ¬ m;      thisTimeExceptions ¬ Real.NoExceptions;      x ¬ Unpack[a];      [v: fli, invalid: inv, overflow: ov] ¬ FixExtended[x, fpmode.round];      IF inv THEN InvalidAndDie[@x];      IF ov OR fli NOT IN [FIRST[CARDINAL]..LAST[CARDINAL]] THEN {	Ieee.SetFixOverflow[];	IF fpmode.traps[fixOverflow] THEN {	  p: LONG POINTER TO Real.Extended;	  Ieee.CVExtended[@x];	  p ¬ SIGNAL Real.RealException[thisTimeExceptions, @myExtended];	  IF p # NIL THEN RETURN[Inline.LowHalf[p­.frac]];	  };	IF NOT ov AND x.det.sign THEN fli ¬ -fli;	};      fc ¬ Inline.LowHalf[fli];      RETURN[fc];      };    END.L. LXS    , July 12, 1980  11:13 PM, Rounds changed to return low order bits on RESUME.L. LXS    , August 12, 1980  12:05 PM, RoundI, RoundC fixed for negative arguments.August 25, 1980  4:05 PM, LStewart; formatting, shorten Float
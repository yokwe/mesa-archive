-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- SpaceCheckPack-- Revised by LNelson:		October 1, 1980  11:19 AM-- Revised by Forrest:		February 5, 1981  9:54 AM-- Revised by Daniels:		28-Jan-82 11:08:47-- Revised by Luniewski:	 7-Apr-83  9:36:39-- Revised by Johnsson:		17-May-83  8:32:36-- Owner: CharlieLevyDIRECTORY  Environment USING [PageCount, PageOffset],  Runtime USING [GetCaller],  PilotSwitches USING [heapOwnerChecking],  Space USING [    Access, Allocate, Class, Deallocate, GetMapUnitAttributes, Interval,    Life, Map, MDS, ReturnWait, ScratchMap, SwapUnitOption, Unmap, Usage,    virtualMemory, Window],  SpaceCheckDefs,  System USING [switches];SpaceCheckPack: MONITOR  IMPORTS Runtime, realSpace: Space, System EXPORTS Space, SpaceCheckDefs =  BEGIN OPEN SpaceCheckDefs;  -- Pack Data Structure:  -- GLOBAL DATA  bvDebug: BOOLEAN ¬ System.switches[PilotSwitches.heapOwnerChecking] = down; --this pack is a NOP if false  globalRec: GlobalRec ¬ [    cvSequenceGlobal: 0, bvRecordChildren: FALSE,    descFreeFirst: NIL, pageRecFirst: NIL, ctDescFree: 0,    descUsedFirst: NIL, descUsedLast: NIL, ctDescUsed: 0,    ctPage: ALL[0], ctPageForChecker: 0];  -- Signals and Errors:  SpaceCheckProblem: PRIVATE SIGNAL = CODE;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Public Operations  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  Allocate: PUBLIC PROC [    count: Environment.PageCount, within: Space.Interval,    base: Environment.PageOffset]    RETURNS [interval: Space.Interval] =    BEGIN    interval ¬ realSpace.Allocate[count, within, base]; --pass errors through     IF bvDebug THEN      BEGIN      spaceType: SpaceType =        (SELECT within FROM          realSpace.virtualMemory => vm,          realSpace.MDS[] => mds,          ENDCASE => child);      IF (spaceType#child OR globalRec.bvRecordChildren) THEN        EnterDesc[interval, within, spaceType];      END; --if bvDebug    END; -- of Allocate  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  Deallocate: PUBLIC PROCEDURE [interval: Space.Interval] =    BEGIN    realSpace.Deallocate[interval]; --pass on the call, pass through errors    IF bvDebug THEN DeleteDescriptor[interval];    END; -- of Delete    ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  Map: PUBLIC PROCEDURE [    window: Space.Window, usage: Space.Usage, class: Space.Class,    access: Space.Access, life: Space.Life,    swapUnits: Space.SwapUnitOption]    RETURNS [mapUnit: Space.Interval] =    BEGIN    mapUnit ¬ realSpace.Map[window, usage, class, access, life, swapUnits];    IF bvDebug THEN EnterDesc[mapUnit, realSpace.virtualMemory, vm];    END; -- of Map  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  Unmap: PUBLIC PROCEDURE [    pointer: LONG POINTER, returnWait: Space.ReturnWait]    RETURNS [nil: LONG POINTER] =    BEGIN    mapUnit: Space.Interval;    IF bvDebug THEN mapUnit ¬ realSpace.GetMapUnitAttributes[pointer].interval;    nil ¬ realSpace.Unmap[pointer, returnWait];    IF bvDebug THEN DeleteDescriptor[mapUnit];    END; -- of Unmap  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  UpdateSpaceOwner: PUBLIC ENTRY PROC [sp: LONG POINTER, newGF: PROGRAM] =    BEGIN    IF bvDebug THEN      FOR d: Desc ¬ globalRec.descUsedLast, d.descPrev UNTIL d = NIL DO        IF d.handle = sp THEN {d.gfhCaller ¬ newGF; EXIT};	ENDLOOP;    END; -- of UpdateSpaceOwner  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Private Operations  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  AddDescToFreeChain: INTERNAL PROCEDURE [desc: Desc] = INLINE    BEGIN    desc.descPrev ¬ NIL;    desc.descNext ¬ globalRec.descFreeFirst;    globalRec.descFreeFirst  ¬ desc;    globalRec.ctDescFree ¬ globalRec.ctDescFree + 1;    END; -- of AddDescToFreeChain  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  AddDescToUsedChain: INTERNAL PROCEDURE [desc: Desc] = INLINE    BEGIN --adds to end of used chain    desc.descNext ¬ NIL;    desc.descPrev ¬ globalRec.descUsedLast;    IF globalRec.descUsedFirst = NIL THEN globalRec.descUsedFirst ¬ desc    ELSE globalRec.descUsedLast.descNext ¬ desc;    globalRec.descUsedLast ¬ desc;    globalRec.ctDescUsed   ¬ globalRec.ctDescUsed + 1;    END; -- of AddDescToUsedChain  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  DeleteDescriptor: PRIVATE ENTRY PROC [interval: Space.Interval] = INLINE    BEGIN OPEN g: globalRec;    FOR d: Desc ¬ globalRec.descUsedLast, d.descPrev UNTIL d = NIL DO      IF d.handle = interval.pointer THEN {        g.ctPage[d.spaceType] ¬ g.ctPage[d.spaceType] - d.szPages;        DeLink[d]; AddDescToFreeChain[d]; EXIT}      ENDLOOP;    END; -- of DeleteDescriptor      ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  DeLink: INTERNAL PROCEDURE [desc: Desc] = INLINE    BEGIN OPEN g: globalRec;    IF g.descUsedFirst=desc THEN g.descUsedFirst ¬ desc.descNext    ELSE desc.descPrev.descNext ¬ desc.descNext;    IF g.descUsedLast=desc THEN g.descUsedLast ¬ desc.descPrev    ELSE desc.descNext.descPrev ¬ desc.descPrev;    g.ctDescUsed ¬ g.ctDescUsed - 1;    END; -- of DeLink      ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  EnterDesc: PRIVATE ENTRY PROC [    interval: Space.Interval, within: Space.Interval, spaceType: SpaceType] = INLINE    BEGIN OPEN g: globalRec;    caller:    PROGRAM = Runtime.GetCaller[];  -- works because INLINE    desc: Desc = GetFreeDesc[];    desc­ ¬ [      descNext: NULL, descPrev: NULL,      handle: interval.pointer, gfhCaller: caller,      cvSequence: g.cvSequenceGlobal,      szPages: SpaceSize[MIN[interval.count, LAST[SpaceSize]]],      bvScratch: NULL, spaceType: spaceType];    g.cvSequenceGlobal ¬ g.cvSequenceGlobal + 1;  --bump for the next guy    g.ctPage[spaceType] ¬ g.ctPage[spaceType] + desc.szPages;    AddDescToUsedChain[desc];    END; --of EnterDesc      ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  GetFreeDesc: INTERNAL PROCEDURE RETURNS [desc: Desc] = INLINE    BEGIN    WHILE (desc ¬ globalRec.descFreeFirst) = NIL DO      MoreDescriptors[] ENDLOOP;    globalRec.descFreeFirst ¬ desc.descNext;    globalRec.ctDescFree ¬ globalRec.ctDescFree - 1;    END; -- of GetFreeDesc  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  MoreDescriptors: INTERNAL PROCEDURE =    BEGIN OPEN g: globalRec;    pageRec: PageRec = realSpace.ScratchMap[1 !      UNWIND => REJECT; ANY => SIGNAL SpaceCheckProblem];    g.ctPageForChecker ¬ g.ctPageForChecker + 1;    pageRec.aqPageHeader.pageRecNext ¬ g.pageRecFirst;    g.pageRecFirst ¬ pageRec;    FOR ixDesc: CARDINAL IN [0..ctDescPerPage) DO      AddDescToFreeChain[@pageRec.descArray[ixDesc]] ENDLOOP;    END; -- of CreateMoreDescriptors  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Mainline Code  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- InitializeGlobalVariables: PROC = {};  -- InitializeGlobalVariables[];  END.  -- of SpaceCheckPackLOG	(date - person - action)March 1, 1980 - CharlieLevy - CreatedMarch 17, 1980 - CharlieLevy - Added better signal catching by Ron NewmanJune 20, 1980 - LNelson - Added PointerFaultTrap by Ron NewmanJuly 28, 1980 - LNelson - Move descriptors to VM for Star 14.2August 27, 1980 - LNelson - Deleted PointerFaultTrap by Ron Newman (Mokelumne has this problem fixed)October 1, 1980 - LNelson - Fix Mesa 6.0m compilation error for Star 15.2February 4, 1981 - FXH     - added UpdateOwner; rearranged code a bit12-Jan-82 - AXD     - use Runtime.GetCaller to avoid implementation dependency 7-Apr-83  9:36:36 AWL       Update to Klamath
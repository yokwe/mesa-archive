-- File: TimeImpl.mesa - last edit:-- AOF                  3-Nov-87 14:03:54-- RXJ                  6-Aug-81 14:59:27-- LXR                 21-Sep-82 14:49:05-- KAM                 18-Nov-83 12:04:53-- Copyright (C) 1981, 1982, 1983, 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Inline USING [DIVMOD, LDIVMOD, LongNumber],  String USING [AppendChar, AppendDecimal, AppendString],  System USING [GetGreenwichMeanTime, GetLocalTimeParameters,    GreenwichMeanTime, gmtEpoch, LocalTimeParameters, SecondsSinceEpoch],  Time USING [defaultTime, LTP, TimeZoneStandard, Unpacked, useSystem];TimeImpl: PROGRAM  IMPORTS Inline, String, System  EXPORTS Time =  BEGIN  baseYear: CARDINAL = 1968;  daysInFourYears: CARDINAL = 4*365+1;  startWeekDay: CARDINAL = 0; -- Jan. 1, 1968 was a Monday  TP: TYPE = RECORD [    beginDST, endDST: CARDINAL,    zone, zoneMinutes: INTEGER];  monthTable: ARRAY [0..12] OF CARDINAL =    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];  UP: TYPE = POINTER TO Time.Unpacked;    DivideTime: PROC[num: Inline.LongNumber, den: CARDINAL]    RETURNS [quotient: LONG CARDINAL, remainder: CARDINAL] =    BEGIN    t: CARDINAL;    q: Inline.LongNumber;    [q.highbits, t] ¬ Inline.LDIVMOD[num.highbits,0,den];    [q.lowbits, remainder] ¬ Inline.LDIVMOD[num.lowbits,t,den];    RETURN[quotient: q.lc, remainder: remainder]    END;  --DivideTime  Current: PUBLIC PROC RETURNS [System.GreenwichMeanTime] =    {RETURN[System.GetGreenwichMeanTime[]]};  --Current  TimeParameters: PROC[l: Time.LTP] RETURNS [p: TP] =    BEGIN    ltp: System.LocalTimeParameters;    WITH tp: l SELECT FROM       useThese => ltp ¬ tp.ltp;      useSystem => ltp ¬ System.GetLocalTimeParameters[];      ENDCASE;    p ¬ [ltp.beginDST, ltp.endDST, ltp.zone, ltp.zoneMinutes];    IF ltp.direction # west THEN      {p.zone ¬ -p.zone; p.zoneMinutes ¬ -p.zoneMinutes};    END;  --TimeParameters  Unpack: PUBLIC PROC[time: System.GreenwichMeanTime, ltp: Time.LTP]    RETURNS [unpacked: Time.Unpacked] =    BEGIN    month: CARDINAL ¬ 1;    seconds: LONG CARDINAL;    day4, day, yr4: CARDINAL;    t: Inline.LongNumber;    parms: TP = TimeParameters[ltp];    WITH tp: ltp SELECT FROM      useThese => unpacked.zone ¬ tp.ltp;      useSystem => unpacked.zone ¬ System.GetLocalTimeParameters[];      ENDCASE;    IF time = Time.defaultTime THEN time ¬ System.GetGreenwichMeanTime[];    seconds ¬ System.SecondsSinceEpoch[time];    [seconds, unpacked.second] ¬ DivideTime[[lc[seconds]], 60];    seconds ¬ seconds - parms.zoneMinutes; -- ignore underflow    [seconds, unpacked.minute] ¬ DivideTime[[lc[seconds]], 60];    unpacked.dst ¬ FALSE;  --we'll figure this out later    seconds ¬ seconds - parms.zone; -- ignore underflow    DO -- have to repeat if DST      [t.lc, unpacked.hour] ¬ DivideTime[[lc[seconds]], 24];      unpacked.weekday ¬ (t.lowbits + startWeekDay) MOD 7;      [yr4, day4] ¬ Inline.DIVMOD[t.lowbits, daysInFourYears];      IF day4 >= (365 + 31 + 29) THEN day4 ¬ (day4 - 31 - 29) / 365 + day4;      [day4, day] ¬ Inline.DIVMOD[day4, 366];      unpacked.year ¬ baseYear + yr4 * 4 + day4;      WHILE day >= monthTable[month] DO month ¬ month.SUCC; ENDLOOP;      unpacked.month ¬ month ¬ month.PRED;      unpacked.day ¬ day.SUCC - monthTable[month];      IF unpacked.dst OR ~DST[@unpacked, parms] THEN EXIT;      seconds ¬ seconds + 1;  --it's really not seconds      unpacked.dst ¬ TRUE;  --we believe this to be true      ENDLOOP;    RETURN    END;  --Unpack  DST: PROC[u: UP, parms: TP] RETURNS[yes: BOOLEAN ¬ TRUE] =    BEGIN      SELECT TRUE FROM	(parms.beginDST < parms.endDST) => --northern hemisphere	  BEGIN	  IF ~CheckDateGE[u, parms.beginDST, 2] OR	    (CheckDateGE[u, parms.endDST, 1] OR	    (u.dst AND CheckDateGE[u, parms.endDST, 2])) THEN RETURN[FALSE];	  END;	(parms.beginDST > parms.endDST) => --southern hemisphere	  BEGIN	  IF (CheckDateGE[u, parms.endDST, 1] OR	    (u.dst AND CheckDateGE[u, parms.endDST, 2])) AND	    ~CheckDateGE[u, parms.beginDST, 2] THEN RETURN[FALSE];	  END;	ENDCASE => RETURN[FALSE];  --equal is like no DST    END;  --DST  Invalid: PUBLIC ERROR = CODE;  Pack: PUBLIC PROC[unpacked: Time.Unpacked, useSystemLTP: BOOLEAN]    RETURNS [time: System.GreenwichMeanTime] =    BEGIN    yr3: [0..3];    t: Inline.LongNumber;    year, month, day, day1, hour, minute, second: CARDINAL;    parms: TP ¬ TimeParameters[      IF useSystemLTP THEN Time.useSystem ELSE [useThese[unpacked.zone]]];    [year: year, month: month, day: day, hour: hour, minute: minute,     second: second] ¬ unpacked;    IF (year ¬ year - baseYear) >= 136 OR      month >= 12 OR day ~IN[1..31] OR      hour >= 24 OR minute >= 60 OR      second >= 60 THEN ERROR Invalid;    yr3 ¬ year MOD 4;    IF day > LOOPHOLE[monthTable[month + 1] - monthTable[month], CARDINAL] OR      (month = 1 AND day = 29 AND yr3 # 0) THEN ERROR Invalid;    -- compute days this year in day1 allowing for leap year    day1 ¬ monthTable[month] + day - (IF yr3 # 0 AND month > 1 THEN 1 ELSE 0);    t ¬ Inline.LongNumber[num[      highbits: 0, lowbits: (year / 4) * daysInFourYears + yr3 * 365 + day1 - 1]];    IF yr3 # 0 THEN t.lowbits ¬ t.lowbits + 1; -- first of four year cycle is leap    unpacked.weekday ¬ (t.lowbits + startWeekDay) MOD 7;    IF DST[@unpacked, parms] THEN parms.zone ¬ parms.zone - 1;    time ¬ [System.gmtEpoch +     ((t.lc * 24 + hour + parms.zone) * 60 +     minute + parms.zoneMinutes) * 60 + second];    END;  --Pack  Append: PUBLIC PROC[    s: LONG STRING, unpacked: Time.Unpacked, zone: BOOLEAN,    zoneStandard: Time.TimeZoneStandard] =    BEGIN    m: CARDINAL;    p: CARDINAL ¬ s.length;    w2d: PROC[v: CARDINAL] =      BEGIN      d1, d2: CARDINAL;      [d1, d2] ¬ Inline.DIVMOD[v,10];      IF d1 # 0 THEN s[p] ¬ '0 + d1;      s[p+1] ¬ '0 + d2;      p ¬ p + 3;      END;  --w2d    String.AppendString[s, " 0-xxx-00  0:00:00"L];    w2d[unpacked.day];    m ¬ unpacked.month*3;    THROUGH [0..2] DO      s[p] ¬ ("JanFebMarAprMayJunJulAugSepOctNovDec"L)[m];      p ¬ p + 1; m ¬ m + 1;      ENDLOOP;    p ¬ p + 1;    w2d[unpacked.year MOD 100];    w2d[unpacked.hour];    w2d[unpacked.minute];    w2d[unpacked.second];    IF zone THEN AppendZone[s, @unpacked, zoneStandard];    RETURN    END;  --Append  AppendCurrent: PUBLIC PROC[s: LONG STRING, zone: BOOLEAN, ltp: Time.LTP,    zoneStandard: Time.TimeZoneStandard] =    {Append[s, Unpack[Time.defaultTime, ltp], zone, zoneStandard]};  AppendZone: PROC[    s: LONG STRING, u: UP, zoneStandard: Time.TimeZoneStandard] =    BEGIN    z: INTEGER;    USZones: TYPE = [4..10];    west: CHARACTER ¬ '-;    east: CHARACTER ¬ '+;    parms: TP = TimeParameters[[useThese[u.zone]]];    zones: PACKED ARRAY USZones OF CHARACTER = ['A,'E,'C,'M,'P,'Y,'H];    IF zoneStandard = Alto THEN {west ¬ '+; east ¬ '-};    String.AppendChar[s, ' ];    IF (z ¬ parms.zone) IN USZones AND parms.zoneMinutes = 0 THEN    -- Newfoundland/Labrador zone is checked for below      BEGIN      String.AppendChar[s, zones[z]];      String.AppendChar[s, IF u.dst THEN 'D ELSE 'S];      String.AppendChar[s,'T];      RETURN      END;    IF parms.zone = 3 AND parms.zoneMinutes = 30 THEN {      String.AppendString[s, IF u.dst THEN "NDT"L ELSE "NST"L]; RETURN};    IF u.dst THEN z ¬ z - 1;    IF z = 0 THEN String.AppendString[s, "GMT"L]    ELSE      BEGIN      String.AppendChar[s, IF z > 0 THEN west ELSE east];      String.AppendDecimal[s, ABS[z]];      IF (z ¬ ABS[parms.zoneMinutes]) # 0 THEN	BEGIN	String.AppendChar[s, ':];	IF z < 10 THEN String.AppendChar[s, '0];	String.AppendDecimal[s, z];	END;      END;    END;  --AppendZone  CheckDateGE: PROC[u: UP, dstDay, dstHour: INTEGER] RETURNS [BOOLEAN] =    BEGIN    weekday: INTEGER ¬ u.weekday;    day: INTEGER = monthTable[u.month] + u.day;    RETURN[      SELECT TRUE FROM        (day < dstDay - 6) => FALSE,	(day > dstDay) => TRUE,	(weekday = 6) => u.hour >= dstHour,	ENDCASE => day - weekday > dstDay - 6];    END;  --CheckDateGE  END.LOGJuly 15, 1979  3:33 PM	RXJ     	Create fileFebruary 9, 1980  1:44 PM	PXM    	Use System.GreenwichMeanTimeMarch 1, 1980  3:50 PM	RXJ     	Fix leapyear bug introduced in change of epochApril 17, 1980  11:14 AM	PXM    	Change default time for Unpack to gmtEpochSeptember 30, 1980  9:36 AM	RXJ     	Various bugsJanuary 28, 1981  4:40 PM	PXM    	Use System.GetLocalTimeParameters 2-Nov-87 18:25:21		AOF    	Southern hemisphere, et al
-- Copyright (C) 1981, 1982, 1983, 1987  by Xerox Corporation. All rights reserved. -- StorageImpl.mesa  Edited by--   SXW   	13-Jul-81 15:20:37--   BXX	22-Oct-81 14:58:17--   PXK    	Oct 8, 1980 1:37 PM--   FXH    	July 25, 1980  7:06PM--   JGS	19-Aug-81 11:57:37--   RXJ     	 6-Jul-83 23:35:10--   SXS   	10-Sep-81 15:33:22--   LXR    	22-Sep-82 11:42:55--   RSV        23-Mar-87 11:14:17  Do ownerChecking the mds relieved wayDIRECTORY  Ascii USING [SP, TAB],  Environment USING [wordsPerPage],  File USING [nullFile],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [Expand, GetAttributes, Prune, systemMDSZone, systemZone],  Inline USING [HighHalf, LongDiv, LowHalf],  PrincOpsExtras2 USING [GFTHandle],  Runtime USING [GetCaller],  Space USING [Map, Unmap],  SpecialRuntimeExtras USING [GlobalFrameFromProgram],  Storage USING [EmptyString, FreeStringNil, StringLength];StorageImpl: PROGRAM  IMPORTS FrameExtras, Heap, Inline, Runtime, Space, SpecialRuntimeExtras, Storage  EXPORTS Storage =  BEGIN  ownerChecking: BOOLEAN = Heap.GetAttributes[Heap.systemZone].ownerChecking;  PageSize: CARDINAL = Environment.wordsPerPage;  InvalidNode: PUBLIC ERROR [p: LONG POINTER] = CODE;  ZoneTooSmall: PUBLIC ERROR [p: LONG POINTER] = CODE;  WordType: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];  PagesForWords: PUBLIC PROCEDURE [nWords: CARDINAL] RETURNS [CARDINAL] =    BEGIN OPEN Environment;    RETURN[Inline.LongDiv[LONG[nWords] + wordsPerPage - 1, wordsPerPage]];    END;  Pages: PUBLIC PROCEDURE [npages: CARDINAL] RETURNS [base: LONG POINTER] =    BEGIN    RETURN [      Space.Map[        window: [File.nullFile, 0, npages], class: data, life: dead,	swapUnits: IF npages > 7 THEN [uniform[4]] ELSE [unitary[]]].pointer];    END;  Words: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [base: LONG POINTER] = {    RETURN[Pages[(nwords + PageSize - 1)/PageSize]]};  FreePages, FreeWords: PUBLIC PROCEDURE [base: LONG POINTER] =    BEGIN    [] ¬ Space.Unmap[base];    END;  -- management of the heap  Node: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [p: LONG POINTER] = {    p ¬ Heap.systemZone.NEW[WordType[nwords]];    IF ownerChecking THEN (p - 1)­ ¬ GetGF[Runtime.GetCaller[]]};  Free: PUBLIC PROCEDURE [p: LONG POINTER] = {    SELECT TRUE FROM      p = NIL => RETURN;      InMDS[p] => {        temp: POINTER ¬ Inline.LowHalf[p];	Heap.systemMDSZone.FREE[@temp]};      ENDCASE => Heap.systemZone.FREE[@p]};  InMDS: PROCEDURE [p: LONG POINTER] RETURNS [BOOLEAN] = {    lpInMDS: LONG POINTER = @p;    RETURN[Inline.HighHalf[p] = Inline.HighHalf[lpInMDS]]};  LocalString: PROCEDURE [nchars: CARDINAL] RETURNS [s: LONG STRING] = INLINE    {s ¬ Heap.systemZone.NEW[StringBody[nchars]]};  String: PUBLIC PROCEDURE [nchars: CARDINAL] RETURNS [s: LONG STRING] =    BEGIN    s ¬ LocalString[nchars];    IF ownerChecking THEN LOOPHOLE[(s - 1), LONG POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    RETURN    END;  CopyString: PUBLIC PROCEDURE [s: LONG STRING, longer: CARDINAL ¬ 0]    RETURNS [newS: LONG STRING] =    BEGIN    l: CARDINAL = (IF s = NIL THEN 0 ELSE s.length);    IF s = NIL AND longer = 0 THEN RETURN[NIL];    newS ¬ LocalString[l + longer];    FOR i: CARDINAL IN [0..l) DO newS[i] ¬ s[i] ENDLOOP;    newS.length ¬ l;    IF ownerChecking THEN      LOOPHOLE[(newS - 1), LONG POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    END;  ExpandString: PUBLIC PROCEDURE [    s: LONG POINTER TO LONG STRING, longer: CARDINAL ¬ 0] =    BEGIN    newS: LONG STRING ¬ CopyString[      s­, longer + (IF s­ = NIL THEN 0 ELSE s.maxlength - s.length)];    FreeString[s­];    s­ ¬ newS;    IF ownerChecking THEN      LOOPHOLE[(newS - 1), LONG POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    END;  FreeString: PUBLIC PROCEDURE [s: LONG STRING] = LOOPHOLE[Free];  Prune: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {    Heap.Prune[Heap.systemZone]; RETURN[TRUE]};  Expand: PUBLIC PROCEDURE [pages: CARDINAL] = {    Heap.Expand[Heap.systemZone, pages]};  SetOwner: PROC [node: LONG POINTER TO LONG STRING, owner: UNSPECIFIED] = INLINE {    p: LONG POINTER = node­; IF p # NIL THEN (p - 1)­ ¬ owner};  GetGF: PROC [p: PROGRAM] RETURNS [PrincOpsExtras2.GFTHandle] = INLINE {    RETURN[FrameExtras.LongGFToGFTHandle[      SpecialRuntimeExtras.GlobalFrameFromProgram[p]]]};  AppendChar: PUBLIC PROC [p: LONG POINTER TO LONG STRING, c: CHARACTER] =    BEGIN    s: STRING ¬ [2];    s[0] ¬ c;    s.length ¬ 1;    IF AppendStringLocal[p, s] AND ownerChecking THEN      SetOwner[p, GetGF[Runtime.GetCaller[]]];    END;  AppendStringLocal: PROC [    to: LONG POINTER TO LONG STRING, from: LONG STRING, extra: CARDINAL ¬ 0]    RETURNS [new: BOOLEAN] =    BEGIN    length: CARDINAL;    i: CARDINAL;    IF Storage.EmptyString[from] OR to = NIL THEN RETURN;    length ¬ from.length + Storage.StringLength[to­];    SELECT TRUE FROM      to­ = NIL => {to­ ¬ String[length]; new ¬ TRUE};      to.maxlength < length => {        temp: LONG STRING ¬ to­;        to­ ¬ CopyString[to­, length - to.length + extra];        FreeString[temp];        new ¬ TRUE};      ENDCASE => new ¬ FALSE;    FOR i IN [0..from.length) DO to[i + to.length] ¬ from[i] ENDLOOP;    to.length ¬ length;    RETURN    END;  AppendExtensionIfNeeded: PUBLIC PROC [    to: LONG POINTER TO LONG STRING, extension: LONG STRING]    RETURNS [done: BOOLEAN] =    BEGIN    i: CARDINAL;    done ¬ FALSE;    IF ~Storage.EmptyString[to­] THEN      BEGIN      FOR i DECREASING IN [1..to.length) DO        SELECT to­[i] FROM          '., Ascii.SP, Ascii.TAB => to.length ¬ to.length - 1;          ENDCASE => EXIT;        ENDLOOP;      FOR i DECREASING IN [0..to.length) DO        IF to­[i] = '. THEN EXIT;        REPEAT          FINISHED =>            BEGIN	    IF extension[0] # '. AND AppendStringLocal[to, "."L, extension.length]	      AND ownerChecking THEN SetOwner[to, GetGF[Runtime.GetCaller[]]];            IF AppendStringLocal[to, extension] AND ownerChecking THEN              SetOwner[to, GetGF[Runtime.GetCaller[]]];            done ¬ TRUE;            END;        ENDLOOP      END;    END;  AppendString: PUBLIC PROC [    to: LONG POINTER TO LONG STRING, from: LONG STRING, extra: CARDINAL ¬ 0] =    BEGIN    IF AppendStringLocal[to, from, extra] AND ownerChecking THEN      SetOwner[to, GetGF[Runtime.GetCaller[]]];    END;  Replace: PUBLIC PROC [to: LONG POINTER TO LONG STRING, from: LONG STRING] =    BEGIN    IF to = NIL THEN RETURN[];    IF to­ # NIL THEN to­ ¬ Storage.FreeStringNil[to­];    IF from # NIL THEN to­ ¬ CopyString[from];    IF ownerChecking THEN SetOwner[to, GetGF[Runtime.GetCaller[]]];    RETURN    END;  END.
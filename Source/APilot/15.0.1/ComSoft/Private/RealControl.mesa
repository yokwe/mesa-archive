-- Copyright (C) 1980, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- RealControl.mesa-- edited by Johnsson;  6-Sep-83 21:42:35-- Microcode to Mesa floating point translaterDIRECTORY  Frame USING [GetReturnFrame, ReadPC, WritePC],  ESCAlpha,  Ieee USING [aSETS, fpmode, InitIeee],  PrincOps USING [ESCTrapTable, LocalFrameHandle, StateVector],  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  Real USING [Exception],  RealFns USING [SqRt],  RealOps;RealControl: PROGRAM   IMPORTS Frame, Ieee, ProcessOperations, RealFns, RealOps  EXPORTS Real, RealOps =  BEGIN    Microcode: PUBLIC BOOLEAN ¬ FALSE;    microSticky: CARDINAL;  InitReals: PUBLIC PROC =    BEGIN    PrincOps.ESCTrapTable[ESCAlpha.aFADD] ¬ LOOPHOLE[TFAdd];    PrincOps.ESCTrapTable[ESCAlpha.aFSUB] ¬ LOOPHOLE[TFSub];    PrincOps.ESCTrapTable[ESCAlpha.aFMUL] ¬ LOOPHOLE[TFMul];    PrincOps.ESCTrapTable[ESCAlpha.aFDIV] ¬ LOOPHOLE[TFDiv];    PrincOps.ESCTrapTable[ESCAlpha.aFCOMP] ¬ LOOPHOLE[TFComp];    PrincOps.ESCTrapTable[ESCAlpha.aFIX] ¬ LOOPHOLE[TFix];    PrincOps.ESCTrapTable[ESCAlpha.aFLOAT] ¬ LOOPHOLE[TFloat];    PrincOps.ESCTrapTable[ESCAlpha.aFIXI] ¬ LOOPHOLE[TFixI];    PrincOps.ESCTrapTable[ESCAlpha.aFIXC] ¬ LOOPHOLE[TFixC];    PrincOps.ESCTrapTable[ESCAlpha.aFSTICKY] ¬ LOOPHOLE[TFSticky];    PrincOps.ESCTrapTable[ESCAlpha.aFREM] ¬ LOOPHOLE[TFRem];    PrincOps.ESCTrapTable[ESCAlpha.aROUND] ¬ LOOPHOLE[TRound];    PrincOps.ESCTrapTable[ESCAlpha.aROUNDI] ¬ LOOPHOLE[TRoundI];    PrincOps.ESCTrapTable[ESCAlpha.aROUNDC] ¬ LOOPHOLE[TRoundC];    PrincOps.ESCTrapTable[ESCAlpha.aFSQRT] ¬ LOOPHOLE[TFSqRt];    PrincOps.ESCTrapTable[Ieee.aSETS] ¬ LOOPHOLE[TSetS];    Ieee.InitIeee[];    END;  BumpPC: PROCEDURE [f: PrincOps.LocalFrameHandle] = INLINE {    Frame.WritePC[[Frame.ReadPC[f]+2], f]};    DI: PROCEDURE = INLINE {ProcessOperations.DisableInterrupts[]};    EI: PROCEDURE = INLINE {ProcessOperations.EnableInterrupts[]};    TFAdd: PROC [a, b: REAL] RETURNS [c: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.FAdd[a, b];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFSub: PROC [a, b: REAL] RETURNS [c: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.FSub[a, b];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFMul: PROC [a, b: REAL] RETURNS [c: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.FMul[a, b];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFDiv: PROC [a, b: REAL] RETURNS [c: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.FDiv[a, b];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFComp: PROC [a, b: REAL] RETURNS [i: INTEGER] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    i ¬ RealOps.FComp[a, b];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFix: PROC [a: REAL] RETURNS [li: LONG INTEGER] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    li ¬ RealOps.RoundLI[a, RealOps.FixMode];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFloat: PROC [a: LONG INTEGER] RETURNS [c: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.Float[a];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFixI: PROC [a: REAL] RETURNS [i: INTEGER] = {    state: PrincOps.StateVector.dst;    state¬ STATE;    i ¬ RealOps.RoundI[a, RealOps.FixMode];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFixC: PROC [a: REAL] RETURNS [c: CARDINAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.RoundC[a, RealOps.FixMode];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFSticky: PROC [c: CARDINAL] RETURNS [cr: CARDINAL] = {    state: RECORD[a: CARDINAL, s: PrincOps.StateVector.dst];    state.s ¬ STATE;    cr ¬ microSticky;    microSticky ¬ c;    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state.s};  TFRem: PROC [a, b: REAL] RETURNS [c: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.FRem[a, b];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TRound: PROC [a: REAL] RETURNS [li: LONG INTEGER] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    li ¬ RealOps.RoundLI[a];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TRoundI: PROC [a: REAL] RETURNS [i: INTEGER] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    i ¬ RealOps.RoundI[a];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TRoundC: PROC [a: REAL] RETURNS [c: CARDINAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    c ¬ RealOps.RoundC[a];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TFSqRt: PROC [a: REAL] RETURNS [b: REAL] = {    state: PrincOps.StateVector.dst;    state ¬ STATE;    b ¬ RealFns.SqRt[a];    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state};  TSetS: PROC [fpm: RealOps.Mode] = {    state: RECORD[a: CARDINAL, s: PrincOps.StateVector.dst];    i: Real.Exception;    state.s ¬ STATE;    FOR i IN Real.Exception DO      IF fpm.traps[i] THEN Ieee.fpmode.traps[i] ¬ TRUE; ENDLOOP;    BumpPC[Frame.GetReturnFrame[]];    STATE ¬ state.s};  -- Mainline code  InitReals[];  END.
-- Copyright (C) 1981, 1984  by Xerox Corporation. All rights reserved. -- MemoryStreamImpl.mesa (last edited by: AOF on:  4-Dec-81  8:11:22)-- Function: A memory stream used for (de)serialization of data.DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block],  Heap USING [systemZone],  Inline USING [LowHalf],  MemoryStream USING [],  Stream USING [Object, Byte, Handle, Word, SubSequenceType, CompletionCode,    InputOptions, Block, defaultObject, EndOfStream, Position];MemoryStreamImpl: PROGRAM  IMPORTS Stream, ByteBlt, Heap, Inline  EXPORTS MemoryStream =  BEGIN  -- types  LeftAndRight: TYPE = MACHINE DEPENDENT RECORD [left, right: Stream.Byte];  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    object: Stream.Object,    blockPointer: LONG POINTER,    block: LONG POINTER TO PACKED ARRAY OF Stream.Byte,    startIndex, stopIndexPlusOne: CARDINAL];  --error  IndexOutOfRange: PUBLIC ERROR = CODE;  -- procedures  Create: PUBLIC PROCEDURE [b: Environment.Block] RETURNS [sH: Stream.Handle] =    BEGIN    handle: Handle ¬ Heap.systemZone.NEW[Object ¬ [      object: Stream.defaultObject,      blockPointer: LOOPHOLE[b.blockPointer],      block: LOOPHOLE[b.blockPointer],      startIndex: b.startIndex,      stopIndexPlusOne: b.stopIndexPlusOne]];    handle.object.getByte ¬ GetByte;    handle.object.getWord ¬ GetWord;    handle.object.get ¬ GetBlock;    handle.object.putByte ¬ PutByte;    handle.object.putWord ¬ PutWord;    handle.object.put ¬ PutBlock;    handle.object.delete ¬ Destroy;    handle.object.getPosition ¬ GetIndex;    handle.object.setPosition ¬ SetIndex;    RETURN[LOOPHOLE[handle]];    END; -- Create  Destroy: PUBLIC PROCEDURE [sH: Stream.Handle] =    BEGIN    handle: Handle ¬ LOOPHOLE[sH, Handle];    Heap.systemZone.FREE[@handle];    END; -- Destroy  SetIndex: PUBLIC PROCEDURE [sH: Stream.Handle, position: Stream.Position] =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    IF Inline.LowHalf[position] <= handle.stopIndexPlusOne      THEN handle.startIndex ¬ Inline.LowHalf[position]      ELSE ERROR IndexOutOfRange;    END; -- SetIndex  GetIndex: PUBLIC PROCEDURE [sH: Stream.Handle] RETURNS[position: Stream.Position] =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    RETURN[LONG[handle.startIndex]];    END; -- GetIndex  GetByte: PROCEDURE [sH: Stream.Handle] RETURNS [byte: Stream.Byte] =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    IF handle.startIndex >= handle.stopIndexPlusOne      THEN SIGNAL Stream.EndOfStream[handle.startIndex]      ELSE {byte ¬ handle.block[handle.startIndex];        handle.startIndex ¬ handle.startIndex + 1};    END; -- GetByte  GetWord: PROCEDURE [sH: Stream.Handle] RETURNS [word: Stream.Word] =    BEGIN OPEN w: LOOPHOLE[word, LeftAndRight];    w.left ¬ GetByte[sH];    w.right ¬ GetByte[sH];    END; -- GetWord  GetBlock: PROCEDURE [    sH: Stream.Handle, block: Stream.Block, options: Stream.InputOptions]    RETURNS [      bytesTransferred: CARDINAL, why: Stream.CompletionCode,      sst: Stream.SubSequenceType] =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    input: Stream.Block ¬ [blockPointer: handle.blockPointer,        startIndex: handle.startIndex,        stopIndexPlusOne: handle.stopIndexPlusOne];    bytesTransferred ¬ ByteBlt.ByteBlt[block, input];    handle.startIndex ¬ handle.startIndex + bytesTransferred;    why ¬ IF bytesTransferred = block.stopIndexPlusOne - block.startIndex      THEN normal ELSE endOfStream;    sst ¬ 0;    END; -- GetBlock  PutByte: PROCEDURE [sH: Stream.Handle, byte: Stream.Byte] =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    IF handle.startIndex >= handle.stopIndexPlusOne      THEN SIGNAL Stream.EndOfStream[handle.startIndex]       ELSE {handle.block[handle.startIndex] ¬ byte;        handle.startIndex ¬ handle.startIndex + 1};    END; -- PutByte  PutWord: PROCEDURE [sH: Stream.Handle, word: Stream.Word] =    BEGIN OPEN w: LOOPHOLE[word, LeftAndRight];    PutByte[sH, w.left];    PutByte[sH, w.right];    END; -- PutWord  PutBlock: PROCEDURE [    sH: Stream.Handle, block: Stream.Block, endRecord: BOOLEAN ¬ FALSE] =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    bytesTransferred: CARDINAL;    output: Stream.Block ¬ [blockPointer: handle.blockPointer,        startIndex: handle.startIndex,        stopIndexPlusOne: handle.stopIndexPlusOne];    bytesTransferred ¬ ByteBlt.ByteBlt[output, block];    IF bytesTransferred # block.stopIndexPlusOne-block.startIndex      THEN ERROR IndexOutOfRange;    handle.startIndex ¬ handle.startIndex + bytesTransferred;    END; -- PutBlock  -- initialization   END. -- MemoryStremaImpl moduleLOGTime: February 11, 1981  9:35 AM  By: LXG      Action: created file.Time: February 17, 1981  1:15 AM  By: AOF  Action: butchered file.Time: February 27, 1981  10:54 AM  By: AOF  Action: butchered file again to MemoryStream.Time:  4-Dec-81  8:16:11  By: AOF  Action: Get stream object from z.NEW.
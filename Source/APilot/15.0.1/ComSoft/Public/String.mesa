-- String.Mesa  Last edited by -- RXJ      on  5-Dec-80 14:57:46-- LXR     on   29-Sep-82 17:26:59-- AXD    ,	29-Sep-82 14:15:26-- Copyright (C) Xerox Corporation 1982. All rights reserved.DIRECTORY  Environment USING [    bitsPerCharacter, charsPerPage, charsPerWord, logCharsPerPage];String: DEFINITIONS =  BEGIN  bitsPerCharacter: CARDINAL = Environment.bitsPerCharacter;  charsPerPage: CARDINAL = Environment.charsPerPage;  charsPerWord: CARDINAL = Environment.charsPerWord;  logCharsPerPage: CARDINAL = Environment.logCharsPerPage;  SubStringDescriptor: TYPE = RECORD [base: LONG STRING, offset, length: CARDINAL];  SubString: TYPE = LONG POINTER TO SubStringDescriptor;  Overflow: SIGNAL;  InvalidNumber: SIGNAL;  StringBoundsFault: SIGNAL [s: LONG STRING] RETURNS [ns: LONG STRING];  Length: PROCEDURE [s: LONG STRING] RETURNS [CARDINAL] = INLINE {    RETURN[IF s = NIL THEN 0 ELSE s.length]};      Empty: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] = INLINE {    RETURN[s = NIL OR s.length = 0]};  WordsForString: PROCEDURE [nchars: CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN[SIZE[StringBody[nchars]]]};  AppendChar: PROCEDURE [s: LONG STRING, c: CHARACTER];  AppendString: PROCEDURE [to: LONG STRING, from: LONG STRING];  Copy: PROCEDURE [to, from: LONG STRING];  Equal, Equivalent: PROCEDURE [s1, s2: LONG STRING]    RETURNS [BOOLEAN];  Compare: PROCEDURE [s1, s2: LONG STRING, ignoreCase: BOOLEAN ¬ TRUE]    RETURNS [INTEGER];  --  -1 => less, 0 => equal, 1 => greater      AppendSubString: PROCEDURE [to: LONG STRING, from: SubString];  EqualSubString, EquivalentSubString: PROCEDURE [s1, s2: SubString]    RETURNS [BOOLEAN];  DeleteSubString: PROCEDURE [s: SubString];  UpperCase, LowerCase: PROCEDURE [c: CHARACTER] RETURNS [CHARACTER];  -- routines for converting between strings and numbers  StringToNumber: PROCEDURE [s: LONG STRING, radix: CARDINAL ¬ 10]    RETURNS [UNSPECIFIED];  StringToDecimal: PROCEDURE [s: LONG STRING] RETURNS [INTEGER] = INLINE    BEGIN RETURN[StringToNumber[s, 10]] END;  StringToOctal: PROCEDURE [s: LONG STRING] RETURNS [UNSPECIFIED] = INLINE    BEGIN RETURN[StringToNumber[s, 8]]; END;  StringToLongNumber: PROCEDURE [s: LONG STRING, radix: CARDINAL ¬ 10]    RETURNS [LONG UNSPECIFIED];  AppendNumber: PROCEDURE [s: LONG STRING, n: UNSPECIFIED, radix: CARDINAL ¬ 10];  AppendDecimal: PROCEDURE [s: LONG STRING, n: INTEGER];  AppendOctal: PROCEDURE [s: LONG STRING, n: UNSPECIFIED];  AppendLongNumber: PROCEDURE [    s: LONG STRING, n: LONG UNSPECIFIED, radix: CARDINAL ¬ 10];  AppendLongDecimal: PROCEDURE [s: LONG STRING, n: LONG INTEGER];  -- routines invloving the allocation and deallocation of strings  MakeString: PROCEDURE [z: UNCOUNTED ZONE, maxlength: CARDINAL]    RETURNS [LONG STRING] = INLINE {RETURN[z.NEW[StringBody [maxlength]]]};  MakeMDSString: PROCEDURE [z: MDSZone, maxlength: CARDINAL] RETURNS [STRING] =    INLINE {RETURN[z.NEW[StringBody [maxlength]]]};  FreeString: PROCEDURE [z: UNCOUNTED ZONE, s: LONG STRING] = INLINE {z.FREE[@s]};  -- note this sets local s to NIL  FreeMDSString: PROCEDURE [z: MDSZone, s: STRING] = INLINE {z.FREE[@s]};  -- note this sets local s to NIL  AppendCharAndGrow: PROC [    to: LONG POINTER TO LONG STRING, c: CHARACTER, z: UNCOUNTED ZONE];  AppendExtensionIfNeeded: PROC [    to: LONG POINTER TO LONG STRING, extension: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [BOOLEAN];  AppendStringAndGrow: PROC [    to: LONG POINTER TO LONG STRING, from: LONG STRING, z: UNCOUNTED ZONE,    extra: CARDINAL ¬ 0];  Replace: PROC [    to: LONG POINTER TO LONG STRING, from: LONG STRING, z: UNCOUNTED ZONE];  CopyToNewString: PROCEDURE [    s: LONG STRING, z: UNCOUNTED ZONE, longer: CARDINAL ¬ 0]    RETURNS [newS: LONG STRING];  ExpandString: PROCEDURE [    s: LONG POINTER TO LONG STRING, longer: CARDINAL, z: UNCOUNTED ZONE];  -- These are kept for compatibility    StringLength: PROCEDURE [s: LONG STRING] RETURNS [CARDINAL] = INLINE {    RETURN[Length[s]]};  EmptyString: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] = INLINE {    RETURN[Empty[s]]};    EqualString, EqualStrings: PROCEDURE [s1, s2: LONG STRING] RETURNS [BOOLEAN] =    INLINE {RETURN[Equal[s1, s2]]};  EquivalentString, EquivalentStrings: PROCEDURE [s1, s2: LONG STRING]    RETURNS [BOOLEAN] = INLINE {RETURN[Equivalent[s1, s2]]};  CompareStrings: PROCEDURE [s1, s2: LONG STRING, ignoreCase: BOOLEAN ¬ TRUE]    RETURNS [INTEGER] = INLINE {RETURN[Compare[s1, s2, ignoreCase]]};  EqualSubStrings: PROCEDURE [s1, s2: SubString] RETURNS [BOOLEAN] = INLINE {    RETURN[EqualSubString[s1, s2]]};  EquivalentSubStrings: PROCEDURE [s1, s2: SubString] RETURNS [BOOLEAN] = INLINE {    RETURN[EquivalentSubString[s1, s2]]};  END.
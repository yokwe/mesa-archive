-- Copyright (C) Xerox Corporation 1982. All rights reserved.-- Floppy.mesa (last edited by: AWL       on: 24-Nov-82  8:46:48)DIRECTORY   File USING [File, maxPagesPerFile, PageCount, PageNumber, Type];Floppy: DEFINITIONS =BEGIN	-- File identifiersFileID: TYPE  = PRIVATE MACHINE DEPENDENT RECORD [a (0), b (1): WORD];nullFileID: FileID = [0, 0];FileHandle: TYPE = RECORD [volume: VolumeHandle, file: FileID];	-- Volume references	VolumeHandle: TYPE [2];nullVolumeHandle: READONLY VolumeHandle;	-- File addressing	PageNumber: TYPE = LONG CARDINAL;   firstPageCount: PageNumber = 0;   lastPageCount: PageNumber = File.maxPagesPerFile;PageCount: TYPE = PageNumber;defaultPageCount: PageNumber = LAST[PageNumber];	-- Volume operationsFormat: PROCEDURE [   drive: CARDINAL, maxNumberOfFileListEntries: CARDINAL, labelString: LONG STRING,   density: Density ¬ default, sides: Sides ¬ default];maxCharactersInLabel: CARDINAL = 40;Density: TYPE = {single, double, default};Sides: TYPE = {one, two, default};Open: PROCEDURE [drive: CARDINAL ¬ 0] RETURNS [volume: VolumeHandle];Close: PROCEDURE [volume: VolumeHandle];GetAttributes: PROCEDURE [volume: VolumeHandle, labelString: LONG STRING]   RETURNS [     freeSpace: PageCount, largestBlock: PageCount, fileList: FileHandle,     rootFile: FileHandle, density: Density[single..double],     sides: Sides[one..two], maxFileListEntries: CARDINAL];Compact: PROCEDURE [volume: VolumeHandle];Scavenge: PROCEDURE [volume: VolumeHandle] RETURNS [numberOfBadSectors: PageCount];GetNextBadSector: PROCEDURE [volume: VolumeHandle, oldIndex: CARDINAL]   RETURNS [newIndex: CARDINAL, file: FileHandle, page: PageNumber];nullIndex: CARDINAL = LAST[CARDINAL];SetRootFile: PROCEDURE [file: FileHandle];	-- File operationsCreateFile: PROCEDURE [volume: VolumeHandle, size: PageCount, type:File.Type]   RETURNS [file: FileHandle];DeleteFile: PROCEDURE [file: FileHandle];Read: PROCEDURE [  file: FileHandle, first: PageNumber, count: PageCount, vm: LONG POINTER];Write: PROCEDURE [  file: FileHandle, first: PageNumber, count: PageCount, vm: LONG POINTER];CopyToPilotFile: PROCEDURE [  floppyFile: FileHandle, pilotFile: File.File, firstFloppyPage: PageNumber,  firstPilotPage: File.PageNumber, count: PageCount ¬ defaultPageCount];CopyFromPilotFile: PROCEDURE [  pilotFile: File.File, floppyFile: FileHandle, firstPilotPage: File.PageNumber,  firstFloppyPage: PageNumber, count: PageCount ¬ defaultPageCount];ReplaceBadSector: PROCEDURE [  file: FileHandle, page: PageNumber] RETURNS [readError: BOOLEAN];GetFileAttributes: PROCEDURE [  file: FileHandle] RETURNS [size: PageCount, type: File.Type];GetNextFile: PROCEDURE [previousFile: FileHandle] RETURNS [nextFile: FileHandle];      -- Bootable floppiesCreateInitialMicrocodeFile: PROCEDURE [   volume: VolumeHandle, size: PageCount, type: File.Type,   startingPageNumber: PageNumber ¬ 1]   RETURNS [file: FileHandle];SetBootFiles: PROCEDURE [   volume: VolumeHandle,   pilotMicrocode, diagnosticMicrocode, germ, pilotBootFile: BootFilePointer      ¬ nullBootFilePointer];GetBootFiles: PROCEDURE [volume: VolumeHandle]   RETURNS [      initialMicrocode, pilotMicrocode, diagnosticMicrocode, germ,        pilotBootFile: BootFilePointer];BootFilePointer: TYPE = RECORD [file: FileID, page: PageNumber];nullBootFilePointer: BootFilePointer = [nullFileID, 0];      -- Floppy ImagesMakeImage: PROCEDURE [  floppyDrive: CARDINAL ¬ 0, imageFile: File.File,  firstImagePage: File.PageNumber];CreateFloppyFromImage: PROCEDURE [  floppyDrive: CARDINAL ¬ 0, imageFile: File.File, firstImagePage: File.PageNumber,  reformatFloppy: BOOLEAN, floppyDensity: Density ¬ default,  floppySides: Sides ¬ default, numberOfFiles: CARDINAL ¬ 0,  newLabelString: LONG STRING ¬ NIL];PagesForImage: PROCEDURE [floppyDrive: CARDINAL ¬ 0] RETURNS [File.PageCount];GetImageAttributes: PROCEDURE [  imageFile: File.File, firstImagePage: File.PageNumber, name: LONG STRING ¬ NIL]  RETURNS [    maxNumberOfFiles: CARDINAL, currentNumberOfFiles: CARDINAL,    density: Density[single..double], sides: Sides[one..two]];      -- Signals and errorsError: ERROR [error: ErrorType];ErrorType: TYPE =   {badDisk, badSectors, endOfFile, fileListFull, fileNotFound, hardwareError,    incompatibleSizes,  invalidFormat, invalidPageNumber,    invalidVolumeHandle, insufficientSpace, needsScavenging, noSuchDrive, notReady,    onlyOneSide, onlySingleDensity, initialMicrocodeSpaceNotAvailable,    stringTooShort, volumeNotOpen, writeInhibited, zeroSizeFile,    fileListLengthTooShort, floppyImageInvalid, floppySpaceTooSmall};DataError: ERROR [file: FileHandle, page: PageNumber, vm: LONG POINTER];AlreadyFormatted: SIGNAL [labelString: LONG STRING];END.LOG31-Jul-81 20:28:00	AWL        Created file2-Nov-81 14:28:00	LXD        Added ErrorTypes invalidPageNumber, zeroSizeFile17-Nov-81 9:58:00		LXD        Added parameters to CopyToPilotFile, CopyFromPilotFile30-Nov-81  9:30:41	LXD        Deleted ErrorType invalidBootFile24-Nov-82  8:46:43	AWL        Added result maxFileListEntries to GetAttributes; added procedures MakeImage, CreateFloppyFromImage, PagesForImage and GetImageAttributes; added fileListLengthTooShort, floppyImageInvalid and floppySpaceTooSmall to ErrorType.